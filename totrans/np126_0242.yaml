- en: Standard array subclasses
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 标准数组子类
- en: 原文：[https://numpy.org/doc/1.26/reference/arrays.classes.html](https://numpy.org/doc/1.26/reference/arrays.classes.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://numpy.org/doc/1.26/reference/arrays.classes.html](https://numpy.org/doc/1.26/reference/arrays.classes.html)
- en: Note
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Subclassing a `numpy.ndarray` is possible but if your goal is to create an array
    with *modified* behavior, as do dask arrays for distributed computation and cupy
    arrays for GPU-based computation, subclassing is discouraged. Instead, using numpy’s
    [dispatch mechanism](../user/basics.dispatch.html#basics-dispatch) is recommended.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: numpy.ndarray 的子类化是可能的，但如果您的目标是创建具有*修改*行为的数组，如用于分布式计算的 Dask 数组和用于基于 GPU 的计算的
    CuPy 数组，不建议子类化。相反，推荐使用 numpy 的[调度机制](../user/basics.dispatch.html#basics-dispatch)。
- en: The [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")
    can be inherited from (in Python or in C) if desired. Therefore, it can form a
    foundation for many useful classes. Often whether to sub-class the array object
    or to simply use the core array component as an internal part of a new class is
    a difficult decision, and can be simply a matter of choice. NumPy has several
    tools for simplifying how your new object interacts with other array objects,
    and so the choice may not be significant in the end. One way to simplify the question
    is by asking yourself if the object you are interested in can be replaced as a
    single array or does it really require two or more arrays at its core.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 可以继承 [ndarray](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")（在
    Python 或 C 中）。因此，它可以成为许多有用类的基础。通常，是子类化数组对象还是只是将核心数组组件作为新类的内部部分的决定是一个困难的决定，只是一种选择。NumPy
    有几种工具可简化新对象与其他数组对象的交互方式，因此最终选择可能并不重要。简化问题的一种方式是问自己您感兴趣的对象是否可以被单个数组替换或者是否它的核心真的需要两个或更多数组。
- en: Note that [`asarray`](generated/numpy.asarray.html#numpy.asarray "numpy.asarray")
    always returns the base-class ndarray. If you are confident that your use of the
    array object can handle any subclass of an ndarray, then [`asanyarray`](generated/numpy.asanyarray.html#numpy.asanyarray
    "numpy.asanyarray") can be used to allow subclasses to propagate more cleanly
    through your subroutine. In principal a subclass could redefine any aspect of
    the array and therefore, under strict guidelines, [`asanyarray`](generated/numpy.asanyarray.html#numpy.asanyarray
    "numpy.asanyarray") would rarely be useful. However, most subclasses of the array
    object will not redefine certain aspects of the array object such as the buffer
    interface, or the attributes of the array. One important example, however, of
    why your subroutine may not be able to handle an arbitrary subclass of an array
    is that matrices redefine the “*” operator to be matrix-multiplication, rather
    than element-by-element multiplication.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`asarray`](generated/numpy.asarray.html#numpy.asarray "numpy.asarray")
    总是返回基类 ndarray。如果您确信您对数组对象的使用可以处理 ndarray 的任何子类，那么 [`asanyarray`](generated/numpy.asanyarray.html#numpy.asanyarray
    "numpy.asanyarray") 可以用于允许子类更清晰地传播到您的子例程中。在原则上，子类可以重新定义数组的任何方面，因此，在严格的指导方针下，[`asanyarray`](generated/numpy.asanyarray.html#numpy.asanyarray
    "numpy.asanyarray") 很少有用。但是，数组对象的大多数子类不会重新定义数组对象的某些方面，如缓冲区接口或数组的属性。然而，您的子例程可能无法处理数组的任意子类的一个重要示例是矩阵将“*”操作符重新定义为矩阵乘法，而不是逐元素乘法。
- en: '## Special attributes and methods'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## 特殊属性和方法'
- en: See also
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Subclassing ndarray](../user/basics.subclassing.html#basics-subclassing)'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[作为 ndarray 的子类](../user/basics.subclassing.html#basics-subclassing)'
- en: 'NumPy provides several hooks that classes can customize:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了几个类可以自定义的钩子：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: New in version 1.13.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.13 新功能。
- en: Any class, ndarray subclass or not, can define this method or set it to None
    in order to override the behavior of NumPy’s ufuncs. This works quite similarly
    to Python’s `__mul__` and other binary operation routines.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类、ndarray 子类或非子类都可以定义此方法或将其设置为 None 以覆盖 NumPy 的 ufunc 的行为。这与 Python 的 `__mul__`
    和其他二进制操作例程的工作方式相似。
- en: '*ufunc* is the ufunc object that was called.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ufunc* 是调用的 ufunc 对象。'
- en: '*method* is a string indicating which Ufunc method was called (one of `"__call__"`,
    `"reduce"`, `"reduceat"`, `"accumulate"`, `"outer"`, `"inner"`).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*method* 是指调用了哪个 Ufunc 方法的字符串（`"__call__"`、`"reduce"`、`"reduceat"`、`"accumulate"`、`"outer"`、`"inner"`之一）。'
- en: '*inputs* is a tuple of the input arguments to the `ufunc`.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*inputs* 是 `ufunc` 的输入参数的元组。'
- en: '*kwargs* is a dictionary containing the optional input arguments of the ufunc.
    If given, any `out` arguments, both positional and keyword, are passed as a [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple
    "(in Python v3.11)") in *kwargs*. See the discussion in [Universal functions (ufunc)](ufuncs.html#ufuncs)
    for details.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*kwargs*是一个包含ufunc的可选输入参数的字典。如果提供，任何`out`参数，无论是位置参数还是关键字参数，都作为[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple
    "(在Python v3.11)")传递给*kwargs*。有关详细信息，请参阅[通用函数(ufunc)](ufuncs.html#ufuncs)中的讨论。'
- en: The method should return either the result of the operation, or [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)") if the operation requested is not implemented.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法应该返回操作的结果，或者如果请求的操作未实现，则返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(在Python v3.11)")。
- en: 'If one of the input, output, or `where` arguments has a [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__") method, it is executed *instead* of the ufunc.
    If more than one of the arguments implements [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__"), they are tried in the order: subclasses before
    superclasses, inputs before outputs, outputs before `where`, otherwise left to
    right. The first routine returning something other than [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)") determines the result. If all of the [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__") operations return [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)"), a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)") is raised.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入、输出或`where`参数中的一个具有[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")方法，那么将*执行*该方法而不是ufunc。如果多个参数实现了[`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__")，则按照以下顺序尝试：子类优先于超类，输入优先于输出，输出优先于`where`，否则从左到右。第一个返回不是[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(在Python v3.11)")的例程确定结果。如果所有的[`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__")操作都返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(在Python v3.11)")，则会引发[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(在Python v3.11)")。
- en: Note
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We intend to re-implement numpy functions as (generalized) Ufunc, in which case
    it will become possible for them to be overridden by the `__array_ufunc__` method.
    A prime candidate is [`matmul`](generated/numpy.matmul.html#numpy.matmul "numpy.matmul"),
    which currently is not a Ufunc, but could be relatively easily be rewritten as
    a (set of) generalized Ufuncs. The same may happen with functions such as [`median`](generated/numpy.median.html#numpy.median
    "numpy.median"), [`amin`](generated/numpy.amin.html#numpy.amin "numpy.amin"),
    and [`argsort`](generated/numpy.argsort.html#numpy.argsort "numpy.argsort").
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算将numpy函数重新实现为（广义的）Ufunc，这样它们就可以被`__array_ufunc__`方法覆盖。一个主要的候选者是[`matmul`](generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul")，它目前不是一个Ufunc，但可以相对容易地重写为（一组）广义Ufuncs。与[`median`](generated/numpy.median.html#numpy.median
    "numpy.median")、[`amin`](generated/numpy.amin.html#numpy.amin "numpy.amin")和[`argsort`](generated/numpy.argsort.html#numpy.argsort
    "numpy.argsort")等功能可能发生相同的情况。
- en: Like with some other special methods in python, such as `__hash__` and `__iter__`,
    it is possible to indicate that your class does *not* support ufuncs by setting
    `__array_ufunc__ = None`. Ufuncs always raise [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)") when called on an object that sets `__array_ufunc__ = None`.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他在Python中的一些特殊方法，如`__hash__`和`__iter__`一样，您可以通过设置`__array_ufunc__ = None`来指示您的类**不**支持ufuncs。当调用在设置了`__array_ufunc__
    = None`的对象上时，ufuncs总是会引发[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(在Python v3.11)")。
- en: The presence of [`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")
    also influences how [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")
    handles binary operations like `arr + obj` and `arr < obj` when `arr` is an [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") and `obj` is an instance of a custom class. There are two possibilities.
    If `obj.__array_ufunc__` is present and not None, then `ndarray.__add__` and friends
    will delegate to the ufunc machinery, meaning that `arr + obj` becomes `np.add(arr,
    obj)`, and then [`add`](generated/numpy.add.html#numpy.add "numpy.add") invokes
    `obj.__array_ufunc__`. This is useful if you want to define an object that acts
    like an array.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")的存在还会影响当`arr`是一个[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")而`obj`是自定义类的实例时，[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")如何处理`arr + obj`和`arr < obj`等二元操作。有两种可能性。如果`obj.__array_ufunc__`存在且不为`None`，那么`ndarray.__add__`等方法将委托给ufunc机制，意味着`arr
    + obj`变成了`np.add(arr, obj)`，然后[`add`](generated/numpy.add.html#numpy.add "numpy.add")调用`obj.__array_ufunc__`。如果你想定义一个像数组一样的对象，这非常有用。'
- en: 'Alternatively, if `obj.__array_ufunc__` is set to None, then as a special case,
    special methods like `ndarray.__add__` will notice this and *unconditionally*
    raise [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)"). This is useful if you want to create objects that interact
    with arrays via binary operations, but are not themselves arrays. For example,
    a units handling system might have an object `m` representing the “meters” unit,
    and want to support the syntax `arr * m` to represent that the array has units
    of “meters”, but not want to otherwise interact with arrays via ufuncs or otherwise.
    This can be done by setting `__array_ufunc__ = None` and defining `__mul__` and
    `__rmul__` methods. (Note that this means that writing an `__array_ufunc__` that
    always returns [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)") is not quite the same as setting `__array_ufunc__ = None`:
    in the former case, `arr + obj` will raise [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)"), while in the latter case it is possible to define a `__radd__`
    method to prevent this.)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果`obj.__array_ufunc__`被设置为`None`，那么作为特殊情况，像`ndarray.__add__`这样的特殊方法会注意到这一点，并*无条件地*引发[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)")。这在你想要创建通过二元操作与数组交互但本身不是数组的对象时很有用。例如，一个处理单位的系统可能有一个代表“米”单位的对象`m`，并且想要支持语法`arr
    * m`以表示数组具有“米”单位，但不希望通过ufunc或其他方式与数组交互。可以通过设置`__array_ufunc__ = None`并定义`__mul__`和`__rmul__`方法来实现这一点。（请注意，这意味着编写一个始终返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)")的`__array_ufunc__`与设置`__array_ufunc__ = None`不完全相同：在前一种情况下，`arr
    + obj`将引发[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)")，而在后一种情况下，可以定义一个`__radd__`方法来防止这种情况发生。）
- en: The above does not hold for in-place operators, for which [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") never returns [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)"). Hence, `arr += obj` would always lead to a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)"). This is because for arrays in-place operations cannot generically
    be replaced by a simple reverse operation. (For instance, by default, `arr +=
    obj` would be translated to `arr = arr + obj`, i.e., `arr` would be replaced,
    contrary to what is expected for in-place array operations.)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 对于就地操作，[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")不会返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)")，因此`arr += obj`总是会导致[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)")。这是因为对于数组来说，就地操作通常无法简单地替换为一个简单的反向操作。（例如，默认情况下，`arr += obj`将被转换为`arr
    = arr + obj`，即`arr`将被替换，与期望的就地数组操作相反。）
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you define `__array_ufunc__`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了`__array_ufunc__`：
- en: If you are not a subclass of [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"), we recommend your class define special methods like `__add__`
    and `__lt__` that delegate to ufuncs just like ndarray does. An easy way to do
    this is to subclass from [`NDArrayOperatorsMixin`](generated/numpy.lib.mixins.NDArrayOperatorsMixin.html#numpy.lib.mixins.NDArrayOperatorsMixin
    "numpy.lib.mixins.NDArrayOperatorsMixin").
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不是[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")的子类，我们建议你的类定义特殊方法如`__add__`和`__lt__`，并像`ndarray`一样委托给ufuncs。一个简单的方法是从[`NDArrayOperatorsMixin`](generated/numpy.lib.mixins.NDArrayOperatorsMixin.html#numpy.lib.mixins.NDArrayOperatorsMixin
    "numpy.lib.mixins.NDArrayOperatorsMixin")继承。
- en: If you subclass [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray"),
    we recommend that you put all your override logic in `__array_ufunc__` and not
    also override special methods. This ensures the class hierarchy is determined
    in only one place rather than separately by the ufunc machinery and by the binary
    operation rules (which gives preference to special methods of subclasses; the
    alternative way to enforce a one-place only hierarchy, of setting [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__") to None, would seem very unexpected and thus confusing,
    as then the subclass would not work at all with ufuncs).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你是[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")的子类，我们建议你将所有的重载逻辑放在`__array_ufunc__`中，而不是同时重载特殊方法。这确保了类层次结构只在一个地方被确定，而不是由ufunc机制和二进制操作规则分别确定（后者优先考虑子类的特殊方法；确保层次结构只在一个地方被确定的替代方法是将[`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__")设置为`None`，这可能看起来很意外并令人困惑，因为这样子类将完全无法与ufuncs一起使用）。
- en: '[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray") defines
    its own [`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__"),
    which, evaluates the ufunc if no arguments have overrides, and returns [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)") otherwise. This may be useful for subclasses for which [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__") converts any instances of its own class to [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"): it can then pass these on to its superclass using `super().__array_ufunc__(*inputs,
    **kwargs)`, and finally return the results after possible back-conversion. The
    advantage of this practice is that it ensures that it is possible to have a hierarchy
    of subclasses that extend the behaviour. See [Subclassing ndarray](../user/basics.subclassing.html#basics-subclassing)
    for details.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")定义了自己的[`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__")方法，如果没有参数被重载，则评估ufunc，并且否则返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)")。这对于生成将自身类的任何实例转换为[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")的子类可能有用：然后可以使用`super().__array_ufunc__(*inputs, **kwargs)`将这些传递给其超类，最终在可能的反向转换后返回结果。这种做法的优点在于确保能够拥有一个扩展行为的子类层次结构。请参阅[ndarray的子类化](../user/basics.subclassing.html#basics-subclassing)了解详情。'
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If a class defines the [`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")
    method, this disables the [`__array_wrap__`](#numpy.class.__array_wrap__ "numpy.class.__array_wrap__"),
    [`__array_prepare__`](#numpy.class.__array_prepare__ "numpy.class.__array_prepare__"),
    [`__array_priority__`](#numpy.class.__array_priority__ "numpy.class.__array_priority__")
    mechanism described below for ufuncs (which may eventually be deprecated).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类定义了[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")方法，这将禁用ufuncs的[`__array_wrap__`](#numpy.class.__array_wrap__
    "numpy.class.__array_wrap__")、[`__array_prepare__`](#numpy.class.__array_prepare__
    "numpy.class.__array_prepare__")、和[`__array_priority__`](#numpy.class.__array_priority__
    "numpy.class.__array_priority__")机制（这些机制可能最终被弃用）。
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: New in version 1.16.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.16版中新增。
- en: '`func` is an arbitrary callable exposed by NumPy’s public API, which was called
    in the form `func(*args, **kwargs)`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`是NumPy公共API中暴露的任意可调用对象，以`func(*args, **kwargs)`的形式调用。'
- en: '`types` is a collection [`collections.abc.Collection`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Collection
    "(in Python v3.11)") of unique argument types from the original NumPy function
    call that implement `__array_function__`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`types`是原始NumPy函数调用中实现`__array_function__`的唯一参数类型的集合[`collections.abc.Collection`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Collection
    "(in Python v3.11)")。'
- en: The tuple `args` and dict `kwargs` are directly passed on from the original
    call.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组`args`和字典`kwargs`直接从原始调用中传递。
- en: As a convenience for `__array_function__` implementors, `types` provides all
    argument types with an `'__array_function__'` attribute. This allows implementors
    to quickly identify cases where they should defer to `__array_function__` implementations
    on other arguments. Implementations should not rely on the iteration order of
    `types`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 作为`__array_function__`实现者的便利，`types`提供了所有参数类型的`'__array_function__'`属性。这使得实现者能够快速识别出应该将其他参数的处理委托给`__array_function__`实现的情况。实现不应依赖于`types`的迭代顺序。
- en: 'Most implementations of `__array_function__` will start with two checks:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`__array_function__`的实现将以两个检查开始：
- en: Is the given function something that we know how to overload?
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定的函数是否是我们知道如何重载的？
- en: Are all arguments of a type that we know how to handle?
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有的参数都是我们知道如何处理的类型吗？
- en: If these conditions hold, `__array_function__` should return the result from
    calling its implementation for `func(*args, **kwargs)`. Otherwise, it should return
    the sentinel value `NotImplemented`, indicating that the function is not implemented
    by these types.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足这些条件，`__array_function__`应该返回调用其实现函数`func(*args, **kwargs)`的结果。否则，应该返回标记值`NotImplemented`，表示这些类型未实现该函数。
- en: There are no general requirements on the return value from `__array_function__`,
    although most sensible implementations should probably return array(s) with the
    same type as one of the function’s arguments.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`__array_function__`的返回值，没有一般性要求，尽管大多数明智的实现应该返回与函数一个参数类型相同的数组。
- en: It may also be convenient to define a custom decorators (`implements` below)
    for registering `__array_function__` implementations.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以方便地定义自定义装饰器（如下所示的`implements`）来注册`__array_function__`的实现。
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that it is not required for `__array_function__` implementations to include
    *all* of the corresponding NumPy function’s optional arguments (e.g., `broadcast_to`
    above omits the irrelevant `subok` argument). Optional arguments are only passed
    in to `__array_function__` if they were explicitly used in the NumPy function
    call.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`__array_function__`的实现不需要包含*所有*对应的NumPy函数的可选参数（例如，上面的`broadcast_to`省略了无关的`subok`参数）。只有在NumPy函数调用中明确使用了可选参数时，才会将可选参数传递给`__array_function__`。
- en: Just like the case for builtin special methods like `__add__`, properly written
    `__array_function__` methods should always return `NotImplemented` when an unknown
    type is encountered. Otherwise, it will be impossible to correctly override NumPy
    functions from another object if the operation also includes one of your objects.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 就像内置特殊方法`__add__`的情况一样，正确编写的`__array_function__`方法在遇到未知类型时应该始终返回`NotImplemented`。否则，如果操作还包括您的对象之一，则无法正确地覆盖另一个对象的NumPy函数。
- en: 'For the most part, the rules for dispatch with `__array_function__` match those
    for `__array_ufunc__`. In particular:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，与`__array_ufunc__`的调度规则匹配的是`__array_function__`。特别是：
- en: 'NumPy will gather implementations of `__array_function__` from all specified
    inputs and call them in order: subclasses before superclasses, and otherwise left
    to right. Note that in some edge cases involving subclasses, this differs slightly
    from the [current behavior](https://bugs.python.org/issue30140) of Python.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy将从所有指定的输入中收集`__array_function__`的实现，并按顺序调用它们：子类优先于超类，否则从左到右。请注意，在涉及子类的某些边缘情况下，这与Python的[当前行为](https://bugs.python.org/issue30140)略有不同。
- en: Implementations of `__array_function__` indicate that they can handle the operation
    by returning any value other than `NotImplemented`.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__array_function__`的实现指示它们可以处理操作，方法是返回任何值，而不是`NotImplemented`。'
- en: If all `__array_function__` methods return `NotImplemented`, NumPy will raise
    `TypeError`.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有的`__array_function__`方法都返回`NotImplemented`，NumPy将引发`TypeError`。
- en: If no `__array_function__` methods exists, NumPy will default to calling its
    own implementation, intended for use on NumPy arrays. This case arises, for example,
    when all array-like arguments are Python numbers or lists. (NumPy arrays do have
    a `__array_function__` method, given below, but it always returns `NotImplemented`
    if any argument other than a NumPy array subclass implements `__array_function__`.)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不存在`__array_function__`方法，NumPy将默认调用其自己的实现，用于NumPy数组。例如，当所有类似数组的参数都是Python数字或列表时，会出现这种情况。（NumPy数组确实有一个`__array_function__`方法，如下所示，但如果除了NumPy数组子类之外的任何参数都实现了`__array_function__`，它将始终返回`NotImplemented`。）
- en: One deviation from the current behavior of `__array_ufunc__` is that NumPy will
    only call `__array_function__` on the *first* argument of each unique type. This
    matches Python’s [rule for calling reflected methods](https://docs.python.org/3/reference/datamodel.html#object.__ror__),
    and this ensures that checking overloads has acceptable performance even when
    there are a large number of overloaded arguments.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 与`__array_ufunc__`当前行为的一个偏差是，NumPy仅会在每种唯一类型的第一个参数上调用`__array_function__`。这符合Python的[调用反射方法的规则](https://docs.python.org/3/reference/datamodel.html#object.__ror__)，这确保了在存在大量重载参数时检查重载的性能是可接受的。
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method is called whenever the system internally allocates a new array from
    *obj*, where *obj* is a subclass (subtype) of the [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"). It can be used to change attributes of *self* after construction
    (so as to ensure a 2-d matrix for example), or to update meta-information from
    the “parent.” Subclasses inherit a default implementation of this method that
    does nothing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统从*obj*（*obj*是[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")的子类（子类型））内部分配新数组时，将调用此方法。它可用于在构造后更改*self*的属性（例如，以确保2维矩阵），或者从“父级”更新元信息。子类继承了此方法的默认实现，什么也不做。
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: At the beginning of every [ufunc](../user/basics.ufuncs.html#ufuncs-output-type),
    this method is called on the input object with the highest array priority, or
    the output object if one was specified. The output array is passed in and whatever
    is returned is passed to the ufunc. Subclasses inherit a default implementation
    of this method which simply returns the output array unmodified. Subclasses may
    opt to use this method to transform the output array into an instance of the subclass
    and update metadata before returning the array to the ufunc for computation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个[ufunc](../user/basics.ufuncs.html#ufuncs-output-type)的开头，会调用此方法来处理具有最高数组优先级的输入对象，或者指定的输出对象。输出数组被传递，而返回的任何内容都会传递给ufunc。子类继承了此方法的默认实现，简单地返回未修改的输出数组。子类可以选择使用此方法将输出数组转换为子类的实例并在将数组返回给ufunc进行计算之前更新元数据。
- en: Note
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: For ufuncs, it is hoped to eventually deprecate this method in favour of [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__").
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ufunc，希望最终弃用此方法，而转而使用[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")。
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At the end of every [ufunc](../user/basics.ufuncs.html#ufuncs-output-type),
    this method is called on the input object with the highest array priority, or
    the output object if one was specified. The ufunc-computed array is passed in
    and whatever is returned is passed to the user. Subclasses inherit a default implementation
    of this method, which transforms the array into a new instance of the object’s
    class. Subclasses may opt to use this method to transform the output array into
    an instance of the subclass and update metadata before returning the array to
    the user.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个[ufunc](../user/basics.ufuncs.html#ufuncs-output-type)的结尾，会调用此方法来处理具有最高数组优先级的输入对象，或者指定的输出对象。ufunc
    计算得到的数组被传递，而返回的任何内容都会传递给用户。子类继承了此方法的默认实现，将数组转换为对象类的新实例。子类可以选择使用此方法将输出数组转换为子类的实例并在返回数组给用户之前更新元数据。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: For ufuncs, it is hoped to eventually deprecate this method in favour of [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__").
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ufunc，希望最终弃用此方法，而转而使用[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")。
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The value of this attribute is used to determine what type of object to return
    in situations where there is more than one possibility for the Python type of
    the returned object. Subclasses inherit a default value of 0.0 for this attribute.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性的值用于确定在返回对象的Python类型有多于一个可能性的情况下返回什么类型的对象。子类继承了此属性的默认值为0.0。
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: For ufuncs, it is hoped to eventually deprecate this method in favour of [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__").
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ufunc，希望最终弃用此方法，而转而使用[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")。
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If a class (ndarray subclass or not) having the [`__array__`](#numpy.class.__array__
    "numpy.class.__array__") method is used as the output object of an [ufunc](../user/basics.ufuncs.html#ufuncs-output-type),
    results will *not* be written to the object returned by [`__array__`](#numpy.class.__array__
    "numpy.class.__array__"). This practice will return `TypeError`.  ## Matrix objects'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '如果一个类（不管是 ndarray 子类还是其他）具有 [`__array__`](#numpy.class.__array__ "numpy.class.__array__")
    方法，被用作 [ufunc](../user/basics.ufuncs.html#ufuncs-output-type) 的输出对象时，结果将不会被写入由
    [`__array__`](#numpy.class.__array__ "numpy.class.__array__") 返回的对象。这种做法会返回`TypeError`。  ##
    矩阵对象'
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is strongly advised *not* to use the matrix subclass. As described below,
    it makes writing functions that deal consistently with matrices and regular arrays
    very difficult. Currently, they are mainly used for interacting with `scipy.sparse`.
    We hope to provide an alternative for this use, however, and eventually remove
    the `matrix` subclass.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议*不*使用矩阵子类。如下所述，这使得编写函数，以一致地处理矩阵和常规数组变得非常困难。目前，它们主要用于与`scipy.sparse`的交互。然而，我们希望为这种用法提供一种替代方案，并最终移除`matrix`子类。
- en: '[`matrix`](generated/numpy.matrix.html#numpy.matrix "numpy.matrix") objects
    inherit from the ndarray and therefore, they have the same attributes and methods
    of ndarrays. There are six important differences of matrix objects, however, that
    may lead to unexpected results when you use matrices but expect them to act like
    arrays:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[`matrix`](generated/numpy.matrix.html#numpy.matrix "numpy.matrix") 对象继承自 ndarray，因此它们具有与
    ndarrays 相同的属性和方法。但是，matrix 对象有六个重要的不同之处，这可能会导致意外的结果，当你使用矩阵时，但期望它们的行为像数组:'
- en: Matrix objects can be created using a string notation to allow Matlab-style
    syntax where spaces separate columns and semicolons (‘;’) separate rows.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用字符串表示法创建矩阵对象，这样可以使用 Matlab 风格的语法，空格分隔列，分号（‘;’）分隔行。
- en: Matrix objects are always two-dimensional. This has far-reaching implications,
    in that m.ravel() is still two-dimensional (with a 1 in the first dimension) and
    item selection returns two-dimensional objects so that sequence behavior is fundamentally
    different than arrays.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵对象始终是二维的。这有着深远的意义，因为 m.ravel() 仍然是二维的（在第一维有一个1），并且条目选择返回二维对象，因此序列行为与数组根本不同。
- en: Matrix objects over-ride multiplication to be matrix-multiplication. **Make
    sure you understand this for functions that you may want to receive matrices.
    Especially in light of the fact that asanyarray(m) returns a matrix when m is
    a matrix.**
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵对象覆盖了乘法，成为矩阵乘法。**务必要理解这一点，特别是在你希望接受矩阵的函数中。尤其要注意的是，当 m 是一个矩阵时，asanyarray(m)
    会返回一个矩阵。**
- en: Matrix objects over-ride power to be matrix raised to a power. The same warning
    about using power inside a function that uses asanyarray(…) to get an array object
    holds for this fact.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵对象覆盖了幂运算，成为矩阵的幂。对于使用 asanyarray(…) 获取数组对象的函数中使用幂运算的相同警告，也适用于这一事实。
- en: The default __array_priority__ of matrix objects is 10.0, and therefore mixed
    operations with ndarrays always produce matrices.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵对象的默认 __array_priority__ 是 10.0，因此与 ndarrays 的混合操作始终产生矩阵。
- en: Matrices have special attributes which make calculations easier. These are
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵具有使计算更简单的特殊属性。这些属性是
- en: '| [`matrix.T`](generated/numpy.matrix.T.html#numpy.matrix.T "numpy.matrix.T")
    | Returns the transpose of the matrix. |'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`matrix.T`](generated/numpy.matrix.T.html#numpy.matrix.T "numpy.matrix.T")
    | 返回矩阵的转置。'
- en: '| [`matrix.H`](generated/numpy.matrix.H.html#numpy.matrix.H "numpy.matrix.H")
    | Returns the (complex) conjugate transpose of *self*. |'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`matrix.H`](generated/numpy.matrix.H.html#numpy.matrix.H "numpy.matrix.H")
    | 返回*自身*的（复数）共轭转置。'
- en: '| [`matrix.I`](generated/numpy.matrix.I.html#numpy.matrix.I "numpy.matrix.I")
    | Returns the (multiplicative) inverse of invertible *self*. |'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`matrix.I`](generated/numpy.matrix.I.html#numpy.matrix.I "numpy.matrix.I")
    | 返回可逆*自身*的（乘法）逆。'
- en: '| [`matrix.A`](generated/numpy.matrix.A.html#numpy.matrix.A "numpy.matrix.A")
    | Return *self* as an [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")
    object. |'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`matrix.A`](generated/numpy.matrix.A.html#numpy.matrix.A "numpy.matrix.A")
    | 以 [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray") 对象的形式返回*自身*。'
- en: Warning
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Matrix objects over-ride multiplication, ‘*’, and power, ‘**’, to be matrix-multiplication
    and matrix power, respectively. If your subroutine can accept sub-classes and
    you do not convert to base- class arrays, then you must use the ufuncs multiply
    and power to be sure that you are performing the correct operation for all inputs.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵对象重写了乘法 `*` 和幂运算 `**`，分别用于矩阵乘法和矩阵幂。如果你的子程序可以接受子类而且你没有转换为基类数组，那么你必须使用 ufuncs
    的 multiply 和 power 来确保对所有输入执行正确的操作。
- en: The matrix class is a Python subclass of the ndarray and can be used as a reference
    for how to construct your own subclass of the ndarray. Matrices can be created
    from other matrices, strings, and anything else that can be converted to an `ndarray`
    . The name “mat “is an alias for “matrix “in NumPy.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵类是 ndarray 的 Python 子类，可用作构建自己的 ndarray 子类的参考。矩阵可以从其他矩阵、字符串和任何可转换为 `ndarray`
    的东西创建。名称“mat”是 NumPy 中“matrix”的别名。
- en: '| [`matrix`](generated/numpy.matrix.html#numpy.matrix "numpy.matrix")(data[, dtype, copy])
    |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| [`matrix`](generated/numpy.matrix.html#numpy.matrix "numpy.matrix")(data[, dtype, copy])
    |'
- en: Note
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is no longer recommended to use this class, even for linear
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 不再建议使用这个类，即使是用于线性
- en: '|'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| [`asmatrix`](generated/numpy.asmatrix.html#numpy.asmatrix "numpy.asmatrix")(data[, dtype])
    | Interpret the input as a matrix. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| [`asmatrix`](generated/numpy.asmatrix.html#numpy.asmatrix "numpy.asmatrix")(data[, dtype])
    | 将输入解释为矩阵。 |'
- en: '| [`bmat`](generated/numpy.bmat.html#numpy.bmat "numpy.bmat")(obj[, ldict, gdict])
    | Build a matrix object from a string, nested sequence, or array. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| [`bmat`](generated/numpy.bmat.html#numpy.bmat "numpy.bmat")(obj[, ldict, gdict])
    | 从字符串、嵌套序列或数组构建一个矩阵对象。 |'
- en: 'Example 1: Matrix creation from a string'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1：从字符串创建矩阵
- en: '[PRE8]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Example 2: Matrix creation from nested sequence'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2：从嵌套序列创建矩阵
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Example 3: Matrix creation from an array'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3：从数组创建矩阵
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Memory-mapped file arrays
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存映射文件数组
- en: Memory-mapped files are useful for reading and/or modifying small segments of
    a large file with regular layout, without reading the entire file into memory.
    A simple subclass of the ndarray uses a memory-mapped file for the data buffer
    of the array. For small files, the over-head of reading the entire file into memory
    is typically not significant, however for large files using memory mapping can
    save considerable resources.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射文件对于读取和/或修改具有常规布局的大文件的小段非常有用，而无需将整个文件读入内存。ndarray 的一个简单子类使用内存映射文件作为数组的数据缓冲区。对于小文件，将整个文件读入内存的开销通常不重要，但对于大文件，使用内存映射可以节省大量资源。
- en: 'Memory-mapped-file arrays have one additional method (besides those they inherit
    from the ndarray): [`.flush()`](generated/numpy.memmap.flush.html#numpy.memmap.flush
    "numpy.memmap.flush") which must be called manually by the user to ensure that
    any changes to the array actually get written to disk.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射文件数组除了继承自 ndarray 的方法之外，还有一个额外的方法：[`.flush()`](generated/numpy.memmap.flush.html#numpy.memmap.flush
    "numpy.memmap.flush")，用户必须手动调用该方法以确保数组的任何更改实际上都被写入磁盘。
- en: '| [`memmap`](generated/numpy.memmap.html#numpy.memmap "numpy.memmap")(filename[, dtype, mode, offset, ...])
    | Create a memory-map to an array stored in a *binary* file on disk. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| [`memmap`](generated/numpy.memmap.html#numpy.memmap "numpy.memmap")(filename[, dtype, mode, offset, ...])
    | 创建一个映射到存储在磁盘上的*二进制*文件中的数组的内存映射。 |'
- en: '| [`memmap.flush`](generated/numpy.memmap.flush.html#numpy.memmap.flush "numpy.memmap.flush")()
    | Write any changes in the array to the file on disk. |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| [`memmap.flush`](generated/numpy.memmap.flush.html#numpy.memmap.flush "numpy.memmap.flush")()
    | 将数组中的任何更改写入磁盘上的文件。'
- en: 'Example:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 例子：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Character arrays ([`numpy.char`](routines.char.html#module-numpy.char "numpy.char"))
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符数组（[`numpy.char`](routines.char.html#module-numpy.char "numpy.char"）)
- en: See also
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Creating character arrays (numpy.char)](routines.array-creation.html#routines-array-creation-char)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建字符数组（numpy.char）](routines.array-creation.html#routines-array-creation-char)'
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The [`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray "numpy.chararray")
    class exists for backwards compatibility with Numarray, it is not recommended
    for new development. Starting from numpy 1.4, if one needs arrays of strings,
    it is recommended to use arrays of [`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype") [`object_`](arrays.scalars.html#numpy.object_ "numpy.object_"),
    [`bytes_`](arrays.scalars.html#numpy.bytes_ "numpy.bytes_") or [`str_`](arrays.scalars.html#numpy.str_
    "numpy.str_"), and use the free functions in the [`numpy.char`](routines.char.html#module-numpy.char
    "numpy.char") module for fast vectorized string operations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray "numpy.chararray")类是为了向后兼容Numarray而存在的，不建议用于新的开发。从numpy
    1.4开始，如果需要字符串数组，建议使用[`dtype`](generated/numpy.dtype.html#numpy.dtype "numpy.dtype")
    [`object_`](arrays.scalars.html#numpy.object_ "numpy.object_")、[`bytes_`](arrays.scalars.html#numpy.bytes_
    "numpy.bytes_")或[`str_`](arrays.scalars.html#numpy.str_ "numpy.str_")的数组，并使用[`numpy.char`](routines.char.html#module-numpy.char
    "numpy.char")模块中的自由函数进行快速向量化字符串操作。'
- en: 'These are enhanced arrays of either [`str_`](arrays.scalars.html#numpy.str_
    "numpy.str_") type or [`bytes_`](arrays.scalars.html#numpy.bytes_ "numpy.bytes_")
    type. These arrays inherit from the [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"), but specially-define the operations `+`, `*`, and `%` on a (broadcasting)
    element-by-element basis. These operations are not available on the standard [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") of character type. In addition, the [`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray") has all of the standard [`str`](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.11)") (and [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes
    "(in Python v3.11)")) methods, executing them on an element-by-element basis.
    Perhaps the easiest way to create a chararray is to use [`self.view(chararray)`](generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") where *self* is an ndarray of str or unicode data-type.
    However, a chararray can also be created using the [`numpy.chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray") constructor, or via the [`numpy.char.array`](generated/numpy.core.defchararray.array.html#numpy.core.defchararray.array
    "numpy.core.defchararray.array") function:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这些数组是增强型数组，可以是[`str_`](arrays.scalars.html#numpy.str_ "numpy.str_")类型或[`bytes_`](arrays.scalars.html#numpy.bytes_
    "numpy.bytes_")类型。这些数组继承自[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")，但特别定义了`+`、`*`和`%`操作，这些操作是以（广播）元素为基础的。这些操作在标准的字符类型的[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")上不可用。此外，[`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray")具有所有标准的[`str`](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.11)") (和[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes
    "(in Python v3.11)"))方法，会在元素基础上执行它们。也许创建一个chararray最简单的方法是使用[`self.view(chararray)`](generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view")，其中*self*是一个str或unicode数据类型的ndarray。然而，chararray也可以使用[`numpy.chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray")构造函数，或通过[`numpy.char.array`](generated/numpy.core.defchararray.array.html#numpy.core.defchararray.array
    "numpy.core.defchararray.array")函数创建：
- en: '| [`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray "numpy.chararray")(shape[, itemsize, unicode, ...])
    | Provides a convenient view on arrays of string and unicode values. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| [`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray "numpy.chararray")(shape[, itemsize, unicode, ...])
    | 为字符串和unicode值的数组提供了一个方便的视图。 |'
- en: '| [`core.defchararray.array`](generated/numpy.core.defchararray.array.html#numpy.core.defchararray.array
    "numpy.core.defchararray.array")(obj[, itemsize, ...]) | Create a [`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray"). |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| [`core.defchararray.array`](generated/numpy.core.defchararray.array.html#numpy.core.defchararray.array
    "numpy.core.defchararray.array")(obj[, itemsize, ...]) | 创建一个[`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.char.chararray")。 |'
- en: Another difference with the standard ndarray of str data-type is that the chararray
    inherits the feature introduced by Numarray that white-space at the end of any
    element in the array will be ignored on item retrieval and comparison operations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的字符串数据类型的ndarray的另一个不同之处是，chararray继承了Numarray引入的特性，即数组中任何元素末尾的空白将在元素检索和比较操作中被忽略。
- en: '## Record arrays (`numpy.rec`)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '## 记录数组（`numpy.rec`）'
- en: See also
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Creating record arrays (numpy.rec)](routines.array-creation.html#routines-array-creation-rec),
    [Data type routines](routines.dtype.html#routines-dtype), [Data type objects (dtype)](arrays.dtypes.html#arrays-dtypes).'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建记录数组（numpy.rec）](routines.array-creation.html#routines-array-creation-rec)，[数据类型例程](routines.dtype.html#routines-dtype)，[数据类型对象（dtype）](arrays.dtypes.html#arrays-dtypes)。'
- en: NumPy provides the [`recarray`](generated/numpy.recarray.html#numpy.recarray
    "numpy.recarray") class which allows accessing the fields of a structured array
    as attributes, and a corresponding scalar data type object [`record`](generated/numpy.record.html#numpy.record
    "numpy.record").
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 提供了 [`recarray`](generated/numpy.recarray.html#numpy.recarray "numpy.recarray")
    类，允许将结构化数组的字段作为属性访问，以及相应的标量数据类型对象 [`record`](generated/numpy.record.html#numpy.record
    "numpy.record")。
- en: '| [`recarray`](generated/numpy.recarray.html#numpy.recarray "numpy.recarray")(shape[, dtype, buf, offset, ...])
    | Construct an ndarray that allows field access using attributes. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| [`recarray`](generated/numpy.recarray.html#numpy.recarray "numpy.recarray")(shape[, dtype, buf, offset, ...])
    | 构造一个允许使用属性进行字段访问的 ndarray。 |'
- en: '| [`record`](generated/numpy.record.html#numpy.record "numpy.record") | A data-type
    scalar that allows field access as attribute lookup. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| [`record`](generated/numpy.record.html#numpy.record "numpy.record") | 允许通过属性查找进行字段访问的数据类型标量。
    |'
- en: Masked arrays ([`numpy.ma`](maskedarray.generic.html#module-numpy.ma "numpy.ma"))
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掩码数组 ([`numpy.ma`](maskedarray.generic.html#module-numpy.ma "numpy.ma"))
- en: See also
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Masked arrays](maskedarray.html#maskedarray)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[掩码数组](maskedarray.html#maskedarray)'
- en: Standard container class
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准容器类
- en: For backward compatibility and as a standard “container “class, the UserArray
    from Numeric has been brought over to NumPy and named [`numpy.lib.user_array.container`](generated/numpy.lib.user_array.container.html#numpy.lib.user_array.container
    "numpy.lib.user_array.container") The container class is a Python class whose
    self.array attribute is an ndarray. Multiple inheritance is probably easier with
    numpy.lib.user_array.container than with the ndarray itself and so it is included
    by default. It is not documented here beyond mentioning its existence because
    you are encouraged to use the ndarray class directly if you can.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向后兼容并作为标准的“容器”类，将 Numeric 中的 UserArray 引入到 NumPy 并命名为 [`numpy.lib.user_array.container`](generated/numpy.lib.user_array.container.html#numpy.lib.user_array.container
    "numpy.lib.user_array.container")。容器类是一个 Python 类，其 self.array 属性是一个 ndarray。可能使用
    numpy.lib.user_array.container 比直接使用 ndarray 自身更容易进行多重继承，因此默认情况下包含在内。这里不对其进行详细说明，仅提及其存在，因为鼓励您直接使用
    ndarray 类。
- en: '| [`numpy.lib.user_array.container`](generated/numpy.lib.user_array.container.html#numpy.lib.user_array.container
    "numpy.lib.user_array.container")(data[, ...]) | Standard container-class for
    easy multiple-inheritance. |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| [`numpy.lib.user_array.container`](generated/numpy.lib.user_array.container.html#numpy.lib.user_array.container
    "numpy.lib.user_array.container")(data[, ...]) | 用于方便多重继承的标准容器类。 |'
- en: '## Array Iterators'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '## 数组迭代器'
- en: 'Iterators are a powerful concept for array processing. Essentially, iterators
    implement a generalized for-loop. If *myiter* is an iterator object, then the
    Python code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是数组处理的一个强大概念。本质上，迭代器实现了一个广义的 for 循环。如果 *myiter* 是一个迭代器对象，则 Python 代码：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'calls `val = next(myiter)` repeatedly until [`StopIteration`](https://docs.python.org/3/library/exceptions.html#StopIteration
    "(in Python v3.11)") is raised by the iterator. There are several ways to iterate
    over an array that may be useful: default iteration, flat iteration, and \(N\)-dimensional
    enumeration.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 重复调用 `val = next(myiter)`，直到迭代器引发 [`StopIteration`](https://docs.python.org/3/library/exceptions.html#StopIteration
    "(in Python v3.11)")。有几种可能有用的数组迭代方法：默认迭代、平面迭代和 \(N\)-维枚举。
- en: Default iteration
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认迭代
- en: 'The default iterator of an ndarray object is the default Python iterator of
    a sequence type. Thus, when the array object itself is used as an iterator. The
    default behavior is equivalent to:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray 对象的默认迭代器是序列类型的默认 Python 迭代器。因此，当数组对象本身被用作迭代器时。默认行为相当于：
- en: '[PRE13]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This default iterator selects a sub-array of dimension \(N-1\) from the array.
    This can be a useful construct for defining recursive algorithms. To loop over
    the entire array requires \(N\) for-loops.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此默认迭代器从数组中选择一个维度为 \(N-1\) 的子数组。这对定义递归算法是一个有用的构造。要循环遍历整个数组需要 \(N\) 个 for 循环。
- en: '[PRE14]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Flat iteration
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平面迭代
- en: '| [`ndarray.flat`](generated/numpy.ndarray.flat.html#numpy.ndarray.flat "numpy.ndarray.flat")
    | A 1-D iterator over the array. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| [`ndarray.flat`](generated/numpy.ndarray.flat.html#numpy.ndarray.flat "numpy.ndarray.flat")
    | 数组上的 1-D 迭代器。 |'
- en: As mentioned previously, the flat attribute of ndarray objects returns an iterator
    that will cycle over the entire array in C-style contiguous order.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如先前提到的，ndarray对象的flat属性返回一个迭代器，该迭代器将以C风格连续顺序循环整个数组。
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, I’ve used the built-in enumerate iterator to return the iterator index
    as well as the value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用内置的enumerate迭代器返回迭代器索引以及值。
- en: N-dimensional enumeration
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: N维枚举
- en: '| [`ndenumerate`](generated/numpy.ndenumerate.html#numpy.ndenumerate "numpy.ndenumerate")(arr)
    | Multidimensional index iterator. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| [`ndenumerate`](generated/numpy.ndenumerate.html#numpy.ndenumerate "numpy.ndenumerate")(arr)
    | 多维索引迭代器。 |'
- en: Sometimes it may be useful to get the N-dimensional index while iterating. The
    ndenumerate iterator can achieve this.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在迭代时获取N维索引可能很有用。 ndenumerate迭代器可以实现这一点。
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Iterator for broadcasting
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于广播的迭代器
- en: '| [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast "numpy.broadcast")
    | Produce an object that mimics broadcasting. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast "numpy.broadcast")
    | 生成一个模拟广播的对象。 |'
- en: The general concept of broadcasting is also available from Python using the
    [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast "numpy.broadcast")
    iterator. This object takes \(N\) objects as inputs and returns an iterator that
    returns tuples providing each of the input sequence elements in the broadcasted
    result.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 广播的一般概念也可以通过Python的[`broadcast`](generated/numpy.broadcast.html#numpy.broadcast
    "numpy.broadcast")迭代器实现。该对象以\(N\)个对象作为输入，并返回一个迭代器，该迭代器在广播结果中提供每个输入序列元素的元组。
- en: '[PRE17]  ## Special attributes and methods'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE17]  ## 特殊属性和方法'
- en: See also
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Subclassing ndarray](../user/basics.subclassing.html#basics-subclassing)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[ndarray的子类化](../user/basics.subclassing.html#basics-subclassing)'
- en: 'NumPy provides several hooks that classes can customize:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了几个类可以自定义的挂钩：
- en: '[PRE18]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: New in version 1.13.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.13 中的新内容。
- en: Any class, ndarray subclass or not, can define this method or set it to None
    in order to override the behavior of NumPy’s ufuncs. This works quite similarly
    to Python’s `__mul__` and other binary operation routines.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类，无论是ndarray的子类还是其他类，都可以定义此方法或将其设置为None，以覆盖NumPy的ufunc行为。这与Python的`__mul__`和其他二进制操作例程非常相似。
- en: '*ufunc* is the ufunc object that was called.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*ufunc* 是被调用的ufunc对象。'
- en: '*method* is a string indicating which Ufunc method was called (one of `"__call__"`,
    `"reduce"`, `"reduceat"`, `"accumulate"`, `"outer"`, `"inner"`).'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*method* 是一个字符串，指示调用哪个Ufunc方法（其中之一是`"__call__"`，`"reduce"`，`"reduceat"`，`"accumulate"`，`"outer"`，`"inner"`）。'
- en: '*inputs* is a tuple of the input arguments to the `ufunc`.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*inputs* 是传递给`ufunc`的输入参数的元组。'
- en: '*kwargs* is a dictionary containing the optional input arguments of the ufunc.
    If given, any `out` arguments, both positional and keyword, are passed as a [`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple
    "(in Python v3.11)") in *kwargs*. See the discussion in [Universal functions (ufunc)](ufuncs.html#ufuncs)
    for details.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*kwargs* 是一个包含ufunc的可选输入参数的字典。如果给定，任何`out`参数，无论是位置参数还是关键字参数，都作为[`tuple`](https://docs.python.org/3/library/stdtypes.html#tuple
    "(在Python v3.11中)")传递给 *kwargs*。有关详细信息，请参见 [Universal functions (ufunc)](ufuncs.html#ufuncs)
    中的讨论。'
- en: The method should return either the result of the operation, or [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)") if the operation requested is not implemented.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法应返回操作的结果或者如果所请求的操作未实现，则返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(在Python v3.11中)")。
- en: 'If one of the input, output, or `where` arguments has a [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__") method, it is executed *instead* of the ufunc.
    If more than one of the arguments implements [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__"), they are tried in the order: subclasses before
    superclasses, inputs before outputs, outputs before `where`, otherwise left to
    right. The first routine returning something other than [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)") determines the result. If all of the [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__") operations return [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)"), a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)") is raised.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入、输出或`where`参数中的一个具有[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")方法，则会执行*该*ufunc而不是。
    如果多个参数都实现了[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")，则按顺序尝试：子类在超类之前，输入在输出之前，在`where`之前，否则从左到右。
    第一个返回值不是[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(在 Python v3.11)")的例程确定结果。 如果所有的[`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__")操作都返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(在 Python v3.11)")，则会引发[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(在 Python v3.11)")。
- en: Note
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We intend to re-implement numpy functions as (generalized) Ufunc, in which case
    it will become possible for them to be overridden by the `__array_ufunc__` method.
    A prime candidate is [`matmul`](generated/numpy.matmul.html#numpy.matmul "numpy.matmul"),
    which currently is not a Ufunc, but could be relatively easily be rewritten as
    a (set of) generalized Ufuncs. The same may happen with functions such as [`median`](generated/numpy.median.html#numpy.median
    "numpy.median"), [`amin`](generated/numpy.amin.html#numpy.amin "numpy.amin"),
    and [`argsort`](generated/numpy.argsort.html#numpy.argsort "numpy.argsort").
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打算将numpy函数重新实现为（广义的）Ufunc，这样它们就可以被`__array_ufunc__`方法覆盖。 一个主要的候选对象是[`matmul`](generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul")，它目前不是一个Ufunc，但可以相对容易地重写为（一组）广义的Ufuncs。 同样的情况可能会发生在函数如[`median`](generated/numpy.median.html#numpy.median
    "numpy.median")、[`amin`](generated/numpy.amin.html#numpy.amin "numpy.amin")和[`argsort`](generated/numpy.argsort.html#numpy.argsort
    "numpy.argsort")。
- en: Like with some other special methods in python, such as `__hash__` and `__iter__`,
    it is possible to indicate that your class does *not* support ufuncs by setting
    `__array_ufunc__ = None`. Ufuncs always raise [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)") when called on an object that sets `__array_ufunc__ = None`.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 与Python中的其他一些特殊方法（如`__hash__`和`__iter__`）一样，可以通过设置`__array_ufunc__ = None`来指示您的类*不*支持ufuncs。
    当在设置了`__array_ufunc__ = None`的对象上调用ufuncs时，ufuncs始终会引发[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(在 Python v3.11)")。
- en: The presence of [`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")
    also influences how [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")
    handles binary operations like `arr + obj` and `arr < obj` when `arr` is an [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") and `obj` is an instance of a custom class. There are two possibilities.
    If `obj.__array_ufunc__` is present and not None, then `ndarray.__add__` and friends
    will delegate to the ufunc machinery, meaning that `arr + obj` becomes `np.add(arr,
    obj)`, and then [`add`](generated/numpy.add.html#numpy.add "numpy.add") invokes
    `obj.__array_ufunc__`. This is useful if you want to define an object that acts
    like an array.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")的存在也影响了[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")如何处理二进制操作，例如`arr + obj`和`arr < obj`，其中`arr`是一个[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")，而`obj`是自定义类的一个实例。 有两种可能性。 如果`obj.__array_ufunc__`存在且不为None，则`ndarray.__add__`等会委托给ufunc机制，这意味着`arr
    + obj`变为`np.add(arr, obj)`，然后[`add`](generated/numpy.add.html#numpy.add "numpy.add")调用`obj.__array_ufunc__`。
    如果您想定义一个像数组一样的对象，这是很有用的。'
- en: 'Alternatively, if `obj.__array_ufunc__` is set to None, then as a special case,
    special methods like `ndarray.__add__` will notice this and *unconditionally*
    raise [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)"). This is useful if you want to create objects that interact
    with arrays via binary operations, but are not themselves arrays. For example,
    a units handling system might have an object `m` representing the “meters” unit,
    and want to support the syntax `arr * m` to represent that the array has units
    of “meters”, but not want to otherwise interact with arrays via ufuncs or otherwise.
    This can be done by setting `__array_ufunc__ = None` and defining `__mul__` and
    `__rmul__` methods. (Note that this means that writing an `__array_ufunc__` that
    always returns [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)") is not quite the same as setting `__array_ufunc__ = None`:
    in the former case, `arr + obj` will raise [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)"), while in the latter case it is possible to define a `__radd__`
    method to prevent this.)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果`obj.__array_ufunc__`被设置为`None`，那么作为一个特殊情况，像`ndarray.__add__`这样的特殊方法会注意到这一点，并且*无条件*地引发[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(在 Python v3.11 中)")。如果你想创建与数组通过二元操作进行交互的对象，但它们本身不是数组，这将非常有用。例如，一个单位处理系统可能有一个表示“米”单位的对象`m`，并且希望支持语法`arr
    * m`表示数组具有“米”单位，但不希望以其他方式通过ufunc或其他方式与数组进行交互。这可以通过设置`__array_ufunc__ = None`并定义`__mul__`和`__rmul__`方法来实现。（注意，这意味着编写一个始终返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(在 Python v3.11 中)")的`__array_ufunc__`并不完全等同于设置`__array_ufunc__ = None`：在前一种情况下，`arr
    + obj`会引发[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(在 Python v3.11 中)")，而在后一种情况下，可以定义一个`__radd__`方法来防止这种情况发生。）
- en: The above does not hold for in-place operators, for which [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") never returns [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)"). Hence, `arr += obj` would always lead to a [`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(in Python v3.11)"). This is because for arrays in-place operations cannot generically
    be replaced by a simple reverse operation. (For instance, by default, `arr +=
    obj` would be translated to `arr = arr + obj`, i.e., `arr` would be replaced,
    contrary to what is expected for in-place array operations.)
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以上内容不适用于就地运算符，对于这些运算符，[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")永远不会返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(在 Python v3.11 中)")。因此，`arr += obj`将总是导致[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError
    "(在 Python v3.11 中)")。这是因为对于数组来说，就地操作通常无法简单地被一个简单的反向操作所取代。（例如，默认情况下，`arr += obj`将被翻译为`arr
    = arr + obj`，即`arr`将被替换，这与期望的就地数组操作相反。）
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you define `__array_ufunc__`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你定义了`__array_ufunc__`：
- en: If you are not a subclass of [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"), we recommend your class define special methods like `__add__`
    and `__lt__` that delegate to ufuncs just like ndarray does. An easy way to do
    this is to subclass from [`NDArrayOperatorsMixin`](generated/numpy.lib.mixins.NDArrayOperatorsMixin.html#numpy.lib.mixins.NDArrayOperatorsMixin
    "numpy.lib.mixins.NDArrayOperatorsMixin").
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你不是[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")的子类，我们建议你的类定义像`__add__`和`__lt__`这样的特殊方法，它们像`ndarray`一样委托给ufunc。一个简单的方法是从[`NDArrayOperatorsMixin`](generated/numpy.lib.mixins.NDArrayOperatorsMixin.html#numpy.lib.mixins.NDArrayOperatorsMixin
    "numpy.lib.mixins.NDArrayOperatorsMixin")继承。
- en: If you subclass [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray"),
    we recommend that you put all your override logic in `__array_ufunc__` and not
    also override special methods. This ensures the class hierarchy is determined
    in only one place rather than separately by the ufunc machinery and by the binary
    operation rules (which gives preference to special methods of subclasses; the
    alternative way to enforce a one-place only hierarchy, of setting [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__") to None, would seem very unexpected and thus confusing,
    as then the subclass would not work at all with ufuncs).
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你继承了[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")，我们建议你把所有的重写逻辑放在`__array_ufunc__`中，而不是同时重写特殊方法。这确保了类层次结构只在一个地方确定，而不是通过ufunc机制和二元操作规则分别确定（后者优先考虑子类的特殊方法；为了强制只在一个地方确定层次结构的另一种方法，将[`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__")设置为None，似乎会让人感到意外并且令人困惑，因为子类将完全无法与ufuncs一起使用）。
- en: '[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray") defines
    its own [`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__"),
    which, evaluates the ufunc if no arguments have overrides, and returns [`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(in Python v3.11)") otherwise. This may be useful for subclasses for which [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__") converts any instances of its own class to [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"): it can then pass these on to its superclass using `super().__array_ufunc__(*inputs,
    **kwargs)`, and finally return the results after possible back-conversion. The
    advantage of this practice is that it ensures that it is possible to have a hierarchy
    of subclasses that extend the behaviour. See [Subclassing ndarray](../user/basics.subclassing.html#basics-subclassing)
    for details.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")定义了自己的[`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__")，如果没有参数有重写，则评估ufunc，并在其他情况下返回[`NotImplemented`](https://docs.python.org/3/library/constants.html#NotImplemented
    "(在 Python v3.11)")。这对于那些[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")将其自身类的任何实例转换为[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")的子类可能是有用的：它然后可以使用`super().__array_ufunc__(*inputs, **kwargs)`将这些传递给其超类，并在可能的情况下返回结果后进行反向转换。这种做法的优势在于确保能够拥有扩展行为的子类层次结构。有关详细信息，请参阅[子类化
    ndarray](../user/basics.subclassing.html#basics-subclassing)。'
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If a class defines the [`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")
    method, this disables the [`__array_wrap__`](#numpy.class.__array_wrap__ "numpy.class.__array_wrap__"),
    [`__array_prepare__`](#numpy.class.__array_prepare__ "numpy.class.__array_prepare__"),
    [`__array_priority__`](#numpy.class.__array_priority__ "numpy.class.__array_priority__")
    mechanism described below for ufuncs (which may eventually be deprecated).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类定义了[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")方法，这将禁用对ufuncs的下面描述的[`__array_wrap__`](#numpy.class.__array_wrap__
    "numpy.class.__array_wrap__")、[`__array_prepare__`](#numpy.class.__array_prepare__
    "numpy.class.__array_prepare__")和[`__array_priority__`](#numpy.class.__array_priority__
    "numpy.class.__array_priority__")机制（最终可能已被弃用）。
- en: '[PRE19]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: New in version 1.16.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本1.16开始的新功能。
- en: '`func` is an arbitrary callable exposed by NumPy’s public API, which was called
    in the form `func(*args, **kwargs)`.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func`是NumPy公共API中公开的任意可调用对象，以`func(*args, **kwargs)`的形式调用。'
- en: '`types` is a collection [`collections.abc.Collection`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Collection
    "(in Python v3.11)") of unique argument types from the original NumPy function
    call that implement `__array_function__`.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`types`是原始NumPy函数调用中实现`__array_function__`的唯一参数类型的集合[`collections.abc.Collection`](https://docs.python.org/3/library/collections.abc.html#collections.abc.Collection
    "(在 Python v3.11)")。'
- en: The tuple `args` and dict `kwargs` are directly passed on from the original
    call.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组`args`和字典`kwargs`直接从原始调用中传递。
- en: As a convenience for `__array_function__` implementors, `types` provides all
    argument types with an `'__array_function__'` attribute. This allows implementors
    to quickly identify cases where they should defer to `__array_function__` implementations
    on other arguments. Implementations should not rely on the iteration order of
    `types`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便`__array_function__`的实现者，`types`提供了所有具有`'__array_function__'`属性的参数类型。这使得实现者能够快速识别应该推迟到其他参数的`__array_function__`实现的情况。实现不应依赖于`types`的迭代顺序。
- en: 'Most implementations of `__array_function__` will start with two checks:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`__array_function__`的实现将从以下两个检查开始：
- en: Is the given function something that we know how to overload?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定的函数是我们知道如何重载的吗？
- en: Are all arguments of a type that we know how to handle?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有参数都是我们知道如何处理的类型吗？
- en: If these conditions hold, `__array_function__` should return the result from
    calling its implementation for `func(*args, **kwargs)`. Otherwise, it should return
    the sentinel value `NotImplemented`, indicating that the function is not implemented
    by these types.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些条件成立，`__array_function__`应返回调用其实现的结果`func(*args, **kwargs)`。否则，它应返回哨兵值`NotImplemented`，表示这些类型未实现该函数。
- en: There are no general requirements on the return value from `__array_function__`,
    although most sensible implementations should probably return array(s) with the
    same type as one of the function’s arguments.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`__array_function__`的返回值没有一般要求，尽管大多数明智的实现可能应该返回与函数参数之一相同类型的数组。
- en: It may also be convenient to define a custom decorators (`implements` below)
    for registering `__array_function__` implementations.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 定义自定义装饰器（`implements`如下）以注册`__array_function__`实现可能也很方便。
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note that it is not required for `__array_function__` implementations to include
    *all* of the corresponding NumPy function’s optional arguments (e.g., `broadcast_to`
    above omits the irrelevant `subok` argument). Optional arguments are only passed
    in to `__array_function__` if they were explicitly used in the NumPy function
    call.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`__array_function__`的实现不需要包含*所有*相应NumPy函数的可选参数（例如，`broadcast_to`上省略了无关的`subok`参数）。只有在NumPy函数调用中明确使用了可选参数时，才会将可选参数传递给`__array_function__`。
- en: Just like the case for builtin special methods like `__add__`, properly written
    `__array_function__` methods should always return `NotImplemented` when an unknown
    type is encountered. Otherwise, it will be impossible to correctly override NumPy
    functions from another object if the operation also includes one of your objects.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 就像内置特殊方法`__add__`的情况一样，正确编写的`__array_function__`方法在遇到未知类型时应始终返回`NotImplemented`。否则，如果操作还涉及到你的对象之一，那么将无法正确覆盖另一个对象的NumPy函数。
- en: 'For the most part, the rules for dispatch with `__array_function__` match those
    for `__array_ufunc__`. In particular:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，使用`__array_function__`进行分发的规则与`__array_ufunc__`的规则相匹配。特别是：
- en: 'NumPy will gather implementations of `__array_function__` from all specified
    inputs and call them in order: subclasses before superclasses, and otherwise left
    to right. Note that in some edge cases involving subclasses, this differs slightly
    from the [current behavior](https://bugs.python.org/issue30140) of Python.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy将从所有指定的输入中收集`__array_function__`的实现并按顺序调用它们：子类在超类之前，否则从左到右。请注意，在涉及子类的一些边缘情况中，这与Python的[当前行为](https://bugs.python.org/issue30140)略有不同。
- en: Implementations of `__array_function__` indicate that they can handle the operation
    by returning any value other than `NotImplemented`.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`__array_function__`的实现表明它们可以通过返回任何值而不是`NotImplemented`来处理操作。'
- en: If all `__array_function__` methods return `NotImplemented`, NumPy will raise
    `TypeError`.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果所有`__array_function__`方法都返回`NotImplemented`，NumPy将引发`TypeError`。
- en: If no `__array_function__` methods exists, NumPy will default to calling its
    own implementation, intended for use on NumPy arrays. This case arises, for example,
    when all array-like arguments are Python numbers or lists. (NumPy arrays do have
    a `__array_function__` method, given below, but it always returns `NotImplemented`
    if any argument other than a NumPy array subclass implements `__array_function__`.)
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`__array_function__`方法存在，NumPy将默认调用其自己的实现，用于在NumPy数组上使用。例如，当所有类似数组的参数都是Python数字或列表时就会出现这种情况。（NumPy数组确实有一个`__array_function__`方法，如下所示，但如果除了NumPy数组子类之外的任何参数实现了`__array_function__`，它总是返回`NotImplemented`。）
- en: One deviation from the current behavior of `__array_ufunc__` is that NumPy will
    only call `__array_function__` on the *first* argument of each unique type. This
    matches Python’s [rule for calling reflected methods](https://docs.python.org/3/reference/datamodel.html#object.__ror__),
    and this ensures that checking overloads has acceptable performance even when
    there are a large number of overloaded arguments.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 与`__array_ufunc__`当前行为的一个偏差是，NumPy仅在每种唯一类型的*第一个*参数上调用`__array_function__`。这与Python的[调用反射方法的规则](https://docs.python.org/3/reference/datamodel.html#object.__ror__)相匹配，并确保即使有大量重载参数时，检查重载也具有可接受的性能。
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This method is called whenever the system internally allocates a new array from
    *obj*, where *obj* is a subclass (subtype) of the [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"). It can be used to change attributes of *self* after construction
    (so as to ensure a 2-d matrix for example), or to update meta-information from
    the “parent.” Subclasses inherit a default implementation of this method that
    does nothing.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统从*obj*（*obj*是[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")的子类（子类型））内部分配新数组时会调用此方法。它可以用来在构造之后更改*self*的属性（比如确保2维矩阵），或者更新来自“父类”的元信息。子类继承了这个方法的默认实现，什么都不做。
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: At the beginning of every [ufunc](../user/basics.ufuncs.html#ufuncs-output-type),
    this method is called on the input object with the highest array priority, or
    the output object if one was specified. The output array is passed in and whatever
    is returned is passed to the ufunc. Subclasses inherit a default implementation
    of this method which simply returns the output array unmodified. Subclasses may
    opt to use this method to transform the output array into an instance of the subclass
    and update metadata before returning the array to the ufunc for computation.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个[ufunc](../user/basics.ufuncs.html#ufuncs-output-type)的开始时，这个方法被调用在具有最高数组优先级的输入对象上，或者如果指定了输出对象，则在输出对象上。输出数组被传递进来，返回的任何内容都被传递给ufunc。子类继承了这个方法的默认实现，它只是返回未修改的输出数组。子类可以选择使用这个方法将输出数组转换成子类的一个实例，并在返回数组给ufunc进行计算之前更新元数据。
- en: Note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For ufuncs, it is hoped to eventually deprecate this method in favour of [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__").
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ufuncs，希望最终废弃这种方法，而支持[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")。
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At the end of every [ufunc](../user/basics.ufuncs.html#ufuncs-output-type),
    this method is called on the input object with the highest array priority, or
    the output object if one was specified. The ufunc-computed array is passed in
    and whatever is returned is passed to the user. Subclasses inherit a default implementation
    of this method, which transforms the array into a new instance of the object’s
    class. Subclasses may opt to use this method to transform the output array into
    an instance of the subclass and update metadata before returning the array to
    the user.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个[ufunc](../user/basics.ufuncs.html#ufuncs-output-type)的结束时，这个方法在具有最高数组优先级的输入对象上被调用，或者如果指定了输出对象，则在输出对象上。ufunc计算得到的数组被传递进来，返回的任何内容都被传递给用户。子类继承了这个方法的默认实现，该实现将数组转换为对象类的一个新实例。子类可以选择使用这个方法将输出数组转换为子类的一个实例，并在返回数组给用户之前更新元数据。
- en: Note
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For ufuncs, it is hoped to eventually deprecate this method in favour of [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__").
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ufuncs，希望最终废弃这种方法，而支持[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")。
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The value of this attribute is used to determine what type of object to return
    in situations where there is more than one possibility for the Python type of
    the returned object. Subclasses inherit a default value of 0.0 for this attribute.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个属性的值被用来确定返回对象的Python类型有多种可能性的情况下使用。子类继承了这个属性的默认值为0.0。
- en: Note
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For ufuncs, it is hoped to eventually deprecate this method in favour of [`__array_ufunc__`](#numpy.class.__array_ufunc__
    "numpy.class.__array_ufunc__").
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ufuncs，希望最终废弃这种方法，而支持[`__array_ufunc__`](#numpy.class.__array_ufunc__ "numpy.class.__array_ufunc__")。
- en: '[PRE25]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If a class (ndarray subclass or not) having the [`__array__`](#numpy.class.__array__
    "numpy.class.__array__") method is used as the output object of an [ufunc](../user/basics.ufuncs.html#ufuncs-output-type),
    results will *not* be written to the object returned by [`__array__`](#numpy.class.__array__
    "numpy.class.__array__"). This practice will return `TypeError`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类（ndarray的子类或不是）具有[`__array__`](#numpy.class.__array__ "numpy.class.__array__")方法，并且被用作[ufunc](../user/basics.ufuncs.html#ufuncs-output-type)的输出对象，则结果不会被写入由[`__array__`](#numpy.class.__array__
    "numpy.class.__array__")返回的对象。这种做法会引发`TypeError`。
- en: '## Matrix objects'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '## 矩阵对象'
- en: Note
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is strongly advised *not* to use the matrix subclass. As described below,
    it makes writing functions that deal consistently with matrices and regular arrays
    very difficult. Currently, they are mainly used for interacting with `scipy.sparse`.
    We hope to provide an alternative for this use, however, and eventually remove
    the `matrix` subclass.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议*不要*使用矩阵子类。正如下文所述，这让编写可以始终处理矩阵和常规数组的函数非常困难。目前，它们主要用于与 `scipy.sparse` 交互。但是我们希望提供另一种用途，最终移除
    `matrix` 子类。
- en: '[`matrix`](generated/numpy.matrix.html#numpy.matrix "numpy.matrix") objects
    inherit from the ndarray and therefore, they have the same attributes and methods
    of ndarrays. There are six important differences of matrix objects, however, that
    may lead to unexpected results when you use matrices but expect them to act like
    arrays:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[`matrix`](generated/numpy.matrix.html#numpy.matrix "numpy.matrix") 对象继承自 ndarray
    ，因此它们具有与 ndarrays 相同的属性和方法。然而，矩阵对象有六个重要的差异，可能导致在使用矩阵时出现意外结果但期望它们的行为类似于数组的情况：'
- en: Matrix objects can be created using a string notation to allow Matlab-style
    syntax where spaces separate columns and semicolons (‘;’) separate rows.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以使用字符串表示法创建矩阵对象，以允许 Matlab 风格的语法，其中空格分隔列，分号（‘;’）分隔行。
- en: Matrix objects are always two-dimensional. This has far-reaching implications,
    in that m.ravel() is still two-dimensional (with a 1 in the first dimension) and
    item selection returns two-dimensional objects so that sequence behavior is fundamentally
    different than arrays.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵对象始终是二维的。这具有深远影响，因为 m.ravel() 仍然是二维的（第一维度为1），项目选择返回二维对象，因此序列行为与数组根本不同。
- en: Matrix objects over-ride multiplication to be matrix-multiplication. **Make
    sure you understand this for functions that you may want to receive matrices.
    Especially in light of the fact that asanyarray(m) returns a matrix when m is
    a matrix.**
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵对象重载乘法以实现矩阵乘法。**确保你理解了这一点，因为你可能需要接收矩阵的函数。特别是因为当m是矩阵时，asanyarray(m)返回一个矩阵。**
- en: Matrix objects over-ride power to be matrix raised to a power. The same warning
    about using power inside a function that uses asanyarray(…) to get an array object
    holds for this fact.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵对象重载幂运算以得到矩阵的幂。在使用 asanyarray(…) 获取数组对象的函数内部使用幂时，需要注意相同的警告。
- en: The default __array_priority__ of matrix objects is 10.0, and therefore mixed
    operations with ndarrays always produce matrices.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵对象的默认 __array_priority__ 为 10.0，因此与 ndarray 的混合操作始终产生矩阵。
- en: Matrices have special attributes which make calculations easier. These are
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩阵具有使计算更容易的特殊属性。这些是
- en: '| [`matrix.T`](generated/numpy.matrix.T.html#numpy.matrix.T "numpy.matrix.T")
    | Returns the transpose of the matrix. |'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`matrix.T`](generated/numpy.matrix.T.html#numpy.matrix.T "numpy.matrix.T")
    | 返回矩阵的转置。 |'
- en: '| [`matrix.H`](generated/numpy.matrix.H.html#numpy.matrix.H "numpy.matrix.H")
    | Returns the (complex) conjugate transpose of *self*. |'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`matrix.H`](generated/numpy.matrix.H.html#numpy.matrix.H "numpy.matrix.H")
    | 返回 *self* 的（复数）共轭转置。 |'
- en: '| [`matrix.I`](generated/numpy.matrix.I.html#numpy.matrix.I "numpy.matrix.I")
    | Returns the (multiplicative) inverse of invertible *self*. |'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`matrix.I`](generated/numpy.matrix.I.html#numpy.matrix.I "numpy.matrix.I")
    | 返回可逆 *self* 的（乘法）逆。 |'
- en: '| [`matrix.A`](generated/numpy.matrix.A.html#numpy.matrix.A "numpy.matrix.A")
    | Return *self* as an [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")
    object. |'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| [`matrix.A`](generated/numpy.matrix.A.html#numpy.matrix.A "numpy.matrix.A")
    | 将 *self* 返回为一个 [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray "numpy.ndarray")
    对象。 |'
- en: Warning
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Matrix objects over-ride multiplication, ‘*’, and power, ‘**’, to be matrix-multiplication
    and matrix power, respectively. If your subroutine can accept sub-classes and
    you do not convert to base- class arrays, then you must use the ufuncs multiply
    and power to be sure that you are performing the correct operation for all inputs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵对象重载乘法，‘*’，和幂，‘**’，分别用于矩阵乘法和矩阵幂。如果你的子程序能够接受子类，并且你没有转换为基类数组，则必须使用ufuncs multiply
    和 power 来确保对所有输入执行正确的操作。
- en: The matrix class is a Python subclass of the ndarray and can be used as a reference
    for how to construct your own subclass of the ndarray. Matrices can be created
    from other matrices, strings, and anything else that can be converted to an `ndarray`
    . The name “mat “is an alias for “matrix “in NumPy.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵类是 ndarray 的 Python 子类，并可用作如何构造你自己的 ndarray 子类的参考。可以从其他矩阵、字符串和任何可转换为 `ndarray`
    的内容创建矩阵。在 NumPy 中，名称“mat”是“matrix”的别名。
- en: '| [`matrix`](generated/numpy.matrix.html#numpy.matrix "numpy.matrix")(data[, dtype, copy])
    |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| [`matrix`](generated/numpy.matrix.html#numpy.matrix "numpy.matrix")(data[, dtype, copy])
    |'
- en: Note
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is no longer recommended to use this class, even for linear
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不再建议使用这个类，即使是线性的
- en: '|'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| [`asmatrix`](generated/numpy.asmatrix.html#numpy.asmatrix "numpy.asmatrix")(data[, dtype])
    | Interpret the input as a matrix. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| [`asmatrix`](generated/numpy.asmatrix.html#numpy.asmatrix "numpy.asmatrix")(data[, dtype])
    | 将输入解释为矩阵。 |'
- en: '| [`bmat`](generated/numpy.bmat.html#numpy.bmat "numpy.bmat")(obj[, ldict, gdict])
    | Build a matrix object from a string, nested sequence, or array. |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '| [`bmat`](generated/numpy.bmat.html#numpy.bmat "numpy.bmat")(obj[, ldict, gdict])
    | 从字符串、嵌套序列或数组构建一个矩阵对象。 |'
- en: 'Example 1: Matrix creation from a string'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 1：从字符串创建矩阵
- en: '[PRE26]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Example 2: Matrix creation from nested sequence'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 2：从嵌套序列创建矩阵
- en: '[PRE27]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Example 3: Matrix creation from an array'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 3：从数组创建矩阵
- en: '[PRE28]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Memory-mapped file arrays
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存映射文件数组
- en: Memory-mapped files are useful for reading and/or modifying small segments of
    a large file with regular layout, without reading the entire file into memory.
    A simple subclass of the ndarray uses a memory-mapped file for the data buffer
    of the array. For small files, the over-head of reading the entire file into memory
    is typically not significant, however for large files using memory mapping can
    save considerable resources.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射文件对于读取和/或修改大文件的正常布局中的小段非常有用，而不需要将整个文件读入内存。一个简单的ndarray的子类使用内存映射文件作为数组的数据缓冲区。对于小文件，将整个文件读入内存的开销通常不重要，但是对于大文件，使用内存映射可以节省大量资源。
- en: 'Memory-mapped-file arrays have one additional method (besides those they inherit
    from the ndarray): [`.flush()`](generated/numpy.memmap.flush.html#numpy.memmap.flush
    "numpy.memmap.flush") which must be called manually by the user to ensure that
    any changes to the array actually get written to disk.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 内存映射文件数组还有一个额外的方法（除了它们从ndarray继承的方法）：[`.flush()`](generated/numpy.memmap.flush.html#numpy.memmap.flush
    "numpy.memmap.flush") ，用户必须手动调用它以确保对数组的任何更改实际上被写入到磁盘。
- en: '| [`memmap`](generated/numpy.memmap.html#numpy.memmap "numpy.memmap")(filename[, dtype, mode, offset, ...])
    | Create a memory-map to an array stored in a *binary* file on disk. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| [`memmap`](generated/numpy.memmap.html#numpy.memmap "numpy.memmap")(filename[, dtype, mode, offset, ...])
    | 在磁盘上的*二进制*文件中创建一个内存映射的数组。 |'
- en: '| [`memmap.flush`](generated/numpy.memmap.flush.html#numpy.memmap.flush "numpy.memmap.flush")()
    | Write any changes in the array to the file on disk. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| [`memmap.flush`](generated/numpy.memmap.flush.html#numpy.memmap.flush "numpy.memmap.flush")()
    | 将数组中的任何更改写入到磁盘文件中。 |'
- en: 'Example:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '示例:'
- en: '[PRE29]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Character arrays ([`numpy.char`](routines.char.html#module-numpy.char "numpy.char"))
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符数组（[`numpy.char`](routines.char.html#module-numpy.char "numpy.char")）
- en: See also
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Creating character arrays (numpy.char)](routines.array-creation.html#routines-array-creation-char)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建字符数组（numpy.char）](routines.array-creation.html#routines-array-creation-char)'
- en: Note
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The [`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray "numpy.chararray")
    class exists for backwards compatibility with Numarray, it is not recommended
    for new development. Starting from numpy 1.4, if one needs arrays of strings,
    it is recommended to use arrays of [`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype") [`object_`](arrays.scalars.html#numpy.object_ "numpy.object_"),
    [`bytes_`](arrays.scalars.html#numpy.bytes_ "numpy.bytes_") or [`str_`](arrays.scalars.html#numpy.str_
    "numpy.str_"), and use the free functions in the [`numpy.char`](routines.char.html#module-numpy.char
    "numpy.char") module for fast vectorized string operations.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray "numpy.chararray")
    类是为了向后兼容Numarray而存在的，不建议用于新开发。从numpy 1.4开始，如果需要字符串数组，建议使用[`dtype`](generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype") 的[`object_`](arrays.scalars.html#numpy.object_ "numpy.object_")
    、[`bytes_`](arrays.scalars.html#numpy.bytes_ "numpy.bytes_") 或[`str_`](arrays.scalars.html#numpy.str_
    "numpy.str_") 数组，并使用[`numpy.char`](routines.char.html#module-numpy.char "numpy.char")
    模块中的自由函数进行快速向量化的字符串操作。'
- en: 'These are enhanced arrays of either [`str_`](arrays.scalars.html#numpy.str_
    "numpy.str_") type or [`bytes_`](arrays.scalars.html#numpy.bytes_ "numpy.bytes_")
    type. These arrays inherit from the [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray"), but specially-define the operations `+`, `*`, and `%` on a (broadcasting)
    element-by-element basis. These operations are not available on the standard [`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray") of character type. In addition, the [`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray") has all of the standard [`str`](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.11)") (and [`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes
    "(in Python v3.11)")) methods, executing them on an element-by-element basis.
    Perhaps the easiest way to create a chararray is to use [`self.view(chararray)`](generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view") where *self* is an ndarray of str or unicode data-type.
    However, a chararray can also be created using the [`numpy.chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray") constructor, or via the [`numpy.char.array`](generated/numpy.core.defchararray.array.html#numpy.core.defchararray.array
    "numpy.core.defchararray.array") function:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是增强型的数组，类型为[`str_`](arrays.scalars.html#numpy.str_ "numpy.str_")或[`bytes_`](arrays.scalars.html#numpy.bytes_
    "numpy.bytes_")。 这些数组继承自[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")，但特别定义了`+`，`*`和`%`操作，以（广播）逐元素方式执行。 这些操作在标准的字符类型[`ndarray`](generated/numpy.ndarray.html#numpy.ndarray
    "numpy.ndarray")上不可用。 此外，[`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray")具有所有标准的[`str`](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.11)")（和[`bytes`](https://docs.python.org/3/library/stdtypes.html#bytes
    "(in Python v3.11)")）方法，并在逐元素的基础上执行它们。 创建`chararray`最简单的方法可能是使用[`self.view(chararray)`](generated/numpy.ndarray.view.html#numpy.ndarray.view
    "numpy.ndarray.view")，其中*self*是一个str或unicode数据类型的ndarray。 但是，也可以使用[`numpy.chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray")构造函数或通过[`numpy.char.array`](generated/numpy.core.defchararray.array.html#numpy.core.defchararray.array
    "numpy.core.defchararray.array")函数来创建chararray：
- en: '| [`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray "numpy.chararray")(shape[, itemsize, unicode, ...])
    | Provides a convenient view on arrays of string and unicode values. |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| [`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray "numpy.chararray")(shape[, itemsize, unicode, ...])
    | 提供方便查看字符串和Unicode值数组的视图。 |'
- en: '| [`core.defchararray.array`](generated/numpy.core.defchararray.array.html#numpy.core.defchararray.array
    "numpy.core.defchararray.array")(obj[, itemsize, ...]) | Create a [`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray"). |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| [`core.defchararray.array`](generated/numpy.core.defchararray.array.html#numpy.core.defchararray.array
    "numpy.core.defchararray.array")(obj[, itemsize, ...]) | 创建一个[`chararray`](generated/numpy.char.chararray.html#numpy.char.chararray
    "numpy.chararray")。 |'
- en: Another difference with the standard ndarray of str data-type is that the chararray
    inherits the feature introduced by Numarray that white-space at the end of any
    element in the array will be ignored on item retrieval and comparison operations.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 与标准的str数据类型的ndarray的另一个区别是，chararray继承了由Numarray引入的特性，即数组中任何元素末尾的空白将在项检索和比较操作中被忽略。
- en: '## Record arrays (`numpy.rec`)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '## 记录数组 (`numpy.rec`)'
- en: See also
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Creating record arrays (numpy.rec)](routines.array-creation.html#routines-array-creation-rec),
    [Data type routines](routines.dtype.html#routines-dtype), [Data type objects (dtype)](arrays.dtypes.html#arrays-dtypes).'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[创建记录数组 (numpy.rec)](routines.array-creation.html#routines-array-creation-rec)，[数据类型例程](routines.dtype.html#routines-dtype)，[数据类型对象
    (dtype)](arrays.dtypes.html#arrays-dtypes)。'
- en: NumPy provides the [`recarray`](generated/numpy.recarray.html#numpy.recarray
    "numpy.recarray") class which allows accessing the fields of a structured array
    as attributes, and a corresponding scalar data type object [`record`](generated/numpy.record.html#numpy.record
    "numpy.record").
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了[`recarray`](generated/numpy.recarray.html#numpy.recarray "numpy.recarray")类，允许将结构化数组的字段作为属性进行访问，并提供相应的标量数据类型对象[`record`](generated/numpy.record.html#numpy.record
    "numpy.record")。
- en: '| [`recarray`](generated/numpy.recarray.html#numpy.recarray "numpy.recarray")(shape[, dtype, buf, offset, ...])
    | Construct an ndarray that allows field access using attributes. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| [`recarray`](generated/numpy.recarray.html#numpy.recarray "numpy.recarray")(shape[, dtype, buf, offset, ...])
    | 构造一个允许使用属性进行字段访问的ndarray。 |'
- en: '| [`record`](generated/numpy.record.html#numpy.record "numpy.record") | A data-type
    scalar that allows field access as attribute lookup. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| [`record`](generated/numpy.record.html#numpy.record "numpy.record") | 允许字段访问作为属性查找的数据类型标量。
    |'
- en: Masked arrays ([`numpy.ma`](maskedarray.generic.html#module-numpy.ma "numpy.ma"))
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 掩码数组（[`numpy.ma`](maskedarray.generic.html#module-numpy.ma "numpy.ma"))
- en: See also
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Masked arrays](maskedarray.html#maskedarray)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[掩码数组](maskedarray.html#maskedarray)'
- en: Standard container class
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准容器类
- en: For backward compatibility and as a standard “container “class, the UserArray
    from Numeric has been brought over to NumPy and named [`numpy.lib.user_array.container`](generated/numpy.lib.user_array.container.html#numpy.lib.user_array.container
    "numpy.lib.user_array.container") The container class is a Python class whose
    self.array attribute is an ndarray. Multiple inheritance is probably easier with
    numpy.lib.user_array.container than with the ndarray itself and so it is included
    by default. It is not documented here beyond mentioning its existence because
    you are encouraged to use the ndarray class directly if you can.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向后兼容和作为标准的“容器”类，从 Numeric 中带有的 UserArray 已经被移植到 NumPy，并命名为 [`numpy.lib.user_array.container`](generated/numpy.lib.user_array.container.html#numpy.lib.user_array.container
    "numpy.lib.user_array.container") 容器类是一个 Python 类，其 self.array 属性是一个 ndarray。使用
    numpy.lib.user_array.container 可能比直接使用 ndarray 更容易进行多重继承，因此它被默认包含在内。这里没有对其进行文档化，只是提及它的存在，因为鼓励您直接使用
    ndarray 类。
- en: '| [`numpy.lib.user_array.container`](generated/numpy.lib.user_array.container.html#numpy.lib.user_array.container
    "numpy.lib.user_array.container")(data[, ...]) | Standard container-class for
    easy multiple-inheritance. |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| [`numpy.lib.user_array.container`](generated/numpy.lib.user_array.container.html#numpy.lib.user_array.container
    "numpy.lib.user_array.container")(data[, ...]) | 用于轻松多重继承的标准容器类。 |'
- en: '## Array Iterators'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '## 数组迭代器'
- en: 'Iterators are a powerful concept for array processing. Essentially, iterators
    implement a generalized for-loop. If *myiter* is an iterator object, then the
    Python code:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代器是数组处理的一个强大概念。基本上，迭代器实现了一个广义的 for 循环。如果 *myiter* 是一个迭代器对象，那么 Python 代码：
- en: '[PRE30]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'calls `val = next(myiter)` repeatedly until [`StopIteration`](https://docs.python.org/3/library/exceptions.html#StopIteration
    "(in Python v3.11)") is raised by the iterator. There are several ways to iterate
    over an array that may be useful: default iteration, flat iteration, and \(N\)-dimensional
    enumeration.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 重复调用 `val = next(myiter)`，直到迭代器引发 [`StopIteration`](https://docs.python.org/3/library/exceptions.html#StopIteration
    "(在 Python v3.11)")。有几种可能有用的数组迭代方式：默认迭代、平坦迭代和 \(N\)-维枚举。
- en: Default iteration
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认迭代
- en: 'The default iterator of an ndarray object is the default Python iterator of
    a sequence type. Thus, when the array object itself is used as an iterator. The
    default behavior is equivalent to:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray 对象的默认迭代器是序列类型的默认 Python 迭代器。因此，当数组对象本身被用作迭代器时。默认行为等同于：
- en: '[PRE31]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This default iterator selects a sub-array of dimension \(N-1\) from the array.
    This can be a useful construct for defining recursive algorithms. To loop over
    the entire array requires \(N\) for-loops.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这个默认迭代器从数组中选择一个 \(N-1\) 维的子数组。这对于定义递归算法可能是一个有用的构造。要循环整个数组需要 \(N\) 个 for 循环。
- en: '[PRE32]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Flat iteration
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平坦迭代
- en: '| [`ndarray.flat`](generated/numpy.ndarray.flat.html#numpy.ndarray.flat "numpy.ndarray.flat")
    | A 1-D iterator over the array. |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| [`ndarray.flat`](generated/numpy.ndarray.flat.html#numpy.ndarray.flat "numpy.ndarray.flat")
    | 数组上的一维迭代器。 |'
- en: As mentioned previously, the flat attribute of ndarray objects returns an iterator
    that will cycle over the entire array in C-style contiguous order.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，ndarray 对象的 flat 属性返回一个迭代器，该迭代器将以 C 风格连续顺序循环整个数组。
- en: '[PRE33]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, I’ve used the built-in enumerate iterator to return the iterator index
    as well as the value.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我使用了内置的 enumerate 迭代器来返回迭代器索引以及值。
- en: N-dimensional enumeration
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: N维枚举
- en: '| [`ndenumerate`](generated/numpy.ndenumerate.html#numpy.ndenumerate "numpy.ndenumerate")(arr)
    | Multidimensional index iterator. |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| [`ndenumerate`](generated/numpy.ndenumerate.html#numpy.ndenumerate "numpy.ndenumerate")(arr)
    | 多维索引迭代器。 |'
- en: Sometimes it may be useful to get the N-dimensional index while iterating. The
    ndenumerate iterator can achieve this.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在迭代时获取 N 维索引可能很有用。ndenumerate 迭代器可以实现这个功能。
- en: '[PRE34]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Iterator for broadcasting
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于广播的迭代器
- en: '| [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast "numpy.broadcast")
    | Produce an object that mimics broadcasting. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast "numpy.broadcast")
    | 生成一个模仿广播的对象。 |'
- en: The general concept of broadcasting is also available from Python using the
    [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast "numpy.broadcast")
    iterator. This object takes \(N\) objects as inputs and returns an iterator that
    returns tuples providing each of the input sequence elements in the broadcasted
    result.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 也可以实现广播的一般概念，使用 [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast
    "numpy.broadcast") 迭代器。该对象接受 \(N\) 个对象作为输入，并返回一个迭代器，该迭代器在广播结果中提供每个输入序列元素的元组。
- en: '[PRE35]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Default iteration
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认迭代
- en: 'The default iterator of an ndarray object is the default Python iterator of
    a sequence type. Thus, when the array object itself is used as an iterator. The
    default behavior is equivalent to:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray 对象的默认迭代器是序列类型的默认 Python 迭代器。因此，当数组对象本身被用作迭代器时，其默认行为等同于：
- en: '[PRE36]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This default iterator selects a sub-array of dimension \(N-1\) from the array.
    This can be a useful construct for defining recursive algorithms. To loop over
    the entire array requires \(N\) for-loops.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此默认迭代器从数组中选择一个维度为 \(N-1\) 的子数组。这对于定义递归算法可能是一个有用的构造。要遍历整个数组需要 \(N\) 个 for 循环。
- en: '[PRE37]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Flat iteration
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 平面迭代
- en: '| [`ndarray.flat`](generated/numpy.ndarray.flat.html#numpy.ndarray.flat "numpy.ndarray.flat")
    | A 1-D iterator over the array. |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| [`ndarray.flat`](generated/numpy.ndarray.flat.html#numpy.ndarray.flat "numpy.ndarray.flat")
    | 数组的一维迭代器。 |'
- en: As mentioned previously, the flat attribute of ndarray objects returns an iterator
    that will cycle over the entire array in C-style contiguous order.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，ndarray 对象的 flat 属性返回一个迭代器，该迭代器将以 C 风格连续顺序循环遍历整个数组。
- en: '[PRE38]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, I’ve used the built-in enumerate iterator to return the iterator index
    as well as the value.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我已经使用了内置的 enumerate 迭代器来返回迭代器索引以及值。
- en: N-dimensional enumeration
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: N 维枚举
- en: '| [`ndenumerate`](generated/numpy.ndenumerate.html#numpy.ndenumerate "numpy.ndenumerate")(arr)
    | Multidimensional index iterator. |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| [`ndenumerate`](generated/numpy.ndenumerate.html#numpy.ndenumerate "numpy.ndenumerate")(arr)
    | 多维索引迭代器。 |'
- en: Sometimes it may be useful to get the N-dimensional index while iterating. The
    ndenumerate iterator can achieve this.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在迭代时获取 N 维索引可能很有用。ndenumerate 迭代器可以实现这一点。
- en: '[PRE39]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Iterator for broadcasting
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 广播迭代器
- en: '| [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast "numpy.broadcast")
    | Produce an object that mimics broadcasting. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast "numpy.broadcast")
    | 生成一个模拟广播的对象。 |'
- en: The general concept of broadcasting is also available from Python using the
    [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast "numpy.broadcast")
    iterator. This object takes \(N\) objects as inputs and returns an iterator that
    returns tuples providing each of the input sequence elements in the broadcasted
    result.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 也可以实现广播的一般概念，使用 [`broadcast`](generated/numpy.broadcast.html#numpy.broadcast
    "numpy.broadcast") 迭代器。该对象接受 \(N\) 个对象作为输入，并返回一个迭代器，该迭代器在广播结果中提供每个输入序列元素的元组。
- en: '[PRE40]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
