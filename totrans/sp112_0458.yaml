- en: scipy.optimize.newton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.newton.html#scipy.optimize.newton](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.newton.html#scipy.optimize.newton)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find a root of a real or complex function using the Newton-Raphson (or secant
    or Halley’s) method.
  prefs: []
  type: TYPE_NORMAL
- en: Find a root of the scalar-valued function *func* given a nearby scalar starting
    point *x0*. The Newton-Raphson method is used if the derivative *fprime* of *func*
    is provided, otherwise the secant method is used. If the second order derivative
    *fprime2* of *func* is also provided, then Halley’s method is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If *x0* is a sequence with more than one item, [`newton`](#scipy.optimize.newton
    "scipy.optimize.newton") returns an array: the roots of the function from each
    (scalar) starting point in *x0*. In this case, *func* must be vectorized to return
    a sequence or array of the same shape as its first argument. If *fprime* (*fprime2*)
    is given, then its return must also have the same shape: each element is the first
    (second) derivative of *func* with respect to its only variable evaluated at each
    element of its first argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`newton`](#scipy.optimize.newton "scipy.optimize.newton") is for finding roots
    of a scalar-valued functions of a single variable. For problems involving several
    variables, see [`root`](scipy.optimize.root.html#scipy.optimize.root "scipy.optimize.root").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func**callable'
  prefs: []
  type: TYPE_NORMAL
- en: The function whose root is wanted. It must be a function of a single variable
    of the form `f(x,a,b,c...)`, where `a,b,c...` are extra arguments that can be
    passed in the *args* parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '**x0**float, sequence, or ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: An initial estimate of the root that should be somewhere near the actual root.
    If not scalar, then *func* must be vectorized and return a sequence or array of
    the same shape as its first argument.
  prefs: []
  type: TYPE_NORMAL
- en: '**fprime**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The derivative of the function when available and convenient. If it is None
    (default), then the secant method is used.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Extra arguments to be used in the function call.
  prefs: []
  type: TYPE_NORMAL
- en: '**tol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The allowable error of the root’s value. If *func* is complex-valued, a larger
    *tol* is recommended as both the real and imaginary parts of *x* contribute to
    `|x - x0|`.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxiter**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of iterations.
  prefs: []
  type: TYPE_NORMAL
- en: '**fprime2**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The second order derivative of the function when available and convenient. If
    it is None (default), then the normal Newton-Raphson or the secant method is used.
    If it is not None, then Halley’s method is used.
  prefs: []
  type: TYPE_NORMAL
- en: '**x1**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Another estimate of the root that should be somewhere near the actual root.
    Used if *fprime* is not provided.
  prefs: []
  type: TYPE_NORMAL
- en: '**rtol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Tolerance (relative) for termination.
  prefs: []
  type: TYPE_NORMAL
- en: '**full_output**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *full_output* is False (default), the root is returned. If True and *x0*
    is scalar, the return value is `(x, r)`, where `x` is the root and `r` is a [`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") object. If True and *x0* is non-scalar, the return
    value is `(x, converged, zero_der)` (see Returns section for details).
  prefs: []
  type: TYPE_NORMAL
- en: '**disp**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'If True, raise a RuntimeError if the algorithm didn’t converge, with the error
    message containing the number of iterations and current function value. Otherwise,
    the convergence status is recorded in a [`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults") return object. Ignored if *x0* is not scalar. *Note:
    this has little to do with displaying, however, the `disp` keyword cannot be renamed
    for backwards compatibility.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**root**float, sequence, or ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Estimated location where function is zero.
  prefs: []
  type: TYPE_NORMAL
- en: '**r**[`RootResults`](scipy.optimize.RootResults.html#scipy.optimize.RootResults
    "scipy.optimize.RootResults"), optional'
  prefs: []
  type: TYPE_NORMAL
- en: Present if `full_output=True` and *x0* is scalar. Object containing information
    about the convergence. In particular, `r.converged` is True if the routine converged.
  prefs: []
  type: TYPE_NORMAL
- en: '**converged**ndarray of bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Present if `full_output=True` and *x0* is non-scalar. For vector functions,
    indicates which elements converged successfully.
  prefs: []
  type: TYPE_NORMAL
- en: '**zero_der**ndarray of bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Present if `full_output=True` and *x0* is non-scalar. For vector functions,
    indicates which elements had a zero derivative.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`root_scalar`](scipy.optimize.root_scalar.html#scipy.optimize.root_scalar
    "scipy.optimize.root_scalar")'
  prefs: []
  type: TYPE_NORMAL
- en: interface to root solvers for scalar functions
  prefs: []
  type: TYPE_NORMAL
- en: '[`root`](scipy.optimize.root.html#scipy.optimize.root "scipy.optimize.root")'
  prefs: []
  type: TYPE_NORMAL
- en: interface to root solvers for multi-input, multi-output functions
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The convergence rate of the Newton-Raphson method is quadratic, the Halley method
    is cubic, and the secant method is sub-quadratic. This means that if the function
    is well-behaved the actual error in the estimated root after the nth iteration
    is approximately the square (cube for Halley) of the error after the (n-1)th step.
    However, the stopping criterion used here is the step size and there is no guarantee
    that a root has been found. Consequently, the result should be verified. Safer
    algorithms are brentq, brenth, ridder, and bisect, but they all require that the
    root first be bracketed in an interval where the function changes sign. The brentq
    algorithm is recommended for general use in one dimensional problems when such
    an interval has been found.
  prefs: []
  type: TYPE_NORMAL
- en: 'When [`newton`](#scipy.optimize.newton "scipy.optimize.newton") is used with
    arrays, it is best suited for the following types of problems:'
  prefs: []
  type: TYPE_NORMAL
- en: The initial guesses, *x0*, are all relatively the same distance from the roots.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some or all of the extra arguments, *args*, are also arrays so that a class
    of similar problems can be solved together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The size of the initial guesses, *x0*, is larger than O(100) elements. Otherwise,
    a naive loop may perform as well or better than a vector.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`fprime` is not provided, use the secant method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Only `fprime` is provided, use the Newton-Raphson method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `fprime2` and `fprime` are provided, use Halley’s method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When we want to find roots for a set of related starting values and/or function
    parameters, we can provide both of those as an array of inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The above is the equivalent of solving for each value in `(x, a)` separately
    in a for-loop, just faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Plot the results found for all values of `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-optimize-newton-1.png](../Images/b8ff7b8af48e693b633f817523785ff1.png)'
  prefs: []
  type: TYPE_IMG
