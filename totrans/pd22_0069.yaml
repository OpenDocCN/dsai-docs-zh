- en: pandas.read_json
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/reference/api/pandas.read_json.html](https://pandas.pydata.org/docs/reference/api/pandas.read_json.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Convert a JSON string to pandas object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**path_or_buf**a valid JSON str, path object or file-like object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Any valid string path is acceptable. The string could be a URL. Valid URL schemes
    include http, ftp, s3, and file. For file URLs, a host is expected. A local file
    could be: `file://localhost/path/to/table.json`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to pass in a path object, pandas accepts any `os.PathLike`.
  prefs: []
  type: TYPE_NORMAL
- en: By file-like object, we refer to objects with a `read()` method, such as a file
    handle (e.g. via builtin `open` function) or `StringIO`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 2.1.0: Passing json literal strings is deprecated.'
  prefs: []
  type: TYPE_NORMAL
- en: '**orient**str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indication of expected JSON string format. Compatible JSON strings can be produced
    by `to_json()` with a corresponding orient value. The set of possible orients
    is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''split''` : dict like `{index -> [index], columns -> [columns], data -> [values]}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''records''` : list like `[{column -> value}, ... , {column -> value}]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''index''` : dict like `{index -> {column -> value}}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''columns''` : dict like `{column -> {index -> value}}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''values''` : just the values array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''table''` : dict like `{''schema'': {schema}, ''data'': {data}}`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The allowed and default values depend on the value of the typ parameter.
  prefs: []
  type: TYPE_NORMAL
- en: when `typ == 'series'`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: allowed orients are `{'split','records','index'}`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: default is `'index'`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Series index must be unique for orient `'index'`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: when `typ == 'frame'`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: allowed orients are `{'split','records','index', 'columns','values', 'table'}`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: default is `'columns'`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The DataFrame index must be unique for orients `'index'` and `'columns'`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The DataFrame columns must be unique for orients `'index'`, `'columns'`, and
    `'records'`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**typ**{‘frame’, ‘series’}, default ‘frame’'
  prefs: []
  type: TYPE_NORMAL
- en: The type of object to recover.
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype**bool or dict, default None'
  prefs: []
  type: TYPE_NORMAL
- en: If True, infer dtypes; if a dict of column to dtype, then use those; if False,
    then don’t infer dtypes at all, applies only to the data.
  prefs: []
  type: TYPE_NORMAL
- en: For all `orient` values except `'table'`, default is True.
  prefs: []
  type: TYPE_NORMAL
- en: '**convert_axes**bool, default None'
  prefs: []
  type: TYPE_NORMAL
- en: Try to convert the axes to the proper dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: For all `orient` values except `'table'`, default is True.
  prefs: []
  type: TYPE_NORMAL
- en: '**convert_dates**bool or list of str, default True'
  prefs: []
  type: TYPE_NORMAL
- en: If True then default datelike columns may be converted (depending on keep_default_dates).
    If False, no dates will be converted. If a list of column names, then those columns
    will be converted and default datelike columns may also be converted (depending
    on keep_default_dates).
  prefs: []
  type: TYPE_NORMAL
- en: '**keep_default_dates**bool, default True'
  prefs: []
  type: TYPE_NORMAL
- en: If parsing dates (convert_dates is not False), then try to parse the default
    datelike columns. A column label is datelike if
  prefs: []
  type: TYPE_NORMAL
- en: it ends with `'_at'`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it ends with `'_time'`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it begins with `'timestamp'`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it is `'modified'`, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: it is `'date'`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**precise_float**bool, default False'
  prefs: []
  type: TYPE_NORMAL
- en: Set to enable usage of higher precision (strtod) function when decoding string
    to double values. Default (False) is to use fast but less precise builtin functionality.
  prefs: []
  type: TYPE_NORMAL
- en: '**date_unit**str, default None'
  prefs: []
  type: TYPE_NORMAL
- en: The timestamp unit to detect if converting dates. The default behaviour is to
    try and detect the correct precision, but if this is not desired then pass one
    of ‘s’, ‘ms’, ‘us’ or ‘ns’ to force parsing only seconds, milliseconds, microseconds
    or nanoseconds respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '**encoding**str, default is ‘utf-8’'
  prefs: []
  type: TYPE_NORMAL
- en: The encoding to use to decode py3 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**encoding_errors**str, optional, default “strict”'
  prefs: []
  type: TYPE_NORMAL
- en: How encoding errors are treated. [List of possible values](https://docs.python.org/3/library/codecs.html#error-handlers)
    .
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**lines**bool, default False'
  prefs: []
  type: TYPE_NORMAL
- en: Read the file as a json object per line.
  prefs: []
  type: TYPE_NORMAL
- en: '**chunksize**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Return JsonReader object for iteration. See the [line-delimited json docs](https://pandas.pydata.org/pandas-docs/stable/user_guide/io.html#line-delimited-json)
    for more information on `chunksize`. This can only be passed if lines=True. If
    this is None, the file will be read into memory all at once.
  prefs: []
  type: TYPE_NORMAL
- en: '**compression**str or dict, default ‘infer’'
  prefs: []
  type: TYPE_NORMAL
- en: 'For on-the-fly decompression of on-disk data. If ‘infer’ and ‘path_or_buf’
    is path-like, then detect compression from the following extensions: ‘.gz’, ‘.bz2’,
    ‘.zip’, ‘.xz’, ‘.zst’, ‘.tar’, ‘.tar.gz’, ‘.tar.xz’ or ‘.tar.bz2’ (otherwise no
    compression). If using ‘zip’ or ‘tar’, the ZIP file must contain only one data
    file to be read in. Set to `None` for no decompression. Can also be a dict with
    key `''method''` set to one of {`''zip''`, `''gzip''`, `''bz2''`, `''zstd''`,
    `''xz''`, `''tar''`} and other key-value pairs are forwarded to `zipfile.ZipFile`,
    `gzip.GzipFile`, `bz2.BZ2File`, `zstandard.ZstdDecompressor`, `lzma.LZMAFile`
    or `tarfile.TarFile`, respectively. As an example, the following could be passed
    for Zstandard decompression using a custom compression dictionary: `compression={''method'':
    ''zstd'', ''dict_data'': my_compression_dict}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.5.0: Added support for .tar files.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.0: Zstandard support.'
  prefs: []
  type: TYPE_NORMAL
- en: '**nrows**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The number of lines from the line-delimited jsonfile that has to be read. This
    can only be passed if lines=True. If this is None, all the rows will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '**storage_options**dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Extra options that make sense for a particular storage connection, e.g. host,
    port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded
    to `urllib.request.Request` as header options. For other URLs (e.g. starting with
    “s3://”, and “gcs://”) the key-value pairs are forwarded to `fsspec.open`. Please
    see `fsspec` and `urllib` for more details, and for more examples on storage options
    refer [here](https://pandas.pydata.org/docs/user_guide/io.html?highlight=storage_options#reading-writing-remote-files).
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype_backend**{‘numpy_nullable’, ‘pyarrow’}, default ‘numpy_nullable’'
  prefs: []
  type: TYPE_NORMAL
- en: 'Back-end data type applied to the resultant [`DataFrame`](pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") (still experimental). Behaviour is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"numpy_nullable"`: returns nullable-dtype-backed [`DataFrame`](pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") (default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"pyarrow"`: returns pyarrow-backed nullable [`ArrowDtype`](pandas.ArrowDtype.html#pandas.ArrowDtype
    "pandas.ArrowDtype") DataFrame.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**engine**{“ujson”, “pyarrow”}, default “ujson”'
  prefs: []
  type: TYPE_NORMAL
- en: Parser engine to use. The `"pyarrow"` engine is only available when `lines=True`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Series, DataFrame, or pandas.api.typing.JsonReader
  prefs: []
  type: TYPE_NORMAL
- en: A JsonReader is returned when `chunksize` is not `0` or `None`. Otherwise, the
    type returned depends on the value of `typ`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.to_json`](pandas.DataFrame.to_json.html#pandas.DataFrame.to_json
    "pandas.DataFrame.to_json")'
  prefs: []
  type: TYPE_NORMAL
- en: Convert a DataFrame to a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series.to_json`](pandas.Series.to_json.html#pandas.Series.to_json "pandas.Series.to_json")'
  prefs: []
  type: TYPE_NORMAL
- en: Convert a Series to a JSON string.
  prefs: []
  type: TYPE_NORMAL
- en: '[`json_normalize`](pandas.json_normalize.html#pandas.json_normalize "pandas.json_normalize")'
  prefs: []
  type: TYPE_NORMAL
- en: Normalize semi-structured JSON data into a flat table.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Specific to `orient='table'`, if a [`DataFrame`](pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") with a literal [`Index`](pandas.Index.html#pandas.Index "pandas.Index")
    name of index gets written with `to_json()`, the subsequent read operation will
    incorrectly set the [`Index`](pandas.Index.html#pandas.Index "pandas.Index") name
    to `None`. This is because index is also used by [`DataFrame.to_json()`](pandas.DataFrame.to_json.html#pandas.DataFrame.to_json
    "pandas.DataFrame.to_json") to denote a missing [`Index`](pandas.Index.html#pandas.Index
    "pandas.Index") name, and the subsequent [`read_json()`](#pandas.read_json "pandas.read_json")
    operation cannot distinguish between the two. The same limitation is encountered
    with a [`MultiIndex`](pandas.MultiIndex.html#pandas.MultiIndex "pandas.MultiIndex")
    and any names beginning with `'level_'`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Encoding/decoding a Dataframe using `''split''` formatted JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Encoding/decoding a Dataframe using `''index''` formatted JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Encoding/decoding a Dataframe using `'records'` formatted JSON. Note that index
    labels are not preserved with this encoding.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Encoding with Table Schema
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The following example uses `dtype_backend="numpy_nullable"`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
