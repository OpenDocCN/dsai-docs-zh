- en: NumPy 1.17.0 Release Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/release/1.17.0-notes.html](https://numpy.org/doc/1.26/release/1.17.0-notes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This NumPy release contains a number of new features that should substantially
    improve its performance and usefulness, see Highlights below for a summary. The
    Python versions supported are 3.5-3.7, note that Python 2.7 has been dropped.
    Python 3.8b2 should work with the released source packages, but there are no future
    guarantees.
  prefs: []
  type: TYPE_NORMAL
- en: Downstream developers should use Cython >= 0.29.11 for Python 3.8 support and
    OpenBLAS >= 3.7 (not currently out) to avoid problems on the Skylake architecture.
    The NumPy wheels on PyPI are built from the OpenBLAS development branch in order
    to avoid those problems.
  prefs: []
  type: TYPE_NORMAL
- en: Highlights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A new extensible [`random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module along with four selectable *random number generators* and
    improved seeding designed for use in parallel processes has been added. The currently
    available bit generators are *MT19937*, *PCG64*, *Philox*, and *SFC64*. See below
    under New Features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy’s [`FFT`](../reference/routines.fft.html#module-numpy.fft "numpy.fft")
    implementation was changed from fftpack to pocketfft, resulting in faster, more
    accurate transforms and better handling of datasets of prime length. See below
    under Improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New radix sort and timsort sorting methods. It is currently not possible to
    choose which will be used. They are hardwired to the datatype and used when either
    `stable` or `mergesort` is passed as the method. See below under Improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding numpy functions is now possible by default, see `__array_function__`
    below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate") is now also a function decorator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") functions warn when passed `float` in place of `int`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously functions in this module would accept `float` values provided they
    were integral (`1.0`, `2.0`, etc). For consistency with the rest of numpy, doing
    so is now deprecated, and in future will raise a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, passing a float like `0.5` in place of an integer will now raise
    a `TypeError` instead of the previous `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecate [`numpy.distutils.exec_command`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") and `temp_file_name`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The internal use of these functions has been refactored and there are better
    alternatives. Replace `exec_command` with [`subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen
    "(in Python v3.11)") and [`temp_file_name`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") with [`tempfile.mkstemp`](https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: Writeable flag of C-API wrapped arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an array is created from the C-API to wrap a pointer to data, the only
    indication we have of the read-write nature of the data is the `writeable` flag
    set during creation. It is dangerous to force the flag to writeable. In the future
    it will not be possible to switch the writeable flag to `True` from python. This
    deprecation should not affect many users since arrays created in such a manner
    are very rare in practice and only available through the NumPy C-API.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero "numpy.nonzero")
    should no longer be called on 0d arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The behavior of [`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero") on 0d arrays was surprising, making uses of it almost always
    incorrect. If the old behavior was intended, it can be preserved without a warning
    by using `nonzero(atleast_1d(arr))` instead of `nonzero(arr)`. In a future release,
    it is most likely this will raise a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the result of [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") will warn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Commonly [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") returns a writeable array with internal overlap, making
    it unsafe to write to. A future version will set the `writeable` flag to `False`,
    and require users to manually set it to `True` if they are sure that is what they
    want to do. Now writing to it will emit a deprecation warning with instructions
    to set the `writeable` flag `True`. Note that if one were to inspect the flag
    before setting it, one would find it would already be `True`. Explicitly setting
    it, though, as one will need to do in future versions, clears an internal flag
    that is used to produce the deprecation warning. To help alleviate confusion,
    an additional *FutureWarning* will be emitted when accessing the `writeable` flag
    state to clarify the contradiction.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for the C-side buffer protocol such an array will return a readonly
    buffer immediately unless a writable buffer is requested. If a writeable buffer
    is requested a warning will be given. When using cython, the `const` qualifier
    should be used with such arrays to avoid the warning (e.g. `cdef const double[::1]
    view`).
  prefs: []
  type: TYPE_NORMAL
- en: Future Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shape-1 fields in dtypes won’t be collapsed to scalars in a future version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, a field specified as `[(name, dtype, 1)]` or `"1type"` is interpreted
    as a scalar field (i.e., the same as `[(name, dtype)]` or `[(name, dtype, ()]`).
    This now raises a FutureWarning; in a future version, it will be interpreted as
    a shape-(1,) field, i.e. the same as `[(name, dtype, (1,))]` or `"(1,)type"` (consistently
    with `[(name, dtype, n)]` / `"ntype"` with `n>1`, which is already equivalent
    to `[(name, dtype, (n,)]` / `"(n,)type"`).
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`float16` subnormal rounding'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Casting from a different floating point precision to `float16` used incorrect
    rounding in some edge cases. This means in rare cases, subnormal results will
    now be rounded up instead of down, changing the last bit (ULP) of the result.
  prefs: []
  type: TYPE_NORMAL
- en: Signed zero when using divmod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting in version *1.12.0*, numpy incorrectly returned a negatively signed
    zero when using the `divmod` and `floor_divide` functions when the result was
    zero. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With this release, the result is correctly returned as a positively signed
    zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`MaskedArray.mask` now returns a view of the mask, not the mask itself'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returning the mask itself was unsafe, as it could be reshaped in place which
    would violate expectations of the masked array code. The behavior of [`mask`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") is now consistent with [`data`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data"), which also returns a view.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying mask can still be accessed with `._mask` if it is needed. Tests
    that contain `assert x.mask is not y.mask` or similar will need to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Do not lookup `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Looking up `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer") was undocumented and non-functional. This code was removed.
    If needed, use `frombuffer(memoryview(obj), ...)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`out` is buffered for memory overlaps in [`take`](../reference/generated/numpy.take.html#numpy.take
    "numpy.take"), [`choose`](../reference/generated/numpy.choose.html#numpy.choose
    "numpy.choose"), [`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the out argument to these functions is provided and has memory overlap with
    the other arguments, it is now buffered to avoid order-dependent behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Unpickling while loading requires explicit opt-in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions [`load`](../reference/generated/numpy.load.html#numpy.load "numpy.load"),
    and `lib.format.read_array` take an `allow_pickle` keyword which now defaults
    to `False` in response to [CVE-2019-6446](https://nvd.nist.gov/vuln/detail/CVE-2019-6446).
  prefs: []
  type: TYPE_NORMAL
- en: Potential changes to the random stream in old random module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to bugs in the application of `log` to random floating point numbers, the
    stream may change when sampling from [`beta`](../reference/random/generated/numpy.random.RandomState.beta.html#numpy.random.RandomState.beta
    "numpy.random.RandomState.beta"), [`binomial`](../reference/random/generated/numpy.random.RandomState.binomial.html#numpy.random.RandomState.binomial
    "numpy.random.RandomState.binomial"), [`laplace`](../reference/random/generated/numpy.random.RandomState.laplace.html#numpy.random.RandomState.laplace
    "numpy.random.RandomState.laplace"), [`logistic`](../reference/random/generated/numpy.random.RandomState.logistic.html#numpy.random.RandomState.logistic
    "numpy.random.RandomState.logistic"), [`logseries`](../reference/random/generated/numpy.random.RandomState.logseries.html#numpy.random.RandomState.logseries
    "numpy.random.RandomState.logseries") or [`multinomial`](../reference/random/generated/numpy.random.RandomState.multinomial.html#numpy.random.RandomState.multinomial
    "numpy.random.RandomState.multinomial") if a `0` is generated in the underlying
    [`MT19937`](../reference/random/bit_generators/mt19937.html#numpy.random.MT19937
    "numpy.random.MT19937") random stream. There is a `1` in \(10^{53}\) chance of
    this occurring, so the probability that the stream changes for any given seed
    is extremely small. If a `0` is encountered in the underlying generator, then
    the incorrect value produced (either [`numpy.inf`](../reference/constants.html#numpy.inf
    "numpy.inf") or [`numpy.nan`](../reference/constants.html#numpy.nan "numpy.nan"))
    is now dropped.
  prefs: []
  type: TYPE_NORMAL
- en: '[`i0`](../reference/generated/numpy.i0.html#numpy.i0 "numpy.i0") now always
    returns a result with the same shape as the input'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, the output was squeezed, such that, e.g., input with just a single
    element would lead to an array scalar being returned, and inputs with shapes such
    as `(10, 1)` would yield results that would not broadcast against the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we generally recommend the SciPy implementation over the numpy one:
    it is a proper ufunc written in C, and more than an order of magnitude faster.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast "numpy.can_cast")
    no longer assumes all unsafe casting is allowed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, [`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast
    "numpy.can_cast") returned *True* for almost all inputs for `casting='unsafe'`,
    even for cases where casting was not possible, such as from a structured dtype
    to a regular one. This has been fixed, making it more consistent with actual casting
    using, e.g., the [`.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype") method.
  prefs: []
  type: TYPE_NORMAL
- en: '`ndarray.flags.writeable` can be switched to true slightly more often'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In rare cases, it was not possible to switch an array from not writeable to
    writeable, although a base array is writeable. This can happen if an intermediate
    [`ndarray.base`](../reference/generated/numpy.ndarray.base.html#numpy.ndarray.base
    "numpy.ndarray.base") object is writeable. Previously, only the deepest base object
    was considered for this decision. However, in rare cases this object does not
    have the necessary information. In that case switching to writeable was never
    allowed. This has now been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: C API changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: dimension or stride input arguments are now passed by `npy_intp const*`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously these function arguments were declared as the more strict `npy_intp*`,
    which prevented the caller passing constant data. This change is backwards compatible,
    but now allows code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module with selectable random number generators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module along with four selectable random number generators and
    improved seeding designed for use in parallel processes has been added. The currently
    available *Bit Generators* are *MT19937*, *PCG64*, *Philox*, and *SFC64*. `PCG64`
    is the new default while `MT19937` is retained for backwards compatibility. Note
    that the legacy random module is unchanged and is now frozen, your current results
    will not change. More information is available in the [API change description](../reference/random/new-or-different.html#new-or-different)
    and in the [`top-level view`](../reference/random/index.html#module-numpy.random
    "numpy.random") documentation.
  prefs: []
  type: TYPE_NORMAL
- en: libFLAME
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for building NumPy with the libFLAME linear algebra package as the LAPACK,
    implementation, see [libFLAME](https://www.cs.utexas.edu/~flame/web/libFLAME.html)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined BLAS detection order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    now uses an environment variable, comma-separated and case insensitive, to determine
    the detection order for BLAS libraries. By default `NPY_BLAS_ORDER=mkl,blis,openblas,atlas,accelerate,blas`.
    However, to force the use of OpenBLAS simply do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined LAPACK detection order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`numpy.distutils` now uses an environment variable, comma-separated and case
    insensitive, to determine the detection order for LAPACK libraries. By default
    `NPY_LAPACK_ORDER=mkl,openblas,flame,atlas,accelerate,lapack`. However, to force
    the use of OpenBLAS simply do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce") and related functions now accept a `where` mask'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce"), [`sum`](../reference/generated/numpy.sum.html#numpy.sum
    "numpy.sum"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min"), [`max`](../reference/generated/numpy.max.html#numpy.max
    "numpy.max") all now accept a `where` keyword argument, which can be used to tell
    which elements to include in the reduction. For reductions that do not have an
    identity, it is necessary to also pass in an initial value (e.g., `initial=np.inf`
    for [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min")). For
    instance, the equivalent of [`nansum`](../reference/generated/numpy.nansum.html#numpy.nansum
    "numpy.nansum") would be `np.sum(a, where=~np.isnan(a))`.'
  prefs: []
  type: TYPE_NORMAL
- en: Timsort and radix sort have replaced mergesort for stable sorting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both radix sort and timsort have been implemented and are now used in place
    of mergesort. Due to the need to maintain backward compatibility, the sorting
    `kind` options `"stable"` and `"mergesort"` have been made aliases of each other
    with the actual sort implementation depending on the array type. Radix sort is
    used for small integer types of 16 bits or less and timsort for the remaining
    types. Timsort features improved performance on data containing already or nearly
    sorted data and performs like mergesort on random data and requires \(O(n/2)\)
    working space. Details of the timsort algorithm can be found at [CPython listsort.txt](https://github.com/python/cpython/blob/3.7/Objects/listsort.txt).
  prefs: []
  type: TYPE_NORMAL
- en: '[`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits "numpy.packbits")
    and [`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") accept an `order` keyword'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `order` keyword defaults to `big`, and will order the **bits** accordingly.
    For `'order=big'` 3 will become `[0, 0, 0, 0, 0, 0, 1, 1]`, and `[1, 1, 0, 0,
    0, 0, 0, 0]` for `order=little`
  prefs: []
  type: TYPE_NORMAL
- en: '[`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") now accepts a `count` parameter'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`count` allows subsetting the number of bits that will be unpacked up-front,
    rather than reshaping and subsetting later, making the [`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits
    "numpy.packbits") operation invertible, and the unpacking less wasteful. Counts
    larger than the number of available bits add zero padding. Negative counts trim
    bits off the end instead of counting from the beginning. None counts implement
    the existing behavior of unpacking everything.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd") and [`linalg.pinv`](../reference/generated/numpy.linalg.pinv.html#numpy.linalg.pinv
    "numpy.linalg.pinv") can be faster on hermitian inputs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These functions now accept a `hermitian` argument, matching the one added to
    [`linalg.matrix_rank`](../reference/generated/numpy.linalg.matrix_rank.html#numpy.linalg.matrix_rank
    "numpy.linalg.matrix_rank") in 1.14.0.
  prefs: []
  type: TYPE_NORMAL
- en: divmod operation is now supported for two `timedelta64` operands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The divmod operator now handles two `timedelta64` operands, with type signature
    `mm->qm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile")
    now takes an `offset` argument'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function now takes an `offset` keyword argument for binary files, which
    specifics the offset (in bytes) from the file’s current position. Defaults to
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: New mode “empty” for [`pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This mode pads an array to a desired shape without initializing the new entries.
  prefs: []
  type: TYPE_NORMAL
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like") and related functions now accept a `shape` argument'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`full_like`](../reference/generated/numpy.full_like.html#numpy.full_like
    "numpy.full_like"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like") and [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like") now accept a `shape` keyword argument, which can be used to
    create a new array as the prototype, overriding its shape as well. This is particularly
    useful when combined with the `__array_function__` protocol, allowing the creation
    of new arbitrary-shape arrays from NumPy-like libraries when such an array is
    used as the prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: Floating point scalars implement `as_integer_ratio` to match the builtin float
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This returns a (numerator, denominator) pair, which can be used to construct
    a [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: Structured `dtype` objects can be indexed with multiple fields names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr.dtype[[''a'', ''b'']]` now returns a dtype that is equivalent to `arr[[''a'',
    ''b'']].dtype`, for consistency with `arr.dtype[''a''] == arr[''a''].dtype`.'
  prefs: []
  type: TYPE_NORMAL
- en: Like the dtype of structured arrays indexed with a list of fields, this dtype
    has the same `itemsize` as the original, but only keeps a subset of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: This means that `arr[['a', 'b']]` and `arr.view(arr.dtype[['a', 'b']])` are
    equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`.npy` files support unicode field names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new format version of 3.0 has been introduced, which enables structured types
    with non-latin1 field names. This is used automatically when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array comparison assertions include maximum differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Error messages from array comparison tests such as [`testing.assert_allclose`](../reference/generated/numpy.testing.assert_allclose.html#numpy.testing.assert_allclose
    "numpy.testing.assert_allclose") now include “max absolute difference” and “max
    relative difference,” in addition to the previous “mismatch” percentage. This
    information makes it easier to update absolute and relative error tolerances.
  prefs: []
  type: TYPE_NORMAL
- en: Replacement of the fftpack based [`fft`](../reference/routines.fft.html#module-numpy.fft
    "numpy.fft") module by the pocketfft library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both implementations have the same ancestor (Fortran77 FFTPACK by Paul N. Swarztrauber),
    but pocketfft contains additional modifications which improve both accuracy and
    performance in some circumstances. For FFT lengths containing large prime factors,
    pocketfft uses Bluestein’s algorithm, which maintains \(O(N log N)\) run time
    complexity instead of deteriorating towards \(O(N*N)\) for prime lengths. Also,
    accuracy for real valued FFTs with near prime lengths has improved and is on par
    with complex valued FFTs.
  prefs: []
  type: TYPE_NORMAL
- en: Further improvements to `ctypes` support in [`numpy.ctypeslib`](../reference/routines.ctypeslib.html#module-numpy.ctypeslib
    "numpy.ctypeslib")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new [`numpy.ctypeslib.as_ctypes_type`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes_type
    "numpy.ctypeslib.as_ctypes_type") function has been added, which can be used to
    converts a [`dtype`](../reference/generated/numpy.dtype.html#numpy.dtype "numpy.dtype")
    into a best-guess [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.11)") type. Thanks to this new function, [`numpy.ctypeslib.as_ctypes`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes
    "numpy.ctypeslib.as_ctypes") now supports a much wider range of array types, including
    structures, booleans, and integers of non-native endianness.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate") is now also a function decorator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, if you have a function like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'and you want to wrap the whole thing in [`errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate"), you have to rewrite it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'but with this change, you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: thereby saving a level of indentation
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp")
    and [`numpy.log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    speed up for float32 implementation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: float32 implementation of [`exp`](../reference/generated/numpy.exp.html#numpy.exp
    "numpy.exp") and [`log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    now benefit from AVX2/AVX512 instruction set which are detected during runtime.
    [`exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp") has a max
    ulp error of 2.52 and [`log`](../reference/generated/numpy.log.html#numpy.log
    "numpy.log") has a max ulp error or 3.83.
  prefs: []
  type: TYPE_NORMAL
- en: Improve performance of [`numpy.pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The performance of the function has been improved for most cases by filling
    in a preallocated array with the desired padded shape instead of using concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.interp`](../reference/generated/numpy.interp.html#numpy.interp "numpy.interp")
    handles infinities more robustly'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases where [`interp`](../reference/generated/numpy.interp.html#numpy.interp
    "numpy.interp") would previously return [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"), it now returns an appropriate infinity.
  prefs: []
  type: TYPE_NORMAL
- en: Pathlib support for [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile"), *tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile"),
    *ndarray.ndarray.tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump") now support the [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path
    "(in Python v3.11)") type for the `file`/`fid` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Specialized [`isnan`](../reference/generated/numpy.isnan.html#numpy.isnan "numpy.isnan"),
    [`isinf`](../reference/generated/numpy.isinf.html#numpy.isinf "numpy.isinf"),
    and [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    ufuncs for bool and int types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The boolean and integer types are incapable of storing [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan") and [`inf`](../reference/constants.html#numpy.inf "numpy.inf") values,
    which allows us to provide specialized ufuncs that are up to 250x faster than
    the previous approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    supports `datetime64` and `timedelta64` types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite
    "numpy.isfinite") used to raise a *TypeError* on being used on these two types.
  prefs: []
  type: TYPE_NORMAL
- en: New keywords added to [`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num") now accepts keywords `nan`, `posinf` and `neginf` allowing
    the user to define the value to replace the `nan`, positive and negative `np.inf`
    values respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: MemoryErrors caused by allocated overly large arrays are more descriptive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often the cause of a MemoryError is incorrect broadcasting, which results in
    a very large and incorrect shape. The message of the error now includes this shape
    to help diagnose the cause of failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor"),
    [`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil "numpy.ceil"), and
    [`trunc`](../reference/generated/numpy.trunc.html#numpy.trunc "numpy.trunc") now
    respect builtin magic methods'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These ufuncs now call the `__floor__`, `__ceil__`, and `__trunc__` methods when
    called on object arrays, making them compatible with [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") and [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[`quantile`](../reference/generated/numpy.quantile.html#numpy.quantile "numpy.quantile")
    now works on *fraction.Fraction* and [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, this handles object arrays more gracefully, and avoids floating-
    point operations if exact arithmetic types are used.
  prefs: []
  type: TYPE_NORMAL
- en: Support of object arrays in [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is now possible to use [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul") (or the `@` operator) with object arrays. For instance, it is
    now possible to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median")
    and [`percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile") family of functions no longer warn about `nan`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`numpy.median`](../reference/generated/numpy.median.html#numpy.median "numpy.median"),
    [`numpy.percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile"), and [`numpy.quantile`](../reference/generated/numpy.quantile.html#numpy.quantile
    "numpy.quantile") used to emit a `RuntimeWarning` when encountering an [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"). Since they return the `nan` value, the warning is redundant and
    has been removed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`timedelta64 % 0` behavior adjusted to return `NaT`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The modulus operation with two `np.timedelta64` operands now returns `NaT` in
    the case of division by zero, rather than returning zero
  prefs: []
  type: TYPE_NORMAL
- en: NumPy functions now always support overrides with `__array_function__`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy now always checks the `__array_function__` method to implement overrides
    of NumPy functions on non-NumPy arrays, as described in [NEP 18](http://www.numpy.org/neps/nep-0018-array-function-protocol.html).
    The feature was available for testing with NumPy 1.16 if appropriate environment
    variables are set, but is now always enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '`lib.recfunctions.structured_to_unstructured` does not squeeze single-field
    views'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `structured_to_unstructured(arr[['a']])` would produce a squeezed
    result inconsistent with `structured_to_unstructured(arr[['a', b']])`. This was
    accidental. The old behavior can be retained with `structured_to_unstructured(arr[['a']]).squeeze(axis=-1)`
    or far more simply, `arr['a']`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip") now
    uses a ufunc under the hood'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that registering clip functions for custom dtypes in C via `descr->f->fastclip`
    is deprecated - they should use the ufunc registration mechanism instead, attaching
    to the `np.core.umath.clip` ufunc.
  prefs: []
  type: TYPE_NORMAL
- en: It also means that `clip` accepts `where` and `casting` arguments, and can be
    override with `__array_ufunc__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A consequence of this change is that some behaviors of the old `clip` have
    been deprecated:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing `nan` to mean “do not clip” as one or both bounds. This didn’t work
    in all cases anyway, and can be better handled by passing infinities of the appropriate
    sign.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using “unsafe” casting by default when an `out` argument is passed. Using `casting="unsafe"`
    explicitly will silence this warning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are some corner cases with behavior changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Padding `max < min` has changed to be more consistent across dtypes, but should
    not be relied upon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar `min` and `max` take part in promotion rules like they do in all other
    ufuncs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__array_interface__` offset now works as documented'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interface may use an `offset` value that was mistakenly ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Pickle protocol in [`savez`](../reference/generated/numpy.savez.html#numpy.savez
    "numpy.savez") set to 3 for `force zip64` flag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`savez`](../reference/generated/numpy.savez.html#numpy.savez "numpy.savez")
    was not using the `force_zip64` flag, which limited the size of the archive to
    2GB. But using the flag requires us to use pickle protocol 3 to write `object`
    arrays. The protocol used was bumped to 3, meaning the archive will be unreadable
    by Python2.'
  prefs: []
  type: TYPE_NORMAL
- en: Structured arrays indexed with non-existent fields raise `KeyError` not `ValueError`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr[''bad_field'']` on a structured type raises `KeyError`, for consistency
    with `dict[''bad_field'']`.'
  prefs: []
  type: TYPE_NORMAL
- en: Highlights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A new extensible [`random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module along with four selectable *random number generators* and
    improved seeding designed for use in parallel processes has been added. The currently
    available bit generators are *MT19937*, *PCG64*, *Philox*, and *SFC64*. See below
    under New Features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy’s [`FFT`](../reference/routines.fft.html#module-numpy.fft "numpy.fft")
    implementation was changed from fftpack to pocketfft, resulting in faster, more
    accurate transforms and better handling of datasets of prime length. See below
    under Improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New radix sort and timsort sorting methods. It is currently not possible to
    choose which will be used. They are hardwired to the datatype and used when either
    `stable` or `mergesort` is passed as the method. See below under Improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding numpy functions is now possible by default, see `__array_function__`
    below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate") is now also a function decorator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") functions warn when passed `float` in place of `int`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously functions in this module would accept `float` values provided they
    were integral (`1.0`, `2.0`, etc). For consistency with the rest of numpy, doing
    so is now deprecated, and in future will raise a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, passing a float like `0.5` in place of an integer will now raise
    a `TypeError` instead of the previous `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecate [`numpy.distutils.exec_command`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") and `temp_file_name`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The internal use of these functions has been refactored and there are better
    alternatives. Replace `exec_command` with [`subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen
    "(in Python v3.11)") and [`temp_file_name`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") with [`tempfile.mkstemp`](https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: Writeable flag of C-API wrapped arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an array is created from the C-API to wrap a pointer to data, the only
    indication we have of the read-write nature of the data is the `writeable` flag
    set during creation. It is dangerous to force the flag to writeable. In the future
    it will not be possible to switch the writeable flag to `True` from python. This
    deprecation should not affect many users since arrays created in such a manner
    are very rare in practice and only available through the NumPy C-API.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero "numpy.nonzero")
    should no longer be called on 0d arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The behavior of [`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero") on 0d arrays was surprising, making uses of it almost always
    incorrect. If the old behavior was intended, it can be preserved without a warning
    by using `nonzero(atleast_1d(arr))` instead of `nonzero(arr)`. In a future release,
    it is most likely this will raise a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the result of [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") will warn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Commonly [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") returns a writeable array with internal overlap, making
    it unsafe to write to. A future version will set the `writeable` flag to `False`,
    and require users to manually set it to `True` if they are sure that is what they
    want to do. Now writing to it will emit a deprecation warning with instructions
    to set the `writeable` flag `True`. Note that if one were to inspect the flag
    before setting it, one would find it would already be `True`. Explicitly setting
    it, though, as one will need to do in future versions, clears an internal flag
    that is used to produce the deprecation warning. To help alleviate confusion,
    an additional *FutureWarning* will be emitted when accessing the `writeable` flag
    state to clarify the contradiction.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for the C-side buffer protocol such an array will return a readonly
    buffer immediately unless a writable buffer is requested. If a writeable buffer
    is requested a warning will be given. When using cython, the `const` qualifier
    should be used with such arrays to avoid the warning (e.g. `cdef const double[::1]
    view`).
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") functions warn when passed `float` in place of `int`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously functions in this module would accept `float` values provided they
    were integral (`1.0`, `2.0`, etc). For consistency with the rest of numpy, doing
    so is now deprecated, and in future will raise a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, passing a float like `0.5` in place of an integer will now raise
    a `TypeError` instead of the previous `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecate [`numpy.distutils.exec_command`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") and `temp_file_name`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The internal use of these functions has been refactored and there are better
    alternatives. Replace `exec_command` with [`subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen
    "(in Python v3.11)") and [`temp_file_name`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") with [`tempfile.mkstemp`](https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: Writeable flag of C-API wrapped arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When an array is created from the C-API to wrap a pointer to data, the only
    indication we have of the read-write nature of the data is the `writeable` flag
    set during creation. It is dangerous to force the flag to writeable. In the future
    it will not be possible to switch the writeable flag to `True` from python. This
    deprecation should not affect many users since arrays created in such a manner
    are very rare in practice and only available through the NumPy C-API.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero "numpy.nonzero")
    should no longer be called on 0d arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The behavior of [`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero") on 0d arrays was surprising, making uses of it almost always
    incorrect. If the old behavior was intended, it can be preserved without a warning
    by using `nonzero(atleast_1d(arr))` instead of `nonzero(arr)`. In a future release,
    it is most likely this will raise a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the result of [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") will warn
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Commonly [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") returns a writeable array with internal overlap, making
    it unsafe to write to. A future version will set the `writeable` flag to `False`,
    and require users to manually set it to `True` if they are sure that is what they
    want to do. Now writing to it will emit a deprecation warning with instructions
    to set the `writeable` flag `True`. Note that if one were to inspect the flag
    before setting it, one would find it would already be `True`. Explicitly setting
    it, though, as one will need to do in future versions, clears an internal flag
    that is used to produce the deprecation warning. To help alleviate confusion,
    an additional *FutureWarning* will be emitted when accessing the `writeable` flag
    state to clarify the contradiction.
  prefs: []
  type: TYPE_NORMAL
- en: Note that for the C-side buffer protocol such an array will return a readonly
    buffer immediately unless a writable buffer is requested. If a writeable buffer
    is requested a warning will be given. When using cython, the `const` qualifier
    should be used with such arrays to avoid the warning (e.g. `cdef const double[::1]
    view`).
  prefs: []
  type: TYPE_NORMAL
- en: Future Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shape-1 fields in dtypes won’t be collapsed to scalars in a future version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, a field specified as `[(name, dtype, 1)]` or `"1type"` is interpreted
    as a scalar field (i.e., the same as `[(name, dtype)]` or `[(name, dtype, ()]`).
    This now raises a FutureWarning; in a future version, it will be interpreted as
    a shape-(1,) field, i.e. the same as `[(name, dtype, (1,))]` or `"(1,)type"` (consistently
    with `[(name, dtype, n)]` / `"ntype"` with `n>1`, which is already equivalent
    to `[(name, dtype, (n,)]` / `"(n,)type"`).
  prefs: []
  type: TYPE_NORMAL
- en: Shape-1 fields in dtypes won’t be collapsed to scalars in a future version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, a field specified as `[(name, dtype, 1)]` or `"1type"` is interpreted
    as a scalar field (i.e., the same as `[(name, dtype)]` or `[(name, dtype, ()]`).
    This now raises a FutureWarning; in a future version, it will be interpreted as
    a shape-(1,) field, i.e. the same as `[(name, dtype, (1,))]` or `"(1,)type"` (consistently
    with `[(name, dtype, n)]` / `"ntype"` with `n>1`, which is already equivalent
    to `[(name, dtype, (n,)]` / `"(n,)type"`).
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`float16` subnormal rounding'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Casting from a different floating point precision to `float16` used incorrect
    rounding in some edge cases. This means in rare cases, subnormal results will
    now be rounded up instead of down, changing the last bit (ULP) of the result.
  prefs: []
  type: TYPE_NORMAL
- en: Signed zero when using divmod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting in version *1.12.0*, numpy incorrectly returned a negatively signed
    zero when using the `divmod` and `floor_divide` functions when the result was
    zero. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With this release, the result is correctly returned as a positively signed
    zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`MaskedArray.mask` now returns a view of the mask, not the mask itself'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returning the mask itself was unsafe, as it could be reshaped in place which
    would violate expectations of the masked array code. The behavior of [`mask`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") is now consistent with [`data`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data"), which also returns a view.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying mask can still be accessed with `._mask` if it is needed. Tests
    that contain `assert x.mask is not y.mask` or similar will need to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Do not lookup `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Looking up `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer") was undocumented and non-functional. This code was removed.
    If needed, use `frombuffer(memoryview(obj), ...)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`out` is buffered for memory overlaps in [`take`](../reference/generated/numpy.take.html#numpy.take
    "numpy.take"), [`choose`](../reference/generated/numpy.choose.html#numpy.choose
    "numpy.choose"), [`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the out argument to these functions is provided and has memory overlap with
    the other arguments, it is now buffered to avoid order-dependent behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Unpickling while loading requires explicit opt-in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions [`load`](../reference/generated/numpy.load.html#numpy.load "numpy.load"),
    and `lib.format.read_array` take an `allow_pickle` keyword which now defaults
    to `False` in response to [CVE-2019-6446](https://nvd.nist.gov/vuln/detail/CVE-2019-6446).
  prefs: []
  type: TYPE_NORMAL
- en: Potential changes to the random stream in old random module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to bugs in the application of `log` to random floating point numbers, the
    stream may change when sampling from [`beta`](../reference/random/generated/numpy.random.RandomState.beta.html#numpy.random.RandomState.beta
    "numpy.random.RandomState.beta"), [`binomial`](../reference/random/generated/numpy.random.RandomState.binomial.html#numpy.random.RandomState.binomial
    "numpy.random.RandomState.binomial"), [`laplace`](../reference/random/generated/numpy.random.RandomState.laplace.html#numpy.random.RandomState.laplace
    "numpy.random.RandomState.laplace"), [`logistic`](../reference/random/generated/numpy.random.RandomState.logistic.html#numpy.random.RandomState.logistic
    "numpy.random.RandomState.logistic"), [`logseries`](../reference/random/generated/numpy.random.RandomState.logseries.html#numpy.random.RandomState.logseries
    "numpy.random.RandomState.logseries") or [`multinomial`](../reference/random/generated/numpy.random.RandomState.multinomial.html#numpy.random.RandomState.multinomial
    "numpy.random.RandomState.multinomial") if a `0` is generated in the underlying
    [`MT19937`](../reference/random/bit_generators/mt19937.html#numpy.random.MT19937
    "numpy.random.MT19937") random stream. There is a `1` in \(10^{53}\) chance of
    this occurring, so the probability that the stream changes for any given seed
    is extremely small. If a `0` is encountered in the underlying generator, then
    the incorrect value produced (either [`numpy.inf`](../reference/constants.html#numpy.inf
    "numpy.inf") or [`numpy.nan`](../reference/constants.html#numpy.nan "numpy.nan"))
    is now dropped.
  prefs: []
  type: TYPE_NORMAL
- en: '[`i0`](../reference/generated/numpy.i0.html#numpy.i0 "numpy.i0") now always
    returns a result with the same shape as the input'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, the output was squeezed, such that, e.g., input with just a single
    element would lead to an array scalar being returned, and inputs with shapes such
    as `(10, 1)` would yield results that would not broadcast against the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we generally recommend the SciPy implementation over the numpy one:
    it is a proper ufunc written in C, and more than an order of magnitude faster.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast "numpy.can_cast")
    no longer assumes all unsafe casting is allowed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, [`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast
    "numpy.can_cast") returned *True* for almost all inputs for `casting='unsafe'`,
    even for cases where casting was not possible, such as from a structured dtype
    to a regular one. This has been fixed, making it more consistent with actual casting
    using, e.g., the [`.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype") method.
  prefs: []
  type: TYPE_NORMAL
- en: '`ndarray.flags.writeable` can be switched to true slightly more often'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In rare cases, it was not possible to switch an array from not writeable to
    writeable, although a base array is writeable. This can happen if an intermediate
    [`ndarray.base`](../reference/generated/numpy.ndarray.base.html#numpy.ndarray.base
    "numpy.ndarray.base") object is writeable. Previously, only the deepest base object
    was considered for this decision. However, in rare cases this object does not
    have the necessary information. In that case switching to writeable was never
    allowed. This has now been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: '`float16` subnormal rounding'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Casting from a different floating point precision to `float16` used incorrect
    rounding in some edge cases. This means in rare cases, subnormal results will
    now be rounded up instead of down, changing the last bit (ULP) of the result.
  prefs: []
  type: TYPE_NORMAL
- en: Signed zero when using divmod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Starting in version *1.12.0*, numpy incorrectly returned a negatively signed
    zero when using the `divmod` and `floor_divide` functions when the result was
    zero. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'With this release, the result is correctly returned as a positively signed
    zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`MaskedArray.mask` now returns a view of the mask, not the mask itself'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returning the mask itself was unsafe, as it could be reshaped in place which
    would violate expectations of the masked array code. The behavior of [`mask`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") is now consistent with [`data`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data"), which also returns a view.
  prefs: []
  type: TYPE_NORMAL
- en: The underlying mask can still be accessed with `._mask` if it is needed. Tests
    that contain `assert x.mask is not y.mask` or similar will need to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Do not lookup `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Looking up `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer") was undocumented and non-functional. This code was removed.
    If needed, use `frombuffer(memoryview(obj), ...)` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`out` is buffered for memory overlaps in [`take`](../reference/generated/numpy.take.html#numpy.take
    "numpy.take"), [`choose`](../reference/generated/numpy.choose.html#numpy.choose
    "numpy.choose"), [`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the out argument to these functions is provided and has memory overlap with
    the other arguments, it is now buffered to avoid order-dependent behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Unpickling while loading requires explicit opt-in
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions [`load`](../reference/generated/numpy.load.html#numpy.load "numpy.load"),
    and `lib.format.read_array` take an `allow_pickle` keyword which now defaults
    to `False` in response to [CVE-2019-6446](https://nvd.nist.gov/vuln/detail/CVE-2019-6446).
  prefs: []
  type: TYPE_NORMAL
- en: Potential changes to the random stream in old random module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Due to bugs in the application of `log` to random floating point numbers, the
    stream may change when sampling from [`beta`](../reference/random/generated/numpy.random.RandomState.beta.html#numpy.random.RandomState.beta
    "numpy.random.RandomState.beta"), [`binomial`](../reference/random/generated/numpy.random.RandomState.binomial.html#numpy.random.RandomState.binomial
    "numpy.random.RandomState.binomial"), [`laplace`](../reference/random/generated/numpy.random.RandomState.laplace.html#numpy.random.RandomState.laplace
    "numpy.random.RandomState.laplace"), [`logistic`](../reference/random/generated/numpy.random.RandomState.logistic.html#numpy.random.RandomState.logistic
    "numpy.random.RandomState.logistic"), [`logseries`](../reference/random/generated/numpy.random.RandomState.logseries.html#numpy.random.RandomState.logseries
    "numpy.random.RandomState.logseries") or [`multinomial`](../reference/random/generated/numpy.random.RandomState.multinomial.html#numpy.random.RandomState.multinomial
    "numpy.random.RandomState.multinomial") if a `0` is generated in the underlying
    [`MT19937`](../reference/random/bit_generators/mt19937.html#numpy.random.MT19937
    "numpy.random.MT19937") random stream. There is a `1` in \(10^{53}\) chance of
    this occurring, so the probability that the stream changes for any given seed
    is extremely small. If a `0` is encountered in the underlying generator, then
    the incorrect value produced (either [`numpy.inf`](../reference/constants.html#numpy.inf
    "numpy.inf") or [`numpy.nan`](../reference/constants.html#numpy.nan "numpy.nan"))
    is now dropped.
  prefs: []
  type: TYPE_NORMAL
- en: '[`i0`](../reference/generated/numpy.i0.html#numpy.i0 "numpy.i0") now always
    returns a result with the same shape as the input'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, the output was squeezed, such that, e.g., input with just a single
    element would lead to an array scalar being returned, and inputs with shapes such
    as `(10, 1)` would yield results that would not broadcast against the input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we generally recommend the SciPy implementation over the numpy one:
    it is a proper ufunc written in C, and more than an order of magnitude faster.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast "numpy.can_cast")
    no longer assumes all unsafe casting is allowed'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, [`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast
    "numpy.can_cast") returned *True* for almost all inputs for `casting='unsafe'`,
    even for cases where casting was not possible, such as from a structured dtype
    to a regular one. This has been fixed, making it more consistent with actual casting
    using, e.g., the [`.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype") method.
  prefs: []
  type: TYPE_NORMAL
- en: '`ndarray.flags.writeable` can be switched to true slightly more often'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In rare cases, it was not possible to switch an array from not writeable to
    writeable, although a base array is writeable. This can happen if an intermediate
    [`ndarray.base`](../reference/generated/numpy.ndarray.base.html#numpy.ndarray.base
    "numpy.ndarray.base") object is writeable. Previously, only the deepest base object
    was considered for this decision. However, in rare cases this object does not
    have the necessary information. In that case switching to writeable was never
    allowed. This has now been fixed.
  prefs: []
  type: TYPE_NORMAL
- en: C API changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: dimension or stride input arguments are now passed by `npy_intp const*`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously these function arguments were declared as the more strict `npy_intp*`,
    which prevented the caller passing constant data. This change is backwards compatible,
    but now allows code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: dimension or stride input arguments are now passed by `npy_intp const*`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously these function arguments were declared as the more strict `npy_intp*`,
    which prevented the caller passing constant data. This change is backwards compatible,
    but now allows code like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module with selectable random number generators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module along with four selectable random number generators and
    improved seeding designed for use in parallel processes has been added. The currently
    available *Bit Generators* are *MT19937*, *PCG64*, *Philox*, and *SFC64*. `PCG64`
    is the new default while `MT19937` is retained for backwards compatibility. Note
    that the legacy random module is unchanged and is now frozen, your current results
    will not change. More information is available in the [API change description](../reference/random/new-or-different.html#new-or-different)
    and in the [`top-level view`](../reference/random/index.html#module-numpy.random
    "numpy.random") documentation.
  prefs: []
  type: TYPE_NORMAL
- en: libFLAME
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for building NumPy with the libFLAME linear algebra package as the LAPACK,
    implementation, see [libFLAME](https://www.cs.utexas.edu/~flame/web/libFLAME.html)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined BLAS detection order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    now uses an environment variable, comma-separated and case insensitive, to determine
    the detection order for BLAS libraries. By default `NPY_BLAS_ORDER=mkl,blis,openblas,atlas,accelerate,blas`.
    However, to force the use of OpenBLAS simply do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined LAPACK detection order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`numpy.distutils` now uses an environment variable, comma-separated and case
    insensitive, to determine the detection order for LAPACK libraries. By default
    `NPY_LAPACK_ORDER=mkl,openblas,flame,atlas,accelerate,lapack`. However, to force
    the use of OpenBLAS simply do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce") and related functions now accept a `where` mask'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce"), [`sum`](../reference/generated/numpy.sum.html#numpy.sum
    "numpy.sum"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min"), [`max`](../reference/generated/numpy.max.html#numpy.max
    "numpy.max") all now accept a `where` keyword argument, which can be used to tell
    which elements to include in the reduction. For reductions that do not have an
    identity, it is necessary to also pass in an initial value (e.g., `initial=np.inf`
    for [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min")). For
    instance, the equivalent of [`nansum`](../reference/generated/numpy.nansum.html#numpy.nansum
    "numpy.nansum") would be `np.sum(a, where=~np.isnan(a))`.'
  prefs: []
  type: TYPE_NORMAL
- en: Timsort and radix sort have replaced mergesort for stable sorting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both radix sort and timsort have been implemented and are now used in place
    of mergesort. Due to the need to maintain backward compatibility, the sorting
    `kind` options `"stable"` and `"mergesort"` have been made aliases of each other
    with the actual sort implementation depending on the array type. Radix sort is
    used for small integer types of 16 bits or less and timsort for the remaining
    types. Timsort features improved performance on data containing already or nearly
    sorted data and performs like mergesort on random data and requires \(O(n/2)\)
    working space. Details of the timsort algorithm can be found at [CPython listsort.txt](https://github.com/python/cpython/blob/3.7/Objects/listsort.txt).
  prefs: []
  type: TYPE_NORMAL
- en: '[`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits "numpy.packbits")
    and [`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") accept an `order` keyword'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `order` keyword defaults to `big`, and will order the **bits** accordingly.
    For `'order=big'` 3 will become `[0, 0, 0, 0, 0, 0, 1, 1]`, and `[1, 1, 0, 0,
    0, 0, 0, 0]` for `order=little`
  prefs: []
  type: TYPE_NORMAL
- en: '[`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") now accepts a `count` parameter'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`count` allows subsetting the number of bits that will be unpacked up-front,
    rather than reshaping and subsetting later, making the [`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits
    "numpy.packbits") operation invertible, and the unpacking less wasteful. Counts
    larger than the number of available bits add zero padding. Negative counts trim
    bits off the end instead of counting from the beginning. None counts implement
    the existing behavior of unpacking everything.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd") and [`linalg.pinv`](../reference/generated/numpy.linalg.pinv.html#numpy.linalg.pinv
    "numpy.linalg.pinv") can be faster on hermitian inputs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These functions now accept a `hermitian` argument, matching the one added to
    [`linalg.matrix_rank`](../reference/generated/numpy.linalg.matrix_rank.html#numpy.linalg.matrix_rank
    "numpy.linalg.matrix_rank") in 1.14.0.
  prefs: []
  type: TYPE_NORMAL
- en: divmod operation is now supported for two `timedelta64` operands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The divmod operator now handles two `timedelta64` operands, with type signature
    `mm->qm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile")
    now takes an `offset` argument'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function now takes an `offset` keyword argument for binary files, which
    specifics the offset (in bytes) from the file’s current position. Defaults to
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: New mode “empty” for [`pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This mode pads an array to a desired shape without initializing the new entries.
  prefs: []
  type: TYPE_NORMAL
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like") and related functions now accept a `shape` argument'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`full_like`](../reference/generated/numpy.full_like.html#numpy.full_like
    "numpy.full_like"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like") and [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like") now accept a `shape` keyword argument, which can be used to
    create a new array as the prototype, overriding its shape as well. This is particularly
    useful when combined with the `__array_function__` protocol, allowing the creation
    of new arbitrary-shape arrays from NumPy-like libraries when such an array is
    used as the prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: Floating point scalars implement `as_integer_ratio` to match the builtin float
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This returns a (numerator, denominator) pair, which can be used to construct
    a [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: Structured `dtype` objects can be indexed with multiple fields names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr.dtype[[''a'', ''b'']]` now returns a dtype that is equivalent to `arr[[''a'',
    ''b'']].dtype`, for consistency with `arr.dtype[''a''] == arr[''a''].dtype`.'
  prefs: []
  type: TYPE_NORMAL
- en: Like the dtype of structured arrays indexed with a list of fields, this dtype
    has the same `itemsize` as the original, but only keeps a subset of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: This means that `arr[['a', 'b']]` and `arr.view(arr.dtype[['a', 'b']])` are
    equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`.npy` files support unicode field names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new format version of 3.0 has been introduced, which enables structured types
    with non-latin1 field names. This is used automatically when needed.
  prefs: []
  type: TYPE_NORMAL
- en: New extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module with selectable random number generators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module along with four selectable random number generators and
    improved seeding designed for use in parallel processes has been added. The currently
    available *Bit Generators* are *MT19937*, *PCG64*, *Philox*, and *SFC64*. `PCG64`
    is the new default while `MT19937` is retained for backwards compatibility. Note
    that the legacy random module is unchanged and is now frozen, your current results
    will not change. More information is available in the [API change description](../reference/random/new-or-different.html#new-or-different)
    and in the [`top-level view`](../reference/random/index.html#module-numpy.random
    "numpy.random") documentation.
  prefs: []
  type: TYPE_NORMAL
- en: libFLAME
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for building NumPy with the libFLAME linear algebra package as the LAPACK,
    implementation, see [libFLAME](https://www.cs.utexas.edu/~flame/web/libFLAME.html)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined BLAS detection order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    now uses an environment variable, comma-separated and case insensitive, to determine
    the detection order for BLAS libraries. By default `NPY_BLAS_ORDER=mkl,blis,openblas,atlas,accelerate,blas`.
    However, to force the use of OpenBLAS simply do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined LAPACK detection order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`numpy.distutils` now uses an environment variable, comma-separated and case
    insensitive, to determine the detection order for LAPACK libraries. By default
    `NPY_LAPACK_ORDER=mkl,openblas,flame,atlas,accelerate,lapack`. However, to force
    the use of OpenBLAS simply do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce") and related functions now accept a `where` mask'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce"), [`sum`](../reference/generated/numpy.sum.html#numpy.sum
    "numpy.sum"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min"), [`max`](../reference/generated/numpy.max.html#numpy.max
    "numpy.max") all now accept a `where` keyword argument, which can be used to tell
    which elements to include in the reduction. For reductions that do not have an
    identity, it is necessary to also pass in an initial value (e.g., `initial=np.inf`
    for [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min")). For
    instance, the equivalent of [`nansum`](../reference/generated/numpy.nansum.html#numpy.nansum
    "numpy.nansum") would be `np.sum(a, where=~np.isnan(a))`.'
  prefs: []
  type: TYPE_NORMAL
- en: Timsort and radix sort have replaced mergesort for stable sorting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both radix sort and timsort have been implemented and are now used in place
    of mergesort. Due to the need to maintain backward compatibility, the sorting
    `kind` options `"stable"` and `"mergesort"` have been made aliases of each other
    with the actual sort implementation depending on the array type. Radix sort is
    used for small integer types of 16 bits or less and timsort for the remaining
    types. Timsort features improved performance on data containing already or nearly
    sorted data and performs like mergesort on random data and requires \(O(n/2)\)
    working space. Details of the timsort algorithm can be found at [CPython listsort.txt](https://github.com/python/cpython/blob/3.7/Objects/listsort.txt).
  prefs: []
  type: TYPE_NORMAL
- en: '[`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits "numpy.packbits")
    and [`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") accept an `order` keyword'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `order` keyword defaults to `big`, and will order the **bits** accordingly.
    For `'order=big'` 3 will become `[0, 0, 0, 0, 0, 0, 1, 1]`, and `[1, 1, 0, 0,
    0, 0, 0, 0]` for `order=little`
  prefs: []
  type: TYPE_NORMAL
- en: '[`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") now accepts a `count` parameter'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`count` allows subsetting the number of bits that will be unpacked up-front,
    rather than reshaping and subsetting later, making the [`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits
    "numpy.packbits") operation invertible, and the unpacking less wasteful. Counts
    larger than the number of available bits add zero padding. Negative counts trim
    bits off the end instead of counting from the beginning. None counts implement
    the existing behavior of unpacking everything.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd") and [`linalg.pinv`](../reference/generated/numpy.linalg.pinv.html#numpy.linalg.pinv
    "numpy.linalg.pinv") can be faster on hermitian inputs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These functions now accept a `hermitian` argument, matching the one added to
    [`linalg.matrix_rank`](../reference/generated/numpy.linalg.matrix_rank.html#numpy.linalg.matrix_rank
    "numpy.linalg.matrix_rank") in 1.14.0.
  prefs: []
  type: TYPE_NORMAL
- en: divmod operation is now supported for two `timedelta64` operands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The divmod operator now handles two `timedelta64` operands, with type signature
    `mm->qm`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile")
    now takes an `offset` argument'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function now takes an `offset` keyword argument for binary files, which
    specifics the offset (in bytes) from the file’s current position. Defaults to
    `0`.
  prefs: []
  type: TYPE_NORMAL
- en: New mode “empty” for [`pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This mode pads an array to a desired shape without initializing the new entries.
  prefs: []
  type: TYPE_NORMAL
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like") and related functions now accept a `shape` argument'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`full_like`](../reference/generated/numpy.full_like.html#numpy.full_like
    "numpy.full_like"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like") and [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like") now accept a `shape` keyword argument, which can be used to
    create a new array as the prototype, overriding its shape as well. This is particularly
    useful when combined with the `__array_function__` protocol, allowing the creation
    of new arbitrary-shape arrays from NumPy-like libraries when such an array is
    used as the prototype.'
  prefs: []
  type: TYPE_NORMAL
- en: Floating point scalars implement `as_integer_ratio` to match the builtin float
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This returns a (numerator, denominator) pair, which can be used to construct
    a [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)").
  prefs: []
  type: TYPE_NORMAL
- en: Structured `dtype` objects can be indexed with multiple fields names
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr.dtype[[''a'', ''b'']]` now returns a dtype that is equivalent to `arr[[''a'',
    ''b'']].dtype`, for consistency with `arr.dtype[''a''] == arr[''a''].dtype`.'
  prefs: []
  type: TYPE_NORMAL
- en: Like the dtype of structured arrays indexed with a list of fields, this dtype
    has the same `itemsize` as the original, but only keeps a subset of the fields.
  prefs: []
  type: TYPE_NORMAL
- en: This means that `arr[['a', 'b']]` and `arr.view(arr.dtype[['a', 'b']])` are
    equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '`.npy` files support unicode field names'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new format version of 3.0 has been introduced, which enables structured types
    with non-latin1 field names. This is used automatically when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array comparison assertions include maximum differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Error messages from array comparison tests such as [`testing.assert_allclose`](../reference/generated/numpy.testing.assert_allclose.html#numpy.testing.assert_allclose
    "numpy.testing.assert_allclose") now include “max absolute difference” and “max
    relative difference,” in addition to the previous “mismatch” percentage. This
    information makes it easier to update absolute and relative error tolerances.
  prefs: []
  type: TYPE_NORMAL
- en: Replacement of the fftpack based [`fft`](../reference/routines.fft.html#module-numpy.fft
    "numpy.fft") module by the pocketfft library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both implementations have the same ancestor (Fortran77 FFTPACK by Paul N. Swarztrauber),
    but pocketfft contains additional modifications which improve both accuracy and
    performance in some circumstances. For FFT lengths containing large prime factors,
    pocketfft uses Bluestein’s algorithm, which maintains \(O(N log N)\) run time
    complexity instead of deteriorating towards \(O(N*N)\) for prime lengths. Also,
    accuracy for real valued FFTs with near prime lengths has improved and is on par
    with complex valued FFTs.
  prefs: []
  type: TYPE_NORMAL
- en: Further improvements to `ctypes` support in [`numpy.ctypeslib`](../reference/routines.ctypeslib.html#module-numpy.ctypeslib
    "numpy.ctypeslib")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new [`numpy.ctypeslib.as_ctypes_type`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes_type
    "numpy.ctypeslib.as_ctypes_type") function has been added, which can be used to
    converts a [`dtype`](../reference/generated/numpy.dtype.html#numpy.dtype "numpy.dtype")
    into a best-guess [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.11)") type. Thanks to this new function, [`numpy.ctypeslib.as_ctypes`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes
    "numpy.ctypeslib.as_ctypes") now supports a much wider range of array types, including
    structures, booleans, and integers of non-native endianness.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate") is now also a function decorator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, if you have a function like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'and you want to wrap the whole thing in [`errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate"), you have to rewrite it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'but with this change, you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: thereby saving a level of indentation
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp")
    and [`numpy.log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    speed up for float32 implementation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: float32 implementation of [`exp`](../reference/generated/numpy.exp.html#numpy.exp
    "numpy.exp") and [`log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    now benefit from AVX2/AVX512 instruction set which are detected during runtime.
    [`exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp") has a max
    ulp error of 2.52 and [`log`](../reference/generated/numpy.log.html#numpy.log
    "numpy.log") has a max ulp error or 3.83.
  prefs: []
  type: TYPE_NORMAL
- en: Improve performance of [`numpy.pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The performance of the function has been improved for most cases by filling
    in a preallocated array with the desired padded shape instead of using concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.interp`](../reference/generated/numpy.interp.html#numpy.interp "numpy.interp")
    handles infinities more robustly'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases where [`interp`](../reference/generated/numpy.interp.html#numpy.interp
    "numpy.interp") would previously return [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"), it now returns an appropriate infinity.
  prefs: []
  type: TYPE_NORMAL
- en: Pathlib support for [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile"), *tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile"),
    *ndarray.ndarray.tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump") now support the [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path
    "(in Python v3.11)") type for the `file`/`fid` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Specialized [`isnan`](../reference/generated/numpy.isnan.html#numpy.isnan "numpy.isnan"),
    [`isinf`](../reference/generated/numpy.isinf.html#numpy.isinf "numpy.isinf"),
    and [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    ufuncs for bool and int types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The boolean and integer types are incapable of storing [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan") and [`inf`](../reference/constants.html#numpy.inf "numpy.inf") values,
    which allows us to provide specialized ufuncs that are up to 250x faster than
    the previous approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    supports `datetime64` and `timedelta64` types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite
    "numpy.isfinite") used to raise a *TypeError* on being used on these two types.
  prefs: []
  type: TYPE_NORMAL
- en: New keywords added to [`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num") now accepts keywords `nan`, `posinf` and `neginf` allowing
    the user to define the value to replace the `nan`, positive and negative `np.inf`
    values respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: MemoryErrors caused by allocated overly large arrays are more descriptive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often the cause of a MemoryError is incorrect broadcasting, which results in
    a very large and incorrect shape. The message of the error now includes this shape
    to help diagnose the cause of failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor"),
    [`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil "numpy.ceil"), and
    [`trunc`](../reference/generated/numpy.trunc.html#numpy.trunc "numpy.trunc") now
    respect builtin magic methods'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These ufuncs now call the `__floor__`, `__ceil__`, and `__trunc__` methods when
    called on object arrays, making them compatible with [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") and [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[`quantile`](../reference/generated/numpy.quantile.html#numpy.quantile "numpy.quantile")
    now works on *fraction.Fraction* and [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, this handles object arrays more gracefully, and avoids floating-
    point operations if exact arithmetic types are used.
  prefs: []
  type: TYPE_NORMAL
- en: Support of object arrays in [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is now possible to use [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul") (or the `@` operator) with object arrays. For instance, it is
    now possible to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Array comparison assertions include maximum differences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Error messages from array comparison tests such as [`testing.assert_allclose`](../reference/generated/numpy.testing.assert_allclose.html#numpy.testing.assert_allclose
    "numpy.testing.assert_allclose") now include “max absolute difference” and “max
    relative difference,” in addition to the previous “mismatch” percentage. This
    information makes it easier to update absolute and relative error tolerances.
  prefs: []
  type: TYPE_NORMAL
- en: Replacement of the fftpack based [`fft`](../reference/routines.fft.html#module-numpy.fft
    "numpy.fft") module by the pocketfft library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both implementations have the same ancestor (Fortran77 FFTPACK by Paul N. Swarztrauber),
    but pocketfft contains additional modifications which improve both accuracy and
    performance in some circumstances. For FFT lengths containing large prime factors,
    pocketfft uses Bluestein’s algorithm, which maintains \(O(N log N)\) run time
    complexity instead of deteriorating towards \(O(N*N)\) for prime lengths. Also,
    accuracy for real valued FFTs with near prime lengths has improved and is on par
    with complex valued FFTs.
  prefs: []
  type: TYPE_NORMAL
- en: Further improvements to `ctypes` support in [`numpy.ctypeslib`](../reference/routines.ctypeslib.html#module-numpy.ctypeslib
    "numpy.ctypeslib")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new [`numpy.ctypeslib.as_ctypes_type`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes_type
    "numpy.ctypeslib.as_ctypes_type") function has been added, which can be used to
    converts a [`dtype`](../reference/generated/numpy.dtype.html#numpy.dtype "numpy.dtype")
    into a best-guess [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.11)") type. Thanks to this new function, [`numpy.ctypeslib.as_ctypes`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes
    "numpy.ctypeslib.as_ctypes") now supports a much wider range of array types, including
    structures, booleans, and integers of non-native endianness.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate") is now also a function decorator'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, if you have a function like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'and you want to wrap the whole thing in [`errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate"), you have to rewrite it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'but with this change, you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: thereby saving a level of indentation
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp")
    and [`numpy.log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    speed up for float32 implementation'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: float32 implementation of [`exp`](../reference/generated/numpy.exp.html#numpy.exp
    "numpy.exp") and [`log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    now benefit from AVX2/AVX512 instruction set which are detected during runtime.
    [`exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp") has a max
    ulp error of 2.52 and [`log`](../reference/generated/numpy.log.html#numpy.log
    "numpy.log") has a max ulp error or 3.83.
  prefs: []
  type: TYPE_NORMAL
- en: Improve performance of [`numpy.pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The performance of the function has been improved for most cases by filling
    in a preallocated array with the desired padded shape instead of using concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.interp`](../reference/generated/numpy.interp.html#numpy.interp "numpy.interp")
    handles infinities more robustly'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases where [`interp`](../reference/generated/numpy.interp.html#numpy.interp
    "numpy.interp") would previously return [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"), it now returns an appropriate infinity.
  prefs: []
  type: TYPE_NORMAL
- en: Pathlib support for [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile"), *tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile"),
    *ndarray.ndarray.tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump") now support the [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path
    "(in Python v3.11)") type for the `file`/`fid` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Specialized [`isnan`](../reference/generated/numpy.isnan.html#numpy.isnan "numpy.isnan"),
    [`isinf`](../reference/generated/numpy.isinf.html#numpy.isinf "numpy.isinf"),
    and [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    ufuncs for bool and int types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The boolean and integer types are incapable of storing [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan") and [`inf`](../reference/constants.html#numpy.inf "numpy.inf") values,
    which allows us to provide specialized ufuncs that are up to 250x faster than
    the previous approach.
  prefs: []
  type: TYPE_NORMAL
- en: '[`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    supports `datetime64` and `timedelta64` types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite
    "numpy.isfinite") used to raise a *TypeError* on being used on these two types.
  prefs: []
  type: TYPE_NORMAL
- en: New keywords added to [`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num") now accepts keywords `nan`, `posinf` and `neginf` allowing
    the user to define the value to replace the `nan`, positive and negative `np.inf`
    values respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: MemoryErrors caused by allocated overly large arrays are more descriptive
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often the cause of a MemoryError is incorrect broadcasting, which results in
    a very large and incorrect shape. The message of the error now includes this shape
    to help diagnose the cause of failure.
  prefs: []
  type: TYPE_NORMAL
- en: '[`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor"),
    [`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil "numpy.ceil"), and
    [`trunc`](../reference/generated/numpy.trunc.html#numpy.trunc "numpy.trunc") now
    respect builtin magic methods'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These ufuncs now call the `__floor__`, `__ceil__`, and `__trunc__` methods when
    called on object arrays, making them compatible with [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") and [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[`quantile`](../reference/generated/numpy.quantile.html#numpy.quantile "numpy.quantile")
    now works on *fraction.Fraction* and [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, this handles object arrays more gracefully, and avoids floating-
    point operations if exact arithmetic types are used.
  prefs: []
  type: TYPE_NORMAL
- en: Support of object arrays in [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul")
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is now possible to use [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul") (or the `@` operator) with object arrays. For instance, it is
    now possible to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median")
    and [`percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile") family of functions no longer warn about `nan`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`numpy.median`](../reference/generated/numpy.median.html#numpy.median "numpy.median"),
    [`numpy.percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile"), and [`numpy.quantile`](../reference/generated/numpy.quantile.html#numpy.quantile
    "numpy.quantile") used to emit a `RuntimeWarning` when encountering an [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"). Since they return the `nan` value, the warning is redundant and
    has been removed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`timedelta64 % 0` behavior adjusted to return `NaT`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The modulus operation with two `np.timedelta64` operands now returns `NaT` in
    the case of division by zero, rather than returning zero
  prefs: []
  type: TYPE_NORMAL
- en: NumPy functions now always support overrides with `__array_function__`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy now always checks the `__array_function__` method to implement overrides
    of NumPy functions on non-NumPy arrays, as described in [NEP 18](http://www.numpy.org/neps/nep-0018-array-function-protocol.html).
    The feature was available for testing with NumPy 1.16 if appropriate environment
    variables are set, but is now always enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '`lib.recfunctions.structured_to_unstructured` does not squeeze single-field
    views'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `structured_to_unstructured(arr[['a']])` would produce a squeezed
    result inconsistent with `structured_to_unstructured(arr[['a', b']])`. This was
    accidental. The old behavior can be retained with `structured_to_unstructured(arr[['a']]).squeeze(axis=-1)`
    or far more simply, `arr['a']`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip") now
    uses a ufunc under the hood'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that registering clip functions for custom dtypes in C via `descr->f->fastclip`
    is deprecated - they should use the ufunc registration mechanism instead, attaching
    to the `np.core.umath.clip` ufunc.
  prefs: []
  type: TYPE_NORMAL
- en: It also means that `clip` accepts `where` and `casting` arguments, and can be
    override with `__array_ufunc__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A consequence of this change is that some behaviors of the old `clip` have
    been deprecated:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing `nan` to mean “do not clip” as one or both bounds. This didn’t work
    in all cases anyway, and can be better handled by passing infinities of the appropriate
    sign.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using “unsafe” casting by default when an `out` argument is passed. Using `casting="unsafe"`
    explicitly will silence this warning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are some corner cases with behavior changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Padding `max < min` has changed to be more consistent across dtypes, but should
    not be relied upon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar `min` and `max` take part in promotion rules like they do in all other
    ufuncs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__array_interface__` offset now works as documented'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interface may use an `offset` value that was mistakenly ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Pickle protocol in [`savez`](../reference/generated/numpy.savez.html#numpy.savez
    "numpy.savez") set to 3 for `force zip64` flag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`savez`](../reference/generated/numpy.savez.html#numpy.savez "numpy.savez")
    was not using the `force_zip64` flag, which limited the size of the archive to
    2GB. But using the flag requires us to use pickle protocol 3 to write `object`
    arrays. The protocol used was bumped to 3, meaning the archive will be unreadable
    by Python2.'
  prefs: []
  type: TYPE_NORMAL
- en: Structured arrays indexed with non-existent fields raise `KeyError` not `ValueError`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr[''bad_field'']` on a structured type raises `KeyError`, for consistency
    with `dict[''bad_field'']`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median")
    and [`percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile") family of functions no longer warn about `nan`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`numpy.median`](../reference/generated/numpy.median.html#numpy.median "numpy.median"),
    [`numpy.percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile"), and [`numpy.quantile`](../reference/generated/numpy.quantile.html#numpy.quantile
    "numpy.quantile") used to emit a `RuntimeWarning` when encountering an [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"). Since they return the `nan` value, the warning is redundant and
    has been removed.'
  prefs: []
  type: TYPE_NORMAL
- en: '`timedelta64 % 0` behavior adjusted to return `NaT`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The modulus operation with two `np.timedelta64` operands now returns `NaT` in
    the case of division by zero, rather than returning zero
  prefs: []
  type: TYPE_NORMAL
- en: NumPy functions now always support overrides with `__array_function__`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy now always checks the `__array_function__` method to implement overrides
    of NumPy functions on non-NumPy arrays, as described in [NEP 18](http://www.numpy.org/neps/nep-0018-array-function-protocol.html).
    The feature was available for testing with NumPy 1.16 if appropriate environment
    variables are set, but is now always enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '`lib.recfunctions.structured_to_unstructured` does not squeeze single-field
    views'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `structured_to_unstructured(arr[['a']])` would produce a squeezed
    result inconsistent with `structured_to_unstructured(arr[['a', b']])`. This was
    accidental. The old behavior can be retained with `structured_to_unstructured(arr[['a']]).squeeze(axis=-1)`
    or far more simply, `arr['a']`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip") now
    uses a ufunc under the hood'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that registering clip functions for custom dtypes in C via `descr->f->fastclip`
    is deprecated - they should use the ufunc registration mechanism instead, attaching
    to the `np.core.umath.clip` ufunc.
  prefs: []
  type: TYPE_NORMAL
- en: It also means that `clip` accepts `where` and `casting` arguments, and can be
    override with `__array_ufunc__`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A consequence of this change is that some behaviors of the old `clip` have
    been deprecated:'
  prefs: []
  type: TYPE_NORMAL
- en: Passing `nan` to mean “do not clip” as one or both bounds. This didn’t work
    in all cases anyway, and can be better handled by passing infinities of the appropriate
    sign.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using “unsafe” casting by default when an `out` argument is passed. Using `casting="unsafe"`
    explicitly will silence this warning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are some corner cases with behavior changes:'
  prefs: []
  type: TYPE_NORMAL
- en: Padding `max < min` has changed to be more consistent across dtypes, but should
    not be relied upon.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar `min` and `max` take part in promotion rules like they do in all other
    ufuncs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__array_interface__` offset now works as documented'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interface may use an `offset` value that was mistakenly ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Pickle protocol in [`savez`](../reference/generated/numpy.savez.html#numpy.savez
    "numpy.savez") set to 3 for `force zip64` flag
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`savez`](../reference/generated/numpy.savez.html#numpy.savez "numpy.savez")
    was not using the `force_zip64` flag, which limited the size of the archive to
    2GB. But using the flag requires us to use pickle protocol 3 to write `object`
    arrays. The protocol used was bumped to 3, meaning the archive will be unreadable
    by Python2.'
  prefs: []
  type: TYPE_NORMAL
- en: Structured arrays indexed with non-existent fields raise `KeyError` not `ValueError`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr[''bad_field'']` on a structured type raises `KeyError`, for consistency
    with `dict[''bad_field'']`.'
  prefs: []
  type: TYPE_NORMAL
