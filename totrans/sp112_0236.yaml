- en: scipy.linalg.solve
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.solve.html#scipy.linalg.solve)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Solves the linear equation set `a @ x == b` for the unknown `x` for square *a*
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: If the data matrix is known to be a particular type then supplying the corresponding
    string to `assume_a` key chooses the dedicated solver. The available options are
  prefs: []
  type: TYPE_NORMAL
- en: '| generic matrix | ‘gen’ |'
  prefs: []
  type: TYPE_TB
- en: '| symmetric | ‘sym’ |'
  prefs: []
  type: TYPE_TB
- en: '| hermitian | ‘her’ |'
  prefs: []
  type: TYPE_TB
- en: '| positive definite | ‘pos’ |'
  prefs: []
  type: TYPE_TB
- en: If omitted, `'gen'` is the default structure.
  prefs: []
  type: TYPE_NORMAL
- en: The datatype of the arrays define which solver is called regardless of the values.
    In other words, even when the complex array entries have precisely zero imaginary
    parts, the complex solver will be called based on the data type of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**(N, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Square input data
  prefs: []
  type: TYPE_NORMAL
- en: '**b**(N, NRHS) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Input data for the right hand side.
  prefs: []
  type: TYPE_NORMAL
- en: '**lower**bool, default: False'
  prefs: []
  type: TYPE_NORMAL
- en: Ignored if `assume_a == 'gen'` (the default). If True, the calculation uses
    only the data in the lower triangle of *a*; entries above the diagonal are ignored.
    If False (default), the calculation uses only the data in the upper triangle of
    *a*; entries below the diagonal are ignored.
  prefs: []
  type: TYPE_NORMAL
- en: '**overwrite_a**bool, default: False'
  prefs: []
  type: TYPE_NORMAL
- en: Allow overwriting data in *a* (may enhance performance).
  prefs: []
  type: TYPE_NORMAL
- en: '**overwrite_b**bool, default: False'
  prefs: []
  type: TYPE_NORMAL
- en: Allow overwriting data in *b* (may enhance performance).
  prefs: []
  type: TYPE_NORMAL
- en: '**check_finite**bool, default: True'
  prefs: []
  type: TYPE_NORMAL
- en: Whether to check that the input matrices contain only finite numbers. Disabling
    may give a performance gain, but may result in problems (crashes, non-termination)
    if the inputs do contain infinities or NaNs.
  prefs: []
  type: TYPE_NORMAL
- en: '**assume_a**str, {‘gen’, ‘sym’, ‘her’, ‘pos’}'
  prefs: []
  type: TYPE_NORMAL
- en: Valid entries are explained above.
  prefs: []
  type: TYPE_NORMAL
- en: '**transposed**bool, default: False'
  prefs: []
  type: TYPE_NORMAL
- en: If True, solve `a.T @ x == b`. Raises *NotImplementedError* for complex *a*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**(N, NRHS) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The solution array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: ValueError
  prefs: []
  type: TYPE_NORMAL
- en: If size mismatches detected or input a is not square.
  prefs: []
  type: TYPE_NORMAL
- en: LinAlgError
  prefs: []
  type: TYPE_NORMAL
- en: If the matrix is singular.
  prefs: []
  type: TYPE_NORMAL
- en: LinAlgWarning
  prefs: []
  type: TYPE_NORMAL
- en: If an ill-conditioned input a is detected.
  prefs: []
  type: TYPE_NORMAL
- en: NotImplementedError
  prefs: []
  type: TYPE_NORMAL
- en: If transposed is True and input a is a complex matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: If the input b matrix is a 1-D array with N elements, when supplied together
    with an NxN input a, it is assumed as a valid column vector despite the apparent
    size mismatch. This is compatible with the numpy.dot() behavior and the returned
    result is still 1-D array.
  prefs: []
  type: TYPE_NORMAL
- en: The generic, symmetric, Hermitian and positive definite solutions are obtained
    via calling ?GESV, ?SYSV, ?HESV, and ?POSV routines of LAPACK respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Given *a* and *b*, solve for *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
