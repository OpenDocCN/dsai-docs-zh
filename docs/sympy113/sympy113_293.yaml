- en: Cryptography
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密码学
- en: Original text：[https://docs.sympy.org/latest/modules/crypto.html](https://docs.sympy.org/latest/modules/crypto.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文链接：[https://docs.sympy.org/latest/modules/crypto.html](https://docs.sympy.org/latest/modules/crypto.html)
- en: Warning
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: This module is intended for educational purposes only. Do not use the functions
    in this module for real cryptographic applications. If you wish to encrypt real
    data, we recommend using something like the [cryptography](https://cryptography.io/en/latest/)
    module.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块仅供教育目的使用。请勿将此模块中的函数用于实际的加密应用。如果希望加密真实数据，建议使用类似 [cryptography](https://cryptography.io/en/latest/)
    模块。
- en: 'Encryption is the process of hiding a message and a cipher is a means of doing
    so. Included in this module are both block and stream ciphers:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 加密是隐藏消息的过程，而密码是这样做的手段。此模块包含块和流密码：
- en: Shift cipher
  id: totrans-5
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移位密码
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-7
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Affine cipher
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仿射密码
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: substitution ciphers
  id: totrans-11
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替换密码
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-13
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Vigenere’s cipher
  id: totrans-14
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维吉尼亚密码
- en: ''
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Hill’s cipher
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hill 密码
- en: ''
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Bifid ciphers
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双密码
- en: ''
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: RSA
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: RSA
- en: ''
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Kid RSA
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kid RSA
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: linear-feedback shift registers (for stream ciphers)
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性反馈移位寄存器（用于流密码）
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ElGamal encryption
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: ElGamal 加密
- en: In a *substitution cipher* “units” (not necessarily single characters) of plaintext
    are replaced with ciphertext according to a regular system.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*替换密码* 中，根据正规系统将明文的“单位”（不一定是单个字符）替换为密文。'
- en: A *transposition cipher* is a method of encryption by which the positions held
    by “units” of plaintext are replaced by a permutation of the plaintext. That is,
    the order of the units is changed using a bijective function on the position of
    the characters to perform the encryption.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*置换密码* 是一种加密方法，通过将明文中“单位”的位置替换为明文的置换来改变单位的顺序，使用字符位置的双射函数执行加密。'
- en: A *monoalphabetic cipher* uses fixed substitution over the entire message, whereas
    a *polyalphabetic cipher* uses a number of substitutions at different times in
    the message.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*单字母密码* 在整个消息上使用固定的替换，而*多字母密码* 在消息中的不同时间使用多个替换。'
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Return the letters of `s` in uppercase. In case more than one string is passed,
    each of them will be processed and a list of upper case strings will be returned.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 返回字符串 `s` 中的大写字母。如果传入多个字符串，每个字符串将被处理，并返回大写字符串列表。
- en: Examples
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: See also
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`check_and_join`](#sympy.crypto.crypto.check_and_join "sympy.crypto.crypto.check_and_join")'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[`check_and_join`](#sympy.crypto.crypto.check_and_join "sympy.crypto.crypto.check_and_join")'
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Return a string of the distinct characters of `symbols` with those of `key`
    appearing first. A ValueError is raised if a) there are duplicate characters in
    `symbols` or b) there are characters in `key` that are not in `symbols`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `symbols` 的不同字符的字符串，其中 `key` 的字符优先出现。如果 `symbols` 中存在重复字符或 `key` 中存在不在 `symbols`
    中的字符，则引发 ValueError。
- en: Examples
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Joins characters of `phrase` and if `symbols` is given, raises an error if any
    character in `phrase` is not in `symbols`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 连接 `phrase` 的字符，并且如果给定了 `symbols`，则如果 `phrase` 中的任何字符不在 `symbols` 中，则引发错误。
- en: 'Parameters:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**phrase**'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**phrase**'
- en: String or list of strings to be returned as a string.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要作为字符串返回的字符串或字符串列表。
- en: '**symbols**'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**symbols**'
- en: Iterable of characters allowed in `phrase`.
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`phrase` 中允许的字符的可迭代。'
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `symbols` is `None`, no checking is performed.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `symbols` 是 `None`，则不执行检查。
- en: Examples
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Returns the elements of the list `range(n)` shifted to the left by `k` (so the
    list starts with `k` (mod `n`)).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 返回列表 `range(n)` 的元素，左移 `k` 位（因此列表从 `k`（模 `n`）开始）。
- en: Examples
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Performs shift cipher encryption on plaintext msg, and returns the ciphertext.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在明文 msg 上执行移位密码加密，并返回密文。
- en: 'Parameters:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**key** : int'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**key** ：整数'
- en: The secret key.
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 秘密密钥。
- en: '**msg** : str'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**msg** ：字符串'
- en: Plaintext of upper-case letters.
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大写字母的明文。
- en: 'Returns:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: str
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串
- en: Ciphertext of upper-case letters.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大写字母的密文。
- en: Examples
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To decipher the shifted text, change the sign of the key:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密移位文本，请更改密钥的符号：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'There is also a convenience function that does this with the original key:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个方便的功能，可以使用原始密钥执行此操作：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notes
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意事项
- en: 'ALGORITHM:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 算法：
- en: 'STEPS:'
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 步骤：
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number the letters of the alphabet from 0, …, N
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字母表中编号字母从 0 到 N
- en: ''
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `msg` a list `L1` of corresponding integers.
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串 `msg` 计算对应整数列表 `L1`。
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the list `L1` a new list `L2`, given by adding `(k mod 26)` to
    each element in `L1`.
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表 `L1` 计算新列表 `L2`，由 `L1` 中的每个元素加上 `(k mod 26)` 组成。
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the list `L2` a string `ct` of corresponding letters.
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表 `L2` 计算对应字母的字符串 `ct`。
- en: The shift cipher is also called the Caesar cipher, after Julius Caesar, who,
    according to Suetonius, used it with a shift of three to protect messages of military
    significance. Caesar’s nephew Augustus reportedly used a similar cipher, but with
    a right shift of 1.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 移位密码也称为凯撒密码，以朱利叶斯·凯撒命名，据苏埃托尼乌斯说，他用3个移位来保护军事重要消息。据报道，凯撒的侄子奥古斯都也使用了类似的密码，但右移1位。
- en: See also
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`decipher_shift`](#sympy.crypto.crypto.decipher_shift "sympy.crypto.crypto.decipher_shift")'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[`decipher_shift`](#sympy.crypto.crypto.decipher_shift "sympy.crypto.crypto.decipher_shift")'
- en: References
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R151](#id2)]'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R151](#id2)]'
- en: '[https://en.wikipedia.org/wiki/Caesar_cipher](https://en.wikipedia.org/wiki/Caesar_cipher)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Caesar_cipher](https://en.wikipedia.org/wiki/Caesar_cipher)'
- en: '[[R152](#id3)]'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R152](#id3)]'
- en: '[https://mathworld.wolfram.com/CaesarsMethod.html](https://mathworld.wolfram.com/CaesarsMethod.html)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mathworld.wolfram.com/CaesarsMethod.html](https://mathworld.wolfram.com/CaesarsMethod.html)'
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Return the text by shifting the characters of `msg` to the left by the amount
    given by `key`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`msg`的字符向左移动`key`给定的量来返回文本。
- en: Examples
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To decipher the shifted text, change the sign of the key:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密移位后的文本，改变密钥的符号：
- en: '[PRE14]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Or use this function with the original key:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 或使用原始密钥使用此函数：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Performs the ROT13 encryption on a given plaintext `msg`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定的明文`msg`执行ROT13加密。
- en: Explanation
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: ROT13 is a substitution cipher which substitutes each letter in the plaintext
    message for the letter furthest away from it in the English alphabet.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ROT13是一种替换密码，将明文消息中的每个字母替换为英语字母表中距离最远的字母。
- en: Equivalently, it is just a Caeser (shift) cipher with a shift key of 13 (midway
    point of the alphabet).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 等效地，它只是一个移位密码，其移位键为13（字母表的中间点）。
- en: See also
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`decipher_rot13`](#sympy.crypto.crypto.decipher_rot13 "sympy.crypto.crypto.decipher_rot13"),
    [`encipher_shift`](#sympy.crypto.crypto.encipher_shift "sympy.crypto.crypto.encipher_shift")'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[`decipher_rot13`](#sympy.crypto.crypto.decipher_rot13 "sympy.crypto.crypto.decipher_rot13"),
    [`encipher_shift`](#sympy.crypto.crypto.encipher_shift "sympy.crypto.crypto.encipher_shift")'
- en: References
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R153](#id4)]'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R153](#id4)]'
- en: '[https://en.wikipedia.org/wiki/ROT13](https://en.wikipedia.org/wiki/ROT13)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/ROT13](https://en.wikipedia.org/wiki/ROT13)'
- en: '[PRE17]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Performs the ROT13 decryption on a given plaintext `msg`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定的明文`msg`执行ROT13解密。
- en: Explanation
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: '`decipher_rot13` is equivalent to `encipher_rot13` as both `decipher_shift`
    with a key of 13 and `encipher_shift` key with a key of 13 will return the same
    results. Nonetheless, `decipher_rot13` has nonetheless been explicitly defined
    here for consistency.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`decipher_rot13`与`encipher_rot13`等效，因为`decipher_shift`使用密钥13和`encipher_shift`使用密钥13将返回相同的结果。尽管如此，`decipher_rot13`在这里仍然明确定义以保持一致性。'
- en: Examples
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE18]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Performs the affine cipher encryption on plaintext `msg`, and returns the ciphertext.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对明文`msg`执行仿射密码加密，并返回密文。
- en: 'Parameters:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**msg** : str'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**msg** : str'
- en: Characters that appear in `symbols`.
  id: totrans-127
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 出现在`symbols`中的字符。
- en: '**a, b** : int, int'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**a, b** : int, int'
- en: A pair integers, with `gcd(a, N) = 1` (the secret key).
  id: totrans-129
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一对整数，其中`gcd(a, N) = 1`（秘密密钥）。
- en: '**symbols**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号**'
- en: String of characters (default = uppercase letters).
  id: totrans-131
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 字符串的字符（默认=大写字母）。
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When no symbols are given, `msg` is converted to upper case letters and all
    other characters are ignored.
  id: totrans-133
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果没有给出符号，则将`msg`转换为大写字母，并忽略所有其他字符。
- en: 'Returns:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: ct
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: ct
- en: String of characters (the ciphertext message)
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 字符串的字符（密文消息）
- en: Explanation
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: Encryption is based on the map \(x \rightarrow ax+b\) (mod \(N\)) where `N`
    is the number of characters in the alphabet. Decryption is based on the map \(x
    \rightarrow cx+d\) (mod \(N\)), where \(c = a^{-1}\) (mod \(N\)) and \(d = -a^{-1}b\)
    (mod \(N\)). In particular, for the map to be invertible, we need \(\mathrm{gcd}(a,
    N) = 1\) and an error will be raised if this is not true.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 加密基于映射\(x \rightarrow ax+b\)（mod \(N\))，其中`N`是字母表中的字符数。解密基于映射\(x \rightarrow
    cx+d\)（mod \(N\))，其中\(c = a^{-1}\)（mod \(N\))和\(d = -a^{-1}b\)（mod \(N\))。特别地，为了使映射可逆，我们需要\(\mathrm{gcd}(a,
    N) = 1\)，如果不是这样将会引发错误。
- en: Notes
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: 'ALGORITHM:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 算法：
- en: 'STEPS:'
  id: totrans-141
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 步骤：
- en: ''
  id: totrans-142
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number the letters of the alphabet from 0, …, N
  id: totrans-143
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字母从0到N编号
- en: ''
  id: totrans-144
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-145
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `msg` a list `L1` of corresponding integers.
  id: totrans-146
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串`msg`计算相应整数列表`L1`。
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the list `L1` a new list `L2`, given by replacing `x` by `a*x +
    b (mod N)`, for each element `x` in `L1`.
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表`L1`计算一个新列表`L2`，替换每个元素`x`为`a*x + b (mod N)`。
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the list `L2` a string `ct` of corresponding letters.
  id: totrans-152
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表`L2`计算字符串`ct`的对应字母。
- en: This is a straightforward generalization of the shift cipher with the added
    complexity of requiring 2 characters to be deciphered in order to recover the
    key.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是移位密码的简单概括，增加了需要解密两个字符才能恢复密钥的复杂性。
- en: See also
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`decipher_affine`](#sympy.crypto.crypto.decipher_affine "sympy.crypto.crypto.decipher_affine")'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[`decipher_affine`](#sympy.crypto.crypto.decipher_affine "sympy.crypto.crypto.decipher_affine")'
- en: References
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: References
- en: '[[R154](#id5)]'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R154](#id5)]'
- en: '[https://en.wikipedia.org/wiki/Affine_cipher](https://en.wikipedia.org/wiki/Affine_cipher)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Affine_cipher](https://en.wikipedia.org/wiki/Affine_cipher)'
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Return the deciphered text that was made from the mapping, \(x \rightarrow
    ax+b\) (mod \(N\)), where `N` is the number of characters in the alphabet. Deciphering
    is done by reciphering with a new key: \(x \rightarrow cx+d\) (mod \(N\)), where
    \(c = a^{-1}\) (mod \(N\)) and \(d = -a^{-1}b\) (mod \(N\)).'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 返回由映射制成的解密文本，其中映射为 \(x \rightarrow ax+b\) (mod \(N\))，其中 `N` 是字母表中的字符数。解密通过使用新密钥进行重新加密完成：\(x
    \rightarrow cx+d\) (mod \(N\))，其中 \(c = a^{-1}\) (mod \(N\)) 且 \(d = -a^{-1}b\)
    (mod \(N\))。
- en: Examples
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Examples
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: See also
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`encipher_affine`](#sympy.crypto.crypto.encipher_affine "sympy.crypto.crypto.encipher_affine")'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[`encipher_affine`](#sympy.crypto.crypto.encipher_affine "sympy.crypto.crypto.encipher_affine")'
- en: '[PRE22]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Enciphers a given `msg` into its Atbash ciphertext and returns it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定的`msg`加密为其Atbash密码文本并返回。
- en: Explanation
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: Explanation
- en: Atbash is a substitution cipher originally used to encrypt the Hebrew alphabet.
    Atbash works on the principle of mapping each alphabet to its reverse / counterpart
    (i.e. a would map to z, b to y etc.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: Atbash是最初用于加密希伯来字母表的代换密码。Atbash的工作原理是将每个字母映射到其反向/对应物（即a映射到z，b映射到y等）。
- en: Atbash is functionally equivalent to the affine cipher with `a = 25` and `b
    = 25`
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Atbash在功能上等同于具有 `a = 25` 和 `b = 25` 的仿射密码。
- en: See also
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`decipher_atbash`](#sympy.crypto.crypto.decipher_atbash "sympy.crypto.crypto.decipher_atbash")'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[`decipher_atbash`](#sympy.crypto.crypto.decipher_atbash "sympy.crypto.crypto.decipher_atbash")'
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Deciphers a given `msg` using Atbash cipher and returns it.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Atbash密码解密给定的`msg`并返回结果。
- en: Explanation
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: Explanation
- en: '`decipher_atbash` is functionally equivalent to `encipher_atbash`. However,
    it has still been added as a separate function to maintain consistency.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`decipher_atbash` 在功能上等同于 `encipher_atbash`。然而，它仍然作为一个单独的函数添加以保持一致性。'
- en: Examples
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Examples
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`encipher_atbash`](#sympy.crypto.crypto.encipher_atbash "sympy.crypto.crypto.encipher_atbash")'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[`encipher_atbash`](#sympy.crypto.crypto.encipher_atbash "sympy.crypto.crypto.encipher_atbash")'
- en: References
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: References
- en: '[[R155](#id6)]'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R155](#id6)]'
- en: '[https://en.wikipedia.org/wiki/Atbash](https://en.wikipedia.org/wiki/Atbash)'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Atbash](https://en.wikipedia.org/wiki/Atbash)'
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Returns the ciphertext obtained by replacing each character that appears in
    `old` with the corresponding character in `new`. If `old` is a mapping, then new
    is ignored and the replacements defined by `old` are used.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 返回通过使用`old`中定义的替换替换每个出现的字符而获得的密文。如果`old`是一个映射，则忽略`new`并使用`old`定义的替换。
- en: Explanation
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Explanation
- en: This is a more general than the affine cipher in that the key can only be recovered
    by determining the mapping for each symbol. Though in practice, once a few symbols
    are recognized the mappings for other characters can be quickly guessed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这比仿射密码更一般化，因为密钥只能通过确定每个符号的映射来恢复。尽管在实践中，一旦识别了几个符号，其他字符的映射可以很快地猜出。
- en: Examples
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Examples
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To decrypt a substitution, reverse the last two arguments:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要解密代换，反转最后两个参数：
- en: '[PRE27]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the special case where `old` and `new` are a permutation of order 2 (representing
    a transposition of characters) their order is immaterial:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `old` 和 `new` 是2阶置换（表示字符置换）的特殊情况下，它们的顺序是无关紧要的：
- en: '[PRE28]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The substitution cipher, in general, is a method whereby “units” (not necessarily
    single characters) of plaintext are replaced with ciphertext according to a regular
    system.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 代换密码通常是一种方法，按照规则系统将明文的“单元”（不一定是单个字符）替换为密文。
- en: '[PRE29]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: References
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: References
- en: '[[R156](#id7)]'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R156](#id7)]'
- en: '[https://en.wikipedia.org/wiki/Substitution_cipher](https://en.wikipedia.org/wiki/Substitution_cipher)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Substitution_cipher](https://en.wikipedia.org/wiki/Substitution_cipher)'
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Performs the Vigenere cipher encryption on plaintext `msg`, and returns the
    ciphertext.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对明文 `msg` 执行维吉尼亚密码加密，并返回密文。
- en: Examples
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Examples
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Section 1 of the Kryptos sculpture at the CIA headquarters uses this cipher
    and also changes the order of the alphabet [[R158]](#r158). Here is the first
    line of that section of the sculpture:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: CIA总部的Kryptos雕塑第1节使用此密码，并且还改变了字母表的顺序[[R158]](#r158)。以下是该雕塑部分的第一行：
- en: '[PRE32]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Explanation
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Explanation
- en: The Vigenere cipher is named after Blaise de Vigenere, a sixteenth century diplomat
    and cryptographer, by a historical accident. Vigenere actually invented a different
    and more complicated cipher. The so-called *Vigenere cipher* was actually invented
    by Giovan Batista Belaso in 1553.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 维吉尼亚密码因历史原因被称为布莱斯·德·维吉尼亚，一位16世纪的外交家和密码学家。实际上，维吉尼亚实际上发明了一种不同且更复杂的密码。所谓的*维吉尼亚密码*实际上是由乔瓦尼·巴蒂斯塔·贝拉索于1553年发明的。
- en: This cipher was used in the 1800’s, for example, during the American Civil War.
    The Confederacy used a brass cipher disk to implement the Vigenere cipher (now
    on display in the NSA Museum in Fort Meade) [[R157]](#r157).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种密码在19世纪被使用，例如在美国内战期间。南方联盟使用黄铜密码盘实现了维吉尼亚密码（现在展览在NSA博物馆中的Fort Meade）[[R157]](#r157)。
- en: The Vigenere cipher is a generalization of the shift cipher. Whereas the shift
    cipher shifts each letter by the same amount (that amount being the key of the
    shift cipher) the Vigenere cipher shifts a letter by an amount determined by the
    key (which is a word or phrase known only to the sender and receiver).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 维吉尼亚密码是移位密码的一种推广。而移位密码每个字母的移位量是相同的（移位密码的密钥），维吉尼亚密码则是由密钥决定字母的移位量（这是发件人和收件人唯一知道的单词或短语）。
- en: For example, if the key was a single letter, such as “C”, then the so-called
    Vigenere cipher is actually a shift cipher with a shift of \(2\) (since “C” is
    the 2nd letter of the alphabet, if you start counting at \(0\)). If the key was
    a word with two letters, such as “CA”, then the so-called Vigenere cipher will
    shift letters in even positions by \(2\) and letters in odd positions are left
    alone (shifted by \(0\), since “A” is the 0th letter, if you start counting at
    \(0\)).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果密钥是单个字母，比如“C”，那么所谓的维吉尼亚密码实际上是一种移位密码，移位量为\(2\)（因为“C”是字母表中的第2个字母，从0开始计数）。如果密钥是两个字母的单词，比如“CA”，那么所谓的维吉尼亚密码将会将偶数位置的字母向右移动\(2\)个位置，奇数位置的字母保持不变（移位\(0\)，因为“A”是字母表中的第0个字母，从0开始计数）。
- en: 'ALGORITHM:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 算法：
- en: 'INPUT:'
  id: totrans-210
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入：
- en: ''
  id: totrans-211
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`msg`: string of characters that appear in `symbols` (the plaintext)'
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`msg`: 字符串，出现在`symbols`（明文）中的字符'
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`key`: a string of characters that appear in `symbols` (the secret key)'
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`key`: 字符串，出现在`symbols`（密钥）中的字符'
- en: ''
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`symbols`: a string of letters defining the alphabet'
  id: totrans-216
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`symbols`: 字母串，定义字母表'
- en: ''
  id: totrans-217
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'OUTPUT:'
  id: totrans-218
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出：
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ct`: string of characters (the ciphertext message)'
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ct`: 字符串，字符（密文消息）'
- en: ''
  id: totrans-221
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'STEPS:'
  id: totrans-222
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 步骤：
- en: ''
  id: totrans-223
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number the letters of the alphabet from 0, …, N
  id: totrans-224
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字母表中的字母编号为0，…，N
- en: ''
  id: totrans-225
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `key` a list `L1` of corresponding integers. Let `n1
    = len(L1)`.
  id: totrans-227
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串`key`计算对应整数列表`L1`。令`n1 = len(L1)`。
- en: ''
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `msg` a list `L2` of corresponding integers. Let `n2
    = len(L2)`.
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串`msg`计算对应整数列表`L2`。令`n2 = len(L2)`。
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Break `L2` up sequentially into sublists of size `n1`; the last sublist may
    be smaller than `n1`
  id: totrans-233
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`L2`按大小为`n1`的子列表顺序分解；最后一个子列表可能比`n1`小
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-235
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: For each of these sublists `L` of `L2`, compute a new list `C` given by `C[i]
    = L[i] + L1[i] (mod N)` to the `i`-th element in the sublist, for each `i`.
  id: totrans-236
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`L2`的每个子列表`L`，计算一个新列表`C`，给定为`C[i] = L[i] + L1[i] (mod N)`到子列表中的第`i`个元素，对于每个`i`。
- en: ''
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-238
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Assemble these lists `C` by concatenation into a new list of length `n2`.
  id: totrans-239
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些列表`C`通过串联成一个长度为`n2`的新列表。
- en: ''
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the new list a string `ct` of corresponding letters.
  id: totrans-242
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新列表计算对应字母串`ct`。
- en: Once it is known that the key is, say, \(n\) characters long, frequency analysis
    can be applied to every \(n\)-th letter of the ciphertext to determine the plaintext.
    This method is called *Kasiski examination* (although it was first discovered
    by Babbage). If they key is as long as the message and is comprised of randomly
    selected characters – a one-time pad – the message is theoretically unbreakable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦知道密钥长度为\(n\)个字符，可以对密文的每第\(n\)个字母应用频率分析来确定明文。这种方法称为*Kasiski检查*（尽管它最初由巴贝奇发现）。如果密钥与消息一样长，并由随机选择的字符组成——一次性密码本——则理论上消息是不可破解的。
- en: The cipher Vigenere actually discovered is an “auto-key” cipher described as
    follows.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 维吉尼亚密码实际上发现的是一种“自动密钥”密码，如下所述。
- en: 'ALGORITHM:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 算法：
- en: 'INPUT:'
  id: totrans-246
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入：
- en: ''
  id: totrans-247
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`key`: a string of letters (the secret key)'
  id: totrans-248
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`key`: 字母串，（密钥）'
- en: ''
  id: totrans-249
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`msg`: string of letters (the plaintext message)'
  id: totrans-250
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`msg`: 字母串，（明文消息）'
- en: ''
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'OUTPUT:'
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输出：
- en: ''
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ct`: string of upper-case letters (the ciphertext message)'
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ct`: 大写字母串，（密文消息）'
- en: ''
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'STEPS:'
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 步骤：
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number the letters of the alphabet from 0, …, N
  id: totrans-258
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字母表中的字母编号为0，…，N
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `msg` a list `L2` of corresponding integers. Let `n2
    = len(L2)`.
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串 `msg` 计算一个与之对应的整数列表 `L2`。设 `n2 = len(L2)`。
- en: ''
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Let `n1` be the length of the key. Append to the string `key` the first `n2
    - n1` characters of the plaintext message. Compute from this string (also of length
    `n2`) a list `L1` of integers corresponding to the letter numbers in the first
    step.
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让 `n1` 是密钥的长度。将明文消息的前 `n2 - n1` 个字符附加到字符串 `key`，计算这个长度为 `n2` 的字符串（也是长度为 `n2`
    的字符串），得到一个与第一步中字母号对应的整数列表 `L1`。
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-266
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute a new list `C` given by `C[i] = L1[i] + L2[i] (mod N)`.
  id: totrans-267
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一个新列表 `C`，其定义为 `C[i] = L1[i] + L2[i] (mod N)`。
- en: ''
  id: totrans-268
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the new list a string `ct` of letters corresponding to the new
    integers.
  id: totrans-270
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新列表 `C` 计算一个与新整数对应的字母字符串 `ct`。
- en: 'To decipher the auto-key ciphertext, the key is used to decipher the first
    `n1` characters and then those characters become the key to decipher the next
    `n1` characters, etc…:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解密自动密钥的密文，使用密钥来解密前 `n1` 个字符，然后这些字符成为解密下一个 `n1` 个字符的密钥，依此类推。
- en: '[PRE33]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: References
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: References
- en: '[R157] ([1](#id9),[2](#id10))'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[R157] ([1](#id9),[2](#id10))'
- en: '[https://en.wikipedia.org/wiki/Vigenere_cipher](https://en.wikipedia.org/wiki/Vigenere_cipher)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Vigenere_cipher](https://en.wikipedia.org/wiki/Vigenere_cipher)'
- en: '[R158] ([1](#id8),[2](#id11))'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[R158] ([1](#id8),[2](#id11))'
- en: '[https://web.archive.org/web/20071116100808/https://filebox.vt.edu/users/batman/kryptos.html](https://web.archive.org/web/20071116100808/https://filebox.vt.edu/users/batman/kryptos.html)
    (short URL: [https://goo.gl/ijr22d](https://goo.gl/ijr22d))'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://web.archive.org/web/20071116100808/https://filebox.vt.edu/users/batman/kryptos.html](https://web.archive.org/web/20071116100808/https://filebox.vt.edu/users/batman/kryptos.html)（短链接：[https://goo.gl/ijr22d](https://goo.gl/ijr22d)）'
- en: '[PRE34]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Decode using the Vigenere cipher.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 使用维吉尼亚密码解密。
- en: Examples
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Examples
- en: '[PRE35]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Return the Hill cipher encryption of `msg`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `msg` 的Hill密码加密。
- en: 'Parameters:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 'Parameters:'
- en: '**msg**'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '**msg**'
- en: Plaintext message of \(n\) upper-case letters.
  id: totrans-286
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`n` 个大写字母的明文消息。'
- en: '**key**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**key**'
- en: A \(k \times k\) invertible matrix \(K\), all of whose entries are in \(Z_{26}\)
    (or whatever number of symbols are being used).
  id: totrans-288
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个 \(k \times k\) 可逆矩阵 \(K\)，其所有条目都在 \(Z_{26}\) 中（或者所用符号的任何数量中）。
- en: '**pad**'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**pad**'
- en: Character (default “Q”) to use to make length of text be a multiple of `k`.
  id: totrans-290
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 字符（默认为“Q”）用于使文本长度为 `k` 的倍数。
- en: 'Returns:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 'Returns:'
- en: ct
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: ct
- en: Ciphertext of upper-case letters.
  id: totrans-293
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 大写字母的密文。
- en: Explanation
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: Explanation
- en: The Hill cipher [[R159]](#r159), invented by Lester S. Hill in the 1920’s [[R160]](#r160),
    was the first polygraphic cipher in which it was practical (though barely) to
    operate on more than three symbols at once. The following discussion assumes an
    elementary knowledge of matrices.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Hill密码 [[R159]](#r159)，由莱斯特·希尔在1920年代发明 [[R160]](#r160)，是第一个可以同时处理超过三个符号的多图密码。以下讨论假设对矩阵有基本的了解。
- en: 'First, each letter is first encoded as a number starting with 0. Suppose your
    message \(msg\) consists of \(n\) capital letters, with no spaces. This may be
    regarded an \(n\)-tuple M of elements of \(Z_{26}\) (if the letters are those
    of the English alphabet). A key in the Hill cipher is a \(k x k\) matrix \(K\),
    all of whose entries are in \(Z_{26}\), such that the matrix \(K\) is invertible
    (i.e., the linear transformation \(K: Z_{N}^k \rightarrow Z_{N}^k\) is one-to-one).'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '首先，每个字母都被编码为从0开始的一个数字。假设您的消息 `msg` 由 `n` 个大写字母组成，没有空格。这可以看作是 `n` 元组 `M`，其元素属于
    `Z_{26}`（如果字母是英语字母）。在Hill密码中，一个密钥是一个 \(k \times k\) 矩阵 `K`，其所有条目都在 `Z_{26}` 中，并且矩阵
    `K` 可逆（即，线性变换 `K: Z_{N}^k \rightarrow Z_{N}^k` 是一对一的）。'
- en: Notes
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Notes
- en: 'ALGORITHM:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 'ALGORITHM:'
- en: 'STEPS:'
  id: totrans-299
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 'STEPS:'
- en: ''
  id: totrans-300
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Number the letters of the alphabet from 0, …, N
  id: totrans-301
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将字母从0到N编号
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-303
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from the string `msg` a list `L` of corresponding integers. Let `n =
    len(L)`.
  id: totrans-304
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从字符串 `msg` 计算一个与之对应的整数列表 `L`。设 `n = len(L)`。
- en: ''
  id: totrans-305
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Break the list `L` up into `t = ceiling(n/k)` sublists `L_1`, …, `L_t` of size
    `k` (with the last list “padded” to ensure its size is `k`).
  id: totrans-307
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将列表 `L` 分解为 `t = ceiling(n/k)` 个大小为 `k` 的子列表 `L_1`, …, `L_t`（最后一个列表被“填充”以确保其大小为
    `k`）。
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute new list `C_1`, …, `C_t` given by `C[i] = K*L_i` (arithmetic is done
    mod N), for each `i`.
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算新列表 `C_1`, …, `C_t`，其定义为 `C[i] = K*L_i`（所有的算术都在模 `N` 下进行），对每个 `i`。
- en: ''
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Concatenate these into a list `C = C_1 + ... + C_t`.
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将它们连接成一个列表 `C = C_1 + ... + C_t`。
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute from `C` a string `ct` of corresponding letters. This has length `k*t`.
  id: totrans-316
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `C` 计算一个长度为 `k*t` 的字符串 `ct`，其对应于相应的字母。
- en: See also
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: See also
- en: '[`decipher_hill`](#sympy.crypto.crypto.decipher_hill "sympy.crypto.crypto.decipher_hill")'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[`decipher_hill`](#sympy.crypto.crypto.decipher_hill "sympy.crypto.crypto.decipher_hill")'
- en: References
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: References
- en: '[R159] ([1](#id12),[2](#id14))'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[R159] ([1](#id12),[2](#id14))'
- en: '[https://en.wikipedia.org/wiki/Hill_cipher](https://en.wikipedia.org/wiki/Hill_cipher)'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Hill_cipher](https://en.wikipedia.org/wiki/Hill_cipher)'
- en: '[R160] ([1](#id13),[2](#id15))'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[R160] ([1](#id13),[2](#id15))'
- en: Lester S. Hill, Cryptography in an Algebraic Alphabet, The American Mathematical
    Monthly Vol.36, June-July 1929, pp.306-312.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Lester S. Hill，《代数字母表中的密码学》，《美国数学月刊》第36卷，1929年6月至7月，第306-312页。
- en: '[PRE37]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Deciphering is the same as enciphering but using the inverse of the key matrix.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 解密与加密相同，但使用密钥矩阵的逆。
- en: Examples
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE38]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: When the length of the plaintext (stripped of invalid characters) is not a multiple
    of the key dimension, extra characters will appear at the end of the enciphered
    and deciphered text. In order to decipher the text, those characters must be included
    in the text to be deciphered. In the following, the key has a dimension of 4 but
    the text is 2 short of being a multiple of 4 so two characters will be added.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 当明文长度（去除无效字符）不是密钥维度的倍数时，加密和解密文本的末尾将出现额外字符。为了解密文本，这些字符必须包含在待解密的文本中。接下来，密钥的维度为4，但文本缺少4的倍数，因此将添加两个字符。
- en: '[PRE40]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If the last two characters of the ciphertext were ignored in either case, the
    wrong plaintext would be recovered:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忽略了密文的最后两个字符，则无论如何都会恢复错误的明文：
- en: '[PRE41]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See also
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`encipher_hill`](#sympy.crypto.crypto.encipher_hill "sympy.crypto.crypto.encipher_hill")'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[`encipher_hill`](#sympy.crypto.crypto.encipher_hill "sympy.crypto.crypto.encipher_hill")'
- en: '[PRE42]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Performs the Bifid cipher encryption on plaintext `msg`, and returns the ciphertext.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 对明文 `msg` 进行 Bifid 密码加密，并返回密文。
- en: This is the version of the Bifid cipher that uses an \(n \times n\) Polybius
    square.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 \(n \times n\) Polybius 方阵的 Bifid 密码的版本。
- en: 'Parameters:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**msg**'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息**'
- en: Plaintext string.
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 明文字符串。
- en: '**key**'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥**'
- en: Short string for key.
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密钥的简短字符串。
- en: ''
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Duplicate characters are ignored and then it is padded with the characters in
    `symbols` that were not in the short key.
  id: totrans-344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 忽略重复字符，然后用 `symbols` 中不在短密钥中的字符填充。
- en: '**symbols**'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号**'
- en: \(n \times n\) characters defining the alphabet.
  id: totrans-346
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(n \times n\) 字符定义字母表。
- en: ''
  id: totrans-347
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (default is string.printable)
  id: totrans-348
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （默认为string.printable）
- en: 'Returns:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: ciphertext
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 密文
- en: Ciphertext using Bifid5 cipher without spaces.
  id: totrans-351
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用 Bifid5 密码的无空格密文。
- en: See also
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`decipher_bifid`](#sympy.crypto.crypto.decipher_bifid "sympy.crypto.crypto.decipher_bifid"),
    [`encipher_bifid5`](#sympy.crypto.crypto.encipher_bifid5 "sympy.crypto.crypto.encipher_bifid5"),
    [`encipher_bifid6`](#sympy.crypto.crypto.encipher_bifid6 "sympy.crypto.crypto.encipher_bifid6")'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[`decipher_bifid`](#sympy.crypto.crypto.decipher_bifid "sympy.crypto.crypto.decipher_bifid"),
    [`encipher_bifid5`](#sympy.crypto.crypto.encipher_bifid5 "sympy.crypto.crypto.encipher_bifid5"),
    [`encipher_bifid6`](#sympy.crypto.crypto.encipher_bifid6 "sympy.crypto.crypto.encipher_bifid6")'
- en: References
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R161](#id16)]'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R161](#id16)]'
- en: '[https://en.wikipedia.org/wiki/Bifid_cipher](https://en.wikipedia.org/wiki/Bifid_cipher)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Bifid_cipher](https://en.wikipedia.org/wiki/Bifid_cipher)'
- en: '[PRE43]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Performs the Bifid cipher decryption on ciphertext `msg`, and returns the plaintext.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 对密文 `msg` 进行 Bifid 密码解密，并返回明文。
- en: This is the version of the Bifid cipher that uses the \(n \times n\) Polybius
    square.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 \(n \times n\) Polybius 方阵的 Bifid 密码的版本。
- en: 'Parameters:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**msg**'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息**'
- en: Ciphertext string.
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密文字符串。
- en: '**key**'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥**'
- en: Short string for key.
  id: totrans-364
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密钥的简短字符串。
- en: ''
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Duplicate characters are ignored and then it is padded with the characters in
    symbols that were not in the short key.
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 忽略重复字符，然后用不在短密钥中的符号填充。
- en: '**symbols**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号**'
- en: \(n \times n\) characters defining the alphabet.
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(n \times n\) 字符定义字母表。
- en: ''
  id: totrans-369
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (default=string.printable, a \(10 \times 10\) matrix)
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: （默认=string.printable，一个 \(10 \times 10\) 矩阵）
- en: 'Returns:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: deciphered
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 解密
- en: Deciphered text.
  id: totrans-373
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解密后的文本。
- en: Examples
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE44]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Do an encryption using the bifid5 alphabet:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 bifid5 字母表进行加密：
- en: '[PRE45]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'When entering the text or ciphertext, spaces are ignored so it can be formatted
    as desired. Re-entering the ciphertext from the preceding, putting 4 characters
    per line and padding with an extra J, does not cause problems for the deciphering:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入文本或密文时，忽略空格，以便根据需要格式化。重新输入上述密文，每行放置4个字符并用额外的 J 填充，不会导致解密问题：
- en: '[PRE46]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When no alphabet is given, all 100 printable characters will be used:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有给出字母表时，将使用所有100个可打印字符：
- en: '[PRE47]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'If the key is changed, a different encryption is obtained:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果更改密钥，则会获得不同的加密结果：
- en: '[PRE48]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And if the key used to decrypt the message is not exact, the original text
    will not be perfectly obtained:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用于解密消息的密钥不完全匹配，原始文本将无法完美获取：
- en: '[PRE49]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 5x5 Polybius square.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 5x5 Polybius 方阵。
- en: Produce the Polybius square for the \(5 \times 5\) Bifid cipher.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 \(5 \times 5\) Bifid 密码的 Polybius 方阵。
- en: Examples
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE51]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Performs the Bifid cipher encryption on plaintext `msg`, and returns the ciphertext.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 执行 Bifid 密码加密以获得明文 `msg` 的结果，并返回密文。
- en: 'Parameters:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**msg** : str'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息**：str'
- en: Plaintext string.
  id: totrans-395
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 明文字符串。
- en: ''
  id: totrans-396
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Converted to upper case and filtered of anything but all letters except J.
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 转换为大写并过滤掉除了所有字母之外的任何东西。
- en: '**key**'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥**'
- en: Short string for key; non-alphabetic letters, J and duplicated characters are
    ignored and then, if the length is less than 25 characters, it is padded with
    other letters of the alphabet (in alphabetical order).
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于密钥的短字符串；忽略非字母字符、J 和重复字符，如果长度少于 25 个字符，则用字母表中的其他字母（按字母顺序）填充。
- en: 'Returns:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: ct
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: ct
- en: Ciphertext (all caps, no spaces).
  id: totrans-402
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密文（全大写，无空格）。
- en: Explanation
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This is the version of the Bifid cipher that uses the \(5 \times 5\) Polybius
    square. The letter “J” is ignored so it must be replaced with something else (traditionally
    an “I”) before encryption.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用 \(5 \times 5\) Polybius 方阵的 Bifid 密码的版本。字母“J”被忽略，因此在加密之前必须用其他东西替换（传统上是“I”）。
- en: 'ALGORITHM: (5x5 case)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 算法：（5x5 情况）
- en: 'STEPS:'
  id: totrans-406
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 步骤：
- en: ''
  id: totrans-407
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Create the \(5 \times 5\) Polybius square `S` associated to `key` as follows:'
  id: totrans-408
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建与 `key` 相关的 \(5 \times 5\) Polybius 方阵 `S` 的方式如下：
- en: ''
  id: totrans-409
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-410
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-411
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: moving from left-to-right, top-to-bottom, place the letters of the key into
    a \(5 \times 5\) matrix,
  id: totrans-412
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从左到右，从上到下，将密钥的字母放入一个 \(5 \times 5\) 矩阵中，
- en: ''
  id: totrans-413
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-414
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: if the key has less than 25 letters, add the letters of the alphabet not in
    the key until the \(5 \times 5\) square is filled.
  id: totrans-415
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果密钥少于 25 个字母，添加字母表中不在密钥中的字母，直到填满 \(5 \times 5\) 方阵。
- en: ''
  id: totrans-416
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-417
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a list `P` of pairs of numbers which are the coordinates in the Polybius
    square of the letters in `msg`.
  id: totrans-418
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `msg` 中字母在 Polybius 方阵中的坐标对的列表 `P`。
- en: ''
  id: totrans-419
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-420
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Let `L1` be the list of all first coordinates of `P` (length of `L1 = n`), let
    `L2` be the list of all second coordinates of `P` (so the length of `L2` is also
    `n`).
  id: totrans-421
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设 `L1` 为 `P` 的所有第一个坐标的列表（`L1` 的长度为 `n`），`L2` 为 `P` 的所有第二个坐标的列表（因此 `L2` 的长度也为
    `n`）。
- en: ''
  id: totrans-422
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-423
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Let `L` be the concatenation of `L1` and `L2` (length `L = 2*n`), except that
    consecutive numbers are paired `(L[2*i], L[2*i + 1])`. You can regard `L` as a
    list of pairs of length `n`.
  id: totrans-424
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设 `L` 为 `L1` 和 `L2` 的连接（长度为 `L = 2*n`），但连续的数字成对出现 `(L[2*i], L[2*i + 1])`。您可以将
    `L` 视为长度为 `n` 的对的列表。
- en: ''
  id: totrans-425
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-426
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Let `C` be the list of all letters which are of the form `S[i, j]`, for all
    `(i, j)` in `L`. As a string, this is the ciphertext of `msg`.
  id: totrans-427
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设 `C` 为形如 `S[i, j]` 的所有字母的列表，对于所有 `(i, j)` 属于 `L`。作为字符串，这是 `msg` 的密文。
- en: Examples
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE53]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '“J” will be omitted unless it is replaced with something else:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: “J” 将被省略，除非用其他内容替换：
- en: '[PRE54]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Notes
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: The Bifid cipher was invented around 1901 by Felix Delastelle. It is a *fractional
    substitution* cipher, where letters are replaced by pairs of symbols from a smaller
    alphabet. The cipher uses a \(5 \times 5\) square filled with some ordering of
    the alphabet, except that “J” is replaced with “I” (this is a so-called Polybius
    square; there is a \(6 \times 6\) analog if you add back in “J” and also append
    onto the usual 26 letter alphabet, the digits 0, 1, …, 9). According to Helen
    Gaines’ book *Cryptanalysis*, this type of cipher was used in the field by the
    German Army during World War I.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: Bifid 密码是由 Felix Delastelle 大约在 1901 年发明的。它是一种 *分数替代* 密码，其中字母被较小字母表中的一对符号替换。该密码使用填充了字母顺序的
    \(5 \times 5\) 方阵，除了将“J”替换为“I”之外（这是所谓的 Polybius 方阵；如果添加回“J”并且在通常的 26 个字母表后附加数字
    0、1、…、9，则有一个 \(6 \times 6\) 的类似物）。根据 Helen Gaines 的书籍 *Cryptanalysis*，这种类型的密码曾被第一次世界大战期间的德国军队使用。
- en: See also
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`decipher_bifid5`](#sympy.crypto.crypto.decipher_bifid5 "sympy.crypto.crypto.decipher_bifid5"),
    [`encipher_bifid`](#sympy.crypto.crypto.encipher_bifid "sympy.crypto.crypto.encipher_bifid")'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[`decipher_bifid5`](#sympy.crypto.crypto.decipher_bifid5 "sympy.crypto.crypto.decipher_bifid5"),
    [`encipher_bifid`](#sympy.crypto.crypto.encipher_bifid "sympy.crypto.crypto.encipher_bifid")'
- en: '[PRE55]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Return the Bifid cipher decryption of `msg`.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `msg` 的 Bifid 密码解密。
- en: 'Parameters:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**msg**'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**消息**'
- en: Ciphertext string.
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密文字符串。
- en: '**key**'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥**'
- en: Short string for key; duplicated characters are ignored and if the length is
    less then 25 characters, it will be padded with other letters from the alphabet
    omitting “J”. Non-alphabetic characters are ignored.
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于密钥的短字符串；忽略重复字符，并且如果长度小于 25 个字符，则用字母表中排除“J”的其他字母填充。
- en: 'Returns:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: plaintext
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 明文
- en: Plaintext from Bifid5 cipher (all caps, no spaces).
  id: totrans-445
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Plaintext from Bifid5 cipher (all caps, no spaces).
- en: Explanation
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This is the version of the Bifid cipher that uses the \(5 \times 5\) Polybius
    square; the letter “J” is ignored unless a `key` of length 25 is used.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用\(5 \times 5\) Polybius方阵的Bifid密码版本；除非使用长度为25的`key`，否则字母“J”将被忽略。
- en: Examples
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE56]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Performs the Bifid cipher encryption on plaintext `msg`, and returns the ciphertext.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 对明文`msg`执行Bifid密码加密，并返回密文。
- en: This is the version of the Bifid cipher that uses the \(6 \times 6\) Polybius
    square.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用\(6 \times 6\) Polybius方阵的Bifid密码版本。
- en: 'Parameters:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**msg**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '**msg**'
- en: Plaintext string (digits okay).
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 明文字符串（允许数字）。
- en: '**key**'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '**key**'
- en: Short string for key (digits okay).
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于密钥的简短字符串（允许数字）。
- en: ''
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `key` is less than 36 characters long, the square will be filled with letters
    A through Z and digits 0 through 9.
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`key`长度小于36个字符，方阵将填充字母A到Z和数字0到9。
- en: 'Returns:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: ciphertext
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 密文
- en: Ciphertext from Bifid cipher (all caps, no spaces).
  id: totrans-462
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来自Bifid密码的密文（全大写，无空格）。
- en: See also
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`decipher_bifid6`](#sympy.crypto.crypto.decipher_bifid6 "sympy.crypto.crypto.decipher_bifid6"),
    [`encipher_bifid`](#sympy.crypto.crypto.encipher_bifid "sympy.crypto.crypto.encipher_bifid")'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[`decipher_bifid6`](#sympy.crypto.crypto.decipher_bifid6 "sympy.crypto.crypto.decipher_bifid6")，[`encipher_bifid`](#sympy.crypto.crypto.encipher_bifid
    "sympy.crypto.crypto.encipher_bifid")'
- en: '[PRE58]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Performs the Bifid cipher decryption on ciphertext `msg`, and returns the plaintext.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 对密文`msg`执行Bifid密码解密，并返回明文。
- en: This is the version of the Bifid cipher that uses the \(6 \times 6\) Polybius
    square.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使用\(6 \times 6\) Polybius方阵的Bifid密码版本。
- en: 'Parameters:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**msg**'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '**msg**'
- en: Ciphertext string (digits okay); converted to upper case
  id: totrans-470
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密文字符串（允许数字）；转换为大写
- en: '**key**'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**key**'
- en: Short string for key (digits okay).
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于密钥的简短字符串（允许数字）。
- en: ''
  id: totrans-473
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `key` is less than 36 characters long, the square will be filled with letters
    A through Z and digits 0 through 9. All letters are converted to uppercase.
  id: totrans-474
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`key`长度小于36个字符，方阵将填充字母A到Z和数字0到9。所有字母均转换为大写。
- en: 'Returns:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: plaintext
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 明文
- en: Plaintext from Bifid cipher (all caps, no spaces).
  id: totrans-477
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 来自Bifid密码的明文（全大写，无空格）。
- en: Examples
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE59]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 6x6 Polybius square.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 6x6 Polybius方阵。
- en: Produces the Polybius square for the \(6 \times 6\) Bifid cipher. Assumes alphabet
    of symbols is “A”, …, “Z”, “0”, …, “9”.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 生成\(6 \times 6\) Bifid密码的Polybius方阵。假设符号的字母表是“A”，…，“Z”，“0”，…，“9”。
- en: Examples
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE61]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Return the RSA *public key* pair, \((n, e)\)
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 返回RSA的*公钥*对，\((n, e)\)
- en: 'Parameters:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**args** : naturals'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**args**：自然数'
- en: If specified as \(p, q, e\) where \(p\) and \(q\) are distinct primes and \(e\)
    is a desired public exponent of the RSA, \(n = p q\) and \(e\) will be verified
    against the totient \(\phi(n)\) (Euler totient) or \(\lambda(n)\) (Carmichael
    totient) to be \(\gcd(e, \phi(n)) = 1\) or \(\gcd(e, \lambda(n)) = 1\).
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果指定为\(p, q, e\)，其中\(p\)和\(q\)是不同的素数，\(e\)是RSA的所需公共指数，则\(n = p q\)，\(e\)将针对欧拉函数\(\phi(n)\)或卡米歇尔函数\(\lambda(n)\)进行验证，以确保\(\gcd(e,
    \phi(n)) = 1\)或\(\gcd(e, \lambda(n)) = 1\)。
- en: ''
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If specified as \(p_1, p_2, \dots, p_n, e\) where \(p_1, p_2, \dots, p_n\) are
    specified as primes, and \(e\) is specified as a desired public exponent of the
    RSA, it will be able to form a multi-prime RSA, which is a more generalized form
    of the popular 2-prime RSA.
  id: totrans-491
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果指定为\(p_1, p_2, \dots, p_n, e\)，其中\(p_1, p_2, \dots, p_n\)被指定为素数，\(e\)被指定为RSA的所需公共指数，则能够形成多素数RSA，这是流行的双素数RSA的更广义形式。
- en: ''
  id: totrans-492
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It can also be possible to form a single-prime RSA by specifying the argument
    as \(p, e\), which can be considered a trivial case of a multiprime RSA.
  id: totrans-493
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还可以通过将参数指定为\(p, e\)来形成单素数RSA，这可以被看作是多素数RSA的特例。
- en: ''
  id: totrans-494
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Furthermore, it can be possible to form a multi-power RSA by specifying two
    or more pairs of the primes to be same. However, unlike the two-distinct prime
    RSA or multi-prime RSA, not every numbers in the complete residue system (\(\mathbb{Z}_n\))
    will be decryptable since the mapping \(\mathbb{Z}_{n} \rightarrow \mathbb{Z}_{n}\)
    will not be bijective. (Only except for the trivial case when \(e = 1\) or more
    generally,
  id: totrans-495
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此外，还可以通过指定两个或更多对相同的素数来形成多功率RSA。但是，与双不同素数RSA或多素数RSA不同，完全剩余系统（\(\mathbb{Z}_n\))中的每个数字都将无法解密，因为映射\(\mathbb{Z}_{n}
    \rightarrow \mathbb{Z}_{n}\)不是双射的。（只有在\(e = 1\)或更一般地时除外，
- en: ''
  id: totrans-496
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \[e \in \left \{ 1 + k \lambda(n) \mid k \in \mathbb{Z} \land k \geq 0 \right
    \}\]
  id: totrans-497
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \[e \in \left \{ 1 + k \lambda(n) \mid k \in \mathbb{Z} \land k \geq 0 \right
    \}\]
- en: ''
  id: totrans-498
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: when RSA reduces to the identity.) However, the RSA can still be decryptable
    for the numbers in the reduced residue system (\(\mathbb{Z}_n^{\times}\)), since
    the mapping \(\mathbb{Z}_{n}^{\times} \rightarrow \mathbb{Z}_{n}^{\times}\) can
    still be bijective.
  id: totrans-499
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当RSA归结为恒等式时。）但是，RSA仍然可以解密在减少的剩余系统（\(\mathbb{Z}_n^{\times}\)）中的数字，因为映射\(\mathbb{Z}_{n}^{\times}
    \rightarrow \mathbb{Z}_{n}^{\times}\)仍然可以是双射。
- en: ''
  id: totrans-500
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you pass a non-prime integer to the arguments \(p_1, p_2, \dots, p_n\), the
    particular number will be prime-factored and it will become either a multi-prime
    RSA or a multi-power RSA in its canonical form, depending on whether the product
    equals its radical or not. \(p_1 p_2 \dots p_n = \text{rad}(p_1 p_2 \dots p_n)\)
  id: totrans-501
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果将非素数整数传递给参数\(p_1, p_2, \dots, p_n\)，则该特定数将被素数因子化，并且它将成为其规范形式中的多素数RSA或多功率RSA，具体取决于乘积是否等于其基数或不等。\(p_1
    p_2 \dots p_n = \text{rad}(p_1 p_2 \dots p_n)\)
- en: '**totient** : bool, optional'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '**totient**：布尔值，可选'
- en: If `'Euler'`, it uses Euler’s totient \(\phi(n)\) which is [`sympy.functions.combinatorial.numbers.totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient") in SymPy.
  id: totrans-503
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果是'欧拉'，它使用欧拉的欧拉函数 \(\phi(n)\)，即[`sympy.functions.combinatorial.numbers.totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient") 在SymPy中。
- en: ''
  id: totrans-504
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `'Carmichael'`, it uses Carmichael’s totient \(\lambda(n)\) which is [`sympy.functions.combinatorial.numbers.reduced_totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.reduced_totient
    "sympy.functions.combinatorial.numbers.reduced_totient") in SymPy.
  id: totrans-505
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果是'卡迈克尔'，它使用卡迈克尔的欧拉函数 \(\lambda(n)\)，即[`sympy.functions.combinatorial.numbers.reduced_totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.reduced_totient
    "sympy.functions.combinatorial.numbers.reduced_totient") 在SymPy中。
- en: ''
  id: totrans-506
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unlike private key generation, this is a trivial keyword for public key generation
    because \(\gcd(e, \phi(n)) = 1 \iff \gcd(e, \lambda(n)) = 1\).
  id: totrans-507
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与私钥生成不同，这是公钥生成的一个微不足道的关键字，因为\(\gcd(e, \phi(n)) = 1 \iff \gcd(e, \lambda(n))
    = 1\)。
- en: '**index** : nonnegative integer, optional'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '**index**：非负整数，可选'
- en: Returns an arbitrary solution of a RSA public key at the index specified at
    \(0, 1, 2, \dots\). This parameter needs to be specified along with `totient='Carmichael'`.
  id: totrans-509
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回指定在\(0, 1, 2, \dots\)处的RSA公钥的任意解。此参数需要与`totient='Carmichael'`一起指定。
- en: ''
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Similarly to the non-uniquenss of a RSA private key as described in the `index`
    parameter documentation in [`rsa_private_key()`](#sympy.crypto.crypto.rsa_private_key
    "sympy.crypto.crypto.rsa_private_key"), RSA public key is also not unique and
    there is an infinite number of RSA public exponents which can behave in the same
    manner.
  id: totrans-511
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 与描述[`rsa_private_key()`](#sympy.crypto.crypto.rsa_private_key "sympy.crypto.crypto.rsa_private_key")中的`index`参数文档的RSA私钥的非唯一性类似，RSA公钥也不唯一，并且有无限多个可以以相同方式运行的RSA公共指数。
- en: ''
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: From any given RSA public exponent \(e\), there are can be an another RSA public
    exponent \(e + k \lambda(n)\) where \(k\) is an integer, \(\lambda\) is a Carmichael’s
    totient function.
  id: totrans-513
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于任何给定的RSA公共指数\(e\)，都可以有另一个RSA公共指数\(e + k \lambda(n)\)，其中\(k\)是整数，\(\lambda\)是卡迈克尔的欧拉函数。
- en: ''
  id: totrans-514
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, considering only the positive cases, there can be a principal solution
    of a RSA public exponent \(e_0\) in \(0 < e_0 < \lambda(n)\), and all the other
    solutions can be canonicalzed in a form of \(e_0 + k \lambda(n)\).
  id: totrans-515
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，仅考虑正数情况，可以有RSA公共指数\(e_0\)的主要解，在\(0 < e_0 < \lambda(n)\)，并且所有其他解可以以\(e_0 +
    k \lambda(n)\)的形式规范化。
- en: ''
  id: totrans-516
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`index` specifies the \(k\) notation to yield any possible value an RSA public
    key can have.'
  id: totrans-517
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`index`指定\(k\)表示法，以产生RSA公钥可能具有的任何可能值。'
- en: ''
  id: totrans-518
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An example of computing any arbitrary RSA public key:'
  id: totrans-519
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算任意RSA公钥的示例：
- en: ''
  id: totrans-520
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-521
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '**multipower** : bool, optional'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**multipower**：布尔值，可选'
- en: Any pair of non-distinct primes found in the RSA specification will restrict
    the domain of the cryptosystem, as noted in the explanation of the parameter `args`.
  id: totrans-523
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在RSA规范中找到的任何非不同素数对将限制密码系统的域，如`args`参数说明中所述。
- en: ''
  id: totrans-524
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SymPy RSA key generator may give a warning before dispatching it as a multi-power
    RSA, however, you can disable the warning if you pass `True` to this keyword.
  id: totrans-525
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: SymPy RSA密钥生成器在将其分发为多功率RSA之前可能会发出警告，但是，如果将`True`传递给此关键字，可以禁用警告。
- en: 'Returns:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**(n, e)** : int, int'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '**(n, e)**：整数，整数'
- en: \(n\) is a product of any arbitrary number of primes given as the argument.
  id: totrans-528
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(n\)是给定作为参数的任意数量的素数的乘积。
- en: ''
  id: totrans-529
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \(e\) is relatively prime (coprime) to the Euler totient \(\phi(n)\).
  id: totrans-530
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(e\)与欧拉函数\(\phi(n)\)是相对素数（互质）的。
- en: 'False'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 错误
- en: Returned if less than two arguments are given, or \(e\) is not relatively prime
    to the modulus.
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果给出的参数少于两个或 \(e\) 与模数不互质，则返回。
- en: Examples
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE64]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'A public key of a two-prime RSA:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 两素数RSA的公钥：
- en: '[PRE65]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A public key of a multiprime RSA:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 多素数RSA的公钥：
- en: '[PRE66]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Notes
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Although the RSA can be generalized over any modulus \(n\), using two large
    primes had became the most popular specification because a product of two large
    primes is usually the hardest to factor relatively to the digits of \(n\) can
    have.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管RSA可以推广到任意模数 \(n\)，但使用两个大素数已经成为最流行的规范，因为两个大素数的乘积通常是相对于 \(n\) 的位数最难分解的。
- en: However, it may need further understanding of the time complexities of each
    prime-factoring algorithms to verify the claim.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 但可能需要进一步了解每个素数分解算法的时间复杂度来验证该说法。
- en: See also
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`rsa_private_key`](#sympy.crypto.crypto.rsa_private_key "sympy.crypto.crypto.rsa_private_key"),
    [`encipher_rsa`](#sympy.crypto.crypto.encipher_rsa "sympy.crypto.crypto.encipher_rsa"),
    [`decipher_rsa`](#sympy.crypto.crypto.decipher_rsa "sympy.crypto.crypto.decipher_rsa")'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '[`rsa_private_key`](#sympy.crypto.crypto.rsa_private_key "sympy.crypto.crypto.rsa_private_key"),
    [`encipher_rsa`](#sympy.crypto.crypto.encipher_rsa "sympy.crypto.crypto.encipher_rsa"),
    [`decipher_rsa`](#sympy.crypto.crypto.decipher_rsa "sympy.crypto.crypto.decipher_rsa")'
- en: References
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R162](#id17)]'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R162](#id17)]'
- en: '[https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29](https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29)'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29](https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29)'
- en: '[[R163](#id18)]'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R163](#id18)]'
- en: '[https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf](https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf)'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf](https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf)'
- en: '[[R164](#id19)]'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R164](#id19)]'
- en: '[https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf](https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf)'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf](https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf)'
- en: '[[R165](#id20)]'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R165](#id20)]'
- en: '[https://www.itiis.org/digital-library/manuscript/1381](https://www.itiis.org/digital-library/manuscript/1381)'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.itiis.org/digital-library/manuscript/1381](https://www.itiis.org/digital-library/manuscript/1381)'
- en: '[PRE67]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Return the RSA *private key* pair, \((n, d)\)
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 返回RSA *私钥* 对，\((n, d)\)
- en: 'Parameters:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**args** : naturals'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**args** : 自然数'
- en: The keyword is identical to the `args` in [`rsa_public_key()`](#sympy.crypto.crypto.rsa_public_key
    "sympy.crypto.crypto.rsa_public_key").
  id: totrans-557
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 该关键字与 [`rsa_public_key()`](#sympy.crypto.crypto.rsa_public_key "sympy.crypto.crypto.rsa_public_key")
    中的 `args` 相同。
- en: '**totient** : bool, optional'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '**totient** : 布尔值，可选'
- en: If `'Euler'`, it uses Euler’s totient convention \(\phi(n)\) which is [`sympy.functions.combinatorial.numbers.totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient") in SymPy.
  id: totrans-559
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果是 `'Euler'`，则使用欧拉的欧拉函数约定 \(\phi(n)\)，即 SymPy 中的 [`sympy.functions.combinatorial.numbers.totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.totient
    "sympy.functions.combinatorial.numbers.totient")。
- en: ''
  id: totrans-560
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `'Carmichael'`, it uses Carmichael’s totient convention \(\lambda(n)\) which
    is [`sympy.functions.combinatorial.numbers.reduced_totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.reduced_totient
    "sympy.functions.combinatorial.numbers.reduced_totient") in SymPy.
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果是 `'Carmichael'`，则使用Carmichael的欧拉函数约定 \(\lambda(n)\)，即 SymPy 中的 [`sympy.functions.combinatorial.numbers.reduced_totient()`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.reduced_totient
    "sympy.functions.combinatorial.numbers.reduced_totient")。
- en: ''
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There can be some output differences for private key generation as examples
    below.
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 对于私钥生成，可能会有一些输出差异，如下面的示例。
- en: ''
  id: totrans-564
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Example using Euler’s totient:'
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用欧拉的示例：
- en: ''
  id: totrans-566
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-567
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE68]'
- en: ''
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Example using Carmichael’s totient:'
  id: totrans-569
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使用Carmichael的欧拉函数的示例：
- en: ''
  id: totrans-570
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-571
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '**index** : nonnegative integer, optional'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '**index** : 非负整数，可选'
- en: Returns an arbitrary solution of a RSA private key at the index specified at
    \(0, 1, 2, \dots\). This parameter needs to be specified along with `totient='Carmichael'`.
  id: totrans-573
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回指定索引 \(0, 1, 2, \dots\) 处的RSA私钥的任意解。此参数需与 `totient='Carmichael'` 一起指定。
- en: ''
  id: totrans-574
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: RSA private exponent is a non-unique solution of \(e d \mod \lambda(n) = 1\)
    and it is possible in any form of \(d + k \lambda(n)\), where \(d\) is an another
    already-computed private exponent, and \(\lambda\) is a Carmichael’s totient function,
    and \(k\) is any integer.
  id: totrans-575
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: RSA私钥指数是 \(e d \mod \lambda(n) = 1\) 的非唯一解，可以用 \(d + k \lambda(n)\) 的形式表示，其中
    \(d\) 是另一个已计算的私钥指数，\(\lambda\) 是Carmichael的欧拉函数，\(k\) 是任意整数。
- en: ''
  id: totrans-576
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: However, considering only the positive cases, there can be a principal solution
    of a RSA private exponent \(d_0\) in \(0 < d_0 < \lambda(n)\), and all the other
    solutions can be canonicalzed in a form of \(d_0 + k \lambda(n)\).
  id: totrans-577
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 然而，仅考虑正面情况，RSA私钥指数\(d_0\)在\(0 < d_0 < \lambda(n)\)中可能有一个主要解，所有其他解可以被规范化为\(d_0
    + k \lambda(n)\)的形式。
- en: ''
  id: totrans-578
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`index` specifies the \(k\) notation to yield any possible value an RSA private
    key can have.'
  id: totrans-579
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`index`指定了\(k\)符号来产生RSA私钥可能有的任何可能值。'
- en: ''
  id: totrans-580
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'An example of computing any arbitrary RSA private key:'
  id: totrans-581
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算任意RSA私钥的示例：
- en: ''
  id: totrans-582
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-583
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '**multipower** : bool, optional'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '**多幂**：布尔值，可选'
- en: The keyword is identical to the `multipower` in [`rsa_public_key()`](#sympy.crypto.crypto.rsa_public_key
    "sympy.crypto.crypto.rsa_public_key").
  id: totrans-585
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 关键字与[`rsa_public_key()`](#sympy.crypto.crypto.rsa_public_key "sympy.crypto.crypto.rsa_public_key")中的`multipower`相同。
- en: 'Returns:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**(n, d)** : int, int'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '**(n, d)**：整数，整数'
- en: \(n\) is a product of any arbitrary number of primes given as the argument.
  id: totrans-588
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(n\)是作为参数给出的任意数量质数的乘积。
- en: ''
  id: totrans-589
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \(d\) is the inverse of \(e\) (mod \(\phi(n)\)) where \(e\) is the exponent
    given, and \(\phi\) is a Euler totient.
  id: totrans-590
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(d\)是给定指数\(e\)的模\(\phi(n)\)的逆，\(\phi\)是欧拉函数。
- en: 'False'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 'False'
- en: Returned if less than two arguments are given, or \(e\) is not relatively prime
    to the totient of the modulus.
  id: totrans-592
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果给出少于两个参数，或者\(e\)与模数的欧拉函数不互质，则返回。
- en: Examples
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE71]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'A private key of a two-prime RSA:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 双质数RSA的私钥：
- en: '[PRE72]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'A private key of a multiprime RSA:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 多质数RSA的私钥：
- en: '[PRE73]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: See also
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`rsa_public_key`](#sympy.crypto.crypto.rsa_public_key "sympy.crypto.crypto.rsa_public_key"),
    [`encipher_rsa`](#sympy.crypto.crypto.encipher_rsa "sympy.crypto.crypto.encipher_rsa"),
    [`decipher_rsa`](#sympy.crypto.crypto.decipher_rsa "sympy.crypto.crypto.decipher_rsa")'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '[`rsa_public_key`](#sympy.crypto.crypto.rsa_public_key "sympy.crypto.crypto.rsa_public_key")，[`encipher_rsa`](#sympy.crypto.crypto.encipher_rsa
    "sympy.crypto.crypto.encipher_rsa")，[`decipher_rsa`](#sympy.crypto.crypto.decipher_rsa
    "sympy.crypto.crypto.decipher_rsa")的关键字。'
- en: References
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R166](#id21)]'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R166](#id21)]'
- en: '[https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29](https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29)'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29](https://en.wikipedia.org/wiki/RSA_%28cryptosystem%29)'
- en: '[[R167](#id22)]'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R167](#id22)]'
- en: '[https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf](https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf)'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf](https://cacr.uwaterloo.ca/techreports/2006/cacr2006-16.pdf)'
- en: '[[R168](#id23)]'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R168](#id23)]'
- en: '[https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf](https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf)'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf](https://link.springer.com/content/pdf/10.1007/BFb0055738.pdf)'
- en: '[[R169](#id24)]'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R169](#id24)]'
- en: '[https://www.itiis.org/digital-library/manuscript/1381](https://www.itiis.org/digital-library/manuscript/1381)'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.itiis.org/digital-library/manuscript/1381](https://www.itiis.org/digital-library/manuscript/1381)'
- en: '[PRE74]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Encrypt the plaintext with RSA.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RSA加密明文。
- en: 'Parameters:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**i** : integer'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '**i**：整数'
- en: The plaintext to be encrypted for.
  id: totrans-614
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 待加密的明文。
- en: '**key** : (n, e) where n, e are integers'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥**：(n, e)，其中n、e为整数'
- en: \(n\) is the modulus of the key and \(e\) is the exponent of the key. The encryption
    is computed by \(i^e \bmod n\).
  id: totrans-616
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(n\)是密钥的模数，\(e\)是密钥的指数。加密计算为\(i^e \bmod n\)。
- en: ''
  id: totrans-617
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The key can either be a public key or a private key, however, the message encrypted
    by a public key can only be decrypted by a private key, and vice versa, as RSA
    is an asymmetric cryptography system.
  id: totrans-618
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密钥可以是公钥或私钥，但通过公钥加密的消息只能由私钥解密，反之亦然，因为RSA是一种非对称加密系统。
- en: '**factors** : list of coprime integers'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '**因子**：互质整数列表'
- en: This is identical to the keyword `factors` in [`decipher_rsa()`](#sympy.crypto.crypto.decipher_rsa
    "sympy.crypto.crypto.decipher_rsa").
  id: totrans-620
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这与[`decipher_rsa()`](#sympy.crypto.crypto.decipher_rsa "sympy.crypto.crypto.decipher_rsa")中的关键字`factors`相同。
- en: Notes
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some specifications may make the RSA not cryptographically meaningful.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 一些规范可能使RSA不具有密码学上的意义。
- en: For example, \(0\), \(1\) will remain always same after taking any number of
    exponentiation, thus, should be avoided.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，\(0\)，\(1\)在进行任意次幂后始终保持不变，因此应避免使用。
- en: Furthermore, if \(i^e < n\), \(i\) may easily be figured out by taking \(e\)
    th root.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果\(i^e < n\)，则\(i\)可能很容易通过取\(e\)次根来找到。
- en: And also, specifying the exponent as \(1\) or in more generalized form as \(1
    + k \lambda(n)\) where \(k\) is an nonnegative integer, \(\lambda\) is a carmichael
    totient, the RSA becomes an identity mapping.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 并且，将指数指定为\(1\)或更一般的形式，如\(1 + k \lambda(n)\)，其中\(k\)是非负整数，\(\lambda\)是卡迈克尔欧拉函数，RSA变成一个恒等映射。
- en: Examples
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE75]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Public Key Encryption:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密：
- en: '[PRE76]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Private Key Encryption:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥加密：
- en: '[PRE77]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Encryption using chinese remainder theorem:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中国剩余定理加密：
- en: '[PRE78]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Decrypt the ciphertext with RSA.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 使用RSA解密密文。
- en: 'Parameters:'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**i** : integer'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '**i** : 整数'
- en: The ciphertext to be decrypted for.
  id: totrans-638
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要解密的密文。
- en: '**key** : (n, d) where n, d are integers'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '**key** : (n, d)，其中 n, d 是整数'
- en: \(n\) is the modulus of the key and \(d\) is the exponent of the key. The decryption
    is computed by \(i^d \bmod n\).
  id: totrans-640
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(n\) 是密钥的模数，\(d\) 是密钥的指数。解密通过 \(i^d \bmod n\) 计算。
- en: ''
  id: totrans-641
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The key can either be a public key or a private key, however, the message encrypted
    by a public key can only be decrypted by a private key, and vice versa, as RSA
    is an asymmetric cryptography system.
  id: totrans-642
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密钥可以是公钥或私钥，然而，用公钥加密的消息只能用私钥解密，反之亦然，因为RSA是一种非对称加密系统。
- en: '**factors** : list of coprime integers'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**factors** : 互质整数列表'
- en: As the modulus \(n\) created from RSA key generation is composed of arbitrary
    prime factors \(n = {p_1}^{k_1}{p_2}^{k_2}\dots{p_n}^{k_n}\) where \(p_1, p_2,
    \dots, p_n\) are distinct primes and \(k_1, k_2, \dots, k_n\) are positive integers,
    chinese remainder theorem can be used to compute \(i^d \bmod n\) from the fragmented
    modulo operations like
  id: totrans-644
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于RSA密钥生成中创建的模数 \(n\) 由任意的素数因子组成 \(n = {p_1}^{k_1}{p_2}^{k_2}\dots{p_n}^{k_n}\)，其中
    \(p_1, p_2, \dots, p_n\) 是不同的素数，\(k_1, k_2, \dots, k_n\) 是正整数，可以使用中国剩余定理从分段的模操作计算
    \(i^d \bmod n\)。
- en: ''
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \[i^d \bmod {p_1}^{k_1}, i^d \bmod {p_2}^{k_2}, \dots, i^d \bmod {p_n}^{k_n}\]
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \[i^d \bmod {p_1}^{k_1}, i^d \bmod {p_2}^{k_2}, \dots, i^d \bmod {p_n}^{k_n}\]
- en: ''
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: or like
  id: totrans-648
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 或者如下
- en: ''
  id: totrans-649
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \[i^d \bmod {p_1}^{k_1}{p_2}^{k_2}, i^d \bmod {p_3}^{k_3}, \dots , i^d \bmod
    {p_n}^{k_n}\]
  id: totrans-650
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \[i^d \bmod {p_1}^{k_1}{p_2}^{k_2}, i^d \bmod {p_3}^{k_3}, \dots , i^d \bmod
    {p_n}^{k_n}\]
- en: ''
  id: totrans-651
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: as long as every moduli does not share any common divisor each other.
  id: totrans-652
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 只要每个模数之间没有共同的除数。
- en: ''
  id: totrans-653
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The raw primes used in generating the RSA key pair can be a good option.
  id: totrans-654
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于生成RSA密钥对的原始素数可以是一个不错的选择。
- en: ''
  id: totrans-655
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that the speed advantage of using this is only viable for very large cases
    (Like 2048-bit RSA keys) since the overhead of using pure Python implementation
    of [`sympy.ntheory.modular.crt()`](ntheory.html#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt")
    may overcompensate the theoretical speed advantage.
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意使用此方法的速度优势仅适用于非常大的情况（如2048位RSA密钥），因为使用[`sympy.ntheory.modular.crt()`](ntheory.html#sympy.ntheory.modular.crt
    "sympy.ntheory.modular.crt")的纯Python实现的开销可能超过了理论上的速度优势。
- en: Notes
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: See the `Notes` section in the documentation of [`encipher_rsa()`](#sympy.crypto.crypto.encipher_rsa
    "sympy.crypto.crypto.encipher_rsa")
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`encipher_rsa()`](#sympy.crypto.crypto.encipher_rsa "sympy.crypto.crypto.encipher_rsa")的文档的`Notes`部分查看。
- en: Examples
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE80]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Public Key Encryption and Decryption:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密和解密：
- en: '[PRE81]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Private Key Encryption and Decryption:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 私钥加密和解密：
- en: '[PRE82]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Decryption using chinese remainder theorem:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 使用中国剩余定理进行解密：
- en: '[PRE83]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: See also
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`encipher_rsa`](#sympy.crypto.crypto.encipher_rsa "sympy.crypto.crypto.encipher_rsa")'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '[`encipher_rsa`](#sympy.crypto.crypto.encipher_rsa "sympy.crypto.crypto.encipher_rsa")'
- en: '[PRE84]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Kid RSA is a version of RSA useful to teach grade school children since it does
    not involve exponentiation.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: Kid RSA是一种版本的RSA，适合用来教授小学生，因为它不涉及指数运算。
- en: Explanation
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'Alice wants to talk to Bob. Bob generates keys as follows. Key generation:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: Alice想要和Bob交流。Bob生成密钥如下。密钥生成：
- en: Select positive integers \(a, b, A, B\) at random.
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择正整数 \(a, b, A, B\)。
- en: Compute \(M = a b - 1\), \(e = A M + a\), \(d = B M + b\), \(n = (e d - 1)//M\).
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算 \(M = a b - 1\), \(e = A M + a\), \(d = B M + b\), \(n = (e d - 1)//M\)。
- en: The *public key* is \((n, e)\). Bob sends these to Alice.
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*公钥* 是 \((n, e)\)。Bob将这些发送给Alice。'
- en: The *private key* is \((n, d)\), which Bob keeps secret.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*私钥* 是 \((n, d)\), 这是Bob保密的。'
- en: 'Encryption: If \(p\) is the plaintext message then the ciphertext is \(c =
    p e \pmod n\).'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 加密：如果 \(p\) 是明文消息，则密文是 \(c = p e \pmod n\)。
- en: 'Decryption: If \(c\) is the ciphertext message then the plaintext is \(p =
    c d \pmod n\).'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 解密：如果 \(c\) 是密文消息，则明文是 \(p = c d \pmod n\)。
- en: Examples
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE85]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Compute \(M = a b - 1\), \(e = A M + a\), \(d = B M + b\), \(n = (e d - 1) /
    M\). The *private key* is \(d\), which Bob keeps secret.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 \(M = a b - 1\), \(e = A M + a\), \(d = B M + b\), \(n = (e d - 1) / M\)。*私钥*
    是 \(d\), 这是Bob保密的。
- en: Examples
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE87]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Here `msg` is the plaintext and `key` is the public key.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `msg` 是明文，`key` 是公钥。
- en: Examples
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE89]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Here `msg` is the plaintext and `key` is the private key.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `msg` 是明文，`key` 是私钥。
- en: Examples
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE91]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Encodes a plaintext into popular Morse Code with letters separated by `sep`
    and words by a double `sep`.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 将明文编码为普通的摩斯密码，字母之间用 `sep` 分隔，单词之间用双 `sep` 分隔。
- en: Examples
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE93]'
  id: totrans-696
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: References
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R170](#id25)]'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R170](#id25)]'
- en: '[https://en.wikipedia.org/wiki/Morse_code](https://en.wikipedia.org/wiki/Morse_code)'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Morse_code](https://en.wikipedia.org/wiki/Morse_code)'
- en: '[PRE94]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Decodes a Morse Code with letters separated by `sep` (default is ‘|’) and words
    by \(word_sep\) (default is ‘||) into plaintext.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 解码摩斯电码，字母用 `sep`（默认为‘|’）分隔，单词用 \(word_sep\)（默认为‘||’）分隔成纯文本。
- en: Examples
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE95]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: References
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R171](#id26)]'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R171](#id26)]'
- en: '[https://en.wikipedia.org/wiki/Morse_code](https://en.wikipedia.org/wiki/Morse_code)'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Morse_code](https://en.wikipedia.org/wiki/Morse_code)'
- en: '[PRE96]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: This function creates an LFSR sequence.
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数创建一个 LFSR 序列。
- en: 'Parameters:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**key** : list'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥**：list'
- en: A list of finite field elements, \([c_0, c_1, \ldots, c_k].\)
  id: totrans-711
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 有限域元素列表，\([c_0, c_1, \ldots, c_k]\)。
- en: '**fill** : list'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '**填充**：list'
- en: The list of the initial terms of the LFSR sequence, \([x_0, x_1, \ldots, x_k].\)
  id: totrans-713
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LFSR 序列的初始项列表，\([x_0, x_1, \ldots, x_k]\)。
- en: '**n**'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**'
- en: Number of terms of the sequence that the function returns.
  id: totrans-715
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 函数返回的序列项数。
- en: 'Returns:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: L
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: L
- en: The LFSR sequence defined by \(x_{n+1} = c_k x_n + \ldots + c_0 x_{n-k}\), for
    \(n \leq k\).
  id: totrans-718
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由 \(x_{n+1} = c_k x_n + \ldots + c_0 x_{n-k}\) 定义的 LFSR 序列，对于 \(n \leq k\)。
- en: Notes
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: S. Golomb [[G171]](#g171) gives a list of three statistical properties a sequence
    of numbers \(a = \{a_n\}_{n=1}^\infty\), \(a_n \in \{0,1\}\), should display to
    be considered “random”. Define the autocorrelation of \(a\) to be
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: S. Golomb [[G171]](#g171) 给出了一个数字序列 \(a = \{a_n\}_{n=1}^\infty\), \(a_n \in
    \{0,1\}\)，应显示为“随机”的三个统计属性列表。定义 \(a\) 的自相关为
- en: \[C(k) = C(k,a) = \lim_{N\rightarrow \infty} {1\over N}\sum_{n=1}^N (-1)^{a_n
    + a_{n+k}}.\]
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: \[C(k) = C(k,a) = \lim_{N\rightarrow \infty} {1\over N}\sum_{n=1}^N (-1)^{a_n
    + a_{n+k}}.\]
- en: In the case where \(a\) is periodic with period \(P\) then this reduces to
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(a\) 周期为 \(P\)，则此情况下简化为
- en: \[C(k) = {1\over P}\sum_{n=1}^P (-1)^{a_n + a_{n+k}}.\]
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: \[C(k) = {1\over P}\sum_{n=1}^P (-1)^{a_n + a_{n+k}}.\]
- en: Assume \(a\) is periodic with period \(P\).
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 \(a\) 是周期为 \(P\) 的周期性序列。
- en: 'balance:'
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 平衡：
- en: \[\left|\sum_{n=1}^P(-1)^{a_n}\right| \leq 1.\]
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: \[\left|\sum_{n=1}^P(-1)^{a_n}\right| \leq 1.\]
- en: 'low autocorrelation:'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低自相关：
- en: \[\begin{split}C(k) = \left\{ \begin{array}{cc} 1,& k = 0,\\ \epsilon, & k \ne
    0\. \end{array} \right.\end{split}\]
  id: totrans-728
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \[\begin{split}C(k) = \left\{ \begin{array}{cc} 1,& k = 0,\\ \epsilon, & k \ne
    0\. \end{array} \right.\end{split}\]
- en: (For sequences satisfying these first two properties, it is known that \(\epsilon
    = -1/P\) must hold.)
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: （对于满足这两个属性的序列，已知必须满足 \(\epsilon = -1/P\)。）
- en: 'proportional runs property: In each period, half the runs have length \(1\),
    one-fourth have length \(2\), etc. Moreover, there are as many runs of \(1\)’s
    as there are of \(0\)’s.'
  id: totrans-730
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比例运行特性：在每个周期内，一半的运行长度为 \(1\)，四分之一的运行长度为 \(2\)，等等。此外，\(1\) 的运行数与 \(0\) 的运行数相同。
- en: Examples
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE97]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: References
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[G171] ([1](#id27),[2](#id28))'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '[G171] ([1](#id27),[2](#id28))'
- en: Solomon Golomb, Shift register sequences, Aegean Park Press, Laguna Hills, Ca,
    1967
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: Solomon Golomb, Shift register sequences, Aegean Park Press, Laguna Hills, Ca,
    1967
- en: '[PRE98]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: This function computes the LFSR autocorrelation function.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数计算 LFSR 自相关函数。
- en: 'Parameters:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**L**'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '**L**'
- en: A periodic sequence of elements of \(GF(2)\). L must have length larger than
    P.
  id: totrans-740
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(GF(2)\) 元素的周期序列。 L 必须比 P 长。
- en: '**P**'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '**P**'
- en: The period of L.
  id: totrans-742
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: L 的周期。
- en: '**k** : int'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '**k**：int'
- en: An integer \(k\) (\(0 < k < P\)).
  id: totrans-744
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个整数 \(k\) (\(0 < k < P\))。
- en: 'Returns:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: autocorrelation
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 自相关
- en: The k-th value of the autocorrelation of the LFSR L.
  id: totrans-747
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: LFSR L 的自相关的第 k 个值。
- en: Examples
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE99]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: This function computes the LFSR connection polynomial.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数计算 LFSR 连接多项式。
- en: 'Parameters:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**s**'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '**s**'
- en: A sequence of elements of even length, with entries in a finite field.
  id: totrans-754
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个偶数长度的元素序列，其条目在有限域内。
- en: 'Returns:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: C(x)
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: C(x)
- en: The connection polynomial of a minimal LFSR yielding s.
  id: totrans-757
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 生成 s 的最小 LFSR 的连接多项式。
- en: ''
  id: totrans-758
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This implements the algorithm in section 3 of J. L. Massey’s article [[M172]](#m172).
  id: totrans-759
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此处实现了 J. L. Massey 文章第 3 节的算法 [[M172]](#m172)。
- en: Examples
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE101]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: References
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[M172] ([1](#id29),[2](#id30))'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '[M172] ([1](#id29),[2](#id30))'
- en: James L. Massey, “Shift-Register Synthesis and BCH Decoding.” IEEE Trans. on
    Information Theory, vol. 15(1), pp. 122-127, Jan 1969.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: James L. Massey, “Shift-Register Synthesis and BCH Decoding.” IEEE Trans. on
    Information Theory, vol. 15(1), pp. 122-127, Jan 1969.
- en: '[PRE102]'
  id: totrans-765
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Return three number tuple as public key.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 以公钥返回三个数字元组。
- en: 'Parameters:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**key** : (p, r, e)'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '**密钥**：(p, r, e)'
- en: Tuple generated by `elgamal_private_key`.
  id: totrans-769
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由 `elgamal_private_key` 生成的元组。
- en: 'Returns:'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**tuple** : (p, r, e)'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '**元组**：(p, r, e)'
- en: \(e = r**d \bmod p\)
  id: totrans-772
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(e = r**d \bmod p\)
- en: ''
  id: totrans-773
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \(d\) is a random number in private key.
  id: totrans-774
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(d\) 是私钥中的随机数。
- en: Examples
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE103]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Return three number tuple as private key.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 以私钥返回三个数字元组。
- en: 'Parameters:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**digit** : int'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字**：int'
- en: Minimum number of binary digits for key.
  id: totrans-781
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 密钥的最小二进制位数。
- en: 'Returns:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**tuple** : (p, r, d)'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '**元组**：(p, r, d)'
- en: p = prime number.
  id: totrans-784
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: p = 素数。
- en: ''
  id: totrans-785
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: r = primitive root.
  id: totrans-786
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: r = 原根。
- en: ''
  id: totrans-787
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: d = random number.
  id: totrans-788
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: d = 随机数。
- en: Explanation
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: Elgamal encryption is based on the mathematical problem called the Discrete
    Logarithm Problem (DLP). For example,
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: Elgamal加密基于称为离散对数问题（DLP）的数学问题。例如，
- en: \(a^{b} \equiv c \pmod p\)
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: \(a^{b} \equiv c \pmod p\)
- en: In general, if `a` and `b` are known, `ct` is easily calculated. If `b` is unknown,
    it is hard to use `a` and `ct` to get `b`.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果已知 `a` 和 `b`，则很容易计算 `ct`。如果 `b` 是未知的，则很难使用 `a` 和 `ct` 来获得 `b`。
- en: Notes
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: For testing purposes, the `seed` parameter may be set to control the output
    of this routine. See sympy.core.random._randrange.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，可以设置 `seed` 参数以控制此过程的输出。参见sympy.core.random._randrange。
- en: Examples
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE105]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Encrypt message with public key.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥加密消息。
- en: 'Parameters:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**msg**'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '**msg**'
- en: int of encoded message.
  id: totrans-801
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 编码消息的整数。
- en: '**key**'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: '**key**'
- en: Public key.
  id: totrans-803
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 公钥。
- en: 'Returns:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**tuple** : (c1, c2)'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '**tuple** : (c1, c2)'
- en: Encipher into two number.
  id: totrans-806
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将加密成两个数字。
- en: Explanation
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: '`i` is a plaintext message expressed as an integer. `key` is public key (p,
    r, e). In order to encrypt a message, a random number `a` in `range(2, p)` is
    generated and the encryped message is returned as \(c_{1}\) and \(c_{2}\) where:'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '`i`是以整数表示的明文消息。 `key`是公钥（p，r，e）。为了加密消息，生成范围为 `range(2, p)` 中的随机数 `a`，并返回加密后的消息作为
    \(c_{1}\) 和 \(c_{2}\)，其中：'
- en: \(c_{1} \equiv r^{a} \pmod p\)
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: \(c_{1} \equiv r^{a} \pmod p\)
- en: \(c_{2} \equiv m e^{a} \pmod p\)
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: \(c_{2} \equiv m e^{a} \pmod p\)
- en: Notes
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: For testing purposes, the `seed` parameter may be set to control the output
    of this routine. See sympy.core.random._randrange.
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，可以设置 `seed` 参数以控制此过程的输出。参见sympy.core.random._randrange。
- en: Examples
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE107]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Decrypt message with private key.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 使用私钥解密消息。
- en: \(msg = (c_{1}, c_{2})\)
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: \(msg = (c_{1}, c_{2})\)
- en: \(key = (p, r, d)\)
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: \(key = (p, r, d)\)
- en: According to extended Eucliden theorem, \(u c_{1}^{d} + p n = 1\)
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 根据扩展欧几里得定理，\(u c_{1}^{d} + p n = 1\)
- en: \(u \equiv 1/{{c_{1}}^d} \pmod p\)
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: \(u \equiv 1/{{c_{1}}^d} \pmod p\)
- en: \(u c_{2} \equiv \frac{1}{c_{1}^d} c_{2} \equiv \frac{1}{r^{ad}} c_{2} \pmod
    p\)
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: \(u c_{2} \equiv \frac{1}{c_{1}^d} c_{2} \equiv \frac{1}{r^{ad}} c_{2} \pmod
    p\)
- en: \(\frac{1}{r^{ad}} m e^a \equiv \frac{1}{r^{ad}} m {r^{d a}} \equiv m \pmod
    p\)
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: \(\frac{1}{r^{ad}} m e^a \equiv \frac{1}{r^{ad}} m {r^{d a}} \equiv m \pmod
    p\)
- en: Examples
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE109]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Return three number tuple as public key.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 返回三个数字元组作为公钥。
- en: This is the tuple that Alice sends to Bob.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Alice发送给Bob的元组。
- en: 'Parameters:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**key** : (p, g, a)'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '**key** : (p, g, a)'
- en: A tuple generated by `dh_private_key`.
  id: totrans-831
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由 `dh_private_key` 生成的元组。
- en: 'Returns:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**tuple** : int, int, int'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '**tuple** : int, int, int'
- en: A tuple of \((p, g, g^a \mod p)\) with \(p\), \(g\) and \(a\) given as parameters.s
  id: totrans-834
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个元组 \((p, g, g^a \mod p)\)，其中给定参数为 `p`，`g` 和 `a`。
- en: Examples
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE112]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Return three integer tuple as private key.
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
  zh: 返回三个整数元组作为私钥。
- en: 'Parameters:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**digit**'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: '**digit**'
- en: Minimum number of binary digits required in key.
  id: totrans-841
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 钥匙所需的最小二进制位数。
- en: 'Returns:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**tuple** : (p, g, a)'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: '**tuple** : (p, g, a)'
- en: p = prime number.
  id: totrans-844
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: p = 素数。
- en: ''
  id: totrans-845
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: g = primitive root of p.
  id: totrans-846
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: g = p 的原根。
- en: ''
  id: totrans-847
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: a = random number from 2 through p - 1.
  id: totrans-848
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: a = 从2到p-1的随机数。
- en: Explanation
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: Diffie-Hellman key exchange is based on the mathematical problem called the
    Discrete Logarithm Problem (see ElGamal).
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie-Hellman密钥交换基于称为离散对数问题的数学问题（参见ElGamal）。
- en: 'Diffie-Hellman key exchange is divided into the following steps:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: Diffie-Hellman密钥交换分为以下步骤：
- en: Alice and Bob agree on a base that consist of a prime `p` and a primitive root
    of `p` called `g`
  id: totrans-852
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice和Bob同意一个基础，由素数 `p` 和称为 `g` 的原根组成。
- en: Alice choses a number `a` and Bob choses a number `b` where `a` and `b` are
    random numbers in range \([2, p)\). These are their private keys.
  id: totrans-853
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice选择一个数字 `a`，Bob选择一个数字 `b`，其中 `a` 和 `b` 是在范围 \([2, p)\) 中的随机数。这些是他们的私钥。
- en: Alice then publicly sends Bob \(g^{a} \pmod p\) while Bob sends Alice \(g^{b}
    \pmod p\)
  id: totrans-854
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice公开发送 \(g^{a} \pmod p\) 给Bob，而Bob向Alice发送 \(g^{b} \pmod p\)。
- en: They both raise the received value to their secretly chosen number (`a` or `b`)
    and now have both as their shared key \(g^{ab} \pmod p\)
  id: totrans-855
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 他们都将接收到的值提升到他们秘密选择的数字（`a`或`b`）上，现在两者都有 `g^{ab} \pmod p` 作为他们的共享密钥。
- en: Notes
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: For testing purposes, the `seed` parameter may be set to control the output
    of this routine. See sympy.core.random._randrange.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试目的，可以设置 `seed` 参数以控制此过程的输出。参见sympy.core.random._randrange。
- en: Examples
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE114]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Return an integer that is the shared key.
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个整数，即共享密钥。
- en: This is what Bob and Alice can both calculate using the public keys they received
    from each other and their private keys.
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Bob和Alice可以使用彼此收到的公钥及其私钥计算的内容。
- en: 'Parameters:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**key** : (p, g, x)'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '**key** : (p, g, x)'
- en: Tuple \((p, g, x)\) generated by `dh_public_key`.
  id: totrans-865
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由 `dh_public_key` 生成的元组 \((p, g, x)\)。
- en: '**b**'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: '**b**'
- en: Random number in the range of \(2\) to \(p - 1\) (Chosen by second key exchange
    member (Bob)).
  id: totrans-867
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在范围\(2\)到\(p - 1\)内的随机数（由第二个密钥交换成员（Bob）选择）。
- en: 'Returns:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: int
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: A shared key.
  id: totrans-870
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 共享密钥。
- en: Examples
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE116]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Compute public keys for `p` and `q`. Note that in Goldwasser-Micali Encryption,
    public keys are randomly selected.
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`p`和`q`的公钥。请注意，在Goldwasser-Micali加密中，公钥是随机选择的。
- en: 'Parameters:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**p, q, a** : int, int, int'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '**p, q, a**：int, int, int'
- en: Initialization variables.
  id: totrans-877
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 初始化变量。
- en: 'Returns:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**tuple** : (a, N)'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: '**tuple**：(a, N)'
- en: '`a` is the input `a` if it is not `None` otherwise some random integer coprime
    to `p` and `q`.'
  id: totrans-880
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`a`不为`None`，则`a`是输入的`a`，否则是一些与`p`和`q`互质的随机整数。
- en: ''
  id: totrans-881
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`N` is the product of `p` and `q`.'
  id: totrans-882
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`N`是`p`和`q`的乘积。'
- en: '[PRE118]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Check if `p` and `q` can be used as private keys for the Goldwasser-Micali encryption.
    The method works roughly as follows.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`p`和`q`是否可以用作Goldwasser-Micali加密的私钥。该方法大致如下运行。
- en: 'Parameters:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**p, q, a**'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '**p, q, a**'
- en: Initialization variables.
  id: totrans-887
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 初始化变量。
- en: 'Returns:'
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**tuple** : (p, q)'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: '**tuple**：(p, q)'
- en: The input value `p` and `q`.
  id: totrans-890
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入值`p`和`q`。
- en: 'Raises:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**ValueError**'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '**ValueError**'
- en: If `p` and `q` are not distinct odd primes.
  id: totrans-893
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`p`和`q`不是不同的奇素数。
- en: Explanation
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Pick two large primes \(p\) and \(q\).
  id: totrans-895
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择两个大素数\(p\)和\(q\)。
- en: Call their product \(N\).
  id: totrans-896
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 称它们的乘积为\(N\)。
- en: Given a message as an integer \(i\), write \(i\) in its bit representation \(b_0,
    \dots, b_n\).
  id: totrans-897
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个整数消息\(i\)，将\(i\)用其比特表示写成\(b_0, \dots, b_n\)。
- en: For each \(k\),
  id: totrans-898
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个\(k\)，
- en: 'if \(b_k = 0\):'
  id: totrans-899
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果\(b_k = 0\)：
- en: ''
  id: totrans-900
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: let \(a_k\) be a random square (quadratic residue) modulo \(p q\) such that
    `jacobi_symbol(a, p*q) = 1`
  id: totrans-901
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让\(a_k\)是一个随机平方数（二次剩余），模\(p q\)，使得`jacobi_symbol(a, p*q) = 1`
- en: ''
  id: totrans-902
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'if \(b_k = 1\):'
  id: totrans-903
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果\(b_k = 1\)：
- en: ''
  id: totrans-904
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: let \(a_k\) be a random non-square (non-quadratic residue) modulo \(p q\) such
    that `jacobi_symbol(a, p*q) = 1`
  id: totrans-905
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 让\(a_k\)是一个随机的非平方数（非二次剩余），模\(p q\)，使得`jacobi_symbol(a, p*q) = 1`
- en: returns \(\left[a_1, a_2, \dots\right]\)
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 返回\(\left[a_1, a_2, \dots\right]\)
- en: \(b_k\) can be recovered by checking whether or not \(a_k\) is a residue. And
    from the \(b_k\)’s, the message can be reconstructed.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: \(b_k\)可以通过检查\(a_k\)是否是余数来恢复。并且从\(b_k\)中，消息可以被重建。
- en: The idea is that, while `jacobi_symbol(a, p*q)` can be easily computed (and
    when it is equal to \(-1\) will tell you that \(a\) is not a square mod \(p q\)),
    quadratic residuosity modulo a composite number is hard to compute without knowing
    its factorization.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 思路是，虽然`jacobi_symbol(a, p*q)`可以很容易计算（当等于\(-1\)时，表明\(a\)在模\(p q\)下不是二次剩余），但二次剩余性模一个复合数的难度在不知其因数分解的情况下很难计算。
- en: Moreover, approximately half the numbers coprime to \(p q\) have [`jacobi_symbol()`](ntheory.html#sympy.ntheory.residue_ntheory.jacobi_symbol
    "sympy.ntheory.residue_ntheory.jacobi_symbol") equal to \(1\) . And among those,
    approximately half are residues and approximately half are not. This maximizes
    the entropy of the code.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，大约一半与\(p q\)互质的数具有[`jacobi_symbol()`](ntheory.html#sympy.ntheory.residue_ntheory.jacobi_symbol
    "sympy.ntheory.residue_ntheory.jacobi_symbol")等于\(1\)。在这些数中，大约一半是剩余，大约一半不是。这最大化了代码的熵。
- en: '[PRE119]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Encrypt integer ‘i’ using public_key ‘key’ Note that gm uses random encryption.
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥‘key’加密整数‘i’注意，gm使用随机加密。
- en: 'Parameters:'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**i** : int'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: '**i**：int'
- en: The message to encrypt.
  id: totrans-914
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要加密的消息。
- en: '**key** : (a, N)'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '**key**：(a, N)'
- en: The public key.
  id: totrans-916
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 公钥。
- en: 'Returns:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**list** : list of int'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '**list**：int列表'
- en: The randomized encrypted message.
  id: totrans-919
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 随机化的加密消息。
- en: '[PRE120]'
  id: totrans-920
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Decrypt message ‘message’ using public_key ‘key’.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥‘key’解密消息‘message’。
- en: 'Parameters:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**message** : list of int'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: '**message**：int列表'
- en: The randomized encrypted message.
  id: totrans-924
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 随机化的加密消息。
- en: '**key** : (p, q)'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '**key**：(p, q)'
- en: The private key.
  id: totrans-926
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 私钥。
- en: 'Returns:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: int
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: int
- en: The encrypted message.
  id: totrans-929
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 加密后的消息。
- en: '[PRE121]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Performs Railfence Encryption on plaintext and returns ciphertext
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 在明文上执行栅栏加密并返回密文
- en: 'Parameters:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**message** : string, the message to encrypt.'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '**message**：string，要加密的消息。'
- en: '**rails** : int, the number of rails.'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '**rails**：int，栏的数量。'
- en: 'Returns:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: The Encrypted string message.
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 加密后的字符串消息。
- en: Examples
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE122]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: References
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R174](#id31)]'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R174](#id31)]'
- en: '[https://en.wikipedia.org/wiki/Rail_fence_cipher](https://en.wikipedia.org/wiki/Rail_fence_cipher)'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/铁栏加密](https://en.wikipedia.org/wiki/Rail_fence_cipher)'
- en: '[PRE123]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Decrypt the message using the given rails
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 使用给定的栏解密消息
- en: 'Parameters:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**message** : string, the message to encrypt.'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '**message**：string，要加密的消息。'
- en: '**rails** : int, the number of rails.'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: '**rails**：int，栏的数量。'
- en: 'Returns:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: The Decrypted string message.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 解密后的字符串消息。
- en: Examples
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE124]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
