["```py\n>>> from scipy import special\n>>> import numpy as np\n>>> def drumhead_height(n, k, distance, angle, t):\n...    kth_zero = special.jn_zeros(n, k)[-1]\n...    return np.cos(t) * np.cos(n*angle) * special.jn(n, distance*kth_zero)\n>>> theta = np.r_[0:2*np.pi:50j]\n>>> radius = np.r_[0:1:50j]\n>>> x = np.array([r * np.cos(theta) for r in radius])\n>>> y = np.array([r * np.sin(theta) for r in radius])\n>>> z = np.array([drumhead_height(1, 1, r, theta, 0.5) for r in radius]) \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> fig = plt.figure()\n>>> ax = fig.add_axes(rect=(0, 0.05, 0.95, 0.95), projection='3d')\n>>> ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap='RdBu_r', vmin=-0.5, vmax=0.5)\n>>> ax.set_xlabel('X')\n>>> ax.set_ylabel('Y')\n>>> ax.set_xticks(np.arange(-1, 1.1, 0.5))\n>>> ax.set_yticks(np.arange(-1, 1.1, 0.5))\n>>> ax.set_zlabel('Z')\n>>> plt.show() \n```", "```py\ncimport scipy.special.cython_special as csc\n\ncdef:\n    double x = 1\n    double complex z = 1 + 1j\n    double si, ci, rgam\n    double complex cgam\n\nrgam = csc.gamma(x)\nprint(rgam)\ncgam = csc.gamma(z)\nprint(cgam)\ncsc.sici(x, &si, &ci)\nprint(si, ci) \n```", "```py\nimport scipy.special as sc\ncimport scipy.special.cython_special as csc\n\ndef python_tight_loop():\n    cdef:\n        int n\n        double x = 1\n\n    for n in range(100):\n        sc.jv(n, x)\n\ndef cython_tight_loop():\n    cdef:\n        int n\n        double x = 1\n\n    for n in range(100):\n        csc.jv(n, x) \n```", "```py\nfrom libc.math cimport fabs\ncimport cython\nfrom cython.parallel cimport prange\n\nimport numpy as np\nimport scipy.special as sc\ncimport scipy.special.cython_special as csc\n\ndef serial_G(k, x, y):\n    return 0.25j*sc.hankel1(0, k*np.abs(x - y))\n\n@cython.boundscheck(False)\n@cython.wraparound(False)\ncdef void _parallel_G(double k, double[:,:] x, double[:,:] y,\n                      double complex[:,:] out) nogil:\n    cdef int i, j\n\n    for i in prange(x.shape[0]):\n        for j in range(y.shape[0]):\n            out[i,j] = 0.25j*csc.hankel1(0, k*fabs(x[i,j] - y[i,j]))\n\ndef parallel_G(k, x, y):\n    out = np.empty_like(x, dtype='complex128')\n    _parallel_G(k, x, y, out)\n    return out \n```", "```py\nimport timeit\n\nimport numpy as np\n\nfrom test import serial_G, parallel_G\n\ndef main():\n    k = 1\n    x, y = np.linspace(-100, 100, 1000), np.linspace(-100, 100, 1000)\n    x, y = np.meshgrid(x, y)\n\n    def serial():\n        serial_G(k, x, y)\n\n    def parallel():\n        parallel_G(k, x, y)\n\n    time_serial = timeit.timeit(serial, number=3)\n    time_parallel = timeit.timeit(parallel, number=3)\n    print(\"Serial method took {:.3} seconds\".format(time_serial))\n    print(\"Parallel method took {:.3} seconds\".format(time_parallel))\n\nif __name__ == \"__main__\":\n    main() \n```", "```py\ndef binary_entropy(x):\n    return -(sc.xlogy(x, x) + sc.xlog1py(1 - x, -x))/np.log(2) \n```", "```py\ndef step(x):\n    return 0.5*(np.sign(x) + np.sign(1 - x)) \n```", "```py\ndef ramp(x):\n    return np.maximum(0, x) \n```"]