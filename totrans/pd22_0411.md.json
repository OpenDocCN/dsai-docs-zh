["```py\nDataFrame.to_sql(name, con, *, schema=None, if_exists='fail', index=True, index_label=None, chunksize=None, dtype=None, method=None)\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> engine = create_engine('sqlite://', echo=False) \n```", "```py\n>>> df = pd.DataFrame({'name' : ['User 1', 'User 2', 'User 3']})\n>>> df\n name\n0  User 1\n1  User 2\n2  User 3 \n```", "```py\n>>> df.to_sql(name='users', con=engine)\n3\n>>> from sqlalchemy import text\n>>> with engine.connect() as conn:\n...    conn.execute(text(\"SELECT * FROM users\")).fetchall()\n[(0, 'User 1'), (1, 'User 2'), (2, 'User 3')] \n```", "```py\n>>> with engine.begin() as connection:\n...     df1 = pd.DataFrame({'name' : ['User 4', 'User 5']})\n...     df1.to_sql(name='users', con=connection, if_exists='append')\n2 \n```", "```py\n>>> df2 = pd.DataFrame({'name' : ['User 6', 'User 7']})\n>>> df2.to_sql(name='users', con=engine, if_exists='append')\n2\n>>> with engine.connect() as conn:\n...    conn.execute(text(\"SELECT * FROM users\")).fetchall()\n[(0, 'User 1'), (1, 'User 2'), (2, 'User 3'),\n (0, 'User 4'), (1, 'User 5'), (0, 'User 6'),\n (1, 'User 7')] \n```", "```py\n>>> df2.to_sql(name='users', con=engine, if_exists='replace',\n...            index_label='id')\n2\n>>> with engine.connect() as conn:\n...    conn.execute(text(\"SELECT * FROM users\")).fetchall()\n[(0, 'User 6'), (1, 'User 7')] \n```", "```py\n>>> from sqlalchemy.dialects.postgresql import insert\n>>> def insert_on_conflict_nothing(table, conn, keys, data_iter):\n...     # \"a\" is the primary key in \"conflict_table\"\n...     data = [dict(zip(keys, row)) for row in data_iter]\n...     stmt = insert(table.table).values(data).on_conflict_do_nothing(index_elements=[\"a\"])\n...     result = conn.execute(stmt)\n...     return result.rowcount\n>>> df_conflict.to_sql(name=\"conflict_table\", con=conn, if_exists=\"append\", method=insert_on_conflict_nothing)  \n0 \n```", "```py\n>>> from sqlalchemy.dialects.mysql import insert\n>>> def insert_on_conflict_update(table, conn, keys, data_iter):\n...     # update columns \"b\" and \"c\" on primary key conflict\n...     data = [dict(zip(keys, row)) for row in data_iter]\n...     stmt = (\n...         insert(table.table)\n...         .values(data)\n...     )\n...     stmt = stmt.on_duplicate_key_update(b=stmt.inserted.b, c=stmt.inserted.c)\n...     result = conn.execute(stmt)\n...     return result.rowcount\n>>> df_conflict.to_sql(name=\"conflict_table\", con=conn, if_exists=\"append\", method=insert_on_conflict_update)  \n2 \n```", "```py\n>>> df = pd.DataFrame({\"A\": [1, None, 2]})\n>>> df\n A\n0  1.0\n1  NaN\n2  2.0 \n```", "```py\n>>> from sqlalchemy.types import Integer\n>>> df.to_sql(name='integers', con=engine, index=False,\n...           dtype={\"A\": Integer()})\n3 \n```", "```py\n>>> with engine.connect() as conn:\n...   conn.execute(text(\"SELECT * FROM integers\")).fetchall()\n[(1,), (None,), (2,)] \n```"]