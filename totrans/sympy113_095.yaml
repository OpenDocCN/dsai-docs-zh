- en: Solveset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/solvers/solveset.html](https://docs.sympy.org/latest/modules/solvers/solveset.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is the official documentation of the `solveset` module in solvers. It contains
    the frequently asked questions about our new module to solve equations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For a beginner-friendly guide focused on solving common types of equations,
    refer to [Solve Equations](../../guides/solving/index.html#solving-guide).
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s wrong with solve():'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SymPy already has a pretty powerful `solve` function. But it has some deficiencies.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'It doesn’t have a consistent output for various types of solutions It needs
    to return a lot of types of solutions consistently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Single solution : \(x = 1\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple solutions: \(x^2 = 1\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'No Solution: \(x^2 + 1 = 0 ; x \in \mathbb{R}\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Interval of solution: \(\lfloor x \rfloor = 0\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Infinitely many solutions: \(\sin(x) = 0\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multivariate functions with point solutions: \(x^2 + y^2 = 0\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multivariate functions with non-point solution: \(x^2 + y^2 = 1\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'System of equations: \(x + y = 1\) and \(x - y = 0\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Relational: \(x > 0\)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And the most important case: “We don’t Know”'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The input API has a lot of parameters and it can be difficult to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are cases like finding the maxima and minima of function using critical
    points where it is important to know if it has returned all the solutions. `solve`
    does not guarantee this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '## Why Solveset?'
  prefs: []
  type: TYPE_NORMAL
- en: '`solveset` has an alternative consistent input and output interface: `solveset`
    returns a set object and a set object takes care of all types of output. For cases
    where it does not “know” all the solutions a `ConditionSet` with a partial solution
    is returned. For input it only takes the equation, the variables to solve for
    and the optional argument `domain` over which the equation is to be solved.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`solveset` can return infinitely many solutions. For example solving for \(\sin{(x)}
    = 0\) returns \(\{2 n \pi | n \in \mathbb{Z}\} \cup \{2 n \pi + \pi | n \in \mathbb{Z}\}\),
    whereas `solve` only returns \([0, \pi]\).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a clear code level and interface level separation between solvers for
    equations in the complex domain and the real domain. For example solving \(e^x
    = 1\) when \(x\) is to be solved in the complex domain, returns the set of all
    solutions, that is \(\{2 n i \pi | n \in \mathbb{Z}\}\), whereas if \(x\) is to
    be solved in the real domain then only \(\{0\}\) is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why do we use Sets as an output type?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SymPy has a well developed sets module, which can represent most of the set
    containers in mathematics such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents a finite set of discrete numbers.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Interval`](../sets.html#sympy.sets.sets.Interval "sympy.sets.sets.Interval")'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents a real interval as a set.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ProductSet`](../sets.html#sympy.sets.sets.ProductSet "sympy.sets.sets.ProductSet")'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents a Cartesian product of sets.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ImageSet`](../sets.html#sympy.sets.fancysets.ImageSet "sympy.sets.fancysets.ImageSet")'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the image of a set under a mathematical function
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ComplexRegion`](../sets.html#sympy.sets.fancysets.ComplexRegion "sympy.sets.fancysets.ComplexRegion")'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the set of all complex numbers in a region in the Argand plane.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet "sympy.sets.conditionset.ConditionSet")'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the set of elements, which satisfies a given condition.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Also, the predefined set classes such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Naturals`](../sets.html#sympy.sets.fancysets.Naturals "sympy.sets.fancysets.Naturals"),
    $mathbb{N}'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the natural numbers (or counting numbers), which are all positive
    integers starting from 1.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Naturals0`](../sets.html#sympy.sets.fancysets.Naturals0 "sympy.sets.fancysets.Naturals0"),
    \(\mathbb{N_0}\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the whole numbers, which are all the non-negative integers, inclusive
    of 0.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Integers`](../sets.html#sympy.sets.fancysets.Integers "sympy.sets.fancysets.Integers"),
    \(\mathbb{Z}\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Represents all integers: positive, negative and zero.'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Reals`](../sets.html#sympy.sets.fancysets.Reals "sympy.sets.fancysets.Reals"),
    \(\mathbb{R}\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the set of all real numbers.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Complexes`](../sets.html#sympy.sets.fancysets.Complexes "sympy.sets.fancysets.Complexes"),
    \(\mathbb{C}\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the set of all complex numbers.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`EmptySet`](../sets.html#sympy.sets.sets.EmptySet "sympy.sets.sets.EmptySet"),
    \(\emptyset\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the empty set.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The above six sets are available as Singletons, like `S.Integers`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'It is capable of most of the set operations in mathematics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Union`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Intersection`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Complement`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SymmetricDifference`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The main reason for using sets as output to solvers is that it can consistently
    represent many types of solutions. For the single variable case it can represent:'
  prefs: []
  type: TYPE_NORMAL
- en: No solution (by the empty set).
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Finitely many solutions (by `FiniteSet`).
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Infinitely many solutions, both countably and uncountably infinite solutions
    (using the `ImageSet` module).
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Interval`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: There can also be bizarre solutions to equations like the set of rational numbers.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: No other Python object (list, dictionary, generator, Python sets) provides the
    flexibility of mathematical sets which our sets module tries to emulate. The second
    reason to use sets is that they are close to the entities which mathematicians
    deal with and it makes it easier to reason about them. Set objects conform to
    Pythonic conventions when possible, i.e., `x in A` and `for i in A` both work
    when they can be computed. Another advantage of using objects closer to mathematical
    entities is that the user won’t have to “learn” our representation and she can
    have her expectations transferred from her mathematical experience.
  prefs: []
  type: TYPE_NORMAL
- en: For the multivariate case we represent solutions as a set of points in a n-dimensional
    space and a point is represented by a `FiniteSet` of ordered tuples, which is
    a point in \(\mathbb{R}^n\) or \(\mathbb{C}^n\).
  prefs: []
  type: TYPE_NORMAL
- en: Please note that, the general `FiniteSet` is unordered, but a `FiniteSet` with
    a tuple as its only argument becomes ordered, since a tuple is ordered. So the
    order in the tuple is mapped to a pre-defined order of variables while returning
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Why not use dicts as output?
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionary are easy to deal with programmatically but mathematically they are
    not very precise and use of them can quickly lead to inconsistency and a lot of
    confusion. For example:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are a lot of cases where we don’t know the complete solution and we may
    like to output a partial solution, consider the equation \(fg = 0\). The solution
    of this equation is the union of the solution of the following two equations:
    \(f = 0\), \(g = 0\). Let’s say that we are able to solve \(f = 0\) but solving
    \(g = 0\) isn’t supported yet. In this case we cannot represent partial solution
    of the given equation \(fg = 0\) using dicts. This problem is solved with sets
    using a `ConditionSet` object:'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(sol_f \cup \{x | x ∊ \mathbb{R} ∧ g = 0\}\), where \(sol_f\) is the solution
    of the equation \(f = 0\).
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using a dict may lead to surprising results like:'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`solve(Eq(x**2, 1), x) != solve(Eq(y**2, 1), y)`'
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Mathematically, this doesn’t make sense. Using `FiniteSet` here solves the problem.
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: It also cannot represent solutions for equations like \(|x| < 1\), which is
    a disk of radius 1 in the Argand Plane. This problem is solved using complex sets
    implemented as `ComplexRegion`.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Input API of `solveset`
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`solveset` has simpler input API, unlike `solve`. It takes a maximum of three
    arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`solveset(equation, variable=None, domain=S.Complexes)`'
  prefs: []
  type: TYPE_NORMAL
- en: Equation
  prefs: []
  type: TYPE_NORMAL
- en: The equation to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Variable
  prefs: []
  type: TYPE_NORMAL
- en: The variable for which the equation is to be solved.
  prefs: []
  type: TYPE_NORMAL
- en: Domain
  prefs: []
  type: TYPE_NORMAL
- en: The domain in which the equation is to be solved.
  prefs: []
  type: TYPE_NORMAL
- en: '`solveset` removes the `flags` argument of `solve`, which had made the input
    API more complicated and output API inconsistent.'
  prefs: []
  type: TYPE_NORMAL
- en: '## What is this domain argument about?'
  prefs: []
  type: TYPE_NORMAL
- en: Solveset is designed to be independent of the assumptions on the variable being
    solved for and instead, uses the `domain` argument to decide the solver to dispatch
    the equation to, namely `solveset_real` or `solveset_complex`. It’s unlike the
    old `solve` which considers the assumption on the variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What are the general methods employed by solveset to solve an equation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solveset uses various methods to solve an equation, here is a brief overview
    of the methodology:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `domain` argument is first considered to know the domain in which the user
    is interested to get the solution.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If the given function is a relational (`>=`, `<=`, `>`, `<`), and the domain
    is real, then `solve_univariate_inequality` and solutions are returned. Solving
    for complex solutions of inequalities, like \(x^2 < 0\) is not yet supported.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Based on the `domain`, the equation is dispatched to one of the two functions
    `solveset_real` or `solveset_complex`, which solves the given equation in the
    complex or real domain, respectively.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If the given expression is a product of two or more functions, like say \(gh
    = 0\), then the solution to the given equation is the Union of the solution of
    the equations \(g = 0\) and \(h = 0\), if and only if both \(g\) and \(h\) are
    finite for a finite input. So, the solution is built up recursively.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If the function is trigonometric or hyperbolic, the function `_solve_real_trig`
    is called, which solves it by converting it to complex exponential form.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The function is now checked if there is any instance of a `Piecewise` expression,
    if it is, then it’s converted to explicit expression and set pairs and then solved
    recursively.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The respective solver now tries to invert the equation using the routines `invert_real`
    and `invert_complex`. These routines are based on the concept of mathematical
    inverse (though not exactly). It reduces the real/complex valued equation \(f(x)
    = y\) to a set of equations: \(\{g(x) = h_1(y), g(x) = h_2(y), ..., g(x) = h_n(y)
    \}\) where \(g(x)\) is a simpler function than \(f(x)\). There is some work needed
    to be done in this to find invert of more complex expressions.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: After the invert, the equations are checked for radical or Abs (Modulus), then
    the method `_solve_radical` tries to simplify the radical, by removing it using
    techniques like squaring, cubing etc, and `_solve_abs` solves nested Modulus by
    considering the positive and negative variants, iteratively.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If none of the above method is successful, then methods of polynomial is used
    as follows:'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The method to solve the rational function, `_solve_as_rational`, is called.
    Based on the domain, the respective poly solver `_solve_as_poly_real` or `_solve_as_poly_complex`
    is called to solve `f` as a polynomial.
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The underlying method `_solve_as_poly` solves the equation using polynomial
    techniques if it’s already a polynomial equation or, with a change of variables,
    can be made so.
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The final solution set returned by `solveset` is the intersection of the set
    of solutions found above and the input domain.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: How do we manipulate and return an infinite solution?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the real domain, we use our `ImageSet` class in the sets module to return
    infinite solutions. `ImageSet` is an image of a set under a mathematical function.
    For example, to represent the solution of the equation \(\sin{(x)} = 0\), we can
    use the `ImageSet` as:'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Where `n` is a dummy variable. It is basically the image of the set of integers
    under the function \(2\pi n\).
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the complex domain, we use complex sets, which are implemented as the `ComplexRegion`
    class in the sets module, to represent infinite solution in the Argand plane.
    For example to represent the solution of the equation \(|z| = 1\), which is a
    unit circle, we can use the `ComplexRegion` as:'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Where the `FiniteSet` in the `ProductSet` is the range of the value of \(r\),
    which is the radius of the circle and the `Interval` is the range of \(\theta\),
    the angle from the \(x\) axis representing a unit circle in the Argand plane.
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note: We also have non-polar form notation for representing solution in rectangular
    form. For example, to represent first two quadrants in the Argand plane, we can
    write the `ComplexRegion` as:'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: where the Intervals are the range of \(x\) and \(y\) for the set of complex
    numbers \(x + iy\).
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: How does `solveset` ensure that it is not returning any wrong solution?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solvers in a Computer Algebra System are based on heuristic algorithms, so
    it’s usually very hard to ensure 100% percent correctness, in every possible case.
    However there are still a lot of cases where we can ensure correctness. Solveset
    tries to verify correctness wherever it can. For example:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the equation \(|x| = n\). A naive method to solve this equation would
    return `{-n, n}` as its solution, which is not correct since `{-n, n}` can be
    its solution if and only if `n` is positive. Solveset returns this information
    as well to ensure correctness.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Though, there still a lot of work needs to be done in this regard.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Search based solver and step-by-step solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Note: This is under Development.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After the introduction of [`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet
    "sympy.sets.conditionset.ConditionSet"), the solving of equations can be seen
    as set transformations. Here is an abstract view of the things we can do to solve
    equations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Apply various set transformations on the given set.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Define a metric of the usability of solutions, or a notion of some solutions
    being better than others.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Different transformations would be the nodes of a tree.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Suitable searching techniques could be applied to get the best solution.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ConditionSet` gives us the ability to represent unevaluated equations and
    inequalities in forms like \(\{x|f(x)=0; x \in S\}\) and \(\{x|f(x)>0; x \in S\}\)
    but a more powerful thing about `ConditionSet` is that it allows us to write the
    intermediate steps as set to set transformation. Some of the transformations are:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Composition: \(\{x|f(g(x))=0;x \in S\} \Rightarrow \{x|g(x)=y; x \in S, y \in
    \{z|f(z)=0; z \in S\}\}\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Polynomial Solver: \(\{x | P(x) = 0;x \in S\} \Rightarrow \{x_1,x_2, ... ,x_n\}
    \cap S\),'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: where \(x_i\) are roots of \(P(x)\).
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Invert solver: \(\{x|f(x)=0;x \in S\} \Rightarrow \{g(0)| \text{ all g such
    that } f(g(x)) = x\}\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'logcombine: \(\{x| \log(f(x)) + \log(g(x));x \in S\}\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(\Rightarrow \{x| \log(f(x).g(x)); x \in S\} \text{ if } f(x) > 0 \text{ and
    } g(x) > 0\) \(\Rightarrow \{x| \log(f(x)) + \log(g(x));x \in S\} \text{ otherwise}\)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'product solve: \(\{x|f(x)g(x)=0; x \in S\}\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(\Rightarrow \{x|f(x)=0; x \in S\} U \{x|g(x)=0; x \in S\}\) \(\text{ given
    } f(x) \text{ and } g(x) \text{ are bounded.}\) \(\Rightarrow \{x|f(x)g(x)=0;
    x \in S\}, \text{ otherwise}\)
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since the output type is same as the input type any composition of these transformations
    is also a valid transformation. And our aim is to find the right sequence of compositions
    (given the atoms) which transforms the given condition set to a set which is not
    a condition set i.e., FiniteSet, Interval, Set of Integers and their Union, Intersection,
    Complement or ImageSet. We can assign a cost function to each set, such that,
    the more desirable that form of set is to us, the less the value of the cost function.
    This way our problem is now reduced to finding the path from the initial ConditionSet
    to the lowest valued set on a graph where the atomic transformations forms the
    edges.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How do we deal with cases where only some of the solutions are known?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a universal equation solver, which can solve each and every equation
    we encounter in mathematics is an ideal case for solvers in a Computer Algebra
    System. When cases which are not solved or can only be solved incompletely, a
    `ConditionSet` is used and acts as an unevaluated solveset object.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that, mathematically, finding a complete set of solutions for an equation
    is undecidable. See [Richardson’s theorem](https://en.wikipedia.org/wiki/Richardson%27s_theorem).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ConditionSet` is basically a Set of elements which satisfy a given condition.
    For example, to represent the solutions of the equation in the real domain:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \[(x^2 - 4)(\sin(x) + x)\]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can represent it as:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \(\{-2, 2\} ∪ \{x | x \in \mathbb{R} ∧ x + \sin(x) = 0\}\)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What is the plan for solve and solveset?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are still a few things `solveset` can’t do, which `solve` can, such as
    solving nonlinear multivariate & LambertW type equations. Hence, it’s not yet
    a perfect replacement for `solve`. As the algorithms in `solveset` mature, `solveset`
    may be able to be used within `solve` to replace some of its algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: How are symbolic parameters handled in solveset?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Solveset is in its initial phase of development, so the symbolic parameters
    aren’t handled well for all the cases, but some work has been done in this regard
    to depict our ideology towards symbolic parameters. As an example, consider the
    solving of \(|x| = n\) for real \(x\), where \(n\) is a symbolic parameter. Solveset
    returns the value of \(x\) considering the domain of the symbolic parameter \(n\)
    as well:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \[([0, \infty) \cap \{n\}) \cup ((-\infty, 0] \cap \{-n\}).\]
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This simply means \(n\) is the solution only when it belongs to the `Interval`
    \([0, \infty)\) and \(-n\) is the solution only when \(-n\) belongs to the `Interval`
    \((- \infty, 0]\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are other cases to address too, like solving \(2^x + (a - 2)\) for \(x\)
    where \(a\) is a symbolic parameter. As of now, It returns the solution as an
    intersection with \(\mathbb{R}\), which is trivial, as it doesn’t reveal the domain
    of \(a\) in the solution.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Recently, we have also implemented a function to find the domain of the expression
    in a FiniteSet (Intersection with the interval) in which it is not-empty. It is
    a useful addition for dealing with symbolic parameters. For example:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Solveset Module Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use [`solveset()`](#sympy.solvers.solveset.solveset "sympy.solvers.solveset.solveset")
    to solve equations or expressions (assumed to be equal to 0) for a single variable.
    Solving an equation like \(x^2 == 1\) can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Or one may manually rewrite the equation as an expression equal to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first argument for [`solveset()`](#sympy.solvers.solveset.solveset "sympy.solvers.solveset.solveset")
    is an expression (equal to zero) or an equation and the second argument is the
    symbol that we want to solve the equation for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Solves a given inequality or equation with set as output
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f** : Expr or a relational.'
  prefs: []
  type: TYPE_NORMAL
- en: The target equation or inequality
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbol** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The variable for which the equation is solved
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**domain** : Set'
  prefs: []
  type: TYPE_NORMAL
- en: The domain over which the equation is solved
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs: []
  type: TYPE_NORMAL
- en: A set of values for \(symbol\) for which \(f\) is True or is equal to zero.
    An [`EmptySet`](../sets.html#sympy.sets.sets.EmptySet "sympy.sets.sets.EmptySet")
    is returned if \(f\) is False or nonzero. A [`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet
    "sympy.sets.conditionset.ConditionSet") is returned as unsolved object if algorithms
    to evaluate complete solution are not yet implemented.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`solveset` claims to be complete in the solution set that it returns.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NotImplementedError**'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithms to solve inequalities in complex domain are not yet implemented.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: The input is not valid.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**RuntimeError**'
  prefs: []
  type: TYPE_NORMAL
- en: It is a bug, please report to the github issue tracker.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Python interprets 0 and 1 as False and True, respectively, but in this function
    they refer to solutions of an expression. So 0 and 1 return the domain and EmptySet,
    respectively, while True and False return the opposite (as they are assumed to
    be solutions of relational expressions).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The default domain is complex. Not specifying a domain will lead to the solving
    of the equation in the complex domain (and this is not affected by the assumptions
    on the symbol):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you want to use `solveset` to solve the equation in the real domain, provide
    a real domain. (Using `solveset_real` does this automatically.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is unaffected by assumptions on the symbol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'When a [`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet "sympy.sets.conditionset.ConditionSet")
    is returned, symbols with assumptions that would alter the set are replaced with
    more generic symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Inequalities can be solved over the real domain only. Use of a complex domain
    leads to a NotImplementedError.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`solveset_real`](#sympy.solvers.solveset.solveset_real "sympy.solvers.solveset.solveset_real")'
  prefs: []
  type: TYPE_NORMAL
- en: solver for real domain
  prefs: []
  type: TYPE_NORMAL
- en: '[`solveset_complex`](#sympy.solvers.solveset.solveset_complex "sympy.solvers.solveset.solveset_complex")'
  prefs: []
  type: TYPE_NORMAL
- en: solver for complex domain
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Inverts a real-valued function. Same as [`invert_complex()`](#sympy.solvers.solveset.invert_complex
    "sympy.solvers.solveset.invert_complex"), but sets the domain to `S.Reals` before
    inverting.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Reduce the complex valued equation \(f(x) = y\) to a set of equations
  prefs: []
  type: TYPE_NORMAL
- en: \[\left\{g(x) = h_1(y),\ g(x) = h_2(y),\ \dots,\ g(x) = h_n(y) \right\}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(g(x)\) is a simpler function than \(f(x)\). The return value is a tuple
    \((g(x), \mathrm{set}_h)\), where \(g(x)\) is a function of \(x\) and \(\mathrm{set}_h\)
    is the set of function \(\left\{h_1(y), h_2(y), \dots, h_n(y)\right\}\). Here,
    \(y\) is not necessarily a symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '\(\mathrm{set}_h\) contains the functions, along with the information about
    the domain in which they are valid, through set operations. For instance, if \(y
    = |x| - n\) is inverted in the real domain, then \(\mathrm{set}_h\) is not simply
    \(\{-n, n\}\) as the nature of \(n\) is unknown; rather, it is:'
  prefs: []
  type: TYPE_NORMAL
- en: $$ left(left[0, inftyright) cap left{nright}right) cup
  prefs: []
  type: TYPE_NORMAL
- en: left(left(-infty, 0right] cap left{- nright}right)$$
  prefs: []
  type: TYPE_NORMAL
- en: By default, the complex domain is used which means that inverting even seemingly
    simple functions like \(\exp(x)\) will give very different results from those
    obtained in the real domain. (In the case of \(\exp(x)\), the inversion via \(\log\)
    is multi-valued in the complex domain, having infinitely many branches.)
  prefs: []
  type: TYPE_NORMAL
- en: If you are working with real values only (or you are not sure which function
    to use) you should probably set the domain to `S.Reals` (or use `invert_real`
    which does that automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When does exp(x) == y?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When does exp(x) == 1?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`invert_real`](#sympy.solvers.solveset.invert_real "sympy.solvers.solveset.invert_real"),
    [`invert_complex`](#sympy.solvers.solveset.invert_complex "sympy.solvers.solveset.invert_complex")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Returns False if point p is infinite or any subexpression of f is infinite or
    becomes so after replacing symbol with p. If none of these conditions is met then
    True will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The function relies on the assumption that the original form of the equation
    has not been changed by automatic simplification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To deal with automatic evaluations use evaluate=False:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Solves an equation using solveset and returns the solution in accordance with
    the \(solve\) output API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: We classify the output based on the type of solution returned by \(solveset\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NotImplementedError**'
  prefs: []
  type: TYPE_NORMAL
- en: A ConditionSet is the input.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Solution | Output
  prefs: []
  type: TYPE_NORMAL
- en: FiniteSet | list
  prefs: []
  type: TYPE_NORMAL
- en: ImageSet, | list (if \(f\) is periodic) Union |
  prefs: []
  type: TYPE_NORMAL
- en: Union | list (with FiniteSet)
  prefs: []
  type: TYPE_NORMAL
- en: EmptySet | empty list
  prefs: []
  type: TYPE_NORMAL
- en: Others | None
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Converts a given System of Equations into Matrix form. Here \(equations\) must
    be a linear system of equations in \(symbols\). Element `M[i, j]` corresponds
    to the coefficient of the jth symbol in the ith equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Matrix form corresponds to the augmented matrix form. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: \[4x + 2y + 3z = 1\]\[3x + y + z = -6\]\[2x + 4y + 9z = 2\]
  prefs: []
  type: TYPE_NORMAL
- en: 'This system will return \(A\) and \(b\) as:'
  prefs: []
  type: TYPE_NORMAL
- en: $$ A = left[begin{array}{ccc}
  prefs: []
  type: TYPE_NORMAL
- en: 4 & 2 & 3 \ 3 & 1 & 1 \ 2 & 4 & 9 end{array}right] b = left[begin{array}{c}
    1 \ -6 \ 2 end{array}right] $$
  prefs: []
  type: TYPE_NORMAL
- en: The only simplification performed is to convert `Eq(a, b)` \(\Rightarrow a -
    b\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NonlinearError**'
  prefs: []
  type: TYPE_NORMAL
- en: The equations contain a nonlinear term.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: The symbols are not given or are not unique.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The coefficients (numerical or symbolic) of the symbols will be returned as
    matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This routine does not simplify expressions and will raise an error if nonlinearity
    is encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Simplifying these equations will discard the removable singularity in the first
    and reveal the linear structure of the second:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Any such simplification needed to eliminate nonlinear terms must be done *before*
    calling this routine.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Solve system of \(N\) linear equations with \(M\) variables; both underdetermined
    and overdetermined systems are supported. The possible number of solutions is
    zero, one or infinite. Zero solutions throws a ValueError, whereas infinite solutions
    are represented parametrically in terms of the given symbols. For unique solution
    a [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")
    of ordered tuples is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'All standard input formats are supported: For the given set of equations, the
    respective input types are given below:'
  prefs: []
  type: TYPE_NORMAL
- en: \[3x + 2y - z = 1\]\[2x - 2y + 4z = -2\]\[2x - y + 2z = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Augmented matrix form, `system` given below:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $$ text{system} = left[{array}{cccc}
  prefs: []
  type: TYPE_NORMAL
- en: 3 & 2 & -1 & 1\ 2 & -2 & 4 & -2\ 2 & -1 & 2 & 0 end{array}right] $$
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: List of equations form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Input \(A\) and \(b\) in matrix form (from \(Ax = b\)) are given as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: $$ A = left[begin{array}{ccc}
  prefs: []
  type: TYPE_NORMAL
- en: 3 & 2 & -1 \ 2 & -2 & 4 \ 2 & -1 & 2 end{array}right] b = left[begin{array}{c}
    1 \ -2 \ 0 end{array}right] $$
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Symbols can always be passed but are actually only needed when 1) a system of
    equations is being passed and 2) the system is passed as an underdetermined matrix
    and one wants to control the name of the free variables in the result. An error
    is raised if no symbols are used for case 1, but if no symbols are provided for
    case 2, internally generated symbols will be provided. When providing symbols
    for case 2, there should be at least as many symbols are there are columns in
    matrix A.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm used here is Gauss-Jordan elimination, which results, after elimination,
    in a row echelon form matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: A FiniteSet containing an ordered tuple of values for the
  prefs: []
  type: TYPE_NORMAL
- en: unknowns for which the \(system\) has a solution. (Wrapping
  prefs: []
  type: TYPE_NORMAL
- en: the tuple in FiniteSet is used to maintain a consistent
  prefs: []
  type: TYPE_NORMAL
- en: output format throughout solveset.)
  prefs: []
  type: TYPE_NORMAL
- en: Returns EmptySet, if the linear system is inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: The input is not valid. The symbols are not given.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Parametric Solution: In case the system is underdetermined, the function will
    return a parametric solution in terms of the given symbols. Those that are free
    will be returned unchanged. e.g. in the system below, \(z\) is returned as the
    solution for variable z; it can take on any value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If no symbols are given, internally generated symbols will be used. The `tau0`
    in the third position indicates (as before) that the third variable – whatever
    it is named – can take on any value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: List of equations as input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Augmented matrix as input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Solve for symbolic coefficients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: A degenerate system returns solution as set of given symbols.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For an empty system linsolve returns empty set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: An error is raised if any nonlinearity is detected, even if it could be removed
    with expansion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Solve system of \(N\) nonlinear equations with \(M\) variables, which means
    both under and overdetermined systems are supported. Positive dimensional system
    is also supported (A system with infinitely many solutions is said to be positive-dimensional).
    In a positive dimensional system the solution will be dependent on at least one
    symbol. Returns both real solution and complex solution (if they exist).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**system** : list of equations'
  prefs: []
  type: TYPE_NORMAL
- en: The target system of equations
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbols** : list of Symbols'
  prefs: []
  type: TYPE_NORMAL
- en: symbols should be given as a sequence eg. list
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: A [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")
    of ordered tuple of values of \(symbols\) for which the \(system\)
  prefs: []
  type: TYPE_NORMAL
- en: has solution. Order of values in the tuple is same as symbols present in
  prefs: []
  type: TYPE_NORMAL
- en: the parameter \(symbols\).
  prefs: []
  type: TYPE_NORMAL
- en: Please note that general [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet
    "sympy.sets.sets.FiniteSet") is unordered, the solution
  prefs: []
  type: TYPE_NORMAL
- en: returned here is not simply a [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet
    "sympy.sets.sets.FiniteSet") of solutions, rather it
  prefs: []
  type: TYPE_NORMAL
- en: is a [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")
    of ordered tuple, i.e. the first and only
  prefs: []
  type: TYPE_NORMAL
- en: argument to [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")
    is a tuple of solutions, which is
  prefs: []
  type: TYPE_NORMAL
- en: ordered, and, hence ,the returned solution is ordered.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that solution could also have been returned as an ordered tuple,
  prefs: []
  type: TYPE_NORMAL
- en: FiniteSet is just a wrapper `{}` around the tuple. It has no other
  prefs: []
  type: TYPE_NORMAL
- en: significance except for the fact it is just used to maintain a consistent
  prefs: []
  type: TYPE_NORMAL
- en: output format throughout the solveset.
  prefs: []
  type: TYPE_NORMAL
- en: For the given set of equations, the respective input types
  prefs: []
  type: TYPE_NORMAL
- en: 'are given below:'
  prefs: []
  type: TYPE_NORMAL
- en: \[xy - 1 = 0\]\[4x^2 + y^2 - 5 = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: The input is not valid. The symbols are not given.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**AttributeError**'
  prefs: []
  type: TYPE_NORMAL
- en: The input symbols are not \(Symbol\) type.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Positive dimensional system and complements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 2\. If some of the equations are non-polynomial then \(nonlinsolve\) will call
    the `substitution` function and return real and complex solutions, if present.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '3\. If system is non-linear polynomial and zero-dimensional then it returns
    both solution (real and complex solutions, if present) using [`solve_poly_system()`](solvers.html#sympy.solvers.polysys.solve_poly_system
    "sympy.solvers.polysys.solve_poly_system"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 4\. `nonlinsolve` can solve some linear (zero or positive dimensional) system
    (because it uses the [`sympy.polys.polytools.groebner()`](../polys/reference.html#sympy.polys.polytools.groebner
    "sympy.polys.polytools.groebner") function to get the groebner basis and then
    uses the `substitution` function basis as the new \(system\)). But it is not recommended
    to solve linear system using `nonlinsolve`, because [`linsolve()`](#sympy.solvers.solveset.linsolve
    "sympy.solvers.solveset.linsolve") is better for general linear systems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '5\. System having polynomial equations and only real solution is solved using
    [`solve_poly_system()`](solvers.html#sympy.solvers.polysys.solve_poly_system "sympy.solvers.polysys.solve_poly_system"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 6\. It is better to use symbols instead of trigonometric functions or [`Function`](../core.html#sympy.core.function.Function
    "sympy.core.function.Function"). For example, replace \(\sin(x)\) with a symbol,
    replace \(f(x)\) with a symbol and so on. Get a solution from `nonlinsolve` and
    then use [`solveset()`](#sympy.solvers.solveset.solveset "sympy.solvers.solveset.solveset")
    to get the value of \(x\).
  prefs: []
  type: TYPE_NORMAL
- en: 'How Nonlinsolve Is Better Than Old Solver `_solve_system` :'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. A positive dimensional system solver: nonlinsolve can return solution for
    positive dimensional system. It finds the Groebner Basis of the positive dimensional
    system(calling it as basis) then we can start solving equation(having least number
    of variable first in the basis) using solveset and substituting that solved solutions
    into other equation(of basis) to get solution in terms of minimum variables. Here
    the important thing is how we are substituting the known values and in which equations.'
  prefs: []
  type: TYPE_NORMAL
- en: '2\. Real and complex solutions: nonlinsolve returns both real and complex solution.
    If all the equations in the system are polynomial then using [`solve_poly_system()`](solvers.html#sympy.solvers.polysys.solve_poly_system
    "sympy.solvers.polysys.solve_poly_system") both real and complex solution is returned.
    If all the equations in the system are not polynomial equation then goes to `substitution`
    method with this polynomial and non polynomial equation(s), to solve for unsolved
    variables. Here to solve for particular variable solveset_real and solveset_complex
    is used. For both real and complex solution `_solve_using_known_values` is used
    inside `substitution` (`substitution` will be called when any non-polynomial equation
    is present). If a solution is valid its general solution is added to the final
    result.'
  prefs: []
  type: TYPE_NORMAL
- en: '3\. [`Complement`](../sets.html#sympy.sets.sets.Complement "sympy.sets.sets.Complement")
    and [`Intersection`](../sets.html#sympy.sets.sets.Intersection "sympy.sets.sets.Intersection")
    will be added: nonlinsolve maintains dict for complements and intersections. If
    solveset find complements or/and intersections with any interval or set during
    the execution of `substitution` function, then complement or/and intersection
    for that variable is added before returning final solution.'
  prefs: []
  type: TYPE_NORMAL
- en: transolve
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Function to solve transcendental equations. It is a helper to `solveset` and
    should be used internally. `_transolve` currently supports the following class
    of equations:'
  prefs: []
  type: TYPE_NORMAL
- en: Exponential equations
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Logarithmic equations
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f** : Any transcendental equation that needs to be solved.'
  prefs: []
  type: TYPE_NORMAL
- en: This needs to be an expression, which is assumed to be equal to `0`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbol** : The variable for which the equation is solved.'
  prefs: []
  type: TYPE_NORMAL
- en: This needs to be of class `Symbol`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**domain** : A set over which the equation is solved.'
  prefs: []
  type: TYPE_NORMAL
- en: This needs to be of class `Set`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Set
  prefs: []
  type: TYPE_NORMAL
- en: A set of values for `symbol` for which `f` is equal to zero. An `EmptySet` is
    returned if `f` does not have solutions in respective domain. A `ConditionSet`
    is returned as unsolved object if algorithms to evaluate complete solution are
    not yet implemented.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: How To Use `_transolve`
  prefs: []
  type: TYPE_NORMAL
- en: '`_transolve` should not be used as an independent function, because it assumes
    that the equation (`f`) and the `symbol` comes from `solveset` and might have
    undergone a few modification(s). To use `_transolve` as an independent function
    the equation (`f`) and the `symbol` should be passed as they would have been by
    `solveset`.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: How `_transolve` Works
  prefs: []
  type: TYPE_NORMAL
- en: '`_transolve` uses two types of helper functions to solve equations of a particular
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Identifying helpers: To determine whether a given equation belongs to a certain
    class of equation or not. Returns either `True` or `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Solving helpers: Once an equation is identified, a corresponding helper either
    solves the equation or returns a form of the equation that `solveset` might better
    be able to handle.'
  prefs: []
  type: TYPE_NORMAL
- en: Philosophy behind the module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of `_transolve` is to take equations which are not already polynomial
    in their generator(s) and to either recast them as such through a valid transformation
    or to solve them outright. A pair of helper functions for each class of supported
    transcendental functions are employed for this purpose. One identifies the transcendental
    form of an equation and the other either solves it or recasts it into a tractable
    form that can be solved by `solveset`. For example, an equation in the form \(ab^{f(x)}
    - cd^{g(x)} = 0\) can be transformed to \(\log(a) + f(x)\log(b) - \log(c) - g(x)\log(d)
    = 0\) (under certain assumptions) and this can be solved with `solveset` if \(f(x)\)
    and \(g(x)\) are in polynomial form.
  prefs: []
  type: TYPE_NORMAL
- en: How `_transolve` Is Better Than `_tsolve`
  prefs: []
  type: TYPE_NORMAL
- en: Better output
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_transolve` provides expressions in a more simplified form.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider a simple exponential equation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Extensible
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The API of `_transolve` is designed such that it is easily extensible, i.e.
    the code that solves a given class of equations is encapsulated in a helper and
    not mixed in with the code of `_transolve` itself.
  prefs: []
  type: TYPE_NORMAL
- en: Modular
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`_transolve` is designed to be modular i.e, for every class of equation a separate
    helper for identification and solving is implemented. This makes it easy to change
    or modify any of the method implemented directly in the helpers without interfering
    with the actual structure of the API.'
  prefs: []
  type: TYPE_NORMAL
- en: Faster Computation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Solving equation via `_transolve` is much faster as compared to `_tsolve`. In
    `solve`, attempts are made computing every possibility to get the solutions. This
    series of attempts makes solving a bit slow. In `_transolve`, computation begins
    only after a particular type of equation is identified.
  prefs: []
  type: TYPE_NORMAL
- en: How To Add New Class Of Equations
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a new class of equation solver is a three-step procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the type of the equations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Determine the type of the class of equations to which they belong: it could
    be of `Add`, `Pow`, etc. types. Separate internal functions are used for each
    type. Write identification and solving helpers and use them from within the routine
    for the given type of equation (after adding it, if necessary). Something like:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define the identification helper.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the solving helper.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Apart from this, a few other things needs to be taken care while adding an
    equation solver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Naming conventions: Name of the identification helper should be as `_is_class`
    where class will be the name or abbreviation of the class of equation. The solving
    helper will be named as `_solve_class`. For example: for exponential equations
    it becomes `_is_exponential` and `_solve_expo`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The identifying helpers should take two input parameters, the equation to be
    checked and the variable for which a solution is being sought, while solving helpers
    would require an additional domain parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be sure to consider corner cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add tests for each helper.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a docstring to your helper that describes the method implemented. The documentation
    of the helpers should identify:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the purpose of the helper,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the method used to identify and solve the equation,
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: a proof of correctness
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: the return values of the helpers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if one or more terms contain `symbol` only in exponents, else
    `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: The equation to be checked
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbol** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The variable in which the equation is checked
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Philosophy behind the helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function extracts each term of the equation and checks if it is of exponential
    form w.r.t `symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Helper function for solving (supported) exponential equations.
  prefs: []
  type: TYPE_NORMAL
- en: Exponential equations are the sum of (currently) at most two terms with one
    or both of them having a power with a symbol-dependent exponent.
  prefs: []
  type: TYPE_NORMAL
- en: For example
  prefs: []
  type: TYPE_NORMAL
- en: \[5^{2x + 3} - 5^{3x - 1}\]\[4^{5 - 9x} - e^{2 - x}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**lhs, rhs** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: The exponential equation to be solved, \(lhs = rhs\)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbol** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The variable in which the equation is solved
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**domain** : Set'
  prefs: []
  type: TYPE_NORMAL
- en: A set over which the equation is solved.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: A set of solutions satisfying the given equation.
  prefs: []
  type: TYPE_NORMAL
- en: A `ConditionSet` if the equation is unsolvable or
  prefs: []
  type: TYPE_NORMAL
- en: if the assumptions are not properly defined, in that case
  prefs: []
  type: TYPE_NORMAL
- en: a different style of `ConditionSet` is returned having the
  prefs: []
  type: TYPE_NORMAL
- en: solution(s) of the equation with the desired assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Proof of correctness of the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The logarithm function is the inverse of the exponential function. The defining
    relation between exponentiation and logarithm is:'
  prefs: []
  type: TYPE_NORMAL
- en: \[{\log_b x} = y \enspace if \enspace b^y = x\]
  prefs: []
  type: TYPE_NORMAL
- en: Therefore if we are given an equation with exponent terms, we can convert every
    term to its corresponding logarithmic form. This is achieved by taking logarithms
    and expanding the equation using logarithmic identities so that it can easily
    be handled by `solveset`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: \[3^{2x} = 2^{x + 3}\]
  prefs: []
  type: TYPE_NORMAL
- en: Taking log both sides will reduce the equation to
  prefs: []
  type: TYPE_NORMAL
- en: \[(2x)\log(3) = (x + 3)\log(2)\]
  prefs: []
  type: TYPE_NORMAL
- en: This form can be easily handed by `solveset`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Helper to solve logarithmic equations which are reducible to a single instance
    of \(\log\).
  prefs: []
  type: TYPE_NORMAL
- en: Logarithmic equations are (currently) the equations that contains \(\log\) terms
    which can be reduced to a single \(\log\) term or a constant using various logarithmic
    identities.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\log(x) + \log(x - 4)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'can be reduced to:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\log(x(x - 4))\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**lhs, rhs** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: The logarithmic equation to be solved, \(lhs = rhs\)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbol** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The variable in which the equation is solved
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**domain** : Set'
  prefs: []
  type: TYPE_NORMAL
- en: A set over which the equation is solved.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: A set of solutions satisfying the given equation.
  prefs: []
  type: TYPE_NORMAL
- en: A `ConditionSet` if the equation is unsolvable.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Proof of correctness
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A logarithm is another way to write exponent and is defined by
  prefs: []
  type: TYPE_NORMAL
- en: \[{\log_b x} = y \enspace if \enspace b^y = x\]
  prefs: []
  type: TYPE_NORMAL
- en: When one side of the equation contains a single logarithm, the equation can
    be solved by rewriting the equation as an equivalent exponential equation as defined
    above. But if one side contains more than one logarithm, we need to use the properties
    of logarithm to condense it into a single logarithm.
  prefs: []
  type: TYPE_NORMAL
- en: Take for example
  prefs: []
  type: TYPE_NORMAL
- en: \[\log(2x) - 15 = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: contains single logarithm, therefore we can directly rewrite it to exponential
    form as
  prefs: []
  type: TYPE_NORMAL
- en: \[x = \frac{e^{15}}{2}\]
  prefs: []
  type: TYPE_NORMAL
- en: But if the equation has more than one logarithm as
  prefs: []
  type: TYPE_NORMAL
- en: \[\log(x - 3) + \log(x + 3) = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: we use logarithmic identities to convert it into a reduced form
  prefs: []
  type: TYPE_NORMAL
- en: Using,
  prefs: []
  type: TYPE_NORMAL
- en: \[\log(a) + \log(b) = \log(ab)\]
  prefs: []
  type: TYPE_NORMAL
- en: the equation becomes,
  prefs: []
  type: TYPE_NORMAL
- en: \[\log((x - 3)(x + 3))\]
  prefs: []
  type: TYPE_NORMAL
- en: This equation contains one logarithm and can be solved by rewriting to exponents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if the equation is in the form \(a\log(f(x)) + b\log(g(x)) + ...
    + c\) else `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: The equation to be checked
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbol** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: The variable in which the equation is checked
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`True` if the equation is logarithmic otherwise `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Philosophy behind the helper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The function extracts each term and checks whether it is logarithmic w.r.t `symbol`.
  prefs: []
  type: TYPE_NORMAL
- en: Diophantine Equations (DEs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Diophantine](diophantine.html#diophantine-docs)
  prefs: []
  type: TYPE_NORMAL
- en: Inequalities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Inequality Solvers](inequalities.html#inequality-docs)
  prefs: []
  type: TYPE_NORMAL
- en: Ordinary Differential equations (ODEs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [ODE](ode.html#ode-docs).
  prefs: []
  type: TYPE_NORMAL
- en: Partial Differential Equations (PDEs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [PDE](pde.html#pde-docs).
  prefs: []
  type: TYPE_NORMAL
