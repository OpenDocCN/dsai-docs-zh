- en: NumPy 1.13.0 Release Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/release/1.13.0-notes.html](https://numpy.org/doc/1.26/release/1.13.0-notes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This release supports Python 2.7 and 3.4 - 3.6.
  prefs: []
  type: TYPE_NORMAL
- en: Highlights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operations like `a + b + c` will reuse temporaries on some platforms, resulting
    in less memory use and faster execution.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Inplace operations check if inputs overlap outputs and create temporaries to
    avoid problems.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: New `__array_ufunc__` attribute provides improved ability for classes to override
    default ufunc behavior.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: New `np.block` function for creating blocked arrays.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: New functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New `np.positive` ufunc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `np.divmod` ufunc provides more efficient divmod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `np.isnat` ufunc tests for NaT special values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `np.heaviside` ufunc computes the Heaviside function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `np.isin` function, improves on `in1d`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `np.block` function for creating blocked arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `PyArray_MapIterArrayCopyIfOverlap` added to NumPy C-API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See below for details.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling `np.fix`, `np.isposinf`, and `np.isneginf` with `f(x, y=out)` is deprecated
    - the argument should be passed as `f(x, out=out)`, which matches other ufunc-like
    interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of the C-API `NPY_CHAR` type number deprecated since version 1.7 will now
    raise deprecation warnings at runtime. Extensions built with older f2py versions
    need to be recompiled to remove the warning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.ma.argsort`, `np.ma.minimum.reduce`, and `np.ma.maximum.reduce` should
    be called with an explicit *axis* argument when applied to arrays with more than
    2 dimensions, as the default value of this argument (`None`) is inconsistent with
    the rest of numpy (`-1`, `0`, and `0`, respectively).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.ma.MaskedArray.mini` is deprecated, as it almost duplicates the functionality
    of `np.MaskedArray.min`. Exactly equivalent behaviour can be obtained with `np.ma.minimum.reduce`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-argument form of `np.ma.minimum` and `np.ma.maximum` is deprecated.
    `np.maximum`. `np.ma.minimum(x)` should now be spelt `np.ma.minimum.reduce(x)`,
    which is consistent with how this would be done with `np.minimum`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `ndarray.conjugate` on non-numeric dtypes is deprecated (it should match
    the behavior of `np.conjugate`, which throws an error).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `expand_dims` when the `axis` keyword does not satisfy `-a.ndim - 1
    <= axis <= a.ndim`, where `a` is the array being reshaped, is deprecated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assignment between structured arrays with different field names will change
    in NumPy 1.14\. Previously, fields in the dst would be set to the value of the
    identically-named field in the src. In numpy 1.14 fields will instead be assigned
    ‘by position’: The n-th field of the dst will be set to the n-th field of the
    src array. Note that the `FutureWarning` raised in NumPy 1.12 incorrectly reported
    this change as scheduled for NumPy 1.13 rather than NumPy 1.14.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build System Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`numpy.distutils` now automatically determines C-file dependencies with GCC
    compatible compilers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Error type changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`numpy.hstack()` now throws `ValueError` instead of `IndexError` when input
    is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions taking an axis argument, when that argument is out of range, now throw
    `np.AxisError` instead of a mixture of `IndexError` and `ValueError`. For backwards
    compatibility, `AxisError` subclasses both of these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple object dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support has been removed for certain obscure dtypes that were unintentionally
    allowed, of the form `(old_dtype, new_dtype)`, where either of the dtypes is or
    contains the `object` dtype. As an exception, dtypes of the form `(object, [('name',
    object)])` are still supported due to evidence of existing use.
  prefs: []
  type: TYPE_NORMAL
- en: DeprecationWarning to error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See Changes section for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`partition`, TypeError when non-integer partition index is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NpyIter_AdvancedNew`, ValueError when `oa_ndim == 0` and `op_axes` is NULL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`negative(bool_)`, TypeError when negative applied to booleans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtract(bool_, bool_)`, TypeError when subtracting boolean from boolean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal`, object identity doesn’t override failed comparison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal`, object identity doesn’t override non-boolean comparison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated boolean indexing behavior dropped. See Changes below for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated `np.alterdot()` and `np.restoredot()` removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FutureWarning to changed behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See Changes section for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.average` preserves subclasses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array == None` and `array != None` do element-wise comparison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal`, object identity doesn’t override comparison result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dtypes are now always true
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `bool(dtype)` would fall back to the default python implementation,
    which checked if `len(dtype) > 0`. Since `dtype` objects implement `__len__` as
    the number of record fields, `bool` of scalar dtypes would evaluate to `False`,
    which was unintuitive. Now `bool(dtype) == True` for all dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '`__getslice__` and `__setslice__` are no longer needed in `ndarray` subclasses'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When subclassing np.ndarray in Python 2.7, it is no longer _necessary_ to implement
    `__*slice__` on the derived class, as `__*item__` will intercept these calls correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Any code that did implement these will work exactly as before. Code that invokes``ndarray.__getslice__``
    (e.g. through `super(...).__getslice__`) will now issue a DeprecationWarning -
    `.__getitem__(slice(start, end))` should be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing MaskedArrays/Constants with `...` (ellipsis) now returns MaskedArray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This behavior mirrors that of np.ndarray, and accounts for nested arrays in
    MaskedArrays of object dtype, and ellipsis combined with other forms of indexing.
  prefs: []
  type: TYPE_NORMAL
- en: C API changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GUfuncs on empty arrays and NpyIter axis removal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is now allowed to remove a zero-sized axis from NpyIter. Which may mean that
    code removing axes from NpyIter has to add an additional check when accessing
    the removed dimensions later on.
  prefs: []
  type: TYPE_NORMAL
- en: The largest followup change is that gufuncs are now allowed to have zero-sized
    inner dimensions. This means that a gufunc now has to anticipate an empty inner
    dimension, while this was never possible and an error raised instead.
  prefs: []
  type: TYPE_NORMAL
- en: For most gufuncs no change should be necessary. However, it is now possible
    for gufuncs with a signature such as `(..., N, M) -> (..., M)` to return a valid
    result if `N=0` without further wrapping code.
  prefs: []
  type: TYPE_NORMAL
- en: '`PyArray_MapIterArrayCopyIfOverlap` added to NumPy C-API'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to `PyArray_MapIterArray` but with an additional `copy_if_overlap` argument.
    If `copy_if_overlap != 0`, checks if input has memory overlap with any of the
    other arrays and make copies as appropriate to avoid problems if the input is
    modified during the iteration. See the documentation for more complete documentation.
  prefs: []
  type: TYPE_NORMAL
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`__array_ufunc__` added'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the renamed and redesigned `__numpy_ufunc__`. Any class, ndarray subclass
    or not, can define this method or set it to `None` in order to override the behavior
    of NumPy’s ufuncs. This works quite similarly to Python’s `__mul__` and other
    binary operation routines. See the documentation for a more detailed description
    of the implementation and behavior of this new option. The API is provisional,
    we do not yet guarantee backward compatibility as modifications may be made pending
    feedback. See [NEP 13](http://www.numpy.org/neps/nep-0013-ufunc-overrides.html)
    and [documentation](https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: New `positive` ufunc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This ufunc corresponds to unary *+*, but unlike *+* on an ndarray it will raise
    an error if array values do not support numeric operations.
  prefs: []
  type: TYPE_NORMAL
- en: New `divmod` ufunc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This ufunc corresponds to the Python builtin *divmod*, and is used to implement
    *divmod* when called on numpy arrays. `np.divmod(x, y)` calculates a result equivalent
    to `(np.floor_divide(x, y), np.remainder(x, y))` but is approximately twice as
    fast as calling the functions separately.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.isnat` ufunc tests for NaT special datetime and timedelta values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new ufunc `np.isnat` finds the positions of special NaT values within datetime
    and timedelta arrays. This is analogous to `np.isnan`.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.heaviside` ufunc computes the Heaviside function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new function `np.heaviside(x, h0)` (a ufunc) computes the Heaviside function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`np.block` function for creating blocked arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a new `block` function to the current stacking functions `vstack`, `hstack`,
    and `stack`. This allows concatenation across multiple axes simultaneously, with
    a similar syntax to array creation, but where elements can themselves be arrays.
    For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: While primarily useful for block matrices, this works for arbitrary dimensions
    of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: It is similar to Matlab’s square bracket notation for creating block matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '`isin` function, improving on `in1d`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new function `isin` tests whether each element of an N-dimensional array
    is present anywhere within a second array. It is an enhancement of `in1d` that
    preserves the shape of the first array.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary elision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On platforms providing the `backtrace` function NumPy will try to avoid creating
    temporaries in expression involving basic numeric types. For example `d = a +
    b + c` is transformed to `d = a + b; d += c` which can improve performance for
    large arrays as less memory bandwidth is required to perform the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`axes` argument for `unique`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an N-dimensional array, the user can now choose the axis along which to look
    for duplicate N-1-dimensional elements using `numpy.unique`. The original behaviour
    is recovered if `axis=None` (default).
  prefs: []
  type: TYPE_NORMAL
- en: '`np.gradient` now supports unevenly spaced data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Users can now specify a not-constant spacing for data. In particular `np.gradient`
    can now take:'
  prefs: []
  type: TYPE_NORMAL
- en: A single scalar to specify a sample distance for all dimensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: N scalars to specify a constant sample distance for each dimension. i.e. `dx`,
    `dy`, `dz`, …
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: N arrays to specify the coordinates of the values along each dimension of F.
    The length of the array must match the size of the corresponding dimension
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any combination of N scalars/arrays with the meaning of 2\. and 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This means that, e.g., it is now possible to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Support for returning arrays of arbitrary dimensions in `apply_along_axis`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, only scalars or 1D arrays could be returned by the function passed
    to `apply_along_axis`. Now, it can return an array of any dimensionality (including
    0D), and the shape of this array replaces the axis of the array being iterated
    over.
  prefs: []
  type: TYPE_NORMAL
- en: '`.ndim` property added to `dtype` to complement `.shape`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For consistency with `ndarray` and `broadcast`, `d.ndim` is a shorthand for
    `len(d.shape)`.
  prefs: []
  type: TYPE_NORMAL
- en: Support for tracemalloc in Python 3.6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy now supports memory tracing with [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    module of Python 3.6 or newer. Memory allocations from NumPy are placed into the
    domain defined by `numpy.lib.tracemalloc_domain`. Note that NumPy allocation will
    not show up in [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    of earlier Python versions.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy may be built with relaxed stride checking debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting NPY_RELAXED_STRIDES_DEBUG=1 in the environment when relaxed stride checking
    is enabled will cause NumPy to be compiled with the affected strides set to the
    maximum value of npy_intp in order to help detect invalid usage of the strides
    in downstream projects. When enabled, invalid usage often results in an error
    being raised, but the exact type of error depends on the details of the code.
    TypeError and OverflowError have been observed in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: It was previously the case that this option was disabled for releases and enabled
    in master and changing between the two required editing the code. It is now disabled
    by default but can be enabled for test builds.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ufunc behavior for overlapping inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Operations where ufunc input and output operands have memory overlap produced
    undefined results in previous NumPy versions, due to data dependency issues. In
    NumPy 1.13.0, results from such operations are now defined to be the same as for
    equivalent operations where there is no memory overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Operations affected now make temporary copies, as needed to eliminate data dependency.
    As detecting these cases is computationally expensive, a heuristic is used, which
    may in rare cases result to needless temporary copies. For operations where the
    data dependency is simple enough for the heuristic to analyze, temporary copies
    will not be made even if the arrays overlap, if it can be deduced copies are not
    necessary. As an example,``np.add(a, b, out=a)`` will not involve copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate a previously undefined operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In NumPy 1.13.0 the last line is guaranteed to be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar operation with simple non-problematic data dependence is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: It will continue to produce the same results as in previous NumPy versions,
    and will not involve unnecessary temporary copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change applies also to in-place binary operations, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This statement is now guaranteed to be equivalent to `x[...] = x + x.T`, whereas
    in previous NumPy versions the results were undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Partial support for 64-bit f2py extensions with MinGW
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extensions that incorporate Fortran libraries can now be built using the free
    [MinGW](https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/)
    toolset, also under Python 3.5\. This works best for extensions that only do calculations
    and uses the runtime modestly (reading and writing from files, for instance).
    Note that this does not remove the need for Mingwpy; if you make extensive use
    of the runtime, you will most likely run into [issues](https://mingwpy.github.io/issues.html).
    Instead, it should be regarded as a band-aid until Mingwpy is fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions can also be compiled using the MinGW toolset using the runtime library
    from the (moveable) WinPython 3.4 distribution, which can be useful for programs
    with a PySide1/Qt4 front-end.
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvements for `packbits` and `unpackbits`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions `numpy.packbits` with boolean input and `numpy.unpackbits` have
    been optimized to be a significantly faster for contiguous data.
  prefs: []
  type: TYPE_NORMAL
- en: Fix for PPC long double floating point information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous versions of NumPy, the `finfo` function returned invalid information
    about the [double double](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic)
    format of the `longdouble` float type on Power PC (PPC). The invalid values resulted
    from the failure of the NumPy algorithm to deal with the variable number of digits
    in the significand that are a feature of *PPC long doubles*. This release by-passes
    the failing algorithm by using heuristics to detect the presence of the PPC double
    double format. A side-effect of using these heuristics is that the `finfo` function
    is faster than previous releases.
  prefs: []
  type: TYPE_NORMAL
- en: Better default repr for `ndarray` subclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subclasses of ndarray with no `repr` specialization now correctly indent their
    data and type lines.
  prefs: []
  type: TYPE_NORMAL
- en: More reliable comparisons of masked arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparisons of masked arrays were buggy for masked scalars and failed for structured
    arrays with dimension higher than one. Both problems are now solved. In the process,
    it was ensured that in getting the result for a structured array, masked fields
    are properly ignored, i.e., the result is equal if all fields that are non-masked
    in both are equal, thus making the behaviour identical to what one gets by comparing
    an unstructured masked array and then doing `.all()` over some axis.
  prefs: []
  type: TYPE_NORMAL
- en: np.matrix with booleans elements can now be created using the string syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.matrix` failed whenever one attempts to use it with booleans, e.g., `np.matrix(''True'')`.
    Now, this works as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: More `linalg` operations now accept empty vectors and matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the following functions in `np.linalg` now work when given input arrays
    with a 0 in the last two dimensions: `det`, `slogdet`, `pinv`, `eigvals`, `eigvalsh`,
    `eig`, `eigh`.'
  prefs: []
  type: TYPE_NORMAL
- en: Bundled version of LAPACK is now 3.2.2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy comes bundled with a minimal implementation of lapack for systems without
    a lapack library installed, under the name of `lapack_lite`. This has been upgraded
    from LAPACK 3.0.0 (June 30, 1999) to LAPACK 3.2.2 (June 30, 2010). See the [LAPACK
    changelogs](http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases)
    for details on the all the changes this entails.
  prefs: []
  type: TYPE_NORMAL
- en: While no new features are exposed through `numpy`, this fixes some bugs regarding
    “workspace” sizes, and in some places may use faster algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '`reduce` of `np.hypot.reduce` and `np.logical_xor` allowed in more cases'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This now works on empty arrays, returning 0, and can reduce over multiple axes.
    Previously, a `ValueError` was thrown in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Better `repr` of object arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Object arrays that contain themselves no longer cause a recursion error.
  prefs: []
  type: TYPE_NORMAL
- en: Object arrays that contain `list` objects are now printed in a way that makes
    clear the difference between a 2d object array, and a 1d object array of lists.
  prefs: []
  type: TYPE_NORMAL
- en: Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`argsort` on masked arrays takes the same default arguments as `sort`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, `argsort` now places the masked values at the end of the sorted
    array, in the same way that `sort` already did. Additionally, the `end_with` argument
    is added to `argsort`, for consistency with `sort`. Note that this argument is
    not added at the end, so breaks any code that passed `fill_value` as a positional
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`average` now preserves subclasses'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For ndarray subclasses, `numpy.average` will now return an instance of the subclass,
    matching the behavior of most other NumPy functions such as `mean`. As a consequence,
    also calls that returned a scalar may now return a subclass array scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '`array == None` and `array != None` do element-wise comparison'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously these operations returned scalars `False` and `True` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal` for object arrays ignores object identity'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, these functions always treated identical objects as equal. This
    had the effect of overriding comparison failures, comparison of objects that did
    not return booleans, such as np.arrays, and comparison of objects where the results
    differed from object identity, such as NaNs.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean indexing changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boolean array-likes (such as lists of python bools) are always treated as boolean
    indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean scalars (including python `True`) are legal boolean indexes and never
    treated as integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexes must match the dimension of the axis that they index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexes used on the lhs of an assignment must match the dimensions of
    the rhs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexing into scalar arrays return a new 1-d array. This means that
    `array(1)[array(True)]` gives `array([1])` and not the original array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.random.multivariate_normal` behavior with bad covariance matrix'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is now possible to adjust the behavior the function will have when dealing
    with the covariance matrix by using two new keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tol` can be used to specify a tolerance to use when checking that the covariance
    matrix is positive semidefinite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check_valid` can be used to configure what the function will do in the presence
    of a matrix that is not positive semidefinite. Valid options are `ignore`, `warn`
    and `raise`. The default value, `warn` keeps the the behavior used on previous
    releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert_array_less` compares `np.inf` and `-np.inf` now'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, `np.testing.assert_array_less` ignored all infinite values. This
    is not the expected behavior both according to documentation and intuitively.
    Now, -inf < x < inf is considered `True` for any real number x and all other cases
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: '`assert_array_` and masked arrays `assert_equal` hide less warnings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some warnings that were previously hidden by the `assert_array_` functions are
    not hidden anymore. In most cases the warnings should be correct and, should they
    occur, will require changes to the tests using these functions. For the masked
    array `assert_equal` version, warnings may occur when comparing NaT. The function
    presently does not handle NaT or NaN specifically and it may be best to avoid
    it at this time should a warning show up due to this change.
  prefs: []
  type: TYPE_NORMAL
- en: '`offset` attribute value in `memmap` objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `offset` attribute in a `memmap` object is now set to the offset into the
    file. This is a behaviour change only for offsets greater than `mmap.ALLOCATIONGRANULARITY`.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.real` and `np.imag` return scalars for scalar inputs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, `np.real` and `np.imag` used to return array objects when provided
    a scalar input, which was inconsistent with other functions like `np.angle` and
    `np.conj`.
  prefs: []
  type: TYPE_NORMAL
- en: The polynomial convenience classes cannot be passed to ufuncs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ABCPolyBase class, from which the convenience classes are derived, sets
    `__array_ufun__ = None` in order of opt out of ufuncs. If a polynomial convenience
    class instance is passed as an argument to a ufunc, a `TypeError` will now be
    raised.
  prefs: []
  type: TYPE_NORMAL
- en: Output arguments to ufuncs can be tuples also for ufunc methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For calls to ufuncs, it was already possible, and recommended, to use an `out`
    argument with a tuple for ufuncs with multiple outputs. This has now been extended
    to output arguments in the `reduce`, `accumulate`, and `reduceat` methods. This
    is mostly for compatibility with `__array_ufunc`; there are no ufuncs yet that
    have more than one output.
  prefs: []
  type: TYPE_NORMAL
- en: Highlights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operations like `a + b + c` will reuse temporaries on some platforms, resulting
    in less memory use and faster execution.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Inplace operations check if inputs overlap outputs and create temporaries to
    avoid problems.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: New `__array_ufunc__` attribute provides improved ability for classes to override
    default ufunc behavior.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: New `np.block` function for creating blocked arrays.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: New functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New `np.positive` ufunc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `np.divmod` ufunc provides more efficient divmod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `np.isnat` ufunc tests for NaT special values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `np.heaviside` ufunc computes the Heaviside function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `np.isin` function, improves on `in1d`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `np.block` function for creating blocked arrays.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New `PyArray_MapIterArrayCopyIfOverlap` added to NumPy C-API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See below for details.
  prefs: []
  type: TYPE_NORMAL
- en: Deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calling `np.fix`, `np.isposinf`, and `np.isneginf` with `f(x, y=out)` is deprecated
    - the argument should be passed as `f(x, out=out)`, which matches other ufunc-like
    interfaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use of the C-API `NPY_CHAR` type number deprecated since version 1.7 will now
    raise deprecation warnings at runtime. Extensions built with older f2py versions
    need to be recompiled to remove the warning.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.ma.argsort`, `np.ma.minimum.reduce`, and `np.ma.maximum.reduce` should
    be called with an explicit *axis* argument when applied to arrays with more than
    2 dimensions, as the default value of this argument (`None`) is inconsistent with
    the rest of numpy (`-1`, `0`, and `0`, respectively).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.ma.MaskedArray.mini` is deprecated, as it almost duplicates the functionality
    of `np.MaskedArray.min`. Exactly equivalent behaviour can be obtained with `np.ma.minimum.reduce`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The single-argument form of `np.ma.minimum` and `np.ma.maximum` is deprecated.
    `np.maximum`. `np.ma.minimum(x)` should now be spelt `np.ma.minimum.reduce(x)`,
    which is consistent with how this would be done with `np.minimum`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `ndarray.conjugate` on non-numeric dtypes is deprecated (it should match
    the behavior of `np.conjugate`, which throws an error).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling `expand_dims` when the `axis` keyword does not satisfy `-a.ndim - 1
    <= axis <= a.ndim`, where `a` is the array being reshaped, is deprecated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assignment between structured arrays with different field names will change
    in NumPy 1.14\. Previously, fields in the dst would be set to the value of the
    identically-named field in the src. In numpy 1.14 fields will instead be assigned
    ‘by position’: The n-th field of the dst will be set to the n-th field of the
    src array. Note that the `FutureWarning` raised in NumPy 1.12 incorrectly reported
    this change as scheduled for NumPy 1.13 rather than NumPy 1.14.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build System Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`numpy.distutils` now automatically determines C-file dependencies with GCC
    compatible compilers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Error type changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`numpy.hstack()` now throws `ValueError` instead of `IndexError` when input
    is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions taking an axis argument, when that argument is out of range, now throw
    `np.AxisError` instead of a mixture of `IndexError` and `ValueError`. For backwards
    compatibility, `AxisError` subclasses both of these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple object dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support has been removed for certain obscure dtypes that were unintentionally
    allowed, of the form `(old_dtype, new_dtype)`, where either of the dtypes is or
    contains the `object` dtype. As an exception, dtypes of the form `(object, [('name',
    object)])` are still supported due to evidence of existing use.
  prefs: []
  type: TYPE_NORMAL
- en: DeprecationWarning to error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See Changes section for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`partition`, TypeError when non-integer partition index is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NpyIter_AdvancedNew`, ValueError when `oa_ndim == 0` and `op_axes` is NULL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`negative(bool_)`, TypeError when negative applied to booleans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtract(bool_, bool_)`, TypeError when subtracting boolean from boolean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal`, object identity doesn’t override failed comparison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal`, object identity doesn’t override non-boolean comparison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated boolean indexing behavior dropped. See Changes below for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated `np.alterdot()` and `np.restoredot()` removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FutureWarning to changed behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See Changes section for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.average` preserves subclasses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array == None` and `array != None` do element-wise comparison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal`, object identity doesn’t override comparison result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dtypes are now always true
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `bool(dtype)` would fall back to the default python implementation,
    which checked if `len(dtype) > 0`. Since `dtype` objects implement `__len__` as
    the number of record fields, `bool` of scalar dtypes would evaluate to `False`,
    which was unintuitive. Now `bool(dtype) == True` for all dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '`__getslice__` and `__setslice__` are no longer needed in `ndarray` subclasses'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When subclassing np.ndarray in Python 2.7, it is no longer _necessary_ to implement
    `__*slice__` on the derived class, as `__*item__` will intercept these calls correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Any code that did implement these will work exactly as before. Code that invokes``ndarray.__getslice__``
    (e.g. through `super(...).__getslice__`) will now issue a DeprecationWarning -
    `.__getitem__(slice(start, end))` should be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing MaskedArrays/Constants with `...` (ellipsis) now returns MaskedArray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This behavior mirrors that of np.ndarray, and accounts for nested arrays in
    MaskedArrays of object dtype, and ellipsis combined with other forms of indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Error type changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`numpy.hstack()` now throws `ValueError` instead of `IndexError` when input
    is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functions taking an axis argument, when that argument is out of range, now throw
    `np.AxisError` instead of a mixture of `IndexError` and `ValueError`. For backwards
    compatibility, `AxisError` subclasses both of these.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tuple object dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support has been removed for certain obscure dtypes that were unintentionally
    allowed, of the form `(old_dtype, new_dtype)`, where either of the dtypes is or
    contains the `object` dtype. As an exception, dtypes of the form `(object, [('name',
    object)])` are still supported due to evidence of existing use.
  prefs: []
  type: TYPE_NORMAL
- en: DeprecationWarning to error
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See Changes section for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`partition`, TypeError when non-integer partition index is used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NpyIter_AdvancedNew`, ValueError when `oa_ndim == 0` and `op_axes` is NULL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`negative(bool_)`, TypeError when negative applied to booleans.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subtract(bool_, bool_)`, TypeError when subtracting boolean from boolean.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal`, object identity doesn’t override failed comparison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal`, object identity doesn’t override non-boolean comparison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated boolean indexing behavior dropped. See Changes below for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated `np.alterdot()` and `np.restoredot()` removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FutureWarning to changed behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See Changes section for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.average` preserves subclasses'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`array == None` and `array != None` do element-wise comparison.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal`, object identity doesn’t override comparison result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dtypes are now always true
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `bool(dtype)` would fall back to the default python implementation,
    which checked if `len(dtype) > 0`. Since `dtype` objects implement `__len__` as
    the number of record fields, `bool` of scalar dtypes would evaluate to `False`,
    which was unintuitive. Now `bool(dtype) == True` for all dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '`__getslice__` and `__setslice__` are no longer needed in `ndarray` subclasses'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When subclassing np.ndarray in Python 2.7, it is no longer _necessary_ to implement
    `__*slice__` on the derived class, as `__*item__` will intercept these calls correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Any code that did implement these will work exactly as before. Code that invokes``ndarray.__getslice__``
    (e.g. through `super(...).__getslice__`) will now issue a DeprecationWarning -
    `.__getitem__(slice(start, end))` should be used instead.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing MaskedArrays/Constants with `...` (ellipsis) now returns MaskedArray
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This behavior mirrors that of np.ndarray, and accounts for nested arrays in
    MaskedArrays of object dtype, and ellipsis combined with other forms of indexing.
  prefs: []
  type: TYPE_NORMAL
- en: C API changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GUfuncs on empty arrays and NpyIter axis removal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is now allowed to remove a zero-sized axis from NpyIter. Which may mean that
    code removing axes from NpyIter has to add an additional check when accessing
    the removed dimensions later on.
  prefs: []
  type: TYPE_NORMAL
- en: The largest followup change is that gufuncs are now allowed to have zero-sized
    inner dimensions. This means that a gufunc now has to anticipate an empty inner
    dimension, while this was never possible and an error raised instead.
  prefs: []
  type: TYPE_NORMAL
- en: For most gufuncs no change should be necessary. However, it is now possible
    for gufuncs with a signature such as `(..., N, M) -> (..., M)` to return a valid
    result if `N=0` without further wrapping code.
  prefs: []
  type: TYPE_NORMAL
- en: '`PyArray_MapIterArrayCopyIfOverlap` added to NumPy C-API'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to `PyArray_MapIterArray` but with an additional `copy_if_overlap` argument.
    If `copy_if_overlap != 0`, checks if input has memory overlap with any of the
    other arrays and make copies as appropriate to avoid problems if the input is
    modified during the iteration. See the documentation for more complete documentation.
  prefs: []
  type: TYPE_NORMAL
- en: GUfuncs on empty arrays and NpyIter axis removal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is now allowed to remove a zero-sized axis from NpyIter. Which may mean that
    code removing axes from NpyIter has to add an additional check when accessing
    the removed dimensions later on.
  prefs: []
  type: TYPE_NORMAL
- en: The largest followup change is that gufuncs are now allowed to have zero-sized
    inner dimensions. This means that a gufunc now has to anticipate an empty inner
    dimension, while this was never possible and an error raised instead.
  prefs: []
  type: TYPE_NORMAL
- en: For most gufuncs no change should be necessary. However, it is now possible
    for gufuncs with a signature such as `(..., N, M) -> (..., M)` to return a valid
    result if `N=0` without further wrapping code.
  prefs: []
  type: TYPE_NORMAL
- en: '`PyArray_MapIterArrayCopyIfOverlap` added to NumPy C-API'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Similar to `PyArray_MapIterArray` but with an additional `copy_if_overlap` argument.
    If `copy_if_overlap != 0`, checks if input has memory overlap with any of the
    other arrays and make copies as appropriate to avoid problems if the input is
    modified during the iteration. See the documentation for more complete documentation.
  prefs: []
  type: TYPE_NORMAL
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`__array_ufunc__` added'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the renamed and redesigned `__numpy_ufunc__`. Any class, ndarray subclass
    or not, can define this method or set it to `None` in order to override the behavior
    of NumPy’s ufuncs. This works quite similarly to Python’s `__mul__` and other
    binary operation routines. See the documentation for a more detailed description
    of the implementation and behavior of this new option. The API is provisional,
    we do not yet guarantee backward compatibility as modifications may be made pending
    feedback. See [NEP 13](http://www.numpy.org/neps/nep-0013-ufunc-overrides.html)
    and [documentation](https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: New `positive` ufunc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This ufunc corresponds to unary *+*, but unlike *+* on an ndarray it will raise
    an error if array values do not support numeric operations.
  prefs: []
  type: TYPE_NORMAL
- en: New `divmod` ufunc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This ufunc corresponds to the Python builtin *divmod*, and is used to implement
    *divmod* when called on numpy arrays. `np.divmod(x, y)` calculates a result equivalent
    to `(np.floor_divide(x, y), np.remainder(x, y))` but is approximately twice as
    fast as calling the functions separately.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.isnat` ufunc tests for NaT special datetime and timedelta values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new ufunc `np.isnat` finds the positions of special NaT values within datetime
    and timedelta arrays. This is analogous to `np.isnan`.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.heaviside` ufunc computes the Heaviside function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new function `np.heaviside(x, h0)` (a ufunc) computes the Heaviside function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`np.block` function for creating blocked arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a new `block` function to the current stacking functions `vstack`, `hstack`,
    and `stack`. This allows concatenation across multiple axes simultaneously, with
    a similar syntax to array creation, but where elements can themselves be arrays.
    For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: While primarily useful for block matrices, this works for arbitrary dimensions
    of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: It is similar to Matlab’s square bracket notation for creating block matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '`isin` function, improving on `in1d`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new function `isin` tests whether each element of an N-dimensional array
    is present anywhere within a second array. It is an enhancement of `in1d` that
    preserves the shape of the first array.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary elision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On platforms providing the `backtrace` function NumPy will try to avoid creating
    temporaries in expression involving basic numeric types. For example `d = a +
    b + c` is transformed to `d = a + b; d += c` which can improve performance for
    large arrays as less memory bandwidth is required to perform the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`axes` argument for `unique`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an N-dimensional array, the user can now choose the axis along which to look
    for duplicate N-1-dimensional elements using `numpy.unique`. The original behaviour
    is recovered if `axis=None` (default).
  prefs: []
  type: TYPE_NORMAL
- en: '`np.gradient` now supports unevenly spaced data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Users can now specify a not-constant spacing for data. In particular `np.gradient`
    can now take:'
  prefs: []
  type: TYPE_NORMAL
- en: A single scalar to specify a sample distance for all dimensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: N scalars to specify a constant sample distance for each dimension. i.e. `dx`,
    `dy`, `dz`, …
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: N arrays to specify the coordinates of the values along each dimension of F.
    The length of the array must match the size of the corresponding dimension
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any combination of N scalars/arrays with the meaning of 2\. and 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This means that, e.g., it is now possible to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Support for returning arrays of arbitrary dimensions in `apply_along_axis`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, only scalars or 1D arrays could be returned by the function passed
    to `apply_along_axis`. Now, it can return an array of any dimensionality (including
    0D), and the shape of this array replaces the axis of the array being iterated
    over.
  prefs: []
  type: TYPE_NORMAL
- en: '`.ndim` property added to `dtype` to complement `.shape`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For consistency with `ndarray` and `broadcast`, `d.ndim` is a shorthand for
    `len(d.shape)`.
  prefs: []
  type: TYPE_NORMAL
- en: Support for tracemalloc in Python 3.6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy now supports memory tracing with [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    module of Python 3.6 or newer. Memory allocations from NumPy are placed into the
    domain defined by `numpy.lib.tracemalloc_domain`. Note that NumPy allocation will
    not show up in [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    of earlier Python versions.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy may be built with relaxed stride checking debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting NPY_RELAXED_STRIDES_DEBUG=1 in the environment when relaxed stride checking
    is enabled will cause NumPy to be compiled with the affected strides set to the
    maximum value of npy_intp in order to help detect invalid usage of the strides
    in downstream projects. When enabled, invalid usage often results in an error
    being raised, but the exact type of error depends on the details of the code.
    TypeError and OverflowError have been observed in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: It was previously the case that this option was disabled for releases and enabled
    in master and changing between the two required editing the code. It is now disabled
    by default but can be enabled for test builds.
  prefs: []
  type: TYPE_NORMAL
- en: '`__array_ufunc__` added'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the renamed and redesigned `__numpy_ufunc__`. Any class, ndarray subclass
    or not, can define this method or set it to `None` in order to override the behavior
    of NumPy’s ufuncs. This works quite similarly to Python’s `__mul__` and other
    binary operation routines. See the documentation for a more detailed description
    of the implementation and behavior of this new option. The API is provisional,
    we do not yet guarantee backward compatibility as modifications may be made pending
    feedback. See [NEP 13](http://www.numpy.org/neps/nep-0013-ufunc-overrides.html)
    and [documentation](https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: New `positive` ufunc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This ufunc corresponds to unary *+*, but unlike *+* on an ndarray it will raise
    an error if array values do not support numeric operations.
  prefs: []
  type: TYPE_NORMAL
- en: New `divmod` ufunc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This ufunc corresponds to the Python builtin *divmod*, and is used to implement
    *divmod* when called on numpy arrays. `np.divmod(x, y)` calculates a result equivalent
    to `(np.floor_divide(x, y), np.remainder(x, y))` but is approximately twice as
    fast as calling the functions separately.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.isnat` ufunc tests for NaT special datetime and timedelta values'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new ufunc `np.isnat` finds the positions of special NaT values within datetime
    and timedelta arrays. This is analogous to `np.isnan`.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.heaviside` ufunc computes the Heaviside function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new function `np.heaviside(x, h0)` (a ufunc) computes the Heaviside function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`np.block` function for creating blocked arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add a new `block` function to the current stacking functions `vstack`, `hstack`,
    and `stack`. This allows concatenation across multiple axes simultaneously, with
    a similar syntax to array creation, but where elements can themselves be arrays.
    For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: While primarily useful for block matrices, this works for arbitrary dimensions
    of arrays.
  prefs: []
  type: TYPE_NORMAL
- en: It is similar to Matlab’s square bracket notation for creating block matrices.
  prefs: []
  type: TYPE_NORMAL
- en: '`isin` function, improving on `in1d`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new function `isin` tests whether each element of an N-dimensional array
    is present anywhere within a second array. It is an enhancement of `in1d` that
    preserves the shape of the first array.
  prefs: []
  type: TYPE_NORMAL
- en: Temporary elision
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: On platforms providing the `backtrace` function NumPy will try to avoid creating
    temporaries in expression involving basic numeric types. For example `d = a +
    b + c` is transformed to `d = a + b; d += c` which can improve performance for
    large arrays as less memory bandwidth is required to perform the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '`axes` argument for `unique`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In an N-dimensional array, the user can now choose the axis along which to look
    for duplicate N-1-dimensional elements using `numpy.unique`. The original behaviour
    is recovered if `axis=None` (default).
  prefs: []
  type: TYPE_NORMAL
- en: '`np.gradient` now supports unevenly spaced data'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Users can now specify a not-constant spacing for data. In particular `np.gradient`
    can now take:'
  prefs: []
  type: TYPE_NORMAL
- en: A single scalar to specify a sample distance for all dimensions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: N scalars to specify a constant sample distance for each dimension. i.e. `dx`,
    `dy`, `dz`, …
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: N arrays to specify the coordinates of the values along each dimension of F.
    The length of the array must match the size of the corresponding dimension
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any combination of N scalars/arrays with the meaning of 2\. and 3.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This means that, e.g., it is now possible to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Support for returning arrays of arbitrary dimensions in `apply_along_axis`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, only scalars or 1D arrays could be returned by the function passed
    to `apply_along_axis`. Now, it can return an array of any dimensionality (including
    0D), and the shape of this array replaces the axis of the array being iterated
    over.
  prefs: []
  type: TYPE_NORMAL
- en: '`.ndim` property added to `dtype` to complement `.shape`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For consistency with `ndarray` and `broadcast`, `d.ndim` is a shorthand for
    `len(d.shape)`.
  prefs: []
  type: TYPE_NORMAL
- en: Support for tracemalloc in Python 3.6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy now supports memory tracing with [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    module of Python 3.6 or newer. Memory allocations from NumPy are placed into the
    domain defined by `numpy.lib.tracemalloc_domain`. Note that NumPy allocation will
    not show up in [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    of earlier Python versions.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy may be built with relaxed stride checking debugging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting NPY_RELAXED_STRIDES_DEBUG=1 in the environment when relaxed stride checking
    is enabled will cause NumPy to be compiled with the affected strides set to the
    maximum value of npy_intp in order to help detect invalid usage of the strides
    in downstream projects. When enabled, invalid usage often results in an error
    being raised, but the exact type of error depends on the details of the code.
    TypeError and OverflowError have been observed in the wild.
  prefs: []
  type: TYPE_NORMAL
- en: It was previously the case that this option was disabled for releases and enabled
    in master and changing between the two required editing the code. It is now disabled
    by default but can be enabled for test builds.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ufunc behavior for overlapping inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Operations where ufunc input and output operands have memory overlap produced
    undefined results in previous NumPy versions, due to data dependency issues. In
    NumPy 1.13.0, results from such operations are now defined to be the same as for
    equivalent operations where there is no memory overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Operations affected now make temporary copies, as needed to eliminate data dependency.
    As detecting these cases is computationally expensive, a heuristic is used, which
    may in rare cases result to needless temporary copies. For operations where the
    data dependency is simple enough for the heuristic to analyze, temporary copies
    will not be made even if the arrays overlap, if it can be deduced copies are not
    necessary. As an example,``np.add(a, b, out=a)`` will not involve copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate a previously undefined operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In NumPy 1.13.0 the last line is guaranteed to be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar operation with simple non-problematic data dependence is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: It will continue to produce the same results as in previous NumPy versions,
    and will not involve unnecessary temporary copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change applies also to in-place binary operations, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This statement is now guaranteed to be equivalent to `x[...] = x + x.T`, whereas
    in previous NumPy versions the results were undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Partial support for 64-bit f2py extensions with MinGW
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extensions that incorporate Fortran libraries can now be built using the free
    [MinGW](https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/)
    toolset, also under Python 3.5\. This works best for extensions that only do calculations
    and uses the runtime modestly (reading and writing from files, for instance).
    Note that this does not remove the need for Mingwpy; if you make extensive use
    of the runtime, you will most likely run into [issues](https://mingwpy.github.io/issues.html).
    Instead, it should be regarded as a band-aid until Mingwpy is fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions can also be compiled using the MinGW toolset using the runtime library
    from the (moveable) WinPython 3.4 distribution, which can be useful for programs
    with a PySide1/Qt4 front-end.
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvements for `packbits` and `unpackbits`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions `numpy.packbits` with boolean input and `numpy.unpackbits` have
    been optimized to be a significantly faster for contiguous data.
  prefs: []
  type: TYPE_NORMAL
- en: Fix for PPC long double floating point information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous versions of NumPy, the `finfo` function returned invalid information
    about the [double double](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic)
    format of the `longdouble` float type on Power PC (PPC). The invalid values resulted
    from the failure of the NumPy algorithm to deal with the variable number of digits
    in the significand that are a feature of *PPC long doubles*. This release by-passes
    the failing algorithm by using heuristics to detect the presence of the PPC double
    double format. A side-effect of using these heuristics is that the `finfo` function
    is faster than previous releases.
  prefs: []
  type: TYPE_NORMAL
- en: Better default repr for `ndarray` subclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subclasses of ndarray with no `repr` specialization now correctly indent their
    data and type lines.
  prefs: []
  type: TYPE_NORMAL
- en: More reliable comparisons of masked arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparisons of masked arrays were buggy for masked scalars and failed for structured
    arrays with dimension higher than one. Both problems are now solved. In the process,
    it was ensured that in getting the result for a structured array, masked fields
    are properly ignored, i.e., the result is equal if all fields that are non-masked
    in both are equal, thus making the behaviour identical to what one gets by comparing
    an unstructured masked array and then doing `.all()` over some axis.
  prefs: []
  type: TYPE_NORMAL
- en: np.matrix with booleans elements can now be created using the string syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.matrix` failed whenever one attempts to use it with booleans, e.g., `np.matrix(''True'')`.
    Now, this works as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: More `linalg` operations now accept empty vectors and matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the following functions in `np.linalg` now work when given input arrays
    with a 0 in the last two dimensions: `det`, `slogdet`, `pinv`, `eigvals`, `eigvalsh`,
    `eig`, `eigh`.'
  prefs: []
  type: TYPE_NORMAL
- en: Bundled version of LAPACK is now 3.2.2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy comes bundled with a minimal implementation of lapack for systems without
    a lapack library installed, under the name of `lapack_lite`. This has been upgraded
    from LAPACK 3.0.0 (June 30, 1999) to LAPACK 3.2.2 (June 30, 2010). See the [LAPACK
    changelogs](http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases)
    for details on the all the changes this entails.
  prefs: []
  type: TYPE_NORMAL
- en: While no new features are exposed through `numpy`, this fixes some bugs regarding
    “workspace” sizes, and in some places may use faster algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '`reduce` of `np.hypot.reduce` and `np.logical_xor` allowed in more cases'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This now works on empty arrays, returning 0, and can reduce over multiple axes.
    Previously, a `ValueError` was thrown in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Better `repr` of object arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Object arrays that contain themselves no longer cause a recursion error.
  prefs: []
  type: TYPE_NORMAL
- en: Object arrays that contain `list` objects are now printed in a way that makes
    clear the difference between a 2d object array, and a 1d object array of lists.
  prefs: []
  type: TYPE_NORMAL
- en: Ufunc behavior for overlapping inputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Operations where ufunc input and output operands have memory overlap produced
    undefined results in previous NumPy versions, due to data dependency issues. In
    NumPy 1.13.0, results from such operations are now defined to be the same as for
    equivalent operations where there is no memory overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Operations affected now make temporary copies, as needed to eliminate data dependency.
    As detecting these cases is computationally expensive, a heuristic is used, which
    may in rare cases result to needless temporary copies. For operations where the
    data dependency is simple enough for the heuristic to analyze, temporary copies
    will not be made even if the arrays overlap, if it can be deduced copies are not
    necessary. As an example,``np.add(a, b, out=a)`` will not involve copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate a previously undefined operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In NumPy 1.13.0 the last line is guaranteed to be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar operation with simple non-problematic data dependence is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: It will continue to produce the same results as in previous NumPy versions,
    and will not involve unnecessary temporary copies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change applies also to in-place binary operations, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This statement is now guaranteed to be equivalent to `x[...] = x + x.T`, whereas
    in previous NumPy versions the results were undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Partial support for 64-bit f2py extensions with MinGW
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Extensions that incorporate Fortran libraries can now be built using the free
    [MinGW](https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/)
    toolset, also under Python 3.5\. This works best for extensions that only do calculations
    and uses the runtime modestly (reading and writing from files, for instance).
    Note that this does not remove the need for Mingwpy; if you make extensive use
    of the runtime, you will most likely run into [issues](https://mingwpy.github.io/issues.html).
    Instead, it should be regarded as a band-aid until Mingwpy is fully functional.
  prefs: []
  type: TYPE_NORMAL
- en: Extensions can also be compiled using the MinGW toolset using the runtime library
    from the (moveable) WinPython 3.4 distribution, which can be useful for programs
    with a PySide1/Qt4 front-end.
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvements for `packbits` and `unpackbits`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions `numpy.packbits` with boolean input and `numpy.unpackbits` have
    been optimized to be a significantly faster for contiguous data.
  prefs: []
  type: TYPE_NORMAL
- en: Fix for PPC long double floating point information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In previous versions of NumPy, the `finfo` function returned invalid information
    about the [double double](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic)
    format of the `longdouble` float type on Power PC (PPC). The invalid values resulted
    from the failure of the NumPy algorithm to deal with the variable number of digits
    in the significand that are a feature of *PPC long doubles*. This release by-passes
    the failing algorithm by using heuristics to detect the presence of the PPC double
    double format. A side-effect of using these heuristics is that the `finfo` function
    is faster than previous releases.
  prefs: []
  type: TYPE_NORMAL
- en: Better default repr for `ndarray` subclasses
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Subclasses of ndarray with no `repr` specialization now correctly indent their
    data and type lines.
  prefs: []
  type: TYPE_NORMAL
- en: More reliable comparisons of masked arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparisons of masked arrays were buggy for masked scalars and failed for structured
    arrays with dimension higher than one. Both problems are now solved. In the process,
    it was ensured that in getting the result for a structured array, masked fields
    are properly ignored, i.e., the result is equal if all fields that are non-masked
    in both are equal, thus making the behaviour identical to what one gets by comparing
    an unstructured masked array and then doing `.all()` over some axis.
  prefs: []
  type: TYPE_NORMAL
- en: np.matrix with booleans elements can now be created using the string syntax
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.matrix` failed whenever one attempts to use it with booleans, e.g., `np.matrix(''True'')`.
    Now, this works as expected.'
  prefs: []
  type: TYPE_NORMAL
- en: More `linalg` operations now accept empty vectors and matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All of the following functions in `np.linalg` now work when given input arrays
    with a 0 in the last two dimensions: `det`, `slogdet`, `pinv`, `eigvals`, `eigvalsh`,
    `eig`, `eigh`.'
  prefs: []
  type: TYPE_NORMAL
- en: Bundled version of LAPACK is now 3.2.2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy comes bundled with a minimal implementation of lapack for systems without
    a lapack library installed, under the name of `lapack_lite`. This has been upgraded
    from LAPACK 3.0.0 (June 30, 1999) to LAPACK 3.2.2 (June 30, 2010). See the [LAPACK
    changelogs](http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases)
    for details on the all the changes this entails.
  prefs: []
  type: TYPE_NORMAL
- en: While no new features are exposed through `numpy`, this fixes some bugs regarding
    “workspace” sizes, and in some places may use faster algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '`reduce` of `np.hypot.reduce` and `np.logical_xor` allowed in more cases'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This now works on empty arrays, returning 0, and can reduce over multiple axes.
    Previously, a `ValueError` was thrown in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: Better `repr` of object arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Object arrays that contain themselves no longer cause a recursion error.
  prefs: []
  type: TYPE_NORMAL
- en: Object arrays that contain `list` objects are now printed in a way that makes
    clear the difference between a 2d object array, and a 1d object array of lists.
  prefs: []
  type: TYPE_NORMAL
- en: Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`argsort` on masked arrays takes the same default arguments as `sort`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, `argsort` now places the masked values at the end of the sorted
    array, in the same way that `sort` already did. Additionally, the `end_with` argument
    is added to `argsort`, for consistency with `sort`. Note that this argument is
    not added at the end, so breaks any code that passed `fill_value` as a positional
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`average` now preserves subclasses'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For ndarray subclasses, `numpy.average` will now return an instance of the subclass,
    matching the behavior of most other NumPy functions such as `mean`. As a consequence,
    also calls that returned a scalar may now return a subclass array scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '`array == None` and `array != None` do element-wise comparison'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously these operations returned scalars `False` and `True` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal` for object arrays ignores object identity'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, these functions always treated identical objects as equal. This
    had the effect of overriding comparison failures, comparison of objects that did
    not return booleans, such as np.arrays, and comparison of objects where the results
    differed from object identity, such as NaNs.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean indexing changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boolean array-likes (such as lists of python bools) are always treated as boolean
    indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean scalars (including python `True`) are legal boolean indexes and never
    treated as integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexes must match the dimension of the axis that they index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexes used on the lhs of an assignment must match the dimensions of
    the rhs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexing into scalar arrays return a new 1-d array. This means that
    `array(1)[array(True)]` gives `array([1])` and not the original array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.random.multivariate_normal` behavior with bad covariance matrix'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is now possible to adjust the behavior the function will have when dealing
    with the covariance matrix by using two new keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tol` can be used to specify a tolerance to use when checking that the covariance
    matrix is positive semidefinite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check_valid` can be used to configure what the function will do in the presence
    of a matrix that is not positive semidefinite. Valid options are `ignore`, `warn`
    and `raise`. The default value, `warn` keeps the the behavior used on previous
    releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert_array_less` compares `np.inf` and `-np.inf` now'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, `np.testing.assert_array_less` ignored all infinite values. This
    is not the expected behavior both according to documentation and intuitively.
    Now, -inf < x < inf is considered `True` for any real number x and all other cases
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: '`assert_array_` and masked arrays `assert_equal` hide less warnings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some warnings that were previously hidden by the `assert_array_` functions are
    not hidden anymore. In most cases the warnings should be correct and, should they
    occur, will require changes to the tests using these functions. For the masked
    array `assert_equal` version, warnings may occur when comparing NaT. The function
    presently does not handle NaT or NaN specifically and it may be best to avoid
    it at this time should a warning show up due to this change.
  prefs: []
  type: TYPE_NORMAL
- en: '`offset` attribute value in `memmap` objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `offset` attribute in a `memmap` object is now set to the offset into the
    file. This is a behaviour change only for offsets greater than `mmap.ALLOCATIONGRANULARITY`.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.real` and `np.imag` return scalars for scalar inputs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, `np.real` and `np.imag` used to return array objects when provided
    a scalar input, which was inconsistent with other functions like `np.angle` and
    `np.conj`.
  prefs: []
  type: TYPE_NORMAL
- en: The polynomial convenience classes cannot be passed to ufuncs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ABCPolyBase class, from which the convenience classes are derived, sets
    `__array_ufun__ = None` in order of opt out of ufuncs. If a polynomial convenience
    class instance is passed as an argument to a ufunc, a `TypeError` will now be
    raised.
  prefs: []
  type: TYPE_NORMAL
- en: Output arguments to ufuncs can be tuples also for ufunc methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For calls to ufuncs, it was already possible, and recommended, to use an `out`
    argument with a tuple for ufuncs with multiple outputs. This has now been extended
    to output arguments in the `reduce`, `accumulate`, and `reduceat` methods. This
    is mostly for compatibility with `__array_ufunc`; there are no ufuncs yet that
    have more than one output.
  prefs: []
  type: TYPE_NORMAL
- en: '`argsort` on masked arrays takes the same default arguments as `sort`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, `argsort` now places the masked values at the end of the sorted
    array, in the same way that `sort` already did. Additionally, the `end_with` argument
    is added to `argsort`, for consistency with `sort`. Note that this argument is
    not added at the end, so breaks any code that passed `fill_value` as a positional
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: '`average` now preserves subclasses'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For ndarray subclasses, `numpy.average` will now return an instance of the subclass,
    matching the behavior of most other NumPy functions such as `mean`. As a consequence,
    also calls that returned a scalar may now return a subclass array scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '`array == None` and `array != None` do element-wise comparison'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously these operations returned scalars `False` and `True` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.equal, np.not_equal` for object arrays ignores object identity'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, these functions always treated identical objects as equal. This
    had the effect of overriding comparison failures, comparison of objects that did
    not return booleans, such as np.arrays, and comparison of objects where the results
    differed from object identity, such as NaNs.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean indexing changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boolean array-likes (such as lists of python bools) are always treated as boolean
    indexes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean scalars (including python `True`) are legal boolean indexes and never
    treated as integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexes must match the dimension of the axis that they index.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexes used on the lhs of an assignment must match the dimensions of
    the rhs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Boolean indexing into scalar arrays return a new 1-d array. This means that
    `array(1)[array(True)]` gives `array([1])` and not the original array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.random.multivariate_normal` behavior with bad covariance matrix'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is now possible to adjust the behavior the function will have when dealing
    with the covariance matrix by using two new keyword arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tol` can be used to specify a tolerance to use when checking that the covariance
    matrix is positive semidefinite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check_valid` can be used to configure what the function will do in the presence
    of a matrix that is not positive semidefinite. Valid options are `ignore`, `warn`
    and `raise`. The default value, `warn` keeps the the behavior used on previous
    releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`assert_array_less` compares `np.inf` and `-np.inf` now'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, `np.testing.assert_array_less` ignored all infinite values. This
    is not the expected behavior both according to documentation and intuitively.
    Now, -inf < x < inf is considered `True` for any real number x and all other cases
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: '`assert_array_` and masked arrays `assert_equal` hide less warnings'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some warnings that were previously hidden by the `assert_array_` functions are
    not hidden anymore. In most cases the warnings should be correct and, should they
    occur, will require changes to the tests using these functions. For the masked
    array `assert_equal` version, warnings may occur when comparing NaT. The function
    presently does not handle NaT or NaN specifically and it may be best to avoid
    it at this time should a warning show up due to this change.
  prefs: []
  type: TYPE_NORMAL
- en: '`offset` attribute value in `memmap` objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `offset` attribute in a `memmap` object is now set to the offset into the
    file. This is a behaviour change only for offsets greater than `mmap.ALLOCATIONGRANULARITY`.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.real` and `np.imag` return scalars for scalar inputs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, `np.real` and `np.imag` used to return array objects when provided
    a scalar input, which was inconsistent with other functions like `np.angle` and
    `np.conj`.
  prefs: []
  type: TYPE_NORMAL
- en: The polynomial convenience classes cannot be passed to ufuncs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ABCPolyBase class, from which the convenience classes are derived, sets
    `__array_ufun__ = None` in order of opt out of ufuncs. If a polynomial convenience
    class instance is passed as an argument to a ufunc, a `TypeError` will now be
    raised.
  prefs: []
  type: TYPE_NORMAL
- en: Output arguments to ufuncs can be tuples also for ufunc methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For calls to ufuncs, it was already possible, and recommended, to use an `out`
    argument with a tuple for ufuncs with multiple outputs. This has now been extended
    to output arguments in the `reduce`, `accumulate`, and `reduceat` methods. This
    is mostly for compatibility with `__array_ufunc`; there are no ufuncs yet that
    have more than one output.
  prefs: []
  type: TYPE_NORMAL
