- en: Matrices (linear algebra)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/matrices/matrices.html](https://docs.sympy.org/latest/modules/matrices/matrices.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Creating Matrices'
  prefs: []
  type: TYPE_NORMAL
- en: 'The linear algebra module is designed to be as simple as possible. First, we
    import and declare our first `Matrix` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to creating a matrix from a list of appropriately-sized lists and/or
    matrices, SymPy also supports more advanced methods of matrix creation including
    a single list of values and dimension inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'More interesting (and useful), is the ability to use a 2-variable function
    (or `lambda`) to create a matrix. Here we create an indicator function which is
    1 on the diagonal and then use it to make the identity matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally let’s use `lambda` to create a 1-line matrix with 1’s in the even permutation
    entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are also a couple of special constructors for quick matrix construction:
    `eye` is the identity matrix, `zeros` and `ones` for matrices of all zeros and
    ones, respectively, and `diag` to put matrices or elements along the diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Basic Manipulation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While learning to work with matrices, let’s choose one where the entries are
    readily identifiable. One useful thing to know is that while matrices are 2-dimensional,
    the storage is not and so it is allowable - though one should be careful - to
    access the entries as if they were a 1-d list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the more standard entry access is a pair of indices which will always
    return the value at the corresponding row and column of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is Python we’re also able to slice submatrices; slices always give
    a matrix in return, even if the dimension is 1 x 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the second example above notice that the slice 2:2 gives an empty range.
    Note also (in keeping with 0-based indexing of Python) the first row/column is
    0.
  prefs: []
  type: TYPE_NORMAL
- en: 'You cannot access rows or columns that are not present unless they are in a
    slice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Slicing an empty matrix works as long as you use a slice for the coordinate
    that has no size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Slicing gives a copy of what is sliced, so modifications of one object do not
    affect the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that changing `M2` didn’t change `M`. Since we can slice, we can also
    assign entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'as well as assign slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'All the standard arithmetic operations are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as some useful vector operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall that the `row_del()` and `col_del()` operations don’t return a value
    - they simply change the matrix object. We can also ‘’glue’’ together matrices
    of the appropriate size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Operations on entries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are not restricted to having multiplication between two matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'but we can also apply functions to our matrix entries using `applyfunc()`.
    Here we’ll declare a function that double any input number. Then we apply it to
    the 3x3 identity matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to extract a common factor from a matrix you can do so by applying
    `gcd` to the data of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'One more useful matrix-wide entry application function is the substitution
    function. Let’s declare a matrix with symbolic entries then substitute a value.
    Remember we can substitute anything - even another symbol!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Linear algebra
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have the basics out of the way, let’s see what we can do with the
    actual matrices. Of course, one of the first things that comes to mind is the
    determinant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common operation is the inverse: In SymPy, this is computed by Gaussian
    elimination by default (for dense matrices) but we can specify it be done by \(LU\)
    decomposition as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can perform a \(QR\) factorization which is handy for solving systems:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to the solvers in the `solver.py` file, we can solve the system
    Ax=b by passing the b vector to the matrix A’s LUsolve function. Here we’ll cheat
    a little choose A and x then multiply to get b. Then we can solve for x and check
    that it’s correct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s also a nice Gram-Schmidt orthogonalizer which will take a set of vectors
    and orthogonalize them with respect to another. There is an optional argument
    which specifies whether or not the output should also be normalized, it defaults
    to `False`. Let’s take some vectors and orthogonalize them - one normalized and
    one not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a look at the vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can spot-check their orthogonality with dot() and their normality with norm():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So there is quite a bit that can be done with the module including eigenvalues,
    eigenvectors, nullspace calculation, cofactor expansion tools, and so on. From
    here one might want to look over the `matrices.py` file for all functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Matrix Base Classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Matrix classes are built from functionality in various base classes. Every
    methods and attribute of `Matrix` is implemented on one of these base classes.
    See also [Dense Matrices](dense.html), and [Sparse Matrices](sparse.html).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: All common matrix operations including basic arithmetic, shaping, and special
    matrices like \(zeros\), and \(eye\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: By-element conjugation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Return Dirac conjugate (if `self.rows == 4`).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If the matrix does not have 4 rows an AttributeError will be raised because
    this property is only defined for matrices with 4 rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.conjugate`](#sympy.matrices.matrixbase.MatrixBase.conjugate
    "sympy.matrices.matrixbase.MatrixBase.conjugate")'
  prefs: []
  type: TYPE_NORMAL
- en: By-element conjugation
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.H`](#sympy.matrices.matrixbase.MatrixBase.H
    "sympy.matrices.matrixbase.MatrixBase.H")'
  prefs: []
  type: TYPE_NORMAL
- en: Hermite conjugation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Return Hermite conjugate.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`conjugate`](#sympy.matrices.matrixbase.MatrixBase.conjugate "sympy.matrices.matrixbase.MatrixBase.conjugate")'
  prefs: []
  type: TYPE_NORMAL
- en: By-element conjugation
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.D`](#sympy.matrices.matrixbase.MatrixBase.D
    "sympy.matrices.matrixbase.MatrixBase.D")'
  prefs: []
  type: TYPE_NORMAL
- en: Dirac conjugation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Returns the LDL Decomposition (L, D) of matrix A, such that L * D * L.H == A
    if hermitian flag is True, or L * D * L.T == A if hermitian is False. This method
    eliminates the use of square root. Further this ensures that all the diagonal
    entries of L are 1. A must be a Hermitian positive-definite matrix if hermitian
    is True, or a symmetric matrix otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The matrix can have complex entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.cholesky`](dense.html#sympy.matrices.dense.DenseMatrix.cholesky
    "sympy.matrices.dense.DenseMatrix.cholesky"), [`sympy.matrices.matrixbase.MatrixBase.LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition
    "sympy.matrices.matrixbase.MatrixBase.LUdecomposition"), [`QRdecomposition`](#sympy.matrices.matrixbase.MatrixBase.QRdecomposition
    "sympy.matrices.matrixbase.MatrixBase.QRdecomposition")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Solves `Ax = B` using LDL decomposition, for a general square and non-singular
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: For a non-square matrix with rows > cols, the least squares solution is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.LDLdecomposition`](dense.html#sympy.matrices.dense.DenseMatrix.LDLdecomposition
    "sympy.matrices.dense.DenseMatrix.LDLdecomposition"), [`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve
    "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve
    "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve
    "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve
    "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve
    "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve
    "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve
    "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve
    "sympy.matrices.matrixbase.MatrixBase.cramer_solve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Returns (L, U, perm) where L is a lower triangular matrix with unit diagonal,
    U is an upper triangular matrix, and perm is a list of row swap index pairs. If
    A is the original matrix, then `A = (L*U).permuteBkwd(perm)`, and the row permutation
    matrix P such that \(P A = L U\) can be computed by `P = eye(A.rows).permuteFwd(perm)`.
  prefs: []
  type: TYPE_NORMAL
- en: See documentation for LUCombined for details about the keyword argument rankcheck,
    iszerofunc, and simpfunc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rankcheck** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Determines if this function should detect the rank deficiency of the matrixis
    and should raise a `ValueError`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**iszerofunc** : function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A function which determines if a given expression is zero.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The function should be a callable that takes a single SymPy expression and returns
    a 3-valued boolean value `True`, `False`, or `None`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is internally used by the pivot searching algorithm. See the notes section
    for a more information about the pivot searching algorithm.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**simpfunc** : function or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A function that simplifies the input.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If this is specified as a function, this function should be a callable that
    takes a single SymPy expression and returns an another SymPy expression that is
    algebraically equivalent.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `None`, it indicates that the pivot search algorithm should not attempt to
    simplify any candidate pivots.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is internally used by the pivot searching algorithm. See the notes section
    for a more information about the pivot searching algorithm.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.cholesky`](dense.html#sympy.matrices.dense.DenseMatrix.cholesky
    "sympy.matrices.dense.DenseMatrix.cholesky"), [`sympy.matrices.dense.DenseMatrix.LDLdecomposition`](dense.html#sympy.matrices.dense.DenseMatrix.LDLdecomposition
    "sympy.matrices.dense.DenseMatrix.LDLdecomposition"), [`QRdecomposition`](#sympy.matrices.matrixbase.MatrixBase.QRdecomposition
    "sympy.matrices.matrixbase.MatrixBase.QRdecomposition"), [`LUdecomposition_Simple`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition_Simple
    "sympy.matrices.matrixbase.MatrixBase.LUdecomposition_Simple"), [`LUdecompositionFF`](#sympy.matrices.matrixbase.MatrixBase.LUdecompositionFF
    "sympy.matrices.matrixbase.MatrixBase.LUdecompositionFF"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Compute a fraction-free LU decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: Returns 4 matrices P, L, D, U such that PA = L D**-1 U. If the elements of the
    matrix belong to some integral domain I, then all elements of L, D and U are guaranteed
    to belong to I.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition
    "sympy.matrices.matrixbase.MatrixBase.LUdecomposition"), [`LUdecomposition_Simple`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition_Simple
    "sympy.matrices.matrixbase.MatrixBase.LUdecomposition_Simple"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R609](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'W. Zhou & D.J. Jeffrey, “Fraction-free matrix factors: new forms for LU and
    QR factors”. Frontiers in Computer Science in China, Vol 2, no. 1, pp. 67-80,
    2008.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Compute the PLU decomposition of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rankcheck** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Determines if this function should detect the rank deficiency of the matrixis
    and should raise a `ValueError`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**iszerofunc** : function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A function which determines if a given expression is zero.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The function should be a callable that takes a single SymPy expression and returns
    a 3-valued boolean value `True`, `False`, or `None`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is internally used by the pivot searching algorithm. See the notes section
    for a more information about the pivot searching algorithm.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**simpfunc** : function or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A function that simplifies the input.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If this is specified as a function, this function should be a callable that
    takes a single SymPy expression and returns an another SymPy expression that is
    algebraically equivalent.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `None`, it indicates that the pivot search algorithm should not attempt to
    simplify any candidate pivots.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is internally used by the pivot searching algorithm. See the notes section
    for a more information about the pivot searching algorithm.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(lu, row_swaps)** : (Matrix, list)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the original matrix is a \(m, n\) matrix:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*lu* is a \(m, n\) matrix, which contains result of the decomposition in a
    compressed form. See the notes section to see how the matrix is compressed.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*row_swaps* is a \(m\)-element list where each element is a pair of row exchange
    indices.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`A = (L*U).permute_backward(perm)`, and the row permutation matrix \(P\) from
    the formula \(P A = L U\) can be computed by `P=eye(A.row).permute_forward(perm)`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: Raised if `rankcheck=True` and the matrix is found to be rank deficient during
    the computation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'About the PLU decomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: PLU decomposition is a generalization of a LU decomposition which can be extended
    for rank-deficient matrices.
  prefs: []
  type: TYPE_NORMAL
- en: It can further be generalized for non-square matrices, and this is the notation
    that SymPy is using.
  prefs: []
  type: TYPE_NORMAL
- en: PLU decomposition is a decomposition of a \(m, n\) matrix \(A\) in the form
    of \(P A = L U\) where
  prefs: []
  type: TYPE_NORMAL
- en: \(L\) is a \(m, m\) lower triangular matrix with unit diagonal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: entries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: \(U\) is a \(m, n\) upper triangular matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(P\) is a \(m, m\) permutation matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, for a square matrix, the decomposition would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}L = \begin{bmatrix} 1 & 0 & 0 & \cdots & 0 \\ L_{1, 0} & 1 &
    0 & \cdots & 0 \\ L_{2, 0} & L_{2, 1} & 1 & \cdots & 0 \\ \vdots & \vdots & \vdots
    & \ddots & \vdots \\ L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \cdots & 1 \end{bmatrix}\end{split}\]\[\begin{split}U
    = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots & U_{0, n-1} \\ 0 &
    U_{1, 1} & U_{1, 2} & \cdots & U_{1, n-1} \\ 0 & 0 & U_{2, 2} & \cdots & U_{2,
    n-1} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & 0 & \cdots & U_{n-1,
    n-1} \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'And for a matrix with more rows than the columns, the decomposition would look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}L = \begin{bmatrix} 1 & 0 & 0 & \cdots & 0 & 0 & \cdots & 0 \\
    L_{1, 0} & 1 & 0 & \cdots & 0 & 0 & \cdots & 0 \\ L_{2, 0} & L_{2, 1} & 1 & \cdots
    & 0 & 0 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots & \vdots &
    \ddots & \vdots \\ L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \cdots & 1 & 0 & \cdots
    & 0 \\ L_{n, 0} & L_{n, 1} & L_{n, 2} & \cdots & L_{n, n-1} & 1 & \cdots & 0 \\
    \vdots & \vdots & \vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\ L_{m-1,
    0} & L_{m-1, 1} & L_{m-1, 2} & \cdots & L_{m-1, n-1} & 0 & \cdots & 1 \\ \end{bmatrix}\end{split}\]\[\begin{split}U
    = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots & U_{0, n-1} \\ 0 &
    U_{1, 1} & U_{1, 2} & \cdots & U_{1, n-1} \\ 0 & 0 & U_{2, 2} & \cdots & U_{2,
    n-1} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & 0 & \cdots & U_{n-1,
    n-1} \\ 0 & 0 & 0 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots \\
    0 & 0 & 0 & \cdots & 0 \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for a matrix with more columns than the rows, the decomposition would
    look like:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}L = \begin{bmatrix} 1 & 0 & 0 & \cdots & 0 \\ L_{1, 0} & 1 &
    0 & \cdots & 0 \\ L_{2, 0} & L_{2, 1} & 1 & \cdots & 0 \\ \vdots & \vdots & \vdots
    & \ddots & \vdots \\ L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \cdots & 1 \end{bmatrix}\end{split}\]\[\begin{split}U
    = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots & U_{0, m-1} & \cdots
    & U_{0, n-1} \\ 0 & U_{1, 1} & U_{1, 2} & \cdots & U_{1, m-1} & \cdots & U_{1,
    n-1} \\ 0 & 0 & U_{2, 2} & \cdots & U_{2, m-1} & \cdots & U_{2, n-1} \\ \vdots
    & \vdots & \vdots & \ddots & \vdots & \cdots & \vdots \\ 0 & 0 & 0 & \cdots &
    U_{m-1, m-1} & \cdots & U_{m-1, n-1} \\ \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'About the compressed LU storage:'
  prefs: []
  type: TYPE_NORMAL
- en: The results of the decomposition are often stored in compressed forms rather
    than returning \(L\) and \(U\) matrices individually.
  prefs: []
  type: TYPE_NORMAL
- en: It may be less intiuitive, but it is commonly used for a lot of numeric libraries
    because of the efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The storage matrix is defined as following for this specific method:'
  prefs: []
  type: TYPE_NORMAL
- en: The subdiagonal elements of \(L\) are stored in the subdiagonal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: portion of \(LU\), that is \(LU_{i, j} = L_{i, j}\) whenever \(i > j\).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The elements on the diagonal of \(L\) are all 1, and are not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: explicitly stored.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: \(U\) is stored in the upper triangular portion of \(LU\), that is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(LU_{i, j} = U_{i, j}\) whenever \(i <= j\).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a case of \(m > n\), the right side of the \(L\) matrix is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: trivial to store.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For a case of \(m < n\), the below side of the \(U\) matrix is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: trivial to store.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, for a square matrix, the compressed output matrix would be:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}LU = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots
    & U_{0, n-1} \\ L_{1, 0} & U_{1, 1} & U_{1, 2} & \cdots & U_{1, n-1} \\ L_{2,
    0} & L_{2, 1} & U_{2, 2} & \cdots & U_{2, n-1} \\ \vdots & \vdots & \vdots & \ddots
    & \vdots \\ L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \cdots & U_{n-1, n-1} \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'For a matrix with more rows than the columns, the compressed output matrix
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}LU = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots
    & U_{0, n-1} \\ L_{1, 0} & U_{1, 1} & U_{1, 2} & \cdots & U_{1, n-1} \\ L_{2,
    0} & L_{2, 1} & U_{2, 2} & \cdots & U_{2, n-1} \\ \vdots & \vdots & \vdots & \ddots
    & \vdots \\ L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \cdots & U_{n-1, n-1} \\ \vdots
    & \vdots & \vdots & \ddots & \vdots \\ L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} &
    \cdots & L_{m-1, n-1} \\ \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'For a matrix with more columns than the rows, the compressed output matrix
    would be:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}LU = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots
    & U_{0, m-1} & \cdots & U_{0, n-1} \\ L_{1, 0} & U_{1, 1} & U_{1, 2} & \cdots
    & U_{1, m-1} & \cdots & U_{1, n-1} \\ L_{2, 0} & L_{2, 1} & U_{2, 2} & \cdots
    & U_{2, m-1} & \cdots & U_{2, n-1} \\ \vdots & \vdots & \vdots & \ddots & \vdots
    & \cdots & \vdots \\ L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \cdots & U_{m-1, m-1}
    & \cdots & U_{m-1, n-1} \\ \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'About the pivot searching algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: When a matrix contains symbolic entries, the pivot search algorithm differs
    from the case where every entry can be categorized as zero or nonzero. The algorithm
    searches column by column through the submatrix whose top left entry coincides
    with the pivot position. If it exists, the pivot is the first entry in the current
    search column that iszerofunc guarantees is nonzero. If no such candidate exists,
    then each candidate pivot is simplified if simpfunc is not None. The search is
    repeated, with the difference that a candidate may be the pivot if `iszerofunc()`
    cannot guarantee that it is nonzero. In the second search the pivot is the first
    candidate that iszerofunc can guarantee is nonzero. If no such candidate exists,
    then the pivot is the first candidate for which iszerofunc returns None. If no
    such candidate exists, then the search is repeated in the next column to the right.
    The pivot search algorithm differs from the one in `rref()`, which relies on `_find_reasonable_pivot()`.
    Future versions of `LUdecomposition_simple()` may use `_find_reasonable_pivot()`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition
    "sympy.matrices.matrixbase.MatrixBase.LUdecomposition"), [`LUdecompositionFF`](#sympy.matrices.matrixbase.MatrixBase.LUdecompositionFF
    "sympy.matrices.matrixbase.MatrixBase.LUdecompositionFF"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Solve the linear system `Ax = rhs` for `x` where `A = M`.
  prefs: []
  type: TYPE_NORMAL
- en: This is for symbolic matrices, for real or complex ones use mpmath.lu_solve
    or mpmath.qr_solve.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve
    "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve
    "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve
    "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve
    "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve
    "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve
    "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve
    "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve
    "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition
    "sympy.matrices.matrixbase.MatrixBase.LUdecomposition"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve
    "sympy.matrices.matrixbase.MatrixBase.cramer_solve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Returns a QR decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A QR decomposition is a decomposition in the form \(A = Q R\) where
  prefs: []
  type: TYPE_NORMAL
- en: \(Q\) is a column orthogonal matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(R\) is a upper triangular (trapezoidal) matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A column orthogonal matrix satisfies \(\mathbb{I} = Q^H Q\) while a full orthogonal
    matrix satisfies relation \(\mathbb{I} = Q Q^H = Q^H Q\) where \(I\) is an identity
    matrix with matching dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: For matrices which are not square or are rank-deficient, it is sufficient to
    return a column orthogonal matrix because augmenting them may introduce redundant
    computations. And an another advantage of this is that you can easily inspect
    the matrix rank by counting the number of columns of \(Q\).
  prefs: []
  type: TYPE_NORMAL
- en: If you want to augment the results to return a full orthogonal decomposition,
    you should use the following procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Augment the \(Q\) matrix with columns that are orthogonal to every other columns
    and make it square.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augment the \(R\) matrix with zero rows to make it have the same shape as the
    original matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The procedure will be illustrated in the examples section.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'A full rank matrix example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: If the matrix is square and full rank, the \(Q\) matrix becomes orthogonal in
    both directions, and needs no augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A rank deficient matrix example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: QRdecomposition might return a matrix Q that is rectangular. In this case the
    orthogonality condition might be satisfied as \(\mathbb{I} = Q.H*Q\) but not in
    the reversed product \(\mathbb{I} = Q * Q.H\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If you want to augment the results to be a full orthogonal decomposition, you
    should augment \(Q\) with an another orthogonal column.
  prefs: []
  type: TYPE_NORMAL
- en: You are able to append an identity matrix, and you can run the Gram-Schmidt
    process to make them augmented as orthogonal basis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Augmenting the \(R\) matrix with zero row is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'A zero matrix example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: They may return matrices with zero rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: As the same augmentation rule described above, \(Q\) can be augmented with columns
    of an identity matrix and \(R\) can be augmented with rows of a zero matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.cholesky`](dense.html#sympy.matrices.dense.DenseMatrix.cholesky
    "sympy.matrices.dense.DenseMatrix.cholesky"), [`sympy.matrices.dense.DenseMatrix.LDLdecomposition`](dense.html#sympy.matrices.dense.DenseMatrix.LDLdecomposition
    "sympy.matrices.dense.DenseMatrix.LDLdecomposition"), [`sympy.matrices.matrixbase.MatrixBase.LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition
    "sympy.matrices.matrixbase.MatrixBase.LUdecomposition"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve
    "sympy.matrices.matrixbase.MatrixBase.QRsolve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Solve the linear system `Ax = b`.
  prefs: []
  type: TYPE_NORMAL
- en: '`M` is the matrix `A`, the method argument is the vector `b`. The method returns
    the solution vector `x`. If `b` is a matrix, the system is solved for each column
    of `b` and the return value is a matrix of the same shape as `b`.'
  prefs: []
  type: TYPE_NORMAL
- en: This method is slower (approximately by a factor of 2) but more stable for floating-point
    arithmetic than the LUsolve method. However, LUsolve usually uses an exact arithmetic,
    so you do not need to use QRsolve.
  prefs: []
  type: TYPE_NORMAL
- en: This is mainly for educational purposes and symbolic matrices, for real (or
    complex) matrices use mpmath.qr_solve.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve
    "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve
    "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve
    "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve
    "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve
    "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve
    "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve
    "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`QRdecomposition`](#sympy.matrices.matrixbase.MatrixBase.QRdecomposition
    "sympy.matrices.matrixbase.MatrixBase.QRdecomposition"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve
    "sympy.matrices.matrixbase.MatrixBase.cramer_solve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Matrix transposition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Returns a new matrix with entry-wise absolute values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Return self + other, raising ShapeError if shapes do not match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Implementations of __getitem__ should accept ints, in which case the matrix
    is indexed as a flat list, tuples (i,j) in which case the (i,j) entry is returned,
    slices, or mixed tuples (a,b) where a and b are any combination of slices and
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Return the number of elements of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Implemented mainly so bool(Matrix()) == False.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Return self*other where other is either a scalar or a matrix of compatible dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`matrix_multiply_elementwise`](#sympy.matrices.dense.matrix_multiply_elementwise
    "sympy.matrices.dense.matrix_multiply_elementwise")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Return self**exp a scalar or symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: list of weak references to the object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Return self + b.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Conjugate transpose or Hermitian conjugation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Returns the adjugate, or classical adjoint, of a matrix. That is, the transpose
    of the matrix of cofactors.
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Adjugate](https://en.wikipedia.org/wiki/Adjugate)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**method** : string, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Method to use to find the cofactors, can be “bareiss”, “berkowitz”, “bird”,
    “laplace” or “lu”.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`cofactor_matrix`](#sympy.matrices.matrixbase.MatrixBase.cofactor_matrix "sympy.matrices.matrixbase.MatrixBase.cofactor_matrix"),
    [`sympy.matrices.matrixbase.MatrixBase.transpose`](#sympy.matrices.matrixbase.MatrixBase.transpose
    "sympy.matrices.matrixbase.MatrixBase.transpose")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Computes f(A) where A is a Square Matrix and f is an analytic function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: Analytic Function
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**x** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: parameter of f
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Apply a function to each element of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Returns a tuple containing the (real, imaginary) part of matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Returns the atoms that form the current object.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Computes determinant using Berkowitz method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`det`](#sympy.matrices.matrixbase.MatrixBase.det "sympy.matrices.matrixbase.MatrixBase.det")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Computes eigenvalues of a Matrix using Berkowitz method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Computes principal minors using Berkowitz method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Returns \((U,B,V.H)\) for
  prefs: []
  type: TYPE_NORMAL
- en: \[A = UBV^{H}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(A\) is the input matrix, and \(B\) is its Bidiagonalized form
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Bidiagonal Computation can hang for symbolic matrices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**upper** : bool. Whether to do upper bidiagnalization or lower.'
  prefs: []
  type: TYPE_NORMAL
- en: True for upper and False for lower.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R610](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 5.4.2, Matrix computations by Golub and Van Loan, 4th edition
  prefs: []
  type: TYPE_NORMAL
- en: '[[R611](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: Complex Matrix Bidiagonalization, [https://github.com/vslobody/Householder-Bidiagonalization](https://github.com/vslobody/Householder-Bidiagonalization)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Returns \(B\), the Bidiagonalized form of the input matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: Bidiagonal Computation can hang for symbolic matrices.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**upper** : bool. Whether to do upper bidiagnalization or lower.'
  prefs: []
  type: TYPE_NORMAL
- en: True for upper and False for lower.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R612](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: Algorithm 5.4.2, Matrix computations by Golub and Van Loan, 4th edition
  prefs: []
  type: TYPE_NORMAL
- en: '[[R613](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex Matrix Bidiagonalization : [https://github.com/vslobody/Householder-Bidiagonalization](https://github.com/vslobody/Householder-Bidiagonalization)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Computes characteristic polynomial det(x*I - M) where I is the identity matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'A PurePoly is returned, so using different variables for `x` does not affect
    the comparison or the polynomials:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x** : string, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Name for the “lambda” variable, defaults to “lambda”.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**simplify** : function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Simplification function to use on the characteristic polynomial calculated.
    Defaults to `simplify`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying `x` is optional; a symbol named `lambda` is used by default (which
    looks good when pretty-printed in unicode):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'And if `x` clashes with an existing symbol, underscores will be prepended to
    the name to make it unique:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Whether you pass a symbol or not, the generator can be obtained with the gen
    attribute since it may not be the same as the symbol that was passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The Samuelson-Berkowitz algorithm is used to compute the characteristic polynomial
    efficiently and without any division operations. Thus the characteristic polynomial
    over any commutative ring without zero divisors can be computed.
  prefs: []
  type: TYPE_NORMAL
- en: If the determinant det(x*I - M) can be found out easily as in the case of an
    upper or a lower triangular matrix, then instead of Samuelson-Berkowitz algorithm,
    eigenvalues are computed and the characteristic polynomial with their help.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`det`](#sympy.matrices.matrixbase.MatrixBase.det "sympy.matrices.matrixbase.MatrixBase.det")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Returns the Cholesky-type decomposition L of a matrix A such that L * L.H ==
    A if hermitian flag is True, or L * L.T == A if hermitian is False.
  prefs: []
  type: TYPE_NORMAL
- en: A must be a Hermitian positive-definite matrix if hermitian is True, or a symmetric
    matrix if it is False.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The matrix can have complex entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Non-hermitian Cholesky-type decomposition may be useful when the matrix is not
    positive-definite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.LDLdecomposition`](dense.html#sympy.matrices.dense.DenseMatrix.LDLdecomposition
    "sympy.matrices.dense.DenseMatrix.LDLdecomposition"), [`sympy.matrices.matrixbase.MatrixBase.LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition
    "sympy.matrices.matrixbase.MatrixBase.LUdecomposition"), [`QRdecomposition`](#sympy.matrices.matrixbase.MatrixBase.QRdecomposition
    "sympy.matrices.matrixbase.MatrixBase.QRdecomposition")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Solves `Ax = B` using Cholesky decomposition, for a general square non-singular
    matrix. For a non-square matrix with rows > cols, the least squares solution is
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve
    "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve
    "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve
    "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve
    "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve
    "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve
    "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve
    "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve
    "sympy.matrices.matrixbase.MatrixBase.cramer_solve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the cofactor of an element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**method** : string, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Method to use to find the cofactors, can be “bareiss”, “berkowitz”, “bird”,
    “laplace” or “lu”.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`cofactor_matrix`](#sympy.matrices.matrixbase.MatrixBase.cofactor_matrix "sympy.matrices.matrixbase.MatrixBase.cofactor_matrix"),
    [`minor`](#sympy.matrices.matrixbase.MatrixBase.minor "sympy.matrices.matrixbase.MatrixBase.minor"),
    [`minor_submatrix`](#sympy.matrices.matrixbase.MatrixBase.minor_submatrix "sympy.matrices.matrixbase.MatrixBase.minor_submatrix")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Return a matrix containing the cofactor of each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**method** : string, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Method to use to find the cofactors, can be “bareiss”, “berkowitz”, “bird”,
    “laplace” or “lu”.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`cofactor`](#sympy.matrices.matrixbase.MatrixBase.cofactor "sympy.matrices.matrixbase.MatrixBase.cofactor"),
    [`minor`](#sympy.matrices.matrixbase.MatrixBase.minor "sympy.matrices.matrixbase.MatrixBase.minor"),
    [`minor_submatrix`](#sympy.matrices.matrixbase.MatrixBase.minor_submatrix "sympy.matrices.matrixbase.MatrixBase.minor_submatrix")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Elementary column selector.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`row`](#sympy.matrices.matrixbase.MatrixBase.row "sympy.matrices.matrixbase.MatrixBase.row"),
    [`col_del`](#sympy.matrices.matrixbase.MatrixBase.col_del "sympy.matrices.matrixbase.MatrixBase.col_del"),
    [`col_join`](#sympy.matrices.matrixbase.MatrixBase.col_join "sympy.matrices.matrixbase.MatrixBase.col_join"),
    [`col_insert`](#sympy.matrices.matrixbase.MatrixBase.col_insert "sympy.matrices.matrixbase.MatrixBase.col_insert")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Delete the specified column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Insert one or more columns at the given column position.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`col`](#sympy.matrices.matrixbase.MatrixBase.col "sympy.matrices.matrixbase.MatrixBase.col"),
    [`row_insert`](#sympy.matrices.matrixbase.MatrixBase.row_insert "sympy.matrices.matrixbase.MatrixBase.row_insert")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Concatenates two matrices along self’s last and other’s first row.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`col`](#sympy.matrices.matrixbase.MatrixBase.col "sympy.matrices.matrixbase.MatrixBase.col"),
    [`row_join`](#sympy.matrices.matrixbase.MatrixBase.row_join "sympy.matrices.matrixbase.MatrixBase.row_join")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Returns a list of vectors (Matrix objects) that span columnspace of `M`
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`nullspace`](#sympy.matrices.matrixbase.MatrixBase.nullspace "sympy.matrices.matrixbase.MatrixBase.nullspace"),
    [`rowspace`](#sympy.matrices.matrixbase.MatrixBase.rowspace "sympy.matrices.matrixbase.MatrixBase.rowspace")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Returns a companion matrix of a polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Returns the condition number of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: This is the maximum singular value divided by the minimum singular value
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`singular_values`](#sympy.matrices.matrixbase.MatrixBase.singular_values "sympy.matrices.matrixbase.MatrixBase.singular_values")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Return the by-element conjugation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`transpose`](#sympy.matrices.matrixbase.MatrixBase.transpose "sympy.matrices.matrixbase.MatrixBase.transpose")'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix transposition
  prefs: []
  type: TYPE_NORMAL
- en: '[`H`](#sympy.matrices.matrixbase.MatrixBase.H "sympy.matrices.matrixbase.MatrixBase.H")'
  prefs: []
  type: TYPE_NORMAL
- en: Hermite conjugation
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.D`](#sympy.matrices.matrixbase.MatrixBase.D
    "sympy.matrices.matrixbase.MatrixBase.D")'
  prefs: []
  type: TYPE_NORMAL
- en: Dirac conjugation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Returns the list of connected vertices of the graph when a square matrix is
    viewed as a weighted graph.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Even if any symbolic elements of the matrix can be indeterminate to be zero
    mathematically, this only takes the account of the structural aspect of the matrix,
    so they will considered to be nonzero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Decomposes a square matrix into block diagonal form only using the permutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**P, B** : PermutationMatrix, BlockDiagMatrix'
  prefs: []
  type: TYPE_NORMAL
- en: '*P* is a permutation matrix for the similarity transform as in the explanation.
    And *B* is the block diagonal matrix of the result of the permutation.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you would like to get the diagonal blocks from the BlockDiagMatrix, see [`get_diag_blocks()`](expressions.html#sympy.matrices.expressions.blockmatrix.BlockDiagMatrix.get_diag_blocks
    "sympy.matrices.expressions.blockmatrix.BlockDiagMatrix.get_diag_blocks").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The decomposition is in a form of \(A = P^{-1} B P\) where \(P\) is a permutation
    matrix and \(B\) is a block diagonal matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This problem corresponds to the finding of the connected components of a graph,
    when a matrix is viewed as a weighted graph.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Returns the copy of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Solves system of linear equations using Cramer’s rule.
  prefs: []
  type: TYPE_NORMAL
- en: This method is relatively inefficient compared to other methods. However it
    only uses a single division, assuming a division-free determinant method is provided.
    This is helpful to minimize the chance of divide-by-zero cases in symbolic solutions
    to linear systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**M** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix representing the left hand side of the equation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**rhs** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix representing the right hand side of the equation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**det_method** : str or callable'
  prefs: []
  type: TYPE_NORMAL
- en: The method to use to calculate the determinant of the matrix. The default is
    `'laplace'`. If a callable is passed, it should take a single argument, the matrix,
    and return the determinant of the matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix that will satisfy `Ax = B`. Will have as many rows as matrix A has
    columns, and as many columns as matrix B.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R614](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Cramer%27s_rule#Explicit_formulas_for_small_systems](https://en.wikipedia.org/wiki/Cramer%27s_rule#Explicit_formulas_for_small_systems)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the cross product of `self` and `b` relaxing the condition of compatible
    dimensions: if each has 3 elements, a matrix of the same type and shape as `self`
    will be returned. If `b` has the same shape as `self` then common identities for
    the cross product (like \(a \times b = - b \times a\)) will hold.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**b** : 3x1 or 1x3 Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`dot`](#sympy.matrices.matrixbase.MatrixBase.dot "sympy.matrices.matrixbase.MatrixBase.dot"),
    [`hat`](#sympy.matrices.matrixbase.MatrixBase.hat "sympy.matrices.matrixbase.MatrixBase.hat"),
    [`vee`](#sympy.matrices.matrixbase.MatrixBase.vee "sympy.matrices.matrixbase.MatrixBase.vee"),
    [`multiply`](#sympy.matrices.matrixbase.MatrixBase.multiply "sympy.matrices.matrixbase.MatrixBase.multiply"),
    [`multiply_elementwise`](#sympy.matrices.matrixbase.MatrixBase.multiply_elementwise
    "sympy.matrices.matrixbase.MatrixBase.multiply_elementwise")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Computes the determinant of a matrix if `M` is a concrete matrix object otherwise
    return an expressions `Determinant(M)` if `M` is a `MatrixSymbol` or other expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**method** : string, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the algorithm used for computing the matrix determinant.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the matrix is at most 3x3, a hard-coded formula is used and the specified
    method is ignored. Otherwise, it defaults to `'bareiss'`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Also, if the matrix is an upper or a lower triangular matrix, determinant is
    computed by simple multiplication of diagonal elements, and the specified method
    is ignored.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is set to `'domain-ge'`, then Gaussian elimination method will be used
    via using DomainMatrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is set to `'bareiss'`, Bareiss’ fraction-free algorithm will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is set to `'berkowitz'`, Berkowitz’ algorithm will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is set to `'bird'`, Bird’s algorithm will be used [[R615]](#r615).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is set to `'laplace'`, Laplace’s algorithm will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Otherwise, if it is set to `'lu'`, LU decomposition will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For backward compatibility, legacy keys like “bareis” and “det_lu” can still
    be used to indicate the corresponding methods. And the keys are also case-insensitive
    for now. However, it is suggested to use the precise keys for specifying the method.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**iszerofunc** : FunctionType or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If it is set to `None`, it will be defaulted to `_iszero` if the method is set
    to `'bareiss'`, and `_is_zero_after_expand_mul` if the method is set to `'lu'`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It can also accept any user-specified zero testing function, if it is formatted
    as a function which accepts a single symbolic argument and returns `True` if it
    is tested as zero and `False` if it tested as non-zero, and also `None` if it
    is undecidable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**det** : Basic'
  prefs: []
  type: TYPE_NORMAL
- en: Result of determinant.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If unrecognized keys are given for `method` or `iszerofunc`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**NonSquareMatrixError**'
  prefs: []
  type: TYPE_NORMAL
- en: If attempted to calculate determinant from a non-square matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R615] ([1](#id7),[2](#id8))'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bird, R. S. (2011). A simple division-free algorithm for computing determinants.
    Inf. Process. Lett., 111(21), 1072-1074\. doi: 10.1016/j.ipl.2011.08.006'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Compute matrix determinant using LU decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this method fails if the LU decomposition itself fails. In particular,
    if the matrix has no inverse this method will fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'TODO: Implement algorithm for sparse matrices (SFF), [http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps](http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`det`](#sympy.matrices.matrixbase.MatrixBase.det "sympy.matrices.matrixbase.MatrixBase.det"),
    [`berkowitz_det`](#sympy.matrices.matrixbase.MatrixBase.berkowitz_det "sympy.matrices.matrixbase.MatrixBase.berkowitz_det")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Returns a matrix with the specified diagonal. If matrices are passed, a block-diagonal
    matrix is created (i.e. the “direct sum” of the matrices).
  prefs: []
  type: TYPE_NORMAL
- en: Kwargs
  prefs: []
  type: TYPE_NORMAL
- en: rowsrows of the resulting matrix; computed if
  prefs: []
  type: TYPE_NORMAL
- en: not given.
  prefs: []
  type: TYPE_NORMAL
- en: colscolumns of the resulting matrix; computed if
  prefs: []
  type: TYPE_NORMAL
- en: not given.
  prefs: []
  type: TYPE_NORMAL
- en: 'cls : class for the resulting matrix'
  prefs: []
  type: TYPE_NORMAL
- en: 'unpack : bool which, when True (default), unpacks a single sequence rather
    than interpreting it as a Matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: 'strict : bool which, when False (default), allows Matrices to have variable-length
    rows.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The current default is to unpack a single sequence. If this is not desired,
    set \(unpack=False\) and it will be interpreted as a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'When more than one element is passed, each is interpreted as something to put
    on the diagonal. Lists are converted to matrices. Filling of the diagonal always
    continues from the bottom right hand corner of the previous item: this will create
    a block-diagonal matrix whether the matrices are square or not.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'When \(unpack\) is False, elements within a list need not all be of the same
    length. Setting \(strict\) to True would raise a ValueError for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The type of the returned matrix can be set with the `cls` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'A zero dimension matrix can be used to position the start of the filling at
    the start of an arbitrary row or column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`eye`](#sympy.matrices.matrixbase.MatrixBase.eye "sympy.matrices.matrixbase.MatrixBase.eye"),
    [`diagonal`](#sympy.matrices.matrixbase.MatrixBase.diagonal "sympy.matrices.matrixbase.MatrixBase.diagonal"),
    [`dense.diag`](#sympy.matrices.dense.diag "sympy.matrices.dense.diag"), [`expressions.blockmatrix.BlockMatrix`](expressions.html#sympy.matrices.expressions.blockmatrix.BlockMatrix
    "sympy.matrices.expressions.blockmatrix.BlockMatrix"), [`sparsetools.banded`](sparsetools.html#sympy.matrices.sparsetools.banded
    "sympy.matrices.sparsetools.banded")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Returns the kth diagonal of self. The main diagonal corresponds to \(k=0\);
    diagonals above and below correspond to \(k > 0\) and \(k < 0\), respectively.
    The values of \(self[i, j]\) for which \(j - i = k\), are returned in order of
    increasing \(i + j\), starting with \(i + j = |k|\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the diagonal is returned as a Matrix, the element retrieval can
    be done with a single index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`diag`](#sympy.matrices.matrixbase.MatrixBase.diag "sympy.matrices.matrixbase.MatrixBase.diag")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Solves `Ax = B` efficiently, where A is a diagonal Matrix, with non-zero diagonal
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve
    "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve
    "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve
    "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve
    "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve
    "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve
    "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve
    "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve
    "sympy.matrices.matrixbase.MatrixBase.cramer_solve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Return (P, D), where D is diagonal and
  prefs: []
  type: TYPE_NORMAL
- en: D = P^-1 * M * P
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where M is current matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**reals_only** : bool. Whether to throw an error if complex numbers are need'
  prefs: []
  type: TYPE_NORMAL
- en: 'to diagonalize. (Default: False)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**sort** : bool. Sort the eigenvalues along the diagonal. (Default: False)'
  prefs: []
  type: TYPE_NORMAL
- en: '**normalize** : bool. If True, normalize the columns of P. (Default: False)'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.is_diagonal`](#sympy.matrices.matrixbase.MatrixBase.is_diagonal
    "sympy.matrices.matrixbase.MatrixBase.is_diagonal"), [`is_diagonalizable`](#sympy.matrices.matrixbase.MatrixBase.is_diagonalizable
    "sympy.matrices.matrixbase.MatrixBase.is_diagonalizable")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the derivative of each element in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`integrate`](#sympy.matrices.matrixbase.MatrixBase.integrate "sympy.matrices.matrixbase.MatrixBase.integrate"),
    [`limit`](#sympy.matrices.matrixbase.MatrixBase.limit "sympy.matrices.matrixbase.MatrixBase.limit")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Return the dot or inner product of two vectors of equal length. Here `self`
    must be a `Matrix` of size 1 x n or n x 1, and `b` must be either a matrix of
    size 1 x n, n x 1, or a list/tuple of length n. A scalar is returned.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `dot` does not conjugate `self` or `b`, even if there are complex
    entries. Set `hermitian=True` (and optionally a `conjugate_convention`) to compute
    the hermitian inner product.
  prefs: []
  type: TYPE_NORMAL
- en: Possible kwargs are `hermitian` and `conjugate_convention`.
  prefs: []
  type: TYPE_NORMAL
- en: If `conjugate_convention` is `"left"`, `"math"` or `"maths"`, the conjugate
    of the first vector (`self`) is used. If `"right"` or `"physics"` is specified,
    the conjugate of the second vector `b` is used.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`cross`](#sympy.matrices.matrixbase.MatrixBase.cross "sympy.matrices.matrixbase.MatrixBase.cross"),
    [`multiply`](#sympy.matrices.matrixbase.MatrixBase.multiply "sympy.matrices.matrixbase.MatrixBase.multiply"),
    [`multiply_elementwise`](#sympy.matrices.matrixbase.MatrixBase.multiply_elementwise
    "sympy.matrices.matrixbase.MatrixBase.multiply_elementwise")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Returns the dual of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'A dual of a matrix is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(1/2)*levicivita(i, j, k, l)*M(k, l)` summed over indices \(k\) and \(l\)'
  prefs: []
  type: TYPE_NORMAL
- en: Since the levicivita method is anti_symmetric for any pairwise exchange of indices,
    the dual of a symmetric matrix is the zero matrix. Strictly speaking the dual
    defined here assumes that the ‘matrix’ \(M\) is a contravariant anti_symmetric
    second rank tensor, so that the dual is a covariant second rank tensor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Returns a matrix row-equivalent to `M` that is in echelon form. Note that echelon
    form of a matrix is *not* unique, however, properties like the row space and the
    null space are preserved.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Compute eigenvalues of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**error_when_incomplete** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If it is set to `True`, it will raise an error if not all eigenvalues are computed.
    This is caused by `roots` not returning a full list of eigenvalues.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**simplify** : bool or function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If it is set to `True`, it attempts to return the most simplified form of expressions
    returned by applying default simplification method in every routine.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is set to `False`, it will skip simplification in this particular routine
    to save computation resources.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a function is passed to, it will attempt to apply the particular function
    as simplification method.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**rational** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If it is set to `True`, every floating point numbers would be replaced with
    rationals before computation. It can solve some issues of `roots` routine not
    working well with floats.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**multiple** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If it is set to `True`, the result will be in the form of a list.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is set to `False`, the result will be in the form of a dictionary.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**eigs** : list or dict'
  prefs: []
  type: TYPE_NORMAL
- en: Eigenvalues of a matrix. The return format would be specified by the key `multiple`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MatrixError**'
  prefs: []
  type: TYPE_NORMAL
- en: If not enough roots had got computed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**NonSquareMatrixError**'
  prefs: []
  type: TYPE_NORMAL
- en: If attempted to compute eigenvalues from a non-square matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Eigenvalues of a matrix \(A\) can be computed by solving a matrix equation \(\det(A
    - \lambda I) = 0\)
  prefs: []
  type: TYPE_NORMAL
- en: It’s not always possible to return radical solutions for eigenvalues for matrices
    larger than \(4, 4\) shape due to Abel-Ruffini theorem.
  prefs: []
  type: TYPE_NORMAL
- en: If there is no radical solution is found for the eigenvalue, it may return eigenvalues
    in the form of [`sympy.polys.rootoftools.ComplexRootOf`](../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MatrixBase.charpoly`](#sympy.matrices.matrixbase.MatrixBase.charpoly "sympy.matrices.matrixbase.MatrixBase.charpoly"),
    [`eigenvects`](#sympy.matrices.matrixbase.MatrixBase.eigenvects "sympy.matrices.matrixbase.MatrixBase.eigenvects")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Compute eigenvectors of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**error_when_incomplete** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Raise an error when not all eigenvalues are computed. This is caused by `roots`
    not returning a full list of eigenvalues.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**iszerofunc** : function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies a zero testing function to be used in `rref`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Default value is `_iszero`, which uses SymPy’s naive and fast default assumption
    handler.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It can also accept any user-specified zero testing function, if it is formatted
    as a function which accepts a single symbolic argument and returns `True` if it
    is tested as zero and `False` if it is tested as non-zero, and `None` if it is
    undecidable.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**simplify** : bool or function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, `as_content_primitive()` will be used to tidy up normalization artifacts.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It will also be used by the `nullspace` routine.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**chop** : bool or positive number, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If the matrix contains any Floats, they will be changed to Rationals for computation
    purposes, but the answers will be returned after being evaluated with evalf. The
    `chop` flag is passed to `evalf`. When `chop=True` a default precision will be
    used; a number will be interpreted as the desired level of precision.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ret** : [(eigenval, multiplicity, eigenspace), …]'
  prefs: []
  type: TYPE_NORMAL
- en: A ragged list containing tuples of data obtained by `eigenvals` and `nullspace`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`eigenspace` is a list containing the `eigenvector` for each eigenvalue.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`eigenvector` is a vector in the form of a `Matrix`. e.g. a vector of length
    3 is returned as `Matrix([a_1, a_2, a_3])`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NotImplementedError**'
  prefs: []
  type: TYPE_NORMAL
- en: If failed to compute nullspace.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`eigenvals`](#sympy.matrices.matrixbase.MatrixBase.eigenvals "sympy.matrices.matrixbase.MatrixBase.eigenvals"),
    [`MatrixBase.nullspace`](#sympy.matrices.matrixbase.MatrixBase.nullspace "sympy.matrices.matrixbase.MatrixBase.nullspace")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Performs the elementary column operation \(op\).
  prefs: []
  type: TYPE_NORMAL
- en: \(op\) may be one of
  prefs: []
  type: TYPE_NORMAL
- en: '`"n->kn"` (column n goes to k*n)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"n<->m"` (swap column n and column m)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"n->n+km"` (column n goes to column n + k*column m)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**op** : string; the elementary row operation'
  prefs: []
  type: TYPE_NORMAL
- en: '**col** : the column to apply the column operation'
  prefs: []
  type: TYPE_NORMAL
- en: '**k** : the multiple to apply in the column operation'
  prefs: []
  type: TYPE_NORMAL
- en: '**col1** : one column of a column swap'
  prefs: []
  type: TYPE_NORMAL
- en: '**col2** : second column of a column swap or column “m” in the column operation'
  prefs: []
  type: TYPE_NORMAL
- en: “n->n+km”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Performs the elementary row operation \(op\).
  prefs: []
  type: TYPE_NORMAL
- en: \(op\) may be one of
  prefs: []
  type: TYPE_NORMAL
- en: '`"n->kn"` (row n goes to k*n)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"n<->m"` (swap row n and row m)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`"n->n+km"` (row n goes to row n + k*row m)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**op** : string; the elementary row operation'
  prefs: []
  type: TYPE_NORMAL
- en: '**row** : the row to apply the row operation'
  prefs: []
  type: TYPE_NORMAL
- en: '**k** : the multiple to apply in the row operation'
  prefs: []
  type: TYPE_NORMAL
- en: '**row1** : one row of a row swap'
  prefs: []
  type: TYPE_NORMAL
- en: '**row2** : second row of a row swap or row “m” in the row operation'
  prefs: []
  type: TYPE_NORMAL
- en: “n->n+km”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Apply evalf() to each element of self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Return the exponential of a square matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Apply core.function.expand to each entry of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Return a submatrix by specifying a list of rows and columns. Negative indices
    can be given. All indices must be in the range \(-n \le i < n\) where \(n\) is
    the number of rows or columns.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Rows or columns can be repeated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Every other row can be taken by using range to provide the indices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'RowsList or colsList can also be a list of booleans, in which case the rows
    or columns corresponding to the True values will be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Returns an identity matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rows** : rows of the matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '**cols** : cols of the matrix (if None, cols=rows)'
  prefs: []
  type: TYPE_NORMAL
- en: Kwargs
  prefs: []
  type: TYPE_NORMAL
- en: 'cls : class of the returned matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Returns a flat list of all elements in the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`tolist`](#sympy.matrices.matrixbase.MatrixBase.tolist "sympy.matrices.matrixbase.MatrixBase.tolist"),
    [`values`](#sympy.matrices.matrixbase.MatrixBase.values "sympy.matrices.matrixbase.MatrixBase.values")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Returns the free symbols within the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Create a matrix from a dictionary of keys.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Solves `Ax = B` using Gauss Jordan elimination.
  prefs: []
  type: TYPE_NORMAL
- en: There may be zero, one, or infinite solutions. If one solution exists, it will
    be returned. If infinite solutions exist, it will be returned parametrically.
    If no solutions exist, It will throw ValueError.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**B** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The right hand side of the equation to be solved for. Must have the same number
    of rows as matrix A.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**freevar** : boolean, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Flag, when set to \(True\) will return the indices of the free variables in
    the solutions (column Matrix), for a system that is undetermined (e.g. A has more
    columns than rows), for which infinite solutions are possible, in terms of arbitrary
    values of free variables. Default \(False\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix that will satisfy `Ax = B`. Will have as many rows as matrix A has
    columns, and as many columns as matrix B.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**params** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: If the system is underdetermined (e.g. A has more columns than rows), infinite
    solutions are possible, in terms of arbitrary parameters. These arbitrary parameters
    are returned as params Matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**free_var_index** : List, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If the system is underdetermined (e.g. A has more columns than rows), infinite
    solutions are possible, in terms of arbitrary values of free variables. Then the
    indices of the free variables in the solutions (column Matrix) are returned by
    free_var_index, if the flag \(freevar\) is set to \(True\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve
    "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve
    "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve
    "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve
    "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve
    "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve
    "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv`](#sympy.matrices.matrixbase.MatrixBase.pinv
    "sympy.matrices.matrixbase.MatrixBase.pinv")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R616](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Gaussian_elimination](https://en.wikipedia.org/wiki/Gaussian_elimination)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Obtains the square sub-matrices on the main diagonal of a square matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Useful for inverting symbolic matrices or solving systems of linear equations
    which may be decoupled by having a block diagonal structure.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Test whether any subexpression matches any of the patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Return the skew-symmetric matrix representing the cross product, so that `self.hat()
    * b` is equivalent to `self.cross(b)`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `hat` creates a skew-symmetric 3x3 Matrix from a 3x1 Matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiplying it with another 3x1 Matrix calculates the cross product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Which is equivalent to calling the `cross` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`dot`](#sympy.matrices.matrixbase.MatrixBase.dot "sympy.matrices.matrixbase.MatrixBase.dot"),
    [`cross`](#sympy.matrices.matrixbase.MatrixBase.cross "sympy.matrices.matrixbase.MatrixBase.cross"),
    [`vee`](#sympy.matrices.matrixbase.MatrixBase.vee "sympy.matrices.matrixbase.MatrixBase.vee"),
    [`multiply`](#sympy.matrices.matrixbase.MatrixBase.multiply "sympy.matrices.matrixbase.MatrixBase.multiply"),
    [`multiply_elementwise`](#sympy.matrices.matrixbase.MatrixBase.multiply_elementwise
    "sympy.matrices.matrixbase.MatrixBase.multiply_elementwise")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Return a matrix formed by joining args horizontally (i.e. by repeated application
    of row_join).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Integrate each element of the matrix. `args` will be passed to the `integrate`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`limit`](#sympy.matrices.matrixbase.MatrixBase.limit "sympy.matrices.matrixbase.MatrixBase.limit"),
    [`diff`](#sympy.matrices.matrixbase.MatrixBase.diff "sympy.matrices.matrixbase.MatrixBase.diff")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: Return the inverse of a matrix using the method indicated. The default is DM
    if a suitable domain is found or otherwise GE for dense matrices LDL for sparse
    matrices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**method** : (‘DM’, ‘DMNC’, ‘GE’, ‘LU’, ‘ADJ’, ‘CH’, ‘LDL’, ‘QR’)'
  prefs: []
  type: TYPE_NORMAL
- en: '**iszerofunc** : function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Zero-testing function to use.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**try_block_diag** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True then will try to form block diagonal matrices using the method get_diag_blocks(),
    invert these individually, and then reconstruct the full inverse matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the determinant of the matrix is zero.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the `method` keyword, it calls the appropriate method:'
  prefs: []
  type: TYPE_NORMAL
- en: DM …. Use DomainMatrix `inv_den` method DMNC …. Use DomainMatrix `inv_den` method
    without cancellation GE …. inverse_GE(); default for dense matrices LU …. inverse_LU()
    ADJ … inverse_ADJ() CH … inverse_CH() LDL … inverse_LDL(); default for sparse
    matrices QR … inverse_QR()
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note, the GE and LU methods may require the matrix to be simplified before it
    is inverted in order to properly detect zeros during pivoting. In difficult cases
    a custom zero detection function can be provided by setting the `iszerofunc` argument
    to a function that should return True if its argument is zero. The ADJ routine
    computes the determinant and uses that to detect singular matrices in addition
    to testing for zeros on the diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"),
    [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"),
    [`inverse_LU`](#sympy.matrices.matrixbase.MatrixBase.inverse_LU "sympy.matrices.matrixbase.MatrixBase.inverse_LU"),
    [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"),
    [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Calculates the inverse using the adjugate matrix and a determinant.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"),
    [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"),
    [`inverse_LU`](#sympy.matrices.matrixbase.MatrixBase.inverse_LU "sympy.matrices.matrixbase.MatrixBase.inverse_LU"),
    [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"),
    [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Calculates the inverse using BLOCKWISE inversion.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"),
    [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"),
    [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"),
    [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"),
    [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Calculates the inverse using cholesky decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"),
    [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"),
    [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"),
    [`inverse_LU`](#sympy.matrices.matrixbase.MatrixBase.inverse_LU "sympy.matrices.matrixbase.MatrixBase.inverse_LU"),
    [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: Calculates the inverse using Gaussian elimination.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"),
    [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"),
    [`inverse_LU`](#sympy.matrices.matrixbase.MatrixBase.inverse_LU "sympy.matrices.matrixbase.MatrixBase.inverse_LU"),
    [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"),
    [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Calculates the inverse using LDL decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"),
    [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"),
    [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"),
    [`inverse_LU`](#sympy.matrices.matrixbase.MatrixBase.inverse_LU "sympy.matrices.matrixbase.MatrixBase.inverse_LU"),
    [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Calculates the inverse using LU decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"),
    [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"),
    [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"),
    [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"),
    [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: Calculates the inverse using QR decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"),
    [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"),
    [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"),
    [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"),
    [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: Return a matrix filled by the given matrices which are listed in order of appearance
    from left to right, top to bottom as they first appear in the matrix. They must
    fill the matrix completely.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Check if matrix M is an antisymmetric matrix, that is, M is a square matrix
    with all M[i, j] == -M[j, i].
  prefs: []
  type: TYPE_NORMAL
- en: When `simplify=True` (default), the sum M[i, j] + M[j, i] is simplified before
    testing to see if it is zero. By default, the SymPy simplify function is used.
    To use a custom function set simplify to a function that accepts a single argument
    which returns a simplified expression. To skip simplification, set simplify to
    False but note that although this will be faster, it may induce false negatives.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'Simplification of matrix elements is done by default so even though two elements
    which should be equal and opposite would not pass an equality test, the matrix
    is still reported as anti-symmetric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'If `simplify=False` is used for the case when a Matrix is already simplified,
    this will speed things up. Here, we see that without simplification the matrix
    does not appear anti-symmetric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'But if the matrix were already expanded, then it would appear anti-symmetric
    and simplification in the is_anti_symmetric routine is not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Check if matrix is diagonal, that is matrix in which the entries outside the
    main diagonal are all zero.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_lower`](#sympy.matrices.matrixbase.MatrixBase.is_lower "sympy.matrices.matrixbase.MatrixBase.is_lower"),
    [`is_upper`](#sympy.matrices.matrixbase.MatrixBase.is_upper "sympy.matrices.matrixbase.MatrixBase.is_upper"),
    [`sympy.matrices.matrixbase.MatrixBase.is_diagonalizable`](#sympy.matrices.matrixbase.MatrixBase.is_diagonalizable
    "sympy.matrices.matrixbase.MatrixBase.is_diagonalizable"), [`diagonalize`](#sympy.matrices.matrixbase.MatrixBase.diagonalize
    "sympy.matrices.matrixbase.MatrixBase.diagonalize")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Returns `True` if a matrix is diagonalizable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**reals_only** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, it tests whether the matrix can be diagonalized to contain only real
    numbers on the diagonal.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `False`, it tests whether the matrix can be diagonalized at all, even with
    numbers that may not be real.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Example of a diagonalizable matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'Example of a non-diagonalizable matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Example of a matrix that is diagonalized in terms of non-real entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.is_diagonal`](#sympy.matrices.matrixbase.MatrixBase.is_diagonal
    "sympy.matrices.matrixbase.MatrixBase.is_diagonal"), [`diagonalize`](#sympy.matrices.matrixbase.MatrixBase.diagonalize
    "sympy.matrices.matrixbase.MatrixBase.diagonalize")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Returns \(True\) if the matrix is in echelon form. That is, all rows of zeros
    are at the bottom, and below each leading non-zero in a row are exclusively zeros.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Checks if the matrix is Hermitian.
  prefs: []
  type: TYPE_NORMAL
- en: In a Hermitian matrix element i,j is the complex conjugate of element j,i.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Finds out the definiteness of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'A square real matrix \(A\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive definite matrix if \(x^T A x > 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive semidefinite matrix if \(x^T A x \geq 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative definite matrix if \(x^T A x < 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative semidefinite matrix if \(x^T A x \leq 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indefinite matrix if there exists non-zero real vectors \(x, y\) with \(x^T
    A x > 0 > y^T A y\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A square complex matrix \(A\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive definite matrix if \(\text{re}(x^H A x) > 0\) for all non-zero complex
    vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive semidefinite matrix if \(\text{re}(x^H A x) \geq 0\) for all non-zero
    complex vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative definite matrix if \(\text{re}(x^H A x) < 0\) for all non-zero complex
    vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative semidefinite matrix if \(\text{re}(x^H A x) \leq 0\) for all non-zero
    complex vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indefinite matrix if there exists non-zero complex vectors \(x, y\) with
    \(\text{re}(x^H A x) > 0 > \text{re}(y^H A y)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matrix need not be symmetric or hermitian to be positive definite.
  prefs: []
  type: TYPE_NORMAL
- en: A real non-symmetric matrix is positive definite if and only if \(\frac{A +
    A^T}{2}\) is positive definite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complex non-hermitian matrix is positive definite if and only if \(\frac{A
    + A^H}{2}\) is positive definite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And this extension can apply for all the definitions above.
  prefs: []
  type: TYPE_NORMAL
- en: However, for complex cases, you can restrict the definition of \(\text{re}(x^H
    A x) > 0\) to \(x^H A x > 0\) and require the matrix to be hermitian. But we do
    not present this restriction for computation because you can check `M.is_hermitian`
    independently with this and use the same procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of symmetric positive definite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/fe5156c3aec16ecd262cdc3ed2267d84/matrices-1.png),
    [`hires.png`](../../_downloads/e3193d497eaf6c8abcce4958dd4a5a24/matrices-1.hires.png),
    [`pdf`](../../_downloads/dac00acb10450bde21ecfc4fd9c34817/matrices-1.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-1.png](../Images/4916da1c0432aff2f10026acd2887d36.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric positive semidefinite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/0d8e9f24fa36bf1b5ba81e15343cc16a/matrices-2.png),
    [`hires.png`](../../_downloads/730039e192f59c01d9e2f23c5d862e93/matrices-2.hires.png),
    [`pdf`](../../_downloads/704bfe351153d402a4a0a831ece25675/matrices-2.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-2.png](../Images/eace542660423182e10c6bddd5c97383.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric negative definite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/3d9c323c5b29e6c0f5213d15bc6d4340/matrices-3.png),
    [`hires.png`](../../_downloads/7eab27e4b46ecd5ee93685f96489c057/matrices-3.hires.png),
    [`pdf`](../../_downloads/e0563f4c3c89c72192ce76efd2e6fe6b/matrices-3.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-3.png](../Images/a2e8d23abdcb48721361ad1d1e406dba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric indefinite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/35a507f5bfd4c8404dc5c74a12c6cf40/matrices-4.png),
    [`hires.png`](../../_downloads/67c6b9a24ce06a94da0bcf2ee46feb48/matrices-4.hires.png),
    [`pdf`](../../_downloads/2667a5fcc739d282a7512f6b7b39071a/matrices-4.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-4.png](../Images/0c3951d2c3aa78848405c4aa739f7f33.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of non-symmetric positive definite matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/4a265f8dd3b8c7410c3383172e12a130/matrices-5.png),
    [`hires.png`](../../_downloads/8bcf06e266cbe0b4c7b278c72b30131b/matrices-5.hires.png),
    [`pdf`](../../_downloads/e51f495094ca971c2da007d95d7c6aff/matrices-5.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-5.png](../Images/573fb2b43a50a3a209b2853a0d0f457f.png)'
  prefs: []
  type: TYPE_IMG
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Although some people trivialize the definition of positive definite matrices
    only for symmetric or hermitian matrices, this restriction is not correct because
    it does not classify all instances of positive definite matrices from the definition
    \(x^T A x > 0\) or \(\text{re}(x^H A x) > 0\).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, `Matrix([[1, 2], [-2, 1]])` presented in the example above is
    an example of real positive definite matrix that is not symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: However, since the following formula holds true;
  prefs: []
  type: TYPE_NORMAL
- en: \[\text{re}(x^H A x) > 0 \iff \text{re}(x^H \frac{A + A^H}{2} x) > 0\]
  prefs: []
  type: TYPE_NORMAL
- en: We can classify all positive definite matrices that may or may not be symmetric
    or hermitian by transforming the matrix to \(\frac{A + A^T}{2}\) or \(\frac{A
    + A^H}{2}\) (which is guaranteed to be always real symmetric or complex hermitian)
    and we can defer most of the studies to symmetric or hermitian positive definite
    matrices.
  prefs: []
  type: TYPE_NORMAL
- en: But it is a different problem for the existence of Cholesky decomposition. Because
    even though a non symmetric or a non hermitian matrix can be positive definite,
    Cholesky or LDL decomposition does not exist because the decompositions require
    the matrix to be symmetric or hermitian.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R617](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues](https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R618](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PositiveDefiniteMatrix.html](https://mathworld.wolfram.com/PositiveDefiniteMatrix.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R619](#id12)]'
  prefs: []
  type: TYPE_NORMAL
- en: Johnson, C. R. “Positive Definite Matrices.” Amer. Math. Monthly 77, 259-264
    1970.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Check if matrix is a lower triangular matrix. True can be returned even if the
    matrix is not square.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_upper`](#sympy.matrices.matrixbase.MatrixBase.is_upper "sympy.matrices.matrixbase.MatrixBase.is_upper"),
    [`is_diagonal`](#sympy.matrices.matrixbase.MatrixBase.is_diagonal "sympy.matrices.matrixbase.MatrixBase.is_diagonal"),
    [`is_lower_hessenberg`](#sympy.matrices.matrixbase.MatrixBase.is_lower_hessenberg
    "sympy.matrices.matrixbase.MatrixBase.is_lower_hessenberg")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Checks if the matrix is in the lower-Hessenberg form.
  prefs: []
  type: TYPE_NORMAL
- en: The lower hessenberg matrix has zero entries above the first superdiagonal.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_upper_hessenberg`](#sympy.matrices.matrixbase.MatrixBase.is_upper_hessenberg
    "sympy.matrices.matrixbase.MatrixBase.is_upper_hessenberg"), [`is_lower`](#sympy.matrices.matrixbase.MatrixBase.is_lower
    "sympy.matrices.matrixbase.MatrixBase.is_lower")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Finds out the definiteness of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'A square real matrix \(A\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive definite matrix if \(x^T A x > 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive semidefinite matrix if \(x^T A x \geq 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative definite matrix if \(x^T A x < 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative semidefinite matrix if \(x^T A x \leq 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indefinite matrix if there exists non-zero real vectors \(x, y\) with \(x^T
    A x > 0 > y^T A y\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A square complex matrix \(A\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive definite matrix if \(\text{re}(x^H A x) > 0\) for all non-zero complex
    vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive semidefinite matrix if \(\text{re}(x^H A x) \geq 0\) for all non-zero
    complex vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative definite matrix if \(\text{re}(x^H A x) < 0\) for all non-zero complex
    vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative semidefinite matrix if \(\text{re}(x^H A x) \leq 0\) for all non-zero
    complex vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indefinite matrix if there exists non-zero complex vectors \(x, y\) with
    \(\text{re}(x^H A x) > 0 > \text{re}(y^H A y)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matrix need not be symmetric or hermitian to be positive definite.
  prefs: []
  type: TYPE_NORMAL
- en: A real non-symmetric matrix is positive definite if and only if \(\frac{A +
    A^T}{2}\) is positive definite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complex non-hermitian matrix is positive definite if and only if \(\frac{A
    + A^H}{2}\) is positive definite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And this extension can apply for all the definitions above.
  prefs: []
  type: TYPE_NORMAL
- en: However, for complex cases, you can restrict the definition of \(\text{re}(x^H
    A x) > 0\) to \(x^H A x > 0\) and require the matrix to be hermitian. But we do
    not present this restriction for computation because you can check `M.is_hermitian`
    independently with this and use the same procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of symmetric positive definite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/132de99a13621a85ce57f12e7c04ed8e/matrices-6.png),
    [`hires.png`](../../_downloads/a2eb0f47e21015de38f03325bc45d081/matrices-6.hires.png),
    [`pdf`](../../_downloads/7d4a2d083d96719b05ab2f759c57874a/matrices-6.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-6.png](../Images/e3e37bc482ba649b41eaa312a2ca73bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric positive semidefinite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/14ee938ea3b9e6af5895013e42d338ce/matrices-7.png),
    [`hires.png`](../../_downloads/e2e6cafac8b61828e6a1912c3c55dd0c/matrices-7.hires.png),
    [`pdf`](../../_downloads/d3453595eb36f834c2ad86d18546535c/matrices-7.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-7.png](../Images/f1c7f91183deb00fff6155ccca67f992.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric negative definite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/347ab36cb1c742d31da5ef1f8a907628/matrices-8.png),
    [`hires.png`](../../_downloads/919dab888d297c58417045d3a17721b1/matrices-8.hires.png),
    [`pdf`](../../_downloads/39dc203c3bf6e7485368c7a401448a6f/matrices-8.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-8.png](../Images/ea7ac06d6d54ce5f0cc5dd9d35f55fe4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric indefinite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/9c4403b24b7e7ac8a78acf73bc276a73/matrices-9.png),
    [`hires.png`](../../_downloads/c7985b2873decf2d383070ffcf33d531/matrices-9.hires.png),
    [`pdf`](../../_downloads/c1adee8d5f4e9aedd715240ee2abc6e5/matrices-9.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-9.png](../Images/c2ce2cbce3b0f2c463386a3f9d96c979.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of non-symmetric positive definite matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/3a5dd7bfe62a7142115c721b3d2532b1/matrices-10.png),
    [`hires.png`](../../_downloads/299d8f654b66b02a5d111bcf88c758bb/matrices-10.hires.png),
    [`pdf`](../../_downloads/0130acc9674ca6615e762dac32f6f525/matrices-10.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-10.png](../Images/89e881190be3747982da2c7dd4548bc4.png)'
  prefs: []
  type: TYPE_IMG
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Although some people trivialize the definition of positive definite matrices
    only for symmetric or hermitian matrices, this restriction is not correct because
    it does not classify all instances of positive definite matrices from the definition
    \(x^T A x > 0\) or \(\text{re}(x^H A x) > 0\).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, `Matrix([[1, 2], [-2, 1]])` presented in the example above is
    an example of real positive definite matrix that is not symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: However, since the following formula holds true;
  prefs: []
  type: TYPE_NORMAL
- en: \[\text{re}(x^H A x) > 0 \iff \text{re}(x^H \frac{A + A^H}{2} x) > 0\]
  prefs: []
  type: TYPE_NORMAL
- en: We can classify all positive definite matrices that may or may not be symmetric
    or hermitian by transforming the matrix to \(\frac{A + A^T}{2}\) or \(\frac{A
    + A^H}{2}\) (which is guaranteed to be always real symmetric or complex hermitian)
    and we can defer most of the studies to symmetric or hermitian positive definite
    matrices.
  prefs: []
  type: TYPE_NORMAL
- en: But it is a different problem for the existence of Cholesky decomposition. Because
    even though a non symmetric or a non hermitian matrix can be positive definite,
    Cholesky or LDL decomposition does not exist because the decompositions require
    the matrix to be symmetric or hermitian.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R620](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues](https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R621](#id14)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PositiveDefiniteMatrix.html](https://mathworld.wolfram.com/PositiveDefiniteMatrix.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R622](#id15)]'
  prefs: []
  type: TYPE_NORMAL
- en: Johnson, C. R. “Positive Definite Matrices.” Amer. Math. Monthly 77, 259-264
    1970.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Finds out the definiteness of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'A square real matrix \(A\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive definite matrix if \(x^T A x > 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive semidefinite matrix if \(x^T A x \geq 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative definite matrix if \(x^T A x < 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative semidefinite matrix if \(x^T A x \leq 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indefinite matrix if there exists non-zero real vectors \(x, y\) with \(x^T
    A x > 0 > y^T A y\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A square complex matrix \(A\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive definite matrix if \(\text{re}(x^H A x) > 0\) for all non-zero complex
    vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive semidefinite matrix if \(\text{re}(x^H A x) \geq 0\) for all non-zero
    complex vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative definite matrix if \(\text{re}(x^H A x) < 0\) for all non-zero complex
    vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative semidefinite matrix if \(\text{re}(x^H A x) \leq 0\) for all non-zero
    complex vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indefinite matrix if there exists non-zero complex vectors \(x, y\) with
    \(\text{re}(x^H A x) > 0 > \text{re}(y^H A y)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matrix need not be symmetric or hermitian to be positive definite.
  prefs: []
  type: TYPE_NORMAL
- en: A real non-symmetric matrix is positive definite if and only if \(\frac{A +
    A^T}{2}\) is positive definite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complex non-hermitian matrix is positive definite if and only if \(\frac{A
    + A^H}{2}\) is positive definite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And this extension can apply for all the definitions above.
  prefs: []
  type: TYPE_NORMAL
- en: However, for complex cases, you can restrict the definition of \(\text{re}(x^H
    A x) > 0\) to \(x^H A x > 0\) and require the matrix to be hermitian. But we do
    not present this restriction for computation because you can check `M.is_hermitian`
    independently with this and use the same procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of symmetric positive definite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/7789b56ac7f1ecb8f132831353486f26/matrices-11.png),
    [`hires.png`](../../_downloads/bd32fb3bd291f29fd3137fcce0d15fba/matrices-11.hires.png),
    [`pdf`](../../_downloads/a892d8f10080acfce9914123b164dd0e/matrices-11.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-11.png](../Images/f0b00383f3e3821a088dd7f854a9d51a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric positive semidefinite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/6d56e28a06b250f7ba102de07fed6d6f/matrices-12.png),
    [`hires.png`](../../_downloads/ed888e4265c5faf635cbe40c22e16539/matrices-12.hires.png),
    [`pdf`](../../_downloads/83ec70596dcaacc88e256e7679fafcee/matrices-12.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-12.png](../Images/cd89d1a5a769dd84ee9321b2e1141d40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric negative definite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/dbd9a90e8e71af21e1e35032242095d3/matrices-13.png),
    [`hires.png`](../../_downloads/fc93659fba99871dd8fd641221131ce9/matrices-13.hires.png),
    [`pdf`](../../_downloads/5b83bd080155a6f59e2eeb633bda5ab4/matrices-13.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-13.png](../Images/f7cce89123ed5036039773d1cae4e8c7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric indefinite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/251852deca26bc9cec31a1c7865e5c72/matrices-14.png),
    [`hires.png`](../../_downloads/cca6bd30da9f73edc2d5a1f91c3b5655/matrices-14.hires.png),
    [`pdf`](../../_downloads/d1eadb36634e8e0276f3d1752e83893e/matrices-14.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-14.png](../Images/3a5275c6f56ee964a0372f9939c9921b.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of non-symmetric positive definite matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/4cc3043ea26261353c303c0fcd504cfd/matrices-15.png),
    [`hires.png`](../../_downloads/77d479f1f001a25cb32034b27787a123/matrices-15.hires.png),
    [`pdf`](../../_downloads/8c3e8789c867600d80b2cce11272d81e/matrices-15.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-15.png](../Images/bf9e1cf9cde16bc5ad36d1b8de2c49dc.png)'
  prefs: []
  type: TYPE_IMG
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Although some people trivialize the definition of positive definite matrices
    only for symmetric or hermitian matrices, this restriction is not correct because
    it does not classify all instances of positive definite matrices from the definition
    \(x^T A x > 0\) or \(\text{re}(x^H A x) > 0\).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, `Matrix([[1, 2], [-2, 1]])` presented in the example above is
    an example of real positive definite matrix that is not symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: However, since the following formula holds true;
  prefs: []
  type: TYPE_NORMAL
- en: \[\text{re}(x^H A x) > 0 \iff \text{re}(x^H \frac{A + A^H}{2} x) > 0\]
  prefs: []
  type: TYPE_NORMAL
- en: We can classify all positive definite matrices that may or may not be symmetric
    or hermitian by transforming the matrix to \(\frac{A + A^T}{2}\) or \(\frac{A
    + A^H}{2}\) (which is guaranteed to be always real symmetric or complex hermitian)
    and we can defer most of the studies to symmetric or hermitian positive definite
    matrices.
  prefs: []
  type: TYPE_NORMAL
- en: But it is a different problem for the existence of Cholesky decomposition. Because
    even though a non symmetric or a non hermitian matrix can be positive definite,
    Cholesky or LDL decomposition does not exist because the decompositions require
    the matrix to be symmetric or hermitian.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R623](#id16)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues](https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R624](#id17)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PositiveDefiniteMatrix.html](https://mathworld.wolfram.com/PositiveDefiniteMatrix.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R625](#id18)]'
  prefs: []
  type: TYPE_NORMAL
- en: Johnson, C. R. “Positive Definite Matrices.” Amer. Math. Monthly 77, 259-264
    1970.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: Checks if a matrix is nilpotent.
  prefs: []
  type: TYPE_NORMAL
- en: A matrix B is nilpotent if for some integer k, B**k is a zero matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Finds out the definiteness of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'A square real matrix \(A\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive definite matrix if \(x^T A x > 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive semidefinite matrix if \(x^T A x \geq 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative definite matrix if \(x^T A x < 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative semidefinite matrix if \(x^T A x \leq 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indefinite matrix if there exists non-zero real vectors \(x, y\) with \(x^T
    A x > 0 > y^T A y\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A square complex matrix \(A\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive definite matrix if \(\text{re}(x^H A x) > 0\) for all non-zero complex
    vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive semidefinite matrix if \(\text{re}(x^H A x) \geq 0\) for all non-zero
    complex vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative definite matrix if \(\text{re}(x^H A x) < 0\) for all non-zero complex
    vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative semidefinite matrix if \(\text{re}(x^H A x) \leq 0\) for all non-zero
    complex vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indefinite matrix if there exists non-zero complex vectors \(x, y\) with
    \(\text{re}(x^H A x) > 0 > \text{re}(y^H A y)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matrix need not be symmetric or hermitian to be positive definite.
  prefs: []
  type: TYPE_NORMAL
- en: A real non-symmetric matrix is positive definite if and only if \(\frac{A +
    A^T}{2}\) is positive definite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complex non-hermitian matrix is positive definite if and only if \(\frac{A
    + A^H}{2}\) is positive definite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And this extension can apply for all the definitions above.
  prefs: []
  type: TYPE_NORMAL
- en: However, for complex cases, you can restrict the definition of \(\text{re}(x^H
    A x) > 0\) to \(x^H A x > 0\) and require the matrix to be hermitian. But we do
    not present this restriction for computation because you can check `M.is_hermitian`
    independently with this and use the same procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of symmetric positive definite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/0dc2c97c9c4fdc58b568a8a82eecead9/matrices-16.png),
    [`hires.png`](../../_downloads/361100ec1d7f7c1e6d509ce98456c903/matrices-16.hires.png),
    [`pdf`](../../_downloads/a11367bb58b03bf09a75c9657b4e223a/matrices-16.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-16.png](../Images/8cff7b3e21a09b5d944ae915f9f2536c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric positive semidefinite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/5df3cd64357fb04b6b8af3d537bbeea6/matrices-17.png),
    [`hires.png`](../../_downloads/88578b4906705f857b924f96cb792ebf/matrices-17.hires.png),
    [`pdf`](../../_downloads/3cd14c510b41514f1496a3155ea8cf2d/matrices-17.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-17.png](../Images/6fb35371b52ed5ec21e66b267775fe48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric negative definite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/6edcb9da8f09d47584e8ca5d5958a6f2/matrices-18.png),
    [`hires.png`](../../_downloads/ad9035d1270a7bc56250873e2d009d7d/matrices-18.hires.png),
    [`pdf`](../../_downloads/464f047ba3ef7f04429a4eb163a6a2de/matrices-18.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-18.png](../Images/cf5858762e3eca3b88980be57e718a77.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric indefinite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/810de00eed457e63dc8a9c10a5a70437/matrices-19.png),
    [`hires.png`](../../_downloads/e5039d4c4155d188b38e3ea1be7a5f16/matrices-19.hires.png),
    [`pdf`](../../_downloads/7eed1bf07a4dacbb97d209dac2614e9a/matrices-19.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-19.png](../Images/25aa285909f375aba65a1f48b24f4b85.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of non-symmetric positive definite matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/d62811c8b8bdef23f805382bf088c1d8/matrices-20.png),
    [`hires.png`](../../_downloads/2b230450d75dde35aa23b644a0a50913/matrices-20.hires.png),
    [`pdf`](../../_downloads/a6ba697f4fd41244d4a03ae13c871d77/matrices-20.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-20.png](../Images/f98ccfbaa53b4e480c40018ef6d6fe32.png)'
  prefs: []
  type: TYPE_IMG
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Although some people trivialize the definition of positive definite matrices
    only for symmetric or hermitian matrices, this restriction is not correct because
    it does not classify all instances of positive definite matrices from the definition
    \(x^T A x > 0\) or \(\text{re}(x^H A x) > 0\).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, `Matrix([[1, 2], [-2, 1]])` presented in the example above is
    an example of real positive definite matrix that is not symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: However, since the following formula holds true;
  prefs: []
  type: TYPE_NORMAL
- en: \[\text{re}(x^H A x) > 0 \iff \text{re}(x^H \frac{A + A^H}{2} x) > 0\]
  prefs: []
  type: TYPE_NORMAL
- en: We can classify all positive definite matrices that may or may not be symmetric
    or hermitian by transforming the matrix to \(\frac{A + A^T}{2}\) or \(\frac{A
    + A^H}{2}\) (which is guaranteed to be always real symmetric or complex hermitian)
    and we can defer most of the studies to symmetric or hermitian positive definite
    matrices.
  prefs: []
  type: TYPE_NORMAL
- en: But it is a different problem for the existence of Cholesky decomposition. Because
    even though a non symmetric or a non hermitian matrix can be positive definite,
    Cholesky or LDL decomposition does not exist because the decompositions require
    the matrix to be symmetric or hermitian.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R626](#id19)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues](https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R627](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PositiveDefiniteMatrix.html](https://mathworld.wolfram.com/PositiveDefiniteMatrix.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R628](#id21)]'
  prefs: []
  type: TYPE_NORMAL
- en: Johnson, C. R. “Positive Definite Matrices.” Amer. Math. Monthly 77, 259-264
    1970.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Finds out the definiteness of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'A square real matrix \(A\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive definite matrix if \(x^T A x > 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive semidefinite matrix if \(x^T A x \geq 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative definite matrix if \(x^T A x < 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative semidefinite matrix if \(x^T A x \leq 0\) for all non-zero real vectors
    \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indefinite matrix if there exists non-zero real vectors \(x, y\) with \(x^T
    A x > 0 > y^T A y\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A square complex matrix \(A\) is:'
  prefs: []
  type: TYPE_NORMAL
- en: A positive definite matrix if \(\text{re}(x^H A x) > 0\) for all non-zero complex
    vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A positive semidefinite matrix if \(\text{re}(x^H A x) \geq 0\) for all non-zero
    complex vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative definite matrix if \(\text{re}(x^H A x) < 0\) for all non-zero complex
    vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A negative semidefinite matrix if \(\text{re}(x^H A x) \leq 0\) for all non-zero
    complex vectors \(x\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An indefinite matrix if there exists non-zero complex vectors \(x, y\) with
    \(\text{re}(x^H A x) > 0 > \text{re}(y^H A y)\).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A matrix need not be symmetric or hermitian to be positive definite.
  prefs: []
  type: TYPE_NORMAL
- en: A real non-symmetric matrix is positive definite if and only if \(\frac{A +
    A^T}{2}\) is positive definite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A complex non-hermitian matrix is positive definite if and only if \(\frac{A
    + A^H}{2}\) is positive definite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And this extension can apply for all the definitions above.
  prefs: []
  type: TYPE_NORMAL
- en: However, for complex cases, you can restrict the definition of \(\text{re}(x^H
    A x) > 0\) to \(x^H A x > 0\) and require the matrix to be hermitian. But we do
    not present this restriction for computation because you can check `M.is_hermitian`
    independently with this and use the same procedure.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of symmetric positive definite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/a54e5f627e2fbeb748a3b6654ee84418/matrices-21.png),
    [`hires.png`](../../_downloads/dbe9baa7d9333de30fb4cea03b67ec3d/matrices-21.hires.png),
    [`pdf`](../../_downloads/81a780d815116a5eb737d2d484c44444/matrices-21.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-21.png](../Images/ea638cc2f8cc1baa48ca62fd12aa13ba.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric positive semidefinite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/a9eea951634fc73dd49d645042a057b8/matrices-22.png),
    [`hires.png`](../../_downloads/aa5c0855ea65d398b77ff5e7a3e00ed3/matrices-22.hires.png),
    [`pdf`](../../_downloads/2608cc95ac952e335ca0ce8cea458c1b/matrices-22.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-22.png](../Images/aff0a4a98884800ef8d2b11ceb564495.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric negative definite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/a2678f0a9d385fd10516366388c9905c/matrices-23.png),
    [`hires.png`](../../_downloads/c51edc0a53a63ae2c958e1c0f4e1d442/matrices-23.hires.png),
    [`pdf`](../../_downloads/eb990a3106294a2a2f898aea0b429ab7/matrices-23.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-23.png](../Images/a2e58072329e79632c886ffb77d128ae.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An example of symmetric indefinite matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/13c22e4deb4a471b56ed749423dc83e1/matrices-24.png),
    [`hires.png`](../../_downloads/4b5e4b16bd34ce73ca3612c694f2a681/matrices-24.hires.png),
    [`pdf`](../../_downloads/16c046e4f150f3aca5fb6bd438b952ce/matrices-24.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-24.png](../Images/e621f10a0ccbac1b5a42c926d26b68c9.png)'
  prefs: []
  type: TYPE_IMG
- en: An example of non-symmetric positive definite matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/6646c86340831efe70e679a2146a3502/matrices-25.png),
    [`hires.png`](../../_downloads/50aad3e85d81cacfd247df6c24f46bdd/matrices-25.hires.png),
    [`pdf`](../../_downloads/16f8dba9abaa041f16c4636d6e41a0ac/matrices-25.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/matrices-25.png](../Images/82d5a5d9d3cd69e45727541b041ba778.png)'
  prefs: []
  type: TYPE_IMG
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Although some people trivialize the definition of positive definite matrices
    only for symmetric or hermitian matrices, this restriction is not correct because
    it does not classify all instances of positive definite matrices from the definition
    \(x^T A x > 0\) or \(\text{re}(x^H A x) > 0\).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, `Matrix([[1, 2], [-2, 1]])` presented in the example above is
    an example of real positive definite matrix that is not symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: However, since the following formula holds true;
  prefs: []
  type: TYPE_NORMAL
- en: \[\text{re}(x^H A x) > 0 \iff \text{re}(x^H \frac{A + A^H}{2} x) > 0\]
  prefs: []
  type: TYPE_NORMAL
- en: We can classify all positive definite matrices that may or may not be symmetric
    or hermitian by transforming the matrix to \(\frac{A + A^T}{2}\) or \(\frac{A
    + A^H}{2}\) (which is guaranteed to be always real symmetric or complex hermitian)
    and we can defer most of the studies to symmetric or hermitian positive definite
    matrices.
  prefs: []
  type: TYPE_NORMAL
- en: But it is a different problem for the existence of Cholesky decomposition. Because
    even though a non symmetric or a non hermitian matrix can be positive definite,
    Cholesky or LDL decomposition does not exist because the decompositions require
    the matrix to be symmetric or hermitian.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R629](#id22)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues](https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R630](#id23)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/PositiveDefiniteMatrix.html](https://mathworld.wolfram.com/PositiveDefiniteMatrix.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R631](#id24)]'
  prefs: []
  type: TYPE_NORMAL
- en: Johnson, C. R. “Positive Definite Matrices.” Amer. Math. Monthly 77, 259-264
    1970.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Checks if a matrix is square.
  prefs: []
  type: TYPE_NORMAL
- en: A matrix is square if the number of rows equals the number of columns. The empty
    matrix is square by definition, since the number of rows and the number of columns
    are both zero.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Tests if the matrix is row strongly diagonally dominant.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A \(n, n\) matrix \(A\) is row strongly diagonally dominant if
  prefs: []
  type: TYPE_NORMAL
- en: \[\left|A_{i, i}\right| > \sum_{j = 0, j \neq i}^{n-1} \left|A_{i, j}\right|
    \quad {\text{for all }} i \in \{ 0, ..., n-1 \}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: If you want to test whether a matrix is column diagonally dominant, you can
    apply the test after transposing the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Checks if any elements contain Symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: Check if matrix is symmetric matrix, that is square matrix and is equal to its
    transpose.
  prefs: []
  type: TYPE_NORMAL
- en: By default, simplifications occur before testing symmetry. They can be skipped
    using ‘simplify=False’; while speeding things a bit, this may however induce false
    negatives.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: If the matrix is already simplified, you may speed-up is_symmetric() test by
    using ‘simplify=False’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Check if matrix is an upper triangular matrix. True can be returned even if
    the matrix is not square.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_lower`](#sympy.matrices.matrixbase.MatrixBase.is_lower "sympy.matrices.matrixbase.MatrixBase.is_lower"),
    [`is_diagonal`](#sympy.matrices.matrixbase.MatrixBase.is_diagonal "sympy.matrices.matrixbase.MatrixBase.is_diagonal"),
    [`is_upper_hessenberg`](#sympy.matrices.matrixbase.MatrixBase.is_upper_hessenberg
    "sympy.matrices.matrixbase.MatrixBase.is_upper_hessenberg")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: Checks if the matrix is the upper-Hessenberg form.
  prefs: []
  type: TYPE_NORMAL
- en: The upper hessenberg matrix has zero entries below the first subdiagonal.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_lower_hessenberg`](#sympy.matrices.matrixbase.MatrixBase.is_lower_hessenberg
    "sympy.matrices.matrixbase.MatrixBase.is_lower_hessenberg"), [`is_upper`](#sympy.matrices.matrixbase.MatrixBase.is_upper
    "sympy.matrices.matrixbase.MatrixBase.is_upper")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: Tests if the matrix is row weakly diagonally dominant.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A \(n, n\) matrix \(A\) is row weakly diagonally dominant if
  prefs: []
  type: TYPE_NORMAL
- en: \[\left|A_{i, i}\right| \ge \sum_{j = 0, j \neq i}^{n-1} \left|A_{i, j}\right|
    \quad {\text{for all }} i \in \{ 0, ..., n-1 \}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: If you want to test whether a matrix is column diagonally dominant, you can
    apply the test after transposing the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: Checks if a matrix is a zero matrix.
  prefs: []
  type: TYPE_NORMAL
- en: A matrix is zero if every element is zero. A matrix need not be square to be
    considered zero. The empty matrix is zero by the principle of vacuous truth. For
    a matrix that may or may not be zero (e.g. contains a symbol), this will be None
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: Iterate over indices and values of nonzero items.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`iter_values`](#sympy.matrices.matrixbase.MatrixBase.iter_values "sympy.matrices.matrixbase.MatrixBase.iter_values"),
    [`todok`](#sympy.matrices.matrixbase.MatrixBase.todok "sympy.matrices.matrixbase.MatrixBase.todok")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: Iterate over non-zero values of self.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`values`](#sympy.matrices.matrixbase.MatrixBase.values "sympy.matrices.matrixbase.MatrixBase.values")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: Calculates the Jacobian matrix (derivative of a vector-valued function).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**``self``** : vector of expressions representing functions f_i(x_1, …, x_n).'
  prefs: []
  type: TYPE_NORMAL
- en: '**X** : set of x_i’s in order, it can be a list or a Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '**Both ``self`` and X can be a row or a column matrix in any order**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(i.e., jacobian() should always work).**'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`hessian`](#sympy.matrices.dense.hessian "sympy.matrices.dense.hessian"),
    [`wronskian`](#sympy.matrices.dense.wronskian "sympy.matrices.dense.wronskian")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: Returns a Jordan block
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**size** : Integer, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the shape of the Jordan block matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**eigenvalue** : Number or Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the value for the main diagonal of the matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The keyword `eigenval` is also specified as an alias of this keyword, but it
    is not recommended to use.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We may deprecate the alias in later release.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**band** : ‘upper’ or ‘lower’, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the position of the off-diagonal to put \(1\) s on.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**cls** : Matrix, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the matrix class of the output form.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is not specified, the class type where the method is being executed on
    will be returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix
  prefs: []
  type: TYPE_NORMAL
- en: A Jordan block matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If insufficient arguments are given for matrix size specification, or no eigenvalue
    is given.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a default Jordan block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating an alternative Jordan block matrix where \(1\) is on lower off-diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: Creating a Jordan block with keyword arguments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R632](#id25)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Jordan_matrix](https://en.wikipedia.org/wiki/Jordan_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: Return \((P, J)\) where \(J\) is a Jordan block matrix and \(P\) is a matrix
    such that \(M = P J P^{-1}\)
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**calc_transform** : bool'
  prefs: []
  type: TYPE_NORMAL
- en: If `False`, then only \(J\) is returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**chop** : bool'
  prefs: []
  type: TYPE_NORMAL
- en: All matrices are converted to exact types when computing eigenvalues and eigenvectors.
    As a result, there may be approximation errors. If `chop==True`, these errors
    will be truncated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`jordan_block`](#sympy.matrices.matrixbase.MatrixBase.jordan_block "sympy.matrices.matrixbase.MatrixBase.jordan_block")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: Converts a key with potentially mixed types of keys (integer and slice) into
    a tuple of ranges and raises an error if any index is out of `self`’s range.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`key2ij`](#sympy.matrices.matrixbase.MatrixBase.key2ij "sympy.matrices.matrixbase.MatrixBase.key2ij")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: Converts key into canonical form, converting integers or indexable items into
    valid integers for `self`’s range or returning slices unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`key2bounds`](#sympy.matrices.matrixbase.MatrixBase.key2bounds "sympy.matrices.matrixbase.MatrixBase.key2bounds")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: Returns left eigenvectors and eigenvalues.
  prefs: []
  type: TYPE_NORMAL
- en: This function returns the list of triples (eigenval, multiplicity, basis) for
    the left eigenvectors. Options are the same as for eigenvects(), i.e. the `**flags`
    arguments gets passed directly to eigenvects().
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the limit of each element in the matrix. `args` will be passed to
    the `limit` function.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`integrate`](#sympy.matrices.matrixbase.MatrixBase.integrate "sympy.matrices.matrixbase.MatrixBase.integrate"),
    [`diff`](#sympy.matrices.matrixbase.MatrixBase.diff "sympy.matrices.matrixbase.MatrixBase.diff")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: Return the logarithm of a square matrix.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**simplify** : function, bool'
  prefs: []
  type: TYPE_NORMAL
- en: The function to simplify the result with.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Default is `cancel`, which is effective to reduce the expression growing for
    taking reciprocals and inverses for symbolic matrices.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples for positive-definite matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples for non positive-definite matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: Return the elements on and below the kth diagonal of a matrix. If k is not specified
    then simply returns lower-triangular portion of a matrix
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: Solves `Ax = B`, where A is a lower triangular matrix.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`upper_triangular_solve`](#sympy.matrices.matrixbase.MatrixBase.upper_triangular_solve
    "sympy.matrices.matrixbase.MatrixBase.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve
    "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve
    "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve
    "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve
    "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve
    "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve
    "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve
    "sympy.matrices.matrixbase.MatrixBase.cramer_solve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Return the (i,j) minor of `M`. That is, return the determinant of the matrix
    obtained by deleting the \(i`th row and `j`th column from ``M`\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i, j** : int'
  prefs: []
  type: TYPE_NORMAL
- en: The row and column to exclude to obtain the submatrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**method** : string, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Method to use to find the determinant of the submatrix, can be “bareiss”, “berkowitz”,
    “bird”, “laplace” or “lu”.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minor_submatrix`](#sympy.matrices.matrixbase.MatrixBase.minor_submatrix "sympy.matrices.matrixbase.MatrixBase.minor_submatrix"),
    [`cofactor`](#sympy.matrices.matrixbase.MatrixBase.cofactor "sympy.matrices.matrixbase.MatrixBase.cofactor"),
    [`det`](#sympy.matrices.matrixbase.MatrixBase.det "sympy.matrices.matrixbase.MatrixBase.det")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: Return the submatrix obtained by removing the \(i`th row and `j`th column from
    ``M`\) (works with Pythonic negative indices).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i, j** : int'
  prefs: []
  type: TYPE_NORMAL
- en: The row and column to exclude to obtain the submatrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minor`](#sympy.matrices.matrixbase.MatrixBase.minor "sympy.matrices.matrixbase.MatrixBase.minor"),
    [`cofactor`](#sympy.matrices.matrixbase.MatrixBase.cofactor "sympy.matrices.matrixbase.MatrixBase.cofactor")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: Same as __mul__() but with optional simplification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dotprodsimp** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies whether intermediate term algebraic simplification is used during
    matrix multiplications to control expression blowup and thus speed up calculation.
    Default is off.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: Return the Hadamard product (elementwise product) of A and B
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.cross`](#sympy.matrices.matrixbase.MatrixBase.cross
    "sympy.matrices.matrixbase.MatrixBase.cross"), [`sympy.matrices.matrixbase.MatrixBase.dot`](#sympy.matrices.matrixbase.MatrixBase.dot
    "sympy.matrices.matrixbase.MatrixBase.dot"), [`multiply`](#sympy.matrices.matrixbase.MatrixBase.multiply
    "sympy.matrices.matrixbase.MatrixBase.multiply")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Apply evalf() to each element of self.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: Return the Norm of a Matrix or Vector.
  prefs: []
  type: TYPE_NORMAL
- en: In the simplest case this is the geometric size of the vector Other norms can
    be specified by the ord parameter
  prefs: []
  type: TYPE_NORMAL
- en: '| ord | norm for matrices | norm for vectors |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| None | Frobenius norm | 2-norm |'
  prefs: []
  type: TYPE_TB
- en: '| ‘fro’ | Frobenius norm |'
  prefs: []
  type: TYPE_TB
- en: does not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| inf | maximum row sum | max(abs(x)) |'
  prefs: []
  type: TYPE_TB
- en: '| -inf | – | min(abs(x)) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | maximum column sum | as below |'
  prefs: []
  type: TYPE_TB
- en: '| -1 | – | as below |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 2-norm (largest sing. value) | as below |'
  prefs: []
  type: TYPE_TB
- en: '| -2 | smallest singular value | as below |'
  prefs: []
  type: TYPE_TB
- en: '| other |'
  prefs: []
  type: TYPE_TB
- en: does not exist
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| sum(abs(x)**ord)**(1./ord) |'
  prefs: []
  type: TYPE_TB
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`normalized`](#sympy.matrices.matrixbase.MatrixBase.normalized "sympy.matrices.matrixbase.MatrixBase.normalized")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: Return the normalized version of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iszerofunc** : Function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A function to determine whether `self` is a zero vector. The default `_iszero`
    tests to see if each element is exactly zero.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix
  prefs: []
  type: TYPE_NORMAL
- en: Normalized vector form of `self`. It has the same length as a unit vector. However,
    a zero vector will be returned for a vector with norm 0.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ShapeError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the matrix is not in a vector form.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`norm`](#sympy.matrices.matrixbase.MatrixBase.norm "sympy.matrices.matrixbase.MatrixBase.norm")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: Returns list of vectors (Matrix objects) that span nullspace of `M`
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`columnspace`](#sympy.matrices.matrixbase.MatrixBase.columnspace "sympy.matrices.matrixbase.MatrixBase.columnspace"),
    [`rowspace`](#sympy.matrices.matrixbase.MatrixBase.rowspace "sympy.matrices.matrixbase.MatrixBase.rowspace")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: Returns a matrix of ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rows** : rows of the matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '**cols** : cols of the matrix (if None, cols=rows)'
  prefs: []
  type: TYPE_NORMAL
- en: Kwargs
  prefs: []
  type: TYPE_NORMAL
- en: 'cls : class of the returned matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: Apply the Gram-Schmidt orthogonalization procedure to vectors supplied in `vecs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**vecs**'
  prefs: []
  type: TYPE_NORMAL
- en: vectors to be made orthogonal
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**normalize** : bool'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, return an orthonormal basis.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**rankcheck** : bool'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, the computation does not stop when encountering linearly dependent
    vectors.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `False`, it will raise `ValueError` when any zero or linearly dependent vectors
    are found.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: list
  prefs: []
  type: TYPE_NORMAL
- en: List of orthogonal (or orthonormal) basis vectors.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MatrixBase.QRdecomposition`](#sympy.matrices.matrixbase.MatrixBase.QRdecomposition
    "sympy.matrices.matrixbase.MatrixBase.QRdecomposition")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R633](#id26)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: Returns the permanent of a matrix. Unlike determinant, permanent is defined
    for both square and non-square matrices.
  prefs: []
  type: TYPE_NORMAL
- en: For an m x n matrix, with m less than or equal to n, it is given as the sum
    over the permutations s of size less than or equal to m on [1, 2, … n] of the
    product from i = 1 to m of M[i, s[i]]. Taking the transpose will not affect the
    value of the permanent.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of a square matrix, this is the same as the permutation definition
    of the determinant, but it does not take the sign of the permutation into account.
    Computing the permanent with this definition is quite inefficient, so here the
    Ryser formula is used.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R634](#id27)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prof. Frank Ben’s notes: [https://math.berkeley.edu/~bernd/ban275.pdf](https://math.berkeley.edu/~bernd/ban275.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R635](#id28)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wikipedia article on Permanent: [https://en.wikipedia.org/wiki/Permanent_%28mathematics%29](https://en.wikipedia.org/wiki/Permanent_%28mathematics%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R636](#id29)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reference.wolfram.com/language/ref/Permanent.html](https://reference.wolfram.com/language/ref/Permanent.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R637](#id30)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Permanent of a rectangular matrix : [https://arxiv.org/pdf/0904.3251.pdf](https://arxiv.org/pdf/0904.3251.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: Permute the rows or columns of a matrix by the given list of swaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**perm** : Permutation, list, or list of lists'
  prefs: []
  type: TYPE_NORMAL
- en: A representation for the permutation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is `Permutation`, it is used directly with some resizing with respect
    to the matrix size.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is specified as list of lists, (e.g., `[[0, 1], [0, 2]]`), then the permutation
    is formed from applying the product of cycles. The direction how the cyclic product
    is applied is described in below.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is specified as a list, the list should represent an array form of a permutation.
    (e.g., `[1, 2, 0]`) which would would form the swapping function \(0 \mapsto 1,
    1 \mapsto 2, 2\mapsto 0\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**orientation** : ‘rows’, ‘cols’'
  prefs: []
  type: TYPE_NORMAL
- en: A flag to control whether to permute the rows or the columns
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**direction** : ‘forward’, ‘backward’'
  prefs: []
  type: TYPE_NORMAL
- en: A flag to control whether to apply the permutations from the start of the list
    first, or from the back of the list first.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, if the permutation specification is `[[0, 1], [0, 2]]`,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the flag is set to `'forward'`, the cycle would be formed as \(0 \mapsto
    2, 2 \mapsto 1, 1 \mapsto 0\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the flag is set to `'backward'`, the cycle would be formed as \(0 \mapsto
    1, 1 \mapsto 2, 2 \mapsto 0\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If the argument `perm` is not in a form of list of lists, this flag takes no
    effect.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'If a bijective function \(\sigma : \mathbb{N}_0 \rightarrow \mathbb{N}_0\)
    denotes the permutation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the matrix \(A\) is the matrix to permute, represented as a horizontal or
    a vertical stack of vectors:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}A = \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix}
    = \begin{bmatrix} \alpha_0 & \alpha_1 & \cdots & \alpha_{n-1} \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'If the matrix \(B\) is the result, the permutation of matrix rows is defined
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}B := \begin{bmatrix} a_{\sigma(0)} \\ a_{\sigma(1)} \\ \vdots
    \\ a_{\sigma(n-1)} \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'And the permutation of matrix columns is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: \[B := \begin{bmatrix} \alpha_{\sigma(0)} & \alpha_{\sigma(1)} & \cdots & \alpha_{\sigma(n-1)}
    \end{bmatrix}\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Permute the rows of the matrix with the given permutation in reverse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: Permute the rows of the matrix with the given permutation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: Alias for `self.permute(swaps, orientation='cols', direction=direction)`
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`permute`](#sympy.matrices.matrixbase.MatrixBase.permute "sympy.matrices.matrixbase.MatrixBase.permute")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: Alias for `self.permute(swaps, orientation='rows', direction=direction)`
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`permute`](#sympy.matrices.matrixbase.MatrixBase.permute "sympy.matrices.matrixbase.MatrixBase.permute")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: Calculate the Moore-Penrose pseudoinverse of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: The Moore-Penrose pseudoinverse exists and is unique for any matrix. If the
    matrix is invertible, the pseudoinverse is the same as the inverse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**method** : String, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the method for computing the pseudoinverse.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `'RD'`, Rank-Decomposition will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `'ED'`, Diagonalization will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Computing pseudoinverse by rank decomposition :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'Computing pseudoinverse by diagonalization :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"),
    [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve "sympy.matrices.matrixbase.MatrixBase.pinv_solve")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R638](#id31)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse](https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: Solve `Ax = B` using the Moore-Penrose pseudoinverse.
  prefs: []
  type: TYPE_NORMAL
- en: There may be zero, one, or infinite solutions. If one solution exists, it will
    be returned. If infinite solutions exist, one will be returned based on the value
    of arbitrary_matrix. If no solutions exist, the least-squares solution is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**B** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The right hand side of the equation to be solved for. Must have the same number
    of rows as matrix A.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**arbitrary_matrix** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: If the system is underdetermined (e.g. A has more columns than rows), infinite
    solutions are possible, in terms of an arbitrary matrix. This parameter may be
    set to a specific matrix to use for that purpose; if so, it must be the same shape
    as x, with as many rows as matrix A has columns, and as many columns as matrix
    B. If left as None, an appropriate matrix containing dummy symbols in the form
    of `wn_m` will be used, with n and m being row and column position of each symbol.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix that will satisfy `Ax = B`. Will have as many rows as matrix A has
    columns, and as many columns as matrix B.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This may return either exact solutions or least squares solutions. To determine
    which, check `A * A.pinv() * B == B`. It will be True if exact solutions exist,
    and False if only a least-squares solution exists. Be aware that the left hand
    side of that equation may need to be simplified to correctly compare to the right
    hand side.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve
    "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve
    "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve
    "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve
    "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve
    "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve
    "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve
    "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv`](#sympy.matrices.matrixbase.MatrixBase.pinv
    "sympy.matrices.matrixbase.MatrixBase.pinv")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R639](#id32)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse#Obtaining_all_solutions_of_a_linear_system](https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse#Obtaining_all_solutions_of_a_linear_system)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: Return self**exp a scalar or symbol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**method** : multiply, mulsimp, jordan, cayley'
  prefs: []
  type: TYPE_NORMAL
- en: If multiply then it returns exponentiation using recursion. If jordan then Jordan
    form exponentiation will be used. If cayley then the exponentiation is done using
    Cayley-Hamilton theorem. If mulsimp then the exponentiation is done using recursion
    with dotprodsimp. This specifies whether intermediate term algebraic simplification
    is used during naive matrix power to control expression blowup and thus speed
    up calculation. If None, then it heuristically decides which method to use.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: Shows location of non-zero entries for fast shape lookup.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: Return the projection of `self` onto the line containing `v`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: Returns the rank of a matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: Returns a pair of matrices (\(C\), \(F\)) with matching rank such that \(A =
    C F\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iszerofunc** : Function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function used for detecting whether an element can act as a pivot. `lambda
    x: x.is_zero` is used by default.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**simplify** : Bool or Function, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A function used to simplify elements when looking for a pivot. By default SymPy’s
    `simplify` is used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(C, F)** : Matrices'
  prefs: []
  type: TYPE_NORMAL
- en: \(C\) and \(F\) are full-rank matrices with rank as same as \(A\), whose product
    gives \(A\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See Notes for additional mathematical details.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Obtaining \(F\), an RREF of \(A\), is equivalent to creating a product
  prefs: []
  type: TYPE_NORMAL
- en: \[E_n E_{n-1} ... E_1 A = F\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(E_n, E_{n-1}, \dots, E_1\) are the elimination matrices or permutation
    matrices equivalent to each row-reduction step.
  prefs: []
  type: TYPE_NORMAL
- en: 'The inverse of the same product of elimination matrices gives \(C\):'
  prefs: []
  type: TYPE_NORMAL
- en: \[C = \left(E_n E_{n-1} \dots E_1\right)^{-1}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not necessary, however, to actually compute the inverse: the columns
    of \(C\) are those from the original matrix with the same column indices as the
    indices of the pivot columns of \(F\).'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.rref`](#sympy.matrices.matrixbase.MatrixBase.rref
    "sympy.matrices.matrixbase.MatrixBase.rref")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R640](#id33)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Rank_factorization](https://en.wikipedia.org/wiki/Rank_factorization)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R641](#id34)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Piziak, R.; Odell, P. L. (1 June 1999). “Full Rank Factorization of Matrices”.
    Mathematics Magazine. 72 (3): 193\. doi:10.2307/2690882'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: Apply refine to each element of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: Replaces Function F in Matrix entries with Function G.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Reshape the matrix. Total number of elements must remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: Same as __rmul__() but with optional simplification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dotprodsimp** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies whether intermediate term algebraic simplification is used during
    matrix multiplications to control expression blowup and thus speed up calculation.
    Default is off.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: Rotates Matrix by 90 degrees
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**k** : int'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies how many times the matrix is rotated by 90 degrees (clockwise when
    positive, counter-clockwise when negative).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: 'Rotating the matrix clockwise one time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: 'Rotating the matrix anticlockwise two times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: Elementary row selector.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`col`](#sympy.matrices.matrixbase.MatrixBase.col "sympy.matrices.matrixbase.MatrixBase.col"),
    [`row_del`](#sympy.matrices.matrixbase.MatrixBase.row_del "sympy.matrices.matrixbase.MatrixBase.row_del"),
    [`row_join`](#sympy.matrices.matrixbase.MatrixBase.row_join "sympy.matrices.matrixbase.MatrixBase.row_join"),
    [`row_insert`](#sympy.matrices.matrixbase.MatrixBase.row_insert "sympy.matrices.matrixbase.MatrixBase.row_insert")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: Delete the specified row.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: Insert one or more rows at the given row position.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`row`](#sympy.matrices.matrixbase.MatrixBase.row "sympy.matrices.matrixbase.MatrixBase.row"),
    [`col_insert`](#sympy.matrices.matrixbase.MatrixBase.col_insert "sympy.matrices.matrixbase.MatrixBase.col_insert")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: Concatenates two matrices along self’s last and rhs’s first column
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`row`](#sympy.matrices.matrixbase.MatrixBase.row "sympy.matrices.matrixbase.MatrixBase.row"),
    [`col_join`](#sympy.matrices.matrixbase.MatrixBase.col_join "sympy.matrices.matrixbase.MatrixBase.col_join")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Returns a list of vectors that span the row space of `M`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: Return reduced row-echelon form of matrix and indices of pivot vars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**iszerofunc** : Function'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function used for detecting whether an element can act as a pivot. `lambda
    x: x.is_zero` is used by default.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**simplify** : Function'
  prefs: []
  type: TYPE_NORMAL
- en: A function used to simplify elements when looking for a pivot. By default SymPy’s
    `simplify` is used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**pivots** : True or False'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, a tuple containing the row-reduced matrix and a tuple of pivot columns
    is returned. If `False` just the row-reduced matrix is returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**normalize_last** : True or False'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, no pivots are normalized to \(1\) until after all entries above and
    below each pivot are zeroed. This means the row reduction algorithm is fraction
    free until the very last step. If `False`, the naive row reduction procedure is
    used where each pivot is normalized to be \(1\) before row operations are used
    to zero above and below the pivot.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: '`iszerofunc` can correct rounding errors in matrices with float values. In
    the following example, calling `rref()` leads to floating point errors, incorrectly
    row reducing the matrix. `iszerofunc= lambda x: abs(x) < 1e-9` sets sufficiently
    small numbers to zero, avoiding this error.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `normalize_last=True` can provide significant speedup to
    row reduction, especially on matrices with symbols. However, if you depend on
    the form row reduction algorithm leaves entries of the matrix, set `normalize_last=False`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: Return reduced row-echelon form of matrix, matrix showing rhs after reduction
    steps. `rhs` must have the same number of rows as `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: The shape (dimensions) of the matrix as the 2-tuple (rows, cols).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: Apply simplify to each element of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: Returns a Condensed Singular Value decomposition.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A Singular Value decomposition is a decomposition in the form \(A = U \Sigma
    V^H\) where
  prefs: []
  type: TYPE_NORMAL
- en: \(U, V\) are column orthogonal matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(\Sigma\) is a diagonal matrix, where the main diagonal contains singular values
    of matrix A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A column orthogonal matrix satisfies \(\mathbb{I} = U^H U\) while a full orthogonal
    matrix satisfies relation \(\mathbb{I} = U U^H = U^H U\) where \(\mathbb{I}\)
    is an identity matrix with matching dimensions.
  prefs: []
  type: TYPE_NORMAL
- en: For matrices which are not square or are rank-deficient, it is sufficient to
    return a column orthogonal matrix because augmenting them may introduce redundant
    computations. In condensed Singular Value Decomposition we only return column
    orthogonal matrices because of this reason
  prefs: []
  type: TYPE_NORMAL
- en: If you want to augment the results to return a full orthogonal decomposition,
    you should use the following procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Augment the \(U, V\) matrices with columns that are orthogonal to every other
    columns and make it square.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Augment the \(\Sigma\) matrix with zero rows to make it have the same shape
    as the original matrix.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The procedure will be illustrated in the examples section.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'we take a full rank matrix first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: If a matrix if square and full rank both U, V are orthogonal in both directions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: If you want to augment the results to be a full orthogonal decomposition, you
    should augment \(V\) with an another orthogonal column.
  prefs: []
  type: TYPE_NORMAL
- en: You are able to append an arbitrary standard basis that are linearly independent
    to every other columns and you can run the Gram-Schmidt process to make them augmented
    as orthogonal basis.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: Similarly we augment U
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: We add 2 zero columns and one row to S
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: Compute the singular values of a Matrix
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`condition_number`](#sympy.matrices.matrixbase.MatrixBase.condition_number
    "sympy.matrices.matrixbase.MatrixBase.condition_number")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: Solves linear equation where the unique solution exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rhs** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Vector representing the right hand side of the linear equation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**method** : string, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If set to `'GJ'` or `'GE'`, the Gauss-Jordan elimination will be used, which
    is implemented in the routine `gauss_jordan_solve`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If set to `'LU'`, `LUsolve` routine will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If set to `'QR'`, `QRsolve` routine will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If set to `'PINV'`, `pinv_solve` routine will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If set to `'CRAMER'`, `cramer_solve` routine will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It also supports the methods available for special linear systems
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For positive definite systems:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If set to `'CH'`, `cholesky_solve` routine will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If set to `'LDL'`, `LDLsolve` routine will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To use a different method and to compute the solution via the inverse, use a
    method defined in the .inv() docstring.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**solutions** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Vector representing the solution.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If there is not a unique solution then a `ValueError` will be raised.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `M` is not square, a `ValueError` and a different routine for solving the
    system will be suggested.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Return the least-square fit to the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rhs** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Vector representing the right hand side of the linear equation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**method** : string or boolean, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If set to `'CH'`, `cholesky_solve` routine will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If set to `'LDL'`, `LDLsolve` routine will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If set to `'QR'`, `QRsolve` routine will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If set to `'PINV'`, `pinv_solve` routine will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Otherwise, the conjugate of `M` will be used to create a system of equations
    that is passed to `solve` along with the hint defined by `method`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**solutions** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Vector representing the solution.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'If each line of S represent coefficients of Ax + By and x and y are [2, 3]
    then S*xy is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'But let’s add 1 to the middle value and then solve for the least-squares value
    of xy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'The error is given by S*xy - r:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'If a different xy is used, the norm will be higher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: Returns the list of strongly connected vertices of the graph when a square matrix
    is viewed as a weighted graph.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: Decomposes a square matrix into block triangular form only using the permutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**lower** : bool'
  prefs: []
  type: TYPE_NORMAL
- en: Makes \(B\) lower block triangular when `True`. Otherwise, makes \(B\) upper
    block triangular.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**P, B** : PermutationMatrix, BlockMatrix'
  prefs: []
  type: TYPE_NORMAL
- en: '*P* is a permutation matrix for the similarity transform as in the explanation.
    And *B* is the block triangular matrix of the result of the permutation.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The decomposition is in a form of \(A = P^{-1} B P\) where \(P\) is a permutation
    matrix and \(B\) is a block diagonal matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: 'A lower block triangular decomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: 'An upper block triangular decomposition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: Return a new matrix with subs applied to each entry.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: String form of Matrix as a table.
  prefs: []
  type: TYPE_NORMAL
- en: '`printer` is the printer to use for on the elements (generally something like
    StrPrinter())'
  prefs: []
  type: TYPE_NORMAL
- en: '`rowstart` is the string used to start each row (by default ‘[‘).'
  prefs: []
  type: TYPE_NORMAL
- en: '`rowend` is the string used to end each row (by default ‘]’).'
  prefs: []
  type: TYPE_NORMAL
- en: '`rowsep` is the string used to separate rows (by default a newline).'
  prefs: []
  type: TYPE_NORMAL
- en: '`colsep` is the string used to separate columns (by default ‘, ‘).'
  prefs: []
  type: TYPE_NORMAL
- en: '`align` defines how the elements are aligned. Must be one of ‘left’, ‘right’,
    or ‘center’. You can also use ‘<’, ‘>’, and ‘^’ to mean the same thing, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: This is used by the string printer for Matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: Returns matrix as dict of dicts containing non-zero elements of the Matrix
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: Return the matrix as dictionary of keys.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: Return the Matrix as a nested Python list.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'When there are no rows then it will not be possible to tell how many columns
    were in the original matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: Returns the trace of a square matrix i.e. the sum of the diagonal elements.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: Returns the transpose of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`conjugate`](#sympy.matrices.matrixbase.MatrixBase.conjugate "sympy.matrices.matrixbase.MatrixBase.conjugate")'
  prefs: []
  type: TYPE_NORMAL
- en: By-element conjugation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: Converts a matrix into Hessenberg matrix H.
  prefs: []
  type: TYPE_NORMAL
- en: Returns 2 matrices H, P s.t. \(P H P^{T} = A\), where H is an upper hessenberg
    matrix and P is an orthogonal matrix
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: Return the elements on and above the kth diagonal of a matrix. If k is not specified
    then simply returns upper-triangular portion of a matrix
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: Solves `Ax = B`, where A is an upper triangular matrix.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`lower_triangular_solve`](#sympy.matrices.matrixbase.MatrixBase.lower_triangular_solve
    "sympy.matrices.matrixbase.MatrixBase.lower_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve
    "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve
    "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve
    "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve
    "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve
    "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve
    "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve
    "sympy.matrices.matrixbase.MatrixBase.cramer_solve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: Return non-zero values of self.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`iter_values`](#sympy.matrices.matrixbase.MatrixBase.iter_values "sympy.matrices.matrixbase.MatrixBase.iter_values"),
    [`tolist`](#sympy.matrices.matrixbase.MatrixBase.tolist "sympy.matrices.matrixbase.MatrixBase.tolist"),
    [`flat`](#sympy.matrices.matrixbase.MatrixBase.flat "sympy.matrices.matrixbase.MatrixBase.flat")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: Return the Matrix converted into a one column matrix by stacking columns
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`vech`](#sympy.matrices.matrixbase.MatrixBase.vech "sympy.matrices.matrixbase.MatrixBase.vech")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: Reshapes the matrix into a column vector by stacking the elements in the lower
    triangle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**diagonal** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, it includes the diagonal elements.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**check_symmetry** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, it checks whether the matrix is symmetric.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This should work for symmetric matrices and `vech` can represent symmetric matrices
    in vector form with less size than `vec`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`vec`](#sympy.matrices.matrixbase.MatrixBase.vec "sympy.matrices.matrixbase.MatrixBase.vec")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: Return a 3x1 vector from a skew-symmetric matrix representing the cross product,
    so that `self * b` is equivalent to `self.vee().cross(b)`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `vee` creates a vector from a skew-symmetric Matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: 'Calculating the matrix product of the original matrix with a vector is equivalent
    to a cross product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: '`vee` can also be used to retrieve angular velocity expressions. Defining a
    rotation matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: 'We can retrive the angular velocity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`dot`](#sympy.matrices.matrixbase.MatrixBase.dot "sympy.matrices.matrixbase.MatrixBase.dot"),
    [`cross`](#sympy.matrices.matrixbase.MatrixBase.cross "sympy.matrices.matrixbase.MatrixBase.cross"),
    [`hat`](#sympy.matrices.matrixbase.MatrixBase.hat "sympy.matrices.matrixbase.MatrixBase.hat"),
    [`multiply`](#sympy.matrices.matrixbase.MatrixBase.multiply "sympy.matrices.matrixbase.MatrixBase.multiply"),
    [`multiply_elementwise`](#sympy.matrices.matrixbase.MatrixBase.multiply_elementwise
    "sympy.matrices.matrixbase.MatrixBase.multiply_elementwise")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: Return a matrix formed by joining args vertically (i.e. by repeated application
    of col_join).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: Returns two square Wilkinson Matrix of size 2*n + 1 \(W_{2n + 1}^-, W_{2n +
    1}^+ =\) Wilkinson(n)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R642](#id36)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://blogs.mathworks.com/cleve/2013/04/15/wilkinsons-matrices-2/](https://blogs.mathworks.com/cleve/2013/04/15/wilkinsons-matrices-2/)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R643](#id37)]'
  prefs: []
  type: TYPE_NORMAL
- en: Wilkinson, The Algebraic Eigenvalue Problem, Claredon Press, Oxford, 1965, 662
    pp.
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: Return a new matrix with xreplace applied to each entry.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: Returns a matrix of zeros.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rows** : rows of the matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '**cols** : cols of the matrix (if None, cols=rows)'
  prefs: []
  type: TYPE_NORMAL
- en: Kwargs
  prefs: []
  type: TYPE_NORMAL
- en: 'cls : class of the returned matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Matrix Exceptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: Wrong matrix shape
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: Matrix Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: Return the Hadamard product (elementwise product) of A and B
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.__mul__`](#sympy.matrices.matrixbase.MatrixBase.__mul__
    "sympy.matrices.matrixbase.MatrixBase.__mul__")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: Returns a matrix of zeros with `rows` rows and `cols` columns; if `cols` is
    omitted a square matrix will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ones`](#sympy.matrices.dense.ones "sympy.matrices.dense.ones"), [`eye`](#sympy.matrices.dense.eye
    "sympy.matrices.dense.eye"), [`diag`](#sympy.matrices.dense.diag "sympy.matrices.dense.diag")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: Returns a matrix of ones with `rows` rows and `cols` columns; if `cols` is omitted
    a square matrix will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`zeros`](#sympy.matrices.dense.zeros "sympy.matrices.dense.zeros"), [`eye`](#sympy.matrices.dense.eye
    "sympy.matrices.dense.eye"), [`diag`](#sympy.matrices.dense.diag "sympy.matrices.dense.diag")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: Create square identity matrix n x n
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`diag`](#sympy.matrices.dense.diag "sympy.matrices.dense.diag"), [`zeros`](#sympy.matrices.dense.zeros
    "sympy.matrices.dense.zeros"), [`ones`](#sympy.matrices.dense.ones "sympy.matrices.dense.ones")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: Returns a matrix with the provided values placed on the diagonal. If non-square
    matrices are included, they will produce a block-diagonal matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: This version of diag is a thin wrapper to Matrix.diag that differs in that it
    treats all lists like matrices – even when a single list is given. If this is
    not desired, either put a \(*\) before the list or set \(unpack=True\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`matrixbase.MatrixBase.eye`](#sympy.matrices.matrixbase.MatrixBase.eye "sympy.matrices.matrixbase.MatrixBase.eye"),
    [`matrixbase.MatrixBase.diagonal`](#sympy.matrices.matrixbase.MatrixBase.diagonal
    "sympy.matrices.matrixbase.MatrixBase.diagonal"), [`matrixbase.MatrixBase.diag`](#sympy.matrices.matrixbase.MatrixBase.diag
    "sympy.matrices.matrixbase.MatrixBase.diag"), [`expressions.blockmatrix.BlockMatrix`](expressions.html#sympy.matrices.expressions.blockmatrix.BlockMatrix
    "sympy.matrices.expressions.blockmatrix.BlockMatrix")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a Jordan block:'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: Compute Hessian matrix for a function f wrt parameters in varlist which may
    be given as a sequence or a row/column vector. A list of constraints may optionally
    be given.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.jacobian`](#sympy.matrices.matrixbase.MatrixBase.jacobian
    "sympy.matrices.matrixbase.MatrixBase.jacobian"), [`wronskian`](#sympy.matrices.dense.wronskian
    "sympy.matrices.dense.wronskian")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R644](#id38)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Hessian_matrix](https://en.wikipedia.org/wiki/Hessian_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: Apply the Gram-Schmidt process to a set of vectors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**vlist** : List of Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Vectors to be orthogonalized for.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**orthonormal** : Bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If true, return an orthonormal basis.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**vlist** : List of Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Orthogonalized vectors
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This routine is mostly duplicate from `Matrix.orthogonalize`, except for some
    difference that this always raises error when linearly dependent vectors are found,
    and the keyword `normalize` has been named as `orthonormal` in this function.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`matrixbase.MatrixBase.orthogonalize`](#sympy.matrices.matrixbase.MatrixBase.orthogonalize
    "sympy.matrices.matrixbase.MatrixBase.orthogonalize")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R645](#id39)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Compute Wronskian for [] of functions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: 'see: [https://en.wikipedia.org/wiki/Wronskian](https://en.wikipedia.org/wiki/Wronskian)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.jacobian`](#sympy.matrices.matrixbase.MatrixBase.jacobian
    "sympy.matrices.matrixbase.MatrixBase.jacobian"), [`hessian`](#sympy.matrices.dense.hessian
    "sympy.matrices.dense.hessian")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: 'Given linear difference operator L of order ‘k’ and homogeneous equation Ly
    = 0 we want to compute kernel of L, which is a set of ‘k’ sequences: a(n), b(n),
    … z(n).'
  prefs: []
  type: TYPE_NORMAL
- en: Solutions of L are linearly independent iff their Casoratian, denoted as C(a,
    b, …, z), do not vanish for n = 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Casoratian is defined by k x k determinant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: 'It proves very useful in rsolve_hyper() where it is applied to a generating
    set of a recurrence to factor out linearly dependent solutions and return a basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: 'Exponential and factorial are linearly independent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: Create random matrix with dimensions `r` x `c`. If `c` is omitted the matrix
    will be square. If `symmetric` is True the matrix must be square. If `percent`
    is less than 100 then only approximately the given percentage of elements will
    be non-zero.
  prefs: []
  type: TYPE_NORMAL
- en: The pseudo-random number generator used to generate matrix is chosen in the
    following way.
  prefs: []
  type: TYPE_NORMAL
- en: If `prng` is supplied, it will be used as random number generator. It should
    be an instance of `random.Random`, or at least have `randint` and `shuffle` methods
    with same signatures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if `prng` is not supplied but `seed` is supplied, then new `random.Random` with
    given `seed` will be created;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: otherwise, a new `random.Random` with default seed will be used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: Rotation matrices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: Returns a a Givens rotation matrix, a a rotation in the plane spanned by two
    coordinates axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**i** : int between `0` and `dim - 1`'
  prefs: []
  type: TYPE_NORMAL
- en: Represents first axis
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**j** : int between `0` and `dim - 1`'
  prefs: []
  type: TYPE_NORMAL
- en: Represents second axis
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**dim** : int bigger than 1'
  prefs: []
  type: TYPE_NORMAL
- en: Number of dimentions. Defaults to 3.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Givens rotation corresponds to a generalization of rotation matrices to
    any number of dimensions, given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}G(i, j, \theta) = \begin{bmatrix} 1 & \cdots & 0 & \cdots & 0
    & \cdots & 0 \\ \vdots & \ddots & \vdots & & \vdots & & \vdots \\ 0 & \cdots &
    c & \cdots & -s & \cdots & 0 \\ \vdots & & \vdots & \ddots & \vdots & & \vdots
    \\ 0 & \cdots & s & \cdots & c & \cdots & 0 \\ \vdots & & \vdots & & \vdots &
    \ddots & \vdots \\ 0 & \cdots & 0 & \cdots & 0 & \cdots & 1 \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Where \(c = \cos(\theta)\) and \(s = \sin(\theta)\) appear at the intersections
    `i`th and `j`th rows and columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For fixed `i > j`, the non-zero elements of a Givens matrix are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \(g_{kk} = 1\) for \(k \ne i,\,j\)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(g_{kk} = c\) for \(k = i,\,j\)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: \(g_{ji} = -g_{ij} = -s\)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: 'A counterclockwise rotation of pi/3 (60 degrees) around the third axis (z-axis):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rotate by pi/2 (90 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be generalized to any number of dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis1`](#sympy.matrices.dense.rot_axis1 "sympy.matrices.dense.rot_axis1")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis
    (clockwise around the x axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis2`](#sympy.matrices.dense.rot_axis2 "sympy.matrices.dense.rot_axis2")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis
    (clockwise around the y axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis3`](#sympy.matrices.dense.rot_axis3 "sympy.matrices.dense.rot_axis3")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis
    (clockwise around the z axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis1`](#sympy.matrices.dense.rot_ccw_axis1 "sympy.matrices.dense.rot_ccw_axis1")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis
    (counterclockwise around the x axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis2`](#sympy.matrices.dense.rot_ccw_axis2 "sympy.matrices.dense.rot_ccw_axis2")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis
    (counterclockwise around the y axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis3`](#sympy.matrices.dense.rot_ccw_axis3 "sympy.matrices.dense.rot_ccw_axis3")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis
    (counterclockwise around the z axis)
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R646](#id40)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Givens_rotation](https://en.wikipedia.org/wiki/Givens_rotation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'For a right-handed coordinate system, this corresponds to a clockwise rotation
    around the \(x\)-axis, given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}R = \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos(\theta) & \sin(\theta)
    \\ 0 & -\sin(\theta) & \cos(\theta) \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: 'A rotation of pi/3 (60 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rotate by pi/2 (90 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Givens rotation matrix (generalized rotation for any number of dimensions)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis1`](#sympy.matrices.dense.rot_ccw_axis1 "sympy.matrices.dense.rot_ccw_axis1")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis
    (counterclockwise around the x axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis2`](#sympy.matrices.dense.rot_axis2 "sympy.matrices.dense.rot_axis2")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis
    (clockwise around the y axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis3`](#sympy.matrices.dense.rot_axis3 "sympy.matrices.dense.rot_axis3")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis
    (clockwise around the z axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'For a right-handed coordinate system, this corresponds to a clockwise rotation
    around the \(y\)-axis, given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}R = \begin{bmatrix} \cos(\theta) & 0 & -\sin(\theta) \\ 0 & 1
    & 0 \\ \sin(\theta) & 0 & \cos(\theta) \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: 'A rotation of pi/3 (60 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rotate by pi/2 (90 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Givens rotation matrix (generalized rotation for any number of dimensions)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis2`](#sympy.matrices.dense.rot_ccw_axis2 "sympy.matrices.dense.rot_ccw_axis2")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis
    (clockwise around the y axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis1`](#sympy.matrices.dense.rot_axis1 "sympy.matrices.dense.rot_axis1")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis
    (counterclockwise around the x axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis3`](#sympy.matrices.dense.rot_axis3 "sympy.matrices.dense.rot_axis3")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis
    (counterclockwise around the z axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'For a right-handed coordinate system, this corresponds to a clockwise rotation
    around the \(z\)-axis, given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}R = \begin{bmatrix} \cos(\theta) & \sin(\theta) & 0 \\ -\sin(\theta)
    & \cos(\theta) & 0 \\ 0 & 0 & 1 \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: 'A rotation of pi/3 (60 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rotate by pi/2 (90 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Givens rotation matrix (generalized rotation for any number of dimensions)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis3`](#sympy.matrices.dense.rot_ccw_axis3 "sympy.matrices.dense.rot_ccw_axis3")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis
    (counterclockwise around the z axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis1`](#sympy.matrices.dense.rot_axis1 "sympy.matrices.dense.rot_axis1")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis
    (clockwise around the x axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis2`](#sympy.matrices.dense.rot_axis2 "sympy.matrices.dense.rot_axis2")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis
    (clockwise around the y axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'For a right-handed coordinate system, this corresponds to a counterclockwise
    rotation around the \(x\)-axis, given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}R = \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos(\theta) & -\sin(\theta)
    \\ 0 & \sin(\theta) & \cos(\theta) \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: 'A rotation of pi/3 (60 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rotate by pi/2 (90 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Givens rotation matrix (generalized rotation for any number of dimensions)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis1`](#sympy.matrices.dense.rot_axis1 "sympy.matrices.dense.rot_axis1")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis
    (clockwise around the x axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis2`](#sympy.matrices.dense.rot_ccw_axis2 "sympy.matrices.dense.rot_ccw_axis2")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis
    (counterclockwise around the y axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis3`](#sympy.matrices.dense.rot_ccw_axis3 "sympy.matrices.dense.rot_ccw_axis3")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis
    (counterclockwise around the z axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'For a right-handed coordinate system, this corresponds to a counterclockwise
    rotation around the \(y\)-axis, given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}R = \begin{bmatrix} \cos(\theta) & 0 & \sin(\theta) \\ 0 & 1
    & 0 \\ -\sin(\theta) & 0 & \cos(\theta) \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: 'A rotation of pi/3 (60 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rotate by pi/2 (90 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Givens rotation matrix (generalized rotation for any number of dimensions)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis2`](#sympy.matrices.dense.rot_axis2 "sympy.matrices.dense.rot_axis2")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis
    (clockwise around the y axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis1`](#sympy.matrices.dense.rot_ccw_axis1 "sympy.matrices.dense.rot_ccw_axis1")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis
    (counterclockwise around the x axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis3`](#sympy.matrices.dense.rot_ccw_axis3 "sympy.matrices.dense.rot_ccw_axis3")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis
    (counterclockwise around the z axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'For a right-handed coordinate system, this corresponds to a counterclockwise
    rotation around the \(z\)-axis, given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}R = \begin{bmatrix} \cos(\theta) & -\sin(\theta) & 0 \\ \sin(\theta)
    & \cos(\theta) & 0 \\ 0 & 0 & 1 \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: 'A rotation of pi/3 (60 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: 'If we rotate by pi/2 (90 degrees):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a Givens rotation matrix (generalized rotation for any number of dimensions)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_axis3`](#sympy.matrices.dense.rot_axis3 "sympy.matrices.dense.rot_axis3")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 3-axis
    (clockwise around the z axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis1`](#sympy.matrices.dense.rot_ccw_axis1 "sympy.matrices.dense.rot_ccw_axis1")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 1-axis
    (counterclockwise around the x axis)
  prefs: []
  type: TYPE_NORMAL
- en: '[`rot_ccw_axis2`](#sympy.matrices.dense.rot_ccw_axis2 "sympy.matrices.dense.rot_ccw_axis2")'
  prefs: []
  type: TYPE_NORMAL
- en: Returns a rotation matrix for a rotation of theta (in radians) about the 2-axis
    (counterclockwise around the y axis)
  prefs: []
  type: TYPE_NORMAL
- en: Numpy Utility Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: Converts Python list of SymPy expressions to a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`matrix2numpy`](#sympy.matrices.dense.matrix2numpy "sympy.matrices.dense.matrix2numpy")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: Converts SymPy’s matrix to a NumPy array.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`list2numpy`](#sympy.matrices.dense.list2numpy "sympy.matrices.dense.list2numpy")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: Create a numpy ndarray of symbols (as an object array).
  prefs: []
  type: TYPE_NORMAL
- en: The created symbols are named `prefix_i1_i2_`… You should thus provide a non-empty
    prefix if you want your symbols to be unique for different output arrays, as SymPy
    symbols with identical names are the same object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**prefix** : string'
  prefs: []
  type: TYPE_NORMAL
- en: A prefix prepended to the name of every symbol.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**shape** : int or tuple'
  prefs: []
  type: TYPE_NORMAL
- en: Shape of the created array. If an int, the array is one-dimensional; for more
    than one dimension the shape must be a tuple.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '****kwargs** : dict'
  prefs: []
  type: TYPE_NORMAL
- en: keyword arguments passed on to Symbol
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: These doctests require numpy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want multiple symarrays to contain distinct symbols, you *must* provide
    unique prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating symarrays with a prefix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: 'For more than one dimension, the shape must be given as a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: 'For setting assumptions of the underlying Symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: Return integer after making positive and validating against n.
  prefs: []
  type: TYPE_NORMAL
