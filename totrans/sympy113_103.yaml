- en: Term Rewriting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/rewriting.html](https://docs.sympy.org/latest/modules/rewriting.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Term rewriting is a very general class of functionalities which are used to
    convert expressions of one type in terms of expressions of different kind. For
    example expanding, combining and converting expressions apply to term rewriting,
    and also simplification routines can be included here. Currently SymPy has several
    functions and basic built-in methods for performing various types of rewriting.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest rewrite rule is expanding expressions into a _sparse_ form. Expanding
    has several flavors and include expanding complex valued expressions, arithmetic
    expand of products and powers but also expanding functions in terms of more general
    functions is possible. Below are listed all currently available expand rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding of arithmetic expressions involving products and powers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic expand is done by default in `expand()` so the keyword `basic` can
    be omitted. However you can set `basic=False` to avoid this type of expand if
    you use rules described below. This give complete control on what is done with
    the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another type of expand rule is expanding complex valued expressions and putting
    them into a normal form. For this `complex` keyword is used. Note that it will
    always perform arithmetic expand to obtain the desired normal form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Note also that the same behavior can be obtained by using `as_real_imag()`
    method. However it will return a tuple containing the real part in the first place
    and the imaginary part in the other. This can be also done in a two step process
    by using `collect` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also possibility for expanding expressions in terms of expressions
    of different kind. This is very general type of expanding and usually you would
    use `rewrite()` to do specific type of rewrite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Common Subexpression Detection and Collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before evaluating a large expression, it is often useful to identify common
    subexpressions, collect them and evaluate them at once. This is implemented in
    the `cse` function. Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Optimizations to be performed before and after common subexpressions elimination
    can be passed in the `optimizations` optional argument. A set of predefined basic
    optimizations can be applied by passing `optimizations=''basic''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, these optimizations can be very slow for large expressions. Moreover,
    if speed is a concern, one can pass the option `order='none'`. Order of terms
    will then be dependent on hashing algorithm implementation, but speed will be
    greatly improved.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Perform common subexpression elimination on an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**exprs** : list of SymPy expressions, or a single SymPy expression'
  prefs: []
  type: TYPE_NORMAL
- en: The expressions to reduce.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**symbols** : infinite iterator yielding unique Symbols'
  prefs: []
  type: TYPE_NORMAL
- en: The symbols used to label the common subexpressions which are pulled out. The
    `numbered_symbols` generator is useful. The default is a stream of symbols of
    the form “x0”, “x1”, etc. This must be an infinite iterator.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**optimizations** : list of (callable, callable) pairs'
  prefs: []
  type: TYPE_NORMAL
- en: The (preprocessor, postprocessor) pairs of external optimization functions.
    Optionally ‘basic’ can be passed for a set of predefined basic optimizations.
    Such ‘basic’ optimizations were used by default in old implementation, however
    they can be really slow on larger expressions. Now, no pre or post optimizations
    are made by default.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**postprocess** : a function which accepts the two return values of cse and'
  prefs: []
  type: TYPE_NORMAL
- en: 'returns the desired form of output from cse, e.g. if you want the replacements
    reversed the function might be the following lambda: lambda r, e: return reversed(r),
    e'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**order** : string, ‘none’ or ‘canonical’'
  prefs: []
  type: TYPE_NORMAL
- en: The order by which Mul and Add arguments are processed. If set to ‘canonical’,
    arguments will be canonically ordered. If set to ‘none’, ordering will be faster
    but dependent on expressions hashes, thus machine dependent and variable. For
    large expressions where speed is a concern, use the setting order=’none’.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ignore** : iterable of Symbols'
  prefs: []
  type: TYPE_NORMAL
- en: Substitutions containing any Symbol from `ignore` will be ignored.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**list** : bool, (default True)'
  prefs: []
  type: TYPE_NORMAL
- en: Returns expression in list or else with same type as input (when False).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**replacements** : list of (Symbol, expression) pairs'
  prefs: []
  type: TYPE_NORMAL
- en: All of the common subexpressions that were replaced. Subexpressions earlier
    in this list might show up in subexpressions later in this list.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**reduced_exprs** : list of SymPy expressions'
  prefs: []
  type: TYPE_NORMAL
- en: The reduced expressions with all of the replacements above.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'List of expressions with recursive substitutions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: the type and mutability of input matrices is retained.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The user may disallow substitutions containing certain symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The default return value for the reduced expression(s) is a list, even if there
    is only one expression. The \(list\) flag preserves the type of the input in the
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
