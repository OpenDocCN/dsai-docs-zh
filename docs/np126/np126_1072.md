# 数组 API

> 原文：[`numpy.org/doc/1.26/reference/c-api/array.html`](https://numpy.org/doc/1.26/reference/c-api/array.html)

一流智慧的试金石是能够同时保持两种相反的想法，并仍然保持能够正常运作的能力。— *F. Scott Fitzgerald*对于成功的技术，现实必须优先于公关，因为自然不能被愚弄。— *理查德·P·费曼* ## 数组结构和数据访问

这些宏访问`PyArrayObject`结构成员，并在`ndarraytypes.h`中定义。输入参数*arr*可以是任何可直接解释为 PyArrayObject（`PyArray_Type`及其子类型的任何实例）的[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject "(在 Python v3.11 中)")*。

```py
int PyArray_NDIM( *arr)
```

数组中的维度数量。

```py
int PyArray_FLAGS( *arr)
```

返回表示 array-flags 的整数。

```py
int PyArray_TYPE( *arr)
```

返回此数组元素的（内置）类型编号。

```py
int PyArray_SETITEM( *arr, void *itemptr, *obj)
```

将对象转换并放置在由 itemptr 指向的位置的 ndarray，*arr*中。如果发生错误则返回-1，成功则返回 0。

```py
void PyArray_ENABLEFLAGS( *arr, int flags)
```

版本 1.7 中新增。

启用指定的数组标志。此函数不进行验证，假定您知道自己在做什么。

```py
void PyArray_CLEARFLAGS( *arr, int flags)
```

版本 1.7 中新增。

清除指定的数组标志。此函数不进行验证，假定您知道自己在做什么。

```py
void *PyArray_DATA( *arr)
```

```py
char *PyArray_BYTES( *arr)
```

这两个宏类似，并获取数组的数据缓冲区指针。第一个宏可以（并且应该）分配给特定指针，而第二个用于通用处理。如果您没有保证数组是连续的和/或对齐的，请确保了解如何访问数组中的数据，以避免内存和/或对齐问题。

```py
*PyArray_DIMS( *arr)
```

返回数组的维度/形状的指针。元素数量与数组的维度数量相匹配。对于 0 维数组可以返回`NULL`。

```py
*PyArray_SHAPE( *arr)
```

版本 1.7 中新增。

与`PyArray_DIMS`同义，命名一致以符合 Python 中的`shape`用法。

```py
*PyArray_STRIDES( *arr)
```

返回数组的步幅的指针。元素数量与数组的维度数量相匹配。

```py
PyArray_DIM( *arr, int n)
```

返回第*n*（第 n 个）维度的形状。

```py
PyArray_STRIDE( *arr, int n)
```

返回第*n*（第 n 个）维度的步幅。

```py
PyArray_ITEMSIZE( *arr)
```

返回此数组元素的项大小。

请注意，在版本 1.7 中弃用的旧 API 中，此函数的返回类型为`int`。

```py
PyArray_SIZE( *arr)
```

返回数组的总大小（元素数量）。

```py
PyArray_Size( *obj)
```

如果*obj*不是 ndarray 的子类，则返回 0。否则，返回数组中元素的总数。`PyArray_SIZE`（*obj*）的更安全版本。

```py
PyArray_NBYTES( *arr)
```

返回数组消耗的总字节数。

```py
*PyArray_BASE( *arr)
```

返回数组的基础对象。在大多数情况下，这意味着拥有数组指向的内存的对象。

如果您正在使用 C API 构建数组，并指定自己的内存，您应该使用函数`PyArray_SetBaseObject`将基础设置为拥有内存的对象。

如果设置了`NPY_ARRAY_WRITEBACKIFCOPY`标志，它具有不同的含义，即基础是当前数组解析时将被复制到的数组。这种对两个函数的基础属性的重载可能在未来的 NumPy 版本中发生变化。

```py
*PyArray_DESCR( *arr)
```

返回数组的 dtype 属性的借用引用。

```py
*PyArray_DTYPE( *arr)
```

自版本 1.7 起新增。

一个和 PyArray_DESCR 同义的名字，命名一致是为了符合 Python 中“dtype”的用法。

```py
*PyArray_GETITEM( *arr, void *itemptr)
```

从 ndarray *arr*在 itemptr 指向的位置获取一个内置类型的 Python 对象。失败时返回`NULL`。

`numpy.ndarray.item`等同于 PyArray_GETITEM。

```py
int PyArray_FinalizeFunc( *arr, *obj)
```

由[`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule "(in Python v3.11)") `__array_finalize__`指向的函数。第一个参数是新创建的子类型。第二个参数（如果不是 NULL）是“父”数组（如果数组是使用分片或某些其他操作创建的，其中存在清晰可区分的父对象）。此例程可以执行任何它想要的操作。它应该在错误时返回-1，否则返回 0。

### 数据访问

这些函数和宏为从 C 语言轻松访问 ndarray 的元素提供了便利。这对所有数组都有效。但是，如果要访问数组中的数据，需要注意如果数据不符合机器字节顺序，未对齐或不可写。换句话说，请务必遵守标志的状态，除非您知道您正在做什么，或者之前已经使用`PyArray_FromAny`保证了一个可写，对齐和机器字节顺序的数组。如果希望处理所有类型的数组，各类型的 copyswap 函数用于处理行为不端的数组非常有用。一些平台（例如 Solaris）不喜欢不对齐的数据，如果您取消引用一个不对齐的指针，它们就会崩溃。其他平台（例如 x86 Linux）会在处理不对齐的数据时工作得更慢。

```py
void *PyArray_GetPtr( *aobj, *ind)
```

返回指向 ndarray *aobj*在由 c 数组*ind*给出的 N 维索引处的数据的指针（该指针的大小必须至少为*aobj*->nd）。您可能需要将返回的指针强制转换为 ndarray 的数据类型。

```py
void *PyArray_GETPTR1( *obj, i)
```

```py
void *PyArray_GETPTR2( *obj, i, j)
```

```py
void *PyArray_GETPTR3( *obj, i, j, k)
```

```py
void *PyArray_GETPTR4( *obj, i, j, k, l)
```

在 ndarray * obj * 中给定坐标的快速内联访问，* obj * 必须分别具有 1、2、3 或 4 个维度（未检查此）。对应的* i *、* j *、* k *和* l *坐标可以是任何整数，但将被解释为`npy_intp`。您可能希望将返回的指针类型转换为阵列的数据类型。

## 创建数组

### 从零开始

```py
*PyArray_NewFromDescr( *subtype, *descr, int nd, const *dims, const *strides, void *data, int flags, *obj)
```

此函数窃取了对* descr *的引用。获取它的最简单方法是使用`PyArray_DescrFromType`。

这是主要的数组创建函数。大多数新数组都是使用这个灵活的函数创建的。

返回的对象是 Python 类型 *subtype* 的对象，它必须是`PyArray_Type`的子类型。数组具有 *nd* 维度，由 *dims* 描述。新数组的数据类型描述符是 *descr*。

如果* subtype *是数组子类的而不是基本的`&PyArray_Type`，那么* obj *是要传递给子类的`__array_finalize__`方法的对象。

如果 *data* 为`NULL`，则将分配新的未初始化内存，并且 *flags* 可以为非零，表示 Fortran 风格连续数组。使用`PyArray_FILLWBYTE`来初始化内存。

如果 *data* 不为`NULL`，则假定它指向要用于数组的内存，并且 *flags* 参数将用作数组的新标志（除了 `NPY_ARRAY_OWNDATA`、`NPY_ARRAY_WRITEBACKIFCOPY` 标志的新数组状态将被重置）。

此外，如果* data *不为 NULL，则还可以提供* strides *。如果* strides *为`NULL`，则数组步幅将计算为 C 风格连续（默认）或 Fortran 风格连续（* data * =`NULL`或* flags * & `NPY_ARRAY_F_CONTIGUOUS`为非零非 NULL* data *）。为新数组对象复制任何提供的* dims *和* strides *。

`PyArray_CheckStrides`可帮助验证非`NULL`的步幅信息。

如果提供了 *data*，则它必须在数组的生命周期内保持存活。通过`PyArray_SetBaseObject`来管理这一点是一种方法。

```py
*PyArray_NewLikeArray( *prototype, order, *descr, int subok)
```

版本 1.6 的新功能。

如果* descr *不为 NULL，则此函数将窃取对*descr*的引用。此数组创建例程允许方便地创建与现有数组的形状和内存布局匹配的新数组，可能会改变布局和/或数据类型。

当*order*为`NPY_ANYORDER`时，如果*prototype*是 Fortran 数组，则结果顺序为`NPY_FORTRANORDER`，否则为`NPY_CORDER`。当*order*为`NPY_KEEPORDER`时，结果顺序与*prototype*的顺序匹配，即使*prototype*的轴不是 C 或 Fortran 顺序。

如果*descr*为 NULL，则使用*prototype*的数据类型。

如果*subok*为 1，则新创建的数组将使用*prototype*的子类型来创建新数组，否则将创建一个基类数组。

```py
*PyArray_New( *subtype, int nd, const *dims, int type_num, const *strides, void *data, int itemsize, int flags, *obj)
```

这类似于`PyArray_NewFromDescr`（…），除了您使用*type_num*和*itemsize*指定数据类型描述符，其中*type_num*对应于内置（或用户定义的）类型。如果类型始终具有相同的字节数，则*itemsize*将被忽略。否则，*itemsize*指定此数组的特定大小。

警告

如果数据被传递给`PyArray_NewFromDescr`或`PyArray_New`，则在删除新数组之前不得释放此内存。如果此数据来自另一个 Python 对象，则可以通过对该对象使用[`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF "(in Python v3.11)")并将新数组的 base 成员指向该对象来实现。如果传入了步幅，则它们必须与数组的维数、itemsize 和数据一致。

```py
*PyArray_SimpleNew(int nd, const *dims, int typenum)
```

创建一个新的未初始化数组，其类型为*typenum*，每个*nd*维中的大小由整数数组*dims*给出。数组的内存是未初始化的（除非 typenum 为`NPY_OBJECT`，在这种情况下，数组中的每个元素都设置为 NULL）。*typenum*参数允许指定任何内置数据类型，例如`NPY_FLOAT`或`NPY_LONG`。如果需要，可以使用`PyArray_FILLWBYTE`（return_object, 0）将数组的内存设置为零。此函数不能用于创建灵活类型的数组（未给出 itemsize）。

```py
*PyArray_SimpleNewFromData(int nd, const *dims, int typenum, void *data)
```

在给定指针指向的*data*周围创建一个数组包装器。数组标志将具有默认设置，即数据区域是良好行为的，并且是 C 风格连续的。数组的形状由长度为*nd*的*dims* c 数组确定。数组的数据类型由*typenum*指示。如果数据来自另一个引用计数的 Python 对象，则应该在传入指针之后增加此对象的引用计数，并且返回的 ndarray 的 base 成员应指向拥有数据的 Python 对象。这将确保在返回的数组存在时不会释放提供的内存。

```py
*PyArray_SimpleNewFromDescr(int nd, const *dims, *descr)
```

此函数会偷取对*descr*的引用。

使用提供的数据类型描述符*descr*，创建一个形状由*nd*和*dims*确定的新数组。

```py
void PyArray_FILLWBYTE( *obj, int val)
```

填充被*obj*指向的数组，*obj*必须是一个 ndarray 的子类，用*val*的内容（作为字节评估）。此宏调用 memset，因此 obj 必须是连续的。

```py
*PyArray_Zeros(int nd, const *dims, *dtype, int fortran)
```

构建一个形状由*dims*确定，数据类型由*dtype*确定的新*nd*维数组。如果*fortran*不是零，则创建一个 Fortran 顺序数组，否则创建一个 C 顺序数组。用零填充内存（或如果*dtype*对应于`NPY_OBJECT` ，则填充为 0 对象）。

```py
*PyArray_ZEROS(int nd, const *dims, int type_num, int fortran)
```

宏形式的`PyArray_Zeros` ，其参数为类型数字而不是数据类型对象。

```py
*PyArray_Empty(int nd, const *dims, *dtype, int fortran)
```

构建一个形状由*dims*确定，数据类型由*dtype*确定的新*nd*维数组。如果*fortran*非零，则创建一个 Fortran 顺序的数组，否则创建一个 C 顺序的数组。该数组未初始化，除非数据类型对应于`NPY_OBJECT` ，此时数组将填充为[`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)")。

```py
*PyArray_EMPTY(int nd, const *dims, int typenum, int fortran)
```

宏形式的`PyArray_Empty` ，其参数为类型数字*typenum*而不是数据类型对象。

```py
*PyArray_Arange(double start, double stop, double step, int typenum)
```

构建一个新的一维数据类型为*typenum*的数组，范围从*start*到*stop*（不包括*stop*），增量为*step*。相当于**arange**(*start*, *stop*, *step*, dtype)。

```py
*PyArray_ArangeObj( *start, *stop, *step, *descr)
```

构建一个由`descr`确定数据类型的新的一维数组，范围从`start`到`stop`（不包括`stop`），步长为`step`。相当于 arange(`start`, `stop`, `step`, typenum)。

```py
int PyArray_SetBaseObject( *arr, *obj)
```

自 1.7 版开始。

此函数**偷取一个引用**，将`obj`设为`arr`的基本属性。

如果通过将自己的内存缓冲区作为参数传递来构建数组，则需要设置数组的*base*属性，以确保内存缓冲区的生命周期适当。

返回值为成功时为 0，失败时为-1。

如果提供的对象是一个数组，则此函数遍历*base*指针链，以使每个数组直接指向内存的所有者。一旦设定了基本值，就不能将其更改为另一个值。

### 来自其他对象

```py
*PyArray_FromAny( *op, *dtype, int min_depth, int max_depth, int requirements, *context)
```

这是从任何嵌套序列或暴露数组接口的对象*op*中获取数组的主要函数。参数允许指定所需的*dtype*，最小(*min_depth*)和最大(*max_depth*)可接受的维数，以及数组的其他*requirements*。这个函数**窃取了对 dtype 参数的引用**，它需要是一个表示所需数据类型（包括所需的字节顺序）的`PyArray_Descr`结构。*dtype*参数可能是`NULL`，表示任何数据类型（以及字节顺序）都可接受。除非`NPY_ARRAY_FORCECAST`在`flags`中出现，否则此调用将生成错误，如果无法安全地从对象中获取数据类型。如果要对*dtype*使用`NULL`并确保数组没有被交换，则使用`PyArray_CheckFromAny`。深度参数为 0 表示忽略该参数。可以向*requirements*参数中添加以下任何数组标志（*例如*使用|）。如果您的代码可以处理一般的（*例如*分步，字节交换或不对齐的数组），则*requirements*可能为 0。此外，如果*op*不是一个数组（或者不公开数组接口），那么将创建一个新的数组（并使用序列协议从*op*中填充）。新数组的 flags 成员将具有`NPY_ARRAY_DEFAULT`。*context*参数未使用。

```py
NPY_ARRAY_C_CONTIGUOUS
```

确保返回的数组是 C 风格连续的

```py
NPY_ARRAY_F_CONTIGUOUS
```

确保返回的数组是 Fortran 风格连续的。

```py
NPY_ARRAY_ALIGNED
```

确保返回的数组对其数据类型有适当的边界。一个对齐的数组具有数据指针和每个步幅因子都是数据类型描述符的对齐因子的倍数。

```py
NPY_ARRAY_WRITEABLE
```

确保返回的数组可写。

```py
NPY_ARRAY_ENSURECOPY
```

确保对*op*进行了复制。如果没有此标志，则只有在可以避免时才不会复制数据。

```py
NPY_ARRAY_ENSUREARRAY
```

确保结果是一个基类的 ndarray。默认情况下，如果*op*是 ndarray 的子类的实例，则会返回该相同子类的实例。如果设置了这个标志，则会返回一个 ndarray 对象。

```py
NPY_ARRAY_FORCECAST
```

强制对输出类型进行转换，即使不能安全地进行。如果没有这个标志，只有在可以安全地进行数据转换时才会发生数据转换，否则将引发错误。

```py
NPY_ARRAY_WRITEBACKIFCOPY
```

如果*op*已经是一个数组，但不符合要求，则会进行复制（这将满足要求）。 如果存在此标志，并且必须复制（已经是数组的对象的复制），则在返回的复制中设置相应的`NPY_ARRAY_WRITEBACKIFCOPY`标志，并使*op*为只读。 您必须确保调用`PyArray_ResolveWritebackIfCopy`将内容复制回*op*，并且*op*数组将再次变为可写。 如果*op*一开始就不可写，或者它不是一个数组，则会引发错误。

```py
NPY_ARRAY_BEHAVED
```

`NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`

```py
NPY_ARRAY_CARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_CARRAY_RO
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_FARRAY_RO
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_DEFAULT
```

`NPY_ARRAY_CARRAY`

```py
NPY_ARRAY_IN_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_IN_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_OUT_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_OUT_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`

```py
NPY_ARRAY_OUT_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_INOUT_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEBACKIFCOPY`

```py
NPY_ARRAY_INOUT_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEBACKIFCOPY`

```py
*PyArray_CheckFromAny( *op, *dtype, int min_depth, int max_depth, int requirements, *context)
```

几乎与`PyArray_FromAny`（…）相同，只是*requirements*可以包含`NPY_ARRAY_NOTSWAPPED`（覆盖*dtype*中的规范）和`NPY_ARRAY_ELEMENTSTRIDES`，表明数组应以步幅是元素大小的倍数的意义对齐。

在 NumPy 的 1.6 版本及之前版本中，以下标志没有使用 _ARRAY_ 宏命名空间。1.7 版本中不再使用该形式的常量名称。

```py
NPY_ARRAY_NOTSWAPPED
```

确保返回的数组具有机器字节顺序的数据类型描述符，覆盖*dtype*参数中的任何规范。通常，字节顺序要求由*dtype*参数确定。如果设置了此标志并且 dtype 参数未指示机器字节顺序描述符（或为 NULL 并且对象已经是具有非机器字节顺序的数据类型描述符的数组），则创建一个新的数据类型描述符并将其用于其字节顺序字段设置为 native。

```py
NPY_ARRAY_BEHAVED_NS
```

`NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_NOTSWAPPED`

```py
NPY_ARRAY_ELEMENTSTRIDES
```

确保返回的数组的步幅是元素大小的倍数。

```py
*PyArray_FromArray( *op, *newtype, int requirements)
```

`PyArray_FromAny` 的特殊情况，当*op*已经是一个数组但需要是特定的*newtype*（包括字节顺序）或具有某些*要求*时。

```py
*PyArray_FromStructInterface( *op)
```

从暴露数组接口协议并遵循数组接口协议的 Python 对象中返回一个 ndarray 对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented "(在 Python v3.11)")的借用引用。

```py
*PyArray_FromInterface( *op)
```

从暴露数组接口协议的 Python 对象中返回一个 ndarray 对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented "(在 Python v3.11)")的借用引用。

```py
*PyArray_FromArrayAttr( *op, *dtype, *context)
```

从暴露`__array__`方法的 Python 对象返回一个 ndarray 对象。`__array__`方法可以接受 0 个或 1 个参数`([dtype])`。*context*未使用。

```py
*PyArray_ContiguousFromAny( *op, int typenum, int min_depth, int max_depth)
```

此函数从任何嵌套序列或数组接口导出的对象*op*返回一个(C 样式)连续和行为良好的函数数组，其类型由枚举*typenum*给出，最小深度为*min_depth*，最大深度为*max_depth*。(非灵活)。相当于调用`PyArray_FromAny`，并将要求设置为`NPY_ARRAY_DEFAULT`和类型参数的 type_num 成员设置为*typenum*。

```py
*PyArray_ContiguousFromObject( *op, int typenum, int min_depth, int max_depth)
```

此函数从任何嵌套序列或数组接口导出的对象返回一个良好行为的 C 样式连续数组。数组可以具有的最小维数由*min_depth*给出，最大维数由*max_depth*给出。这相当于调用`PyArray_FromAny`，并将要求设置为`NPY_ARRAY_DEFAULT`和`NPY_ARRAY_ENSUREARRAY`。

```py
*PyArray_FromObject( *op, int typenum, int min_depth, int max_depth)
```

从任何嵌套序列或数组接口导出的对象**op**返回一个对齐的、本地字节顺序的数组，其类型由枚举类型号给出。数组可以具有的最小维数由*min_depth*给出，最大维数由*max_depth*给出。这相当于调用`PyArray_FromAny`，并将要求设置为 BEHAVED。

```py
*PyArray_EnsureArray( *op)
```

此函数**窃取对 op 的引用**，并确保 op 是一个基类 ndarray。它特殊处理数组标量，否则调用`PyArray_FromAny`(`op`，NULL，0，0，`NPY_ARRAY_ENSUREARRAY`，NULL)。

```py
*PyArray_FromString(char *string, slen, *dtype, num, char *sep)
```

从长度为*slen*的二进制或（ASCII）文本`string`构造一个单一类型的一维 ndarray。要创建的数组的数据类型由`dtype`给出。如果*num*为-1，则**复制**整个字符串并返回一个适当大小的数组，否则，`num`是从字符串中**复制**的项数。如果`sep`为 NULL（或“”），则将字符串解释为二进制数据的字节，否则将由`sep`分隔的子字符串转换为数据类型为`dtype`的项。某些数据类型在文本模式下可能无法读取，如果发生这种情况，将引发错误。所有错误都返回 NULL。

```py
*PyArray_FromFile(FILE *fp, *dtype, num, char *sep)
```

从二进制或文本文件中构造单一类型的一维 ndarray。打开的文件指针是`fp`，要创建的数组的数据类型由`dtype`给出。这必须与文件中的数据匹配。如果`num`为-1，则读取到文件结束并返回一个大小适当的数组，否则，`num`是要读取的项目数。如果`sep`为 NULL（或“”），则从文件中以二进制模式读取，否则以文本模式从文件中读取，并使用`sep`提供项目分隔符。有些数组类型无法以文本模式读取，此时会引发错误。

```py
*PyArray_FromBuffer( *buf, *dtype, count, offset)
```

从导出（单一段）缓冲区协议的对象`buf`构造单一类型的一维 ndarray。首先尝试可写缓冲区，然后尝试只读缓冲区。返回的数组的`NPY_ARRAY_WRITEABLE`标志将反映哪种操作成功。假定数据从对象的内存位置的起始位置偏移`offset`字节开始。缓冲区中的数据类型将根据数据类型描述符`dtype`进行解释。如果`count`为负，则它将根据缓冲区的大小和请求的 itemsize 来确定，否则，`count`表示应从缓冲区转换多少元素。

```py
int PyArray_CopyInto( *dest, *src)
```

从源数组`src`复制到目标数组`dest`，必要时执行数据类型转换。如果发生错误，则返回-1（否则返回 0）。`src`的形状必须可以广播到`dest`的形状。目标数组和源数组的数据区域不能重叠。

```py
int PyArray_CopyObject( *dest, *src)
```

根据数组强制转换规则，将对象`src`分配给 NumPy 数组`dest`。这基本上与`PyArray_FromAny`相同，但直接分配给输出数组。成功返回 0，失败返回-1。

```py
int PyArray_MoveInto( *dest, *src)
```

将源数组`src`中的数据移动到目标数组`dest`中，必要时执行数据类型转换。如果发生错误，则返回-1（否则返回 0）。`src`的形状必须可以广播到`dest`的形状。目标数组和源数组的数据区域可能重叠。

```py
*PyArray_GETCONTIGUOUS( *op)
```

如果`op`已经（C 风格）是连续且表现良好的数组，那么只需返回一个引用，否则返回一个（连续且表现良好的）数组的副本。参数`op`必须是一个（多维数组的）ndarray 的子类，并且没有进行其他检查。

```py
*PyArray_FROM_O( *obj)
```

将`obj`转换为 ndarray。参数可以是任何嵌套序列或导出数组接口的对象。这是使用`NULL`、0、0、0 作为其他参数的`PyArray_FromAny`的宏形式。您的代码必须能够处理任何数据类型描述符和使用此宏的数据标志的任何组合。

```py
*PyArray_FROM_OF( *obj, int requirements)
```

类似于`PyArray_FROM_O`，只是它可以接受一个*requirements*参数，指示返回的数组必须具有的属性。可强制执行的可用要求包括`NPY_ARRAY_C_CONTIGUOUS`、`NPY_ARRAY_F_CONTIGUOUS`、`NPY_ARRAY_ALIGNED`、`NPY_ARRAY_WRITEABLE`、`NPY_ARRAY_NOTSWAPPED`、`NPY_ARRAY_ENSURECOPY`、`NPY_ARRAY_WRITEBACKIFCOPY`、`NPY_ARRAY_FORCECAST`和`NPY_ARRAY_ENSUREARRAY`。还可以使用标准的标志组合：

```py
*PyArray_FROM_OT( *obj, int typenum)
```

类似于`PyArray_FROM_O`，只是它可以接受一个*typenum*参数，指定返回数组的类型码。

```py
*PyArray_FROM_OTF( *obj, int typenum, int requirements)
```

结合`PyArray_FROM_OF`和`PyArray_FROM_OT`，允许提供*typenum*和*flags*两个参数。

```py
*PyArray_FROMANY( *obj, int typenum, int min, int max, int requirements)
```

类似于`PyArray_FromAny`，但是数据类型通过类型码指定。`PyArray_DescrFromType` (*typenum*)直接传递给`PyArray_FromAny`。如果传入`NPY_ARRAY_ENSURECOPY`作为要求，此宏还会将`NPY_ARRAY_DEFAULT`添加到要求中。

```py
*PyArray_CheckAxis( *obj, int *axis, int requirements)
```

封装了以 axis=关键字作为输入参数，以 None 作为 axis 参数的函数和方法的功能。输入数组是`obj`，而`*axis`是一个转换后的整数（使得>=MAXDIMS 表示 None 值），`requirements`给出了`obj`的所需属性。输出是输入的转换版本，以满足要求，并且如果需要则执行了展平操作。在输出中，负数值的`*axis`会被转换，并检查新值以确保与`obj`的形状一致。

## 处理类型

### Python 类型的一般检查

```py
int PyArray_Check( *op)
```

如果*op*是一个 Python 对象，并且其类型是`PyArray_Type`的子类型，则求值为真。

```py
int PyArray_CheckExact( *op)
```

如果*op*是一个 Python 对象，并且其类型是`PyArray_Type`，则求值为真。

```py
int PyArray_HasArrayInterface( *op, *out)
```

如果`op`实现了数组接口的任何部分，则`out`将包含对使用接口创建的新 ndarray 的新引用，或者如果在转换过程中发生错误，则`out`将包含`NULL`。否则，`out`将包含对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented)的借用引用，并且不会设置错误条件。

```py
int PyArray_HasArrayInterfaceType( *op, *dtype, *context, *out)
```

如果`op`实现了数组接口的任何部分，则`out`将包含对使用接口创建的新 ndarray 的新引用，或者如果在转换过程中发生错误，则`out`将包含`NULL`。否则，`out`将包含对 Py_NotImplemented 的借用引用，并且不会设置错误条件。此版本允许在寻找`__array__`属性的数组接口的部分中设置数据类型。*context*未使用。

```py
int PyArray_IsZeroDim( *op)
```

如果*op*是（子类的）`PyArray_Type`的实例且维数为 0，则评估为真。

```py
PyArray_IsScalar(op, cls)
```

如果*op*是`Py{cls}ArrType_Type`的实例，则评估为真。

```py
int PyArray_CheckScalar( *op)
```

如果*op*是数组标量（`PyGenericArr_Type`的子类型的实例）或者（子类的）`PyArray_Type`的实例且维数为 0，则评估为真。

```py
int PyArray_IsPythonNumber( *op)
```

如果*op*是内置数值类型（int、float、complex、long、bool）的实例，则评估为真。

```py
int PyArray_IsPythonScalar( *op)
```

如果*op*是内置的 Python 标量对象（int、float、complex、bytes、str、long、bool），则评估为真。

```py
int PyArray_IsAnyScalar( *op)
```

如果*op*是 Python 标量对象（请参见`PyArray_IsPythonScalar`）或数组标量（`PyGenericArr_Type`的子类型的实例）的实例，则评估为真。

```py
int PyArray_CheckAnyScalar( *op)
```

如果*op*是 Python 标量对象（请参见`PyArray_IsPythonScalar`）、数组标量（`PyGenericArr_Type`的子类型的实例）或者维数为 0 的`PyArray_Type`的子类型的实例，则评估为真。

### 数据类型检查

对于 typenum 宏，参数是表示枚举数组数据类型的整数。对于数组类型检查宏，参数必须是可以直接解释为 PyArrayObject 的[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject)。

```py
int PyTypeNum_ISUNSIGNED(int num)
```

```py
int PyDataType_ISUNSIGNED( *descr)
```

```py
int PyArray_ISUNSIGNED( *obj)
```

类型表示无符号整数。

```py
int PyTypeNum_ISSIGNED(int num)
```

```py
int PyDataType_ISSIGNED( *descr)
```

```py
int PyArray_ISSIGNED( *obj)
```

类型表示有符号整数。

```py
int PyTypeNum_ISINTEGER(int num)
```

```py
int PyDataType_ISINTEGER( *descr)
```

```py
int PyArray_ISINTEGER( *obj)
```

类型表示任何整数。

```py
int PyTypeNum_ISFLOAT(int num)
```

```py
int PyDataType_ISFLOAT( *descr)
```

```py
int PyArray_ISFLOAT( *obj)
```

类型表示任何浮点数。

```py
int PyTypeNum_ISCOMPLEX(int num)
```

```py
int PyDataType_ISCOMPLEX( *descr)
```

```py
int PyArray_ISCOMPLEX( *obj)
```

类型表示任何复数浮点数。

```py
int PyTypeNum_ISNUMBER(int num)
```

```py
int PyDataType_ISNUMBER( *descr)
```

```py
int PyArray_ISNUMBER( *obj)
```

类型表示任何整数、浮点数或复数浮点数。

```py
int PyTypeNum_ISSTRING(int num)
```

```py
int PyDataType_ISSTRING( *descr)
```

```py
int PyArray_ISSTRING( *obj)
```

类型表示字符串数据类型。

```py
int PyTypeNum_ISPYTHON(int num)
```

```py
int PyDataType_ISPYTHON( *descr)
```

```py
int PyArray_ISPYTHON( *obj)
```

类型表示枚举类型，对应于标准 Python 标量中的一个（bool、int、float 或 complex）。

```py
int PyTypeNum_ISFLEXIBLE(int num)
```

```py
int PyDataType_ISFLEXIBLE( *descr)
```

```py
int PyArray_ISFLEXIBLE( *obj)
```

类型代表了一种灵活的数组类型（`NPY_STRING`，`NPY_UNICODE`或者`NPY_VOID`）。

```py
int PyDataType_ISUNSIZED( *descr)
```

类型没有附加的大小信息，并且可以重新调整大小。应仅在灵活的数据类型上调用。附加到数组的类型始终会有大小，因此不存在该宏的数组形式。

从版本 1.18 开始更改。

对于没有字段的结构化数据类型，此函数现在返回 False。

```py
int PyTypeNum_ISUSERDEF(int num)
```

```py
int PyDataType_ISUSERDEF( *descr)
```

```py
int PyArray_ISUSERDEF( *obj)
```

类型代表用户定义的类型。

```py
int PyTypeNum_ISEXTENDED(int num)
```

```py
int PyDataType_ISEXTENDED( *descr)
```

```py
int PyArray_ISEXTENDED( *obj)
```

类型是灵活的或用户定义的。

```py
int PyTypeNum_ISOBJECT(int num)
```

```py
int PyDataType_ISOBJECT( *descr)
```

```py
int PyArray_ISOBJECT( *obj)
```

类型代表对象数据类型。

```py
int PyTypeNum_ISBOOL(int num)
```

```py
int PyDataType_ISBOOL( *descr)
```

```py
int PyArray_ISBOOL( *obj)
```

类型代表布尔数据类型。

```py
int PyDataType_HASFIELDS( *descr)
```

```py
int PyArray_HASFIELDS( *obj)
```

类型有与之关联的字段。

```py
int PyArray_ISNOTSWAPPED( *m)
```

如果 ndarray *m* 的数据区域按照数组的数据类型描述符是机器字节顺序的话，则评估为真。

```py
int PyArray_ISBYTESWAPPED( *m)
```

如果 ndarray *m* 的数据区域 **不** 按照数组的数据类型描述符是机器字节顺序的话，则评估为真。

```py
PyArray_EquivTypes( *type1, *type2)
```

如果 *type1* 和 *type2* 在此平台上实际上表示等效类型（忽略每种类型的 fortran 成员），则返回`NPY_TRUE`。例如，在 32 位平台上，`NPY_LONG` 和 `NPY_INT` 是等效的。否则返回`NPY_FALSE`。

```py
PyArray_EquivArrTypes( *a1, *a2)
```

如果 *a1* 和 *a2* 是在此平台上具有等效类型的数组，则返回`NPY_TRUE`。

```py
PyArray_EquivTypenums(int typenum1, int typenum2)
```

`PyArray_EquivTypes`（…）的特殊情况，不接受灵活的数据类型，但可能更容易调用。

```py
int PyArray_EquivByteorders(int b1, int b2)
```

如果字节顺序字符 *b1* 和 *b2*（`NPY_LITTLE`，`NPY_BIG`，`NPY_NATIVE`，`NPY_IGNORE`）相等或等效，则为真。因此，在小端机器上，`NPY_LITTLE` 和 `NPY_NATIVE` 是等效的，而在大端机器上不等效。

### 转换数据类型

```py
*PyArray_Cast( *arr, int typenum)
```

主要用于向后兼容 Numeric C-API 和简单地将类型转换为非灵活类型。返回一个新的数组对象，其元素为 *arr* 转换为数据类型 *typenum*，*typenum* 必须是枚举类型之一，而不是灵活类型。

```py
*PyArray_CastToType( *arr, *type, int fortran)
```

返回指定的 *type* 的新数组，将 *arr* 的元素转换为适当的类型。fortran 参数指定输出数组的顺序。

```py
int PyArray_CastTo( *out, *in)
```

从 1.6 开始，此函数只是调用了 `PyArray_CopyInto`，它处理了类型转换。

将数组 *in* 的元素转换为数组 *out*。输出数组应可写，具有输入数组中元素数量的整数倍（可以在 out 中放置多个副本），并具有一个内建类型的数据类型。成功时返回 0，如果发生错误则返回 -1。

```py
PyArray_VectorUnaryFunc *PyArray_GetCastFunc( *from, int totype)
```

返回从给定描述符转换为内置类型数的低级转换函数。如果没有转换函数存在，则返回`NULL`并设置错误。使用此函数而不是直接访问*from*->f->cast 将允许支持添加到描述符的转换字典中的任何用户定义的转换函数。

```py
int PyArray_CanCastSafely(int fromtype, int totype)
```

如果*fromtype*数据类型的数组可以转换为*toptype*数据类型的数组而不会丢失信息，则返回非零值。唯一的例外是 64 位整数可以转换为 64 位浮点数，即使这样做会丢失大整数的精度，这是为了避免在没有显式请求的情况下过多使用长双精度。此函数不检查灵活数组类型的长度。

```py
int PyArray_CanCastTo( *fromtype, *totype)
```

`PyArray_CanCastTypeTo`在 NumPy 1.6 及更高版本中已被弃用。

等同于 PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING)。

```py
int PyArray_CanCastTypeTo( *fromtype, *totype, casting)
```

新版本 1.6 中加入。

如果*fromtype*数据类型的数组（可以包括灵活类型）可以根据*casting*规则安全地转换为*toptype*数据类型的数组（可以包括灵活类型），则返回非零值。对于使用`NPY_SAFE_CASTING`的简单类型来说，这基本上只是`PyArray_CanCastSafely`的一个包装器，但对于字符串或 unicode 等灵活类型，它会考虑它们的大小生成结果。只有整数和浮点类型（使用`NPY_SAFE_CASTING`）能够转换为足够大以容纳转换前的整数/浮点类型的最大值的字符串或 unicode 类型。

```py
int PyArray_CanCastArrayTo( *arr, *totype, casting)
```

新版本 1.6 中加入。

如果*arr*可以根据*casting*规则转换为*totype*，则返回非零值。如果*arr*是数组标量，则其值也会被考虑在内，当将其转换为较小类型时，值不会溢出或被截断时也会返回非零值。

这几乎与 PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), toptype, casting)的结果相同，但它还处理了一个特殊情况，因为具有相同位数的类型中 uint 值的集合不是 int 值的子集。

```py
*PyArray_MinScalarType( *arr)
```

新版本 1.6 中加入。

如果*arr*是一个数组，则返回其数据类型描述符，但如果*arr*是一个数组标量（维度为 0），则找到可以将值转换为而不会溢出或截断为整数的最小大小的数据类型。

此函数不会将复数降级为浮点数或任何东西降级为布尔值，但在标量值为正数时，将有符号整数降级为无符号整数。

```py
*PyArray_PromoteTypes( *type1, *type2)
```

新版本 1.6 中加入。

查找*type1*和*type2*可以安全转换为的最小大小和种类的数据类型。此函数是对称的和可结合的。字符串或 unicode 结果将是适当大小，以存储转换为字符串或 unicode 的输入类型的最大值。

```py
*PyArray_ResultType( narrs, **arrs, ndtypes, **dtypes)
```

1.6 中的新功能。

这将应用类型提升到所有输入数组和 dtype 对象，使用 NumPy 规则来组合标量和数组，以确定给定操作的输出类型的输出类型。这是 ufuncs 产生的相同结果类型。

有关类型提升算法的更多详细信息，请参阅`numpy.result_type`的文档。

```py
int PyArray_ObjectType( *op, int mintype)
```

此函数已被`PyArray_MinScalarType`和/或`PyArray_ResultType`取代。

此函数用于确定两个或多个数组可以转换为的公共类型。它仅适用于非灵活的数组类型，因为没有传递 itemsize 信息。*mintype*参数表示可接受的最小类型，*op*表示将转换为数组的对象。返回值是表示*op*应具有的数据类型的枚举类型编号。

```py
**PyArray_ConvertToCommonType( *op, int *n)
```

此功能的功能在 1.6 中引入的迭代器`NpyIter`或所有操作数的相同 dtype 参数的标志`NPY_ITER_COMMON_DTYPE`已大部分被取代。

将包含在*op*中的 Python 对象序列转换为具有相同数据类型的 ndarrays 数组。类型的选择方式与*PyArray_ResultType*相同。序列的长度在*n*中返回，并且*n* -长度的`PyArrayObject`指针数组是返回值（如果发生错误，则返回`NULL`）。返回的数组必须由此例程的调用者释放（使用`PyDataMem_FREE`），并且其中的所有数组对象都必须`DECREF`，否则将发生内存泄漏。下面的示例模板代码显示了典型的用法：

从版本 1.18.0 开始更改：标量和零维数组的混合现在会产生一个能够容纳标量值的类型。先前优先考虑数组的 dtype。

```py
mps  =  PyArray_ConvertToCommonType(obj,  &n);
if  (mps==NULL)  return  NULL;
{code}
<before  return>
for  (i=0;  i<n;  i++)  Py_DECREF(mps[i]);
PyDataMem_FREE(mps);
{return} 
```

```py
char *PyArray_Zero( *arr)
```

指向新创建的大小为*arr* ->itemsize 的内存的指针，该内存保存该类型的 0 的表示。返回的指针*ret*在不再需要时**必须**使用`PyDataMem_FREE` (ret)释放。

```py
char *PyArray_One( *arr)
```

指向新创建的大小为*arr* ->itemsize 的内存的指针，该内存保存该类型的 1 的表示。返回的指针*ret*在不再需要时**必须**使用`PyDataMem_FREE` (ret)释放。

```py
int PyArray_ValidType(int typenum)
```

如果*typenum*表示有效的类型编号（内置或用户定义或字符代码），则返回`NPY_TRUE`。否则，此函数返回`NPY_FALSE`。

### 用户定义的数据类型

```py
void PyArray_InitArrFuncs( *f)
```

将所有函数指针和成员初始化为`NULL`。

```py
int PyArray_RegisterDataType( *dtype)
```

为数组注册一个新的用户定义的数据类型。该类型必须填充了大部分条目。这通常不会被检查，错误可能会导致段错误。特别地，`dtype` 结构的 typeobj 成员必须填充为具有与 *dtype* 的 elsize 成员对应的固定大小元素大小的 Python 类型。此外，如果不需要某些转换函数，`f` 成员必须具有所需的函数：nonzero、copyswap、copyswapn、getitem、setitem 和 cast（如果不需要支持，则一些转换函数可能为`NULL`）。为了避免混淆，应选择一个唯一的字符类型代码，但这并不是强制执行的，也不是内部依赖的。

返回一个用户定义的类型编号，用于唯一标识该类型。然后，可以使用返回的类型编号从`PyArray_DescrFromType`中获取到新结构的指针。如果发生错误，则返回-1。如果此 *dtype* 已经被注册（仅通过指针的地址进行检查），则返回先前分配的类型编号。

```py
int PyArray_RegisterCastFunc( *descr, int totype, PyArray_VectorUnaryFunc *castfunc)
```

注册低级转换函数*castfunc*，将数据类型*descr*转换为给定的数据类型编号*totype*。任何旧的转换功能都将被覆盖。成功返回`0`，失败返回`-1`。

```py
int PyArray_RegisterCanCast( *descr, int totype, scalar)
```

将数据类型编号*totype*注册为可以从给定*totype*的数据类型对象*descr*进行类型转换。使用*scalar* = `NPY_NOSCALAR`表示可以安全地将数据类型*descr*的数组转换为类型编号为*totype*的数据类型。成功返回 0，失败返回-1。

```py
int PyArray_TypeNumFromName(char const *str)
```

给定一个字符串，返回该字符串作为类型对象名称的数据类型编号。如果找不到类型，则不设置错误返回`NPY_NOTYPE`。仅适用于用户定义的数据类型。

### NPY_OBJECT 的特殊函数

警告

在处理填充有对象的数组或缓冲区时，NumPy 会尽量确保这些缓冲区在可以读取任何数据之前都填充了`None`。然而，可能存在代码路径，其中数组只被初始化为`NULL`。NumPy 本身将`NULL`视为`None`的别名，但在调试模式下可能会`assert`非`NULL`。

因为 NumPy 在初始化 None 方面还不一致，用户在处理由 NumPy 创建的缓冲区时**必须**预期得到`NULL`的值。用户**也应**确保将完全初始化的缓冲区传递给 NumPy，因为在将来 NumPy 可能会将此变为强制要求。 

目前有意确保 NumPy 总是在可能被读取之前初始化对象数组。任何不这样做的失败都将被视为一个错误。将来，用户可能可以在从任何数组中读取时依赖非 NULL 的值，尽管对于在 ufunc 代码中写入新创建的数组的输出数组可能仍然存在一些例外情况（例如，对于 NumPy 1.23 中存在的已知代码路径，没有进行正确的填充）。

```py
int PyArray_INCREF( *op)
```

用于包含任何 Python 对象的数组*op*。根据*op*的数据类型递增数组中每个对象的引用计数。如果发生错误，则返回-1，否则返回 0。

```py
void PyArray_Item_INCREF(char *ptr, *dtype)
```

用于根据数据类型*dtype*增加位置*ptr*处的所有对象的引用计数的函数。如果*ptr*是具有任何偏移量处的对象的结构类型的开头，则（递归地）增加结构类型中所有类似对象的引用计数。

```py
int PyArray_XDECREF( *op)
```

用于包含任何 Python 对象的数组*op*。根据*op*的数据类型递减数组中每个对象的引用计数。正常返回值为 0。如果发生错误，则返回-1。

```py
void PyArray_Item_XDECREF(char *ptr, *dtype)
```

用于在数据类型*dtype*中记录的位置*ptr*上的所有类似对象的函数。这样递归地工作，因此如果`dtype`本身具有包含类似对象的数据类型的字段，则所有类似对象字段都将被 XDECREF `'d`。

```py
void PyArray_FillObjectArray( *arr, *obj)
```

用单个值 obj 在所有具有对象数据类型的结构位置上填充新创建的数组。不执行任何检查，但*arr*必须是`NPY_OBJECT`数据类型的单段未初始化的拷贝（位置上没有先前的对象）。如果需要在调用此函数之前递减对象数组中的所有项，则使用`PyArray_XDECREF`(*arr*)。

```py
int PyArray_SetWritebackIfCopyBase( *arr, *base)
```

先决条件：`arr`是`base`的一个拷贝（尽管可能具有不同的步幅、顺序等）。设置`NPY_ARRAY_WRITEBACKIFCOPY`标志和`arr->base`，并将`base`设置为 READONLY。在调用*Py_DECREF*之前调用`PyArray_ResolveWritebackIfCopy`以便将任何更改复制回`base`并重置 READONLY 标志。

成功返回 0，失败返回-1。

## 数组标志

`PyArrayObject`结构的`flags`属性包含有关数组（由数据成员指向）使用的内存的重要信息。这些标志信息必须保持准确，否则可能会产生奇怪的结果，甚至可能导致段错误。

有 6 个（二进制）标志描述了数据缓冲区所使用的内存区域。这些常量在`arrayobject.h`中定义，并确定标志的位位置。Python 公开了一个良好的基于属性的接口以及一个类似字典的接口，用于获取（如果合适，则设置）这些标志。

所有种类的内存区域都可以被 ndarray 指向，因此需要这些标志。如果在 C 代码中获得一个随意的`PyArrayObject`，则需要了解设置的标志。如果需要保证某种类型的数组（例如`NPY_ARRAY_C_CONTIGUOUS`和`NPY_ARRAY_BEHAVED`），则将这些要求传递给 PyArray_FromAny 函数。

### 基本数组标志

一个 ndarray 可以有一个数据段，它不是一个简单的连续的可操作的内存块。它可能与字边界不对齐（在一些平台上非常重要）。它可能以机器不认识的另一种字节顺序存储数据。它可能是不可写的。它可能是以 Fortran 连续的顺序。数组标志用于指示与数组相关联的数据的特性。

在 NumPy 的 1.6 版本及更早版本中，以下标志没有在它们的常量名称中使用 _ARRAY_ 宏命名空间。在 1.7 中，这种常量名称形式已被弃用。

```py
NPY_ARRAY_C_CONTIGUOUS
```

数据区域是 C 风格的连续顺序（最后一个索引变化最快）。

```py
NPY_ARRAY_F_CONTIGUOUS
```

数据区域是以 Fortran 风格的连续顺序（第一个索引变化最快）。

注意

数组可以同时是 C 风格和 Fortran 风格的连续数组。对于 1 维数组很明显，但对于更高维的数组也可能成立。

即使对于连续的数组，对于给定维度的步幅`arr.strides[dim]`，如果`arr.shape[dim] == 1`或数组没有元素，则可能是*任意的*。对于 C 风格的连续数组或 Fortran 风格的连续数组，一般而言不成立`self.strides[-1] == self.itemsize`或`self.strides[0] == self.itemsize`。从 C API 访问数组的`itemsize`的正确方法是`PyArray_ITEMSIZE(arr)`。

另请参见

ndarray 的内部内存布局

```py
NPY_ARRAY_OWNDATA
```

数据区域归此数组所有。不应手动设置，而是创建一个包装数据的`PyObject`，并将数组的基设置为该对象。例如，请参见`test_mem_policy`中的测试。

```py
NPY_ARRAY_ALIGNED
```

数据区域和所有数组元素都被适当对齐。

```py
NPY_ARRAY_WRITEABLE
```

数据区域可以被写入。

注意上述三个标志被定义为新的、行为良好的数组具有这些标志为真。

```py
NPY_ARRAY_WRITEBACKIFCOPY
```

数据区域代表一个（行为良好的）副本，其信息在调用`PyArray_ResolveWritebackIfCopy`时应传递回原始数据。

这是一个特殊标志，如果这个数组表示一个用户由于在`PyArray_FromAny`中需要某些标志而制作的副本，那么必须对其他数组进行复制（并且用户要求在这种情况下设置此标志）。 然后基本属性指向“表现不当”的数组（设置为只读）。 `PyArray_ResolveWritebackIfCopy`将其内容拷贝回“表现不当”的数组（必要时进行转换），并将“表现不当”的数组重置为`NPY_ARRAY_WRITEABLE`。 如果“表现不当”的数组一开始就不是`NPY_ARRAY_WRITEABLE`，那么 `PyArray_FromAny`就会返回一个错误，因为 `NPY_ARRAY_WRITEBACKIFCOPY` 是不可能的。

`PyArray_UpdateFlags`（obj，flags）将为 `flags` 更新 `obj->flags`，可以是 `NPY_ARRAY_C_CONTIGUOUS`、`NPY_ARRAY_F_CONTIGUOUS`、`NPY_ARRAY_ALIGNED` 或 `NPY_ARRAY_WRITEABLE` 中的任意一个。

### 数组标志的组合

```py
NPY_ARRAY_BEHAVED
```

`NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`

```py
NPY_ARRAY_CARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_CARRAY_RO
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_FARRAY_RO
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_DEFAULT
```

`NPY_ARRAY_CARRAY`

```py
NPY_ARRAY_UPDATE_ALL
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

### 类似标志的常量

这些常量用于 `PyArray_FromAny`（及其宏形式）中，以指定新数组的期望属性。

```py
NPY_ARRAY_FORCECAST
```

将其转换为所需类型，即使这样做会导致信息的丢失。

```py
NPY_ARRAY_ENSURECOPY
```

确保生成的数组是原始数组的副本。

```py
NPY_ARRAY_ENSUREARRAY
```

确保生成的对象是一个实际的 ndarray，而不是一个子类。

### 标志检查

对于所有这些宏，arr 必须是（或其子类的）`PyArray_Type`的实例。

```py
int PyArray_CHKFLAGS( *arr, int flags)
```

第一个参数 arr 必须是 ndarray 或其子类。参数*flags*应该是一个整数，包含数组可以具有的可能标志的按位组合: `NPY_ARRAY_C_CONTIGUOUS`, `NPY_ARRAY_F_CONTIGUOUS`, `NPY_ARRAY_OWNDATA`, `NPY_ARRAY_ALIGNED`, `NPY_ARRAY_WRITEABLE`, `NPY_ARRAY_WRITEBACKIFCOPY`。

```py
int PyArray_IS_C_CONTIGUOUS( *arr)
```

如果 arr 是 C 风格连续的，则为真。

```py
int PyArray_IS_F_CONTIGUOUS( *arr)
```

如果 arr 是 Fortran 风格连续的，则为真。

```py
int PyArray_ISFORTRAN( *arr)
```

如果 arr 是 Fortran 风格连续的且*不是*C 风格连续的，使用`PyArray_IS_F_CONTIGUOUS`是测试 Fortran 风格连续性的正确方法。

```py
int PyArray_ISWRITEABLE( *arr)
```

如果 arr 的数据区可以写入，则为真。

```py
int PyArray_ISALIGNED( *arr)
```

如果 arr 的数据区在机器上适当对齐，则为真。

```py
int PyArray_ISBEHAVED( *arr)
```

如果 arr 的数据区对齐且可写，并且符合其描述符的机器字节顺序，则为真。

```py
int PyArray_ISBEHAVED_RO( *arr)
```

如果 arr 的数据区对齐且符合机器字节顺序，则为真。

```py
int PyArray_ISCARRAY( *arr)
```

如果 arr 的数据区是 C 风格连续的，并且`PyArray_ISBEHAVED` (*arr*)为 true，则为真。

```py
int PyArray_ISFARRAY( *arr)
```

如果 arr 的数据区是 Fortran 风格连续的，并且`PyArray_ISBEHAVED` (*arr*)为 true，则为真。

```py
int PyArray_ISCARRAY_RO( *arr)
```

如果 arr 的数据区是 C 风格连续的，对齐，并且在机器字节顺序中，则为真。

```py
int PyArray_ISFARRAY_RO( *arr)
```

如果 arr 的数据区是 Fortran 风格连续的，对齐，并且在机器字节顺序**中，则为真。

```py
int PyArray_ISONESEGMENT( *arr)
```

如果 arr 的数据区由一个（C 风格或 Fortran 风格）连续的段组成，则为真。

```py
void PyArray_UpdateFlags( *arr, int flagmask)
```

`NPY_ARRAY_C_CONTIGUOUS`、`NPY_ARRAY_ALIGNED`和`NPY_ARRAY_F_CONTIGUOUS`数组标志可以从数组对象本身“计算”出来。此例程根据*flagmask*中指定的要求执行所需的计算，更新*arr*的一个或多个这些标志。

警告

在执行可能导致这些标志发生改变的数组操作时，保持标志的更新是很重要的（可以使用`PyArray_UpdateFlags`帮助进行更新）。NumPy 中后续依赖于这些标志状态的计算不会重复计算以更新它们。

```py
int PyArray_FailUnlessWriteable( *obj, const char *name)
```

如果*obj*是可写的，则此函数不会执行任何操作并返回 0。如果*obj*不可写，则引发异常并返回-1。它也可以执行其他一些工作，例如对正在转换为视图的数组发出警告。在向数组写入之前一定要调用此函数。

*name*是数组的名称，用于提供更好的错误消息。它可以是“分配目标”、“输出数组”或甚至只是“数组”之类的东西。

## 数组方法替代 API

### 转换

```py
*PyArray_GetField( *self, *dtype, int offset)
```

等价于`ndarray.getfield`（*self*，*dtype*，*offset*）。该函数[窃取一个引用](https://docs.python.org/3/c-api/intro.html?reference-count-details)到*PyArray_Descr*，并使用当前数组中指定*offset*字节的数据返回给定*dtype*类型的新数组。新数组类型的*offset*加 itemsize 必须小于`self ->descr->elsize`，否则会引发错误。使用与原始数组相同的形状和步幅。因此，该函数的作用类似于从结构化数组中返回字段。但它也可以用于从任何数组类型中选择特定的字节或字节组。

```py
int PyArray_SetField( *self, *dtype, int offset, *val)
```

等价于`ndarray.setfield`（*self*，*val*，*dtype*，*offset*）。从*offset*字节处开始，将给定*dtype*类型的字段设置为*val*。*offset*加*dtype*→elsize 必须小于*self*→descr→elsize，否则会引发错误。否则，将*val*参数转换为数组并复制到指向的字段。必要时，将重复*val*的元素以填充目标数组，但目标数组中的元素数量必须是*val*中元素数量的整数倍。

```py
*PyArray_Byteswap( *self, inplace)
```

等价于`ndarray.byteswap`（*self*，*inplace*）。返回一个数据区域进行字节交换的数组。如果*inplace*非零，则在原地执行字节交换并返回对自身的引用。否则，创建一个进行字节交换的副本，保持原数组不变。

```py
*PyArray_NewCopy( *old, order)
```

等价于`ndarray.copy`（*self*，*fortran*）。复制*old*数组。返回的数组始终是对齐且可写的，数据解释与旧数组相同。如果*order*是`NPY_CORDER`，则返回一个 C 样式连续的数组。如果*order*是`NPY_FORTRANORDER`，则返回一个 Fortran 样式连续的数组。如果*order*是`NPY_ANYORDER`，那么只有当旧数组是 Fortran 样式连续时，才返回 Fortran 样式连续的数组；否则，就是 C 样式连续的数组。

```py
*PyArray_ToList( *self)
```

等同于`ndarray.tolist`（*self*）。从*self*返回一个嵌套的 Python 列表。

```py
*PyArray_ToString( *self, order)
```

等同于`ndarray.tobytes`（*self*，*order*）。以 Python 字符串的形式返回这个数组的字节。

```py
*PyArray_ToFile( *self, FILE *fp, char *sep, char *format)
```

以 C 风格连续的方式将*self*的内容写入文件指针*fp*。如果*sep*是字符串“”或`NULL`，则以二进制字节形式写入数据。否则，使用*sep*字符串作为项分隔符，将*self*的内容作为文本写入文件。每个项将被打印到文件中。如果*format*字符串不是`NULL`或“”，那么它是一个 Python 打印语句格式字符串，显示如何编写这些项。

```py
int PyArray_Dump( *self, *file, int protocol)
```

将*self*中的对象封装为给定的*file*（可以是字符串或 Python 文件对象）。如果*file*是 Python 字符串，则被认为是一个文件的名称，然后以二进制模式打开。使用给定的*protocol*（如果*protocol*为负值，则使用最高可用级别）。这只是 cPickle.dump(*self*, *file*, *protocol*)的一个简单封装。

```py
*PyArray_Dumps( *self, int protocol)
```

将*self*中的对象封装成 Python 字符串并返回。使用提供的 Pickle *protocol*（如果*protocol*为负值，则使用可用的最高级别）。

```py
int PyArray_FillWithScalar( *arr, *obj)
```

用给定的标量对象*obj*填充数组*arr*。首先将对象转换为*arr*的数据类型，然后将其复制到每个位置。如果发生错误，返回-1，否则返回 0。

```py
*PyArray_View( *self, *dtype, *ptype)
```

等同于`ndarray.view`（*self*，*dtype*）。将数组*self*作为可能是不同数据类型*dtype*和不同数组子类*ptype*的新视图返回。

如果*dtype*为`NULL`，则返回的数组将具有与*self*相同的数据类型。新数据类型必须与*self*的大小一致。要么项大小必须相同，要么*self*必须是单段的，总字节数必须相同。在后一种情况下，返回的数组的维度将在最后一个（或对于 Fortran 风格连续数组为第一个）维度上发生变化。返回的数组和*self*的数据区域完全相同。

### 形状操作

```py
*PyArray_Newshape( *self, *newshape, order)
```

结果将是一个新数组（如果可能的话指向与*self*相同的内存位置），但形状由*newshape*给出。如果新形状与*self*的步幅不兼容，那么将返回一个具有新指定形状的数组的副本。

```py
*PyArray_Reshape( *self, *shape)
```

等同于`ndarray.reshape`（*self*，*shape*），其中*shape*是一个序列。将*shape*转换为一个`PyArray_Dims`结构并在内部调用`PyArray_Newshape`。出于向后兼容性 - 不推荐使用

```py
*PyArray_Squeeze( *self)
```

等同于`ndarray.squeeze` (*self*)。返回一个从*self*中去除所有长度为 1 的维度的新视图。

警告

矩阵对象始终是 2 维的。因此，对矩阵子类的数组，`PyArray_Squeeze` 没有任何效果。

```py
*PyArray_SwapAxes( *self, int a1, int a2)
```

等同于`ndarray.swapaxes` (*self*, *a1*, *a2*)。返回的数组是数据在*self*中给定轴*a1*和*a2*交换后的新视图。

```py
*PyArray_Resize( *self, *newshape, int refcheck, fortran)
```

等同于`ndarray.resize` (*self*, *newshape*, refcheck `=` *refcheck*, order= fortran )。这个函数只能用于单片段数组。它会改变*self*的形状并且如果*newshape*与旧形状的元素总数不同时将重新分配*self*的内存。如果需要重新分配，则*self*必须拥有它的数据，有*self* - `>base==NULL`，有*self* - `>weakrefs==NULL`，且（除非 refcheck 为 0）不被任何其他数组引用。fortran 参数可以是`NPY_ANYORDER`，`NPY_CORDER`，或者`NPY_FORTRANORDER`。它目前没有任何效果。最终它可以用于确定重新调整操作在构建不同维度的数组时如何查看数据。成功时返回 None，错误时返回 NULL。

```py
*PyArray_Transpose( *self, *permute)
```

等同于`ndarray.transpose` (*self*, *permute*)。根据数据结构*permute*重新排列 ndarray 对象*self*的轴并返回结果。如果*permute*为`NULL`，则结果数组的轴被反转。例如，如果*self*的形状为\(10\times20\times30\)，并且*permute* `.ptr`为(0,2,1)，则结果的形状为\(10\times30\times20\)。如果*permute*为`NULL`，则结果的形状为\(30\times20\times10\)。

```py
*PyArray_Flatten( *self, order)
```

等同于`ndarray.flatten` (*self*, *order*)。返回数组的 1 维拷贝。如果*order*为`NPY_FORTRANORDER`，则按 Fortran 顺序扫描元素（第一维变化最快）。如果*order*为`NPY_CORDER`，则按 C 顺序扫描*self*的元素（最后一维变化最快）。如果*order*为`NPY_ANYORDER`，则使用`PyArray_ISFORTRAN` (*self*)的结果来确定要展平的顺序。

```py
*PyArray_Ravel( *self, order)
```

等同于 *self*.ravel(*order*)。与 `PyArray_Flatten` (*self*, *order*) 具有相同的基本功能，除非 *order* 为 0 并且 *self* 是 C 样式连续的，否则形状会改变，但不会执行复制操作。

### 项目选择和操作

```py
*PyArray_TakeFrom( *self, *indices, int axis, *ret, clipmode)
```

等同于 `ndarray.take` (*self*, *indices*, *axis*, *ret*, *clipmode*)，除了在 Python 中 *axis* =None 对应的 C 语言中 *axis* = `NPY_MAXDIMS`。沿着给定的 *axis* 提取由整数值 *indices* 指示的 self 中的项目。clipmode 参数可以是 `NPY_RAISE`、`NPY_WRAP` 或 `NPY_CLIP`，表示如何处理超出边界的索引。*ret* 参数可以指定一个输出数组，而不是在内部创建一个数组。

```py
*PyArray_PutTo( *self, *values, *indices, clipmode)
```

等同于 *self*.put(*values*, *indices*, *clipmode* )。在相应的（扁平化的）*indices* 中将 *values* 放入 *self*。如果 *values* 太小，将根据需要重复它。

```py
*PyArray_PutMask( *self, *values, *mask)
```

将 *values* 放入 *self* 中，其中对应位置（使用扁平化的上下文）在 *mask* 中为 true。*mask* 和 *self* 数组必须具有相同数量的元素。如果 *values* 太小，将根据需要重复它。

```py
*PyArray_Repeat( *self, *op, int axis)
```

等同于 `ndarray.repeat` (*self*, *op*, *axis*)。沿着给定的 *axis* 将 *self* 的元素复制 *op* 次。*op* 可以是一个标量整数或者长度为 *self* ->dimensions[ *axis* ] 的序列，指示沿着轴重复每个项目的次数。

```py
*PyArray_Choose( *self, *op, *ret, clipmode)
```

等同于 `ndarray.choose` (*self*, *op*, *ret*, *clipmode*)。根据 *self* 中的整数值从 *op* 中的数组序列中选择元素创建一个新数组。这些数组必须都可以广播到相同的形状，而 *self* 中的条目应该在 0 和 len(*op*) 之间。输出放在 *ret* 中，除非它是 `NULL`，在这种情况下会创建一个新的输出。*clipmode* 参数确定当 *self* 中的条目不在 0 和 len(*op*) 之间时的行为。

```py
NPY_RAISE
```

引发 ValueError；

```py
NPY_WRAP
```

通过添加 len(*op*) 包装值 < 0，通过减去 len(*op*) 包装值 >=len(*op*)，直到它们在范围内；

```py
NPY_CLIP
```

所有值都被剪切到区间 0, len(*op*) )。

```py
*PyArray_Sort( *self, int axis, kind)
```

等同于 [`ndarray.sort` (*self*, *axis*, *kind*)。返回沿着 *axis* 排序的 *self* 的项目数组。数组使用由 *kind* 指示的算法排序，这是一个指向使用的排序算法类型的整数/枚举。

```py
*PyArray_ArgSort( *self, int axis)
```

相当于`ndarray.argsort`(*self*, *axis*)。返回一个索引数组，以便沿给定的`axis`选择这些索引会返回一个排序后的*self*。如果*self*->descr 是带字段定义的数据类型，则会使用 self->descr->names 来确定排序顺序。 当第一个字段相等时，将使用第二个字段，以此类推。要更改结构数组的排序顺序，创建一个具有不同名称顺序的新数据类型，并使用该新数据类型构造数组的视图。

```py
*PyArray_LexSort( *sort_keys, int axis)
```

给定一个相同形状的数组序列（*sort_keys*），返回一个索引数组（类似于`PyArray_ArgSort` (…)）可按字典顺序排序数组。字典顺序指定当两个键被发现相等时，顺序是基于后续键的比较。对于类型，需要定义一种合并排序（遗留相等条目）。

如果这些数组都被收集到一个结构数组中，那么`PyArray_Sort` (…)也可以用来直接对数组进行排序。

```py
*PyArray_SearchSorted( *self, *values, side, *perm)
```

相当于`ndarray.searchsorted`(*self*, *values*, *side*, *perm*)。假设*self*是按升序排列的一维数组，那么输出就是一个与*values*相同形状的索引数组，以便按顺序插入*values*中的元素，将保持*self*的顺序。不会对*self*是否按升序进行检查。

*side*参数指示返回的索引是第一个合适位置的（如果`NPY_SEARCHLEFT`），还是最后一个的（如果`NPY_SEARCHRIGHT`）。

如果*sorter*参数不是`NULL`，必须是一个与*self*长度相同的整数索引的一维数组，用于将其按升序排序。这通常是对`PyArray_ArgSort` (…)的调用结果。二元搜索用于找到所需的插入点。

```py
int PyArray_Partition( *self, *ktharray, int axis, which)
```

相当于 `ndarray.partition`（*self*、*ktharray*、*axis*、*kind*）。分区数组，使得由*ktharray*索引的元素的值位于如果数组完全排序后它们应处的位置，并将所有小于 kth 的元素放在 kth 之前，所有等于或大于 kth 的元素放在 kth 之后。所有分区内元素的排序是未定义的。如果*self*->descr 是具有字段定义的数据类型，则使用 self->descr->names 来确定排序顺序。如果第一个字段相等，则使用第二个字段，依此类推。要更改结构化数组的排序顺序，创建一个字段名称顺序不同的新数据类型，并用这种新数据类型构造数组的视图。成功返回零，失败返回-1。

```py
*PyArray_ArgPartition( *op, *ktharray, int axis, which)
```

相当于 `ndarray.argpartition`（*self*、*ktharray*、*axis*、*kind*）。返回一个索引数组，这些索引沿着给定的`axis`选择时会返回*self*的一个分区版本。

```py
*PyArray_Diagonal( *self, int offset, int axis1, int axis2)
```

相当于 `ndarray.diagonal`（*self*、*offset*、*axis1*、*axis2*）。返回由*axis1*和*axis2*定义的 2 维数组的*offset*对角线。

```py
PyArray_CountNonzero( *self)
```

1.6 版中的新功能。

计数数组对象*self*中的非零元素数量。

```py
*PyArray_Nonzero( *self)
```

相当于 `ndarray.nonzero`（*self*）。返回一个索引数组的元组，这些索引数组选取*self*中的非零元素。如果（nd= `PyArray_NDIM`（`self`））==1，则返回一个索引数组。索引数组的数据类型为 `NPY_INTP`。如果返回的是元组（nd \(\neq\) 1），则其长度为 nd。

```py
*PyArray_Compress( *self, *condition, int axis, *out)
```

相当于 `ndarray.compress`（*self*、*condition*、*axis*）。返回沿*axis*的元素，对应于*condition*中为真的元素。

### 计算

提示

在 axis 中传入 `NPY_MAXDIMS` 以达到与在 Python 中传入`axis=None`（将数组视为一维数组）时获得的同样效果。

注意

out 参数指定结果的放置位置。如果 out 为 NULL，则创建输出数组；否则，输出将放在 out 中，out 必须具有正确的大小和类型。即使 out 不为 NULL，也总是返回对输出数组的新引用。如果 out 不为 NULL，调用此函数的人有责任使用 `Py_DECREF` out，否则将发生内存泄漏。

```py
*PyArray_ArgMax( *self, int axis, *out)
```

相当于`ndarray.argmax` (*self*, *axis*)。返回 *self* 沿 *axis* 的最大元素的索引。

```py
*PyArray_ArgMin( *self, int axis, *out)
```

相当于`ndarray.argmin` (*self*, *axis*)。返回 *self* 沿 *axis* 的最小元素的索引。

```py
*PyArray_Max( *self, int axis, *out)
```

相当于`ndarray.max` (*self*, *axis*)。返回 *self* 沿给定 *axis* 的最大元素。当结果是单个元素时，返回一个 numpy 标量而不是一个 ndarray。

```py
*PyArray_Min( *self, int axis, *out)
```

相当于`ndarray.min` (*self*, *axis*)。返回 *self* 沿给定 *axis* 的最小元素。当结果是单个元素时，返回一个 numpy 标量而不是一个 ndarray。

```py
*PyArray_Ptp( *self, int axis, *out)
```

相当于`ndarray.ptp` (*self*, *axis*)。返回 *self* 沿 *axis* 的最大元素与沿 *axis* 的最小元素之间的差异。当结果是单个元素时，返回一个 numpy 标量而不是一个 ndarray。

注意

rtype 参数指定了减少应该在其上进行的数据类型。如果数组的数据类型不足以处理输出，则这一点很重要。默认情况下，所有整数数据类型都至少与 `NPY_LONG` 一样大，用于“add”和“multiply”ufuncs（这些是平均值、和、累加和、乘积和累积乘积函数的基础）。

```py
*PyArray_Mean( *self, int axis, int rtype, *out)
```

相当于`ndarray.mean` (*self*, *axis*, *rtype*)。返回沿给定 *axis* 的元素的平均值，使用枚举类型 *rtype* 作为求和时的数据类型。默认求和行为使用 `NPY_NOTYPE` 作为 *rtype*。

```py
*PyArray_Trace( *self, int offset, int axis1, int axis2, int rtype, *out)
```

相当于`ndarray.trace` (*self*, *offset*, *axis1*, *axis2*, *rtype*)。返回由 *axis1* 和 *axis2* 变量定义的 2 维数组的 *offset* 对角线元素的总和（使用 *rtype* 作为求和的数据类型）。正偏移选择主对角线上方的对角线。负偏移选择主对角线下方的对角线。

```py
*PyArray_Clip( *self, *min, *max)
```

相当于`ndarray.clip` (*self*, *min*, *max*)。裁剪数组 *self*，使大于 *max* 的值固定为 *max*，小于 *min* 的值固定为 *min*。

```py
*PyArray_Conjugate( *self)
```

相当于`ndarray.conjugate` (*self*)。返回 *self* 的复共轭。如果 *self* 不是复数数据类型，则返回一个带有引用的 *self*。

```py
*PyArray_Round( *self, int decimals, *out)
```

等效于`ndarray.round` (*self*，*decimals*，*out*)。返回将元素四舍五入到最接近小数位的数组。小数位定义为 \(\(10^{-\textrm{decimals}}\) 位，因此负 *decimals* 导致四舍五入到最接近的 10、100 等。如果 out 为 `NULL`，则创建输出数组，否则将输出放置在 *out* 中， *out* 必须具有正确的大小和类型。

```py
*PyArray_Std( *self, int axis, int rtype, *out)
```

等效于`ndarray.std` (*self*，*axis*，*rtype*)。返回使用沿着 *axis* 转换为数据类型 *rtype* 的数据的标准差。

```py
*PyArray_Sum( *self, int axis, int rtype, *out)
```

等效于`ndarray.sum` (*self*，*axis*，*rtype*)。返回 `self` 沿着 `axis` 的元素的一维向量和。在将数据转换为数据类型 *rtype* 后执行求和。

```py
*PyArray_CumSum( *self, int axis, int rtype, *out)
```

等效于`ndarray.cumsum` (*self*，*axis*，*rtype*)。返回 `self` 沿着 `axis` 的元素的累积一维和。在将数据转换为数据类型 *rtype* 后执行求和。

```py
*PyArray_Prod( *self, int axis, int rtype, *out)
```

等效于`ndarray.prod` (*self*，*axis*，*rtype*)。返回 `self` 沿着 `axis` 的元素的一维乘积。在将数据转换为数据类型 *rtype* 后执行乘积。

```py
*PyArray_CumProd( *self, int axis, int rtype, *out)
```

等效于`ndarray.cumprod` （*self*，*axis*，*rtype*）。返回`self`沿着`axis`累积乘积的一维数组。在将数据转换为数据类型`rtype`后执行乘积。

```py
*PyArray_All( *self, int axis, *out)
```

等效于`ndarray.all` (*self*，*axis*)。对于由`axis`定义的`self`的每个一维子数组，返回具有 True 元素的数组，其中所有元素为 True。

```py
*PyArray_Any( *self, int axis, *out)
```

等效于`ndarray.any` (*self*, *axis*)。对于由*axis*定义的*self*的每个一维子数组，返回具有 True 元素的数组，其中任何元素为 True。

## 函数

### 数组函数

```py
int PyArray_AsCArray( **op, void *ptr, *dims, int nd, *typedescr)
```

有时，将多维数组视为 C 风格的多维数组是有用的，以便可以使用 C 的 a[i][j][k] 语法实现算法。此例程返回一个指针，*ptr*，模拟这种类型的 C 风格数组，用于 1、2 和 3 维 ndarrays。

参数：

+   **op** – 任何 Python 对象的地址。此 Python 对象将被替换为等效的良好行为的、C 风格的连续的给定数据类型的 ndarray。请确保以这种方式窃取输入对象的引用是合理的。

+   **ptr** – 一个（1-d 的 ctype*，2-d 的 ctype**，或 3-d 的 ctype***）变量的地址，其中 ctype 是该数据类型的等效 C 类型。在返回时，*ptr*将作为 1-d，2-d 或 3-d 数组可寻址。

+   **dims** – 一个包含数组对象形状的输出数组。这个数组给出了任何即将发生的循环的边界。

+   **nd** – 数组的维度（1、2 或 3）。

+   **typedescr** – 一个 `PyArray_Descr` 结构，表示所需的数据类型（包括所需的字节顺序）。该调用将会窃取参数的引用。

注意

对于 2-d 和 3-d 数组，C 风格数组的模拟是不完整的。例如，模拟的指针数组不能传递给期望特定的静态定义的 2-d 和 3-d 数组的子例程。要传递给需要这些类型输入的函数，必须静态定义所需的数组并复制数据。

```py
int PyArray_Free( *op, void *ptr)
```

必须与从`PyArray_AsCArray`返回的相同对象和内存位置一起调用（…）。此函数清理了否则将会泄漏的内存。

```py
*PyArray_Concatenate( *obj, int axis)
```

将*obj*中的对象序列沿着*axis*合并成单个数组。如果维度或类型不兼容，则会引发错误。

```py
*PyArray_InnerProduct( *obj1, *obj2)
```

在*obj1*和*obj2*的最后维度上计算一个积和。两个数组都不是共轭的。

```py
*PyArray_MatrixProduct( *obj1, *obj)
```

在*obj1*的最后一个维度和*obj2*的倒数第二个维度上计算一个积和。对于 2-d 数组而言，这是一个矩阵积。两个数组都不是共轭的。

```py
*PyArray_MatrixProduct2( *obj1, *obj, *out)
```

自 1.6 版本新增。

与 PyArray_MatrixProduct 相同，但将结果存储在*out*中。输出数组必须具有正确的形状、类型，并且是 C 连续的，否则将引发异常。

```py
*PyArray_EinsteinSum(char *subscripts, nop, **op_in, *dtype, order, casting, *out)
```

自 1.6 版本新增。

对所提供的数组操作数应用爱因斯坦求和约定，返回一个新数组或将结果放在*out*中。*subscripts*中的字符串是索引字母的逗号分隔列表。操作数数量由*nop*确定，*op_in*是包含这些操作数的数组。可以使用*dtype*强制输出的数据类型，可以使用*order*强制输出的顺序（推荐使用`NPY_KEEPORDER`），当指定*dtype*时，*casting*表示数据转换应该有多宽容。

有关更多细节，请参见`einsum`函数。

```py
*PyArray_CopyAndTranspose( *op)
```

一个仅适用于 2-d 数组的专门的复制和转置函数。返回的数组是*op*的转置副本。

```py
*PyArray_Correlate( *op1, *op2, int mode)
```

计算 1-d 数组*op1*和*op2*的 1-d 相关性。相关性是通过将*op1*乘以*op2*的一个移位版本并求和来计算的。由于移位，*op1*和*op2*定义范围之外所需的值被解释为零。模式确定要返回多少移位：0 - 仅返回不需要假设零值的移位；1 - 返回一个与*op1*大小相同的对象；2 - 返回所有可能的移位（任何重叠都被接受）。

注意

这不计算通常的相关性：如果 op2 比 op1 大，则会交换参数，并且对于复杂数组，永远不会进行共轭。有关通常的信号处理相关性，请参见 PyArray_Correlate2。

```py
*PyArray_Correlate2( *op1, *op2, int mode)
```

更新版本的 PyArray_Correlate，它使用了 1d 数组的常规相关定义。相关性是通过在每个输出点上将*op1*乘以*op2*的一个移位版本并求和来计算的。由于移位， *op1* 和 *op2* 定义范围之外所需的值被解释为零。模式确定要返回多少移位：0 - 仅返回不需要假设零值的移位；1 - 返回一个与*op1*大小相同的对象；2 - 返回所有可能的移位（任何重叠都被接受）。

注意

计算 z 如下：

```py
z[k] = sum_n op1[n] * conj(op2[n+k]) 
```

```py
*PyArray_Where( *condition, *x, *y)
```

如果`x`和`y`都是`NULL`，那么返回`PyArray_Nonzero`(*condition*)。否则，*x*和*y*必须都给出且返回的对象的形状与*condition*相同，并且在*condition*分别为 True 或 False 时的元素是*x*和*y*。

### 其他函数

```py
PyArray_CheckStrides(int elsize, int nd, numbytes, const *dims, const *newstrides)
```

确定*newstrides*是否是与具有形状`dims`和元素大小*elsize*的*nd*维数组的内存一致的跨度数组。将检查*newstrides*数组，以查看每个方向跳跃所需的字节数是否会超过*numbytes*，而*numbytes*是可用内存段的假定大小。如果*numbytes*为 0，那么将计算出一个等效的*numbytes*，假设*nd*，*dims*和*elsize*指的是单段数组。如果*newstrides*可接受，则返回`NPY_TRUE`，否则返回`NPY_FALSE`。

```py
PyArray_MultiplyList( const *seq, int n)
```

```py
int PyArray_MultiplyIntList(int const *seq, int n)
```

这两个例程都会将*n*长度的整数数组*seq*相乘并返回结果。不执行溢出检查。

```py
int PyArray_CompareLists( const *l1, const *l2, int n)
```

给定两个长度为*n*的整数数组*l1*和*l2*，如果列表相同，则返回 1；否则，返回 0。

## 具有对象语义的辅助数据

版本 1.7.0 中的新内容。

```py
type NpyAuxData
```

在使用更复杂的由其他 dtype 组成的 dtype（例如 struct dtype）时，创建操作 dtype 的内部循环需要携带额外的数据。NumPy 通过一个 struct `NpyAuxData`来支持这个想法，要求一些约定，以便可以做到这一点。

定义`NpyAuxData`类似于在 C++中定义类，但由于 API 是用 C 编写的，因此必须手动跟踪对象语义。以下是使用元素复制函数作为原始函数来双倍元素的函数的示例。

```py
typedef  struct  {
  NpyAuxData  base;
  ElementCopier_Func  *func;
  NpyAuxData  *funcdata;
}  eldoubler_aux_data;

void  free_element_doubler_aux_data(NpyAuxData  *data)
{
  eldoubler_aux_data  *d  =  (eldoubler_aux_data  *)data;
  /* Free the memory owned by this auxdata */
  NPY_AUXDATA_FREE(d->funcdata);
  PyArray_free(d);
}

NpyAuxData  *clone_element_doubler_aux_data(NpyAuxData  *data)
{
  eldoubler_aux_data  *ret  =  PyArray_malloc(sizeof(eldoubler_aux_data));
  if  (ret  ==  NULL)  {
  return  NULL;
  }

  /* Raw copy of all data */
  memcpy(ret,  data,  sizeof(eldoubler_aux_data));

  /* Fix up the owned auxdata so we have our own copy */
  ret->funcdata  =  NPY_AUXDATA_CLONE(ret->funcdata);
  if  (ret->funcdata  ==  NULL)  {
  PyArray_free(ret);
  return  NULL;
  }

  return  (NpyAuxData  *)ret;
}

NpyAuxData  *create_element_doubler_aux_data(
  ElementCopier_Func  *func,
  NpyAuxData  *funcdata)
{
  eldoubler_aux_data  *ret  =  PyArray_malloc(sizeof(eldoubler_aux_data));
  if  (ret  ==  NULL)  {
  PyErr_NoMemory();
  return  NULL;
  }
  memset(&ret,  0,  sizeof(eldoubler_aux_data));
  ret->base->free  =  &free_element_doubler_aux_data;
  ret->base->clone  =  &clone_element_doubler_aux_data;
  ret->func  =  func;
  ret->funcdata  =  funcdata;

  return  (NpyAuxData  *)ret;
} 
```

```py
type NpyAuxData_FreeFunc
```

NpyAuxData 释放函数的函数指针类型。

```py
type NpyAuxData_CloneFunc
```

NpyAuxData 克隆函数的函数指针类型。这些函数在错误时不应设置 Python 异常，因为它们可能会在多线程上下文中被调用。

```py
void NPY_AUXDATA_FREE( *auxdata)
```

一个宏，适当地调用辅助数据的释放函数，如果 auxdata 为 NULL 则不执行任何操作。

```py
*NPY_AUXDATA_CLONE( *auxdata)
```

一个宏，适当地调用辅助数据的克隆函数，返回辅助数据的深层副本。

## 数组迭代器

自 NumPy 1.6.0 起，这些数组迭代器已被新的数组迭代器`NpyIter`取代。

数组迭代器是一种快速有效地访问 N 维数组元素的简单方法，如示例所示，该示例提供了关于从 C 中循环遍历数组的此有用方法的更多描述。

```py
*PyArray_IterNew( *arr)
```

从数组*arr*返回一个数组迭代器对象。这相当于*arr*。**flat**。数组迭代器对象使得以 C 风格连续方式循环遍历 N 维非连续数组变得容易。

```py
*PyArray_IterAllButAxis( *arr, int *axis)
```

返回一个数组迭代器，它将遍历除了**axis*之外的所有轴。返回的迭代器不能与`PyArray_ITER_GOTO1D`一起使用。该迭代器可用于编写类似于 ufunc 的东西，其中最大轴的循环由单独的子例程完成。如果**axis*为负，则将**axis*设置为具有最小步幅的轴，并使用该轴。

```py
*PyArray_BroadcastToShape( *arr, const *dimensions, int nd)
```

返回一个广播为按*dimensions*和*nd*提供的形状的数组的数组迭代器。

```py
int PyArrayIter_Check( *op)
```

如果*op*是数组迭代器（或数组迭代器类型的子类的实例），则评估为 true。

```py
void PyArray_ITER_RESET( *iterator)
```

将*iterator*重置为数组的开头。

```py
void PyArray_ITER_NEXT( *iterator)
```

将*iterator*的索引和 dataptr 成员递增，指向数组的下一个元素。如果数组不是（C 风格的）连续的，则还要递增 N 维坐标数组。

```py
void *PyArray_ITER_DATA( *iterator)
```

数组的当前元素的指针。

```py
void PyArray_ITER_GOTO( *iterator, *destination)
```

将*iterator*的索引、dataptr 和 coordinates 成员设置为由 N 维 C 数组*destination*指示的数组位置，*destination*的大小必须至少为*iterator*->nd_m1+1。

```py
void PyArray_ITER_GOTO1D( *iterator, index)
```

将*iterator*的索引和 dataptr 设置为由整数*index*指示的位置，该位置指向 C 风格展开的数组中的元素。

```py
int PyArray_ITER_NOTDONE( *iterator)
```

只要迭代器尚未遍历所有元素，就将 TRUE 评估为真，否则评估为假。

## 广播（多迭代器）

```py
*PyArray_MultiIterNew(int num, ...)
```

广播的简化接口。此函数接受要进行广播的数组数量，然后获取 *num* 个额外的 ( [`PyObject *`](https://docs.python.org/3/c-api/structures.html#c.PyObject "(in Python v3.11)") ) 参数。这些参数将被转换为数组，并创建迭代器。然后在得到的多迭代器对象上调用 `PyArray_Broadcast`。然后返回产生的广播多迭代器对象。然后可以使用单个循环执行广播操作，并使用 `PyArray_MultiIter_NEXT` (..)

```py
void PyArray_MultiIter_RESET( *multi)
```

重置多迭代器对象 *multi* 中所有迭代器到开始位置。

```py
void PyArray_MultiIter_NEXT( *multi)
```

将多迭代器对象 *multi* 中的每个迭代器推进到其下一个（广播的）元素。

```py
void *PyArray_MultiIter_DATA( *multi, int i)
```

返回多迭代器对象中第 *i* \(^{\textrm{th}}\) 迭代器的数据指针。

```py
void PyArray_MultiIter_NEXTi( *multi, int i)
```

仅推进第 *i* \(^{\textrm{th}}\) 迭代器的指针。

```py
void PyArray_MultiIter_GOTO( *multi, *destination)
```

将多迭代器对象 *multi* 中的每个迭代器推进到给定的 \(N\) -维度 *destination*，其中 \(N\) 是广播数组中的维数。

```py
void PyArray_MultiIter_GOTO1D( *multi, index)
```

将多迭代器对象 *multi* 中的每个迭代器推进到展开广播数组中 *index* 的相应位置。

```py
int PyArray_MultiIter_NOTDONE( *multi)
```

只要多迭代器还没有遍历所有元素（广播结果的元素），它就会评估为 TRUE，否则评估为 FALSE。

```py
int PyArray_Broadcast( *mit)
```

此函数封装了广播规则。*mit* 容器应已包含需要进行广播的所有数组的迭代器。返回时，这些迭代器将被调整，以便同时迭代每个数组可以完成广播。如果发生错误，将返回负数。

```py
int PyArray_RemoveSmallest( *mit)
```

此函数接受先前已经“广播”的多迭代器对象，找到在广播结果中具有最小“步幅总和”的维度，并调整所有迭代器，以便在该维度上不进行迭代（实际上使它们在该维度上的长度为 1）。返回相应的维度，除非 *mit* ->nd 为 0，那么返回 -1 。此函数对构造类似 ufunc 的例程非常有用，这些例程正确广播它们的输入，然后调用该例程的跨步 1-d 版本作为内部循环。此 1-d 版本通常被优化为速度，因此应该沿着不需要大跨度跳跃的轴执行循环。

## 邻域迭代器

1.4.0 版的新增内容。

邻域迭代器是迭代器对象的子类，可用于迭代某一点的邻域。例如，您可能希望对 3D 图像的每个体素进行迭代，并对每个这样的体素进行超立方体的迭代。邻域迭代器会自动处理边界，因此使得这种代码的编写比手动处理边界容易得多，尽管会稍微增加一些开销。

```py
*PyArray_NeighborhoodIterNew( *iter, bounds, int mode, *fill_value)
```

这个函数会根据 iter 当前指向的位置相对地创建一个新的邻域迭代器，bounds 定义了邻域迭代器的形状，mode 参数定义了边界处理模式。

*bounds*参数应该是一个(2 * iter->ao->nd)的数组，比如范围 bound[2*i]->bounds[2*i+1]定义了维度 i 上的范围（两个边界都包括在内）。每个维度的边界都应该是有序的（bounds[2*i] <= bounds[2*i+1]）。

mode 应该是以下之一：

```py
NPY_NEIGHBORHOOD_ITER_ZERO_PADDING
```

零填充。超出边界的值将会是 0。

```py
NPY_NEIGHBORHOOD_ITER_ONE_PADDING
```

单一填充，超出边界的值将会是 1。

```py
NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING
```

常量填充。超出边界的值将与 fill_value 的第一个项目相同。

```py
NPY_NEIGHBORHOOD_ITER_MIRROR_PADDING
```

镜像填充。超出边界的值将会像数组项一样做镜像处理。例如，对于数组 [1, 2, 3, 4]，x[-2] 将会是 2，x[-2] 将会是 1，x[4] 将会是 4，x[5] 将会是 1，依此类推…

```py
NPY_NEIGHBORHOOD_ITER_CIRCULAR_PADDING
```

循环填充。超出边界的值将会被看作数组重复的值。例如，对于数组 [1, 2, 3, 4]，x[-2] 将会是 3，x[-2] 将会是 4，x[4] 将会是 1，x[5] 将会是 2，依此类推…

如果 mode 是常量填充（*NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING*），fill_value 应该指向一个保存填充值的数组对象（如果数组包含多个项目，第一个项目将是填充值）。对于其他情况，fill_value 可以是 NULL。

+   迭代器持有对 iter 的引用

+   失败时返回 NULL（在这种情况下，iter 的引用计数不会改变）

+   iter 本身可以是一个邻域迭代器：这对于自动处理边界很有用。

+   这个函数返回的对象应该可以安全地用作普通迭代器

+   如果 iter 的位置被改变，任何对 PyArrayNeighborhoodIter_Next 的后续调用都是未定义行为，并且必须调用 PyArrayNeighborhoodIter_Reset。

+   如果 iter 的位置不是数据的开头，并且 iter 的底层数据是连续的，那么迭代器会指向数据的开头，而不是 iter 指向的位置。为了避免这种情况，应该在创建迭代器后只移动 iter 到所需位置，并且必须调用 PyArrayNeighborhoodIter_Reset。

```py
PyArrayIterObject  *iter;
PyArrayNeighborhoodIterObject  *neigh_iter;
iter  =  PyArray_IterNew(x);

/*For a 3x3 kernel */
bounds  =  {-1,  1,  -1,  1};
neigh_iter  =  (PyArrayNeighborhoodIterObject*)PyArray_NeighborhoodIterNew(
  iter,  bounds,  NPY_NEIGHBORHOOD_ITER_ZERO_PADDING,  NULL);

for(i  =  0;  i  <  iter->size;  ++i)  {
  for  (j  =  0;  j  <  neigh_iter->size;  ++j)  {
  /* Walk around the item currently pointed by iter->dataptr */
  PyArrayNeighborhoodIter_Next(neigh_iter);
  }

  /* Move to the next point of iter */
  PyArrayIter_Next(iter);
  PyArrayNeighborhoodIter_Reset(neigh_iter);
} 
```

```py
int PyArrayNeighborhoodIter_Reset( *iter)
```

将迭代器位置重置到邻域的第一个点。每当在 PyArray_NeighborhoodIterObject 中给定 iter 参数被改变时，都应该调用这个函数（参见示例）。

```py
int PyArrayNeighborhoodIter_Next( *iter)
```

调用此函数后，iter->dataptr 指向邻域的下一个点。在访问邻域的每个点后调用这个函数是未定义的。

## 数组映射

数组映射是高级索引背后的机制。

```py
*PyArray_MapIterArray( *a, *index)
```

使用高级索引来迭代一个数组。

```py
void PyArray_MapIterSwapAxes( *mit, **ret, int getmap)
```

交换轴以插入或从插入的形式中取消。`MapIter`始终将高级（数组）索引放在迭代中的第一位。但如果它们是连续的，它将在返回之前插入/转置它们。这存储为`mit->consec != 0`（它们被插入的位置）。对于赋值，相反会发生: 要分配的值会被转置（`getmap=1`而不是`getmap=0`）。`getmap=0`和`getmap=1`会撤消另一个操作。

```py
void PyArray_MapIterNext( *mit)
```

此函数需要更新地图迭代器的状态，并将`mit->dataptr`指向下一个对象的内存位置。

请注意，此函数从不处理额外的操作数，但提供了旧（已公开）API 的兼容性。

```py
*PyArray_MapIterArrayCopyIfOverlap( *a, *index, int copy_if_overlap, *extra_op)
```

类似于`PyArray_MapIterArray`，但有一个额外的`copy_if_overlap`参数。如果`copy_if_overlap != 0`，则检查`a`是否与`index`中的任何数组以及`extra_op`有内存重叠，并根据需要进行复制，以避免在迭代过程中修改输入时出现问题。`iter->array`可能包含一个已复制的数组（设置了 WRITEBACKIFCOPY）。

## 数组标量

```py
*PyArray_Return( *arr)
```

此函数窃取对*arr*的引用。

此函数检查*arr*是否为 0 维数组，如果是，则返回适当的数组标量。每当可能返回 0 维数组到 Python 时应使用此函数。

```py
*PyArray_Scalar(void *data, *dtype, *base)
```

通过**复制**从由*data*指向的内存中返回给定*dtype*的数组标量对象。如果*dtype*是`void`标量，则期望*base*是拥有数据的数组对象。如果设置了`NPY_USE_GETITEM`标志，并且知道`getitem`方法使用`arr`参数而不检查它是否为`NULL`，则需要*base*。否则*base*可以是`NULL`。

如果数据不是本机字节顺序（由`dtype->byteorder`指示），那么此函数将进行字节交换，因为数据总是处于正确的机器字节顺序中。

```py
*PyArray_ToScalar(void *data, *arr)
```

从由*data*指向的内存中复制以及如果*arr*中的数据不是机器字节顺序则进行交换，返回*arr*指示的给定*dtype*的数组标量对象。

```py
*PyArray_FromScalar( *scalar, *outcode)
```

从*scalar*中返回一个由*outcode*确定类型的 0 维数组，*scalar*应该是一个数组标量对象。如果*outcode*为 NULL，则类型从*scalar*确定。

```py
void PyArray_ScalarAsCtype( *scalar, void *ctypeptr)
```

在*ctypeptr*中返回一个指向数组标量中实际值的指针。没有错误检查，因此*scalar*必须是一个数组标量对象，而 ctypeptr 必须有足够的空间来容纳正确的类型。

```py
void PyArray_CastScalarToCtype( *scalar, void *ctypeptr, *outcode)
```

将数组标量*scalar*中的数据（转换为*outcode*指示的数据类型）返回到由*ctypeptr*指向的内存中（必须足够大以处理传入的内存）。

```py
*PyArray_TypeObjectFromType(int type)
```

从类型编号*type*返回一个标量类型对象。等效于`PyArray_DescrFromType` (*type*)->typeobj，除了引用计数和错误检查。成功时返回对类型对象的新引用，失败时返回`NULL`。

```py
PyArray_ScalarKind(int typenum, **arr)
```

详见函数`PyArray_MinScalarType`，介绍了 NumPy 1.6.0 中引入的另一种机制。

返回由*typenum*和**arr*（如果*arr*不是`NULL`）所代表的标量的种类和数组。假定数组的秩为 0，仅当*typenum*表示有符号整数时使用*arr*。如果*arr*不是`NULL`并且第一个元素为负数，则返回`NPY_INTNEG_SCALAR`，否则返回`NPY_INTPOS_SCALAR`。可能的返回值是`NPY_SCALARKIND`中的枚举值。

```py
int PyArray_CanCoerceScalar(char thistype, char neededtype, scalar)
```

详细了解 NumPy 类型提升的功能`PyArray_ResultType`，在 NumPy 1.6.0 中更新。

实现标量强制转换的规则。只有当此函数返回非零值时，标量才能从这种类型默默地转换为所需类型。如果标量为`NPY_NOSCALAR`，则此函数等效于`PyArray_CanCastSafely`。规则是，相同种类的标量可以强制转换为相同种类的数组。这条规则意味着高精度标量永远不会导致相同种类的低精度数组被向上转换。

## 数据类型描述符

警告

数据类型对象必须引用计数，因此要注意不同的 C-API 调用对数据类型引用的影响。标准规则是，当返回一个数据类型对象时，这是一个新引用。接受 PyArray_Descr*对象并返回数组的函数会窃取对其输入数据类型的引用，除非另有说明。因此，您必须拥有作为此类函数输入的任何数据类型对象的引用。

```py
int PyArray_DescrCheck( *obj)
```

如果*obj*是数据类型对象（PyArray_Descr*），则评估为真。

```py
*PyArray_DescrNew( *obj)
```

返回从*obj*（如果有 fields 字典，则更新引用）复制的新数据类型对象。

```py
*PyArray_DescrNewFromType(int typenum)
```

从内置（或用户注册）的数据类型中创建一个新的数据类型对象，指示*typenum*。所有内置类型不应更改其任何字段。这将创建`PyArray_Descr`结构的一个新副本，以便您可以适当地填入它。这个函数对于需要在数组构造中具有新 elsize 成员的灵活数据类型尤为重要。

```py
*PyArray_DescrNewByteorder( *obj, char newendian)
```

创建一个新的数据类型对象，其中字节顺序按照*newendian*设置。所有引用的数据类型对象（在数据类型对象的 subdescr 和 fields 成员中）也会进行更改（递归）。

*newendian*的值是以下这些宏之一：

```py
NPY_IGNORE
```

```py
NPY_SWAP
```

```py
NPY_NATIVE
```

```py
NPY_LITTLE
```

```py
NPY_BIG
```

如果遇到`NPY_IGNORE`的字节顺序，它将保持不变。如果 newendian 为`NPY_SWAP`，则会交换所有字节顺序。其他有效的 newendian 值为`NPY_NATIVE`、`NPY_LITTLE`和`NPY_BIG`，它们都会导致返回的数据类型描述符（以及所有引用的数据类型描述符）具有相应的字节顺序。

```py
*PyArray_DescrFromObject( *op, *mintype)
```

从对象*op*（应为“嵌套”序列对象）和最小数据类型描述符 mintype（可以为`NULL`）确定合适的数据类型对象。行为类似于 array(*op*).dtype。不要将此函数与`PyArray_DescrConverter`混淆。该函数主要查看（嵌套）序列中的所有对象，并根据找到的元素确定数据类型。

```py
*PyArray_DescrFromScalar( *scalar)
```

从数组标量对象返回一个数据类型对象。不会检查*scalar*是否为数组标量。如果无法确定合适的数据类型，则默认返回一个`NPY_OBJECT`数据类型。

```py
*PyArray_DescrFromType(int typenum)
```

返回与*typenum*相对应的数据类型对象。*typenum*可以是枚举类型之一，用于枚举类型之一的字符代码，或用户定义的类型。如果要使用可变大小数组，则需要`flexible typenum`并将结果`elsize`参数设置为所需的大小。typenum 是`NPY_TYPES`之一。

```py
int PyArray_DescrConverter( *obj, **dtype)
```

将任何兼容的 Python 对象*obj*转换为数据类型对象在*dtype*中。大量 Python 对象可以转换为数据类型对象。有关完整描述，请参见数据类型对象（dtype）。此转换器的版本将 None 对象转换为`NPY_DEFAULT_TYPE`数据类型对象。此函数可与 PyArg_ParseTuple 处理中的“O&”字符代码一起使用。

```py
int PyArray_DescrConverter2( *obj, **dtype)
```

将任何兼容的 Python 对象*obj*转换为*dtype*中的数据类型对象。此转换器的版本将 None 对象转换为返回的数据类型为`NULL`。此函数也可与 PyArg_ParseTuple 处理中的“O&”字符一起使用。

```py
int Pyarray_DescrAlignConverter( *obj, **dtype)
```

与`PyArray_DescrConverter`类似，但它会将类似于 C 结构的对象与编译器对齐在字边界上。

```py
int Pyarray_DescrAlignConverter2( *obj, **dtype)
```

与`PyArray_DescrConverter2`类似，但它将 C 结构对象与编译器一样对齐到字边界。

```py
*PyArray_FieldNames( *dict)
```

获取字段字典 *dict*，例如附加到数据类型对象的字典，并构造一个字段名称的有序列表，例如存储在`PyArray_Descr`对象的 names 字段中。

## 转换工具

### 用于 [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(in Python v3.11)")

所有这些函数都可以在 [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(in Python v3.11)") (…) 中使用“O&”格式说明符，自动将任何 Python 对象转换为所需的 C 对象。所有这些函数如果成功则返回`NPY_SUCCEED`，如果失败则返回`NPY_FAIL`。所有这些函数的第一个参数是一个 Python 对象。第二个参数是要将 Python 对象转换为的 C 类型的 **address**。

警告

确保理解在使用这些转换函数时应该采取哪些步骤来管理内存。这些函数可能需要释放内存，并且/或者根据您的使用情况更改特定对象的引用计数。

```py
int PyArray_Converter( *obj, **address)
```

将任何 Python 对象转换为`PyArrayObject`。如果 `PyArray_Check` （*obj*）为真，则增加其引用计数并将引用放入 *address* 中。如果 *obj* 不是数组，则使用 `PyArray_FromAny` 将其转换为数组。无论返回什么，当完成后你必须在 *address* 中减少此函数返回的对象的引用计数。

```py
int PyArray_OutputConverter( *obj, **address)
```

这是给定给函数的输出数组的默认转换器。如果 *obj* 是[`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)")或 `NULL`，那么 **address* 将为 `NULL` 但调用将成功。如果 `PyArray_Check` （*obj*）为真，则在不增加其引用计数的情况下将其返回到 **address* 中。

```py
int PyArray_IntpConverter( *obj, *seq)
```

将任何小于`NPY_MAXDIMS`的 Python 序列 *obj* 转换为`npy_intp`的 C 数组。Python 对象也可以是单个数字。*seq* 变量是一个具有成员 ptr 和 len 的结构体指针。成功返回时，*seq* ->ptr 包含必须通过调用 `PyDimMem_FREE` 来释放内存以避免内存泄漏的内存指针。对内存大小的限制使得可以方便地将此转换器用于预期被解释为数组形状的序列。

```py
int PyArray_BufferConverter( *obj, *buf)
```

把任何 Python 对象 *obj*，具有（单段）缓冲区接口的，转换为具有详细描述对象内存块使用情况的成员的变量。*buf* 变量是指向具有 base、ptr、len 和 flags 成员的结构体的指针。`PyArray_Chunk` 结构体在 32 位平台上通过其 len 成员和 64 位平台上的 ptr 成员与 Python 的缓冲区对象二进制兼容。返回时，base 成员设置为 *obj*（或其基类，如果 *obj* 已经是指向另一个对象的缓冲区对象）。如果需要保留内存，请确保增加 base 成员的引用计数。内存块由 *buf*->ptr 成员指向，并且长度为 *buf*->len。 *buf* 的 flags 成员是 `NPY_ARRAY_ALIGNED`，如果 *obj* 具有可写的缓冲区接口，则设置`NPY_ARRAY_WRITEABLE` 标志。

```py
int PyArray_AxisConverter( *obj, int *axis)
```

将 Python 对象 *obj* 表示的轴参数转换为传递给接受整数轴的函数的正确值。具体来说，如果 *obj* 是 None，则 *axis* 设置为`NPY_MAXDIMS`，这由接受轴参数的 C-API 函数正确解释。

```py
int PyArray_BoolConverter( *obj, *value)
```

把任何 Python 对象 *obj* 转换为 `NPY_TRUE` 或 `NPY_FALSE`，并将结果放入 *value* 中。

```py
int PyArray_ByteorderConverter( *obj, char *endian)
```

将 Python 字符串转换为对应的字节顺序字符：‘>’、‘<’、‘s’、‘=’ 或 ‘|’。

```py
int PyArray_SortkindConverter( *obj, *sort)
```

将 Python 字符串转换为其中之一的`NPY_QUICKSORT`（以‘q’或‘Q’开头），`NPY_HEAPSORT`（以‘h’或‘H’开头），`NPY_MERGESORT`（以‘m’或‘M’开头）或 `NPY_STABLESORT` （以‘t’或‘T’开头）。`NPY_MERGESORT`和 `NPY_STABLESORT` 是为了向后兼容而彼此别名，并且基于数据类型可能指代多种稳定的排序算法之一。

```py
int PyArray_SearchsideConverter( *obj, *side)
```

将 Python 字符串转换为其中之一的`NPY_SEARCHLEFT`（以‘l’或‘L’开头），或`NPY_SEARCHRIGHT`（以‘r’或‘R’开头）。

```py
int PyArray_OrderConverter( *obj, *order)
```

将 Python 字符串 ‘C’、‘F’、‘A’ 和 ‘K’ 转换为 `NPY_ORDER` 枚举`NPY_CORDER`、`NPY_FORTRANORDER`、`NPY_ANYORDER` 和 `NPY_KEEPORDER`。

```py
int PyArray_CastingConverter( *obj, *casting)
```

将 Python 字符串‘no’、‘equiv’、‘safe’、‘same_kind’和‘unsafe’转换为`NPY_CASTING` 枚举`NPY_NO_CASTING`、`NPY_EQUIV_CASTING`、`NPY_SAFE_CASTING`、`NPY_SAME_KIND_CASTING`和`NPY_UNSAFE_CASTING`。

```py
int PyArray_ClipmodeConverter( *object, *val)
```

将 Python 字符串‘clip’、‘wrap’和‘raise’转换为`NPY_CLIPMODE` 枚举 `NPY_CLIP`、`NPY_WRAP`和`NPY_RAISE`。

```py
int PyArray_ConvertClipmodeSequence( *object, *modes, int n)
```

将一系列剪裁模式或单个剪裁模式转换为`NPY_CLIPMODE`值的 C 数组。在调用此函数之前必须知道剪裁模式*n*的数量。为了帮助函数允许每个维度选择不同的剪裁模式，提供了此函数。

### 其他转换

```py
int PyArray_PyIntAsInt( *op)
```

将所有类型的 Python 对象（包括数组和数组标量）转换为标准整数。发生错误时返回-1 并设置异常。您可能会发现宏有用：

```py
#define error_converting(x) (((x) == -1) && PyErr_Occurred()) 
```

```py
PyArray_PyIntAsIntp( *op)
```

将所有类型的 Python 对象（包括数组和数组标量）转换为（平台指针大小的）整数。发生错误时返回-1 并设置异常。

```py
int PyArray_IntpFromSequence( *seq, *vals, int maxvals)
```

将传入的任何 Python 序列（或单个 Python 数字）*seq* 转换为（最多）*maxvals* 个指针大小的整数，并将它们放入 *vals* 数组中。由于转换对象的数量会返回，所以序列可以比 *maxvals* 小。

```py
int PyArray_TypestrConvert(int itemsize, int gentype)
```

将类型字符串字符（带 *itemsize*）转换为基本的枚举数据类型。识别并转换了符号和无符号整数、浮点数和复数浮点数对应的类型字符串字符。返回其他值的 gentype。例如，此函数可用于将字符串‘f4’转换为`NPY_FLOAT32`。

## 杂项

### 导入 API

为了从另一个扩展模块中使用 C-API，必须调用`import_array`函数。如果扩展模块是一个单独的.c 文件，那么只需要做这些。然而，如果扩展模块涉及需要 C-API 的多个文件，则必须采取一些额外的步骤。

```py
void import_array(void)
```

必须在将使用 C-API 的模块的初始化部分中调用此函数。它将导入存储函数指针表的模块，并将正确的变量指向它。

```py
PY_ARRAY_UNIQUE_SYMBOL
```

```py
NO_IMPORT_ARRAY
```

使用这些 #defines，你可以在单个扩展模块的多个文件中使用 C-API。在每个文件中，你必须将 `PY_ARRAY_UNIQUE_SYMBOL` 定义为一个将保存 C-API 的名称（*例如* myextension_ARRAY_API）。这必须在包含 numpy/arrayobject.h 文件之前完成。在模块初始化例程中，你调用 `import_array`。此外，在没有模块初始化子例程的文件中，在包含 numpy/arrayobject.h 之前定义 `NO_IMPORT_ARRAY`。

假设我有两个文件 coolmodule.c 和 coolhelper.c 需要编译并链接成一个单独的扩展模块。假设 coolmodule.c 包含所需的 initcool 模块初始化函数（调用了 import_array() 函数）。那么，coolmodule.c 将包含如下内容：

```py
#define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API
#include numpy/arrayobject.h 
```

另一方面，coolhelper.c 将包含如下内容：

```py
#define NO_IMPORT_ARRAY
#define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API
#include numpy/arrayobject.h 
```

你也可以将常见的最后两行放入扩展本地标头文件中，只要确保在包含该文件之前定义了 NO_IMPORT_ARRAY。

在内部，这些 #defines 的工作原理如下：

> +   如果两者都未定义，则 C-API 被声明为 `static void**`，因此它只能在包含 numpy/arrayobject.h 的编译单元中可见。
> +   
> +   如果 `PY_ARRAY_UNIQUE_SYMBOL` 被 #defined，但 `NO_IMPORT_ARRAY` 没有被定义，那么 C-API 被声明为 `void**`，以便它也可见于其他编译单元。
> +   
> +   如果 `NO_IMPORT_ARRAY` 被 #defined，无论 `PY_ARRAY_UNIQUE_SYMBOL` 是否被定义，C-API 被声明为 `extern void**`，因此预计将在另一个编译单元中定义。
> +   
> +   每当 `PY_ARRAY_UNIQUE_SYMBOL` 被 #defined 时，它也会更改保存 C-API 的变量名称（默认为 `PyArray_API`）为宏所定义的任何内容。

### 检查 API 版本

因为 Python 扩展在大多数平台上不像通常的库那样被使用，所以一些错误不能在构建时甚至运行时自动检测到。例如，如果您使用仅适用于 numpy >= 1.3.0 的函数构建扩展，然后稍后使用 numpy 1.2 导入扩展，您将不会得到导入错误（但几乎肯定在调用该函数时会导致段错误）。这就是为什么提供了几个函数来检查 numpy 版本。宏`NPY_VERSION`和`NPY_FEATURE_VERSION`对应于用于构建扩展的 numpy 版本，而函数`PyArray_GetNDArrayCVersion`和`PyArray_GetNDArrayCFeatureVersion`返回的版本对应于运行时 numpy 的版本。

ABI 和 API 兼容性的规则可以总结如下：

> +   每当`NPY_VERSION` != `PyArray_GetNDArrayCVersion()`时，扩展都必须重新编译（ABI 不兼容性）。
> +   
> +   `NPY_VERSION` == `PyArray_GetNDArrayCVersion()`，而`NPY_FEATURE_VERSION` <= `PyArray_GetNDArrayCFeatureVersion()`意味着向后兼容的更改。

ABI 不兼容性在每个 numpy 版本中都会自动检测到。API 不兼容性检测在 numpy 1.4.0 中添加。如果您希望支持许多不同的 numpy 版本，使用一个扩展二进制文件，您必须尽可能以最低的`NPY_FEATURE_VERSION`构建您的扩展。

```py
NPY_VERSION
```

ndarray 对象的当前版本（检查此变量是否定义以确保正在使用`numpy/arrayobject.h`头文件）。

```py
NPY_FEATURE_VERSION
```

C-API 的当前版本。

```py
unsigned int PyArray_GetNDArrayCVersion(void)
```

这只是返回值`NPY_VERSION`。每当 ABI 级别发生向后不兼容的更改时，`NPY_VERSION`会发生变化。然而，因为它在 C-API 中，比较此函数的输出与当前头文件中定义的值可以测试 C-API 是否已更改，从而需要重新编译使用 C-API 的扩展模块。这在函数`import_array`中自动检查。

```py
unsigned int PyArray_GetNDArrayCFeatureVersion(void)
```

版本 1.4.0 中的新功能。

这只是返回值`NPY_FEATURE_VERSION`。当 API 变化时（例如，添加了一个函数），`NPY_FEATURE_VERSION`会发生变化。改变的值并不总是需要重新编译。

### 内部灵活性

```py
int PyArray_SetNumericOps( *dict)
```

NumPy 存储了一个内部的 Python 可调用对象表，用于为数组实现算术运算以及某些数组计算方法。此函数允许用户用自己的版本替换任何或所有这些 Python 对象。字典*dict*的键是要替换的命名函数，配对值是要使用的 Python 可调用对象。应谨慎处理要用于替换内部数组操作的函数，不要自己回调该内部数组操作（除非你已经设计了该函数来处理），否则可能会导致未检查的无限递归（可能导致程序崩溃）。可以替换表示操作的关键名称是：

> **添加**，**减去**，**乘以**，**除以**，**余数**，**幂**，**平方**，**倒数**，**ones_like**，**sqrt**，**负数**，**正数**，**绝对值**，**倒数**，**左移**，**右移**，**按位与**，**按位异或**，**按位或**，**小于**，**小于等于**，**等于**，**不等于**，**大于**，**大于等于**，**地板除**，**真除**，**逻辑或**，**逻辑与**，**地板**，**上取整**，**最大值**，**最小值**，**rint**。

这些函数包含在此处是因为它们至少在数组对象的方法中使用一次。如果要分配的其中一个对象不可调用，则函数返回-1（而不设置 Python 错误）。

自版本 1.16 开始已过时。

```py
*PyArray_GetNumericOps(void)
```

返回一个包含存储在内部算术运算表中的可调用 Python 对象的 Python 字典。此字典的键在`PyArray_SetNumericOps`的解释中给出。

自版本 1.16 开始已过时。

```py
void PyArray_SetStringFunction( *op, int repr)
```

此函数允许您将数组对象的 tp_str 和 tp_repr 方法更改为任何 Python 函数。因此，您可以更改 Python 调用时对所有数组进行 str(arr)或 repr(arr)的操作。要调用的函数传递为*op*。如果*repr*非零，则将在 repr(arr)中调用此函数，否则将在 str(arr)中调用此函数。不执行有关*op*是否可调用的检查。传递给*op*的可调用对象应期望一个数组参数，并应返回要打印的字符串。

### 内存管理

```py
char *PyDataMem_NEW(size_t nbytes)
```

```py
void PyDataMem_FREE(char *ptr)
```

```py
char *PyDataMem_RENEW(void *ptr, size_t newbytes)
```

用于分配，释放和重新分配内存的宏。这些宏在内部用于创建数组。

```py
*PyDimMem_NEW(int nd)
```

```py
void PyDimMem_FREE(char *ptr)
```

```py
*PyDimMem_RENEW(void *ptr, size_t newnd)
```

用于分配，释放和重新分配维度和步幅内存的宏。

```py
void *PyArray_malloc(size_t nbytes)
```

```py
void PyArray_free(void *ptr)
```

```py
void *PyArray_realloc( *ptr, size_t nbytes)
```

这些宏使用不同的内存分配器，取决于常量`NPY_USE_PYMEM`。当`NPY_USE_PYMEM`为 0 时，使用系统 malloc，如果`NPY_USE_PYMEM`为 1，则使用 Python 内存分配器。

```py
NPY_USE_PYMEM
```

```py
int PyArray_ResolveWritebackIfCopy( *obj)
```

如果`obj->flags`具有`NPY_ARRAY_WRITEBACKIFCOPY`，则此函数会清除标志，减少*obj->base*的引用计数并使其可写，并将`obj->base`设置为 NULL。然后将`obj->data`复制到*obj->base->data*，并返回复制操作的错误状态。这与`PyArray_SetWritebackIfCopyBase`的相反操作。通常，在完成`obj`后及时调用此函数，就在`Py_DECREF(obj)`之前。可以多次调用此函数，或使用`NULL`输入。另请参见`PyArray_DiscardWritebackIfCopy`。

如果未执行任何操作，则返回 0；发生错误，则返回-1；执行操作，则返回 1。

### 线程支持

这些宏仅在扩展模块的编译期间，当`NPY_ALLOW_THREADS`评估为 True 时才有意义。否则，这些宏等同于空格。Python 为每个 Python 进程使用了单个全局解释器锁（Global Interpreter Lock，GIL），因此一次只能执行一个线程（即使在多 CPU 的机器上）。在调用需要一段时间计算的编译函数时（且不对其他线程产生副作用，如更新全局变量），GIL 应该被释放，以便其他 Python 线程可以在执行耗时计算时运行。这可以通过两组宏来实现。通常，如果在代码块中使用一组宏，那么同一代码块中必须使用所有宏。当前，`NPY_ALLOW_THREADS`被定义为 Python 定义的`WITH_THREADS`常量，除非设置环境变量`NPY_NOSMP`，在这种情况下，`NPY_ALLOW_THREADS`被定义为 0。

```py
NPY_ALLOW_THREADS
```

```py
WITH_THREADS
```

#### 组 1

> 此组用于调用可能需要一些时间但不使用任何 Python C-API 调用的代码。因此，在计算其过程中应释放 GIL。
> 
> ```py
> NPY_BEGIN_ALLOW_THREADS
> ```
> 
> 等效于[`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS "(in Python v3.11)")，只是它使用`NPY_ALLOW_THREADS`来确定是否将宏替换为空格。
> 
> ```py
> NPY_END_ALLOW_THREADS
> ```
> 
> 等效于[`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS "(in Python v3.11)")，只是它使用`NPY_ALLOW_THREADS`来确定是否将宏替换为空格。
> 
> ```py
> NPY_BEGIN_THREADS_DEF
> ```
> 
> 放置在变量声明区域。此宏设置存储 Python 状态所需的变量。
> 
> ```py
> NPY_BEGIN_THREADS
> ```
> 
> 放置在不需要 Python 解释器的代码之前（没有 Python C-API 调用）。此宏保存 Python 状态并释放 GIL。
> 
> ```py
> NPY_END_THREADS
> ```
> 
> 放在不需要 Python 解释器的代码之后。此宏获取 GIL 并从保存的变量恢复 Python 状态。
> 
> ```py
> void NPY_BEGIN_THREADS_DESCR( *dtype)
> ```
> 
> 仅当*dtype*不包含可能在循环执行期间需要 Python 解释器的任意 Python 对象时，才释放 GIL 是有用的。
> 
> ```py
> void NPY_END_THREADS_DESCR( *dtype)
> ```
> 
> 在使用此宏的 BEGIN 形式释放 GIL 的情况下，有用于重新获得 GIL。
> 
> ```py
> void NPY_BEGIN_THREADS_THRESHOLDED(int loop_size)
> ```
> 
> 仅当*loop_size*超过最小阈值（当前设置为 500）时才释放 GIL 是有用的。应该与`NPY_END_THREADS`配对以重新获得 GIL。

#### 第 2 组

> 此组用于在释放后重新获取 Python GIL。例如，假设已释放 GIL（使用前面的调用），然后代码中的某些路径（可能在不同的子例程中）需要使用 Python C-API，则这些宏对获取 GIL 很有用。这些宏基本上完成了前三个的反向操作（获取锁并保存其状态），然后使用保存的状态重新释放它。
> 
> ```py
> NPY_ALLOW_C_API_DEF
> ```
> 
> 放在变量声明区域以设置必要的变量。
> 
> ```py
> NPY_ALLOW_C_API
> ```
> 
> 放在需要调用 Python C-API 的代码之前（已知 GIL 已被释放时）。
> 
> ```py
> NPY_DISABLE_C_API
> ```
> 
> 放在需要调用 Python C-API（以重新释放 GIL）的代码之后。

提示

在线程支持宏后面永远不要使用分号。

### 优先级

```py
NPY_PRIORITY
```

数组的默认优先级。

```py
NPY_SUBTYPE_PRIORITY
```

默认子类型优先级。

```py
NPY_SCALAR_PRIORITY
```

默认标量优先级（非常小）

```py
double PyArray_GetPriority( *obj, double def)
```

返回*obj*或*def*的`__array_priority__`属性（转换为 double），如果不存在该名称的属性，则返回。对于类型为`PyArray_Type`的对象，提供了避免属性查找的快速返回。

### 默认缓冲区

```py
NPY_BUFSIZE
```

用户可设置内部缓冲区的默认大小。

```py
NPY_MIN_BUFSIZE
```

用户可设置内部缓冲区的最小大小。

```py
NPY_MAX_BUFSIZE
```

用户可设置缓冲区的最大大小。

### 其他常数

```py
NPY_NUM_FLOATTYPE
```

浮点类型的数量

```py
NPY_MAXDIMS
```

数组中允许的最大维数。

```py
NPY_MAXARGS
```

可在函数中使用的最大数组参数数。

```py
NPY_FALSE
```

对于 Bool 使用定义为 0。

```py
NPY_TRUE
```

对于 Bool 使用定义为 1。

```py
NPY_FAIL
```

在[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(in Python v3.11)")-like 函数中使用“O&”语法调用的失败转换器函数的返回值。

```py
NPY_SUCCEED
```

在[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(in Python v3.11)")-like 函数中使用“O&”语法调用的成功转换器函数的返回值。

### 杂项宏

```py
int PyArray_SAMESHAPE( *a1, *a2)
```

如果数组*a1*和*a2*具有相同的形状，则为 True。

```py
PyArray_MAX(a, b)
```

返回*a*和*b*的最大值。如果(*a*)或(*b*)是表达式，则它们将被评估两次。

```py
PyArray_MIN(a, b)
```

返回*a*和*b*的最小值。如果(*a*)或(*b*)是表达式，则它们将被评估两次。

```py
PyArray_CLT(a, b)
```

```py
PyArray_CGT(a, b)
```

```py
PyArray_CLE(a, b)
```

```py
PyArray_CGE(a, b)
```

```py
PyArray_CEQ(a, b)
```

```py
PyArray_CNE(a, b)
```

使用 NumPy 定义的排序方式，实现两个复数（具有实部和虚部成员的结构）之间的复杂比较，即词典排序：首先比较实部，然后比较复数部分（如果实部相等）。

```py
PyArray_REFCOUNT( *op)
```

返回任何 Python 对象的引用计数。

```py
void PyArray_DiscardWritebackIfCopy( *obj)
```

如果`obj->flags`标有`NPY_ARRAY_WRITEBACKIFCOPY`，则此函数会清除标志，*DECREF* *obj->base* 使其可写，并将`obj->base`设置为 NULL。与`PyArray_ResolveWritebackIfCopy`相比，它不会尝试从*obj->base*复制数据。这会撤销`PyArray_SetWritebackIfCopyBase`。通常在错误发生后，当你已经完成对`obj`的操作时，在`Py_DECREF(obj)`之前调用此函数。可以多次调用，或者使用`NULL`输入。

### 枚举类型

```py
enum NPY_SORTKIND
```

一个特殊的变量类型，可以采用不同的值来指示正在使用的排序算法。

```py
enumerator NPY_QUICKSORT
```

```py
enumerator NPY_HEAPSORT
```

```py
enumerator NPY_MERGESORT
```

```py
enumerator NPY_STABLESORT
```

用作`NPY_MERGESORT`的别名，反之亦然。

```py
enumerator NPY_NSORTS
```

定义为排序数目。由于向后兼容性的需要，它固定为三个，因此 `NPY_MERGESORT` 和 `NPY_STABLESORT` 相互别名，并可以引用多个稳定排序算法中的一个，具体取决于数据类型。

```py
enum NPY_SCALARKIND
```

一个特殊的变量类型，指示在确定标量强制转换规则时区分的标量“种类”的数量。此变量可以采用以下值：

```py
enumerator NPY_NOSCALAR
```

```py
enumerator NPY_BOOL_SCALAR
```

```py
enumerator NPY_INTPOS_SCALAR
```

```py
enumerator NPY_INTNEG_SCALAR
```

```py
enumerator NPY_FLOAT_SCALAR
```

```py
enumerator NPY_COMPLEX_SCALAR
```

```py
enumerator NPY_OBJECT_SCALAR
```

```py
enumerator NPY_NSCALARKINDS
```

定义为标量种类的数量（不包括`NPY_NOSCALAR`）。

```py
enum NPY_ORDER
```

一个枚举类型，指示应如何解释数组的元素顺序。当创建全新的数组时，通常只使用**NPY_CORDER**和**NPY_FORTRANORDER**，而当提供一个或多个输入时，顺序可以基于它们。

```py
enumerator NPY_ANYORDER
```

如果所有输入都是 Fortran，则为 Fortran 顺序，否则为 C。

```py
enumerator NPY_CORDER
```

C 顺序。

```py
enumerator NPY_FORTRANORDER
```

Fortran 顺序。

```py
enumerator NPY_KEEPORDER
```

尽可能接近输入顺序的顺序，即使输入既不是 C 顺序也不是 Fortran 顺序。

```py
enum NPY_CLIPMODE
```

一个变量类型，指示在某些函数中应用的剪裁类型。

```py
enumerator NPY_RAISE
```

大多数操作的默认值，如果索引越界则引发异常。

```py
enumerator NPY_CLIP
```

如果索引越界，则将其剪裁到有效范围内。

```py
enumerator NPY_WRAP
```

如果索引越界，则将其包装到有效范围内。

```py
enum NPY_SEARCHSIDE
```

一个变量类型，指示返回的索引是第一个合适位置的（如果是`NPY_SEARCHLEFT`）还是最后一个的（如果是`NPY_SEARCHRIGHT`）。

```py
enumerator NPY_SEARCHLEFT
```

```py
enumerator NPY_SEARCHRIGHT
```

```py
enum NPY_SELECTKIND
```

一个变量类型，指示正在使用的选择算法。

```py
enumerator NPY_INTROSELECT
```

```py
enum NPY_CASTING
```

自 1.6 版引入。

枚举类型，指示数据转换应该多么宽松。这由 NumPy 1.6 中添加的迭代器使用，并计划在未来版本中更广泛地使用。

```py
enumerator NPY_NO_CASTING
```

只允许相同类型的转换。

```py
enumerator NPY_EQUIV_CASTING
```

允许相同和涉及字节交换的类型转换。

```py
enumerator NPY_SAFE_CASTING
```

只允许不会导致值四舍五入、截断或以其他方式改变的转换。

```py
enumerator NPY_SAME_KIND_CASTING
```

允许任何安全的类型转换，以及相同类型的类型转换。例如，`float64` -> `float32` 的转换符合此规则。

```py
enumerator NPY_UNSAFE_CASTING
```

允许任何类型的转换，无论可能发生什么样的数据丢失。

## 数组结构和数据访问

这些宏访问 `PyArrayObject` 结构成员，并在 `ndarraytypes.h` 中定义。输入参数 *arr* 可以是任何可直接解释为 PyArrayObject*（任何 `PyArray_Type` 及其子类型的实例）的 [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject "(in Python v3.11)")*。

```py
int PyArray_NDIM( *arr)
```

数组中的维度数。

```py
int PyArray_FLAGS( *arr)
```

返回表示 数组标志 的整数。

```py
int PyArray_TYPE( *arr)
```

返回此数组元素的（内置）类型编号。

```py
int PyArray_SETITEM( *arr, void *itemptr, *obj)
```

将 obj 转换并将其放置在 *arr* 中，位置由 itemptr 指向。如果发生错误则返回 -1，成功返回 0。

```py
void PyArray_ENABLEFLAGS( *arr, int flags)
```

版本 1.7 中的新功能。

启用指定的数组标志。此函数不进行验证，并假定您知道自己在做什么。

```py
void PyArray_CLEARFLAGS( *arr, int flags)
```

版本 1.7 中的新功能。

清除指定的数组标志。此函数不进行验证，并假定您知道自己在做什么。

```py
void *PyArray_DATA( *arr)
```

```py
char *PyArray_BYTES( *arr)
```

这两个宏很相似，并获取数组数据缓冲区的指针。第一个宏可以（也应该）分配给特定指针，而第二个用于通用处理。如果您没有保证数组是连续和/或对齐的，请确保了解如何访问数组中的数据，以避免内存和/或对齐问题。

```py
*PyArray_DIMS( *arr)
```

返回指向数组的维度/形状的指针。元素数量与数组的维度数相匹配。对于 0 维数组，可能返回 `NULL`。

```py
*PyArray_SHAPE( *arr)
```

版本 1.7 中的新功能。

与 `PyArray_DIMS` 同义，命名以与 Python 中的 `shape` 用法一致。

```py
*PyArray_STRIDES( *arr)
```

返回指向数组步幅的指针。元素数量与数组的维度数相匹配。

```py
PyArray_DIM( *arr, int n)
```

在*n* \(^{\textrm{th}}\) 维度中返回形状。

```py
PyArray_STRIDE( *arr, int n)
```

返回*n* \(^{\textrm{th}}\) 维度中的步幅。

```py
PyArray_ITEMSIZE( *arr)
```

返回此数组元素的项大小。

注意，在版本 1.7 中已弃用的旧 API 中，此函数的返回类型为 `int`。

```py
PyArray_SIZE( *arr)
```

返回数组的总大小（元素数）。

```py
PyArray_Size( *obj)
```

如果 *obj* 不是 ndarray 的子类，则返回 0。否则，返回数组中的元素总数。`PyArray_SIZE` (*obj*) 的更安全版本。

```py
PyArray_NBYTES( *arr)
```

返回数组消耗的总字节数。

```py
*PyArray_BASE( *arr)
```

返回数组的基本对象。在大多数情况下，这意味着数组指向的内存的所有者对象。

如果你正在使用 C API 构建数组，并指定自己的内存，你应该使用函数`PyArray_SetBaseObject`来将基础设置为一个拥有该内存的对象。

如果设置了`NPY_ARRAY_WRITEBACKIFCOPY`标志，则其含义不同，即基本是当前数组将在复制解析时复制到的数组。这两个函数的基本属性的重载可能会在 NumPy 的将来版本中更改。

```py
*PyArray_DESCR( *arr)
```

返回数组的 dtype 属性的借用引用。

```py
*PyArray_DTYPE( *arr)
```

自 NumPy 版本 1.7 起新增。

PyArray_DESCR 的同义词，命名为与 Python 中的 'dtype' 用法一致。

```py
*PyArray_GETITEM( *arr, void *itemptr)
```

从 ndarray *arr* 的位置指针 itemptr 获取内置类型的 Python 对象。失败时返回 `NULL`。

`numpy.ndarray.item` 与 PyArray_GETITEM 完全相同。

```py
int PyArray_FinalizeFunc( *arr, *obj)
```

[`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule "(in Python v3.11)") `__array_finalize__` 所指向的函数。第一个参数是新创建的子类型。第二个参数（如果不为 NULL）是“父”数组（如果数组是使用切片或某些其他操作创建的，则存在一个明显可区分的父数组）。此例程可以执行任何操作。错误时应返回 -1，否则返回 0。

### 数据访问

这些函数和宏提供了从 C 语言访问 ndarray 元素的简便方法。这对所有数组都有效。但是，如果数组中的数据不是机器字节顺序、未对齐或不可写入，你可能需要小心访问数组中的数据。换句话说，一定要尊重标志的状态，除非你知道自己在做什么，或者之前已经通过`PyArray_FromAny`确保了可写入、对齐且处于机器字节顺序的数组。如果你希望处理所有类型的数组，每种类型的 copyswap 函数对于处理不规范的数组非常有用。某些平台（例如 Solaris）不喜欢未对齐的数据，并且如果你对未对齐的指针进行解引用，它们将崩溃。其他平台（例如 x86 Linux）在处理未对齐的数据时会变得更慢。

```py
void *PyArray_GetPtr( *aobj, *ind)
```

返回 ndarray *aobj* 在由 c 数组 *ind* 指定的 N 维索引处的数据的指针（*ind* 的大小必须至少为 *aobj* ->nd）。你可能需要将返回的指针类型转换为 ndarray 的数据类型。

```py
void *PyArray_GETPTR1( *obj, i)
```

```py
void *PyArray_GETPTR2( *obj, i, j)
```

```py
void *PyArray_GETPTR3( *obj, i, j, k)
```

```py
void *PyArray_GETPTR4( *obj, i, j, k, l)
```

在 ndarray *obj*中以给定坐标快速内联访问元素，*obj* 必须分别具有 1、2、3 或 4 个维度（未经检查）。相应的 *i*、*j*、*k* 和 *l* 坐标可以是任何整数，但将被解释为`npy_intp`。您可能希望将返回的指针强制转换为 ndarray 的数据类型。

### 数据访问

这些函数和宏为从 C 中轻松访问 ndarray 的元素提供了便利。这些适用于所有数组。但是，如果数组不符合机器字节顺序、未对齐或不可写，那么在访问数组中的数据时，您可能需要小心。换句话说，请确保尊重标志的状态，除非您知道自己在做什么，或者之前已经保证了一个可写、对齐并且符合机器字节顺序的数组，使用`PyArray_FromAny`。如果希望处理所有类型的数组，每种类型的复制交换功能可用于处理表现不佳的数组。某些平台（例如 Solaris）不喜欢不对齐数据，如果您对一个不对齐的指针进行反引用，它们将崩溃。其他平台（例如 x86 Linux）将更慢地处理不对齐数据。

```py
void *PyArray_GetPtr( *aobj, *ind)
```

在由 c 数组*ind*给出的 N 维索引处返回 ndarray *aobj* 的数据指针（数组大小至少为*aobj*->nd）。您可能希望将返回的指针强制转换为 ndarray 的数据类型。

```py
void *PyArray_GETPTR1( *obj, i)
```

```py
void *PyArray_GETPTR2( *obj, i, j)
```

```py
void *PyArray_GETPTR3( *obj, i, j, k)
```

```py
void *PyArray_GETPTR4( *obj, i, j, k, l)
```

在 ndarray *obj*中以给定坐标快速内联访问元素，*obj* 必须分别具有 1、2、3 或 4 个维度（未经检查）。相应的 *i*、*j*、*k* 和 *l* 坐标可以是任何整数，但将被解释为`npy_intp`。您可能希望将返回的指针强制转换为 ndarray 的数据类型。

## 创建数组

### 从最基础开始

```py
*PyArray_NewFromDescr( *subtype, *descr, int nd, const *dims, const *strides, void *data, int flags, *obj)
```

此函数将引用*descr*。获取它的最简单方法是使用`PyArray_DescrFromType`。

这是主要的数组创建函数。大多数新数组都是使用此灵活函数创建的。

返回的对象是 Python 类型*subtype*的对象，它必须是`PyArray_Type`的子类型。数组具有*nd*维，由*dims*描述。新数组的数据类型描述符是*descr*。

如果*subtype*是数组子类的而不是基本`&PyArray_Type`，则*obj*是传递给子类的`__array_finalize__`方法的对象。

如果*data*为`NULL`，则将分配新的未初始化内存，而*flags*可以非零以指示 Fortran 风格连续数组。使用`PyArray_FILLWBYTE`来初始化内存。

如果*data*不为`NULL`，那么假定它指向要用于数组的内存，*flags*参数将用作数组的新标志（除了新数组的`NPY_ARRAY_OWNDATA`、`NPY_ARRAY_WRITEBACKIFCOPY`标志状态将被重置之外）。

另外，如果*data*非 NULL，则还可以提供*strides*。如果*strides*为`NULL`，则数组步幅将计算为 C 风格连续（默认）或 Fortran 风格连续（*data*为`NULL`或*flags* & `NPY_ARRAY_F_CONTIGUOUS`为非空非 NULL*data*）。任何提供的*dims*和*strides*都将复制到新分配的维度和步幅数组中，以供新数组对象使用。

`PyArray_CheckStrides` 可以帮助验证非`NULL`的步幅信息。

如果提供了`data`，它必须在数组的生命周期内保持活动状态。管理其方式之一是通过`PyArray_SetBaseObject`。

```py
*PyArray_NewLikeArray( *prototype, order, *descr, int subok)
```

自 1.6 版开始新添加的功能。

这个函数会在*descr*不为 NULL 的情况下窃取一个引用。这个数组创建例程允许方便地创建一个与现有数组形状和内存布局匹配的新数组，可能会改变布局和/或数据类型。

当*order*为`NPY_ANYORDER`时，如果*prototype*是一个 Fortran 数组，则结果顺序为`NPY_FORTRANORDER`，否则为`NPY_CORDER`。当*order*为`NPY_KEEPORDER`时，结果顺序与*prototype*匹配，即使*prototype*的轴不按照 C 或 Fortran 顺序。

如果*descr*为 NULL，将使用*prototype*的数据类型。

如果*subok*为 1，新创建的数组将使用*prototype*的子类型来创建新数组，否则将创建一个基类数组。

```py
*PyArray_New( *subtype, int nd, const *dims, int type_num, const *strides, void *data, int itemsize, int flags, *obj)
```

这类似于`PyArray_NewFromDescr`（…），只是您使用*type_num*和*itemsize*指定数据类型描述符，其中*type_num*对应于内置（或用户定义）类型。如果该类型始终具有相同数量的字节，则 itemsize 将被忽略。否则，itemsize 指定了此数组的特定大小。

警告

如果数据传递给`PyArray_NewFromDescr`或`PyArray_New`，则在删除新数组之前不能释放此内存。如果这些数据来自另一个 Python 对象，可以通过对该对象使用[`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF "(在 Python v3.11 中)")并将新数组的基础成员设置为指向该对象来实现。如果传入了步幅，它们必须与数组的维度、项大小和数据一致。

```py
*PyArray_SimpleNew(int nd, const *dims, int typenum)
```

创建一个未初始化的类型为*typenum*的新数组，每个*nd*维度的大小由整数数组*dims*给出。数组的内存未初始化（除非 typenum 是`NPY_OBJECT`，在这种情况下数组中的每个元素都设置为 NULL）。*typenum*参数允许指定任何内置数据类型，如`NPY_FLOAT`或`NPY_LONG`。如果需要，可以使用`PyArray_FILLWBYTE`（return_object，0）将数组的内存设置为零。此函数不能用于创建灵活类型数组（未给出 itemsize）。

```py
*PyArray_SimpleNewFromData(int nd, const *dims, int typenum, void *data)
```

在给定指针指向的*data*周围创建一个数组包装器。数组标志将具有数据区域是良好行为和 C 风格连续的默认值。数组的形状由长度为*nd*的*c*数组*dims*给出。数组的数据类型由*typenum*指示。如果数据来自另一个引用计数的 Python 对象，则在传入指针后应增加此对象的引用计数，并且返回的 ndarray 的基础成员应指向拥有数据的 Python 对象。这将确保在返回的数组存在时不会释放提供的内存。

```py
*PyArray_SimpleNewFromDescr(int nd, const *dims, *descr)
```

此函数窃取了对*descr*的引用。

使用提供的数据类型描述符*descr*创建一个新数组，其形状由*nd*和*dims*确定。

```py
void PyArray_FILLWBYTE( *obj, int val)
```

填充由*obj*指向的数组（必须是 ndarray 的子类）的内容为*val*（作为一个字节进行评估）。此宏调用 memset，因此 obj 必须是连续的。

```py
*PyArray_Zeros(int nd, const *dims, *dtype, int fortran)
```

使用由*dims*给定的形状和由*dtype*给定的数据类型构造一个新的*nd*维数组。如果*fortran*非零，则创建一个 Fortran 顺序数组，否则创建一个 C 顺序数组。用零（或如果*dtype*对应于`NPY_OBJECT`则为 0 对象）填充内存。

```py
*PyArray_ZEROS(int nd, const *dims, int type_num, int fortran)
```

宏形式的`PyArray_Zeros`，它接受一个类型编号而不是数据类型对象。

```py
*PyArray_Empty(int nd, const *dims, *dtype, int fortran)
```

使用由*dims*给定形状和*dtype*给定数据类型构建一个新的*nd* -维数组。如果*fortran*非零，则创建一个 Fortran 顺序数组，否则创建一个 C 顺序数组。除非数据类型对应于`NPY_OBJECT`，否则数组未经初始化，此时数组将填充为[`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)")。

```py
*PyArray_EMPTY(int nd, const *dims, int typenum, int fortran)
```

`PyArray_Empty`的宏表单，它使用类型编号*typenum*，而不是数据类型对象。

```py
*PyArray_Arange(double start, double stop, double step, int typenum)
```

构建一个数据类型为*typenum*的新的一维数组，范围从*start*到*stop*（不包括*stop*），增量为*step*。相当于**arange**（*start*，*stop*，*step*，dtype）。

```py
*PyArray_ArangeObj( *start, *stop, *step, *descr)
```

构建一个由`descr`确定的数据类型为`typenum`的新的一维数组，范围从`start`到`stop`（不包括`stop`），增量为`step`。相当于 arange（`start`，`stop`，`step`，`typenum`）。

```py
int PyArray_SetBaseObject( *arr, *obj)
```

1.7 版本新增。

此函数**窃取一个引用**到`obj`并将其设置为`arr`的基本属性。

如果通过将自己的内存缓冲区作为参数传递来构建数组，则需要设置数组的*base*属性以确保内存缓冲区的生命周期合适。

返回值：成功返回 0，失败返回-1。

如果提供的对象是一个数组，该函数将遍历*base*指针链，以便每个数组直接指向内存的所有者。一旦设置了*base*，就不能将其更改为另一个值。

### 从其他对象

```py
*PyArray_FromAny( *op, *dtype, int min_depth, int max_depth, int requirements, *context)
```

这是从任何嵌套序列或暴露数组接口的对象*op*获取数组的主要函数。参数允许指定所需的*dtype*，可接受的最小（*min_depth*）和最大（*max_depth*）维数，以及数组的其他*要求*。此函数**窃取一个引用**到 dtype 参数，它应该是指示所需数据类型（包括所需的字节顺序）的`PyArray_Descr`结构。*dtype*参数可以为`NULL`，表示接受任何数据类型（和字节顺序）。除非在`flags`中包含`NPY_ARRAY_FORCECAST`，否则如果无法安全地从对象获取数据类型，此调用将生成错误。如果您想为*dtype*使用`NULL`并确保数组不会被交换，则使用`PyArray_CheckFromAny`。深度参数的值为 0 会使该参数被忽略。可以将以下任何数组标志（*例如*使用|）添加到*要求*参数中。如果您的代码可以处理一般的（*例如*分布、字节交换或非对齐的数组），那么*要求*可以是 0。此外，如果*op*不已经是数组（或不公开数组接口），那么将创建一个新数组（并使用序列协议从*op*中填充）。新数组将具有`NPY_ARRAY_DEFAULT`作为其标志成员。*context*参数未使用。

```py
NPY_ARRAY_C_CONTIGUOUS
```

确保返回的数组是以 C 风格连续的

```py
NPY_ARRAY_F_CONTIGUOUS
```

确保返回的数组是以 Fortran 风格连续的。

```py
NPY_ARRAY_ALIGNED
```

确保返回的数组在其数据类型的适当边界上对齐。对齐的数组具有与数据类型描述符的对齐因子的数据指针和每个步幅因子的倍数。

```py
NPY_ARRAY_WRITEABLE
```

确保返回的数组可以被写入。

```py
NPY_ARRAY_ENSURECOPY
```

确保对*op*进行复制。如果不存在此标志，则只有在可以避免复制数据时才不会复制数据。

```py
NPY_ARRAY_ENSUREARRAY
```

确保结果是基类的 ndarray。默认情况下，如果*op*是 ndarray 的子类的实例，则返回相同子类的实例。如果设置了这个标志，则将返回一个 ndarray 对象。

```py
NPY_ARRAY_FORCECAST
```

强制对输出类型进行转换，即使不能安全地进行。如果没有这个标志，只有在可以安全进行数据转换时才会发生数据转换，否则会引发错误。

```py
NPY_ARRAY_WRITEBACKIFCOPY
```

如果*op*已经是一个数组，但不符合要求，那么就会制作一个副本（该副本将符合要求）。如果此标志存在并且必须创建副本（一个已经是数组的对象），那么在返回的副本中设置对应的`NPY_ARRAY_WRITEBACKIFCOPY`标志，并且*op*将被设置为只读。您必须确保调用`PyArray_ResolveWritebackIfCopy`将内容复制回*op*，并且*op*数组将会重新变得可写。如果*op*一开始就不可写，或者如果它不已经是一个数组，那么将会引发错误。

```py
NPY_ARRAY_BEHAVED
```

`NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`

```py
NPY_ARRAY_CARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_CARRAY_RO
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_FARRAY_RO
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_DEFAULT
```

`NPY_ARRAY_CARRAY`

```py
NPY_ARRAY_IN_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_IN_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_OUT_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_OUT_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`

```py
NPY_ARRAY_OUT_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_INOUT_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEBACKIFCOPY`

```py
NPY_ARRAY_INOUT_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEBACKIFCOPY`

```py
*PyArray_CheckFromAny( *op, *dtype, int min_depth, int max_depth, int requirements, *context)
```

与`PyArray_FromAny`（…）几乎相同，除了*requirements*可以包含`NPY_ARRAY_NOTSWAPPED`（覆盖*dtype*中的规定）和`NPY_ARRAY_ELEMENTSTRIDES`，其中表明数组应该在步幅是元素大小的倍数的意义上对齐。

在 NumPy 的 1.6 版本及更早版本中，以下标志的命名形式中没有 ARRAY 宏命名空间。该常量名称的形式在 1.7 中已不推荐使用。

```py
NPY_ARRAY_NOTSWAPPED
```

确保返回的数组具有机器字节顺序的数据类型描述符，覆盖*dtype*参数中的任何规定。通常，字节顺序要求由*dtype*参数确定。如果设置了此标志并且 dtype 参数未指示机器字节顺序描述符（或为 NULL 且对象已经是一个不在机器字节顺序中的数据类型描述符的数组），则会创建一个新的数据类型描述符并使用其字节顺序字段设置为本机。

```py
NPY_ARRAY_BEHAVED_NS
```

`NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_NOTSWAPPED`

```py
NPY_ARRAY_ELEMENTSTRIDES
```

确保返回的数组具有元素大小的倍数步幅。

```py
*PyArray_FromArray( *op, *newtype, int requirements)
```

`PyArray_FromAny`的特例，当*op*已经是一个数组但需要是特定的*newtype*（包括字节顺序）或具有特定的*requirements*时。

```py
*PyArray_FromStructInterface( *op)
```

从暴露`__array_struct__`属性并遵循数组接口协议的 Python 对象中返回一个 ndarray 对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented "(在 Python v3.11)")的借用引用。

```py
*PyArray_FromInterface( *op)
```

从暴露`__array_interface__`属性并遵循数组接口协议的 Python 对象中返回一个 ndarray 对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented "(在 Python v3.11)")的借用引用。

```py
*PyArray_FromArrayAttr( *op, *dtype, *context)
```

从公开`__array__`方法的 Python 对象返回一个 ndarray 对象。`__array__`方法可以采取 0 或 1 个参数（[dtype]）。`context`未使用。

```py
*PyArray_ContiguousFromAny( *op, int typenum, int min_depth, int max_depth)
```

此函数从任何嵌套序列或数组接口导出的对象*op*返回一个（C 风格）连续且行为良好的函数数组，类型由枚举*typenum*给出，最小深度为*min_depth*，最大深度为*max_depth*。等同于调用`PyArray_FromAny`并将需求设置为`NPY_ARRAY_DEFAULT`，并将类型参数的类型号成员设置为*typenum*。

```py
*PyArray_ContiguousFromObject( *op, int typenum, int min_depth, int max_depth)
```

此函数从任何嵌套序列或数组接口导出的对象返回一个行为良好的 C 风格连续数组。数组的最小维数由*min_depth*给出，最大维数为*max_depth*。这等同于调用`PyArray_FromAny`并将需求设置为`NPY_ARRAY_DEFAULT`和`NPY_ARRAY_ENSUREARRAY`。

```py
*PyArray_FromObject( *op, int typenum, int min_depth, int max_depth)
```

从任何嵌套序列或数组接口导出的对象*op*返回一个对齐且以本机字节序排列的数组，类型由枚举 typenum 给出。数组的最小维数由 min_depth 给出，最大维数为 max_depth。这相当于调用`PyArray_FromAny`并将需求设置为 BEHAVED。

```py
*PyArray_EnsureArray( *op)
```

此函数**窃取一个引用**并确保`op`是一个基类 ndarray。它特殊处理数组标量，否则调用`PyArray_FromAny`（`op`，NULL，0，0，`NPY_ARRAY_ENSUREARRAY`，NULL）。

```py
*PyArray_FromString(char *string, slen, *dtype, num, char *sep)
```

从长度为 slen 的二进制或（ASCII）文本`string`构建一个单一类型的一维 ndarray。要创建的数组的数据类型由`dtype`给出。如果 num 为-1，则**复制**整个字符串并返回大小合适的数组，否则，num 是从字符串中**复制**的项目数。如果`sep`为 NULL（或“”），则将字符串解释为二进制数据的字节，否则将由`sep`分隔的子字符串转换为数据类型`dtype`的项。一些数据类型在文本模式下可能无法读取，并且如果发生这种情况，将会引发错误。所有错误都会返回 NULL。

```py
*PyArray_FromFile(FILE *fp, *dtype, num, char *sep)
```

从二进制或文本文件构建一个单一类型的一维 ndarray。打开的文件指针为`fp`，要创建的数组的数据类型由`dtype`给出。这必须与文件中的数据匹配。 如果`num`为-1，则读取直到文件结束并返回一个大小适当的数组，否则，`num`是要读取的项数。 如果`sep`为 NULL（或“”），则以二进制模式从文件读取，否则以`sep`提供的项分隔符以文本模式从文件读取。有些数组类型在文本模式下无法读取，在这种情况下会引发错误。

```py
*PyArray_FromBuffer( *buf, *dtype, count, offset)
```

从一个导出（单一段）缓冲区协议的对象`buf`构建一个单一类型的一维 ndarray（或者具有返回导出缓冲区协议的对象的属性`__buffer__`）。首先尝试可写缓冲区，然后尝试只读缓冲区。返回的数组的`NPY_ARRAY_WRITEABLE`标志将反映哪一个成功。假定数据从对象的内存位置开始的`offset`字节。根据数据类型描述符`dtype`解释缓冲区中的数据类型。如果`count`为负数，则将根据缓冲区的大小和要求的项大小确定，否则，`count`表示应从缓冲区中转换多少个元素。

```py
int PyArray_CopyInto( *dest, *src)
```

从源数组`src`复制数据到目标数组`dest`中，必要时执行数据类型转换。 如果出现错误，则返回-1（否则返回 0）。 `src`的形状必须可以广播到`dest`的形状。 目标和源的数据区域不能重叠。

```py
int PyArray_CopyObject( *dest, *src)
```

根据数组强制转换规则，将对象`src`分配给 NumPy 数组`dest`。这基本上与`PyArray_FromAny`相同，但直接分配给输出数组。成功时返回 0，失败时返回-1。

```py
int PyArray_MoveInto( *dest, *src)
```

将源数组`src`中的数据移动到目标数组`dest`中，必要时执行数据类型转换。如果发生错误，则返回-1（否则返回 0）。 `src`的形状必须可以广播到`dest`的形状。目标和源的数据区域可能重叠。

```py
*PyArray_GETCONTIGUOUS( *op)
```

如果`op`已经（C 风格）是连续且行为良好的，则只返回一个引用，否则返回数组的（连续和行为良好的）副本。参数`op`必须是（ndarray 的子类的）ndarray，并且不做检查。

```py
*PyArray_FROM_O( *obj)
```

将`obj`转换为 ndarray。该参数可以是任何嵌套序列或导出数组接口的对象。 这是使用`NULL`，0，0，0 作为其他参数的`PyArray_FromAny`的宏形式。您的代码必须能够处理任何数据类型描述符和任何数据标志的组合以使用此宏。

```py
*PyArray_FROM_OF( *obj, int requirements)
```

类似于 `PyArray_FROM_O`，只是它可以接受一个 *requirements* 参数，指示结果数组必须具有的属性。可以强制执行的可用要求包括 `NPY_ARRAY_C_CONTIGUOUS`、`NPY_ARRAY_F_CONTIGUOUS`、`NPY_ARRAY_ALIGNED`、`NPY_ARRAY_WRITEABLE`、`NPY_ARRAY_NOTSWAPPED`、`NPY_ARRAY_ENSURECOPY`、`NPY_ARRAY_WRITEBACKIFCOPY`、`NPY_ARRAY_FORCECAST` 和 `NPY_ARRAY_ENSUREARRAY`。也可以使用标准组合的标志：

```py
*PyArray_FROM_OT( *obj, int typenum)
```

类似于 `PyArray_FROM_O`，只是它可以接受一个 *typenum* 参数，指定返回的数组的类型编号。

```py
*PyArray_FROM_OTF( *obj, int typenum, int requirements)
```

结合 `PyArray_FROM_OF` 和 `PyArray_FROM_OT`，允许同时提供 *typenum* 和 *flags* 参数。

```py
*PyArray_FROMANY( *obj, int typenum, int min, int max, int requirements)
```

类似于 `PyArray_FromAny`，只是数据类型使用 typenumber 来指定。将 `PyArray_DescrFromType`（*typenum*）直接传递给 `PyArray_FromAny`。如果传入 `NPY_ARRAY_ENSURECOPY` 作为要求，则此宏还会添加 `NPY_ARRAY_DEFAULT`。

```py
*PyArray_CheckAxis( *obj, int *axis, int requirements)
```

封装了使用 axis= 关键字并正确处理 None 作为轴参数的函数和方法的功能。输入数组为 `obj`，而 `*axis` 是转换后的整数（所以 >=MAXDIMS 就是 None 值），而 `requirements` 给出了 `obj` 的所需属性。输出是输入的转换版本，以满足要求，如有需要，已执行了扁平化。在输出中，`*axis` 的负值被转换，并检查新值以确保与 `obj` 的形状一致。

### 从头开始

```py
*PyArray_NewFromDescr( *subtype, *descr, int nd, const *dims, const *strides, void *data, int flags, *obj)
```

此函数会获取对 *descr* 的引用。最简单的方法是使用 `PyArray_DescrFromType`。

这是主要的数组创建函数。大多数新数组都是使用这个灵活的函数创建的。

返回的对象是 Python 类型 *subtype* 的对象，它必须是 `PyArray_Type` 的一个子类型。数组具有 *nd* 维，由 *dims* 描述。新数组的数据类型描述符是 *descr*。

如果*subtype*是一个数组子类而不是基础`&PyArray_Type`，那么*obj*就是将传递给子类的`__array_finalize__`方法的对象。

如果*data*为`NULL`，那么将分配新的未初始化内存，并且*flags*可以是非零以指示 Fortran 风格连续数组。使用`PyArray_FILLWBYTE`来初始化内存。

如果*data*不为`NULL`，则假定它指向要用于数组的内存，并且 *flags* 参数将用作数组的新标志（除了新数组的`NPY_ARRAY_OWNDATA`、`NPY_ARRAY_WRITEBACKIFCOPY` 标志的状态将被重置）。

此外，如果*data*为非 NULL，那么也可以提供*strides*。如果*strides*为`NULL`，则计算数组的步幅为 C 风格连续（默认）或 Fortran 风格连续（*data*=`NULL`或*flags*&`NPY_ARRAY_F_CONTIGUOUS`为非零 non-NULL*data*）。任何提供的*dims*和*strides*都将被复制到新分配的维度和步幅数组中，用于新的数组对象。

`PyArray_CheckStrides`可以帮助验证非`NULL`的步幅信息。

如果提供了`data`，它必须在数组的生存期内保持活动。管理此情况的一种方法是通过`PyArray_SetBaseObject`

```py
*PyArray_NewLikeArray( *prototype, order, *descr, int subok)
```

自 1.6 版开始。

此函数会偷走*descr*的引用，如果不是 NULL 的话。这个数组创建程序允许方便地创建一个与现有数组形状和内存布局匹配的新数组，可能会改变布局和/或数据类型。

当*order*为`NPY_ANYORDER`时，结果顺序为`NPY_FORTRANORDER`，如果*prototype*是 Fortran 数组，则为`NPY_CORDER`。当*order*为`NPY_KEEPORDER`时，结果顺序与*prototype*的顺序匹配，即使*prototype*的轴不是按 C 或 Fortran 顺序排列。

如果*descr*为 NULL，则使用*prototype*的数据类型。

如果*subok*为 1，则新创建的数组将使用*prototype*的子类型来创建新数组，否则将创建一个基类数组。

```py
*PyArray_New( *subtype, int nd, const *dims, int type_num, const *strides, void *data, int itemsize, int flags, *obj)
```

这类似于`PyArray_NewFromDescr`(...)，不同之处在于您使用*type_num*和*itemsize*指定数据类型描述符，其中*type_num*对应于内置（或用户定义）类型。如果该类型始终具有相同数量的字节，则 itemsize 会被忽略。否则，itemsize 指定该数组的特定大小。

警告

如果数据被传递给 `PyArray_NewFromDescr` 或 `PyArray_New`，则在删除新数组之前不能释放该内存。如果此数据来自另一个 Python 对象，可以使用 [`Py_INCREF`](https://docs.python.org/3/c-api/refcounting.html#c.Py_INCREF "(in Python v3.11)") 增加该对象的引用计数，并将新数组的基类成员设置为指向该对象。如果传入了步幅，它们必须与数组的维度、项大小和数据一致。

```py
*PyArray_SimpleNew(int nd, const *dims, int typenum)
```

创建一个未初始化的类型为 *typenum* 的新数组，每个维度的大小都由整数数组 *dims* 给出。数组的内存未初始化（除非 typenum 是 `NPY_OBJECT` ，此时数组中的每个元素都设置为 NULL）。*typenum* 参数允许指定任何内置的数据类型，例如 `NPY_FLOAT` 或 `NPY_LONG`。如果需要，可以使用 `PyArray_FILLWBYTE`（return_object，0）将数组的内存设置为零。此函数不能用于创建灵活类型的数组（未给出项大小）。

```py
*PyArray_SimpleNewFromData(int nd, const *dims, int typenum, void *data)
```

在给定指针指向的 *data* 上创建一个数组包装器。数组标志将具有默认值，即数据区域是良好行为并且 C 风格连续的。数组的形状由长度为 *nd* 的 *dims* c 数组给出。数组的数据类型由 *typenum* 指示。如果数据来自另一个引用计数的 Python 对象，则要在指针传递后增加此对象的引用计数，并且返回的 ndarray 的基类成员应指向拥有数据的 Python 对象。这样可以确保在返回的数组存在时，提供的内存不会被释放。

```py
*PyArray_SimpleNewFromDescr(int nd, const *dims, *descr)
```

这个函数引用了 *descr*。

使用提供的数据类型描述符 *descr* 和由 *nd* 和 *dims* 确定的形状创建一个新数组。

```py
void PyArray_FILLWBYTE( *obj, int val)
```

使用 *val* 的内容（作为字节评估）填充 *obj* 指向的数组。此宏调用 memset，因此 obj 必须是连续的。

```py
*PyArray_Zeros(int nd, const *dims, *dtype, int fortran)
```

使用给定的 *dims* 形状和 *dtype* 数据类型构建一个新的 *nd* 维数组。如果 *fortran* 不为零，则创建一个 Fortran 顺序数组，否则创建一个 C 顺序数组。用零填充内存（或者如果 *dtype* 对应 `NPY_OBJECT` ，则填充 0 对象）。

```py
*PyArray_ZEROS(int nd, const *dims, int type_num, int fortran)
```

转换为宏形式的 `PyArray_Zeros`，它接受类型编号而不是数据类型对象。

```py
*PyArray_Empty(int nd, const *dims, *dtype, int fortran)
```

创建一个由*dims*给定形状和*dtype*给定数据类型的新*nd*维数组。如果*fortran*非零，则创建一个 Fortran 顺序数组，否则创建一个 C 顺序数组。该数组未初始化，除非数据类型对应于`NPY_OBJECT`，在这种情况下，数组将填充[`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(在 Python v3.11)")。

```py
*PyArray_EMPTY(int nd, const *dims, int typenum, int fortran)
```

以宏形式的`PyArray_Empty`，它接受一个类型编号*typenum*，而不是数据类型对象。

```py
*PyArray_Arange(double start, double stop, double step, int typenum)
```

构造一个新的一维数据类型数组，*typenum*，它的范围是从*start*到*stop*（不包括*stop*），增量为*step*。相当于**arange**(*start*, *stop*, *step*, dtype)。

```py
*PyArray_ArangeObj( *start, *stop, *step, *descr)
```

构造一个新的一维由`descr`确定数据类型的数组，范围是从`start`到`stop`（不包括`stop`），增量为`step`。相当于 arange(`start`, `stop`, `step`, `typenum`)。

```py
int PyArray_SetBaseObject( *arr, *obj)
```

在 1.7 版中新增。

这个函数**窃取了一个引用**到`obj`，并将其设置为`arr`的基本属性。

如果你通过传入自己的内存缓冲区来构造一个数组，你需要设置数组的*base*属性以确保内存缓冲区的生命周期是适当的。

成功时返回值为 0，失败时为-1。

如果提供的对象是一个数组，这个函数会遍历*基本*指针链，以便每个数组直接指向内存的所有者。一旦设置了基本值，就不能更改为另一个值。

### 来自其他对象

```py
*PyArray_FromAny( *op, *dtype, int min_depth, int max_depth, int requirements, *context)
```

这是用于从任何嵌套序列或暴露数组接口的对象（*op*）中获取数组的主要函数。参数允许指定所需的*dtype*、可接受的最小（*min_depth*）和最大（*max_depth*）维数以及数组的其他*requirements*。此函数会**窃取一个引用**用于 dtype 参数，该参数需要一个`PyArray_Descr` 结构，指示所需的数据类型（包括所需的字节序）。*dtype* 参数可以为 `NULL`，表示可以接受任何数据类型（和字节序）。除非 `NPY_ARRAY_FORCECAST` 在 `flags` 中存在，否则如果无法安全地从对象中获取数据类型，则此调用将引发错误。如果希望将 *dtype* 设置为 `NULL`，并确保数组未交换，则使用 `PyArray_CheckFromAny`。任何一个深度参数为 0 都会导致该参数被忽略。可以添加以下任何数组标志（例如使用 |）来获取 *requirements* 参数。如果您的代码可以处理一般的（例如分段的、字节交换的或未对齐的数组），则 *requirements* 可以设置为 0。此外，如果 *op* 尚未是数组（或未暴露数组接口），则将创建一个新的数组（并使用序列协议从 *op* 中填充）。新数组的 flags 成员将为`NPY_ARRAY_DEFAULT`。*context* 参数未使用。

```py
NPY_ARRAY_C_CONTIGUOUS
```

确保返回的数组是 C 风格的连续数组。

```py
NPY_ARRAY_F_CONTIGUOUS
```

确保返回的数组是 Fortran 风格的连续数组。

```py
NPY_ARRAY_ALIGNED
```

确保返回的数组在其数据类型的适当边界上对齐。对齐数组的数据指针以及每个步幅因子都是数据类型描述符的对齐因子的倍数。

```py
NPY_ARRAY_WRITEABLE
```

确保返回的数组可以写入。

```py
NPY_ARRAY_ENSURECOPY
```

确保对 *op* 进行复制。如果没有设置该标志，将尽可能避免复制数据。 

```py
NPY_ARRAY_ENSUREARRAY
```

确保结果是一个基类 ndarray。默认情况下，如果 *op* 是 ndarray 的子类的实例，则返回相同子类的实例。如果设置了此标志，则返回一个 ndarray 对象。

```py
NPY_ARRAY_FORCECAST
```

强制将输出类型转换，即使不能安全地进行转换。如果没有设置该标志，则只有在可以安全地进行数据转换时才会发生数据转换，否则将引发错误。

```py
NPY_ARRAY_WRITEBACKIFCOPY
```

如果*op*已经是一个数组，但不满足要求，那么就会进行复制（以满足要求）。如果设置了这个标识并且必须进行复制（复制一个已经是数组的对象），那么返回的副本将设置相应的`NPY_ARRAY_WRITEBACKIFCOPY`标志，并且*op*将被设为只读。您必须确保调用`PyArray_ResolveWritebackIfCopy`将内容复制回*op*，并且*op*数组将重新变为可写。如果*op*一开始就不可写，或者不是一个数组，那么将会引发错误。

```py
NPY_ARRAY_BEHAVED
```

`NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`

```py
NPY_ARRAY_CARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_CARRAY_RO
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_FARRAY_RO
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_DEFAULT
```

`NPY_ARRAY_CARRAY`

```py
NPY_ARRAY_IN_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_IN_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_OUT_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_OUT_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`

```py
NPY_ARRAY_OUT_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_INOUT_ARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEBACKIFCOPY`

```py
NPY_ARRAY_INOUT_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEBACKIFCOPY`

```py
*PyArray_CheckFromAny( *op, *dtype, int min_depth, int max_depth, int requirements, *context)
```

与`PyArray_FromAny` (…) 几乎相同，但 *requirements* 可以包含 `NPY_ARRAY_NOTSWAPPED`（覆盖 *dtype* 中的规范）和 `NPY_ARRAY_ELEMENTSTRIDES`，这表示数组应该对齐，即步幅是元素大小的倍数。

在 NumPy 的 1.6 版本及更早版本中，以下标志的命名中没有包含 _ARRAY_ 宏命名空间。该常量名称形式在 1.7 版本中已被弃用。

```py
NPY_ARRAY_NOTSWAPPED
```

确保返回的数组具有机器字节顺序的数据类型描述符，覆盖 *dtype* 参数中的任何规范。通常，字节顺序要求由 *dtype* 参数确定。如果设置了此标志并且 *dtype* 参数没有指示机器字节顺序描述符（或者为 NULL 并且对象已经是一个具有不在机器字节顺序中的数据类型描述符的数组），则会创建一个新的数据类型描述符并使用其字节顺序字段设置为本机。

```py
NPY_ARRAY_BEHAVED_NS
```

`NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE` | `NPY_ARRAY_NOTSWAPPED`

```py
NPY_ARRAY_ELEMENTSTRIDES
```

确保返回的数组的步幅是元素大小的倍数。

```py
*PyArray_FromArray( *op, *newtype, int requirements)
```

`PyArray_FromAny` 的特殊情况，当 *op* 已经是一个数组但它需要是一个特定的 *newtype*（包括字节顺序）或具有某些 *requirements*。

```py
*PyArray_FromStructInterface( *op)
```

从一个暴露了`__array_struct__` 属性并遵循数组接口协议的 Python 对象中返回一个 ndarray 对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented "(in Python v3.11)") 的借用引用。

```py
*PyArray_FromInterface( *op)
```

从一个暴露了`__array_interface__` 属性并遵循数组接口协议的 Python 对象中返回一个 ndarray 对象。如果对象不包含此属性，则返回对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented "(in Python v3.11)") 的借用引用。

```py
*PyArray_FromArrayAttr( *op, *dtype, *context)
```

从暴露`__array__`方法的 Python 对象返回一个 ndarray 对象。`__array__`方法可以接受 0 个或 1 个参数`([dtype])`。`context`未使用。

```py
*PyArray_ContiguousFromAny( *op, int typenum, int min_depth, int max_depth)
```

此函数从任何嵌套序列或数组接口导出的对象*op*返回一个（C 风格）连续且表现良好的函数数组，其类型由枚举*typenum*给定，最小深度为*min_depth*，最大深度为*max_depth*。（非灵活）类型为*typenum*的等同于调用具有要求设置为`NPY_ARRAY_DEFAULT`和类型参数的 type_num 成员设置为*typenum*的`PyArray_FromAny`。

```py
*PyArray_ContiguousFromObject( *op, int typenum, int min_depth, int max_depth)
```

此函数从任何嵌套序列或导出数组接口的对象返回一个表现良好的 C 风格连续数组。数组可以具有的最小维数由*min_depth*给出，而最大维数为*max_depth*。这等同于使用要求为`NPY_ARRAY_DEFAULT`和`NPY_ARRAY_ENSUREARRAY`的调用`PyArray_FromAny`。

```py
*PyArray_FromObject( *op, int typenum, int min_depth, int max_depth)
```

从任何嵌套序列或导出数组接口的对象`op`返回一个对齐的本机字节顺序数组，该数组的类型由枚举类型标号给出。数组可以具有的最小维数由`min_depth`给出，而最大维数由`max_depth`给出。这相当于使用要求设置为 BEHAVED 的调用`PyArray_FromAny`。

```py
*PyArray_EnsureArray( *op)
```

此函数**窃取引用**`op`并确保`op`是一个基类 ndarray。它特殊处理数组标量，但否则调用`PyArray_FromAny`（ `op`, NULL, 0, 0, `NPY_ARRAY_ENSUREARRAY`, NULL）。

```py
*PyArray_FromString(char *string, slen, *dtype, num, char *sep)
```

从长度为`slen`的二进制或（ASCII）文本`string`构建一个单一类型的一维 ndarray。将要创建的数组的数据类型由`dtype`给出。如果`num`为-1，则**复制**整个字符串并返回一个适当大小的数组，否则，`num`是从字符串中**复制**的项目数。如果`sep`为 NULL（或“”），则将字符串解释为二进制数据的字节，否则将由`sep`分隔的子字符串转换为数据类型`dtype`的项。某些数据类型在文本模式下可能无法读取，如果发生这种情况，则会引发错误。所有错误都返回 NULL。

```py
*PyArray_FromFile(FILE *fp, *dtype, num, char *sep)
```

从二进制或文本文件构造一个单一类型的一维 ndarray。 打开的文件指针是`fp`，要创建的数组的数据类型由`dtype`给出。 这必须与文件中的数据匹配。 如果`num`为-1，则读取直到文件结束并返回一个大小适当的数组，否则，`num`是要读取的项目数。 如果`sep`为 NULL（或“”），则以二进制模式从文件中读取，否则使用`sep`以文本模式从文件中读取，`sep`提供项目分隔符。 有些数组类型无法以文本模式读取，这将引发错误。

```py
*PyArray_FromBuffer( *buf, *dtype, count, offset)
```

从导出（单段）缓冲区协议的对象`buf`构造单一类型的一维 ndarray（或具有返回导出缓冲区协议的对象的属性 __buffer__）。 首先尝试可写缓冲区，然后尝试只读缓冲区。 返回的数组的`NPY_ARRAY_WRITEABLE`标志将反映哪种是成功的。 假定数据从对象的内存位置的起始处偏移`offset`字节。 缓冲区中的数据类型将根据数据类型描述符`dtype`进行解释。 如果`count`为负，则将从缓冲区的大小和请求的项大小确定它，否则，`count`表示应从缓冲区中转换多少元素。

```py
int PyArray_CopyInto( *dest, *src)
```

从源数组`src`复制到目标数组`dest`，必要时执行数据类型转换。 如果发生错误，则返回-1（否则返回 0）。 `src`的形状必须可广播至`dest`的形状。 dest 和 src 的数据区域不得重叠。

```py
int PyArray_CopyObject( *dest, *src)
```

根据数组强制规则，将对象`src`分配给 NumPy 数组`dest`。 这基本上与`PyArray_FromAny`相同，但直接分配给输出数组。 成功返回 0，失败返回-1。

```py
int PyArray_MoveInto( *dest, *src)
```

将数据从源数组`src`移动到目标数组`dest`，必要时执行数据类型转换。 如果发生错误，则返回-1（否则返回 0）。 `src`的形状必须可广播到`dest`的形状。 dest 和 src 的数据区域可能重叠。

```py
*PyArray_GETCONTIGUOUS( *op)
```

如果`op`已经（C 样式）连续且行为良好，则只返回引用，否则返回数组的（连续且行为良好）副本。 参数 op 必须是 ndarray 的（子类的）并且不对其进行检查。

```py
*PyArray_FROM_O( *obj)
```

将`obj`转换为 ndarray。 该参数可以是任何嵌套序列或导出数组接口的对象。 这是使用`NULL`、0、0、0 作为其他参数的`PyArray_FromAny`的宏形式。 您的代码必须能够处理任何数据类型描述符和任何数据标志的组合以使用此宏。

```py
*PyArray_FROM_OF( *obj, int requirements)
```

类似于`PyArray_FROM_O`，除了它可以接受一个*requirements*参数，指示生成的数组必须具有的属性。可以强制执行的可用要求包括`NPY_ARRAY_C_CONTIGUOUS`，`NPY_ARRAY_F_CONTIGUOUS`，`NPY_ARRAY_ALIGNED`，`NPY_ARRAY_WRITEABLE`，`NPY_ARRAY_NOTSWAPPED`，`NPY_ARRAY_ENSURECOPY`，`NPY_ARRAY_WRITEBACKIFCOPY`，`NPY_ARRAY_FORCECAST`，和`NPY_ARRAY_ENSUREARRAY`。也可以使用标准组合标志：

```py
*PyArray_FROM_OT( *obj, int typenum)
```

类似于`PyArray_FROM_O`，除了它可以接受一个*typenum*参数，指定返回的数组的类型编号。

```py
*PyArray_FROM_OTF( *obj, int typenum, int requirements)
```

结合`PyArray_FROM_OF`和`PyArray_FROM_OT`，允许提供*typenum*和*flags*参数。

```py
*PyArray_FROMANY( *obj, int typenum, int min, int max, int requirements)
```

类似于`PyArray_FromAny`，除了使用 typenumber 指定数据类型之外。`PyArray_DescrFromType`（*typenum*）直接传递给`PyArray_FromAny`。如果作为 requirements 传入了`NPY_ARRAY_ENSURECOPY`，则此宏还会将`NPY_ARRAY_DEFAULT`添加到 requirements 中。

```py
*PyArray_CheckAxis( *obj, int *axis, int requirements)
```

封装了使用 axis=关键字并且能够正确处理 None 作为 axis 参数的函数和方法的功能。输入数组是`obj`，而`*axis`是转换后的整数（使得>=MAXDIMS 为 None 值），`requirements`给出了`obj`的所需属性。输出是输入的转换版本，以满足要求，并且如果需要进行了展平。输出时将会转换`*axis`的负值，并将检查新值以确保与`obj`的形状一致。

## 处理类型

### Python 类型的通用检查

```py
int PyArray_Check( *op)
```

如果*op*是类型是`PyArray_Type`的子类型的 Python 对象，则评估为 true。

```py
int PyArray_CheckExact( *op)
```

如果*op*是一个具有类型`PyArray_Type`的 Python 对象，则评估为 true。

```py
int PyArray_HasArrayInterface( *op, *out)
```

如果`op`实现了数组接口的任何部分，则`out`将包含使用接口创建的新 ndarray 的新引用，或者如果在转换过程中发生错误，则`out`将包含`NULL`。否则，out 将包含对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented "(在 Python v3.11)")的借用引用，并且不设置错误条件。

```py
int PyArray_HasArrayInterfaceType( *op, *dtype, *context, *out)
```

如果`op`实现了数组接口的任何部分，则`out`将包含使用接口创建的新 ndarray 的新引用，或者如果在转换过程中发生错误，则`out`将包含`NULL`。否则，out 将包含对 Py_NotImplemented 的借用引用，并且不设置错误条件。此版本允许在查找`__array__`属性的数组接口的部分中设置 dtype。*context*未使用。

```py
int PyArray_IsZeroDim( *op)
```

如果*op*是（子类的）`PyArray_Type`的实例，并且维度为 0，则评估为真。

```py
PyArray_IsScalar(op, cls)
```

如果*op*是`Py{cls}ArrType_Type`的实例，则评估为真。

```py
int PyArray_CheckScalar( *op)
```

如果*op*是数组标量（`PyGenericArr_Type`子类型的实例）或者是（子类的）`PyArray_Type`且维度为 0 的实例，则评估为真。

```py
int PyArray_IsPythonNumber( *op)
```

如果*op*是内置数字类型（int、float、complex、long、bool）的实例，则评估为真。

```py
int PyArray_IsPythonScalar( *op)
```

如果*op*是 Python 内置标量对象（int、float、complex、bytes、str、long、bool），则评估为真。

```py
int PyArray_IsAnyScalar( *op)
```

如果*op*是 Python 标量对象（参见`PyArray_IsPythonScalar`）或者数组标量（`PyGenericArr_Type`子类型的实例），则评估为真。

```py
int PyArray_CheckAnyScalar( *op)
```

如果*op*是 Python 标量对象（参见`PyArray_IsPythonScalar`）、数组标量（`PyGenericArr_Type`子类型的实例）或者是（`PyArray_Type`子类型的）维度为 0 的实例的（子类的）实例，则评估为真。

### 数据类型检查

对于 typenum 宏，参数是表示枚举数组数据类型的整数。对于数组类型检查宏，参数必须是可直接解释为 PyArrayObject*的[PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject "(在 Python v3.11)")。

```py
int PyTypeNum_ISUNSIGNED(int num)
```

```py
int PyDataType_ISUNSIGNED( *descr)
```

```py
int PyArray_ISUNSIGNED( *obj)
```

类型表示无符号整数。

```py
int PyTypeNum_ISSIGNED(int num)
```

```py
int PyDataType_ISSIGNED( *descr)
```

```py
int PyArray_ISSIGNED( *obj)
```

类型表示有符号整数。

```py
int PyTypeNum_ISINTEGER(int num)
```

```py
int PyDataType_ISINTEGER( *descr)
```

```py
int PyArray_ISINTEGER( *obj)
```

类型表示任意整数。

```py
int PyTypeNum_ISFLOAT(int num)
```

```py
int PyDataType_ISFLOAT( *descr)
```

```py
int PyArray_ISFLOAT( *obj)
```

类型表示任意浮点数。

```py
int PyTypeNum_ISCOMPLEX(int num)
```

```py
int PyDataType_ISCOMPLEX( *descr)
```

```py
int PyArray_ISCOMPLEX( *obj)
```

类型表示任意复数浮点数。

```py
int PyTypeNum_ISNUMBER(int num)
```

```py
int PyDataType_ISNUMBER( *descr)
```

```py
int PyArray_ISNUMBER( *obj)
```

类型表示任意整数、浮点数或复数浮点数。

```py
int PyTypeNum_ISSTRING(int num)
```

```py
int PyDataType_ISSTRING( *descr)
```

```py
int PyArray_ISSTRING( *obj)
```

类型表示字符串数据类型。

```py
int PyTypeNum_ISPYTHON(int num)
```

```py
int PyDataType_ISPYTHON( *descr)
```

```py
int PyArray_ISPYTHON( *obj)
```

类型表示对应于标准 Python 标量（bool、int、float 或 complex）之一的枚举类型。

```py
int PyTypeNum_ISFLEXIBLE(int num)
```

```py
int PyDataType_ISFLEXIBLE( *descr)
```

```py
int PyArray_ISFLEXIBLE( *obj)
```

类型表示灵活数组类型之一（`NPY_STRING`，`NPY_UNICODE`或`NPY_VOID`）。

```py
int PyDataType_ISUNSIZED( *descr)
```

类型没有附加的大小信息，并且可以调整大小。只应在灵活的数据类型上调用。附加到数组的类型将始终被分配大小，因此不存在此宏的数组形式。

版本 1.18 中更改。

对于没有字段的结构化数据类型，此函数现在返回 False。

```py
int PyTypeNum_ISUSERDEF(int num)
```

```py
int PyDataType_ISUSERDEF( *descr)
```

```py
int PyArray_ISUSERDEF( *obj)
```

类型表示用户定义的类型。

```py
int PyTypeNum_ISEXTENDED(int num)
```

```py
int PyDataType_ISEXTENDED( *descr)
```

```py
int PyArray_ISEXTENDED( *obj)
```

类型可以是灵活的或用户定义的。

```py
int PyTypeNum_ISOBJECT(int num)
```

```py
int PyDataType_ISOBJECT( *descr)
```

```py
int PyArray_ISOBJECT( *obj)
```

类型表示对象数据类型。

```py
int PyTypeNum_ISBOOL(int num)
```

```py
int PyDataType_ISBOOL( *descr)
```

```py
int PyArray_ISBOOL( *obj)
```

类型代表布尔数据类型。

```py
int PyDataType_HASFIELDS( *descr)
```

```py
int PyArray_HASFIELDS( *obj)
```

类型具有与其关联的字段。

```py
int PyArray_ISNOTSWAPPED( *m)
```

如果数组* m*的数据区根据数组的数据类型描述符处于机器字节顺序中，则评估为 true。

```py
int PyArray_ISBYTESWAPPED( *m)
```

如果根据数组的数据类型描述符，数组* m*的数据区不处于机器字节顺序中，则评估为 True。

```py
PyArray_EquivTypes( *type1, *type2)
```

如果* type1*和* type2*实际上表示此平台上等效的类型（忽略每种类型的 fortran 成员），则返回`NPY_TRUE`。例如，在 32 位平台上，`NPY_LONG`和`NPY_INT`是等效的。否则返回`NPY_FALSE`。

```py
PyArray_EquivArrTypes( *a1, *a2)
```

如果*a1*和*a2*是此平台上具有等效类型的数组，则返回`NPY_TRUE`。

```py
PyArray_EquivTypenums(int typenum1, int typenum2)
```

`PyArray_EquivTypes`的特殊情况（…），不接受灵活数据类型，但可能更容易调用。

```py
int PyArray_EquivByteorders(int b1, int b2)
```

如果字节顺序字符*b1*和*b2*（`NPY_LITTLE`，`NPY_BIG`，`NPY_NATIVE`，`NPY_IGNORE`）相等或等价于它们对本机字节顺序的规定，则返回 True。因此，在小端机器上，`NPY_LITTLE`和`NPY_NATIVE`是等价的，在大端机器上它们是不等价的。

### 数据类型转换

```py
*PyArray_Cast( *arr, int typenum)
```

主要用于向后兼容 Numeric C-API 和向非灵活类型的简单转换。返回一个新的数组对象，其中元素* arr*转换为* typenum*的数据类型，它必须是列举类型之一，而不是灵活类型。

```py
*PyArray_CastToType( *arr, *type, int fortran)
```

返回指定*类型*的新数组，适当地将*arr*的元素转换。 Fortran 参数指定输出数组的排序方式。

```py
int PyArray_CastTo( *out, *in)
```

从 1.6 开始，此函数简单地调用`PyArray_CopyInto`，处理类型转换。

将数组* in*的元素转换为数组* out*。输出数组应可写，具有输入数组元素数量的整数倍（out 中可以放置多于一个副本），并且具有内置类型之一。成功时返回 0，如果发生错误则返回-1。

```py
PyArray_VectorUnaryFunc *PyArray_GetCastFunc( *from, int totype)
```

返回从给定描述符到内置类型编号的低级转换函数。如果不存在转换函数，则返回`NULL`并设置错误。使用此函数而不是直接访问*from*->f->cast，可以支持添加到描述符转换字典的任何用户定义的转换函数。

```py
int PyArray_CanCastSafely(int fromtype, int totype)
```

如果*fromtype*的数据类型数组可以在不丢失信息的情况下转换为*totype*的数据类型数组，则返回非零值。有一个例外，即允许将 64 位整数转换为 64 位浮点值，即使这可能会在大整数上丢失精度，以便不会在没有明确要求的情况下扩散使用长双精度值。此函数不根据灵活数组类型的长度进行检查。

```py
int PyArray_CanCastTo( *fromtype, *totype)
```

在 NumPy 1.6 及更高版本中，`PyArray_CanCastTypeTo`取代了此函数。

等同于 PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING)。

```py
int PyArray_CanCastTypeTo( *fromtype, *totype, casting)
```

新版本 1.6 中新增。

根据转换规则*casting*，如果数据类型*fromtype*（可以包括灵活类型）的数组可以安全地转换为数据类型*totype*（可以包括灵活类型）的数组，则返回非零值。对于`NPY_SAFE_CASTING`的简单类型，基本上这是一个围绕`PyArray_CanCastSafely`的包装器，但对于字符串或 unicode 等灵活类型，它会生成结果，考虑到它们的大小。只有当字符串或 unicode 类型足够大以容纳转换的整数/浮点类型的最大值时，整数和浮点类型才能使用`NPY_SAFE_CASTING`转换为字符串或 unicode 类型。

```py
int PyArray_CanCastArrayTo( *arr, *totype, casting)
```

新版本 1.6 中新增。

如果根据*casting*给定的转换规则*arr*可以转换为*totype*，则返回非零值。如果*arr*是一个数组标量，则其值会被考虑在内，当值转换为较小类型时，如果值不会溢出或被截断为整数，则也会返回非零值。

这几乎与 PyArray_CanCastTypeTo(PyArray_MinScalarType(arr)，totype，casting)的结果相同，但它还处理了一种特殊情况，因为 uint 值的集合不是具有相同位数的 int 值的子集。

```py
*PyArray_MinScalarType( *arr)
```

新版本 1.6 中新增。

如果*arr*是一个数组，则返回其数据类型描述符，但如果*arr*是一个数组标量（具有 0 个维度），则找到可以将值转换为整数且不会溢出或截断的最小尺寸的数据类型。

此函数不会将复数降级为浮点数或任何东西降级为布尔值，但当标量值为正时，将有符号整数降级为无符号整数。

```py
*PyArray_PromoteTypes( *type1, *type2)
```

新版本 1.6 中新增。

找到*type1*和*type2*可以安全转换为的最小大小和种类的数据类型。此函数对称且可结合。字符串或 Unicode 结果将是为存储输入类型的最大值转换为字符串或 Unicode 而正确的大小。

```py
*PyArray_ResultType( narrs, **arrs, ndtypes, **dtypes)
```

1.6 中的新功能。

这将对所有输入数组和 dtype 对象应用类型提升，使用 NumPy 规则来组合标量和数组，以确定给定操作的操作数集合的输出类型。这与 ufuncs 产生的相同结果类型相同。

参见`numpy.result_type`的文档，以了解有关类型提升算法的更多细节。

```py
int PyArray_ObjectType( *op, int mintype)
```

这个函数被`PyArray_MinScalarType`和/或`PyArray_ResultType`取代。

这个函数用于确定两个或多个数组可以转换为的共同类型。它仅适用于非灵活的数组类型，因为没有传递任何`itemsize`信息。*mintype*参数表示可接受的最小类型，*op*表示将被转换为数组的对象。返回值是代表*op*应具有的数据类型的枚举类型编号。

```py
**PyArray_ConvertToCommonType( *op, int *n)
```

这个函数提供的功能在 1.6 中引入的迭代器`NpyIter`中基本被取代，使用标志`NPY_ITER_COMMON_DTYPE`或对所有操作数使用相同的 dtype 参数。

将*op*中包含的 Python 对象序列转换为具有相同数据类型的 ndarrays 数组。类型的选择方式与*PyArray_ResultType*相同。序列的长度在*n*中返回，返回值是长度为*n*的`PyArrayObject`指针数组（如果发生错误则返回`NULL`）。返回的数组必须由此例程的调用者（使用`PyDataMem_FREE`）释放，否则会发生内存泄漏。下面是一个典型用法的示例模板代码：

在 1.18.0 版本中更改：标量和零维数组的组合现在产生一个能容纳标量值的类型。先前优先考虑了数组的 dtype。

```py
mps  =  PyArray_ConvertToCommonType(obj,  &n);
if  (mps==NULL)  return  NULL;
{code}
<before  return>
for  (i=0;  i<n;  i++)  Py_DECREF(mps[i]);
PyDataMem_FREE(mps);
{return} 
```

```py
char *PyArray_Zero( *arr)
```

指向新创建的、大小为*arr* ->itemsize 的内存的指针，其中保存了该类型的 0 的表示。返回的指针*ret*在不再需要时，**必须被**使用`PyDataMem_FREE` (ret)释放。

```py
char *PyArray_One( *arr)
```

指向新创建的、大小为*arr* ->itemsize 的内存的指针，其中保存了该类型的 1 的表示。返回的指针*ret*在不再需要时，**必须被**使用`PyDataMem_FREE` (ret)释放。

```py
int PyArray_ValidType(int typenum)
```

如果*typenum*表示有效的类型编号（内置、用户定义或字符码），则返回`NPY_TRUE`。否则，此函数返回`NPY_FALSE`。

### 用户定义的数据类型

```py
void PyArray_InitArrFuncs( *f)
```

将所有函数指针和成员初始化为`NULL`。

```py
int PyArray_RegisterDataType( *dtype)
```

将数据类型注册为数组的新用户定义数据类型。该类型必须填写大部分条目。这不总是被检查的，错误可能会产生段错误。特别是，`dtype`结构的 typeobj 成员必须填写为具有与*dtype*的 elsize 成员对应的固定大小元素大小的 Python 类型。此外，如果不需要支持，`f`成员必须具有所需的函数：nonzero、copyswap、copyswapn、getitem、setitem 和 cast（一些转换函数可能为`NULL`）。为避免混淆，应选择一个唯一的字符类型码，但这并不是强制执行的，也不能在内部依赖它。

返回一个唯一标识该类型的用户定义类型编号。然后，可以使用返回的类型编号从`PyArray_DescrFromType`中获取指向新结构的指针。如果发生错误，则返回-1。如果此*dtype*已经注册（仅根据指针的地址进行检查），则返回先前分配的类型编号。

```py
int PyArray_RegisterCastFunc( *descr, int totype, PyArray_VectorUnaryFunc *castfunc)
```

注册一个低级转换函数*castfunc*，以将数据类型*descr*转换为给定的数据类型编号*totype*。成功返回`0`，失败返回`-1`。

```py
int PyArray_RegisterCanCast( *descr, int totype, scalar)
```

将数据类型对象*descr*的标量类型注册为可以安全转换为类型编号为*totype*的数据类型。当*scalar* = `NPY_NOSCALAR`时，注册数据类型*descr*的数组可以安全地转换为类型编号为*totype*的数据类型。成功返回值为 0，失败返回值为-1。

```py
int PyArray_TypeNumFromName(char const *str)
```

给定一个字符串，返回具有该字符串作为类型对象名称的数据类型的类型编号。如果找不到类型，则返回`NPY_NOTYPE`而不设置错误。仅适用于用户定义的数据类型。

### NPY_OBJECT 的特殊函数

警告

当处理数组或填充有对象的缓冲区时，NumPy 会尽量确保在任何数据被读取之前用`None`填充这些缓冲区。但是，可能存在代码路径，其中数组只初始化为`NULL`。NumPy 本身接受`NULL`作为`None`的别名，但在调试模式编译时，可能会`assert`非`NULL`。

因为 NumPy 尚未在 None 初始化方面保持一致，用户**必须**预计在处理 NumPy 创建的缓冲区时会得到`NULL`的值。用户**还应**确保将完全初始化的缓冲区传递给 NumPy，因为将来 NumPy 可能使这成为一个严格要求。

目前有意确保在读取之前始终初始化对象数组。任何未能这样做的情况都将被视为错误。将来，用户可能可以在从任何数组中读取时依赖非空值，尽管对于刚创建的数组可能会保留例外（例如，在 ufunc 代码中的输出数组）。截至 NumPy 1.23，已知存在未正确填充的代码路径。

```py
int PyArray_INCREF( *op)
```

用于包含任何 Python 对象的数组*op*，根据*op*的数据类型，增加数组中每个对象的引用计数。如果发生错误，则返回-1，否则返回 0。

```py
void PyArray_Item_INCREF(char *ptr, *dtype)
```

根据数据类型*dtype*，增加位置*ptr*处的所有对象的引用计数的函数。如果*ptr*是具有任何偏移量处的对象的结构化类型的开始，则这将（递归地）增加结构化类型中所有类似对象的引用计数。

```py
int PyArray_XDECREF( *op)
```

用于包含任何 Python 对象的数组*op*，根据*op*的数据类型，减少数组中每个对象的引用计数。正常返回值为 0。如果发生错误，则返回-1。

```py
void PyArray_Item_XDECREF(char *ptr, *dtype)
```

根据记录在数据类型*dtype*中的对象类似项，XDECREF 位置*ptr*处的所有对象。这将递归地进行，以便如果`dtype`本身具有包含类似对象的数据类型的字段，则将 XDECREF 所有类似对象字段。

```py
void PyArray_FillObjectArray( *arr, *obj)
```

用值*obj*填充新创建的数组中所有包含对象数据类型的位置。不执行任何检查，但*arr*必须是数据类型`NPY_OBJECT`的单一段并且未初始化（位置中没有先前的对象）。如果需要在调用此函数之前减少对象数组中所有项目的引用计数，请使用`PyArray_XDECREF`（*arr*）。

```py
int PyArray_SetWritebackIfCopyBase( *arr, *base)
```

前提条件：`arr`是`base`的副本（尽管可能有不同的步幅、顺序等）。设置`NPY_ARRAY_WRITEBACKIFCOPY`标志以及`arr->base`，并将`base`设置为只读。在调用*Py_DECREF*之前调用`PyArray_ResolveWritebackIfCopy`，以便将任何更改复制回`base`并重置只读标志。

成功返回 0，失败返回-1。

### Python 类型的一般检查

```py
int PyArray_Check( *op)
```

如果*op*是 Python 对象，并且其类型是`PyArray_Type`的子类型，则返回 true。

```py
int PyArray_CheckExact( *op)
```

如果*op*是 Python 对象，并且其类型是`PyArray_Type`，则返回 true。

```py
int PyArray_HasArrayInterface( *op, *out)
```

如果 `op` 实现了数组接口的任何部分，则 `out` 将包含使用该接口新创建的 ndarray 的新引用，或者如果在转换过程中发生错误，则 `out` 将包含 `NULL`。否则，out 将包含对[`Py_NotImplemented`](https://docs.python.org/3/c-api/object.html#c.Py_NotImplemented "(在 Python v3.11 中)") 的借用引用，并且不设置错误条件。

```py
int PyArray_HasArrayInterfaceType( *op, *dtype, *context, *out)
```

如果 `op` 实现了数组接口的任何部分，则 `out` 将包含使用该接口新创建的 ndarray 的新引用，或者如果在转换过程中发生错误，则 `out` 将包含 `NULL`。否则，out 将包含对 Py_NotImplemented 的借用引用，并且不设置错误条件。此版本允许在查找 `__array__` 属性的数组接口的部分中设置 dtype。*context* 未使用。

```py
int PyArray_IsZeroDim( *op)
```

如果 *op* 是 `PyArray_Type` 的实例（子类）且维度为 0，则评估为真。

```py
PyArray_IsScalar(op, cls)
```

如果 *op* 是 `Py{cls}ArrType_Type` 的实例，则评估为真。

```py
int PyArray_CheckScalar( *op)
```

如果 *op* 是数组标量（`PyGenericArr_Type` 子类型的实例）之一，或者是维度为 0 的 `PyArray_Type` 的实例（子类），则评估为真。

```py
int PyArray_IsPythonNumber( *op)
```

如果 *op* 是内置数字类型（int、float、complex、long、bool）的实例，则评估为真。

```py
int PyArray_IsPythonScalar( *op)
```

如果 *op* 是内置 Python 标量对象（int、float、complex、bytes、str、long、bool）的实例，则评估为真。

```py
int PyArray_IsAnyScalar( *op)
```

如果 *op* 是 Python 标量对象（参见`PyArray_IsPythonScalar`）或者数组标量（`PyGenericArr_Type` 子类型的实例）之一，则评估为真。

```py
int PyArray_CheckAnyScalar( *op)
```

如果 *op* 是 Python 标量对象（参见`PyArray_IsPythonScalar`）、数组标量（`PyGenericArr_Type` 子类型的实例）或者维度为 0 的 `PyArray_Type` 子类型的实例之一，则评估为真。

### 数据类型检查

对于 typenum 宏，参数是表示枚举数组数据类型的整数。对于数组类型检查宏，参数必须是可直接解释为 PyArrayObject* 的 [PyObject](https://docs.python.org/3/c-api/structures.html#c.PyObject "(在 Python v3.11 中)")*。

```py
int PyTypeNum_ISUNSIGNED(int num)
```

```py
int PyDataType_ISUNSIGNED( *descr)
```

```py
int PyArray_ISUNSIGNED( *obj)
```

Type 表示无符号整数。

```py
int PyTypeNum_ISSIGNED(int num)
```

```py
int PyDataType_ISSIGNED( *descr)
```

```py
int PyArray_ISSIGNED( *obj)
```

Type 表示有符号整数。

```py
int PyTypeNum_ISINTEGER(int num)
```

```py
int PyDataType_ISINTEGER( *descr)
```

```py
int PyArray_ISINTEGER( *obj)
```

Type 表示任何整数。

```py
int PyTypeNum_ISFLOAT(int num)
```

```py
int PyDataType_ISFLOAT( *descr)
```

```py
int PyArray_ISFLOAT( *obj)
```

Type 表示任何浮点数。

```py
int PyTypeNum_ISCOMPLEX(int num)
```

```py
int PyDataType_ISCOMPLEX( *descr)
```

```py
int PyArray_ISCOMPLEX( *obj)
```

Type 表示任何复数浮点数。

```py
int PyTypeNum_ISNUMBER(int num)
```

```py
int PyDataType_ISNUMBER( *descr)
```

```py
int PyArray_ISNUMBER( *obj)
```

Type 表示任何整数、浮点数或复数浮点数。

```py
int PyTypeNum_ISSTRING(int num)
```

```py
int PyDataType_ISSTRING( *descr)
```

```py
int PyArray_ISSTRING( *obj)
```

Type 表示字符串数据类型。

```py
int PyTypeNum_ISPYTHON(int num)
```

```py
int PyDataType_ISPYTHON( *descr)
```

```py
int PyArray_ISPYTHON( *obj)
```

Type 表示枚举类型，对应于标准 Python 标量类型之一（bool、int、float 或 complex）。

```py
int PyTypeNum_ISFLEXIBLE(int num)
```

```py
int PyDataType_ISFLEXIBLE( *descr)
```

```py
int PyArray_ISFLEXIBLE( *obj)
```

类型代表灵活数组类型之一（`NPY_STRING`，`NPY_UNICODE`，或`NPY_VOID`）。

```py
int PyDataType_ISUNSIZED( *descr)
```

类型没有附加大小信息，并且可以调整大小。应仅在灵活的数据类型上调用。附加到数组的类型将始终具有尺寸，因此该宏的数组形式不存在。

在 1.18 版本中更改。

对于没有字段的结构化数据类型，此函数现在返回 False。

```py
int PyTypeNum_ISUSERDEF(int num)
```

```py
int PyDataType_ISUSERDEF( *descr)
```

```py
int PyArray_ISUSERDEF( *obj)
```

类型代表用户定义的类型。

```py
int PyTypeNum_ISEXTENDED(int num)
```

```py
int PyDataType_ISEXTENDED( *descr)
```

```py
int PyArray_ISEXTENDED( *obj)
```

类型是灵活的或用户定义的。

```py
int PyTypeNum_ISOBJECT(int num)
```

```py
int PyDataType_ISOBJECT( *descr)
```

```py
int PyArray_ISOBJECT( *obj)
```

类型代表对象数据类型。

```py
int PyTypeNum_ISBOOL(int num)
```

```py
int PyDataType_ISBOOL( *descr)
```

```py
int PyArray_ISBOOL( *obj)
```

类型代表布尔数据类型。

```py
int PyDataType_HASFIELDS( *descr)
```

```py
int PyArray_HASFIELDS( *obj)
```

类型具有与之关联的字段。

```py
int PyArray_ISNOTSWAPPED( *m)
```

如果数组*m*的数据区域根据数组的数据类型描述符符合机器字节顺序，则评估为真。

```py
int PyArray_ISBYTESWAPPED( *m)
```

如果数组*m*的数据区域根据数组的数据类型描述符*不*符合机器字节顺序，则评估为真。

```py
PyArray_EquivTypes( *type1, *type2)
```

如果*type1*和*type2*实际上代表此平台上的等效类型（忽略每种类型的 fortran 成员），则返回`NPY_TRUE`。例如，在 32 位平台上，`NPY_LONG`和`NPY_INT`是等效的。否则返回`NPY_FALSE`。

```py
PyArray_EquivArrTypes( *a1, *a2)
```

如果*a1*和*a2*是具有等效类型（对于此平台）的数组，则返回`NPY_TRUE`。

```py
PyArray_EquivTypenums(int typenum1, int typenum2)
```

`PyArray_EquivTypes`（…）的特殊情况，不接受灵活的数据类型，但可能更容易调用。

```py
int PyArray_EquivByteorders(int b1, int b2)
```

如果字节顺序字符*b1*和*b2*（`NPY_LITTLE`，`NPY_BIG`，`NPY_NATIVE`，`NPY_IGNORE`）相等或相等于它们对本机字节顺序的规范，则为真。因此，在小端机器上，`NPY_LITTLE`和`NPY_NATIVE`是等效的，在大端机器上则不是。

### 转换数据类型

```py
*PyArray_Cast( *arr, int typenum)
```

主要用于向后兼容 Numeric C-API 和对非灵活类型进行简单转换。返回一个新的数组对象，其中的元素被转换为数据类型*typenum*，它必须是枚举类型之一而不是灵活类型。

```py
*PyArray_CastToType( *arr, *type, int fortran)
```

返回指定*类型*的新数组，将*arr*的元素适当转换。fortran 参数指定输出数组的排序方式。

```py
int PyArray_CastTo( *out, *in)
```

截至 1.6 版本，此函数只是调用`PyArray_CopyInto`来处理转换。

将*in*数组的元素转换为*out*数组。输出数组应该是可写的，具有输入数组的元素数量的整数倍（可以将多个副本放入 out），并且具有内置类型之一的数据类型。成功时返回 0，如果发生错误则返回-1。

```py
PyArray_VectorUnaryFunc *PyArray_GetCastFunc( *from, int totype)
```

返回从给定描述符转换为内置类型编号的低级转换函数。如果不存在转换函数，则返回 `NULL` 并设置错误。使用此函数而不是直接访问 *from* ->f->cast 将允许支持添加到描述符转换字典的任何用户定义的转换函数。

```py
int PyArray_CanCastSafely(int fromtype, int totype)
```

如果 *fromtype* 的数组可以在不丢失信息的情况下转换为 *totype* 的数组，则返回非零值。例外情况是允许将 64 位整数转换为 64 位浮点值，即使这可能导致大整数失去精度，也不会隐式请求使用 long double。此函数不根据灵活数组类型的长度进行检查。

```py
int PyArray_CanCastTo( *fromtype, *totype)
```

`PyArray_CanCastTypeTo` 在 NumPy 1.6 及更高版本中取代了这个函数。

等效于 `PyArray_CanCastTypeTo(fromtype, totype, NPY_SAFE_CASTING)`。

```py
int PyArray_CanCastTypeTo( *fromtype, *totype, casting)
```

自 1.6 版本开始提供。

如果数据类型为 *fromtype*（包括灵活类型），根据转换规则 *casting*，可以安全地转换为数据类型为 *totype*（包括灵活类型）的数组，则返回非零值。对于简单类型，使用 `NPY_SAFE_CASTING`，基本上是 `PyArray_CanCastSafely` 的一个包装器，但对于字符串或 Unicode 等灵活类型，它会考虑到它们的大小。只有当字符串或 Unicode 类型足够大以容纳要转换的整数/浮点数类型的最大值时，整数和浮点数类型才可以使用 `NPY_SAFE_CASTING` 转换为字符串或 Unicode 类型。

```py
int PyArray_CanCastArrayTo( *arr, *totype, casting)
```

自 1.6 版本开始提供。

根据给定的 *casting* 规则，如果 *arr* 可以根据转换规则转换为 *totype*，则返回非零值。如果 *arr* 是数组标量，则还将考虑其值，并且当值转换为较小类型时不会溢出或截断时也返回非零值。

这几乎与 PyArray_CanCastTypeTo(PyArray_MinScalarType(arr), totype, casting) 的结果相同，但它还处理了一个特殊情况，因为具有相同位数的类型的 uint 值集合不是 int 值集合的子集。

```py
*PyArray_MinScalarType( *arr)
```

自 1.6 版本开始提供。

如果 *arr* 是数组，则返回其数据类型描述符；但如果 *arr* 是数组标量（维度为 0），则找到可将值转换为的最小尺寸的数据类型，而不会溢出或截断为整数。

此函数不会将复数转换为浮点数，也不会将任何值转换为布尔值，但当标量值为正时，会将有符号整数转换为无符号整数。

```py
*PyArray_PromoteTypes( *type1, *type2)
```

自 1.6 版本开始提供。

找到 *type1* 和 *type2* 可以安全转换为的最小大小和种类的数据类型。这个函数是对称的和可结合的。字符串或 unicode 结果将是存储将输入类型转换为字符串或 unicode 的最大值所需的正确大小。

```py
*PyArray_ResultType( narrs, **arrs, ndtypes, **dtypes)
```

1.6 版本中新增。

这将类型提升应用于所有输入数组和 dtype 对象，使用 NumPy 规则来组合标量和数组，以确定给定操作的输出类型。这是 ufuncs 产生的相同结果类型。

更详细了解类型提升算法的文档，请参阅`numpy.result_type`。

```py
int PyArray_ObjectType( *op, int mintype)
```

此函数已被 `PyArray_MinScalarType` 和/或 `PyArray_ResultType` 取代。

这个函数对确定两个或更多数组可以转换为的共同类型非常有用。它仅适用于非灵活数组类型，因为没有传递任何项目大小信息。*mintype* 参数表示可接受的最小类型，*op* 表示将转换为数组的对象。返回值是代表 *op* 应该具有的数据类型的枚举类型号。

```py
**PyArray_ConvertToCommonType( *op, int *n)
```

此提供的功能在 1.6 中引入了带有标志`NPY_ITER_COMMON_DTYPE`或对所有操作数具有相同 dtype 参数的迭代器`NpyIter`中大部分已被取代。

将包含在*op*中的 Python 对象的序列转换为具有相同数据类型的 ndarrays 数组。类型的选择方式与*PyArray_ResultType*相同。序列的长度在*n*中返回，返回值为*n*长度的`PyArrayObject`指针数组（如果发生错误，则返回`NULL`）。调用此例程的调用者必须释放返回的数组（使用`PyDataMem_FREE`），并且其中的所有数组对象都必须被`DECREF`‘d，否则将发生内存泄漏。下面的示例模板代码显示了典型的用法：

自版本 1.18.0 更改：标量和零维数组的混合现在会产生一个能够容纳标量值的类型。以前，优先考虑数组的 dtype。

```py
mps  =  PyArray_ConvertToCommonType(obj,  &n);
if  (mps==NULL)  return  NULL;
{code}
<before  return>
for  (i=0;  i<n;  i++)  Py_DECREF(mps[i]);
PyDataMem_FREE(mps);
{return} 
```

```py
char *PyArray_Zero( *arr)
```

指向新创建的大小为*arr* ->itemsize 的内存的指针，该内存保存该类型的表示为 0 的表示。返回的指针*ret*，**必须使用** `PyDataMem_FREE` (ret) **释放**，当不再需要时。

```py
char *PyArray_One( *arr)
```

指向新创建的大小为*arr* ->itemsize 的内存的指针，该内存保存该类型的表示为 1 的表示。返回的指针*ret*，**必须使用** `PyDataMem_FREE` (ret) **释放**，当不再需要时。

```py
int PyArray_ValidType(int typenum)
```

如果*typenum*表示有效的类型号（内置的或用户定义的或字符代码），则返回`NPY_TRUE`。否则，该函数返回`NPY_FALSE`。

### 用户定义的数据类型

```py
void PyArray_InitArrFuncs( *f)
```

初始化所有函数指针和成员为`NULL`。

```py
int PyArray_RegisterDataType( *dtype)
```

注册一个数据类型为数组的新用户定义数据类型。该类型必须填写大部分条目。这通常不会被检查，并且会产生段错误。特别是，`dtype`结构的 typeobj 成员必须填写有一个具有与*dtype*中的元素大小相对应的固定大小元素大小的 Python 类型。此外，`f`成员必须具有所需的函数：nonzero、copyswap、copyswapn、getitem、setitem 和 cast（如果不需要支持，则一些转换函数可能为`NULL`）。为避免混淆，应选择一个唯一的字符类型码，但这并未强制执行，且在内部不依赖于此。

返回一个用户定义类型数字，用于唯一标识该类型。然后可以使用返回的类型号从`PyArray_DescrFromType`中获取到新结构的指针。如果发生错误则返回-1。如果已经注册过这个*dtype*(只根据指针的地址检查)，则返回先前分配的类型号。

```py
int PyArray_RegisterCastFunc( *descr, int totype, PyArray_VectorUnaryFunc *castfunc)
```

注册一个低级转换函数*castfunc*，以从数据类型*descr*转换为给定的数据类型号*totype*。任何旧的转换函数都将被覆盖。成功时返回`0`，失败时返回`-1`。

```py
int PyArray_RegisterCanCast( *descr, int totype, scalar)
```

将数据类型号*totype*注册为可以从给定*scalar*类型的数据类型对象*descr*进行转换。使用*scalar* = `NPY_NOSCALAR`来注册，即一个数据类型为*descr*的数组可以安全地转换为类型编号为*totype*的数据类型。成功时返回值为 0，失败时返回-1。

```py
int PyArray_TypeNumFromName(char const *str)
```

给定一个字符串，返回具有该字符串为类型对象名称的数据类型的类型号。如果找不到类型，则返回`NPY_NOTYPE`而不设置错误。仅适用于用户定义的数据类型。

### NPY_OBJECT 的特殊功能

警告

当使用填充有对象的数组或缓冲区时，NumPy 会尽量确保在可以读取任何数据之前，这些缓冲区都填充有`None`。但是，可能存在代码路径，其中数组只被初始化为`NULL`。NumPy 本身接受`NULL`作为`None`的别名，但在调试模式下编译时，可能会`assert`非`NULL`。

因为 NumPy 在初始化为 None 方面尚不一致，用户**必须**在处理由 NumPy 创建的缓冲区时，预期得到一个`NULL`值。用户**还应该**确保向 NumPy 传递完全初始化的缓冲区，因为 NumPy 将来可能会将此作为强制要求。

目前打算确保 NumPy 在可以读取对象数组之前总是初始化它们。任何未能这样做的情况将被视为错误。将来，用户可以依赖于从任何数组中读取时为非 NULL 值，尽管可能会为新创建的数组的写入保留异常（例如，在 ufunc 代码中的输出数组）。截至 NumPy 1.23，存在已知的代码路径存在未进行正确填充的情况。

```py
int PyArray_INCREF( *op)
```

用于包含任何 Python 对象的数组 *op*。根据*op*的数据类型来增加数组中每个对象的引用计数。如果发生错误，则返回-1，否则返回 0。

```py
void PyArray_Item_INCREF(char *ptr, *dtype)
```

一个函数，根据数据类型 *dtype* 来增加位置*ptr*处的所有对象的引用计数。如果*ptr*是具有偏移量处的对象的结构类型的起始位置，则这将（递归地）增加结构类型中所有类似对象的引用计数。

```py
int PyArray_XDECREF( *op)
```

用于包含任何 Python 对象的数组 *op*。它根据*op*的数据类型来递减数组中每个对象的引用计数。正常的返回值是 0。如果发生错误，返回-1。

```py
void PyArray_Item_XDECREF(char *ptr, *dtype)
```

一个函数，用于按照数据类型 *dtype* 中记录的位置 *ptr* 来 XDECREF 所有类似对象的项目。这将递归地工作，以便如果 `dtype` 本身具有包含类似对象的数据类型的字段，则将 XDECREF 所有类似对象的字段。

```py
void PyArray_FillObjectArray( *arr, *obj)
```

用单个值 obj 填充新创建的数组中结构的所有位置，该结构具有对象数据类型。不执行任何检查，但 *arr* 必须是`NPY_OBJECT`数据类型的单段且未初始化（位置中没有以前的对象）。如果需要在调用此函数之前递减对象数组中的所有项目，请使用`PyArray_XDECREF` (*arr*)。

```py
int PyArray_SetWritebackIfCopyBase( *arr, *base)
```

先决条件：`arr`是`base`的副本（尽管可能具有不同的步幅、顺序等）。设置`NPY_ARRAY_WRITEBACKIFCOPY`标志和`arr->base`，并将`base`设置为只读。在调用 *Py_DECREF* 之前，调用`PyArray_ResolveWritebackIfCopy`以将任何更改复制回`base`并重置只读标志。

返回 0 表示成功，-1 表示失败。

## 数组标志

结构`PyArrayObject`的`flags`属性包含有关数组使用的内存的重要信息（由数据成员指向）。此标志信息必须保持准确，否则可能会产生奇怪的结果，甚至可能会出现段错误。

有 6 个（二进制）标志描述了数据缓冲区使用的内存区域。这些常量在 `arrayobject.h` 中定义，并确定了标志的位位置。Python 公开了一个很好的基于属性的接口，以及一个类似于字典的接口，用于获取（如果合适，设置）这些标志。

所有类型的内存区域都可以由 ndarray 指向，这需要这些标志。如果你在 C 代码中得到一个任意的 `PyArrayObject`，你需要注意已设置的标志。如果你需要保证某种类型的数组（例如 `NPY_ARRAY_C_CONTIGUOUS` 和 `NPY_ARRAY_BEHAVED`），那么将这些要求传递给 PyArray_FromAny 函数。

### 基本数组标志

一个 ndarray 可以有一个数据段，不是一个简单连续的良好内存块，你可以操纵它。它可能不会与字边界对齐（在某些平台上非常重要）。它的数据可能与机器识别的字节顺序不同。它可能不可写。它可能是 Fortran 连续的顺序。数组标志用于指示与数组相关的数据可以说什么。

在 NumPy 的 1.6 版本及更早版本中，以下标志中没有在它们中间使用 _ARRAY_ 宏命名空间。这种常量命名形式在 1.7 版本中已经过时。

```py
NPY_ARRAY_C_CONTIGUOUS
```

数据区域是以 C 风格连续顺序排列的（最后一个索引变化最快）。

```py
NPY_ARRAY_F_CONTIGUOUS
```

数据区域是以 Fortran 风格连续顺序排列的（第一个索引变化最快）。

注意

数组可以同时是 C 风格和 Fortran 风格连续的。这对于 1 维数组是清楚的，但对于更高维度的数组也是真实的。

即使对于连续的数组，对于给定维度 `arr.strides[dim]` 的步幅可能是*任意*的，如果 `arr.shape[dim] == 1` 或数组没有元素。对于 C 风格连续数组或 Fortran 风格连续数组，通常不会满足 `self.strides[-1] == self.itemsize` 或 `self.strides[0] == self.itemsize`。从 C API 中访问数组的 `itemsize` 的正确方法是 `PyArray_ITEMSIZE(arr)`。

另见

ndarray 的内部内存布局

```py
NPY_ARRAY_OWNDATA
```

数据区域是由该数组拥有的。不应该手动设置，而是创建一个包装数据的 `PyObject` 并将数组的基础设置为该对象。例如，请参阅 `test_mem_policy` 中的测试。

```py
NPY_ARRAY_ALIGNED
```

数据区域和所有数组元素都适当地对齐。

```py
NPY_ARRAY_WRITEABLE
```

数据区域可以被写入。

注意上述 3 个标志被定义为一个新的、良好的数组，这些标志被定义为 true。

```py
NPY_ARRAY_WRITEBACKIFCOPY
```

数据区域表示一个（良好的）副本，在调用 `PyArray_ResolveWritebackIfCopy` 时应将其信息传输回原始副本。

这是一个特殊的标志，如果此数组表示的是因用户在 `PyArray_FromAny` 中需要某些标志而创建的副本，并且必须对某个其他数组进行复制（且用户要求在这种情况下设置此标志），则设置此标志。然后，基本属性将指向“不规范”数组（设置为只读）。`PyArray_ResolveWritebackIfCopy` 将其内容复制回“不规范”数组（必要时进行转换），并将“不规范”数组重置为 `NPY_ARRAY_WRITEABLE`。如果“不规范”数组一开始就不是 `NPY_ARRAY_WRITEABLE`，则 `PyArray_FromAny` 将返回一个错误，因为无法进行 `NPY_ARRAY_WRITEBACKIFCOPY`。

`PyArray_UpdateFlags` (obj, flags) 将更新`obj->flags`，使其符合`flags`，而`flags`可以是`NPY_ARRAY_C_CONTIGUOUS`、`NPY_ARRAY_F_CONTIGUOUS`、`NPY_ARRAY_ALIGNED`或`NPY_ARRAY_WRITEABLE`之一。

### 数组标志的组合

```py
NPY_ARRAY_BEHAVED
```

`NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`

```py
NPY_ARRAY_CARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_CARRAY_RO
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_FARRAY_RO
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_DEFAULT
```

`NPY_ARRAY_CARRAY`

```py
NPY_ARRAY_UPDATE_ALL
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

### 类似标志的常量

这些常量用于`PyArray_FromAny`（及其宏形式）中，以指定新数组的期望属性。

```py
NPY_ARRAY_FORCECAST
```

强制转换为所需类型，即使这样做会丢失信息。

```py
NPY_ARRAY_ENSURECOPY
```

确保结果数组是原始数组的副本。

```py
NPY_ARRAY_ENSUREARRAY
```

确保结果对象是一个真正的 ndarray，而不是一个子类。

### 标志检查

对于所有这些宏，*arr* 必须是（子类的）`PyArray_Type` 的实例。

```py
int PyArray_CHKFLAGS( *arr, int flags)
```

第一个参数 arr 必须是一个 ndarray 或其子类。参数*flags*应该是一个整数，由数组可能拥有的标志的位组合组成：`NPY_ARRAY_C_CONTIGUOUS`, `NPY_ARRAY_F_CONTIGUOUS`, `NPY_ARRAY_OWNDATA`, `NPY_ARRAY_ALIGNED`, `NPY_ARRAY_WRITEABLE`, `NPY_ARRAY_WRITEBACKIFCOPY`。

```py
int PyArray_IS_C_CONTIGUOUS( *arr)
```

如果 *arr* 是 C 风格连续的，则为真。

```py
int PyArray_IS_F_CONTIGUOUS( *arr)
```

如果 *arr* 是 Fortran 风格连续的，则为真。

```py
int PyArray_ISFORTRAN( *arr)
```

如果 *arr* 是 Fortran 风格的连续存储且*不是* C 风格的连续存储，则为真。 `PyArray_IS_F_CONTIGUOUS` 是测试 Fortran 风格连续性的正确方式。

```py
int PyArray_ISWRITEABLE( *arr)
```

如果 *arr* 的数据区域可以写入，则为真。

```py
int PyArray_ISALIGNED( *arr)
```

如果 *arr* 的数据区域在机器上是正确对齐的，则为真。

```py
int PyArray_ISBEHAVED( *arr)
```

如果 *arr* 的数据区域根据其描述符是对齐的且可写，并且符合机器字节顺序，则为真。

```py
int PyArray_ISBEHAVED_RO( *arr)
```

如果 *arr* 的数据区域是对齐的并且符合机器字节顺序，则为真。

```py
int PyArray_ISCARRAY( *arr)
```

如果 *arr* 的数据区域是 C 风格连续的，并且 `PyArray_ISBEHAVED` (*arr*) 为 true，则为真。

```py
int PyArray_ISFARRAY( *arr)
```

如果 *arr* 的数据区域是 Fortran 风格连续的，并且 `PyArray_ISBEHAVED` (*arr*) 为 true，则为真。

```py
int PyArray_ISCARRAY_RO( *arr)
```

如果 *arr* 的数据区域是 C 风格的连续存储，对齐且符合机器字节顺序，则为真。

```py
int PyArray_ISFARRAY_RO( *arr)
```

如果 *arr* 的数据区域是 Fortran 风格连续的，对齐且符合机器字节顺序**，** 则为真。

```py
int PyArray_ISONESEGMENT( *arr)
```

如果 *arr* 的数据区域由一个（C 风格或 Fortran 风格）连续段组成，则为真。

```py
void PyArray_UpdateFlags( *arr, int flagmask)
```

`NPY_ARRAY_C_CONTIGUOUS`、`NPY_ARRAY_ALIGNED` 和 `NPY_ARRAY_F_CONTIGUOUS` 数组标志可以从数组对象本身 "计算" 出来。此程序根据 *flagmask* 指定的方式通过进行所需的计算来更新 *arr* 中的一个或多个标志。

警告

当数组进行操作可能导致这些标志发生变化时，保持标志更新是很重要的。稍后在 NumPy 中依赖这些标志状态进行的计算不会重复进行计算以更新它们。

```py
int PyArray_FailUnlessWriteable( *obj, const char *name)
```

如果*obj*是可写的，此函数不执行任何操作并返回 0。如果*obj*不可写，则引发异常并返回-1。它也可以执行其他一些工作，比如对即将成为视图的数组发出警告。写入数组之前一定要在某个时刻调用此函数。

*name*是数组的名称，用于提供更好的错误消息。它可以是类似于“分配目标”、“输出数组”甚至只是“数组”之类的东西。

### 基本数组标志

一个 ndarray 可能有一个数据段，它不是一个简单的连续的行为良好的内存块，你可以对其进行操作。它可能不与字边界对齐（在一些平台上非常重要）。它可能具有与机器识别不同的字节顺序。它可能是不可写的。它可能是 Fortran 连续顺序的。数组标志用于指示与数组关联的数据可以说什么。

在 NumPy 的 1.6 版本及更早版本中，以下标志没有在它们中包含 _MACRO_ 名称空间。这种常量名称形式在 1.7 中已经被弃用。

```py
NPY_ARRAY_C_CONTIGUOUS
```

数据区域以 C 风格的连续顺序排列（最后一个索引变化最快）。

```py
NPY_ARRAY_F_CONTIGUOUS
```

数据区域以 Fortran 风格的连续顺序排列（第一个索引变化最快）。

注意

数组可以同时是 C 风格和 Fortran 风格连续的。这对于 1 维数组是显而易见的，但对于更高维的数组也可能成立。

即使对于连续数组，对于给定维度的步长`arr.strides[dim]`可能是*任意的*，如果`arr.shape[dim] == 1`或者数组没有元素。对于 C 风格的连续数组，通常`self.strides[-1] == self.itemsize`或者对于 Fortran 风格的连续数组`self.strides[0] == self.itemsize`是错误的。从 C API 访问数组的`itemsize`的正确方式是`PyArray_ITEMSIZE(arr)`。

请参阅

ndarray 的内部内存布局

```py
NPY_ARRAY_OWNDATA
```

数据区域归此数组所有。不应手动设置，而是创建一个包装数据的`PyObject`，并将数组的基础设置为该对象。例如，请参阅`test_mem_policy`中的测试。

```py
NPY_ARRAY_ALIGNED
```

数据区域和所有数组元素都被适当地对齐。

```py
NPY_ARRAY_WRITEABLE
```

数据区域可以被写入。

请注意，上述的 3 个标志被定义为一个新的、行为良好的数组具有这些标志为真。

```py
NPY_ARRAY_WRITEBACKIFCOPY
```

数据区域表示一个（行为良好的）副本，当调用`PyArray_ResolveWritebackIfCopy`时，其信息应被传输回原始数组。

这是一个特殊标志，如果该数组代表因用户要求 `PyArray_FromAny` 中存在某些特定标志而必须对其他数组进行复制而产生的副本，那么就会设置这个标志。然后，base 属性指向“不端正”的数组（设置为只读）。 `PyArray_ResolveWritebackIfCopy` 将把其内容复制回“不端正”的数组（必要时转换类型），并将“不端正”的数组重置为 `NPY_ARRAY_WRITEABLE`。如果“不端正”的数组一开始就不是 `NPY_ARRAY_WRITEABLE`，那么 `PyArray_FromAny` 将返回错误，因为此时不可能设置 `NPY_ARRAY_WRITEBACKIFCOPY`。

`PyArray_UpdateFlags` (obj, flags) 将为 `flags` 更新 `obj->flags`，其中 `flags` 可以是 `NPY_ARRAY_C_CONTIGUOUS`、`NPY_ARRAY_F_CONTIGUOUS`、`NPY_ARRAY_ALIGNED` 或 `NPY_ARRAY_WRITEABLE` 中的任何一个。

### 数组标志的组合

```py
NPY_ARRAY_BEHAVED
```

`NPY_ARRAY_ALIGNED` | `NPY_ARRAY_WRITEABLE`

```py
NPY_ARRAY_CARRAY
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_CARRAY_RO
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_FARRAY
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_BEHAVED`

```py
NPY_ARRAY_FARRAY_RO
```

`NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

```py
NPY_ARRAY_DEFAULT
```

`NPY_ARRAY_CARRAY`

```py
NPY_ARRAY_UPDATE_ALL
```

`NPY_ARRAY_C_CONTIGUOUS` | `NPY_ARRAY_F_CONTIGUOUS` | `NPY_ARRAY_ALIGNED`

### 类似标志的常量

这些常量用于 `PyArray_FromAny`（及其宏形��）中，用于指定新数组的期望属性。

```py
NPY_ARRAY_FORCECAST
```

强制转换为所需类型，即使在不丢失信息的情况下也无法执行。

```py
NPY_ARRAY_ENSURECOPY
```

确保生成的数组是原始数组的副本。

```py
NPY_ARRAY_ENSUREARRAY
```

确保生成的对象是一个实际的 ndarray，而不是一个子类。

### 标志检查

对于所有这些宏，*arr*必须是`PyArray_Type`的实例或子类。

```py
int PyArray_CHKFLAGS( *arr, int flags)
```

第一个参数，arr，必须是一个 ndarray 或其子类。参数*flags*应该是一个整数，由数组可能具有的所有标志的位组合组成：`NPY_ARRAY_C_CONTIGUOUS`，`NPY_ARRAY_F_CONTIGUOUS`，`NPY_ARRAY_OWNDATA`，`NPY_ARRAY_ALIGNED`，`NPY_ARRAY_WRITEABLE`，`NPY_ARRAY_WRITEBACKIFCOPY`。

```py
int PyArray_IS_C_CONTIGUOUS( *arr)
```

评估如果*arr*是 C 风格连续的是真。

```py
int PyArray_IS_F_CONTIGUOUS( *arr)
```

评估如果*arr*是 Fortran 风格连续的是真。

```py
int PyArray_ISFORTRAN( *arr)
```

评估如果*arr*是 Fortran 风格连续并且*不是* C 风格连续。`PyArray_IS_F_CONTIGUOUS` 是测试 Fortran 风格连续性的正确方式。

```py
int PyArray_ISWRITEABLE( *arr)
```

评估如果*arr*的数据区域可以被写入是真

```py
int PyArray_ISALIGNED( *arr)
```

评估如果*arr*的数据区域在机器上正确对齐是真。

```py
int PyArray_ISBEHAVED( *arr)
```

评估如果*arr*的数据区域是对齐的、可写的并且按照其描述符的机器字节顺序排列是真。

```py
int PyArray_ISBEHAVED_RO( *arr)
```

评估*arr*的数据区域是否对齐并且按照机器字节顺序排列是真。

```py
int PyArray_ISCARRAY( *arr)
```

评估如果*arr*的数据区域是 C 风格连续的，且`PyArray_ISBEHAVED` (*arr*)为真，则为真。

```py
int PyArray_ISFARRAY( *arr)
```

评估如果*arr*的数据区域是 Fortran 风格连续的，并且`PyArray_ISBEHAVED` (*arr*)是真。

```py
int PyArray_ISCARRAY_RO( *arr)
```

评估如果*arr*的数据区域是 C 风格连续的、对齐的并且按照机器字节顺序排列是真。

```py
int PyArray_ISFARRAY_RO( *arr)
```

评估如果*arr*的数据区域是 Fortran 风格连续的、对齐的并且按照机器字节顺序排列**.**是真。

```py
int PyArray_ISONESEGMENT( *arr)
```

评估如果*arr*的数据区域由单个（C 风格或 Fortran 风格）连续段组成是真。

```py
void PyArray_UpdateFlags( *arr, int flagmask)
```

`NPY_ARRAY_C_CONTIGUOUS`，`NPY_ARRAY_ALIGNED`和`NPY_ARRAY_F_CONTIGUOUS`数组标志可以从数组对象本身“计算”出来。该例程通过执行所需的计算，根据*flagmask*指定的参数更新*arr*的一个或多个标志。

警告

在进行可能导致它们发生变化的数组处理时，保持标志的更新（使用`PyArray_UpdateFlags`可以有所帮助）是非常重要的。 NumPy 中依赖于这些标志状态的后续计算不会重复计算以更新它们。

```py
int PyArray_FailUnlessWriteable( *obj, const char *name)
```

如果*obj*可写，该函数什么也不做并返回 0。如果*obj*不可写，它会引发异常并返回-1。它还可能进行其他一些内部管理工作，比如针对正在转换为视图的数组发出警告。在对数组进行写操作之前，一定要在某个时候调用此函数。

*name*是数组的名称，用于提供更好的错误消息。可以是“赋值目标”，“输出数组”，甚至只是“数组”之类的东西。

## 数组方法的替代 API

### 转换

```py
*PyArray_GetField( *self, *dtype, int offset)
```

等同于`ndarray.getfield` (*self*, *dtype*, *offset*)。此函数[窃取引用](https://docs.python.org/3/c-api/intro.html?reference-count-details)到*PyArray_Descr*并返回一个使用当前数组中指定*offset*字节位置上的数据创建的给定*dtype*的新数组。新数组类型的*offset*加上其 itemsize 必须小于`self ->descr->elsize`，否则会引发错误。使用原始数组的相同形状和跨度。因此，此函数的效果是从结构化数组中返回字段。但它也可以用于从任何数组类型中选择特定的字节或字节组。

```py
int PyArray_SetField( *self, *dtype, int offset, *val)
```

等同于`ndarray.setfield` (*self*, *val*, *dtype*, *offset* )。将从指定*offset*字节开始并且具有给定*dtype*的字段设置为*val*。*offset*加上*dtype* ->elsize 必须小于*self* ->descr->elsize，否则会引发错误。否则，将*val*参数转换为数组并复制到所指向的字段中。如有必要，目标数组的元素将重复以填充，但目标数组中的元素数量必须是*val*元素数量的整数倍。

```py
*PyArray_Byteswap( *self, inplace)
```

等同于`ndarray.byteswap` (*self*, *inplace*)。返回一个数据区域进行字节交换的数组。如果*inplace*非零，那么就原地进行字节交换并返回对自身的引用。否则，创建一个字节交换的副本，并保持自身不变。

```py
*PyArray_NewCopy( *old, order)
```

等同于`ndarray.copy` (*self*, *fortran*)。创建一个*old*数组的副本。返回的数组始终是对齐的和可写的，并且数据的解释与旧数组相同。如果*order*是`NPY_CORDER`，则返回一个 C 风格的连续数组。如果*order*是`NPY_FORTRANORDER`，则返回一个 Fortran 风格的连续数组。如果*order is* `NPY_ANYORDER`，则返回的数组仅在旧数组为 Fortran 风格连续时才是 Fortran 风格连续；否则，它就是 C 风格连续的。

```py
*PyArray_ToList( *self)
```

相当于`ndarray.tolist` (*self*)。从*自我*返回一个嵌套的 Python 列表。

```py
*PyArray_ToString( *self, order)
```

相当于`ndarray.tobytes` (*self*, *order*)。以 Python 字符串的形式返回此数组的字节。

```py
*PyArray_ToFile( *self, FILE *fp, char *sep, char *format)
```

以 C 风格的连续方式将*自我*的内容写入文件指针*fp*中。如果*sep*是字符串“”或`NULL`，则以二进制字节形式写入数据。否则，使用*sep*字符串作为项目分隔符，以文本形式写入*自我*的内容。将每个项目打印到文件中。如果*format*字符串不是`NULL`或“”，那么它是一个 Python 打印语句格式字符串，显示如何写入项目。

```py
int PyArray_Dump( *self, *file, int protocol)
```

将对象*自我*在给定的*文件*（可以是字符串或 Python 文件对象）中保存起来。如果*file*是 Python 字符串，则被视为文件的名称，然后以二进制模式打开。使用给定的*protocol*（如果*protocol*为负数，则使用最高可用值）。这只是 cPickle.dump(*self*, *file*, *protocol*)的简单包装。

```py
*PyArray_Dumps( *self, int protocol)
```

将*自我*中的对象 pickle 为 Python 字符串并返回它。使用提供的 Pickle *protocol*（如果*protocol*为负数，则使用最高可用值）。

```py
int PyArray_FillWithScalar( *arr, *obj)
```

用给定的标量对象*obj*填充数组*arr*。首先将对象转换为*arr*的数据类型，然后复制到每个位置。如果发生错误，则返回-1，否则返回 0。

```py
*PyArray_View( *self, *dtype, *ptype)
```

相当于`ndarray.view` (*self*, *dtype*)。将数组*自我*作为可能不同数据类型的新视图返回，并作为不同的数组子类*ptype*。

如果*dtype*为`NULL`，则返回的数组将具有与*自我*相同的数据类型。新数据类型必须与*自我*的大小一致。要么项目大小必须相同，要么*自我*必须是单段的，并且总字节数必须相同。在后一种情况下，返回的数组的维数将在最后一个（或第一个对于 Fortran 样式连续数组）维度上进行更改。返回数组的数据区域与*自我*完全相同。

### 形状操作

```py
*PyArray_Newshape( *self, *newshape, order)
```

结果将是一个新数组（如果可能的话指向与*自我*相同的内存位置），但具有*newshape*给定的形状。如果新形状与*自我*的步幅不兼容，则将返回具有新指定形状的数组的副本。

```py
*PyArray_Reshape( *self, *shape)
```

相当于`ndarray.reshape` (*self*, *shape*)，其中*shape*是一个序列。将*shape*转换为`PyArray_Dims`结构，并在内部调用`PyArray_Newshape`。为了向后兼容 - 不建议使用

```py
*PyArray_Squeeze( *self)
```

等同于`ndarray.squeeze`（*self*）。返回* self *的所有长度为 1 的维度均已移除的新视图。

警告

矩阵对象始终是 2 维的。因此，数组的矩阵子类上调用`PyArray_Squeeze`不产生任何效果。

```py
*PyArray_SwapAxes( *self, int a1, int a2)
```

等同于`ndarray.swapaxes`（*self*，*a1*，*a2*）。返回的数组是* self *中给定轴*a1*和*a2*交换后的新视图。

```py
*PyArray_Resize( *self, *newshape, int refcheck, fortran)
```

等同于`ndarray.resize`（*self*，*newshape*，refcheck `=` *refcheck*，order=fortran）。此函数仅适用于单段数组。它会就地更改* self *的形状，并且如果* newshape *的元素总数与旧形状不同时，将为* self *重新分配内存。如果需要重新分配，则* self *必须拥有其数据，*self* - `>base==NULL`，*self* - `>weakrefs==NULL`，并且（除非 refcheck 为 0）不能被任何其他数组引用。 fortran 参数可以是`NPY_ANYORDER`、`NPY_CORDER`或`NPY_FORTRANORDER`。目前对它没有影响。将来可能用于确定在构建维度不同的数组时，调整大小操作应如何查看数据。成功时返回 None，出错时返回 NULL。

```py
*PyArray_Transpose( *self, *permute)
```

等同于`ndarray.transpose`（*self*，*permute*）。根据数据结构* permute *重新排列 ndarray 对象* self *的轴并返回结果。如果* permute *为`NULL`，则结果数组的轴被颠倒。例如，如果*self*的形状为\(10\times20\times30\)，并且*permute*`.ptr`为（0,2,1），则结果的形状为\(10\times30\times20.\)如果* permute *为`NULL`，则结果的形状为\(30\times20\times10.\)

```py
*PyArray_Flatten( *self, order)
```

等同于`ndarray.flatten`（*self*，*order*）。返回数组的 1 维副本。如果*order*为`NPY_FORTRANORDER`，则按 Fortran 顺序扫描元素（第一维最快变化）。如果*order*为`NPY_CORDER`，则按 C 顺序扫描`self`的元素（最后一维最快变化）。如果*order*为`NPY_ANYORDER`，则使用`PyArray_ISFORTRAN`（*self*）的结果确定要展平的顺序。

```py
*PyArray_Ravel( *self, order)
```

等价于*self*.ravel(*order*)。与`PyArray_Flatten` (*self*, *order*)具有相同的基本功能，除了如果*order*为 0 且*self*是 C 风格连续的，则形状会被改变但不执行复制。

### 项目选择和操作。

```py
*PyArray_TakeFrom( *self, *indices, int axis, *ret, clipmode)
```

等价于`ndarray.take` (*self*, *indices*, *axis*, *ret*, *clipmode*)，除了在 Python 中*axis* =None 的情况下通过在 C 中设置*axis* = `NPY_MAXDIMS`来获得。沿给定的*axis*提取*self*中由整数值*indices*指定的项目。clipmode 参数可以是`NPY_RAISE`、`NPY_WRAP`或`NPY_CLIP`，以表示对越界索引的处理方式。*ret*参数可以指定输出数组，而不是在内部创建一个新的。

```py
*PyArray_PutTo( *self, *values, *indices, clipmode)
```

等价于*self*.put(*values*, *indices*, *clipmode*)。将*values*放入*self*中对应（展平的）*indices*的位置。如果*values*太小，它将根据需要重复。

```py
*PyArray_PutMask( *self, *values, *mask)
```

在*mask*对应为真的位置（使用展平的上下文）将*values*放入*self*中。*mask*和*self*数组必须具有相同的元素总数。如果*values*太小，将根据需要重复。

```py
*PyArray_Repeat( *self, *op, int axis)
```

等价于`ndarray.repeat` (*self*, *op*, *axis*)。沿给定的*axis*复制*self*中的元素*op*次。*op*可以是一个标量整数或长度为*self* ->dimensions[*axis*]的序列，表示在轴上重复每个项目的次数。

```py
*PyArray_Choose( *self, *op, *ret, clipmode)
```

等价于`ndarray.choose` (*self*, *op*, *ret*, *clipmode*)。根据*self*中的整数值，从*op*中的数组序列中选择元素，创建一个新数组。这些数组必须全部可以广播到相同的形状，并且*self*中的条目应在 0 和 len(*op*)之间。如果*ret*为 NULL，则输出被放置在*ret*中，否则将创建新的输出。*clipmode*参数决定当*self*中的条目不在 0 和 len(*op*)之间时的行为。

```py
NPY_RAISE
```

引发 ValueError;

```py
NPY_WRAP
```

将小于 0 的值通过添加 len(*op*)来封装，将大于等于 len(*op*)的值通过减去 len(*op*)来封装，直到它们在范围内；

```py
NPY_CLIP
```

所有值都被限制在 0, len(*op*) )的范围内。

```py
*PyArray_Sort( *self, int axis, kind)
```

等价于[`ndarray.sort` (*self*, *axis*, *kind*)。返回一个按*axis*排序的*self*数组。数组使用由*kind*表示的算法排序，它是一个整数/枚举，指向所使用的排序算法的类型。

```py
*PyArray_ArgSort( *self, int axis)
```

等同于`ndarray.argsort`（*self*，*axis*）。返回一个索引数组，按给定的`axis`选择这些索引将返回*self*的排序版本。如果*self*->descr 是一个已定义字段的数据类型，则使用 self->descr->names 来确定排序顺序。第一个字段相等的比较将使用第二个字段，依此类推。要更改结构化数组的排序顺序，需创建一个具有不同名称顺序的新数据类型，并使用该新数据类型构造数组的视图。

```py
*PyArray_LexSort( *sort_keys, int axis)
```

给定一个相同形状的数组序列（*sort_keys*），返回一个与`PyArray_ArgSort`（…）类似的索引数组，该数组按字典顺序对数组进行排序。字典顺序指定当找到两个键相等时，基于后续键的比较顺序。合并排序（使相等的条目不动）需要为类型进行定义。排序通过首先使用第一个*sort_key*，然后使用第二个*sort_key*，依此类推来对索引进行排序来完成。这等同于 Python 命令 lexsort(*sort_keys*, *axis*)。由于合并排序的工作方式，一定要理解*sort_keys*的顺序（与比较两个元素时使用的顺序相反）。

如果这些数组都被收集到一个结构化数组中，那么`PyArray_Sort`（…）也可以用来直接对数组进行排序。

```py
*PyArray_SearchSorted( *self, *values, side, *perm)
```

等同于`ndarray.searchsorted`（*self*，*values*，*side*，*perm*）。假设*self*是一个按升序排列的一维数组，则输出是一个与*values*形状相同的索引数组，使得，如果将*values*中的元素插入到这些索引之前，*self*的顺序将被保留。不会对*self*是否按升序排列进行检查。

*side*参数指示返回的索引应该是第一个合适位置（如果是`NPY_SEARCHLEFT`）或最后一个位置（如果是`NPY_SEARCHRIGHT`）。

如果*sorter*参数不是`NULL`，必须是一个与*self*相同长度的整数索引的一维数组，可以将*self*排序为升序。这通常是对`PyArray_ArgSort`（…）的调用结果。二分搜索用于找到所需的插入点。

```py
int PyArray_Partition( *self, *ktharray, int axis, which)
```

等同于`ndarray.partition` (*self*, *ktharray*, *axis*, *kind*)。将数组分区，使得由*ktharray*索引的元素值位于数组全排序后的位置，并将所有小于第 k 个元素的元素放在第 k 个元素之前，大于或等于第 k 个元素的元素放在第 k 个元素之后。分区内所有元素的排序是未定义的。如果*self*->descr 是具有字段定义的数据类型，则使用 self->descr->names 来确定排序顺序。如果第一个字段相等，则使用第二个字段，依此类推。要改变结构化数组的排序顺序，创建一个具有不同名称顺序的新数据类型，并使用该新数据类型构建数组的视图。成功返回零，失败返回-1。

```py
*PyArray_ArgPartition( *op, *ktharray, int axis, which)
```

等同于`ndarray.argpartition` (*self*, *ktharray*, *axis*, *kind*)。返回一个索引数组，选择这些索引沿着给定的`axis`将返回分区版本的*self*。

```py
*PyArray_Diagonal( *self, int offset, int axis1, int axis2)
```

等同于`ndarray.diagonal` (*self*, *offset*, *axis1*, *axis2* )。返回由*axis1*和*axis2*定义的 2 维数组的*offset*对角线。

```py
PyArray_CountNonzero( *self)
```

版本 1.6 中新增。

计算数组对象*self*中非零元素的数量。

```py
*PyArray_Nonzero( *self)
```

等同于`ndarray.nonzero` (*self*)。返回一个数组的索引数组元组，选择*self*中不为零的元素。如果（nd=`PyArray_NDIM`](#c.PyArray_NDIM "PyArray_NDIM")(`self`))==1，则返回单个索引数组。索引数组具有数据类型`NPY_INTP`。如果返回一个元组（nd \(\neq\) 1），则其长度为 nd。

```py
*PyArray_Compress( *self, *condition, int axis, *out)
```

等同于`ndarray.compress` (*self*, *condition*, *axis* )。返回沿着*axis*对应于*condition*中为真的元素。

### 计算

提示

为了达到在 Python 中传入`axis=None`的效果（将数组视为 1 维数组），在轴上传入`NPY_MAXDIMS`。

注意

out 参数指定结果放置的位置。如果 out 为 NULL，则创建输出数组，否则将输出放置在必须是正确大小和类型的 out 中。即使 out 不为 NULL，始终返回对输出数组的新引用。如果不为 NULL，则调用该例程的调用者有责任`Py_DECREF` out，否则将导致内存泄漏。

```py
*PyArray_ArgMax( *self, int axis, *out)
```

等同于`ndarray.argmax`（*self*，*axis*）。返回*self*沿*axis*的最大元素的索引。

```py
*PyArray_ArgMin( *self, int axis, *out)
```

等同于`ndarray.argmin`（*self*，*axis*）。返回*self*沿*axis*的最小元素的索引。

```py
*PyArray_Max( *self, int axis, *out)
```

等同于`ndarray.max`（*self*，*axis*）。返回沿指定*axis*的*self*的最大元素。当结果是单个元素时，返回的是 numpy 标量而不是 ndarray。

```py
*PyArray_Min( *self, int axis, *out)
```

等同于`ndarray.min`（*self*，*axis*）。返回沿指定*axis*的*self*的最小元素。当结果是单个元素时，返回的是 numpy 标量而不是 ndarray。

```py
*PyArray_Ptp( *self, int axis, *out)
```

等同于`ndarray.ptp`（*self*，*axis*）。返回*self*沿*axis*的最大元素与*self*沿*axis*的最小元素之差。当结果是单个元素时，返回的是 numpy 标量而不是 ndarray。

注意

rtype 参数指定应该进行归约的数据类型。如果数组的数据类型不足以处理输出，这一点非常重要。默认情况下，所有整数数据类型都至少与`NPY_LONG`一样大，用于“add”和“multiply”ufuncs（这构成了 mean、sum、cumsum、prod 和 cumprod 函数的基础）。

```py
*PyArray_Mean( *self, int axis, int rtype, *out)
```

等同于`ndarray.mean`（*self*，*axis*，*rtype*）。返回沿指定*axis*的元素的平均值，使用列举类型*rtype*作为要累加的数据类型。默认的求和行为使用`NPY_NOTYPE`作为*rtype*。

```py
*PyArray_Trace( *self, int offset, int axis1, int axis2, int rtype, *out)
```

等同于`ndarray.trace`（*self*，*offset*，*axis1*，*axis2*，*rtype*）。返回沿由*axis1*和*axis2*变量定义的 2 维数组的*offset*对角元素的和（使用*rtype*作为求和的数据类型）。正偏移选择主对角线上方的对角线。负偏移选择主对角线下方的对角线。

```py
*PyArray_Clip( *self, *min, *max)
```

等同于`ndarray.clip`（*self*，*min*，*max*）。夹取数组*self*，使大于*max*的值固定为*max*，小于*min*的值固定为*min*。

```py
*PyArray_Conjugate( *self)
```

等同于`ndarray.conjugate`（*self*）。返回*self*的复共轭。如果*self*不是复数数据类型，则返回一个带有引用的*self*。

```py
*PyArray_Round( *self, int decimals, *out)
```

等同于`ndarray.round` (*self*, *decimals*, *out*)。返回将元素四舍五入到最接近的小数位的数组。小数位被定义为 \(10^{-\textrm{decimals}}\) 位，因此负的 *decimals* 会导致四舍五入到最接近的 10、100 等位。如果 *out* 为 `NULL`，则创建输出数组，否则输出放入 *out* 中，*out* 必须是正确的大小和类型。

```py
*PyArray_Std( *self, int axis, int rtype, *out)
```

等同于`ndarray.std` (*self*, *axis*, *rtype*)。返回使用沿 *axis* 转换为数据类型 *rtype* 的数据的标准偏差。

```py
*PyArray_Sum( *self, int axis, int rtype, *out)
```

等同于`ndarray.sum` (*self*, *axis*, *rtype*)。返回 *self* 沿 *axis* 的元素的 1-d 向量和。在将数据转换为数据类型 *rtype* 后执行求和。

```py
*PyArray_CumSum( *self, int axis, int rtype, *out)
```

等同于`ndarray.cumsum` (*self*, *axis*, *rtype*)。返回 *self* 沿 *axis* 的元素的累积 1-d 和。在将数据转换为数据类型 *rtype* 后执行累积和。

```py
*PyArray_Prod( *self, int axis, int rtype, *out)
```

等同于`ndarray.prod` (*self*, *axis*, *rtype*)。返回 *self* 沿 *axis* 的元素的 1-d 乘积。在将数据转换为数据类型 *rtype* 后执行乘积。

```py
*PyArray_CumProd( *self, int axis, int rtype, *out)
```

等同于`ndarray.cumprod` (*self*, *axis*, *rtype*)。返回 *self* 沿 *axis* 的元素的累积 1-d 乘积。在将数据转换为数据类型 *rtype* 后执行累积乘积。

```py
*PyArray_All( *self, int axis, *out)
```

等同于`ndarray.all` (*self*, *axis*)。返回一个数组，其中对于 *self* 中由 *axis* 定义的每个 1-d 子数组，所有元素都为 True。

```py
*PyArray_Any( *self, int axis, *out)
```

等同于`ndarray.any` (*self*, *axis*)。返回一个数组，其中对于 *self* 中由 *axis* 定义的每个 1-d 子数组，只要有一个元素为 True，就返回 True 元素。

### 转换

```py
*PyArray_GetField( *self, *dtype, int offset)
```

等同于`ndarray.getfield` (*self*, *dtype*, *offset*)。此函数[窃取一个引用](https://docs.python.org/3/c-api/intro.html?reference-count-details)到*PyArray_Descr*，并返回使用当前数组中指定偏移量（以字节为单位）的数据生成的给定*dtype*的新数组。 新数组类型的*offset*加上 itemsize 必须小于`self ->descr->elsize`，否则将引发错误。使用与原始数组相同的形状和步幅。因此，此函数的效果是从结构化数组返回字段。但是，它还可用于从任何数组类型中选择特定字节或字节组。

```py
int PyArray_SetField( *self, *dtype, int offset, *val)
```

等同于`ndarray.setfield`（*self*，*val*，*dtype*，*offset*）。将从指定偏移量（以字节为单位）开始并具有给定*dtype*的字段设置为*val*。 *offset*加上*dtype*->elsize 必须小于*self* ->descr->elsize，否则将引发错误。否则，将*val*参数转换为数组并复制到指向的字段中。如有必要，将重复*val*的元素以填充目标数组，但是目标中的元素数必须是*val*中元素数的整数倍。

```py
*PyArray_Byteswap( *self, inplace)
```

等同于`ndarray.byteswap` (*self*, *inplace*)。返回一个数据区域进行字节交换的数组。 如果*inplace*非零，则就地执行字节交换并返回自身的引用。否则，创建一个进行字节交换的副本，并保持自身不变。

```py
*PyArray_NewCopy( *old, order)
```

等同于`ndarray.copy` (*self*, *fortran*)。复制*old*数组。返回的数组始终对齐和可写，数据解释与旧数组相同。如果*order*为`NPY_CORDER`，则返回一个 C 风格的连续数组。 如果*order*为`NPY_FORTRANORDER`，则返回一个 Fortran 风格的连续数组。 如果*order*为`NPY_ANYORDER`，则仅当旧数组为 Fortran 风格连续时，返回的数组才是 Fortran 风格连续；否则，它是 C 风格连续。

```py
*PyArray_ToList( *self)
```

等同于`ndarray.tolist`（*self*）。从* self *返回一个嵌套的 Python 列表。

```py
*PyArray_ToString( *self, order)
```

等同于`ndarray.tobytes`（*self*，*order*）。以 Python 字符串形式返回此数组的字节。

```py
*PyArray_ToFile( *self, FILE *fp, char *sep, char *format)
```

以 C 风格的连续方式将 *self* 的内容写入文件指针 *fp*。如果 *sep* 为字符串“”或 `NULL`，则以二进制字节写入数据。否则，使用 *sep* 字符串作为项目分隔符，将 *self* 的内容作为文本写入。每个项目都将打印到文件中。如果 *format* 字符串不是 `NULL` 或 “”，则它是一个 Python 的打印语句格式字���串，显示如何写入项目。

```py
int PyArray_Dump( *self, *file, int protocol)
```

将 *self* 中的对象保存到给定的 *file* （可以是字符串或 Python 文件对象）中。如果 *file* 是一个 Python 字符串，则被认为是一个文件的名称，然后以二进制模式打开。使用给定的 *protocol*（如果 *protocol* 是负数，则使用最高可用的 *protocol*）。这只是对 cPickle.dump(*self*, *file*, *protocol*) 的简单包装器。

```py
*PyArray_Dumps( *self, int protocol)
```

将 *self* 中的对象存储为 Python 字符串并返回。使用所提供的 Pickle *protocol*（或者如果 *protocol* 是负数，则使用最高可用的 *protocol*）。

```py
int PyArray_FillWithScalar( *arr, *obj)
```

使用给定的标量对象 *obj* 填充数组 *arr*。首先将对象转换为 *arr* 的数据类型，然后将其复制到每个位置。如果发生错误，则返回 -1，否则返回 0。

```py
*PyArray_View( *self, *dtype, *ptype)
```

等效于 `ndarray.view` (*self*, *dtype*)。返回一个新的数组 *self* 的视图，可能具有不同的数据类型 *dtype* 和不同的数组子类 *ptype*。

如果 *dtype* 为 `NULL`，则返回的数组将与 *self* 具有相同的数据类型。新的数据类型必须与 *self* 的大小一致。要么项目大小必须相同，要么 *self* 必须是单段的，并且字节的总数必须相同。在后一种情况下，返回的数组的维度将在最后一个维度（或者对于 Fortran 风格连续的数组，在第一个维度）进行更改。返回的数组的数据区域与 self 完全相同。

### 形状操作

```py
*PyArray_Newshape( *self, *newshape, order)
```

结果将是一个新的数组（如果可能，则指向与 *self* 相同的内存位置），但具有 *newshape* 给定的形状。如果新形状与 *self* 的步幅不兼容，则返回具有新指定形状的数组的副本。

```py
*PyArray_Reshape( *self, *shape)
```

等效于 `ndarray.reshape` (*self*, *shape*)，其中 *shape* 是一个序列。将 *shape* 转换为 `PyArray_Dims` 结构，并在内部调用 `PyArray_Newshape`。为保持向后兼容性 - 不推荐使用

```py
*PyArray_Squeeze( *self)
```

等效于 `ndarray.squeeze` (*self*)。返回 *self* 的一个新的视图，其中已删除所有长度为 1 的维度。

警告

矩阵对象始终是二维的。因此，对于矩阵子类的数组，`PyArray_Squeeze` 没有任何效果。

```py
*PyArray_SwapAxes( *self, int a1, int a2)
```

等同于`ndarray.swapaxes` (*self*, *a1*, *a2*)。返回的数组是* self*中给定轴*a1*和*a2*互换后的数据的新视图。

```py
*PyArray_Resize( *self, *newshape, int refcheck, fortran)
```

等同于`ndarray.resize` (*self*, *newshape*, refcheck `=` *refcheck*, order= fortran )。此函数仅适用于单一片段的数组。它会在原地改变*self*的形状，并且如果*newshape*的总元素数与旧形状不同，则会重新分配*self*的内存。如果需要重新分配，则*self*必须拥有其数据，*self* - `>base==NULL`，*self* - `>weakrefs==NULL`，而且（除非 refcheck 为 0）不能被任何其他数组引用。fortran 参数可以是`NPY_ANYORDER`、`NPY_CORDER`或`NPY_FORTRANORDER`。目前它没有任何效果。最终它可以用来确定重塑操作在构造不同尺寸数组时应如何查看数据。成功时返回 None，出错时返回 NULL。

```py
*PyArray_Transpose( *self, *permute)
```

等同于`ndarray.transpose` (*self*, *permute*)。根据数据结构*permute*对 ndarray 对象*self*的轴进行置换，并返回结果。如果*permute*为`NULL`，则结果数组的轴将被颠倒。例如，如果*self*的形状为\(10\times20\times30\)，*permute*`.ptr`为（0,2,1），则结果的形状为\(10\times30\times20\)。如果*permute*为`NULL`，结果的形状为\(30\times20\times10\)。

```py
*PyArray_Flatten( *self, order)
```

等同于`ndarray.flatten` (*self*, *order*)。返回数组的 1 维拷贝。如果*order*为`NPY_FORTRANORDER`，元素按 Fortran 顺序扫描（第一维变化最快）。如果*order*为`NPY_CORDER`，则`self`的元素按 C 顺序扫描（最后一维变化最快）。如果*order*为`NPY_ANYORDER`，则使用`PyArray_ISFORTRAN` (*self*)的结果来确定要展平的顺序。

```py
*PyArray_Ravel( *self, order)
```

等同于*self*.ravel(*order*)。与`PyArray_Flatten` (*self*, *order*)具有相同的基本功能，除非*order*为 0 且*self*是 C 风格连续的，形状会改变但不会进行复制。

### 项目选择和操作

```py
*PyArray_TakeFrom( *self, *indices, int axis, *ret, clipmode)
```

相当于`ndarray.take` (*self*, *indices*, *axis*, *ret*, *clipmode*)，在 Python 中除了*axis* =None 是通过在 C 中设置*axis* = `NPY_MAXDIMS` 而获得的。沿着给定的*axis*提取由整数值*indices*指示的*self*中的项目。*clipmode*参数可以是`NPY_RAISE`、`NPY_WRAP`或`NPY_CLIP`，表示对超出边界索引该怎么办。*ret*参数可以指定一个输出数组而不是在内部创建一个。

```py
*PyArray_PutTo( *self, *values, *indices, clipmode)
```

相当于*self*.put(*values*, *indices*, *clipmode* )。在相应的（扁平化的）*indices*中将*values*放入*self*。如果*values*太小，则将根据需要重复。

```py
*PyArray_PutMask( *self, *values, *mask)
```

在*mask*为真的相应位置（使用扁平化的上下文）中将*values*放入*self*。 *mask*和*self*数组必须具有相同数量的元素。如果*values*太小，将根据需要重复。

```py
*PyArray_Repeat( *self, *op, int axis)
```

相当于`ndarray.repeat` (*self*, *op*, *axis*)。沿着给定的*axis*复制*self*的元素*op*次。 *op*可以是标量整数或与长度*self*->dimensions[*axis*]相同的长度序列，指示沿着该轴重复每个项目的次数。

```py
*PyArray_Choose( *self, *op, *ret, clipmode)
```

相当于`ndarray.choose` (*self*, *op*, *ret*, *clipmode*)。根据*self*中的整数值从*op*的数组序列中选择元素创建一个新的数组。这些数组必须都能广播到相同的形状，并且*self*中的条目应在 0 和 len(*op*)之间。除非*ret*为`NULL`，否则输出将放在*ret*中，在这种情况下将创建一个新的输出。*clipmode*参数确定当*self*中的条目不在 0 和 len(*op*)之间时的行为。

```py
NPY_RAISE
```

抛出一个 ValueError；

```py
NPY_WRAP
```

通过添加 len(*op*)将小于 0 的值进行包裹，并通过减去 len(*op*)使大于等于 len(*op*)的值在范围内；

```py
NPY_CLIP
```

所有值被剪切到区间 0, len(*op*) )内。

```py
*PyArray_Sort( *self, int axis, kind)
```

相当于[`ndarray.sort` (*self*, *axis*, *kind*)。沿着*axis*对*self*的项目进行排序并返回一个数组。该数组使用由*kind*表示的算法进行排序，*kind*是一个指向使用的排序算法类型的整数/枚举。

```py
*PyArray_ArgSort( *self, int axis)
```

等同于`ndarray.argsort`（*self*, *axis*）。返回一个索引数组，以便沿着给定的`axis` 选择这些索引将返回*sefl*的排序版本。如果*self*->descr 是一个已定义字段的数据类型，则会使用 self->descr->names 来确定排序顺序。当第一个字段相等时，将使用第二个字段，依此类推。要更改结构化数组的排序顺序，创建一个具有不同名称顺序的新数据类型，并使用该新数据类型的视图构造数组。

```py
*PyArray_LexSort( *sort_keys, int axis)
```

给定具有相同形状的数组序列(*sort_keys*)，返回一个索引数组（类似于`PyArray_ArgSort`（…）），该数组按字典顺序对数组进行排序。字典排序指出，当两个键被发现相等时，顺序是基于后续键的比较。需要为类型定义一个合并排序（使相等条目不动）。通过首先使用第一个*sort_key*对索引进行排序，然后使用第二个*sort_key*等等来完成排序。这等效于 Python 命令 lexsort(*sort_keys*, *axis*)。由于合并排序的工作方式，务必了解必须对*sort_keys*进行的排序顺序（与比较两个元素时使用的顺序相反）。

如果这些数组都集成在一个结构化数组中，那么`PyArray_Sort`（…）也可以用于直接对数组进行排序。

```py
*PyArray_SearchSorted( *self, *values, side, *perm)
```

等同于`ndarray.searchsorted`（*self*, *values*, *side*, *perm*）。假设*self*是按升序排列的 1 维数组，则输出是一个与*values*相同形状的索引数组，以便如果*values*中的元素在这些索引之前插入，则*self* 的顺序将被保留。不会检查*self* 是否按升序排列。

*side* 参数指示返回的索引是第一个合适位置的（如果是`NPY_SEARCHLEFT`）还是最后一个的（如果是`NPY_SEARCHRIGHT`）。

*sorter* 参数，如果不是`NULL`，必须是一个与*self*长度相同的整数索引的 1D 数组，用于将其按升序排序。这通常是由调用`PyArray_ArgSort`（…）而得到的结果。使用二分搜索来找到必要的插入点。

```py
int PyArray_Partition( *self, *ktharray, int axis, which)
```

等同于`ndarray.partition` (*self*, *ktharray*, *axis*, *kind*). 对数组进行分区，使得索引为*ktharray*的元素的值处于数组完全排序时的位置，并将所有小于第 kth 个元素的元素放在之前，所有相等或大于第 kth 个元素的元素放在之后。分区内所有元素的排序是未定义的。如果*self*->descr 是一个有定义字段的数据类型，那么 self->descr->names 会用来确定排序顺序。当第一个字段相等时，将使用第二个字段，以此类推。要更改结构化数组的排序顺序，可以创建一个具有不同名称顺序的新数据类型，并使用该新数据类型构造数组的视图。成功返回零，失败返回-1。

```py
*PyArray_ArgPartition( *op, *ktharray, int axis, which)
```

等同于`ndarray.argpartition` (*self*, *ktharray*, *axis*, *kind*). 返回一个索引数组，选择这些索引沿给定`axis`会返回*self*的分区版本。

```py
*PyArray_Diagonal( *self, int offset, int axis1, int axis2)
```

等同于`ndarray.diagonal` (*self*, *offset*, *axis1*, *axis2* ). 返回由*axis1*和*axis2*定义的 2-d 数组的*offset*对角线。

```py
PyArray_CountNonzero( *self)
```

1.6 版中的新功能。

对数组对象*self*中的非零元素的数量进行计数。

```py
*PyArray_Nonzero( *self)
```

等同于`ndarray.nonzero` (*self*). 返回选择非零元素的*self*的索引数组元组。如果(nd= `PyArray_NDIM` ( `self` ))==1,则返回单个索引数组。索引数组具有数据类型`NPY_INTP`。如果返回元组(nd \(\neq\) 1)，那么其长度为 nd。

```py
*PyArray_Compress( *self, *condition, int axis, *out)
```

等同于`ndarray.compress` (*self*, *condition*, *axis* ). 返回沿*axis*对应于*condition*中为真的元素。

### 计算

提示

为了实现与在 Python 中传入`axis=None`相同的效果（将数组视为 1-d 数组），在`NPY_MAXDIMS`中传入`NPY_MAXDIMS`。

注意

out 参数指定了结果放在哪里。如果 out 为 NULL，那么将创建输出数组，否则结果将放在必须是正确大小和类型的 out 中。即使 out 不为 NULL，也总是返回对输出数组的新引用。如果 out 不为 NULL，调用该例程的人有责任释放 out 或者会发生内存泄漏。

```py
*PyArray_ArgMax( *self, int axis, *out)
```

等同于`ndarray.argmax`（*self*，*axis*）。返回*self*沿*axis*的最大元素的索引。

```py
*PyArray_ArgMin( *self, int axis, *out)
```

等同于`ndarray.argmin`（*self*，*axis*）。返回*self*沿*axis*的最小元素的索引。

```py
*PyArray_Max( *self, int axis, *out)
```

等同于`ndarray.max`（*self*，*axis*）。返回*self*沿给定*axis*的最大元素。当结果是单个元素时，返回一个 numpy 标量而不是 ndarray。

```py
*PyArray_Min( *self, int axis, *out)
```

等同于`ndarray.min`（*self*，*axis*）。返回*self*沿给定*axis*的最小元素。当结果是单个元素时，返回一个 numpy 标量而不是 ndarray。

```py
*PyArray_Ptp( *self, int axis, *out)
```

等同于`ndarray.ptp`（*self*，*axis*）。返回*self*沿*axis*的最大元素与*self*沿*axis*的最小元素之间的差值。当结果是单个元素时，返回一个 numpy 标量而不是 ndarray。

注意

rtype 参数指定应执行规约的数据类型。如果数组的数据类型不足以处理输出，则这一点非常重要。默认情况下，所有整数数据类型至少比“add”和“multiply” ufuncs（它们构成 mean、sum、cumsum、prod 和 cumprod 函数的基础）大得多。

```py
*PyArray_Mean( *self, int axis, int rtype, *out)
```

等同于`ndarray.mean`（*self*，*axis*，*rtype*）。返回沿给定*axis*的元素平均值，使用枚举类型*rtype*作为求和的数据类型。默认求和行为使用`NPY_NOTYPE`作为*rtype*。

```py
*PyArray_Trace( *self, int offset, int axis1, int axis2, int rtype, *out)
```

等同于`ndarray.trace`（*self*，*offset*，*axis1*，*axis2*，*rtype*）。返回对以*axis1*和*axis2*变量定义的 2-d 数组的*offset*对角线元素（使用*rtype*作为求和数据类型）的总和。正偏移选择主对角线上方的对角线。负偏移选择主对角线下方的对角线。

```py
*PyArray_Clip( *self, *min, *max)
```

等同于`ndarray.clip`（*self*，*min*，*max*）。剪辑数组*self*，使大于*max*的值固定为*max*，小于*min*的值固定为*min*。

```py
*PyArray_Conjugate( *self)
```

等同于`ndarray.conjugate`（*self*）。返回*self*的复共轭。如果*self*不是复数数据类型，则返回具有引用的*self*。

```py
*PyArray_Round( *self, int decimals, *out)
```

等效于`ndarray.round` (*self*, *decimals*, *out*)。返回将元素四舍五入到最近小数位的数组。小数点位定义为\(10^{-\textrm{decimals}}\)位，因此负数*decimals*会导致四舍五入到最近的 10、100 等。如果 out 为`NULL`，则创建输出数组，否则将输出放置在*out*中，其必须是正确的大小和类型。

```py
*PyArray_Std( *self, int axis, int rtype, *out)
```

等效于`ndarray.std` (*self*, *axis*, *rtype*)。使用沿着*axis*转换为数据类型*rtype*的数据返回标准差。

```py
*PyArray_Sum( *self, int axis, int rtype, *out)
```

等效于`ndarray.sum` (*self*, *axis*, *rtype*)。返回在*axis*沿着*self*的元素中的 1-d 矢量和。在将数据转换为数据类型*rtype*后执行求和。

```py
*PyArray_CumSum( *self, int axis, int rtype, *out)
```

等效于`ndarray.cumsum` (*self*, *axis*, *rtype*)。返回*self*沿*axis*的累积 1-d 元素和。在将数据转换为数据类型*rtype*后执行求和。

```py
*PyArray_Prod( *self, int axis, int rtype, *out)
```

等效于`ndarray.prod` (*self*, *axis*, *rtype*)。返回在*axis*沿着*self*的元素中的 1-d 积。在将数据转换为数据类型*rtype*后执行积。

```py
*PyArray_CumProd( *self, int axis, int rtype, *out)
```

等效于`ndarray.cumprod` (*self*, *axis*, *rtype*)。返回 1-d `self`中沿着`axis`的元素的累积乘积。在将数据转换为数据类型`rtype`后执行乘积。

```py
*PyArray_All( *self, int axis, *out)
```

等效于`ndarray.all` (*self*, *axis*)。对于由*axis*定义的`self`的每个 1-d 子数组，返回一个包含 True 元素的数组，其中所有元素都为 True。

```py
*PyArray_Any( *self, int axis, *out)
```

等效于`ndarray.any` (*self*, *axis*)。对于由*axis*定义的*self*的每个 1-d 子数组，返回一个包含 True 元素的数组，其中任何元素为 True。

## 函数

### 数组函数

```py
int PyArray_AsCArray( **op, void *ptr, *dims, int nd, *typedescr)
```

有时，以 C 风格的多维数组的方式访问多维数组是有用的，以便可以使用 C 的 a[i][j][k]语法来实现算法。该例程返回一个指针*ptr*，模拟这种 C 风格数组的方式，用于 1-、2- 和 3-d ndarrays。

参数：

+   **op** – 任何 Python 对象的地址。该 Python 对象将被替换为一个等价的，行为良好的，C 风格连续的 ndarray，其数据类型由最后两个参数指定。请确保以这种方式窃取输入对象的引用是合理的。

+   **ptr** - （针对 1 维，2 维或 3 维分别为 ctype*，ctype**或 ctype***）变量的地址，其中 ctype 是数据类型的等效 C 类型。返回时，*ptr*将作为 1 维、2 维或 3 维数组的地址。

+   **dims** - 一个包含数组对象形状的输出数组。这个数组给出了任何循环的边界。

+   **nd** - 数组的维数（1、2 或 3）。

+   **typedescr** - 一个 `PyArray_Descr` 结构，指示所需的数据类型（包括所需的字节顺序）。调用会窃取参数的引用。

注意

对于 2 维和 3 维数组，C 风格数组的模拟并不完整。例如，无法将模拟的指针数组传递给需要特定、静态定义的 2 维和 3 维数组的子例程。要传递给需要这种输入的函数，必须静态定义所需的数组并复制数据。

```py
int PyArray_Free( *op, void *ptr)
```

必须使用从`PyArray_AsCArray`（…）返回的相同对象和内存位置调用此函数。该函数会清理否则可能会泄漏的内存。

```py
*PyArray_Concatenate( *obj, int axis)
```

沿着*axis*连接*obj*中的对象序列成为单个数组。如果维度或类型不兼容，则会引发错误。

```py
*PyArray_InnerProduct( *obj1, *obj2)
```

在*obj1*和*obj2*的最后维度上计算一个乘积和。两个数组都不是共轭的。

```py
*PyArray_MatrixProduct( *obj1, *obj)
```

在*obj1*的最后维度和*obj2*的倒数第二个维度上计算一个乘积和。对于 2 维数组，这是一个矩阵乘积。两个数组都不是共轭的。

```py
*PyArray_MatrixProduct2( *obj1, *obj, *out)
```

1.6 版中的新增功能。

与 PyArray_MatrixProduct 相同，但将结果存储在*out*中。输出数组必须具有正确的形状、类型，并且是 C 连续的，否则会引发异常。

```py
*PyArray_EinsteinSum(char *subscripts, nop, **op_in, *dtype, order, casting, *out)
```

1.6 版中的新增内容。

将爱因斯坦求和约定应用于提供的数组操作数，返回一个新数组或将结果放在*out*中。 *subscripts*中的字符串是索引字母的逗号分隔列表。操作数的数量为*nop*，*op_in*是包含这些操作数的数组。可以通过*dtype*强制输出的数据类型，可以通过*order*强制输出顺序（建议使用`NPY_KEEPORDER`），并且在指定*dtype*时，*casting*表示数据转换应有多大宽松度。

更多细节，请参见`einsum`函数。

```py
*PyArray_CopyAndTranspose( *op)
```

仅适用于 2 维数组的专用复制和转置函数。返回的数组是*op*的转置副本。

```py
*PyArray_Correlate( *op1, *op2, int mode)
```

计算 1 维数组 *op1* 和 *op2* 的 1 维相关性。通过将 *op1* 乘以 *op2* 的位移版本并将结果相加来计算每个输出点的相关性。由于位移，*op1* 和 *op2* 定义范围之外所需的值被解释为零。模式确定要返回多少位移：0 - 仅返回不需要假设零值的位移；1 - 返回与 *op1* 大小相同的对象；2 - 返回所有可能的位移（任何重叠都被接受）。

笔记

这不是计算通常的相关性：如果 op2 大于 op1，则交换参数，并且对复数数组不进行共轭。参见 PyArray_Correlate2 以获得通常的信号处理相关性。

```py
*PyArray_Correlate2( *op1, *op2, int mode)
```

PyArray_Correlate 的更新版本，使用了 1 维数组的常规相关性定义。通过将 *op1* 乘以 *op2* 的位移版本并将结果相加来计算每个输出点的相关性。由于位移，*op1* 和 *op2* 定义范围之外所需的值被解释为零。模式确定要返回多少位移：0 - 仅返回不需要假设零值的位移；1 - 返回与 *op1* 大小相同的对象；2 - 返回所有可能的位移（任何重叠都被接受）。

笔记

将 z 计算如下：

```py
z[k] = sum_n op1[n] * conj(op2[n+k]) 
```

```py
*PyArray_Where( *condition, *x, *y)
```

如果 `x` 和 `y` 都是 `NULL`，则返回 `PyArray_Nonzero`（*condition*）。否则，必须提供 *x* 和 *y*，返回的对象的形状类似 *condition*，并且具有 *x* 和 *y* 的元素，*condition* 分别是 True 或 False。

### 其他函数

```py
PyArray_CheckStrides(int elsize, int nd, numbytes, const *dims, const *newstrides)
```

确定 *newstrides* 是否是与形状 `dims`、元素大小 *elsize* 和内存一致的 *nd* 维数组的跨度数组。将检查 *newstrides* 数组以查看每个方向跳过提供的字节数是否会导致跳过超过 *numbytes*，*numbytes* 是假定的可用内存段的大小。如果 *numbytes* 为 0，则假定 *nd*、*dims* 和 *elsize* 指的是单个段的数组，如果 *newstrides* 可接受，则返回`NPY_TRUE`，否则返回`NPY_FALSE`。

```py
PyArray_MultiplyList( const *seq, int n)
```

```py
int PyArray_MultiplyIntList(int const *seq, int n)
```

这两个例程都是将长度为 *n* 的整数数组 *seq* 相乘并返回结果。不执行溢出检查。

```py
int PyArray_CompareLists( const *l1, const *l2, int n)
```

给定两个长度为 *n* 的整数数组 *l1* 和 *l2*，如果列表相同，则返回 1；否则返回 0。

### 数组函数

```py
int PyArray_AsCArray( **op, void *ptr, *dims, int nd, *typedescr)
```

有时候，以 C 风格的多维数组形式访问多维数组是有用的，以便可以使用 C 的 a[i][j][k] 语法来实现算法。此例程返回一个指针，*ptr*，它模拟这种 C 风格数组，用于 1 维、2 维和 3 维 ndarray。

参数：

+   **op** – Python 对象的地址。此 Python 对象将被替换为等效的、C 风格的连续 ndarray 的地址，其数据类型由最后两个参数指定。确保以这种方式偷窃输入对象的引用是合理的。

+   **ptr** – 指向变量（1-d 用 ctype*，2-d 用 ctype**，3-d 用 ctype***）的地址，其中 ctype 是数据类型的等效 C 类型。返回时，*ptr* 将作为 1-d、2-d 或 3-d 数组可寻址。

+   **dims** – 一个包含数组对象形状的输出数组。此数组给出任何将发生的循环的边界。

+   **nd** – 数组的维数（1、2 或 3）。

+   **typedescr** – 一个`PyArray_Descr` 结构，指示所需的数据类型（包括所需的字节顺序）。调用将偷取参数的引用。

注意

对于 2 维和 3 维数组，C 风格数组的模拟不完整。例如，模拟的指针数组不能传递给期望特定的静态定义的 2 维和 3 维数组的子程序。要传递给需要这种输入的函数，必须静态定义所需的数组并复制数据。

```py
int PyArray_Free( *op, void *ptr)
```

必须使用从`PyArray_AsCArray`返回的相同对象和内存位置来调用（...）。该函数会清理否则将泄漏的内存。

```py
*PyArray_Concatenate( *obj, int axis)
```

沿着 *axis* 将 *obj* 中的对象序列连接成一个单一的数组。如果维度或类型不兼容，将引发错误。

```py
*PyArray_InnerProduct( *obj1, *obj2)
```

对 *obj1* 和 *obj2* 的最后一维进行产品和求和。两个数组都不是共轭的。

```py
*PyArray_MatrixProduct( *obj1, *obj)
```

对 *obj1* 的最后一维和 *obj2* 的倒数第二维进行产品和求和。对于 2 维数组，这是一个矩阵乘积。两个数组都不是共轭的。

```py
*PyArray_MatrixProduct2( *obj1, *obj, *out)
```

版本 1.6 中的新内容。

与 PyArray_MatrixProduct 相同，但是将结果存储在 *out* 中。输出数组必须具有正确的形状、类型，并且是 C 连续的，否则会引发异常。

```py
*PyArray_EinsteinSum(char *subscripts, nop, **op_in, *dtype, order, casting, *out)
```

版本 1.6 中的新内容。

对提供的数组操作数应用爱因斯坦求和约定，返回一个新数组或将结果放置在 *out* 中。 *subscripts* 中的字符串是逗号分隔的索引字母列表。操作数的数量在 *nop* 中，*op_in* 是一个包含这些操作数的数组。可以使用 *dtype* 强制输出的数据类型，可以使用 *order* 强制输出的顺序（建议使用`NPY_KEEPORDER`），当指定 *dtype* 时，*casting* 指示数据转换应该有多宽容。

有关详细信息，请参见`einsum` 函数。

```py
*PyArray_CopyAndTranspose( *op)
```

仅适用于 2 维数组的专用复制和转置函数。返回的数组是 *op* 的转置副本。

```py
*PyArray_Correlate( *op1, *op2, int mode)
```

计算 1-d 数组 *op1* 和 *op2* 的 1-d 相关性。每个输出点的相关性是通过将 *op1* 乘以 *op2* 的一个偏移版本并对结果进行求和来计算的。由于偏移，需要的值超出了 *op1* 和 *op2* 的定义范围被解释为零。模式确定要返回多少个偏移量：0 - 仅返回不需要假定零值的偏移；1 - 返回与 *op1* 相同大小的对象；2 - 返回所有可能的偏移量（接受任何重叠）。

注意

这不是计算常规相关性的方法：如果 op2 大于 op1，则交换参数，并且复数数组不需要取共轭。详见 PyArray_Correlate2 获取常规信号处理的相关性。

```py
*PyArray_Correlate2( *op1, *op2, int mode)
```

PyArray_Correlate 的更新版本，使用了 1d 数组的常规相关性定义。每个输出点的相关性是通过将 *op1* 乘以 *op2* 的一个偏移版本并对结果进行求和来计算的。由于偏移，需要的值超出了 *op1* 和 *op2* 的定义范围被解释为零。模式确定要返回多少个偏移量：0 - 仅返回不需要假定零值的偏移；1 - 返回与 *op1* 相同大小的对象；2 - 返回所有可能的偏移量（接受任何重叠）。

注意

计算 z 如下所示：

```py
z[k] = sum_n op1[n] * conj(op2[n+k]) 
```

```py
*PyArray_Where( *condition, *x, *y)
```

如果 `x` 和 `y` 都是 `NULL`，则返回 `PyArray_Nonzero` (*condition*)。否则，必须提供 *x* 和 *y*，并且返回的对象的形状与 *condition* 相同，并且在*condition* 分别为真和假时，返回 *x* 和 *y* 的元素。

### 其他函数

```py
PyArray_CheckStrides(int elsize, int nd, numbytes, const *dims, const *newstrides)
```

确定 *newstrides* 是否是与形状 `dims` 和元素大小 *elsize* 相对应的内存中 *nd* 维数组的偏移数组。将检查 *newstrides* 数组以查看每个方向按提供的字节数跳跃是否意味着跳跃超过假定的可用内存段的大小 *numbytes*。如果 *numbytes* 为 0，则假定 *nd*、*dims* 和 *elsize* 指的是单段数组。如果 *newstrides* 可接受，则返回 `NPY_TRUE`，否则返回 `NPY_FALSE`。

```py
PyArray_MultiplyList( const *seq, int n)
```

```py
int PyArray_MultiplyIntList(int const *seq, int n)
```

这两个例程都会将整数数组 *seq* 的 *n* 长度相乘并返回结果。不进行溢出检查。

```py
int PyArray_CompareLists( const *l1, const *l2, int n)
```

给定两个 *n* 长度的整数数组 *l1* 和 *l2*，如果列表相同则返回 1；否则返回 0。

## 具有对象语义辅助数据

版本 1.7.0 中的新内容。

```py
type NpyAuxData
```

当处理由其他数据类型组成的更复杂的数据类型时（比如结构化数据类型），创建操作数据类型的内部循环需要携带额外的数据。NumPy 通过结构 `NpyAuxData` 来支持这个想法，并通过一些约定来实现这一点。

定义一个`NpyAuxData`类似于在 C++中定义类，但由于 API 是 C 语言，需要手动跟踪对象语义。以下是一个使用元素复制函数作为原语实现元素翻倍的函数的示例。

```py
typedef  struct  {
  NpyAuxData  base;
  ElementCopier_Func  *func;
  NpyAuxData  *funcdata;
}  eldoubler_aux_data;

void  free_element_doubler_aux_data(NpyAuxData  *data)
{
  eldoubler_aux_data  *d  =  (eldoubler_aux_data  *)data;
  /* Free the memory owned by this auxdata */
  NPY_AUXDATA_FREE(d->funcdata);
  PyArray_free(d);
}

NpyAuxData  *clone_element_doubler_aux_data(NpyAuxData  *data)
{
  eldoubler_aux_data  *ret  =  PyArray_malloc(sizeof(eldoubler_aux_data));
  if  (ret  ==  NULL)  {
  return  NULL;
  }

  /* Raw copy of all data */
  memcpy(ret,  data,  sizeof(eldoubler_aux_data));

  /* Fix up the owned auxdata so we have our own copy */
  ret->funcdata  =  NPY_AUXDATA_CLONE(ret->funcdata);
  if  (ret->funcdata  ==  NULL)  {
  PyArray_free(ret);
  return  NULL;
  }

  return  (NpyAuxData  *)ret;
}

NpyAuxData  *create_element_doubler_aux_data(
  ElementCopier_Func  *func,
  NpyAuxData  *funcdata)
{
  eldoubler_aux_data  *ret  =  PyArray_malloc(sizeof(eldoubler_aux_data));
  if  (ret  ==  NULL)  {
  PyErr_NoMemory();
  return  NULL;
  }
  memset(&ret,  0,  sizeof(eldoubler_aux_data));
  ret->base->free  =  &free_element_doubler_aux_data;
  ret->base->clone  =  &clone_element_doubler_aux_data;
  ret->func  =  func;
  ret->funcdata  =  funcdata;

  return  (NpyAuxData  *)ret;
} 
```

```py
type NpyAuxData_FreeFunc
```

用于 NpyAuxData 自由函数的函数指针类型。

```py
type NpyAuxData_CloneFunc
```

用于 NpyAuxData 克隆函数的函数指针类型。这些函数在发生错误时不应该设置 Python 异常，因为它们可能会从多线程上下文中调用。

```py
void NPY_AUXDATA_FREE( *auxdata)
```

适当调用 auxdata 的释放函数的宏，如果 auxdata 为 NULL，则什么也不做。

```py
*NPY_AUXDATA_CLONE( *auxdata)
```

适当调用 auxdata 的克隆函数的宏，返回辅助数据的深层副本。

## 数组迭代器

从 NumPy 1.6.0 开始，这些数组迭代器被新的数组迭代器`NpyIter`取代。

一个数组迭代器是一种快速高效地访问 N 维数组元素的简单方法，可以在示例中看到更多关于这种循环数组的有用方法的描述。

```py
*PyArray_IterNew( *arr)
```

从数组*arr*返回一个数组迭代器对象。这等同于*arr*。**flat**。数组迭代器对象使在 C 风格连续方式下轻松循环遍历 N 维非连续数组成为可能。

```py
*PyArray_IterAllButAxis( *arr, int *axis)
```

返回一个数组迭代器，该迭代器将在除了**axis*以外的所有轴上迭代。返回的迭代器不能使用`PyArray_ITER_GOTO1D`。此迭代器可用于编写类似于 ufuncs 的内容，其中在最大轴上的循环由一个单独的子例程完成。如果**axis*为负数，则将**axis*设置为具有最小步幅的轴，并使用该轴。

```py
*PyArray_BroadcastToShape( *arr, const *dimensions, int nd)
```

返回一个广播到由*dimensions*和*nd*提供的形状的数组迭代器对象。

```py
int PyArrayIter_Check( *op)
```

如果*op*是数组迭代器（或数组迭代器类型的子类的实例），则评估为 True。

```py
void PyArray_ITER_RESET( *iterator)
```

将*iterator*重置为数组的开头。

```py
void PyArray_ITER_NEXT( *iterator)
```

增加*iterator*的索引和 dataptr 成员以指向数组的下一个元素。如果数组不是（C 风格）连续的，则还要增加 N 维坐标数组。

```py
void *PyArray_ITER_DATA( *iterator)
```

数组的当前元素的指针。

```py
void PyArray_ITER_GOTO( *iterator, *destination)
```

将*iterator*的索引、dataptr 和坐标成员设置为 N 维 c 数组*destination*指示的数组中的位置，该数组的大小至少为*iterator* ->nd_m1+1。

```py
void PyArray_ITER_GOTO1D( *iterator, index)
```

将*iterator*的索引和 dataptr 设置为整数*index*指示的位置，在 C 风格的扁平化数组中指向一个元素。

```py
int PyArray_ITER_NOTDONE( *iterator)
```

只要迭代器尚未循环遍历所有元素，就评估为 True，否则评估为 False。

## 广播（多个迭代器）

```py
*PyArray_MultiIterNew(int num, ...)
```

一个简化的广播接口。这个函数接受要广播的数组数量，以及 *num* 个额外（[`PyObject *`](https://docs.python.org/3/c-api/structures.html#c.PyObject "(在 Python v3.11 中)") ）参数。这些参数被转换为数组，并创建迭代器。然后在生成的多迭代器对象上调用 `PyArray_Broadcast`。然后返回生成的广播多迭代器对象。然后可以使用单个循环执行广播操作，并使用 `PyArray_MultiIter_NEXT` (..)。

```py
void PyArray_MultiIter_RESET( *multi)
```

重置多迭代器对象 *multi* 中的所有迭代器到开头。

```py
void PyArray_MultiIter_NEXT( *multi)
```

将多迭代器对象 *multi* 中的每个迭代器推进到其下一个（广播的）元素。

```py
void *PyArray_MultiIter_DATA( *multi, int i)
```

返回多迭代器对象中第 *i*（^{\textrm{th}}）个迭代器的数据指针。

```py
void PyArray_MultiIter_NEXTi( *multi, int i)
```

只推进第 *i*（^{\textrm{th}}）个迭代器的指针。

```py
void PyArray_MultiIter_GOTO( *multi, *destination)
```

将多迭代器对象 *multi* 中的每个迭代器推进到给定的 \(N\) -维 *destination*，其中 \(N\) 是广播数组中的维数。

```py
void PyArray_MultiIter_GOTO1D( *multi, index)
```

将多迭代器对象 *multi* 中的每个迭代器推进到展平广播数组的 *index* 对应位置。

```py
int PyArray_MultiIter_NOTDONE( *multi)
```

只要多迭代器尚未循环完所有元素（广播结果的元素），则评估为 TRUE，否则评估为 FALSE。

```py
int PyArray_Broadcast( *mit)
```

这个函数包装了广播规则。*mit* 容器应该已经包含了需要进行广播的所有数组的迭代器。返回时，这些迭代器将被调整，以便同时对每个进行迭代完成广播。如果发生错误，则返回负数。

```py
int PyArray_RemoveSmallest( *mit)
```

这个函数接受先前已经“广播”的多迭代器对象，找到在广播结果中具有最小“步幅之和”的维度，并适应所有迭代器，以便不在该维度上进行迭代（通过有效地使它们在该维度上为长度-1）。除非 *mit* ->nd 为 0，则返回相应的维度。这个函数用于构造类似于 ufunc 的例程，正确传播其输入然后调用一个针对速度进行了优化的 strided 1-d 版本的例程作为内循环。这个 1-d 版本通常针对速度进行了优化，因此循环应该在不需要大步跳跃的轴上执行。

## 邻域迭代器

版本 1.4.0 中新增。

邻域迭代器是迭代器对象的子类，可用于迭代点的邻域。例如，您可能希望遍历 3d 图像的每个体素，并对每个这样的体素遍历一个超立方体。邻域迭代器自动处理边界，因此使得编写这种代码比手动处理边界更容易，代价是稍微增加一些开销。

```py
*PyArray_NeighborhoodIterNew( *iter, bounds, int mode, *fill_value)
```

此函数从现有迭代器创建一个新的邻域迭代器。邻域将相对于 *iter* 当前指向的位置计算，bounds 定义了邻域迭代器的形状，mode 参数定义了边界处理模式。

*bounds* 参数应为一个 (2 * iter->ao->nd) 数组，例如范围 bound[2*i]->bounds[2*i+1] 定义了在维度 i 上遍历的范围（这两个边界都包含在遍历的坐标中）。边界应对每个维度进行排序（bounds[2*i] <= bounds[2*i+1]）。

模式应为以下之一：

```py
NPY_NEIGHBORHOOD_ITER_ZERO_PADDING
```

零填充。超出边界的值将为 0。

```py
NPY_NEIGHBORHOOD_ITER_ONE_PADDING
```

单个填充，超出边界的值将为 1。

```py
NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING
```

常量填充。超出边界的值将与 fill_value 中的第一个项目相同。

```py
NPY_NEIGHBORHOOD_ITER_MIRROR_PADDING
```

镜像填充。超出边界的值将如同数组项被镜像一样。例如，对于数组 [1, 2, 3, 4]，x[-2] 将为 2，x[-2] 将为 1，x[4] 将为 4，x[5] 将为 1，等等...

```py
NPY_NEIGHBORHOOD_ITER_CIRCULAR_PADDING
```

循环填充。超出边界的值将如同数组被重复一样。例如，对于数组 [1, 2, 3, 4]，x[-2] 将为 3，x[-2] 将为 4，x[4] 将为 1，x[5] 将为 2，等等...

如果模式为常量填充（*NPY_NEIGHBORHOOD_ITER_CONSTANT_PADDING*），则 fill_value 应指向一个包含填充值的数组对象（如果数组包含多个项，则第一项将是填充值）。对于其他情况，fill_value 可能为 NULL。

+   迭代器持有对 iter 的引用

+   失败时返回 NULL（在此情况下，iter 的引用计数不会更改）

+   iter 本身可以是邻域迭代器：这对于例如自动边界处理很有用

+   此函数返回的对象应安全用作普通迭代器

+   如果更改了 iter 的位置，则后续对 PyArrayNeighborhoodIter_Next 的任何调用都是未定义行为，并且必须调用 PyArrayNeighborhoodIter_Reset。

+   如果 iter 的位置不是数据的开头且 iter 的底层数据是连续的，则迭代器将指向数据的开头而不是 iter 指向的位置。为避免此情况，应在迭代器创建后仅将 iter 移动到所需位置，并且必须调用 PyArrayNeighborhoodIter_Reset。

```py
PyArrayIterObject  *iter;
PyArrayNeighborhoodIterObject  *neigh_iter;
iter  =  PyArray_IterNew(x);

/*For a 3x3 kernel */
bounds  =  {-1,  1,  -1,  1};
neigh_iter  =  (PyArrayNeighborhoodIterObject*)PyArray_NeighborhoodIterNew(
  iter,  bounds,  NPY_NEIGHBORHOOD_ITER_ZERO_PADDING,  NULL);

for(i  =  0;  i  <  iter->size;  ++i)  {
  for  (j  =  0;  j  <  neigh_iter->size;  ++j)  {
  /* Walk around the item currently pointed by iter->dataptr */
  PyArrayNeighborhoodIter_Next(neigh_iter);
  }

  /* Move to the next point of iter */
  PyArrayIter_Next(iter);
  PyArrayNeighborhoodIter_Reset(neigh_iter);
} 
```

```py
int PyArrayNeighborhoodIter_Reset( *iter)
```

将迭代器位置重置为邻域的第一个点。每当在 PyArray_NeighborhoodIterObject 中给出 iter 参数被更改时应调用此函数（见示例）

```py
int PyArrayNeighborhoodIter_Next( *iter)
```

在此调用后，iter->dataptr 指向邻域的下一个点。在访问完邻域的每个点后调用此函数是未定义的。

## 数组映射

数组映射是高级索引背后的机制。

```py
*PyArray_MapIterArray( *a, *index)
```

使用高级索引来迭代数组。

```py
void PyArray_MapIterSwapAxes( *mit, **ret, int getmap)
```

将轴与其插入形式互换。`MapIter`始终将高级（数组）索引放在迭代中的第一位。但如果它们是连续的，则在返回之前会插入/转置它们。这存储为`mit->consec != 0`（它们被插入的位置）。对于赋值，相反的情况发生：要分配的值被转置（而不是`getmap=0`而是`getmap=1`）。`getmap=0`和`getmap=1`撤消另一个操作。

```py
void PyArray_MapIterNext( *mit)
```

此函数需要更新地图迭代器的状态，并将`mit->dataptr`指向下一个对象的内存位置。

请注意，此函数从不处理额外的操作数，但为旧的（公开的）API 提供兼容性。

```py
*PyArray_MapIterArrayCopyIfOverlap( *a, *index, int copy_if_overlap, *extra_op)
```

与`PyArray_MapIterArray`类似，但增加了一个`copy_if_overlap`参数。如果`copy_if_overlap != 0`，则检查`a`是否与`index`中的任何数组以及`extra_op`有内存重叠，并根据需要进行复制，以避免在迭代期间修改输入时出现问题。`iter->array`可能包含一个已复制的数组（设置了 WRITEBACKIFCOPY）。

## 数组标量

```py
*PyArray_Return( *arr)
```

此函数窃取了对*arr*的引用。

此函数检查*arr*是否为零维数组，并在是的情况下返回适当的数组标量。每当可能返回 0 维数组到 Python 时应使用它。

```py
*PyArray_Scalar(void *data, *dtype, *base)
```

通过从由*data*指向的内存中**复制**到指定的*dtype*的数组标量对象返回。 *base*应为拥有数据的数组对象。如果*dtype*是`void`标量，或者设置了`NPY_USE_GETITEM`标志并且已知`getitem`方法使用`arr`参数而不检查它是否为`NULL`，则需要*base*。否则，*base*可能为`NULL`。

如果数据不是本机字节顺序（由`dtype->byteorder`指示），则此函数将对数据进行字节交换，因为数组标量始终以正确的机器字节顺序排列。

```py
*PyArray_ToScalar(void *data, *arr)
```

返回从由*data*指向的内存复制并在*arr*中的数据不是机器字节顺序时交换的类型和项目大小指示的数组标量对象。

```py
*PyArray_FromScalar( *scalar, *outcode)
```

从*scalar*（应为数组标量对象）返回由*outcode*指定类型的 0 维数组。如果*outcode*为 NULL，则类型由*scalar*确定。

```py
void PyArray_ScalarAsCtype( *scalar, void *ctypeptr)
```

在*ctypeptr*中返回指向数组标量中实际值的指针。没有错误检查，因此*scalar*必须是一个数组标量对象，而*ctypeptr*必须有足够的空间来容纳正确的类型。对于可变大小的类型，将数据的指针复制到*ctypeptr*的内存中，对于所有其他类型，将实际数据复制到*ctypeptr*指向的地址中。

```py
void PyArray_CastScalarToCtype( *scalar, void *ctypeptr, *outcode)
```

从数组标量*scalar*中返回数据（转换为*outcode*指示的数据类型），并复制到指向*ctypeptr*（必须足够大以处理传入内存）的内存中。

```py
*PyArray_TypeObjectFromType(int type)
```

从类型编号*type*返回一个标量类型对象。相当于`PyArray_DescrFromType` (*type*)->typeobj，除了引用计数和错误检查。成功时返回对类型对象的新引用，失败时返回`NULL`。

```py
PyArray_ScalarKind(int typenum, **arr)
```

请查看 NumPy 1.6.0 中引入的另一种机制的函数`PyArray_MinScalarType`。

返回由*typenum*表示的标量类型和数组**arr*（如果*arr*不是`NULL`）。假定数组的秩为 0，仅当*typenum*表示有符号整数时才使用该数组。如果*arr*不是`NULL`且第一个元素为负数，则返回`NPY_INTNEG_SCALAR`，否则返回`NPY_INTPOS_SCALAR`。可能的返回值是`NPY_SCALARKIND`中的枚举值。

```py
int PyArray_CanCoerceScalar(char thistype, char neededtype, scalar)
```

详细了解 NumPy 类型提升的函数`PyArray_ResultType`，在 NumPy 1.6.0 中更新。

实现标量强制转换的规则。只有当此函数返回非零值时，标量才会从此类型默默转换为需要的类型。如果标量是`NPY_NOSCALAR`，那么此函数相当于`PyArray_CanCastSafely`。规则是相同 KIND 的标量可以强制转换为相同 KIND 的数组。这个规则意味着高精度标量永远不会导致相同 KIND 的低精度数组被上升。

## 数据类型描述符

警告

数据类型对象必须进行引用计数，因此要注意不同的 C-API 调用对数据类型引用的影响。标准规则是当返回数据类型对象时，它是一个新的引用。除非另有说明，否则接受 PyArray_Descr*对象并返回数组的函数会窃取其输入的数据类型的引用。因此，您必须拥有任何用作此类函数输入的数据类型对象的引用。

```py
int PyArray_DescrCheck( *obj)
```

如果*obj*是数据类型对象（PyArray_Descr*），则评估为真。

```py
*PyArray_DescrNew( *obj)
```

从*obj*（如果有的话，字段引用仅更新，以便新对象指向相同的字段字典）复制一个新的数据类型对象。

```py
*PyArray_DescrNewFromType(int typenum)
```

从由*typenum*指示的内置（或用户注册的）数据类型创建一个新的数据类型对象。所有内置类型都不应更改其任何字段。这将创建一个`PyArray_Descr`结构的新副本，以便您可以根据需要填充它。这个函数对于灵活的数据类型尤其需要，因为它们需要一个新的 elsize 成员以便在数组构造中有意义。

```py
*PyArray_DescrNewByteorder( *obj, char newendian)
```

使用根据*newendian*设置字节顺序创建一个新的数据类型对象。所有引用的数据类型对象（子描述符和数据类型对象的字段成员）也会被更改（递归地）。

*newendian*的值是以下这些宏之一：

```py
NPY_IGNORE
```

```py
NPY_SWAP
```

```py
NPY_NATIVE
```

```py
NPY_LITTLE
```

```py
NPY_BIG
```

如果遇到一个`NPY_IGNORE`的字节顺序，则会被保留。如果 newendian 是`NPY_SWAP`，则所有字节顺序都会被交换。其他有效的 newendian 值包括`NPY_NATIVE`、`NPY_LITTLE`和`NPY_BIG`，它们都会导致返回的数据类型描述符（以及它引用的所有数据类型描述符）具有相应的字节顺序。

```py
*PyArray_DescrFromObject( *op, *mintype)
```

根据对象*op*（应该是一个“嵌套”序列对象）和最小数据类型描述符 mintype（可以是`NULL`）确定合适的数据类型对象。与 array(*op*).dtype 的行为类似。不要将此函数与`PyArray_DescrConverter`混淆。这个函数基本上查看（嵌套）序列中的所有对象，并从找到的元素中确定数据类型。

```py
*PyArray_DescrFromScalar( *scalar)
```

从数组标量对象返回一个数据类型对象。不检查*scalar*是否是数组标量。如果无法确定合适的数据类型，则默认返回一个`NPY_OBJECT`的数据类型。

```py
*PyArray_DescrFromType(int typenum)
```

返回与*typenum*对应的数据类型对象。*typenum*可以是枚举类型之一，枚举类型的字符代码，或用户定义的类型。如果要使用灵活大小的数组，那么你需要`flexible typenum`，并将结果`elsize`参数设置为所需的大小。typenum 是`NPY_TYPES`之一。

```py
int PyArray_DescrConverter( *obj, **dtype)
```

将任何兼容的 Python 对象*obj*转换为*dtype*中的数据类型对象。许多 Python 对象可以转换为数据类型对象。有关完整描述，请参见数据类型对象（dtype）。这个转换器的版本将 None 对象转换为`NPY_DEFAULT_TYPE`数据类型对象。此函数可以在[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(in Python v3.11)")处理中使用“O&”字符代码。

```py
int PyArray_DescrConverter2( *obj, **dtype)
```

将任何兼容的 Python 对象*obj*转换为*dtype*中的数据类型对象。这个转换器的版本将 None 对象转换为`NULL`，这样返回的数据类型就是`NULL`。此函数还可以与 PyArg_ParseTuple 处理中的“O&”字符一起使用。

```py
int Pyarray_DescrAlignConverter( *obj, **dtype)
```

与`PyArray_DescrConverter`类似，但它将 C 结构类对象与编译器一样对齐到字边界。

```py
int Pyarray_DescrAlignConverter2( *obj, **dtype)
```

与`PyArray_DescrConverter2`类似，不过它会像编译器一样将 C 结构对象按照字边界对齐。

```py
*PyArray_FieldNames( *dict)
```

使用字段字典 *dict*，例如附加到数据类型对象上的字段，并构造字段名的有序列表，如存储在 `PyArray_Descr` 对象的 names 字段中。

## 转换实用程序

### 用于 [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(in Python v3.11)")。

所有这些函数都可以在 [`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(in Python v3.11)") (…) 中与“O&”格式说明符一起使用，以自动将任何 Python 对象转换为所需的 C 对象。如果成功，所有这些函数都返回 `NPY_SUCCEED`，如果失败则返回 `NPY_FAIL`。所有这些函数的第一个参数是一个 Python 对象。第二个参数是将 Python 对象转换为的 C 类型的**address**。

警告

确保了解在使用这些转换函数时应该采取哪些步骤来管理内存。这些函数可能需要释放内存，和/或者根据您的使用来改变特定对象的引用计数。

```py
int PyArray_Converter( *obj, **address)
```

将任何 Python 对象转换为 `PyArrayObject`。如果 `PyArray_Check` (*obj*) 为 TRUE，则增加其引用计数并在 *address* 中放置一个引用。如果 *obj* 不是数组，则使用 `PyArray_FromAny` 将其转换为数组。无论返回什么，你在完成后必须 DECREF 这个地址中返回的对象。

```py
int PyArray_OutputConverter( *obj, **address)
```

这是给定给函数的输出数组的默认转换器。如果 *obj* 是 [`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)") 或 `NULL`，则 **address** 将是 `NULL`，但是调用会成功。如果 `PyArray_Check` ( *obj*) 为 TRUE，则返回其 **address** 而不增加其引用计数。

```py
int PyArray_IntpConverter( *obj, *seq)
```

将小于 `NPY_MAXDIMS` 的任何 Python 序列 *obj* 转换为 `npy_intp` 的 C 数组。Python 对象也可以是单个数字。*seq* 变量是一个指向具有成员 ptr 和 len 的结构体的指针。成功返回后，*seq* ->ptr 包含必须通过调用 `PyDimMem_FREE` 来释放内存，以避免内存泄漏的内存指针。对内存大小的限制使得这个转换器可以方便地用于被视为数组形状的序列。

```py
int PyArray_BufferConverter( *obj, *buf)
```

将任何具有（单片段）缓冲区接口的 Python 对象*obj*转换为一个具有详细描述对象在内存块中使用的成员的变量。*buf*变量是一个指向具有 base、ptr、len 和 flags 成员的结构体指针。`PyArray_Chunk` 结构与 Python 的缓冲区对象二进制兼容（在 32 位平台上通过其 len 成员，在 64 位平台上通过其 ptr 成员）。返回时，base 成员设置为*obj*（或其基础如果*obj*已经是指向另一个对象的缓冲区对象）。如果需要保留内存，请确保增加引用计数（INCREF）base 成员。内存块由*buf*->ptr 成员指向，并具有长度*buf*->len。*buf*的 flags 成员是`NPY_ARRAY_ALIGNED`，如果*obj*具有可写的缓冲区接口，则设置`NPY_ARRAY_WRITEABLE`标志。

```py
int PyArray_AxisConverter( *obj, int *axis)
```

将表示轴参数的 Python 对象*obj*转换为适合传递给需要整数轴的函数的值。具体来说，如果*obj*为 None，则 axis 设置为`NPY_MAXDIMS`，C-API 函数将正确解释带轴参数的函数。

```py
int PyArray_BoolConverter( *obj, *value)
```

将任何 Python 对象*obj*转换为`NPY_TRUE`或`NPY_FALSE`，并将结果放在*value*中。

```py
int PyArray_ByteorderConverter( *obj, char *endian)
```

将 Python 字符串转换为相应的字节顺序字符：‘>’、‘<’、‘s’、‘=’或‘|’。

```py
int PyArray_SortkindConverter( *obj, *sort)
```

将 Python 字符串转换为`NPY_QUICKSORT`之一（以‘q’或‘Q’开头）、`NPY_HEAPSORT`之一（以‘h’或‘H’开头）、`NPY_MERGESORT`之一（以‘m’或‘M’开头）或`NPY_STABLESORT`之一（以‘t’或‘T’开头）。`NPY_MERGESORT`和`NPY_STABLESORT`彼此别名以保持向后兼容性，并根据数据类型可能指的是几种稳定排序算法之一。

```py
int PyArray_SearchsideConverter( *obj, *side)
```

将 Python 字符串转换为`NPY_SEARCHLEFT`之一（以‘l’或‘L’开头），或`NPY_SEARCHRIGHT`之一（以‘r’或‘R’开头）。

```py
int PyArray_OrderConverter( *obj, *order)
```

将 Python 字符串‘C’、‘F’、‘A’和‘K’转换成`NPY_ORDER`枚举`NPY_CORDER`、`NPY_FORTRANORDER`、`NPY_ANYORDER`和`NPY_KEEPORDER`。

```py
int PyArray_CastingConverter( *obj, *casting)
```

将 Python 字符串‘no’，‘equiv’，‘safe’，‘same_kind’和‘unsafe’转换为`NPY_CASTING`枚举`NPY_NO_CASTING`，`NPY_EQUIV_CASTING`，`NPY_SAFE_CASTING`，`NPY_SAME_KIND_CASTING`和`NPY_UNSAFE_CASTING`的枚举。

```py
int PyArray_ClipmodeConverter( *object, *val)
```

将 Python 字符串‘clip’，‘wrap’和‘raise’转换为`NPY_CLIPMODE`枚举`NPY_CLIP`，`NPY_WRAP`和`NPY_RAISE`。

```py
int PyArray_ConvertClipmodeSequence( *object, *modes, int n)
```

将剪裁模式序列或单个剪裁模式转换为`NPY_CLIPMODE`值的 C 数组。 在调用此函数之前必须知道剪裁模式的数量*n*。 提供此函数以帮助函数为每个维度允许不同的剪裁模式。

### 其他转换

```py
int PyArray_PyIntAsInt( *op)
```

将所有类型的 Python 对象（包括数组和数组标量）转换为标准整数。 出现错误时，返回-1 并设置异常。 您可能会发现以下宏有用：

```py
#define error_converting(x) (((x) == -1) && PyErr_Occurred()) 
```

```py
PyArray_PyIntAsIntp( *op)
```

将所有类型的 Python 对象（包括数组和数组标量）转换为（平台指针大小的）整数。 出现错误时，返回-1 并设置异常。

```py
int PyArray_IntpFromSequence( *seq, *vals, int maxvals)
```

将作为*seq*传递的任何 Python 序列（或单个 Python 数字）转换为（最多）*maxvals*指针大小的整数，并将它们放在*vals*数组中。 序列可以小于*maxvals*，因为返回转换对象的数量。

```py
int PyArray_TypestrConvert(int itemsize, int gentype)
```

将类型字符串字符（带有*itemsize*）转换为基本枚举数据类型。 识别并转换相对应于有符号和无符号整数，浮点数和复数浮点数的类型字符串字符。 返回其他值的 gentype。 例如，可以使用此函数将字符串‘f4’转换为`NPY_FLOAT32`。

### 用于[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(在 Python v3.11 中)")

所有这些函数都可以在[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(在 Python v3.11 中)") (…)中使用，使用“O&”格式说明符自动将任何 Python 对象转换为所需的 C 对象。 所有这些函数如果成功，则返回`NPY_SUCCEED`，否则返回`NPY_FAIL`。 所有这些函数的第一个参数是 Python 对象。 第二个参数是要将 Python 对象转换为的 C 类型的**地址**。

警告

一定要了解在使用这些转换函数时应采取哪些步骤来管理内存。这些函数可能需要释放内存，和/或根据您的使用情况改变特定对象的引用计数。

```py
int PyArray_Converter( *obj, **address)
```

将任何 Python 对象转换为`PyArrayObject`。如果`PyArray_Check`（*obj*）为 TRUE，则增加其引用计数并在 *address* 中放置一个引用。如果 *obj* 不是数组，则使用`PyArray_FromAny`将其转换为数组。无论返回什么，当使用完这个例程返回的对象时，必须在 *address* 中减少对该对象的引用。

```py
int PyArray_OutputConverter( *obj, **address)
```

这是给定给函数的输出数组的默认转换器。如果 *obj* 是[`Py_None`](https://docs.python.org/3/c-api/none.html#c.Py_None "(in Python v3.11)")或`NULL`，那么**address* 将为`NULL`，但调用会成功。如果`PyArray_Check`（*obj*）为 TRUE，则会在**address* 中返回它而不增加其引用计数。

```py
int PyArray_IntpConverter( *obj, *seq)
```

将任何小于`NPY_MAXDIMS`的 Python 序列 *obj* 转换为`npy_intp`的 C 数组。Python 对象也可以是单个数字。*seq* 变量是指向具有成员 ptr 和 len 的结构体的指针。成功返回后，*seq* ->ptr 包含一个必须通过调用`PyDimMem_FREE`释放的内存的指针，以避免内存泄漏。对内存大小的限制允许方便地将此转换器用于被解释为数组形状的序列。

```py
int PyArray_BufferConverter( *obj, *buf)
```

将具有（单一段）缓冲区接口的任何 Python 对象 *obj* 转换为具有详细成员的变量，以详细说明对象对其内存块的使用。*buf* 变量是指向具有基址、ptr、len 和 flags 成员的结构体的指针。`PyArray_Chunk` 结构与 Python 的缓冲区对象二进制兼容（通过其 32 位平台上的 len 成员和 64 位平台上的 ptr 成员）。返回时，将 base 成员设置为 *obj*（或其基址，如果 *obj* 已经是指向另一个对象的缓冲区对象）。如果需要保留内存，请确保增加 base 成员的引用计数。内存块由 *buf* ->ptr 成员指向，并具有长度 *buf* ->len。如果 *obj* 具有可写缓冲区接口，则 *buf* 的 flags 成员是`NPY_ARRAY_ALIGNED`，并设置了`NPY_ARRAY_WRITEABLE`标志。

```py
int PyArray_AxisConverter( *obj, int *axis)
```

将代表轴参数的 Python 对象 *obj* 转换为适当的值，以便传递给接受整数轴的函数。具体来说，如果 *obj* 是 None，则 *axis* 设置为`NPY_MAXDIMS`，这样 C-API 函数就能正确解释轴参数。

```py
int PyArray_BoolConverter( *obj, *value)
```

将任何 Python 对象 *obj* 转换为 `NPY_TRUE` 或 `NPY_FALSE`，并将结果放置在 *value* 中。

```py
int PyArray_ByteorderConverter( *obj, char *endian)
```

将 Python 字符串转换为相应的字节顺序字符：'>'、'<'、's'、'=' 或 '|'。

```py
int PyArray_SortkindConverter( *obj, *sort)
```

将 Python 字符串转换为 `NPY_QUICKSORT`（以 'q' 或 'Q' 开头）、`NPY_HEAPSORT`（以 'h' 或 'H' 开头）、`NPY_MERGESORT`（以 'm' 或 'M' 开头）或 `NPY_STABLESORT`（以 't' 或 'T' 开头）中的一个。对于向后兼容性，`NPY_MERGESORT`和 `NPY_STABLESORT` 会相互别名，并且可能根据数据类型指代多种稳定的排序算法之一。

```py
int PyArray_SearchsideConverter( *obj, *side)
```

将 Python 字符串转换为 `NPY_SEARCHLEFT`（以 'l' 或 'L' 开头），或 `NPY_SEARCHRIGHT`（以 'r' 或 'R' 开头）。

```py
int PyArray_OrderConverter( *obj, *order)
```

将 Python 字符串 'C'、 'F'、 'A' 和 'K' 转换为枚举 `NPY_CORDER`、`NPY_FORTRANORDER`、`NPY_ANYORDER` 和 `NPY_KEEPORDER`。

```py
int PyArray_CastingConverter( *obj, *casting)
```

将 Python 字符串 'no'、 'equiv'、'safe'、'same_kind' 和 'unsafe' 转换为枚举 `NPY_NO_CASTING`、`NPY_EQUIV_CASTING`、`NPY_SAFE_CASTING`、`NPY_SAME_KIND_CASTING` 和 `NPY_UNSAFE_CASTING`。

```py
int PyArray_ClipmodeConverter( *object, *val)
```

将 Python 字符串 'clip'、'wrap' 和 'raise' 转换为枚举 `NPY_CLIP`、`NPY_WRAP` 和 `NPY_RAISE`。

```py
int PyArray_ConvertClipmodeSequence( *object, *modes, int n)
```

将一系列 clipmodes 或单个 clipmode 转换为存储 `NPY_CLIPMODE` 值的 C 数组。在调用此函数之前，必须知道 clipmodes 的数量 *n*。此函数用于帮助函数允许每个维度使用不同的 clipmode。

### 其他转换

```py
int PyArray_PyIntAsInt( *op)
```

将所有类型的 Python 对象（包括数组和数组标量）转换为标准整数。出现错误时，返回-1 并设置异常。您可能会发现以下宏有用：

```py
#define error_converting(x) (((x) == -1) && PyErr_Occurred()) 
```

```py
PyArray_PyIntAsIntp( *op)
```

将所有类型的 Python 对象（包括数组和数组标量）转换为（平台指针大小的）整数。出现错误时，返回-1 并设置异常。

```py
int PyArray_IntpFromSequence( *seq, *vals, int maxvals)
```

将作为*seq*传递的任何 Python 序列（或单个 Python 数字）转换为（最多）*maxvals*个指针大小的整数，并将它们放入*vals*数组中。由于返回已转换对象的数量，因此序列可以小于*maxvals*。

```py
int PyArray_TypestrConvert(int itemsize, int gentype)
```

将类型字符串字符（带有*itemsize*）转换为基本枚举数据类型。识别并转换有符号和无符号整数、浮点数和复数浮点数对应的类型字符串字符。并返回 gentype 的其他值。例如，此函数可用于将字符串‘f4’转换为`NPY_FLOAT32`。

## 其他

### 导入 API

为了从另一个扩展模块中使用 C-API，必须调用`import_array`函数。如果扩展模块包含在单个.c 文件中，则只需完成这些步骤。但是，如果扩展模块涉及需要 C-API 的多个文件，则必须执行一些额外的步骤。

```py
void import_array(void)
```

此函数必须在将使用 C-API 的模块的初始化部分中调用。它导入存储函数指针表的模块，并将正确的变量指向它。

```py
PY_ARRAY_UNIQUE_SYMBOL
```

```py
NO_IMPORT_ARRAY
```

使用这些#定义，您可以在单个扩展模块的多个文件中使用 C-API。在每个文件中，您必须将`PY_ARRAY_UNIQUE_SYMBOL`定义为将保存 C-API 的一些名称（如 myextension_ARRAY_API）。这必须在包含 numpy/arrayobject.h 文件**之前**完成。在模块初始化例程中，调用`import_array`。此外，在没有模块初始化子例程的文件中，在包含 numpy/arrayobject.h 之前，定义`NO_IMPORT_ARRAY`。

假设我有两个文件 coolmodule.c 和 coolhelper.c，需要编译并链接成单个扩展模块。假设 coolmodule.c 包含所需的 initcool 模块初始化函数（调用了 import_array()函数）。那么，coolmodule.c 应该在顶部包含：

```py
#define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API
#include numpy/arrayobject.h 
```

另一方面，coolhelper.c 应该在顶部包含：

```py
#define NO_IMPORT_ARRAY
#define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API
#include numpy/arrayobject.h 
```

可以将常见的最后两行放入局部扩展头文件中，只要在#包含该文件之前确保已定义了 NO_IMPORT_ARRAY。

在内部，这些#定义的工作方式如下：

> +   如果两者都没有定义，则 C-API 被声明为`static void**`，因此它仅在包含 numpy/arrayobject.h 的编译单元中可见。
> +   
> +   如果已经定义了`PY_ARRAY_UNIQUE_SYMBOL`，但没有定义`NO_IMPORT_ARRAY`，则 C-API 被声明为`void**`，以便它也可被其他编译单元看到。
> +   
> +   如果`NO_IMPORT_ARRAY`被定义，无论是否`PY_ARRAY_UNIQUE_SYMBOL`被定义，C-API 都声明为`extern void**`，因此预计它将在另一个编译单元中定义。
> +   
> +   每当`PY_ARRAY_UNIQUE_SYMBOL`被定义，它还会改变默认情况下保存 C-API 的变量名称`PyArray_API`，变成宏所定义的任何名称。

### 检查 API 版本

因为在大多数平台上，python 扩展的使用方式与通常库不同，所以某些错误在构建时甚至运行时都不能自动检测到。例如，如果你使用了仅适用于 numpy >= 1.3.0 的函数来构建扩展，并且稍后在 numpy 1.2 下导入扩展，你将不会得到导入错误（但在调用函数时几乎肯定会发生分段错误）。这就是为什么提供了几个函数来检查 numpy 版本。宏`NPY_VERSION`和`NPY_FEATURE_VERSION`对应于用于构建扩展的 numpy 版本，而函数`PyArray_GetNDArrayCVersion`和`PyArray_GetNDArrayCFeatureVersion`返回的版本对应于运行时 numpy 的版本。

ABI 和 API 兼容性的规则可以总结如下：

> +   每当`NPY_VERSION` != `PyArray_GetNDArrayCVersion()`时，扩展都必须重新编译（ABI 不兼容）。
> +   
> +   `NPY_VERSION` == `PyArray_GetNDArrayCVersion()`和`NPY_FEATURE_VERSION` <= `PyArray_GetNDArrayCFeatureVersion()`表示向后兼容的更改。

在每个 numpy 版本中自动检测 ABI 不兼容性。在 numpy 1.4.0 中添加了 API 不兼容性检测。如果要支持多个不同的 numpy 版本，并且使用一个扩展二进制文件，就必须尽可能用最低的`NPY_FEATURE_VERSION`来构建扩展。

```py
NPY_VERSION
```

ndarray 对象的当前版本（检查是否定义了这个变量，以确保正在使用`numpy/arrayobject.h`头文件）。

```py
NPY_FEATURE_VERSION
```

C-API 的当前版本。

```py
unsigned int PyArray_GetNDArrayCVersion(void)
```

这只是返回值`NPY_VERSION`。每当 ABI 级别发生向后不兼容的变化时，`NPY_VERSION`就会改变。但由于它在 C-API 中，因此比较该函数输出的值与当前头文件中定义的值可以测试 C-API 是否发生了变化，从而需要重新编译使用 C-API 的扩展模块。这在函数`import_array`中会自动检查。

```py
unsigned int PyArray_GetNDArrayCFeatureVersion(void)
```

新版本 1.4.0 中添加。

这只是返回值`NPY_FEATURE_VERSION`。每当 API 发生变化（例如添加函数），`NPY_FEATURE_VERSION`就会改变。更改的值并不总是需要重新编译。

### 内部灵活性

```py
int PyArray_SetNumericOps( *dict)
```

NumPy 存储了一个内部表格，其中包含用于实现数组的算术运算以及某些数组计算方法的 Python 可调用对象。此函数允许用户用自己的版本替换这些 Python 对象中的任意一个或全部。字典*dict*的键是要替换的命名函数，配对的值是要使用的 Python 可调用对象。应注意要替换内部数组操作的函数不能调用回该内部数组操作（除非您设计了能处理该问题的函数），否则可能导致未经检查的无限递归（可能导致程序崩溃）。可以替换的操作的键名包括：

> **add**,**subtract**,**multiply**,**divide**,**remainder**,**power**,**square**,**reciprocal**,**ones_like**,**sqrt**,**negative**,**positive**,**absolute**,**invert**,**left_shift**,**right_shift**,**bitwise_and**,**bitwise_xor**,**bitwise_or**,**less**,**less_equal**,**equal**,**not_equal**,**greater**,**greater_equal**,**floor_divide**,**true_divide**,**logical_or**,**logical_and**,**floor**,**ceil**,**maximum**,**minimum**,**rint**。

这些函数在此处列出，因为它们至少在数组对象的方法中被使用一次。如果要分配的对象之一不可调用，则函数将返回-1（而不设置 Python 错误）。

自版本 1.16 起不推荐使用。

```py
*PyArray_GetNumericOps(void)
```

返回一个包含存储在内部算术操作表中的可调用 Python 对象的 Python 字典。该字典的键在`PyArray_SetNumericOps`的说明中给出。

自版本 1.16 起不推荐使用。

```py
void PyArray_SetStringFunction( *op, int repr)
```

此函数允许您将数组对象的`tp_str`和`tp_repr`方法更改为任何 Python 函数。因此，您可以更改在 Python 调用`str(arr)`或`repr(arr)`时发生的情况。要调用的函数作为*op*传递。如果*repr*非零，则该函数将在回应`repr(arr)`时被调用，否则将在回应`str(arr)`时调用。不会检查*op*是否可调用。传递给*op*的可调用对象应期望一个数组参数，并应返回要打印的字符串。

### 内存管理

```py
char *PyDataMem_NEW(size_t nbytes)
```

```py
void PyDataMem_FREE(char *ptr)
```

```py
char *PyDataMem_RENEW(void *ptr, size_t newbytes)
```

用于分配、释放和重新分配内存的宏。这些宏在内部用于创建数组。

```py
*PyDimMem_NEW(int nd)
```

```py
void PyDimMem_FREE(char *ptr)
```

```py
*PyDimMem_RENEW(void *ptr, size_t newnd)
```

用于分配、释放和重新分配维度和步长内存的宏。

```py
void *PyArray_malloc(size_t nbytes)
```

```py
void PyArray_free(void *ptr)
```

```py
void *PyArray_realloc( *ptr, size_t nbytes)
```

这些宏使用不同的内存分配器，具体取决于常量`NPY_USE_PYMEM`。当`NPY_USE_PYMEM`为 0 时，使用系统 malloc，如果`NPY_USE_PYMEM`为 1，则使用 Python 内存分配器。

```py
NPY_USE_PYMEM
```

```py
int PyArray_ResolveWritebackIfCopy( *obj)
```

如果`obj->flags`具有`NPY_ARRAY_WRITEBACKIFCOPY`，则此函数清除标志，*DECREF* *obj->base*并使其可写，并将`obj->base`设置为 NULL。然后将`obj->data`复制到*obj->base->data*，并返回复制操作的错误状态。这与`PyArray_SetWritebackIfCopyBase`相反。通常情况下，一旦完成`obj`的使用，就会调用此函数，就在`Py_DECREF(obj)`之前。可以多次调用，或使用`NULL`输入。另请参阅`PyArray_DiscardWritebackIfCopy`。

如果没有进行任何操作，则返回 0，发生错误时返回-1，如果进行了操作则返回 1。

### 线程支持

这些宏仅在扩展模块的编译期间评估`NPY_ALLOW_THREADS`为 True 时才有意义。否则，这些宏等同于空白。Python 为每个 Python 进程使用单个全局解释器锁（GIL），因此一次只能执行一个线程（即使在多 CPU 机器上也是如此）。当调用编译函数可能需要时间来计算（并且对其他线程没有副作用，比如更新全局变量）时，应释放 GIL，以便其他 Python 线程在进行耗时计算时可以运行。这可以通过两组宏来实现。通常，如果在代码块中使用了一个组中的宏，则所有这些宏都必须在同一个代码块中使用。当前，`NPY_ALLOW_THREADS`被定义为 python 定义的`WITH_THREADS`常量，除非环境变量`NPY_NOSMP`被设置，否则`NPY_ALLOW_THREADS`被定义为 0。

```py
NPY_ALLOW_THREADS
```

```py
WITH_THREADS
```

#### 第一组

> 这个组用于调用可能需要一些时间但不使用任何 Python C-API 调用的代码。因此，在计算期间应释放 GIL。
> 
> ```py
> NPY_BEGIN_ALLOW_THREADS
> ```
> 
> 等同于[`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS "(在 Python v3.11 中)")，除了它使用`NPY_ALLOW_THREADS`来确定宏是否被替换为空格。
> 
> ```py
> NPY_END_ALLOW_THREADS
> ```
> 
> 等同于[`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS "(在 Python v3.11 中)")，除了它使用`NPY_ALLOW_THREADS`来确定宏是否被替换为空格。
> 
> ```py
> NPY_BEGIN_THREADS_DEF
> ```
> 
> 放置在变量声明区域。此宏设置了存储 Python 状态所需的变量。
> 
> ```py
> NPY_BEGIN_THREADS
> ```
> 
> 放置在不需要 Python 解释器的代码之前。此宏保存 Python 状态并释放 GIL。
> 
> ```py
> NPY_END_THREADS
> ```
> 
> 放置在不需要 Python 解释器的代码之后。此宏获取 GIL 并从保存的变量中恢复 Python 状态。
> 
> ```py
> void NPY_BEGIN_THREADS_DESCR( *dtype)
> ```
> 
> 只有当*dtype*不包含在执行循环期间可能需要 Python 解释器的任意 Python 对象时才有用。
> 
> ```py
> void NPY_END_THREADS_DESCR( *dtype)
> ```
> 
> 在使用此宏的 BEGIN 形式释放 GIL 后，有助于恢复 GIL。
> 
> ```py
> void NPY_BEGIN_THREADS_THRESHOLDED(int loop_size)
> ```
> 
> 只有在*loop_size*超过最小阈值（当前设置为 500）时才有用。应该与`NPY_END_THREADS`配对，以恢复 GIL。

#### 第二组

> 这个组用于在释放后重新获取 Python GIL。例如，假设已释放 GIL（使用以前的调用），然后代码中的某些路径（可能在不同的子例程中）需要使用 Python C-API，则这些宏有助于获取 GIL。这些宏基本上实现了先前三个的反转（获取 LOCK 并保存其状态），然后使用保存的状态重新释放它。
> 
> ```py
> NPY_ALLOW_C_API_DEF
> ```
> 
> 放置在变量声明区域以设置所需变量。
> 
> ```py
> NPY_ALLOW_C_API
> ```
> 
> 放置在需要调用 Python C-API 的代码之前（当已知 GIL 已经被释放时）。
> 
> ```py
> NPY_DISABLE_C_API
> ```
> 
> 放置在需要调用 Python C-API 的代码之后（以释放 GIL）。

提示

在线程支持宏后永远不要使用分号。

### 优先级

```py
NPY_PRIORITY
```

数组的默认优先级。

```py
NPY_SUBTYPE_PRIORITY
```

默认子类型优先级。

```py
NPY_SCALAR_PRIORITY
```

默认标量优先级（非常小）

```py
double PyArray_GetPriority( *obj, double def)
```

返回 *obj* 或 *def* 的 `__array_priority__` 属性（转换为 double），如果该名称的属性不存在，则提供快速返回避免属性查找对象的类型为 `PyArray_Type`。

### 默认缓冲区

```py
NPY_BUFSIZE
```

用户可设置内部缓冲区的默认大小。

```py
NPY_MIN_BUFSIZE
```

用户可设置内部缓冲区的最小大小。

```py
NPY_MAX_BUFSIZE
```

用户可设置缓冲区的最大大小。

### 其他常量

```py
NPY_NUM_FLOATTYPE
```

浮点类型的数量

```py
NPY_MAXDIMS
```

数组中允许的最大维数。

```py
NPY_MAXARGS
```

函数中可以使用的数组参数的最大数量。

```py
NPY_FALSE
```

定义为 0 以与 Bool 一起使用。

```py
NPY_TRUE
```

定义为 1 以与 Bool 一起使用。

```py
NPY_FAIL
```

失败的转换器函数的返回值，这些函数使用类似[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(在 Python v3.11 中)")的函数中的“O&”语法调用。

```py
NPY_SUCCEED
```

成功的转换器函数的返回值，这些函数使用类似[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple "(在 Python v3.11 中)")的函数中的“O&”语法调用。

### 其他宏

```py
int PyArray_SAMESHAPE( *a1, *a2)
```

如果数组 *a1* 和 *a2* 具有相同的形状，则评估为 True。

```py
PyArray_MAX(a, b)
```

返回 *a* 和 *b* 的最大值。如果 (*a*) 或 (*b*) 是表达式，则会评估两次。

```py
PyArray_MIN(a, b)
```

返回 *a* 和 *b* 的最小值。如果 (*a*) 或 (*b*) 是表达式，则会评估两次。

```py
PyArray_CLT(a, b)
```

```py
PyArray_CGT(a, b)
```

```py
PyArray_CLE(a, b)
```

```py
PyArray_CGE(a, b)
```

```py
PyArray_CEQ(a, b)
```

```py
PyArray_CNE(a, b)
```

使用 NumPy 的两个复数（具有实部和虚部成员的结构）之间的复杂比较实现了基于词法顺序的 NumPy 定义的比较：首先比较实部，然后如果实部相等，则比较复数部分。

```py
PyArray_REFCOUNT( *op)
```

返回任何 Python 对象的引用计数。

```py
void PyArray_DiscardWritebackIfCopy( *obj)
```

如果`obj->flags`具有`NPY_ARRAY_WRITEBACKIFCOPY`，此函数清除标志，*DECREF* s *obj->base*并使其可写，并将`obj->base`设置为 NULL。与`PyArray_ResolveWritebackIfCopy`相比，它不会尝试从*obj->base*复制数据。这是在发生错误时，当你完成`obj`时，即在`Py_DECREF(obj)`之前通常调用的。可多次调用，或使用`NULL`输入。

### 枚举类型

```py
enum NPY_SORTKIND
```

一种特殊的变量类型，可以采用不同值来指示正在使用的排序算法。

```py
enumerator NPY_QUICKSORT
```

```py
enumerator NPY_HEAPSORT
```

```py
enumerator NPY_MERGESORT
```

```py
enumerator NPY_STABLESORT
```

用作`NPY_MERGESORT`的别名，反之亦然。

```py
enumerator NPY_NSORTS
```

定义为排序的数量。由于向后兼容性的需要，此值固定为三，因此`NPY_MERGESORT`和`NPY_STABLESORT`互为别名，并可以引用几种稳定排序算法之一，具体取决于数据类型。

```py
enum NPY_SCALARKIND
```

一种特殊的变量类型，表示在确定标量强制转换规则时区分的“种类”数量。此变量可以取以下值：

```py
enumerator NPY_NOSCALAR
```

```py
enumerator NPY_BOOL_SCALAR
```

```py
enumerator NPY_INTPOS_SCALAR
```

```py
enumerator NPY_INTNEG_SCALAR
```

```py
enumerator NPY_FLOAT_SCALAR
```

```py
enumerator NPY_COMPLEX_SCALAR
```

```py
enumerator NPY_OBJECT_SCALAR
```

```py
enumerator NPY_NSCALARKINDS
```

定义为标量种类的数量（不包括`NPY_NOSCALAR`）。

```py
enum NPY_ORDER
```

表示应解释数组的元素顺序的枚举类型。创建全新数组时，一般只使用**NPY_CORDER**和**NPY_FORTRANORDER**，而在提供一个或多个输入时，顺序可以基于它们。

```py
enumerator NPY_ANYORDER
```

如果所有输入都是 Fortran，则为 Fortran 顺序，否则为 C 顺序。

```py
enumerator NPY_CORDER
```

C 顺序。

```py
enumerator NPY_FORTRANORDER
```

Fortran 顺序。

```py
enumerator NPY_KEEPORDER
```

尽可能接近输入顺序的顺序，即使输入既不是 C 顺序也不是 Fortran 顺序。

```py
enum NPY_CLIPMODE
```

表示应在某些函数中应用的裁剪类型的变量类型。

```py
enumerator NPY_RAISE
```

对大多数操作来说是默认的，在索引越界时会引发异常。

```py
enumerator NPY_CLIP
```

如果超出范围，则将索引剪辑到有效范围内。

```py
enumerator NPY_WRAP
```

如果超出范围，则将索引包裹到有效范围内。

```py
enum NPY_SEARCHSIDE
```

表示返回的索引是第一个合适位置的索引（如果`NPY_SEARCHLEFT`）还是最后一个位置的索引（如果`NPY_SEARCHRIGHT`）的变量类型。

```py
enumerator NPY_SEARCHLEFT
```

```py
enumerator NPY_SEARCHRIGHT
```

```py
enum NPY_SELECTKIND
```

表示正在使用的选择算法的变量类型。

```py
enumerator NPY_INTROSELECT
```

```py
enum NPY_CASTING
```

版本 1.6 中新增。

表示数据转换应有多宽松的枚举类型。在 NumPy 1.6 中添加的迭代器中使用，计划在将来的版本中更广泛地使用。

```py
enumerator NPY_NO_CASTING
```

仅允许相同类型。

```py
enumerator NPY_EQUIV_CASTING
```

允许相同和涉及字节交换的强制转换。

```py
enumerator NPY_SAFE_CASTING
```

仅允许不会导致值四舍五入、截断或以其他方式更改的强制转换。

```py
enumerator NPY_SAME_KIND_CASTING
```

允许任何安全的转换和相同类型的转换。例如，float64 -> float32 可以使用此规则进行转换。

```py
enumerator NPY_UNSAFE_CASTING
```

允许进行任何类型的转换，无论可能发生什么样的数据损失。

### 导入 API

要从另一个扩展模块中使用 C-API，必须调用 `import_array` 函数。如果扩展模块是包含在一个单独的 .c 文件中的自包含模块，则只需要做这些。然而，如果扩展模块涉及到需要 C-API 的多个文件，则需要进行一些额外的步骤。

```py
void import_array(void)
```

此函数必须在将要使用 C-API 的模块的初始化部分中调用。它导入存储函数指针表的模块，并将正确的变量指向它。

```py
PY_ARRAY_UNIQUE_SYMBOL
```

```py
NO_IMPORT_ARRAY
```

使用这些 #define，你可以在单个扩展模块的多个文件中使用 C-API。在每个文件中，必须将 `PY_ARRAY_UNIQUE_SYMBOL` 定义为某个保存 C-API 的名称（例如，myextension_ARRAY_API）。在模块初始化例程中，调用 `import_array`。此外，在不具有模块初始化子例程的文件中，在包含 numpy/arrayobject.h 之前定义 `NO_IMPORT_ARRAY`。

假设我有两个需要编译和链接到单个扩展模块的文件 coolmodule.c 和 coolhelper.c。假设 coolmodule.c 包含所需的 initcool 模块初始化函数（其中调用了 import_array()函数）。那么，coolmodule.c 的顶部应有以下内容：

```py
#define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API
#include numpy/arrayobject.h 
```

另一方面，coolhelper.c 的顶部应有以下内容：

```py
#define NO_IMPORT_ARRAY
#define PY_ARRAY_UNIQUE_SYMBOL cool_ARRAY_API
#include numpy/arrayobject.h 
```

你也可以将最后两行的通用内容放入扩展的本地头文件中，只要在 #include 该文件之前，确保 NO_IMPORT_ARRAY 被 #defined。

在内部，这些 #define 的工作原理如下：

> +   如果都没有定义，C-API 声明为 `static void**`，因此它仅在包含 numpy/arrayobject.h 的编译单元内可见。
> +   
> +   如果 #defined 了 `PY_ARRAY_UNIQUE_SYMBOL`，但未定义 `NO_IMPORT_ARRAY`，则 C-API 声明为 `void**`，以便它也对其他编译单元可见。
> +   
> +   如果 #defined 了 `NO_IMPORT_ARRAY`，无论 `PY_ARRAY_UNIQUE_SYMBOL` 是否被定义，都将 C-API 声明为 `extern void**`，因此它应该在另一个编译单元中定义。
> +   
> +   每当定义了 `PY_ARRAY_UNIQUE_SYMBOL`，它也会更改保存 C-API 的变量的名称，默认为 `PyArray_API`，改为宏定义所指定的名称。

### 检查 API 版本

因为在大多数平台上，Python 扩展的使用方式与通常的库不同，因此有些错误无法在构建时甚至运行时自动检测到。例如，如果使用仅在 numpy >= 1.3.0 可用的函数构建扩展，然后稍后在 numpy 1.2 上导入该扩展，您将不会收到导入错误（但几乎可以肯定在调用该函数时会导致分段错误）。这就是为什么提供了多个函数来检查 numpy 版本。宏`NPY_VERSION` 和 `NPY_FEATURE_VERSION` 对应于用于构建扩展的 numpy 版本，而函数`PyArray_GetNDArrayCVersion` 和 `PyArray_GetNDArrayCFeatureVersion` 返回的版本对应于运行时 numpy 的版本。

ABI 和 API 兼容性的规则可以总结如下：

> +   每当`NPY_VERSION` != `PyArray_GetNDArrayCVersion()`时，就需要重新编译扩展（ABI 不兼容）。
> +   
> +   `NPY_VERSION` == `PyArray_GetNDArrayCVersion()`，并且`NPY_FEATURE_VERSION` <= `PyArray_GetNDArrayCFeatureVersion()` 意味着向后兼容的变化。

每个 numpy 版本都会自动检测 ABI 不兼容性。API 不兼容性检测是在 numpy 1.4.0 中添加的。如果要使用一个扩展二进制文件支持许多不同的 numpy 版本，就必须尽可能使用最低的`NPY_FEATURE_VERSION`构建扩展。

```py
NPY_VERSION
```

ndarray 对象的当前版本（检查是否定义了此变量，以确保使用了`numpy/arrayobject.h`头文件）。

```py
NPY_FEATURE_VERSION
```

C-API 的当前版本。

```py
unsigned int PyArray_GetNDArrayCVersion(void)
```

这只返回值`NPY_VERSION`。每当 ABI 级别发生向后不兼容的更改时，`NPY_VERSION`就会改变。由于它在 C-API 中，可以通过比较此函数的输出和当前头文件中定义的值来测试 C-API 是否已更改，从而需要重新编译使用 C-API 的扩展模块。这在函数`import_array`中自动检查。

```py
unsigned int PyArray_GetNDArrayCFeatureVersion(void)
```

版本 1.4.0 的新增内容。

这只返回值`NPY_FEATURE_VERSION`。每当 API 发生变化（例如增加了一个函数），`NPY_FEATURE_VERSION`就会改变。改变的值并不总是需要重新编译。

### 内部灵活性

```py
int PyArray_SetNumericOps( *dict)
```

NumPy 存储了一个内部表格，其中包含用于实现数组的算术操作以及某些数组计算方法的 Python 可调用对象。该函数允许用户用自己的版本替换这些 Python 对象中的任意几个或全部。字典 *dict* 的键是要替换的以及要使用的 Python 可调用对象的命名函数。应注意，用于替换内部数组操作的函数不应调用该内部数组操作（除非您已设计该函数来处理），否则可能导致未经检查的无限递归（可能导致程序崩溃）。可替换操作的键名包括:

> **add**，**subtract**，**multiply**，**divide**，**remainder**，**power**，**square**，**reciprocal**，**ones_like**，**sqrt**，**negative**，**positive**，**absolute**，**invert**，**left_shift**，**right_shift**，**bitwise_and**，**bitwise_xor**，**bitwise_or**，**less**，**less_equal**，**equal**，**not_equal**，**greater**，**greater_equal**，**floor_divide**，**true_divide**，**logical_or**，**logical_and**，**floor**，**ceil**，**maximum**，**minimum**，**rint**。

这些函数在这里包含，因为它们至少在数组对象的方法中使用一次。如果分配的对象中有一个不是可调用的，则函数返回 -1（而不设置 Python 错误）。

自版本 1.16 起被弃用。

```py
*PyArray_GetNumericOps(void)
```

返回一个包含内部算术操作表中存储的可调用 Python 对象的 Python 字典。该字典的键在 `PyArray_SetNumericOps` 的解释中给出。

自版本 1.16 起被弃用。

```py
void PyArray_SetStringFunction( *op, int repr)
```

该函数允许您将数组对象的 *tp_str* 和 *tp_repr* 方法更改为任何 Python 函数。因此，您可以更改当从 Python 调用 str(arr) 或 repr(arr) 时发生的情况。要调用的函数传递为 *op*。如果 *repr* 非零，则会在响应 repr(arr) 时调用该函数，否则将在响应 str(arr) 时调用该函数。不会执行 *op* 是否可调用的检查。传递给 *op* 的可调用对象应期望一个数组参数，并应返回一个要打印的字符串。

### 内存管理

```py
char *PyDataMem_NEW(size_t nbytes)
```

```py
void PyDataMem_FREE(char *ptr)
```

```py
char *PyDataMem_RENEW(void *ptr, size_t newbytes)
```

用于分配、释放和重新分配内存的宏。这些宏在内部用于创建数组。

```py
*PyDimMem_NEW(int nd)
```

```py
void PyDimMem_FREE(char *ptr)
```

```py
*PyDimMem_RENEW(void *ptr, size_t newnd)
```

用于分配、释放和重新分配维度和步幅内存的宏。

```py
void *PyArray_malloc(size_t nbytes)
```

```py
void PyArray_free(void *ptr)
```

```py
void *PyArray_realloc( *ptr, size_t nbytes)
```

这些宏使用不同的内存分配器，具体取决于常量 `NPY_USE_PYMEM`。当 `NPY_USE_PYMEM` 为 0 时，将使用系统 malloc，如果 `NPY_USE_PYMEM` 为 1，则将使用 Python 内存分配器。

```py
NPY_USE_PYMEM
```

```py
int PyArray_ResolveWritebackIfCopy( *obj)
```

如果`obj->flags`具有`NPY_ARRAY_WRITEBACKIFCOPY`，此函数会清除标志，*DECREF* *obj->base*并使其可写，并将`obj->base`设置为 NULL。然后将`obj->data`复制到*obj->base->data*，并返回复制操作的错误状态。这与`PyArray_SetWritebackIfCopyBase`相反。通常在完成对`obj`的操作后，就在`Py_DECREF(obj)`之前调用此函数。可以多次调用，或者使用`NULL`输入。另请参阅`PyArray_DiscardWritebackIfCopy`。

如果未执行任何操作则返回 0，出错返回-1，执行操作返回 1。

### 线程支持

这些宏仅在编译扩展模块时`NPY_ALLOW_THREADS`评估为 True 时才有意义。否则，这些宏等效于空格。Python 为每个 Python 进程使用单个全局解释器锁（GIL），因此一次只能执行一个线程（即使在多 CPU 机器上也是如此）。当调用编译函数可能需要时间来计算（并且不会对其他线程产生副作用，如更新全局变量）时，应释放 GIL，以便其他 Python 线程在进行耗时计算时可以运行。可以使用两组宏来实现这一点。通常，如果在代码块中使用一组宏，则必须在同一代码块中使用所有宏。当前，`NPY_ALLOW_THREADS`被定义为 python 定义的`WITH_THREADS`常量，除非设置了环境变量`NPY_NOSMP`，在这种情况下，`NPY_ALLOW_THREADS`被定义为 0。

```py
NPY_ALLOW_THREADS
```

```py
WITH_THREADS
```

#### 第一组

> 此组用于调用可能需要一些时间但不使用任何 Python C-API 调用的代码。因此，在计算过程中应释放 GIL。
> 
> ```py
> NPY_BEGIN_ALLOW_THREADS
> ```
> 
> 等效于[`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS "(在 Python v3.11 中)")，只是它使用`NPY_ALLOW_THREADS`来确定宏是否替换为空格。
> 
> ```py
> NPY_END_ALLOW_THREADS
> ```
> 
> 等效于[`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS "(在 Python v3.11 中)")，只是它使用`NPY_ALLOW_THREADS`来确定宏是否替换为空格。
> 
> ```py
> NPY_BEGIN_THREADS_DEF
> ```
> 
> 放置在变量声明区域。此宏设置了存储 Python 状态所需的变量。
> 
> ```py
> NPY_BEGIN_THREADS
> ```
> 
> 放置在不需要 Python 解释器的代码之前。此宏保存 Python 状态并释放 GIL。
> 
> ```py
> NPY_END_THREADS
> ```
> 
> 放在不需要 Python 解释器的代码之后。这个宏获取 GIL 并从保存的变量恢复 Python 状态。
> 
> ```py
> void NPY_BEGIN_THREADS_DESCR( *dtype)
> ```
> 
> 只有在 *dtype* 不包含在循环执行过程中可能需要 Python 解释器的任意 Python 对象时才有用于释放 GIL。 
> 
> ```py
> void NPY_END_THREADS_DESCR( *dtype)
> ```
> 
> 在使用此宏的 BEGIN 形式后释放 GIL 的情况下，有助于重新获得 GIL。
> 
> ```py
> void NPY_BEGIN_THREADS_THRESHOLDED(int loop_size)
> ```
> 
> 只有在 *loop_size* 超过最小阈值时有用于释放 GIL，目前设置为 500。应与 `NPY_END_THREADS` 一起匹配以重新获得 GIL。

#### 组 2

> 这个组用于在释放后重新获取 Python GIL。例如，假设已经释放了 GIL（使用之前的调用），然后代码中的某些路径（可能在不同的子例程中）需要使用 Python C-API，那么这些宏很有用，用于获取 GIL。这些宏基本上完成了前三个操作的反向操作（获取锁保存其状态），然后用保存的状态重新释放它。
> 
> ```py
> NPY_ALLOW_C_API_DEF
> ```
> 
> 放在变量声明区域以设置必要的变量。
> 
> ```py
> NPY_ALLOW_C_API
> ```
> 
> 放置在需要调用 Python C-API 的代码之前（已知已释放 GIL）。
> 
> ```py
> NPY_DISABLE_C_API
> ```
> 
> 放在需要调用 Python C-API 的代码之后（用于重新释放 GIL）。

提示

在线程支持宏后面不要使用分号。

#### 组 1

> 这个组用于调用可能需要一些时间但不使用任何 Python C-API 调用的代码。因此，在其计算过程中应释放 GIL。
> 
> ```py
> NPY_BEGIN_ALLOW_THREADS
> ```
> 
> 与[`Py_BEGIN_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_BEGIN_ALLOW_THREADS)相当，只是它使用`NPY_ALLOW_THREADS`来确定该宏是否替换为空格还是不替换。
> 
> ```py
> NPY_END_ALLOW_THREADS
> ```
> 
> 与[`Py_END_ALLOW_THREADS`](https://docs.python.org/3/c-api/init.html#c.Py_END_ALLOW_THREADS)相当，只是它使用`NPY_ALLOW_THREADS`来确定该宏是否替换为空格还是不替换。
> 
> ```py
> NPY_BEGIN_THREADS_DEF
> ```
> 
> 放在变量声明区域。此宏设置所需的用于存储 Python 状态的变量。
> 
> ```py
> NPY_BEGIN_THREADS
> ```
> 
> 放在不需要 Python 解释器（没有 Python C-API 调用）的代码之前。此宏保存 Python 状态并释放 GIL。
> 
> ```py
> NPY_END_THREADS
> ```
> 
> 放在不需要 Python 解释器的代码之后。这个宏获取 GIL 并从保存的变量恢复 Python 状态。
> 
> ```py
> void NPY_BEGIN_THREADS_DESCR( *dtype)
> ```
> 
> 只有在 *dtype* 不包含在循环执行过程中可能需要 Python 解释器的任意 Python 对象时才有用于释放 GIL。
> 
> ```py
> void NPY_END_THREADS_DESCR( *dtype)
> ```
> 
> 在使用此宏的 BEGIN 形式后释放 GIL 的情况下，有助于重新获得 GIL。
> 
> ```py
> void NPY_BEGIN_THREADS_THRESHOLDED(int loop_size)
> ```
> 
> 只有在 *loop_size* 超过最小阈值时才有用于释放 GIL，目前设置为 500。应与 `NPY_END_THREADS` 一起匹配以重新获得 GIL。

#### 组 2

> 此组用于在释放后重新获取 Python GIL。例如，假设 GIL 已经被释放（使用先前的调用），然后代码中的一些路径（也许在不同的子例程中）需要使用 Python C-API，那么这些宏就可以用于获取 GIL。这些宏基本上完成了前三个的反向操作（获取锁保存其状态），然后使用保存的状态重新释放。
> 
> ```py
> NPY_ALLOW_C_API_DEF
> ```
> 
> 放置在变量声明区域以设置必要的变量。
> 
> ```py
> NPY_ALLOW_C_API
> ```
> 
> 在需要调用 Python C-API 的代码之前放置（当已知 GIL 已经被释放时）。
> 
> ```py
> NPY_DISABLE_C_API
> ```
> 
> 在需要调用 Python C-API 的代码后面放置（重新释放 GIL）。

提示

在线程支持宏后永远不要使用分号。

### 优先级

```py
NPY_PRIORITY
```

数组的默认优先级。

```py
NPY_SUBTYPE_PRIORITY
```

默认子类型优先级。

```py
NPY_SCALAR_PRIORITY
```

默认标量优先级（非常小）

```py
double PyArray_GetPriority( *obj, double def)
```

返回*obj*或*def*的`__array_priority__`属性（转换为 double），如果不存在该名称的属性，则提供避免属性查找的快速返回。为`PyArray_Type`类型的对象提供了实现。

### 默认缓冲区

```py
NPY_BUFSIZE
```

用户可设置内部缓冲区的默认尺寸。

```py
NPY_MIN_BUFSIZE
```

用户可设置内部缓冲区的最小尺寸。

```py
NPY_MAX_BUFSIZE
```

用户可设置缓冲区的最大大小。

### 其他常量

```py
NPY_NUM_FLOATTYPE
```

浮点类型的数量

```py
NPY_MAXDIMS
```

数组中允许的最大维数。

```py
NPY_MAXARGS
```

函数中可以使用的数组参数的最大数量。

```py
NPY_FALSE
```

定义为 0，以与 Bool 一起使用。

```py
NPY_TRUE
```

定义为 1，以与 Bool 一起使用。

```py
NPY_FAIL
```

通过“O&”语法在类似[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple)的函数中调用的失败转换函数的返回值。

```py
NPY_SUCCEED
```

成功转换函数的返回值，这些函数是在类似[`PyArg_ParseTuple`](https://docs.python.org/3/c-api/arg.html#c.PyArg_ParseTuple)的函数中使用“O&”语法调用的。

### 杂项宏

```py
int PyArray_SAMESHAPE( *a1, *a2)
```

如果数组*a1*和*a2*具有相同的形状，则评估为 True。

```py
PyArray_MAX(a, b)
```

返回*a*和*b*的最大值。如果(*a*)或(*b*)是表达式，则会评估两次。

```py
PyArray_MIN(a, b)
```

返回*a*和*b*的最小值。如果(*a*)或(*b*)是表达式，则会评估两次。

```py
PyArray_CLT(a, b)
```

```py
PyArray_CGT(a, b)
```

```py
PyArray_CLE(a, b)
```

```py
PyArray_CGE(a, b)
```

```py
PyArray_CEQ(a, b)
```

```py
PyArray_CNE(a, b)
```

使用 NumPy 的复数进行复杂比较（具有实部和虚部成员的结构）的实现，其排序定义为字典顺序：首先比较实部，如果实部相等，则比较虚部。

```py
PyArray_REFCOUNT( *op)
```

返回任何 Python 对象的引用计数。

```py
void PyArray_DiscardWritebackIfCopy( *obj)
```

如果`obj->flags`具有`NPY_ARRAY_WRITEBACKIFCOPY`，此函数会清除标志，*DECREF* *obj->base* 并使其可写，并将`obj->base`设置为 NULL。与`PyArray_ResolveWritebackIfCopy`相反，它不会尝试从*obj->base*复制数据。这会撤消`PyArray_SetWritebackIfCopyBase`。通常在错误发生时并且在使用`obj`完成后，即在`Py_DECREF(obj)`之前调用此函数。它可以被多次调用，或者带有`NULL`输入。

### 枚举类型

```py
enum NPY_SORTKIND
```

一个特殊的变量类型，可以采用不同的值表示所使用的排序算法。

```py
enumerator NPY_QUICKSORT
```

```py
enumerator NPY_HEAPSORT
```

```py
enumerator NPY_MERGESORT
```

```py
enumerator NPY_STABLESORT
```

用作`NPY_MERGESORT`的别名，反之亦然。

```py
enumerator NPY_NSORTS
```

定义为排序的数量。由于向后兼容性的需要，它被固定为三个，并且因此`NPY_MERGESORT`和`NPY_STABLESORT`等彼此别名，并可能指代取决于数据类型的几种稳定排序算法之一。

```py
enum NPY_SCALARKIND
```

一种特殊的变量类型，用于指示在确定标量强制规则时区分的标量“种类”的数量。该变量可以取以下值：

```py
enumerator NPY_NOSCALAR
```

```py
enumerator NPY_BOOL_SCALAR
```

```py
enumerator NPY_INTPOS_SCALAR
```

```py
enumerator NPY_INTNEG_SCALAR
```

```py
enumerator NPY_FLOAT_SCALAR
```

```py
enumerator NPY_COMPLEX_SCALAR
```

```py
enumerator NPY_OBJECT_SCALAR
```

```py
enumerator NPY_NSCALARKINDS
```

定义为标量种类的数量（不包括`NPY_NOSCALAR`）。

```py
enum NPY_ORDER
```

表示数组应该以哪种顺序解释的枚举类型。创建全新数组时，通常只使用**NPY_CORDER**和**NPY_FORTRANORDER**，而当提供一个或多个输入时，顺序可以基于它们。

```py
enumerator NPY_ANYORDER
```

如果所有输入都是 Fortran，则为 Fortran 顺序，否则为 C 顺序。

```py
enumerator NPY_CORDER
```

C 顺序。

```py
enumerator NPY_FORTRANORDER
```

Fortran 顺序。

```py
enumerator NPY_KEEPORDER
```

尽量接近输入顺序的顺序，即使输入的顺序既不是 C 顺序也不是 Fortran 顺序。

```py
enum NPY_CLIPMODE
```

一个变量类型，指示在某些函数中应用的剪裁类型。

```py
enumerator NPY_RAISE
```

大多数操作的默认值，如果索引超出范围会引发异常。

```py
enumerator NPY_CLIP
```

如果索引超出范围，则将其剪裁到有效范围。

```py
enumerator NPY_WRAP
```

如果索引超出范围，则将其包裹到有效范围。

```py
enum NPY_SEARCHSIDE
```

一个变量类型，指示返回的索引应该是第一个合适位置的（如果是`NPY_SEARCHLEFT`）还是最后一个位置的（如果是`NPY_SEARCHRIGHT`）。

```py
enumerator NPY_SEARCHLEFT
```

```py
enumerator NPY_SEARCHRIGHT
```

```py
enum NPY_SELECTKIND
```

一个变量类型，指示正在使用的选择算法。

```py
enumerator NPY_INTROSELECT
```

```py
enum NPY_CASTING
```

在 1.6���本中新增。

表示数据转换应该多宽松的枚举类型。这是 NumPy 1.6 中添加的迭代器使用的，未来版本中打算更广泛使用。

```py
enumerator NPY_NO_CASTING
```

仅允许相同类型。

```py
enumerator NPY_EQUIV_CASTING
```

允许相同类型和涉及字节交换的强制转换。

```py
enumerator NPY_SAFE_CASTING
```

仅允许不会导致值四舍五入、截断或以其他方式更改的强制转换。

```py
enumerator NPY_SAME_KIND_CASTING
```

允许任何安全转换，以及同类别之间的转换。例如，float64 -> float32 符合这个规则。

```py
enumerator NPY_UNSAFE_CASTING
```

允许任何类型的转换，无论可能发生何种数据损失。
