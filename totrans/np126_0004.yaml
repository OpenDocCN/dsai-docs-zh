- en: NumPy quickstart
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy快速开始
- en: 原文：[https://numpy.org/doc/1.26/user/quickstart.html](https://numpy.org/doc/1.26/user/quickstart.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://numpy.org/doc/1.26/user/quickstart.html](https://numpy.org/doc/1.26/user/quickstart.html)
- en: Prerequisites
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: You’ll need to know a bit of Python. For a refresher, see the [Python tutorial](https://docs.python.org/tutorial/).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解一点Python。需要恢复记忆的话，参见[Python教程](https://docs.python.org/tutorial/)。
- en: To work the examples, you’ll need `matplotlib` installed in addition to NumPy.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些示例，除了NumPy外，你还需要安装`matplotlib`。
- en: '**Learner profile**'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习者概况**'
- en: This is a quick overview of arrays in NumPy. It demonstrates how n-dimensional
    (\(n>=2\)) arrays are represented and can be manipulated. In particular, if you
    don’t know how to apply common functions to n-dimensional arrays (without using
    for-loops), or if you want to understand axis and shape properties for n-dimensional
    arrays, this article might be of help.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 这是NumPy中数组的快速概述。它演示了如何表示和操作n维（\(n>=2\))数组。特别是，如果你不知道如何在n维数组上应用常见的函数（而不使用for循环），或者想理解关于n维数组的轴和形状属性，这篇文章可能会有所帮助。
- en: '**Learning Objectives**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习目标**'
- en: 'After reading, you should be able to:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完之后，你应该能够：
- en: Understand the difference between one-, two- and n-dimensional arrays in NumPy;
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解在NumPy中一维、二维和n维数组之间的区别；
- en: Understand how to apply some linear algebra operations to n-dimensional arrays
    without using for-loops;
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何在n维数组上应用一些线性代数操作，而不使用for循环；
- en: Understand axis and shape properties for n-dimensional arrays.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解n维数组的轴和形状属性。
- en: '## The Basics'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '## 基础知识'
- en: NumPy’s main object is the homogeneous multidimensional array. It is a table
    of elements (usually numbers), all of the same type, indexed by a tuple of non-negative
    integers. In NumPy dimensions are called *axes*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的主要对象是同质的多维数组。它是一张元素表（通常是数字），全部是相同类型的，通过非负整数的元组索引。在NumPy中，维度被称为*轴*。
- en: For example, the array for the coordinates of a point in 3D space, `[1, 2, 1]`,
    has one axis. That axis has 3 elements in it, so we say it has a length of 3\.
    In the example pictured below, the array has 2 axes. The first axis has a length
    of 2, the second axis has a length of 3.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，三维空间中一个点的坐标的数组`[1, 2, 1]`有一个轴。该轴有3个元素，因此我们说它的长度是3。在下面的例子中，数组有2个轴。第一个轴的长度为2，第二个轴的长度为3。
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'NumPy’s array class is called `ndarray`. It is also known by the alias `array`.
    Note that `numpy.array` is not the same as the Standard Python Library class `array.array`,
    which only handles one-dimensional arrays and offers less functionality. The more
    important attributes of an `ndarray` object are:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy的数组类称为`ndarray`。它也被别名`array`所知。注意，`numpy.array`并不等同于标准Python库的`array.array`类，后者只处理一维数组并提供较少的功能。`ndarray`对象的更重要的属性有：
- en: ndarray.ndim
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.ndim
- en: the number of axes (dimensions) of the array.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的轴（维度）数量。
- en: ndarray.shape
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.shape
- en: the dimensions of the array. This is a tuple of integers indicating the size
    of the array in each dimension. For a matrix with *n* rows and *m* columns, `shape`
    will be `(n,m)`. The length of the `shape` tuple is therefore the number of axes,
    `ndim`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的维度。这是一个整数元组，指示每个维度上数组的大小。对于一个有*n*行和*m*列的矩阵，`shape`将是`(n,m)`。因此`shape`元组的长度即为轴的数量，即`ndim`。
- en: ndarray.size
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.size
- en: the total number of elements of the array. This is equal to the product of the
    elements of `shape`.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中元素的总个数。这等于`shape`元素的乘积。
- en: ndarray.dtype
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.dtype
- en: an object describing the type of the elements in the array. One can create or
    specify dtype’s using standard Python types. Additionally NumPy provides types
    of its own. numpy.int32, numpy.int16, and numpy.float64 are some examples.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 描述数组中元素类型的对象。可以使用标准的Python类型创建或指定dtype。另外，NumPy提供了自己的类型。`numpy.int32`、`numpy.int16`和`numpy.float64`是一些例子。
- en: ndarray.itemsize
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.itemsize
- en: the size in bytes of each element of the array. For example, an array of elements
    of type `float64` has `itemsize` 8 (=64/8), while one of type `complex32` has
    `itemsize` 4 (=32/8). It is equivalent to `ndarray.dtype.itemsize`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中每个元素的字节大小。例如，一个`float64`类型的元素数组的`itemsize`是8（=64/8），而一个`complex32`类型的元素数组的`itemsize`是4（=32/8）。它等同于`ndarray.dtype.itemsize`。
- en: ndarray.data
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.data
- en: the buffer containing the actual elements of the array. Normally, we won’t need
    to use this attribute because we will access the elements in an array using indexing
    facilities.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 包含数组实际元素的缓冲区。通常，我们不需要使用这个属性，因为我们将使用索引设施来访问数组中的元素。
- en: An example
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '### Array Creation'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '### 数组创建'
- en: There are several ways to create arrays.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种创建数组的方式。
- en: For example, you can create an array from a regular Python list or tuple using
    the `array` function. The type of the resulting array is deduced from the type
    of the elements in the sequences.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用`array`函数从常规Python列表或元组创建数组。结果数组的类型是从序列中的元素的类型推断出来的。
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A frequent error consists in calling `array` with multiple arguments, rather
    than providing a single sequence as an argument.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 经常出错的一个错误是调用`array`时提供多个参数，而不是提供单个序列作为参数。
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`array` transforms sequences of sequences into two-dimensional arrays, sequences
    of sequences of sequences into three-dimensional arrays, and so on.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`array`将序列的序列转换为二维数组，序列的序列的序列转换为三维数组，依此类推。'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The type of the array can also be explicitly specified at creation time:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的类型也可以在创建时明确指定：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Often, the elements of an array are originally unknown, but its size is known.
    Hence, NumPy offers several functions to create arrays with initial placeholder
    content. These minimize the necessity of growing arrays, an expensive operation.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数组的元素最初是未知的，但其大小已知。因此，NumPy提供了几个函数来创建带有初始占位内容的数组。这些函数最小化了增长数组的必要性，这是一项昂贵的操作。
- en: The function `zeros` creates an array full of zeros, the function `ones` creates
    an array full of ones, and the function `empty` creates an array whose initial
    content is random and depends on the state of the memory. By default, the dtype
    of the created array is `float64`, but it can be specified via the key word argument
    `dtype`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`zeros`创建一个全是零的数组，函数`ones`创建一个全是一的数组，函数`empty`创建一个初始内容是随机的依赖于内存状态的数组。默认情况下，创建的数组的dtype是`float64`，但可以通过关键字参数`dtype`指定。
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To create sequences of numbers, NumPy provides the `arange` function which is
    analogous to the Python built-in `range`, but returns an array.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数字序列，NumPy提供了`arange`函数，它类似于Python内置的`range`，但返回一个数组。
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When `arange` is used with floating point arguments, it is generally not possible
    to predict the number of elements obtained, due to the finite floating point precision.
    For this reason, it is usually better to use the function `linspace` that receives
    as an argument the number of elements that we want, instead of the step:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当`arange`与浮点参数一起使用时，由于有限的浮点精度，通常无法预测所得元素的数量。因此，通常最好使用函数`linspace`，该函数接受我们想要的元素数量作为参数，而不是步长：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See also
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`array`](../reference/generated/numpy.array.html#numpy.array "numpy.array"),
    [`zeros`](../reference/generated/numpy.zeros.html#numpy.zeros "numpy.zeros"),
    [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like "numpy.zeros_like"),
    [`ones`](../reference/generated/numpy.ones.html#numpy.ones "numpy.ones"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like"), [`empty`](../reference/generated/numpy.empty.html#numpy.empty
    "numpy.empty"), [`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`arange`](../reference/generated/numpy.arange.html#numpy.arange
    "numpy.arange"), [`linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), *numpy.random.Generator.rand*, *numpy.random.Generator.randn*,
    [`fromfunction`](../reference/generated/numpy.fromfunction.html#numpy.fromfunction
    "numpy.fromfunction"), [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile")'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[`array`](../reference/generated/numpy.array.html#numpy.array "numpy.array"),
    [`zeros`](../reference/generated/numpy.zeros.html#numpy.zeros "numpy.zeros"),
    [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like "numpy.zeros_like"),
    [`ones`](../reference/generated/numpy.ones.html#numpy.ones "numpy.ones"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like"), [`empty`](../reference/generated/numpy.empty.html#numpy.empty
    "numpy.empty"), [`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`arange`](../reference/generated/numpy.arange.html#numpy.arange
    "numpy.arange"), [`linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), *numpy.random.Generator.rand*, *numpy.random.Generator.randn*,
    [`fromfunction`](../reference/generated/numpy.fromfunction.html#numpy.fromfunction
    "numpy.fromfunction"), [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile")'
- en: Printing Arrays
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印数组
- en: 'When you print an array, NumPy displays it in a similar way to nested lists,
    but with the following layout:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打印一个数组时，NumPy以类似嵌套列表的方式显示它，但布局如下：
- en: the last axis is printed from left to right,
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个轴从左到右打印，
- en: the second-to-last is printed from top to bottom,
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倒数第二个从上到下打印，
- en: the rest are also printed from top to bottom, with each slice separated from
    the next by an empty line.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余部分也是从上到下打印的，每个切片之间用空行分隔。
- en: One-dimensional arrays are then printed as rows, bidimensionals as matrices
    and tridimensionals as lists of matrices.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组被打印为行，二维数组被打印为矩阵，三维数组被打印为矩阵的列表。
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See [below](#quickstart-shape-manipulation) to get more details on `reshape`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[下文](#quickstart-shape-manipulation)以了解`reshape`的更多详细信息。
- en: 'If an array is too large to be printed, NumPy automatically skips the central
    part of the array and only prints the corners:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组太大无法打印，NumPy将自动跳过数组的中间部分，并只打印角落：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To disable this behaviour and force NumPy to print the entire array, you can
    change the printing options using `set_printoptions`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用这种行为，并强制NumPy打印整个数组，你可以使用`set_printoptions`来更改打印选项。
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '### Basic Operations'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '### 基本操作'
- en: Arithmetic operators on arrays apply *elementwise*. A new array is created and
    filled with the result.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 数组上的算术运算符是*逐元素*应用的。创建一个新数组，并用结果填充。
- en: '[PRE12]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Unlike in many matrix languages, the product operator `*` operates elementwise
    in NumPy arrays. The matrix product can be performed using the `@` operator (in
    python >=3.5) or the `dot` function or method:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多矩阵语言不同，在NumPy数组中，乘法运算符`*`是逐元素操作的。矩阵乘积可以使用`@`运算符（在Python >=3.5中）或`dot`函数或方法来执行：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Some operations, such as `+=` and `*=`, act in place to modify an existing array
    rather than create a new one.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作，比如`+=`和`*=`，是就地修改现有数组而不是创建新数组。
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When operating with arrays of different types, the type of the resulting array
    corresponds to the more general or precise one (a behavior known as upcasting).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当对不同类型的数组进行操作时，结果数组的类型对应于更一般或更精确的类型（这种行为称为向上转型）。
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Many unary operations, such as computing the sum of all the elements in the
    array, are implemented as methods of the `ndarray` class.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 许多一元操作，如计算数组中所有元素的和，都作为`ndarray`类的方法实现。
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By default, these operations apply to the array as though it were a list of
    numbers, regardless of its shape. However, by specifying the `axis` parameter
    you can apply an operation along the specified axis of an array:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些操作将应用于数组，就像它是数字的列表一样，而不考虑其形状。然而，通过指定`axis`参数，你可以沿着指定的轴对数组应用操作：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Universal Functions
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用函数
- en: NumPy provides familiar mathematical functions such as sin, cos, and exp. In
    NumPy, these are called “universal functions” (`ufunc`). Within NumPy, these functions
    operate elementwise on an array, producing an array as output.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了熟悉的数学函数，如sin，cos和exp。在NumPy中，这些被称为“通用函数”（`ufunc`）。在NumPy中，这些函数对数组进行逐元素操作，产生一个数组作为输出。
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见下文
- en: '[`all`](../reference/generated/numpy.all.html#numpy.all "numpy.all"), [`any`](../reference/generated/numpy.any.html#numpy.any
    "numpy.any"), [`apply_along_axis`](../reference/generated/numpy.apply_along_axis.html#numpy.apply_along_axis
    "numpy.apply_along_axis"), [`argmax`](../reference/generated/numpy.argmax.html#numpy.argmax
    "numpy.argmax"), [`argmin`](../reference/generated/numpy.argmin.html#numpy.argmin
    "numpy.argmin"), [`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort
    "numpy.argsort"), [`average`](../reference/generated/numpy.average.html#numpy.average
    "numpy.average"), [`bincount`](../reference/generated/numpy.bincount.html#numpy.bincount
    "numpy.bincount"), [`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil
    "numpy.ceil"), [`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip"),
    [`conj`](../reference/generated/numpy.conj.html#numpy.conj "numpy.conj"), [`corrcoef`](../reference/generated/numpy.corrcoef.html#numpy.corrcoef
    "numpy.corrcoef"), [`cov`](../reference/generated/numpy.cov.html#numpy.cov "numpy.cov"),
    [`cross`](../reference/generated/numpy.cross.html#numpy.cross "numpy.cross"),
    [`cumprod`](../reference/generated/numpy.cumprod.html#numpy.cumprod "numpy.cumprod"),
    [`cumsum`](../reference/generated/numpy.cumsum.html#numpy.cumsum "numpy.cumsum"),
    [`diff`](../reference/generated/numpy.diff.html#numpy.diff "numpy.diff"), [`dot`](../reference/generated/numpy.dot.html#numpy.dot
    "numpy.dot"), [`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor"),
    [`inner`](../reference/generated/numpy.inner.html#numpy.inner "numpy.inner"),
    [`invert`](../reference/generated/numpy.invert.html#numpy.invert "numpy.invert"),
    [`lexsort`](../reference/generated/numpy.lexsort.html#numpy.lexsort "numpy.lexsort"),
    [`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max"), [`maximum`](../reference/generated/numpy.maximum.html#numpy.maximum
    "numpy.maximum"), [`mean`](../reference/generated/numpy.mean.html#numpy.mean "numpy.mean"),
    [`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median"),
    [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min"), [`minimum`](../reference/generated/numpy.minimum.html#numpy.minimum
    "numpy.minimum"), [`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero"), [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`re`](https://docs.python.org/3/library/re.html#module-re "(in Python v3.11)"),
    [`round`](../reference/generated/numpy.round.html#numpy.round "numpy.round"),
    [`sort`](../reference/generated/numpy.sort.html#numpy.sort "numpy.sort"), [`std`](../reference/generated/numpy.std.html#numpy.std
    "numpy.std"), [`sum`](../reference/generated/numpy.sum.html#numpy.sum "numpy.sum"),
    [`trace`](../reference/generated/numpy.trace.html#numpy.trace "numpy.trace"),
    [`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose "numpy.transpose"),
    [`var`](../reference/generated/numpy.var.html#numpy.var "numpy.var"), [`vdot`](../reference/generated/numpy.vdot.html#numpy.vdot
    "numpy.vdot"), [`vectorize`](../reference/generated/numpy.vectorize.html#numpy.vectorize
    "numpy.vectorize"), [`where`](../reference/generated/numpy.where.html#numpy.where
    "numpy.where")'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[`all`](../reference/generated/numpy.all.html#numpy.all "numpy.all")，[`any`](../reference/generated/numpy.any.html#numpy.any
    "numpy.any")，[`apply_along_axis`](../reference/generated/numpy.apply_along_axis.html#numpy.apply_along_axis
    "numpy.apply_along_axis")，[`argmax`](../reference/generated/numpy.argmax.html#numpy.argmax
    "numpy.argmax")，[`argmin`](../reference/generated/numpy.argmin.html#numpy.argmin
    "numpy.argmin")，[`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort
    "numpy.argsort")，[`average`](../reference/generated/numpy.average.html#numpy.average
    "numpy.average")，[`bincount`](../reference/generated/numpy.bincount.html#numpy.bincount
    "numpy.bincount")，[`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil "numpy.ceil")，[`clip`](../reference/generated/numpy.clip.html#numpy.clip
    "numpy.clip")，[`conj`](../reference/generated/numpy.conj.html#numpy.conj "numpy.conj")，[`corrcoef`](../reference/generated/numpy.corrcoef.html#numpy.corrcoef
    "numpy.corrcoef")，[`cov`](../reference/generated/numpy.cov.html#numpy.cov "numpy.cov")，[`cross`](../reference/generated/numpy.cross.html#numpy.cross
    "numpy.cross")，[`cumprod`](../reference/generated/numpy.cumprod.html#numpy.cumprod
    "numpy.cumprod")，[`cumsum`](../reference/generated/numpy.cumsum.html#numpy.cumsum
    "numpy.cumsum")，[`diff`](../reference/generated/numpy.diff.html#numpy.diff "numpy.diff")，[`dot`](../reference/generated/numpy.dot.html#numpy.dot
    "numpy.dot")，[`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor")，[`inner`](../reference/generated/numpy.inner.html#numpy.inner
    "numpy.inner")，[`invert`](../reference/generated/numpy.invert.html#numpy.invert
    "numpy.invert")，[`lexsort`](../reference/generated/numpy.lexsort.html#numpy.lexsort
    "numpy.lexsort")，[`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max")，[`maximum`](../reference/generated/numpy.maximum.html#numpy.maximum
    "numpy.maximum")，[`mean`](../reference/generated/numpy.mean.html#numpy.mean "numpy.mean")，[`median`](../reference/generated/numpy.median.html#numpy.median
    "numpy.median")，[`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min")，[`minimum`](../reference/generated/numpy.minimum.html#numpy.minimum
    "numpy.minimum")，[`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero")，[`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer")，[`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod")，[`re`](https://docs.python.org/3/library/re.html#module-re
    "(in Python v3.11)")，[`round`](../reference/generated/numpy.round.html#numpy.round
    "numpy.round")，[`sort`](../reference/generated/numpy.sort.html#numpy.sort "numpy.sort")，[`std`](../reference/generated/numpy.std.html#numpy.std
    "numpy.std")，[`sum`](../reference/generated/numpy.sum.html#numpy.sum "numpy.sum")，[`trace`](../reference/generated/numpy.trace.html#numpy.trace
    "numpy.trace")，[`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose
    "numpy.transpose")，[`var`](../reference/generated/numpy.var.html#numpy.var "numpy.var")，[`vdot`](../reference/generated/numpy.vdot.html#numpy.vdot
    "numpy.vdot")，[`vectorize`](../reference/generated/numpy.vectorize.html#numpy.vectorize
    "numpy.vectorize")，[`where`](../reference/generated/numpy.where.html#numpy.where
    "numpy.where")'
- en: '### Indexing, Slicing and Iterating'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '### 索引、切片和迭代'
- en: '**One-dimensional** arrays can be indexed, sliced and iterated over, much like
    [lists](https://docs.python.org/tutorial/introduction.html#lists) and other Python
    sequences.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**一维**数组可以像[列表](https://docs.python.org/tutorial/introduction.html#lists)和其他Python序列一样进行索引、切片和迭代。'
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '**Multidimensional** arrays can have one index per axis. These indices are
    given in a tuple separated by commas:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**多维**数组可以有每个轴的一个索引。这些索引以逗号分隔的元组给出：'
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When fewer indices are provided than the number of axes, the missing indices
    are considered complete slices`:`
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供的索引少于轴的数量，则缺失的索引被视为完整的切片`:`：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The expression within brackets in `b[i]` is treated as an `i` followed by as
    many instances of `:` as needed to represent the remaining axes. NumPy also allows
    you to write this using dots as `b[i, ...]`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号中的表达式`b[i]`被视为一个`i`，后面跟着需要表示剩余轴的冒号实例。NumPy还允许您使用点表示法`b[i, ...]`来编写它。
- en: The **dots** (`...`) represent as many colons as needed to produce a complete
    indexing tuple. For example, if `x` is an array with 5 axes, then
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**点**（`...`）表示需要生成完整索引元组的多少个冒号。例如，如果`x`是一个具有5个轴的数组，则'
- en: '`x[1, 2, ...]` is equivalent to `x[1, 2, :, :, :]`,'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x[1, 2, ...]` 相当于 `x[1, 2, :, :, :]`，'
- en: '`x[..., 3]` to `x[:, :, :, :, 3]` and'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x[..., 3]` 相当于 `x[:, :, :, :, 3]` 和'
- en: '`x[4, ..., 5, :]` to `x[4, :, :, 5, :]`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x[4, ..., 5, :]` 相当于 `x[4, :, :, 5, :]`。'
- en: '[PRE22]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Iterating** over multidimensional arrays is done with respect to the first
    axis:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对多维数组进行迭代是针对第一个轴进行的：
- en: '[PRE23]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, if one wants to perform an operation on each element in the array,
    one can use the `flat` attribute which is an [iterator](https://docs.python.org/tutorial/classes.html#iterators)
    over all the elements of the array:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果想对数组中的每个元素执行操作，可以使用`flat`属性，该属性是对数组的所有元素的[迭代器](https://docs.python.org/tutorial/classes.html#iterators)：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Indexing on ndarrays](basics.indexing.html#basics-indexing), [Indexing routines](../reference/arrays.indexing.html#arrays-indexing)
    (reference), [`newaxis`](../reference/constants.html#numpy.newaxis "numpy.newaxis"),
    [`ndenumerate`](../reference/generated/numpy.ndenumerate.html#numpy.ndenumerate
    "numpy.ndenumerate"), [`indices`](../reference/generated/numpy.indices.html#numpy.indices
    "numpy.indices")  ## Shape Manipulation'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[ndarrays的索引](basics.indexing.html#basics-indexing)、[索引例程](../reference/arrays.indexing.html#arrays-indexing)（参考）、[`newaxis`](../reference/constants.html#numpy.newaxis
    "numpy.newaxis")、[`ndenumerate`](../reference/generated/numpy.ndenumerate.html#numpy.ndenumerate
    "numpy.ndenumerate")、[`indices`](../reference/generated/numpy.indices.html#numpy.indices
    "numpy.indices")  ## 形状操作'
- en: Changing the shape of an array
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变数组的形状
- en: 'An array has a shape given by the number of elements along each axis:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的形状由沿每个轴的元素数量确定：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The shape of an array can be changed with various commands. Note that the following
    three commands all return a modified array, but do not change the original array:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的形状可以用各种命令进行更改。请注意，以下三个命令都会返回一个修改后的数组，但不会更改原始数组：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The order of the elements in the array resulting from `ravel` is normally “C-style”,
    that is, the rightmost index “changes the fastest”, so the element after `a[0,
    0]` is `a[0, 1]`. If the array is reshaped to some other shape, again the array
    is treated as “C-style”. NumPy normally creates arrays stored in this order, so
    `ravel` will usually not need to copy its argument, but if the array was made
    by taking slices of another array or created with unusual options, it may need
    to be copied. The functions `ravel` and `reshape` can also be instructed, using
    an optional argument, to use FORTRAN-style arrays, in which the leftmost index
    changes the fastest.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`ravel`结果数组中的元素顺序通常是“C风格”，即，最右边的索引“变化最快”，因此`a[0, 0]`之后的元素是`a[0, 1]`。如果数组被重塑为其他形状，那么数组再次被视为“C风格”。NumPy通常创建以这种顺序存储的数组，因此`ravel`通常不需要复制其参数，但如果数组是通过对另一个数组取片或使用不寻常的选项创建的，则可能需要复制。函数`ravel`和`reshape`还可以使用可选参数指示使用FORTRAN风格的数组，其中最左边的索引变化最快。'
- en: 'The [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape "numpy.reshape")
    function returns its argument with a modified shape, whereas the [`ndarray.resize`](../reference/generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") method modifies the array itself:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape "numpy.reshape")函数返回其具有修改形状的参数，而[`ndarray.resize`](../reference/generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize")方法修改数组本身：'
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If a dimension is given as `-1` in a reshaping operation, the other dimensions
    are automatically calculated:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在重塑操作中给定维度为`-1`，则其他维度将自动计算：
- en: '[PRE28]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See also
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`ndarray.shape`](../reference/generated/numpy.ndarray.shape.html#numpy.ndarray.shape
    "numpy.ndarray.shape"), [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape
    "numpy.reshape"), [`resize`](../reference/generated/numpy.resize.html#numpy.resize
    "numpy.resize"), [`ravel`](../reference/generated/numpy.ravel.html#numpy.ravel
    "numpy.ravel")'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ndarray.shape`](../reference/generated/numpy.ndarray.shape.html#numpy.ndarray.shape
    "numpy.ndarray.shape"), [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape
    "numpy.reshape"), [`resize`](../reference/generated/numpy.resize.html#numpy.resize
    "numpy.resize"), [`ravel`](../reference/generated/numpy.ravel.html#numpy.ravel
    "numpy.ravel")'
- en: '### Stacking together different arrays'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将不同数组堆叠在一起'
- en: 'Several arrays can be stacked together along different axes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以沿不同轴堆叠几个数组：
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The function [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack") stacks 1D arrays as columns into a 2D array. It is equivalent
    to [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack "numpy.hstack")
    only for 2D arrays:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '函数 [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack") 将 1D 数组作为列堆叠到 2D 数组中。它仅对于 2D 数组等效于 [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack"):'
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'On the other hand, the function [`row_stack`](../reference/generated/numpy.row_stack.html#numpy.row_stack
    "numpy.row_stack") is equivalent to [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") for any input arrays. In fact, [`row_stack`](../reference/generated/numpy.row_stack.html#numpy.row_stack
    "numpy.row_stack") is an alias for [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack"):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，函数 [`row_stack`](../reference/generated/numpy.row_stack.html#numpy.row_stack
    "numpy.row_stack") 对于任何输入数组都相当于 [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack")。事实上，[`row_stack`](../reference/generated/numpy.row_stack.html#numpy.row_stack
    "numpy.row_stack") 是 [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") 的别名：
- en: '[PRE31]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In general, for arrays with more than two dimensions, [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack") stacks along their second axes, [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") stacks along their first axes, and [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate") allows for an optional arguments giving the number of the
    axis along which the concatenation should happen.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，对于超过两个维度的数组，[`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack") 沿第二个轴堆叠，[`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") 沿第一个轴堆叠，而 [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate") 允许一个可选参数，用于指定连接应该发生的轴的编号。
- en: '**Note**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意**'
- en: In complex cases, [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_")
    and [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_") are useful
    for creating arrays by stacking numbers along one axis. They allow the use of
    range literals `:`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂情况下，[`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_") 和 [`c_`](../reference/generated/numpy.c_.html#numpy.c_
    "numpy.c_") 对于通过在一个轴上堆叠数字创建数组非常有用。它们允许使用范围文字 `:`。
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When used with arrays as arguments, [`r_`](../reference/generated/numpy.r_.html#numpy.r_
    "numpy.r_") and [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_")
    are similar to [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") and [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack") in their default behavior, but allow for an optional argument
    giving the number of the axis along which to concatenate.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当用数组作为参数时，[`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_") 和
    [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_") 在默认行为上类似于 [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") 和 [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack")，但允许一个可选参数，用于指定沿哪个轴进行连接。
- en: See also
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack "numpy.hstack"),
    [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack "numpy.vstack"),
    [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack"), [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate"), [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_")'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack "numpy.hstack"),
    [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack "numpy.vstack"),
    [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack"), [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate"), [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_")'
- en: Splitting one array into several smaller ones
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将一个数组拆分为几个较小的数组
- en: 'Using [`hsplit`](../reference/generated/numpy.hsplit.html#numpy.hsplit "numpy.hsplit"),
    you can split an array along its horizontal axis, either by specifying the number
    of equally shaped arrays to return, or by specifying the columns after which the
    division should occur:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`hsplit`](../reference/generated/numpy.hsplit.html#numpy.hsplit "numpy.hsplit")，您可以沿着数组的水平轴分割数组，可以通过指定要返回的等形数组的数量，也可以通过指定在哪些列之后进行分割：
- en: '[PRE33]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[`vsplit`](../reference/generated/numpy.vsplit.html#numpy.vsplit "numpy.vsplit")
    splits along the vertical axis, and [`array_split`](../reference/generated/numpy.array_split.html#numpy.array_split
    "numpy.array_split") allows one to specify along which axis to split.  ## Copies
    and Views'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[`vsplit`](../reference/generated/numpy.vsplit.html#numpy.vsplit "numpy.vsplit")
    沿垂直轴拆分，而 [`array_split`](../reference/generated/numpy.array_split.html#numpy.array_split
    "numpy.array_split") 允许指定沿哪个轴进行拆分。## 复制和视图'
- en: 'When operating and manipulating arrays, their data is sometimes copied into
    a new array and sometimes not. This is often a source of confusion for beginners.
    There are three cases:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作和操作数组时，有时会将它们的数据复制到新数组中，有时则不会。这常常会让初学者感到困惑。有三种情况：
- en: No Copy at All
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 没有任何复制
- en: Simple assignments make no copy of objects or their data.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的赋值不会复制对象或其数据。
- en: '[PRE34]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Python passes mutable objects as references, so function calls make no copy.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Python 以引用的方式传递可变对象，因此函数调用不会复制。
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: View or Shallow Copy
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看或浅拷贝
- en: Different array objects can share the same data. The `view` method creates a
    new array object that looks at the same data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的数组对象可以共享相同的数据。`view` 方法创建一个查看相同数据的新数组对象。
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Slicing an array returns a view of it:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对数组进行切片会返回它的视图：
- en: '[PRE37]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Deep Copy
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 深复制
- en: The `copy` method makes a complete copy of the array and its data.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`copy` 方法将数组及其数据完全复制一份。'
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Sometimes `copy` should be called after slicing if the original array is not
    required anymore. For example, suppose `a` is a huge intermediate result and the
    final result `b` only contains a small fraction of `a`, a deep copy should be
    made when constructing `b` with slicing:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有时在切片之后如果不再需要原始数组，则应调用 `copy`。例如，假设 `a` 是一个巨大的中间结果，而最终结果 `b` 只包含 `a` 的一小部分，则在使用切片构造
    `b` 时应进行深复制：
- en: '[PRE39]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If `b = a[:100]` is used instead, `a` is referenced by `b` and will persist
    in memory even if `del a` is executed.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用`b = a[:100]`，则`a`由`b`引用，并且即使执行`del a`，`a`也会在内存中持续存在。
- en: Functions and Methods Overview
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数和方法概述
- en: Here is a list of some useful NumPy functions and methods names ordered in categories.
    See [Routines](../reference/routines.html#routines) for the full list.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一些有用的 NumPy 函数和方法名称的列表，按类别排序。请参阅 [例程](../reference/routines.html#routines)
    获取完整列表。
- en: Array Creation
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 数组创建
- en: '[`arange`](../reference/generated/numpy.arange.html#numpy.arange "numpy.arange"),
    [`array`](../reference/generated/numpy.array.html#numpy.array "numpy.array"),
    [`copy`](../reference/generated/numpy.copy.html#numpy.copy "numpy.copy"), [`empty`](../reference/generated/numpy.empty.html#numpy.empty
    "numpy.empty"), [`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`eye`](../reference/generated/numpy.eye.html#numpy.eye "numpy.eye"),
    [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile"),
    [`fromfunction`](../reference/generated/numpy.fromfunction.html#numpy.fromfunction
    "numpy.fromfunction"), [`identity`](../reference/generated/numpy.identity.html#numpy.identity
    "numpy.identity"), [`linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), [`logspace`](../reference/generated/numpy.logspace.html#numpy.logspace
    "numpy.logspace"), [`mgrid`](../reference/generated/numpy.mgrid.html#numpy.mgrid
    "numpy.mgrid"), [`ogrid`](../reference/generated/numpy.ogrid.html#numpy.ogrid
    "numpy.ogrid"), [`ones`](../reference/generated/numpy.ones.html#numpy.ones "numpy.ones"),
    [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like "numpy.ones_like"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_"), [`zeros`](../reference/generated/numpy.zeros.html#numpy.zeros
    "numpy.zeros"), [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like")'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[`arange`](../reference/generated/numpy.arange.html#numpy.arange "numpy.arange"),
    [`array`](../reference/generated/numpy.array.html#numpy.array "numpy.array"),
    [`copy`](../reference/generated/numpy.copy.html#numpy.copy "numpy.copy"), [`empty`](../reference/generated/numpy.empty.html#numpy.empty
    "numpy.empty"), [`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`eye`](../reference/generated/numpy.eye.html#numpy.eye "numpy.eye"),
    [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile"),
    [`fromfunction`](../reference/generated/numpy.fromfunction.html#numpy.fromfunction
    "numpy.fromfunction"), [`identity`](../reference/generated/numpy.identity.html#numpy.identity
    "numpy.identity"), [`linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), [`logspace`](../reference/generated/numpy.logspace.html#numpy.logspace
    "numpy.logspace"), [`mgrid`](../reference/generated/numpy.mgrid.html#numpy.mgrid
    "numpy.mgrid"), [`ogrid`](../reference/generated/numpy.ogrid.html#numpy.ogrid
    "numpy.ogrid"), [`ones`](../reference/generated/numpy.ones.html#numpy.ones "numpy.ones"),
    [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like "numpy.ones_like"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_"), [`zeros`](../reference/generated/numpy.zeros.html#numpy.zeros
    "numpy.zeros"), [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like")'
- en: Conversions
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 转换
- en: '[`ndarray.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype"), [`atleast_1d`](../reference/generated/numpy.atleast_1d.html#numpy.atleast_1d
    "numpy.atleast_1d"), [`atleast_2d`](../reference/generated/numpy.atleast_2d.html#numpy.atleast_2d
    "numpy.atleast_2d"), [`atleast_3d`](../reference/generated/numpy.atleast_3d.html#numpy.atleast_3d
    "numpy.atleast_3d"), [`mat`](../reference/generated/numpy.mat.html#numpy.mat "numpy.mat")'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ndarray.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype"), [`atleast_1d`](../reference/generated/numpy.atleast_1d.html#numpy.atleast_1d
    "numpy.atleast_1d"), [`atleast_2d`](../reference/generated/numpy.atleast_2d.html#numpy.atleast_2d
    "numpy.atleast_2d"), [`atleast_3d`](../reference/generated/numpy.atleast_3d.html#numpy.atleast_3d
    "numpy.atleast_3d"), [`mat`](../reference/generated/numpy.mat.html#numpy.mat "numpy.mat")'
- en: Manipulations
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 操作
- en: '[`array_split`](../reference/generated/numpy.array_split.html#numpy.array_split
    "numpy.array_split"), [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack"), [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate"), [`diagonal`](../reference/generated/numpy.diagonal.html#numpy.diagonal
    "numpy.diagonal"), [`dsplit`](../reference/generated/numpy.dsplit.html#numpy.dsplit
    "numpy.dsplit"), [`dstack`](../reference/generated/numpy.dstack.html#numpy.dstack
    "numpy.dstack"), [`hsplit`](../reference/generated/numpy.hsplit.html#numpy.hsplit
    "numpy.hsplit"), [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack"), [`ndarray.item`](../reference/generated/numpy.ndarray.item.html#numpy.ndarray.item
    "numpy.ndarray.item"), [`newaxis`](../reference/constants.html#numpy.newaxis "numpy.newaxis"),
    [`ravel`](../reference/generated/numpy.ravel.html#numpy.ravel "numpy.ravel"),
    [`repeat`](../reference/generated/numpy.repeat.html#numpy.repeat "numpy.repeat"),
    [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape "numpy.reshape"),
    [`resize`](../reference/generated/numpy.resize.html#numpy.resize "numpy.resize"),
    [`squeeze`](../reference/generated/numpy.squeeze.html#numpy.squeeze "numpy.squeeze"),
    [`swapaxes`](../reference/generated/numpy.swapaxes.html#numpy.swapaxes "numpy.swapaxes"),
    [`take`](../reference/generated/numpy.take.html#numpy.take "numpy.take"), [`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose
    "numpy.transpose"), [`vsplit`](../reference/generated/numpy.vsplit.html#numpy.vsplit
    "numpy.vsplit"), [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack")'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[`array_split`](../reference/generated/numpy.array_split.html#numpy.array_split
    "numpy.array_split"), [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack"), [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate"), [`diagonal`](../reference/generated/numpy.diagonal.html#numpy.diagonal
    "numpy.diagonal"), [`dsplit`](../reference/generated/numpy.dsplit.html#numpy.dsplit
    "numpy.dsplit"), [`dstack`](../reference/generated/numpy.dstack.html#numpy.dstack
    "numpy.dstack"), [`hsplit`](../reference/generated/numpy.hsplit.html#numpy.hsplit
    "numpy.hsplit"), [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack"), [`ndarray.item`](../reference/generated/numpy.ndarray.item.html#numpy.ndarray.item
    "numpy.ndarray.item"), [`newaxis`](../reference/constants.html#numpy.newaxis "numpy.newaxis"),
    [`ravel`](../reference/generated/numpy.ravel.html#numpy.ravel "numpy.ravel"),
    [`repeat`](../reference/generated/numpy.repeat.html#numpy.repeat "numpy.repeat"),
    [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape "numpy.reshape"),
    [`resize`](../reference/generated/numpy.resize.html#numpy.resize "numpy.resize"),
    [`squeeze`](../reference/generated/numpy.squeeze.html#numpy.squeeze "numpy.squeeze"),
    [`swapaxes`](../reference/generated/numpy.swapaxes.html#numpy.swapaxes "numpy.swapaxes"),
    [`take`](../reference/generated/numpy.take.html#numpy.take "numpy.take"), [`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose
    "numpy.transpose"), [`vsplit`](../reference/generated/numpy.vsplit.html#numpy.vsplit
    "numpy.vsplit"), [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack")'
- en: Questions
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 问题
- en: '[`all`](../reference/generated/numpy.all.html#numpy.all "numpy.all"), [`any`](../reference/generated/numpy.any.html#numpy.any
    "numpy.any"), [`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero"), [`where`](../reference/generated/numpy.where.html#numpy.where
    "numpy.where")'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[`all`](../reference/generated/numpy.all.html#numpy.all "numpy.all"), [`any`](../reference/generated/numpy.any.html#numpy.any
    "numpy.any"), [`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero"), [`where`](../reference/generated/numpy.where.html#numpy.where
    "numpy.where")'
- en: Ordering
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 排序
- en: '[`argmax`](../reference/generated/numpy.argmax.html#numpy.argmax "numpy.argmax"),
    [`argmin`](../reference/generated/numpy.argmin.html#numpy.argmin "numpy.argmin"),
    [`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort "numpy.argsort"),
    [`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max"), [`min`](../reference/generated/numpy.min.html#numpy.min
    "numpy.min"), [`ptp`](../reference/generated/numpy.ptp.html#numpy.ptp "numpy.ptp"),
    [`searchsorted`](../reference/generated/numpy.searchsorted.html#numpy.searchsorted
    "numpy.searchsorted"), [`sort`](../reference/generated/numpy.sort.html#numpy.sort
    "numpy.sort")'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[`argmax`](../reference/generated/numpy.argmax.html#numpy.argmax "numpy.argmax"),
    [`argmin`](../reference/generated/numpy.argmin.html#numpy.argmin "numpy.argmin"),
    [`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort "numpy.argsort"),
    [`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max"), [`min`](../reference/generated/numpy.min.html#numpy.min
    "numpy.min"), [`ptp`](../reference/generated/numpy.ptp.html#numpy.ptp "numpy.ptp"),
    [`searchsorted`](../reference/generated/numpy.searchsorted.html#numpy.searchsorted
    "numpy.searchsorted"), [`sort`](../reference/generated/numpy.sort.html#numpy.sort
    "numpy.sort")'
- en: Operations
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 操作
- en: '[`choose`](../reference/generated/numpy.choose.html#numpy.choose "numpy.choose"),
    [`compress`](../reference/generated/numpy.compress.html#numpy.compress "numpy.compress"),
    [`cumprod`](../reference/generated/numpy.cumprod.html#numpy.cumprod "numpy.cumprod"),
    [`cumsum`](../reference/generated/numpy.cumsum.html#numpy.cumsum "numpy.cumsum"),
    [`inner`](../reference/generated/numpy.inner.html#numpy.inner "numpy.inner"),
    [`ndarray.fill`](../reference/generated/numpy.ndarray.fill.html#numpy.ndarray.fill
    "numpy.ndarray.fill"), [`imag`](../reference/generated/numpy.imag.html#numpy.imag
    "numpy.imag"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put"), [`putmask`](../reference/generated/numpy.putmask.html#numpy.putmask
    "numpy.putmask"), [`real`](../reference/generated/numpy.real.html#numpy.real "numpy.real"),
    [`sum`](../reference/generated/numpy.sum.html#numpy.sum "numpy.sum")'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[`choose`](../reference/generated/numpy.choose.html#numpy.choose "numpy.choose"),
    [`compress`](../reference/generated/numpy.compress.html#numpy.compress "numpy.compress"),
    [`cumprod`](../reference/generated/numpy.cumprod.html#numpy.cumprod "numpy.cumprod"),
    [`cumsum`](../reference/generated/numpy.cumsum.html#numpy.cumsum "numpy.cumsum"),
    [`inner`](../reference/generated/numpy.inner.html#numpy.inner "numpy.inner"),
    [`ndarray.fill`](../reference/generated/numpy.ndarray.fill.html#numpy.ndarray.fill
    "numpy.ndarray.fill"), [`imag`](../reference/generated/numpy.imag.html#numpy.imag
    "numpy.imag"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put"), [`putmask`](../reference/generated/numpy.putmask.html#numpy.putmask
    "numpy.putmask"), [`real`](../reference/generated/numpy.real.html#numpy.real "numpy.real"),
    [`sum`](../reference/generated/numpy.sum.html#numpy.sum "numpy.sum")'
- en: Basic Statistics
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 基本统计
- en: '[`cov`](../reference/generated/numpy.cov.html#numpy.cov "numpy.cov"), [`mean`](../reference/generated/numpy.mean.html#numpy.mean
    "numpy.mean"), [`std`](../reference/generated/numpy.std.html#numpy.std "numpy.std"),
    [`var`](../reference/generated/numpy.var.html#numpy.var "numpy.var")'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[`cov`](../reference/generated/numpy.cov.html#numpy.cov "numpy.cov"), [`mean`](../reference/generated/numpy.mean.html#numpy.mean
    "numpy.mean"), [`std`](../reference/generated/numpy.std.html#numpy.std "numpy.std"),
    [`var`](../reference/generated/numpy.var.html#numpy.var "numpy.var")'
- en: Basic Linear Algebra
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 基本线性代数
- en: '[`cross`](../reference/generated/numpy.cross.html#numpy.cross "numpy.cross"),
    [`dot`](../reference/generated/numpy.dot.html#numpy.dot "numpy.dot"), [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer"), [`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd"), [`vdot`](../reference/generated/numpy.vdot.html#numpy.vdot
    "numpy.vdot")'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[`cross`](../reference/generated/numpy.cross.html#numpy.cross "numpy.cross"),
    [`dot`](../reference/generated/numpy.dot.html#numpy.dot "numpy.dot"), [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer"), [`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd"), [`vdot`](../reference/generated/numpy.vdot.html#numpy.vdot
    "numpy.vdot")'
- en: Less Basic
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更不基础的
- en: '### Broadcasting rules'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '### 广播规则'
- en: Broadcasting allows universal functions to deal in a meaningful way with inputs
    that do not have exactly the same shape.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 广播允许通用函数以有意义的方式处理形状不完全相同的输入。
- en: The first rule of broadcasting is that if all input arrays do not have the same
    number of dimensions, a “1” will be repeatedly prepended to the shapes of the
    smaller arrays until all the arrays have the same number of dimensions.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 广播的第一规则是，如果所有输入数组的维度数不相同，那么“1”将被重复地前置到较小数组的形状上，直到所有数组具有相同的维度数。
- en: The second rule of broadcasting ensures that arrays with a size of 1 along a
    particular dimension act as if they had the size of the array with the largest
    shape along that dimension. The value of the array element is assumed to be the
    same along that dimension for the “broadcast” array.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 广播的第二规则确保了沿着特定维度大小为1的数组的行为，就好像它们在该维度上的最大形状的数组的大小一样。假定“广播”数组沿着那个维度的数组元素的值是相同的。
- en: After application of the broadcasting rules, the sizes of all arrays must match.
    More details can be found in [Broadcasting](basics.broadcasting.html#basics-broadcasting).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 应用广播规则后，所有数组的大小必须匹配。更多细节可以在[Broadcasting](basics.broadcasting.html#basics-broadcasting)中找到。
- en: Advanced indexing and index tricks
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级索引和索引技巧
- en: NumPy offers more indexing facilities than regular Python sequences. In addition
    to indexing by integers and slices, as we saw before, arrays can be indexed by
    arrays of integers and arrays of booleans.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供比普通Python序列更多的索引工具。除了之前我们所见到的按整数和切片进行索引之外，数组还可以通过整数数组和布尔数组进行索引。
- en: Indexing with Arrays of Indices
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用索引数组进行索引
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When the indexed array `a` is multidimensional, a single array of indices refers
    to the first dimension of `a`. The following example shows this behavior by converting
    an image of labels into a color image using a palette.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当索引数组`a`是多维的时，单个索引数组会引用`a`的第一个维度。以下示例通过使用调色板，将标签图像转换为彩色图像展示了这种行为。
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can also give indexes for more than one dimension. The arrays of indices
    for each dimension must have the same shape.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以为多个维度提供索引。每个维度的索引数组必须具有相同的形状。
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In Python, `arr[i, j]` is exactly the same as `arr[(i, j)]`—so we can put `i`
    and `j` in a `tuple` and then do the indexing with that.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python中，`arr[i, j]`与`arr[(i, j)]`完全相同 - 因此我们可以将`i`和`j`放入一个`tuple`，然后使用该索引。
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: However, we can not do this by putting `i` and `j` into an array, because this
    array will be interpreted as indexing the first dimension of `a`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不能将`i`和`j`放入一个数组中来做到这一点，因为这个数组会被解释为索引`a`的第一个维度。
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Another common use of indexing with arrays is the search of the maximum value
    of time-dependent series:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数组进行索引的另一个常见用途是搜索时序系列的最大值：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also use indexing with arrays as a target to assign to:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用数组作为目标进行编制索引：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'However, when the list of indices contains repetitions, the assignment is done
    several times, leaving behind the last value:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当索引列表包含重复项时，赋值会多次进行，留下最后一个值：
- en: '[PRE47]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This is reasonable enough, but watch out if you want to use Python’s `+=` construct,
    as it may not do what you expect:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是足够合理的，但要注意如果你想使用 Python 的`+=`构造，因为它可能不会如你所期望地运行：
- en: '[PRE48]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Even though 0 occurs twice in the list of indices, the 0th element is only incremented
    once. This is because Python requires `a += 1` to be equivalent to `a = a + 1`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管索引列表中 0 出现了两次，但第 0 个元素只增加了一次。这是因为 Python 要求`a += 1`等价于`a = a + 1`。
- en: Indexing with Boolean Arrays
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用布尔数组进行索引
- en: When we index arrays with arrays of (integer) indices we are providing the list
    of indices to pick. With boolean indices the approach is different; we explicitly
    choose which items in the array we want and which ones we don’t.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用（整数）索引数组对数组进行索引时，我们提供要选择的索引列表。使用布尔索引时，方法不同；我们明确选择数组中的哪些项和哪些项不要。
- en: 'The most natural way one can think of for boolean indexing is to use boolean
    arrays that have *the same shape* as the original array:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于布尔索引，最自然的想法之一是使用与原始数组*相同形状*的布尔数组：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'This property can be very useful in assignments:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在赋值中非常有用：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'You can look at the following example to see how to use boolean indexing to
    generate an image of the [Mandelbrot set](https://en.wikipedia.org/wiki/Mandelbrot_set):'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看下面的例子，看如何使用布尔索引生成[Mandelbrot 集合](https://en.wikipedia.org/wiki/Mandelbrot_set)的图像：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '![../_images/quickstart-1.png](../Images/f14ba9a03da211bbacbafc982923e1f4.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/quickstart-1.png](../Images/f14ba9a03da211bbacbafc982923e1f4.png)'
- en: 'The second way of indexing with booleans is more similar to integer indexing;
    for each dimension of the array we give a 1D boolean array selecting the slices
    we want:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔值进行索引的第二种方式更类似于整数索引；对数组的每个维度，我们提供一个选择我们想要的切片的 1D 布尔数组：
- en: '[PRE52]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that the length of the 1D boolean array must coincide with the length of
    the dimension (or axis) you want to slice. In the previous example, `b1` has length
    3 (the number of *rows* in `a`), and `b2` (of length 4) is suitable to index the
    2nd axis (columns) of `a`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 1D 布尔数组的长度必须与您要切片的维度（或轴）的长度相一致。在前面的例子中，`b1`的长度为 3（`a`中的 *行* 数），而`b2`（长度为4）适合于索引`a`的第
    2 轴（列）。
- en: The ix_() function
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ix_()` 函数'
- en: 'The [`ix_`](../reference/generated/numpy.ix_.html#numpy.ix_ "numpy.ix_") function
    can be used to combine different vectors so as to obtain the result for each n-uplet.
    For example, if you want to compute all the a+b*c for all the triplets taken from
    each of the vectors a, b and c:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ix_`](../reference/generated/numpy.ix_.html#numpy.ix_ "numpy.ix_")函数可用于组合不同的向量，以便为每个
    n-uplet（*n 元组*）的结果。例如，如果想要计算从向量 a、b 和 c 中取出的所有三元组的 a+b*c：'
- en: '[PRE53]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You could also implement the reduce as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以如下实现 reduce：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'and then use it as:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用它：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The advantage of this version of reduce compared to the normal ufunc.reduce
    is that it makes use of the [broadcasting rules](#broadcasting-rules) in order
    to avoid creating an argument array the size of the output times the number of
    vectors.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 与普通的 ufunc.reduce 相比，这个 reduce 版本的优势在于它利用[广播规则](#broadcasting-rules)来避免创建一个大小等于输出乘以向量数量的参数数组。
- en: Indexing with strings
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用字符串进行索引
- en: See [Structured arrays](basics.rec.html#structured-arrays).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[结构化数组](basics.rec.html#structured-arrays)。
- en: Tricks and Tips
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技巧和提示
- en: Here we give a list of short and useful tips.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们列出一些简短且有用的提示。
- en: “Automatic” Reshaping
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “自动”重塑
- en: 'To change the dimensions of an array, you can omit one of the sizes which will
    then be deduced automatically:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变数组的维度，你可以省略其中一个尺寸，这样它将自动推导出来：
- en: '[PRE56]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Vector Stacking
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向量堆叠
- en: 'How do we construct a 2D array from a list of equally-sized row vectors? In
    MATLAB this is quite easy: if `x` and `y` are two vectors of the same length you
    only need do `m=[x;y]`. In NumPy this works via the functions `column_stack`,
    `dstack`, `hstack` and `vstack`, depending on the dimension in which the stacking
    is to be done. For example:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何从一系列等大小的行向量构造一个二维数组？在 MATLAB 中，这相当容易：如果 `x` 和 `y` 是长度相同的两个向量，你只需要 `m=[x;y]`。在
    NumPy 中，这可以通过函数 `column_stack`、`dstack`、`hstack` 和 `vstack` 来实现，具体取决于堆叠的维度。例如：
- en: '[PRE57]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The logic behind those functions in more than two dimensions can be strange.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 那些超过两个维度的函数背后的逻辑可能会有些奇怪。
- en: See also
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 也请参见
- en: '[NumPy for MATLAB users](numpy-for-matlab-users.html)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[NumPy 适用于 MATLAB 用户](numpy-for-matlab-users.html)'
- en: Histograms
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直方图
- en: 'The NumPy `histogram` function applied to an array returns a pair of vectors:
    the histogram of the array and a vector of the bin edges. Beware: `matplotlib`
    also has a function to build histograms (called `hist`, as in Matlab) that differs
    from the one in NumPy. The main difference is that `pylab.hist` plots the histogram
    automatically, while `numpy.histogram` only generates the data.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 应用于数组的 NumPy `histogram` 函数返回一对向量：数组的直方图和一个箱边的向量。注意：`matplotlib` 也有一个构建直方图的函数（称为
    `hist`，类似于 Matlab），它与 NumPy 中的函数不同。主要区别在于 `pylab.hist` 会自动绘制直方图，而 `numpy.histogram`
    只会生成数据。
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '![../_images/quickstart-2.png](../Images/6e8a719f3f733b746d4f0762a37ae4e0.png)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/quickstart-2.png](../Images/6e8a719f3f733b746d4f0762a37ae4e0.png)'
- en: With Matplotlib >=3.4 you can also use `plt.stairs(n, bins)`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Matplotlib >=3.4，你也可以使用 `plt.stairs(n, bins)`。
- en: Further reading
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: The [Python tutorial](https://docs.python.org/tutorial/)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python 教程](https://docs.python.org/tutorial/)'
- en: '[NumPy reference](../reference/index.html#reference)'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[NumPy 参考手册](../reference/index.html#reference)'
- en: '[SciPy Tutorial](https://docs.scipy.org/doc/scipy/tutorial/index.html)'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SciPy 教程](https://docs.scipy.org/doc/scipy/tutorial/index.html)'
- en: '[SciPy Lecture Notes](https://scipy-lectures.org)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SciPy 讲义](https://scipy-lectures.org)'
- en: A [matlab, R, IDL, NumPy/SciPy dictionary](http://mathesaurus.sf.net/)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个[matlab、R、IDL、NumPy/SciPy 字典](http://mathesaurus.sf.net/)
- en: '[tutorial-svd](https://numpy.org/numpy-tutorials/content/tutorial-svd.html
    "(in NumPy tutorials)")'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SVD 教程](https://numpy.org/numpy-tutorials/content/tutorial-svd.html "(在 NumPy
    教程中)")'
- en: Prerequisites
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先决条件
- en: You’ll need to know a bit of Python. For a refresher, see the [Python tutorial](https://docs.python.org/tutorial/).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要了解一些 Python。需要复习的话，请参见[Python 教程](https://docs.python.org/tutorial/)。
- en: To work the examples, you’ll need `matplotlib` installed in addition to NumPy.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行示例，除了 NumPy 外，你还需要安装 `matplotlib`。
- en: '**Learner profile**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习者档案**'
- en: This is a quick overview of arrays in NumPy. It demonstrates how n-dimensional
    (\(n>=2\)) arrays are represented and can be manipulated. In particular, if you
    don’t know how to apply common functions to n-dimensional arrays (without using
    for-loops), or if you want to understand axis and shape properties for n-dimensional
    arrays, this article might be of help.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 NumPy 中数组的快速概述。它演示了如何表示和操作 n 维（\(n>=2\))）数组。特别是，如果你不知道如何将常见函数应用于 n 维数组（不使用
    for 循环），或者如果你想了解 n 维数组的轴和形状属性，这篇文章可能会有所帮助。
- en: '**Learning Objectives**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**学习目标**'
- en: 'After reading, you should be able to:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读后，你应该能够：
- en: Understand the difference between one-, two- and n-dimensional arrays in NumPy;
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 NumPy 中一维、二维和 n 维数组之间的区别；
- en: Understand how to apply some linear algebra operations to n-dimensional arrays
    without using for-loops;
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解如何将一些线性代数操作应用于 n 维数组，而不使用 for 循环；
- en: Understand axis and shape properties for n-dimensional arrays.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解 n 维数组的轴和形状属性。
- en: '## The Basics'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '## 基础知识'
- en: NumPy’s main object is the homogeneous multidimensional array. It is a table
    of elements (usually numbers), all of the same type, indexed by a tuple of non-negative
    integers. In NumPy dimensions are called *axes*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的主要对象是同构的多维数组。它是一个元素表（通常是数字），所有元素的类型相同，由非负整数的元组索引。在 NumPy 中，维度称为 *轴*。
- en: For example, the array for the coordinates of a point in 3D space, `[1, 2, 1]`,
    has one axis. That axis has 3 elements in it, so we say it has a length of 3\.
    In the example pictured below, the array has 2 axes. The first axis has a length
    of 2, the second axis has a length of 3.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，三维空间中一点的坐标数组 `[1, 2, 1]` 具有一个轴。该轴中有 3 个元素，因此我们说它的长度为 3。在下面的示例中，数组有 2 个轴。第一个轴长度为
    2，第二个轴长度为 3。
- en: '[PRE59]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'NumPy’s array class is called `ndarray`. It is also known by the alias `array`.
    Note that `numpy.array` is not the same as the Standard Python Library class `array.array`,
    which only handles one-dimensional arrays and offers less functionality. The more
    important attributes of an `ndarray` object are:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 的数组类称为 `ndarray`。它也以别名 `array` 而闻名。注意 `numpy.array` 不同于标准 Python 库中的类
    `array.array`，后者只处理一维数组并提供较少的功能。`ndarray` 对象的更重要的属性有：
- en: ndarray.ndim
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.ndim
- en: the number of axes (dimensions) of the array.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的轴数（维数）。
- en: ndarray.shape
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.shape
- en: the dimensions of the array. This is a tuple of integers indicating the size
    of the array in each dimension. For a matrix with *n* rows and *m* columns, `shape`
    will be `(n,m)`. The length of the `shape` tuple is therefore the number of axes,
    `ndim`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的维度。这是一个整数元组，指示每个维度中数组的大小。对于具有 *n* 行和 *m* 列的矩阵，`shape` 将是 `(n,m)`。因此，`shape`
    元组的长度是轴数 `ndim`。
- en: ndarray.size
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.size
- en: the total number of elements of the array. This is equal to the product of the
    elements of `shape`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的元素总数。这等于 `shape` 元素的乘积。
- en: ndarray.dtype
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.dtype
- en: an object describing the type of the elements in the array. One can create or
    specify dtype’s using standard Python types. Additionally NumPy provides types
    of its own. numpy.int32, numpy.int16, and numpy.float64 are some examples.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 描述数组中元素类型的对象。可以使用标准的 Python 类型创建或指定 dtype。此外，NumPy 还提供了自己的类型。numpy.int32、numpy.int16
    和 numpy.float64 是一些示例。
- en: ndarray.itemsize
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.itemsize
- en: the size in bytes of each element of the array. For example, an array of elements
    of type `float64` has `itemsize` 8 (=64/8), while one of type `complex32` has
    `itemsize` 4 (=32/8). It is equivalent to `ndarray.dtype.itemsize`.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 数组中每个元素的字节大小。例如，类型为 `float64` 的元素数组的 `itemsize` 为 8（=64/8），而类型为 `complex32`
    的元素数组的 `itemsize` 为 4（=32/8）。它相当于 `ndarray.dtype.itemsize`。
- en: ndarray.data
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ndarray.data
- en: the buffer containing the actual elements of the array. Normally, we won’t need
    to use this attribute because we will access the elements in an array using indexing
    facilities.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 包含数组实际元素的缓冲区。通常，我们不需要使用此属性，因为我们将使用索引功能访问数组中的元素。
- en: An example
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个例子
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '### Array Creation'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '### 数组创建'
- en: There are several ways to create arrays.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种创建数组的方法。
- en: For example, you can create an array from a regular Python list or tuple using
    the `array` function. The type of the resulting array is deduced from the type
    of the elements in the sequences.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以使用 `array` 函数从常规的 Python 列表或元组创建数组。结果数组的类型是从序列中元素的类型推断出来的。
- en: '[PRE61]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: A frequent error consists in calling `array` with multiple arguments, rather
    than providing a single sequence as an argument.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 经常出现的错误是调用 `array` 时提供多个参数，而不是提供一个序列作为参数。
- en: '[PRE62]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '`array` transforms sequences of sequences into two-dimensional arrays, sequences
    of sequences of sequences into three-dimensional arrays, and so on.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`array` 将序列序列转换为二维数组，序列序列序列转换为三维数组，依此类推。'
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The type of the array can also be explicitly specified at creation time:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的类型也可以在创建时明确指定：
- en: '[PRE64]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Often, the elements of an array are originally unknown, but its size is known.
    Hence, NumPy offers several functions to create arrays with initial placeholder
    content. These minimize the necessity of growing arrays, an expensive operation.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数组的元素最初是未知的，但其大小已知。因此，NumPy 提供了几个函数来创建带有初始占位符内容的数组。这些函数最小化了增长数组的必要性，这是一项昂贵的操作。
- en: The function `zeros` creates an array full of zeros, the function `ones` creates
    an array full of ones, and the function `empty` creates an array whose initial
    content is random and depends on the state of the memory. By default, the dtype
    of the created array is `float64`, but it can be specified via the key word argument
    `dtype`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `zeros` 创建一个全为零的数组，函数 `ones` 创建一个全为一的数组，函数 `empty` 创建一个初始内容是随机的数组，取决于内存状态。默认情况下，创建的数组的
    dtype 是 `float64`，但可以通过关键字参数 `dtype` 指定。
- en: '[PRE65]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: To create sequences of numbers, NumPy provides the `arange` function which is
    analogous to the Python built-in `range`, but returns an array.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建数字序列，NumPy提供了`arange`函数，它类似于Python内置的`range`，但返回一个数组。
- en: '[PRE66]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'When `arange` is used with floating point arguments, it is generally not possible
    to predict the number of elements obtained, due to the finite floating point precision.
    For this reason, it is usually better to use the function `linspace` that receives
    as an argument the number of elements that we want, instead of the step:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 当`arange`与浮点参数一起使用时，通常无法预测获得的元素数量，这是由于有限的浮点精度。因此，通常最好使用函数`linspace`，它接收我们想要的元素数量作为参数，而不是步长：
- en: '[PRE67]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: See also
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`array`](../reference/generated/numpy.array.html#numpy.array "numpy.array"),
    [`zeros`](../reference/generated/numpy.zeros.html#numpy.zeros "numpy.zeros"),
    [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like "numpy.zeros_like"),
    [`ones`](../reference/generated/numpy.ones.html#numpy.ones "numpy.ones"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like"), [`empty`](../reference/generated/numpy.empty.html#numpy.empty
    "numpy.empty"), [`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`arange`](../reference/generated/numpy.arange.html#numpy.arange
    "numpy.arange"), [`linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), *numpy.random.Generator.rand*, *numpy.random.Generator.randn*,
    [`fromfunction`](../reference/generated/numpy.fromfunction.html#numpy.fromfunction
    "numpy.fromfunction"), [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile")'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[`array`](../reference/generated/numpy.array.html#numpy.array "numpy.array"),
    [`zeros`](../reference/generated/numpy.zeros.html#numpy.zeros "numpy.zeros"),
    [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like "numpy.zeros_like"),
    [`ones`](../reference/generated/numpy.ones.html#numpy.ones "numpy.ones"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like"), [`empty`](../reference/generated/numpy.empty.html#numpy.empty
    "numpy.empty"), [`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`arange`](../reference/generated/numpy.arange.html#numpy.arange
    "numpy.arange"), [`linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), *numpy.random.Generator.rand*, *numpy.random.Generator.randn*,
    [`fromfunction`](../reference/generated/numpy.fromfunction.html#numpy.fromfunction
    "numpy.fromfunction"), [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile")'
- en: Printing Arrays
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印数组
- en: 'When you print an array, NumPy displays it in a similar way to nested lists,
    but with the following layout:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当您打印一个数组时，NumPy会以嵌套列表的方式显示，但布局如下：
- en: the last axis is printed from left to right,
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一轴从左到右打印，
- en: the second-to-last is printed from top to bottom,
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倒数第二个从上到下打印，
- en: the rest are also printed from top to bottom, with each slice separated from
    the next by an empty line.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其余部分也会从上到下打印，每个切片之间由一个空行分隔。
- en: One-dimensional arrays are then printed as rows, bidimensionals as matrices
    and tridimensionals as lists of matrices.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组然后按行打印，二维数组按矩阵打印，三维数组按矩阵列表打印。
- en: '[PRE68]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: See [below](#quickstart-shape-manipulation) to get more details on `reshape`.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 请看[下文](#quickstart-shape-manipulation)以获取有关`reshape`的更多详细信息。
- en: 'If an array is too large to be printed, NumPy automatically skips the central
    part of the array and only prints the corners:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组太大无法打印，NumPy会自动跳过数组的中心部分，只打印角落部分：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: To disable this behaviour and force NumPy to print the entire array, you can
    change the printing options using `set_printoptions`.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用此行为并强制NumPy打印整个数组，您可以使用`set_printoptions`更改打印选项。
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '### Basic Operations'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '### 基本运算'
- en: Arithmetic operators on arrays apply *elementwise*. A new array is created and
    filled with the result.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 数组上的算术运算符以*逐元素*方式应用。将创建一个新数组并填充结果。
- en: '[PRE71]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Unlike in many matrix languages, the product operator `*` operates elementwise
    in NumPy arrays. The matrix product can be performed using the `@` operator (in
    python >=3.5) or the `dot` function or method:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多矩阵语言不同，在NumPy数组中，乘积运算符`*`以元素方式操作。可以使用`@`运算符（在python >=3.5中）或`dot`函数或方法执行矩阵乘积：
- en: '[PRE72]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Some operations, such as `+=` and `*=`, act in place to modify an existing array
    rather than create a new one.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作，例如`+=`和`*=`，会就地修改现有数组，而不是创建新数组。
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: When operating with arrays of different types, the type of the resulting array
    corresponds to the more general or precise one (a behavior known as upcasting).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作不同类型的数组时，结果数组的类型对应于更一般或更精确的类型（这种行为称为向上转型）。
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Many unary operations, such as computing the sum of all the elements in the
    array, are implemented as methods of the `ndarray` class.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 许多一元操作，如计算数组中所有元素的总和，都实现为`ndarray`类的方法。
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'By default, these operations apply to the array as though it were a list of
    numbers, regardless of its shape. However, by specifying the `axis` parameter
    you can apply an operation along the specified axis of an array:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些操作将应用于数组，就好像它是一个数字列表，而不考虑其形状。然而，通过指定`axis`参数，你可以沿着数组的指定轴应用操作：
- en: '[PRE76]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Universal Functions
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用函数
- en: NumPy provides familiar mathematical functions such as sin, cos, and exp. In
    NumPy, these are called “universal functions” (`ufunc`). Within NumPy, these functions
    operate elementwise on an array, producing an array as output.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了熟悉的数学函数，如sin、cos和exp。在NumPy中，这些被称为“通用函数”（`ufunc`）。在NumPy中，这些函数对数组进行逐元素操作，产生一个数组作为输出。
- en: '[PRE77]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: See also
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`all`](../reference/generated/numpy.all.html#numpy.all "numpy.all"), [`any`](../reference/generated/numpy.any.html#numpy.any
    "numpy.any"), [`apply_along_axis`](../reference/generated/numpy.apply_along_axis.html#numpy.apply_along_axis
    "numpy.apply_along_axis"), [`argmax`](../reference/generated/numpy.argmax.html#numpy.argmax
    "numpy.argmax"), [`argmin`](../reference/generated/numpy.argmin.html#numpy.argmin
    "numpy.argmin"), [`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort
    "numpy.argsort"), [`average`](../reference/generated/numpy.average.html#numpy.average
    "numpy.average"), [`bincount`](../reference/generated/numpy.bincount.html#numpy.bincount
    "numpy.bincount"), [`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil
    "numpy.ceil"), [`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip"),
    [`conj`](../reference/generated/numpy.conj.html#numpy.conj "numpy.conj"), [`corrcoef`](../reference/generated/numpy.corrcoef.html#numpy.corrcoef
    "numpy.corrcoef"), [`cov`](../reference/generated/numpy.cov.html#numpy.cov "numpy.cov"),
    [`cross`](../reference/generated/numpy.cross.html#numpy.cross "numpy.cross"),
    [`cumprod`](../reference/generated/numpy.cumprod.html#numpy.cumprod "numpy.cumprod"),
    [`cumsum`](../reference/generated/numpy.cumsum.html#numpy.cumsum "numpy.cumsum"),
    [`diff`](../reference/generated/numpy.diff.html#numpy.diff "numpy.diff"), [`dot`](../reference/generated/numpy.dot.html#numpy.dot
    "numpy.dot"), [`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor"),
    [`inner`](../reference/generated/numpy.inner.html#numpy.inner "numpy.inner"),
    [`invert`](../reference/generated/numpy.invert.html#numpy.invert "numpy.invert"),
    [`lexsort`](../reference/generated/numpy.lexsort.html#numpy.lexsort "numpy.lexsort"),
    [`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max"), [`maximum`](../reference/generated/numpy.maximum.html#numpy.maximum
    "numpy.maximum"), [`mean`](../reference/generated/numpy.mean.html#numpy.mean "numpy.mean"),
    [`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median"),
    [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min"), [`minimum`](../reference/generated/numpy.minimum.html#numpy.minimum
    "numpy.minimum"), [`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero"), [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`re`](https://docs.python.org/3/library/re.html#module-re "(in Python v3.11)"),
    [`round`](../reference/generated/numpy.round.html#numpy.round "numpy.round"),
    [`sort`](../reference/generated/numpy.sort.html#numpy.sort "numpy.sort"), [`std`](../reference/generated/numpy.std.html#numpy.std
    "numpy.std"), [`sum`](../reference/generated/numpy.sum.html#numpy.sum "numpy.sum"),
    [`trace`](../reference/generated/numpy.trace.html#numpy.trace "numpy.trace"),
    [`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose "numpy.transpose"),
    [`var`](../reference/generated/numpy.var.html#numpy.var "numpy.var"), [`vdot`](../reference/generated/numpy.vdot.html#numpy.vdot
    "numpy.vdot"), [`vectorize`](../reference/generated/numpy.vectorize.html#numpy.vectorize
    "numpy.vectorize"), [`where`](../reference/generated/numpy.where.html#numpy.where
    "numpy.where")'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '### Indexing, Slicing and Iterating'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '### 索引、切片和迭代'
- en: '**One-dimensional** arrays can be indexed, sliced and iterated over, much like
    [lists](https://docs.python.org/tutorial/introduction.html#lists) and other Python
    sequences.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**一维**数组可以像[列表](https://docs.python.org/tutorial/introduction.html#lists)和其他Python序列一样进行索引、切片和迭代。'
- en: '[PRE78]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '**Multidimensional** arrays can have one index per axis. These indices are
    given in a tuple separated by commas:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '**多维**数组每个轴可以有一个索引。这些索引以逗号分隔的元组形式给出：'
- en: '[PRE79]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: When fewer indices are provided than the number of axes, the missing indices
    are considered complete slices`:`
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供的索引少于轴的数量时，缺少的索引被视为完整的切片`:`
- en: '[PRE80]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The expression within brackets in `b[i]` is treated as an `i` followed by as
    many instances of `:` as needed to represent the remaining axes. NumPy also allows
    you to write this using dots as `b[i, ...]`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在`b[i]`方括号中的表达式被视为`i`，后面跟着需要表示剩余轴的`：`的实例数。NumPy还允许您使用点`...`来编写这个表达式，即`b[i, ...]`。
- en: The **dots** (`...`) represent as many colons as needed to produce a complete
    indexing tuple. For example, if `x` is an array with 5 axes, then
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '**点** (`...`) 表示需要产生一个完整索引元组所需的冒号数量。例如，如果`x`是一个具有5个轴的数组，则'
- en: '`x[1, 2, ...]` is equivalent to `x[1, 2, :, :, :]`,'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x[1, 2, ...]`等同于`x[1, 2, :, :, :]`,'
- en: '`x[..., 3]` to `x[:, :, :, :, 3]` and'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x[..., 3]`转换为`x[:, :, :, :, 3]`，以及'
- en: '`x[4, ..., 5, :]` to `x[4, :, :, 5, :]`.'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x[4, ..., 5, :]`转换为`x[4, :, :, 5, :]`。'
- en: '[PRE81]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '**Iterating** over multidimensional arrays is done with respect to the first
    axis:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 对多维数组的**迭代**是针对第一个轴完成的：
- en: '[PRE82]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'However, if one wants to perform an operation on each element in the array,
    one can use the `flat` attribute which is an [iterator](https://docs.python.org/tutorial/classes.html#iterators)
    over all the elements of the array:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果想对数组中的每个元素执行操作，可以使用`flat`属性，它是数组所有元素的[迭代器](https://docs.python.org/tutorial/classes.html#iterators)：
- en: '[PRE83]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: See also
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Indexing on ndarrays](basics.indexing.html#basics-indexing), [Indexing routines](../reference/arrays.indexing.html#arrays-indexing)
    (reference), [`newaxis`](../reference/constants.html#numpy.newaxis "numpy.newaxis"),
    [`ndenumerate`](../reference/generated/numpy.ndenumerate.html#numpy.ndenumerate
    "numpy.ndenumerate"), [`indices`](../reference/generated/numpy.indices.html#numpy.indices
    "numpy.indices")'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[ndarrays的索引](basics.indexing.html#basics-indexing), [索引例程](../reference/arrays.indexing.html#arrays-indexing)
    (参考), [`newaxis`](../reference/constants.html#numpy.newaxis "numpy.newaxis"),
    [`ndenumerate`](../reference/generated/numpy.ndenumerate.html#numpy.ndenumerate
    "numpy.ndenumerate"), [`indices`](../reference/generated/numpy.indices.html#numpy.indices
    "numpy.indices")'
- en: An example
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个例子
- en: '[PRE84]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '### Array Creation'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '### 数组创建'
- en: There are several ways to create arrays.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种创建数组的方法。
- en: For example, you can create an array from a regular Python list or tuple using
    the `array` function. The type of the resulting array is deduced from the type
    of the elements in the sequences.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以使用`array`函数从常规Python列表或元组创建数组。结果数组的类型是从序列中元素的类型推断出来的。
- en: '[PRE85]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: A frequent error consists in calling `array` with multiple arguments, rather
    than providing a single sequence as an argument.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见错误是使用多个参数调用`array`，而不是提供一个序列作为参数。
- en: '[PRE86]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '`array` transforms sequences of sequences into two-dimensional arrays, sequences
    of sequences of sequences into three-dimensional arrays, and so on.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`array`将序列转换为二维数组，序列的序列转换为三维数组，依此类推。'
- en: '[PRE87]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The type of the array can also be explicitly specified at creation time:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的类型也可以在创建时显式指定：
- en: '[PRE88]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Often, the elements of an array are originally unknown, but its size is known.
    Hence, NumPy offers several functions to create arrays with initial placeholder
    content. These minimize the necessity of growing arrays, an expensive operation.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，数组的元素最初是未知的，但其大小是已知的。因此，NumPy提供了几个函数来创建具有初始占位内容的数组。这减少了增长数组的必要性，这是一个昂贵的操作。
- en: The function `zeros` creates an array full of zeros, the function `ones` creates
    an array full of ones, and the function `empty` creates an array whose initial
    content is random and depends on the state of the memory. By default, the dtype
    of the created array is `float64`, but it can be specified via the key word argument
    `dtype`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`zeros`创建一个全零数组，函数`ones`创建一个全一数组，函数`empty`创建一个其初始内容是随机的并且取决于内存状态的数组。默认情况下，创建的数组的dtype是`float64`，但可以通过关键字参数`dtype`进行指定。
- en: '[PRE89]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: To create sequences of numbers, NumPy provides the `arange` function which is
    analogous to the Python built-in `range`, but returns an array.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建数字序列，NumPy提供了类似于Python内置的`range`的`arange`函数，但它返回一个数组。
- en: '[PRE90]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'When `arange` is used with floating point arguments, it is generally not possible
    to predict the number of elements obtained, due to the finite floating point precision.
    For this reason, it is usually better to use the function `linspace` that receives
    as an argument the number of elements that we want, instead of the step:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当`arange`与浮点数参数一起使用时，通常无法预测获得的元素数量，这是由于有限浮点精度。因此，通常最好使用接收我们想要的元素数量作为参数而不是步长的函数`linspace`：
- en: '[PRE91]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: See also
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`array`](../reference/generated/numpy.array.html#numpy.array "numpy.array"),
    [`zeros`](../reference/generated/numpy.zeros.html#numpy.zeros "numpy.zeros"),
    [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like "numpy.zeros_like"),
    [`ones`](../reference/generated/numpy.ones.html#numpy.ones "numpy.ones"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like"), [`empty`](../reference/generated/numpy.empty.html#numpy.empty
    "numpy.empty"), [`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`arange`](../reference/generated/numpy.arange.html#numpy.arange
    "numpy.arange"), [`linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), *numpy.random.Generator.rand*, *numpy.random.Generator.randn*,
    [`fromfunction`](../reference/generated/numpy.fromfunction.html#numpy.fromfunction
    "numpy.fromfunction"), [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile")'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[`array`](../reference/generated/numpy.array.html#numpy.array "numpy.array"),
    [`zeros`](../reference/generated/numpy.zeros.html#numpy.zeros "numpy.zeros"),
    [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like "numpy.zeros_like"),
    [`ones`](../reference/generated/numpy.ones.html#numpy.ones "numpy.ones"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like"), [`empty`](../reference/generated/numpy.empty.html#numpy.empty
    "numpy.empty"), [`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`arange`](../reference/generated/numpy.arange.html#numpy.arange
    "numpy.arange"), [`linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), *numpy.random.Generator.rand*, *numpy.random.Generator.randn*,
    [`fromfunction`](../reference/generated/numpy.fromfunction.html#numpy.fromfunction
    "numpy.fromfunction"), [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile")'
- en: Printing Arrays
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 打印数组
- en: 'When you print an array, NumPy displays it in a similar way to nested lists,
    but with the following layout:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当打印数组时，NumPy以类似嵌套列表的方式显示它，但布局如下：
- en: the last axis is printed from left to right,
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个轴从左到右打印，
- en: the second-to-last is printed from top to bottom,
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 倒数第二个从上到下打印，
- en: the rest are also printed from top to bottom, with each slice separated from
    the next by an empty line.
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 剩余部分也从上到下打印，每个切片与下一个切片之间由一个空行分隔。
- en: One-dimensional arrays are then printed as rows, bidimensionals as matrices
    and tridimensionals as lists of matrices.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 一维数组被打印为行，二维数组被打印为矩阵，三维数组被打印为矩阵的列表。
- en: '[PRE92]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: See [below](#quickstart-shape-manipulation) to get more details on `reshape`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见[下面](#quickstart-shape-manipulation)以获取有关`reshape`的更多详细信息。
- en: 'If an array is too large to be printed, NumPy automatically skips the central
    part of the array and only prints the corners:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数组太大而无法打印，NumPy会自动跳过数组的中间部分，仅打印角落：
- en: '[PRE93]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: To disable this behaviour and force NumPy to print the entire array, you can
    change the printing options using `set_printoptions`.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用此行为并强制NumPy打印整个数组，可以使用`set_printoptions`更改打印选项。
- en: '[PRE94]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '### Basic Operations'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '### 基本操作'
- en: Arithmetic operators on arrays apply *elementwise*. A new array is created and
    filled with the result.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 数组上的算术运算*逐元素*应用。创建一个新数组并用结果填充。
- en: '[PRE95]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Unlike in many matrix languages, the product operator `*` operates elementwise
    in NumPy arrays. The matrix product can be performed using the `@` operator (in
    python >=3.5) or the `dot` function or method:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多矩阵语言不同，在NumPy数组中，乘积运算符`*`是按元素操作的。可以使用`@`运算符（在python >=3.5中）或`dot`函数或方法执行矩阵乘积：
- en: '[PRE96]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Some operations, such as `+=` and `*=`, act in place to modify an existing array
    rather than create a new one.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 一些操作，比如`+=`和`*=`，是就地修改现有数组而不是创建新数组。
- en: '[PRE97]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: When operating with arrays of different types, the type of the resulting array
    corresponds to the more general or precise one (a behavior known as upcasting).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作不同类型的数组时，结果数组的类型对应于更一般或更精确的类型（这种行为称为向上转型）。
- en: '[PRE98]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Many unary operations, such as computing the sum of all the elements in the
    array, are implemented as methods of the `ndarray` class.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 许多一元操作，比如计算数组中所有元素的和，都作为`ndarray`类的方法实现。
- en: '[PRE99]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'By default, these operations apply to the array as though it were a list of
    numbers, regardless of its shape. However, by specifying the `axis` parameter
    you can apply an operation along the specified axis of an array:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这些操作会将数组视为数字列表进行，而不考虑其形状。但是，通过指定`axis`参数，您可以沿着数组的指定轴应用操作：
- en: '[PRE100]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Universal Functions
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通用函数
- en: NumPy provides familiar mathematical functions such as sin, cos, and exp. In
    NumPy, these are called “universal functions” (`ufunc`). Within NumPy, these functions
    operate elementwise on an array, producing an array as output.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy提供了一些熟悉的数学函数，如sin、cos和exp。在NumPy中，这些被称为“通用函数”（`ufunc`）。在NumPy中，这些函数对数组进行逐元素操作，并产生一个数组作为输出。
- en: '[PRE101]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: See also
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`all`](../reference/generated/numpy.all.html#numpy.all "numpy.all"), [`any`](../reference/generated/numpy.any.html#numpy.any
    "numpy.any"), [`apply_along_axis`](../reference/generated/numpy.apply_along_axis.html#numpy.apply_along_axis
    "numpy.apply_along_axis"), [`argmax`](../reference/generated/numpy.argmax.html#numpy.argmax
    "numpy.argmax"), [`argmin`](../reference/generated/numpy.argmin.html#numpy.argmin
    "numpy.argmin"), [`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort
    "numpy.argsort"), [`average`](../reference/generated/numpy.average.html#numpy.average
    "numpy.average"), [`bincount`](../reference/generated/numpy.bincount.html#numpy.bincount
    "numpy.bincount"), [`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil
    "numpy.ceil"), [`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip"),
    [`conj`](../reference/generated/numpy.conj.html#numpy.conj "numpy.conj"), [`corrcoef`](../reference/generated/numpy.corrcoef.html#numpy.corrcoef
    "numpy.corrcoef"), [`cov`](../reference/generated/numpy.cov.html#numpy.cov "numpy.cov"),
    [`cross`](../reference/generated/numpy.cross.html#numpy.cross "numpy.cross"),
    [`cumprod`](../reference/generated/numpy.cumprod.html#numpy.cumprod "numpy.cumprod"),
    [`cumsum`](../reference/generated/numpy.cumsum.html#numpy.cumsum "numpy.cumsum"),
    [`diff`](../reference/generated/numpy.diff.html#numpy.diff "numpy.diff"), [`dot`](../reference/generated/numpy.dot.html#numpy.dot
    "numpy.dot"), [`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor"),
    [`inner`](../reference/generated/numpy.inner.html#numpy.inner "numpy.inner"),
    [`invert`](../reference/generated/numpy.invert.html#numpy.invert "numpy.invert"),
    [`lexsort`](../reference/generated/numpy.lexsort.html#numpy.lexsort "numpy.lexsort"),
    [`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max"), [`maximum`](../reference/generated/numpy.maximum.html#numpy.maximum
    "numpy.maximum"), [`mean`](../reference/generated/numpy.mean.html#numpy.mean "numpy.mean"),
    [`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median"),
    [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min"), [`minimum`](../reference/generated/numpy.minimum.html#numpy.minimum
    "numpy.minimum"), [`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero"), [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`re`](https://docs.python.org/3/library/re.html#module-re "(in Python v3.11)"),
    [`round`](../reference/generated/numpy.round.html#numpy.round "numpy.round"),
    [`sort`](../reference/generated/numpy.sort.html#numpy.sort "numpy.sort"), [`std`](../reference/generated/numpy.std.html#numpy.std
    "numpy.std"), [`sum`](../reference/generated/numpy.sum.html#numpy.sum "numpy.sum"),
    [`trace`](../reference/generated/numpy.trace.html#numpy.trace "numpy.trace"),
    [`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose "numpy.transpose"),
    [`var`](../reference/generated/numpy.var.html#numpy.var "numpy.var"), [`vdot`](../reference/generated/numpy.vdot.html#numpy.vdot
    "numpy.vdot"), [`vectorize`](../reference/generated/numpy.vectorize.html#numpy.vectorize
    "numpy.vectorize"), [`where`](../reference/generated/numpy.where.html#numpy.where
    "numpy.where")'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[`all`](../reference/generated/numpy.all.html#numpy.all "numpy.all"), [`any`](../reference/generated/numpy.any.html#numpy.any
    "numpy.any"), [`apply_along_axis`](../reference/generated/numpy.apply_along_axis.html#numpy.apply_along_axis
    "numpy.apply_along_axis"), [`argmax`](../reference/generated/numpy.argmax.html#numpy.argmax
    "numpy.argmax"), [`argmin`](../reference/generated/numpy.argmin.html#numpy.argmin
    "numpy.argmin"), [`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort
    "numpy.argsort"), [`average`](../reference/generated/numpy.average.html#numpy.average
    "numpy.average"), [`bincount`](../reference/generated/numpy.bincount.html#numpy.bincount
    "numpy.bincount"), [`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil
    "numpy.ceil"), [`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip"),
    [`conj`](../reference/generated/numpy.conj.html#numpy.conj "numpy.conj"), [`corrcoef`](../reference/generated/numpy.corrcoef.html#numpy.corrcoef
    "numpy.corrcoef"), [`cov`](../reference/generated/numpy.cov.html#numpy.cov "numpy.cov"),
    [`cross`](../reference/generated/numpy.cross.html#numpy.cross "numpy.cross"),
    [`cumprod`](../reference/generated/numpy.cumprod.html#numpy.cumprod "numpy.cumprod"),
    [`cumsum`](../reference/generated/numpy.cumsum.html#numpy.cumsum "numpy.cumsum"),
    [`diff`](../reference/generated/numpy.diff.html#numpy.diff "numpy.diff"), [`dot`](../reference/generated/numpy.dot.html#numpy.dot
    "numpy.dot"), [`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor"),
    [`inner`](../reference/generated/numpy.inner.html#numpy.inner "numpy.inner"),
    [`invert`](../reference/generated/numpy.invert.html#numpy.invert "numpy.invert"),
    [`lexsort`](../reference/generated/numpy.lexsort.html#numpy.lexsort "numpy.lexsort"),
    [`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max"), [`maximum`](../reference/generated/numpy.maximum.html#numpy.maximum
    "numpy.maximum"), [`mean`](../reference/generated/numpy.mean.html#numpy.mean "numpy.mean"),
    [`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median"),
    [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min"), [`minimum`](../reference/generated/numpy.minimum.html#numpy.minimum
    "numpy.minimum"), [`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero"), [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`re`](https://docs.python.org/3/library/re.html#module-re "(在 Python v3.11 中)"),
    [`round`](../reference/generated/numpy.round.html#numpy.round "numpy.round"),
    [`sort`](../reference/generated/numpy.sort.html#numpy.sort "numpy.sort"), [`std`](../reference/generated/numpy.std.html#numpy.std
    "numpy.std"), [`sum`](../reference/generated/numpy.sum.html#numpy.sum "numpy.sum"),
    [`trace`](../reference/generated/numpy.trace.html#numpy.trace "numpy.trace"),
    [`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose "numpy.transpose"),
    [`var`](../reference/generated/numpy.var.html#numpy.var "numpy.var"), [`vdot`](../reference/generated/numpy.vdot.html#numpy.vdot
    "numpy.vdot"), [`vectorize`](../reference/generated/numpy.vectorize.html#numpy.vectorize
    "numpy.vectorize"), [`where`](../reference/generated/numpy.where.html#numpy.where
    "numpy.where")'
- en: '### Indexing, Slicing and Iterating'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '### 索引、切片和迭代'
- en: '**One-dimensional** arrays can be indexed, sliced and iterated over, much like
    [lists](https://docs.python.org/tutorial/introduction.html#lists) and other Python
    sequences.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**一维**数组可以像[列表](https://docs.python.org/tutorial/introduction.html#lists)和其他Python序列一样进行索引、切片和迭代。'
- en: '[PRE102]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '**Multidimensional** arrays can have one index per axis. These indices are
    given in a tuple separated by commas:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '**多维**数组可以有每个轴的一个索引。这些索引用逗号分隔的元组给出：'
- en: '[PRE103]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: When fewer indices are provided than the number of axes, the missing indices
    are considered complete slices`:`
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 当提供的索引少于轴的数量时，缺少的索引被视为完整切片`：`
- en: '[PRE104]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The expression within brackets in `b[i]` is treated as an `i` followed by as
    many instances of `:` as needed to represent the remaining axes. NumPy also allows
    you to write this using dots as `b[i, ...]`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式`b[i]`中的括号内被视为`i`后面跟着尽可能多的`:`来表示剩下的轴。NumPy还允许您使用点号表示为`b[i, ...]`。
- en: The **dots** (`...`) represent as many colons as needed to produce a complete
    indexing tuple. For example, if `x` is an array with 5 axes, then
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '**省略号**（`...`）表示为产生一个完整索引元组所需的冒号。例如，如果`x`是一个具有5个轴的数组，则'
- en: '`x[1, 2, ...]` is equivalent to `x[1, 2, :, :, :]`,'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x[1, 2, ...]`等同于`x[1, 2, :, :, :]`，'
- en: '`x[..., 3]` to `x[:, :, :, :, 3]` and'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x[..., 3]`到`x[:, :, :, :, 3]`和'
- en: '`x[4, ..., 5, :]` to `x[4, :, :, 5, :]`.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x[4, ..., 5, :]`到`x[4, :, :, 5, :]`。'
- en: '[PRE105]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '**Iterating** over multidimensional arrays is done with respect to the first
    axis:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 对多维数组的**迭代**是针对第一个轴进行的：
- en: '[PRE106]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'However, if one wants to perform an operation on each element in the array,
    one can use the `flat` attribute which is an [iterator](https://docs.python.org/tutorial/classes.html#iterators)
    over all the elements of the array:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果想要对数组中的每个元素执行操作，可以使用`flat`属性，它是一个对数组的所有元素进行[迭代](https://docs.python.org/tutorial/classes.html#iterators)的迭代器：
- en: '[PRE107]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: See also
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Indexing on ndarrays](basics.indexing.html#basics-indexing), [Indexing routines](../reference/arrays.indexing.html#arrays-indexing)
    (reference), [`newaxis`](../reference/constants.html#numpy.newaxis "numpy.newaxis"),
    [`ndenumerate`](../reference/generated/numpy.ndenumerate.html#numpy.ndenumerate
    "numpy.ndenumerate"), [`indices`](../reference/generated/numpy.indices.html#numpy.indices
    "numpy.indices")'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[ndarrays上的索引](basics.indexing.html#basics-indexing)，索引例程（参考文档），[`newaxis`](../reference/constants.html#numpy.newaxis
    "numpy.newaxis")，[`ndenumerate`](../reference/generated/numpy.ndenumerate.html#numpy.ndenumerate
    "numpy.ndenumerate")，[`indices`](../reference/generated/numpy.indices.html#numpy.indices
    "numpy.indices")'
- en: '## Shape Manipulation'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '## 形状操作'
- en: Changing the shape of an array
  id: totrans-404
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变数组的形状
- en: 'An array has a shape given by the number of elements along each axis:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的形状由每个轴上的元素数量确定：
- en: '[PRE108]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The shape of an array can be changed with various commands. Note that the following
    three commands all return a modified array, but do not change the original array:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 数组的形状可以使用各种命令来改变。请注意，以下三个命令都会返回一个修改后的数组，但不会改变原始数组：
- en: '[PRE109]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The order of the elements in the array resulting from `ravel` is normally “C-style”,
    that is, the rightmost index “changes the fastest”, so the element after `a[0,
    0]` is `a[0, 1]`. If the array is reshaped to some other shape, again the array
    is treated as “C-style”. NumPy normally creates arrays stored in this order, so
    `ravel` will usually not need to copy its argument, but if the array was made
    by taking slices of another array or created with unusual options, it may need
    to be copied. The functions `ravel` and `reshape` can also be instructed, using
    an optional argument, to use FORTRAN-style arrays, in which the leftmost index
    changes the fastest.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 从`ravel`操作中生成的数组的元素顺序通常是“C-style”，即右边的索引“变化最快”，所以下标为`a[0, 0]`之后的元素是`a[0, 1]`。如果数组被重新整形为其他形状，这个数组仍然被视为“C-style”。NumPy通常创建存储在这个顺序中的数组，所以`ravel`通常不需要复制它的参数，但如果数组是通过对另一个数组切片或使用不寻常的选项创建的，则可能需要复制它。函数`ravel`和`reshape`还可以使用可选参数指示使用FORTRAN-style数组，其中最左边的索引变化得最快。
- en: 'The [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape "numpy.reshape")
    function returns its argument with a modified shape, whereas the [`ndarray.resize`](../reference/generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") method modifies the array itself:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`reshape`函数用修改后的形状返回其参数，而`ndarray.resize`方法修改数组本身：'
- en: '[PRE110]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If a dimension is given as `-1` in a reshaping operation, the other dimensions
    are automatically calculated:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在重整形操作中给出的维度为`-1`，则其他维度会自动计算：
- en: '[PRE111]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: See also
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[`ndarray.shape`](../reference/generated/numpy.ndarray.shape.html#numpy.ndarray.shape
    "numpy.ndarray.shape"), [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape
    "numpy.reshape"), [`resize`](../reference/generated/numpy.resize.html#numpy.resize
    "numpy.resize"), [`ravel`](../reference/generated/numpy.ravel.html#numpy.ravel
    "numpy.ravel")'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '### Stacking together different arrays'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'Several arrays can be stacked together along different axes:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The function [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack") stacks 1D arrays as columns into a 2D array. It is equivalent
    to [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack "numpy.hstack")
    only for 2D arrays:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'On the other hand, the function [`row_stack`](../reference/generated/numpy.row_stack.html#numpy.row_stack
    "numpy.row_stack") is equivalent to [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") for any input arrays. In fact, [`row_stack`](../reference/generated/numpy.row_stack.html#numpy.row_stack
    "numpy.row_stack") is an alias for [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack"):'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: In general, for arrays with more than two dimensions, [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack") stacks along their second axes, [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") stacks along their first axes, and [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate") allows for an optional arguments giving the number of the
    axis along which the concatenation should happen.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: In complex cases, [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_")
    and [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_") are useful
    for creating arrays by stacking numbers along one axis. They allow the use of
    range literals `:`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: When used with arrays as arguments, [`r_`](../reference/generated/numpy.r_.html#numpy.r_
    "numpy.r_") and [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_")
    are similar to [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") and [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack") in their default behavior, but allow for an optional argument
    giving the number of the axis along which to concatenate.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack "numpy.hstack"),
    [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack "numpy.vstack"),
    [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack"), [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate"), [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_")'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Splitting one array into several smaller ones
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using [`hsplit`](../reference/generated/numpy.hsplit.html#numpy.hsplit "numpy.hsplit"),
    you can split an array along its horizontal axis, either by specifying the number
    of equally shaped arrays to return, or by specifying the columns after which the
    division should occur:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[`vsplit`](../reference/generated/numpy.vsplit.html#numpy.vsplit "numpy.vsplit")
    splits along the vertical axis, and [`array_split`](../reference/generated/numpy.array_split.html#numpy.array_split
    "numpy.array_split") allows one to specify along which axis to split.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Changing the shape of an array
  id: totrans-434
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An array has a shape given by the number of elements along each axis:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'The shape of an array can be changed with various commands. Note that the following
    three commands all return a modified array, but do not change the original array:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The order of the elements in the array resulting from `ravel` is normally “C-style”,
    that is, the rightmost index “changes the fastest”, so the element after `a[0,
    0]` is `a[0, 1]`. If the array is reshaped to some other shape, again the array
    is treated as “C-style”. NumPy normally creates arrays stored in this order, so
    `ravel` will usually not need to copy its argument, but if the array was made
    by taking slices of another array or created with unusual options, it may need
    to be copied. The functions `ravel` and `reshape` can also be instructed, using
    an optional argument, to use FORTRAN-style arrays, in which the leftmost index
    changes the fastest.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape "numpy.reshape")
    function returns its argument with a modified shape, whereas the [`ndarray.resize`](../reference/generated/numpy.ndarray.resize.html#numpy.ndarray.resize
    "numpy.ndarray.resize") method modifies the array itself:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'If a dimension is given as `-1` in a reshaping operation, the other dimensions
    are automatically calculated:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: See also
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: '[`ndarray.shape`](../reference/generated/numpy.ndarray.shape.html#numpy.ndarray.shape
    "numpy.ndarray.shape"), [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape
    "numpy.reshape"), [`resize`](../reference/generated/numpy.resize.html#numpy.resize
    "numpy.resize"), [`ravel`](../reference/generated/numpy.ravel.html#numpy.ravel
    "numpy.ravel")'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: '### Stacking together different arrays'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'Several arrays can be stacked together along different axes:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The function [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack") stacks 1D arrays as columns into a 2D array. It is equivalent
    to [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack "numpy.hstack")
    only for 2D arrays:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'On the other hand, the function [`row_stack`](../reference/generated/numpy.row_stack.html#numpy.row_stack
    "numpy.row_stack") is equivalent to [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") for any input arrays. In fact, [`row_stack`](../reference/generated/numpy.row_stack.html#numpy.row_stack
    "numpy.row_stack") is an alias for [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack"):'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: In general, for arrays with more than two dimensions, [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack") stacks along their second axes, [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") stacks along their first axes, and [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate") allows for an optional arguments giving the number of the
    axis along which the concatenation should happen.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: In complex cases, [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_")
    and [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_") are useful
    for creating arrays by stacking numbers along one axis. They allow the use of
    range literals `:`.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: When used with arrays as arguments, [`r_`](../reference/generated/numpy.r_.html#numpy.r_
    "numpy.r_") and [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_")
    are similar to [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack") and [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack") in their default behavior, but allow for an optional argument
    giving the number of the axis along which to concatenate.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack "numpy.hstack"),
    [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack "numpy.vstack"),
    [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack"), [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate"), [`c_`](../reference/generated/numpy.c_.html#numpy.c_ "numpy.c_"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_")'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: Splitting one array into several smaller ones
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using [`hsplit`](../reference/generated/numpy.hsplit.html#numpy.hsplit "numpy.hsplit"),
    you can split an array along its horizontal axis, either by specifying the number
    of equally shaped arrays to return, or by specifying the columns after which the
    division should occur:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[`vsplit`](../reference/generated/numpy.vsplit.html#numpy.vsplit "numpy.vsplit")
    splits along the vertical axis, and [`array_split`](../reference/generated/numpy.array_split.html#numpy.array_split
    "numpy.array_split") allows one to specify along which axis to split.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '## Copies and Views'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: 'When operating and manipulating arrays, their data is sometimes copied into
    a new array and sometimes not. This is often a source of confusion for beginners.
    There are three cases:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: No Copy at All
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simple assignments make no copy of objects or their data.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Python passes mutable objects as references, so function calls make no copy.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: View or Shallow Copy
  id: totrans-471
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Different array objects can share the same data. The `view` method creates a
    new array object that looks at the same data.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Slicing an array returns a view of it:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Deep Copy
  id: totrans-476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `copy` method makes a complete copy of the array and its data.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Sometimes `copy` should be called after slicing if the original array is not
    required anymore. For example, suppose `a` is a huge intermediate result and the
    final result `b` only contains a small fraction of `a`, a deep copy should be
    made when constructing `b` with slicing:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: If `b = a[:100]` is used instead, `a` is referenced by `b` and will persist
    in memory even if `del a` is executed.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: Functions and Methods Overview
  id: totrans-482
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a list of some useful NumPy functions and methods names ordered in categories.
    See [Routines](../reference/routines.html#routines) for the full list.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: Array Creation
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[`arange`](../reference/generated/numpy.arange.html#numpy.arange "numpy.arange"),
    [`array`](../reference/generated/numpy.array.html#numpy.array "numpy.array"),
    [`copy`](../reference/generated/numpy.copy.html#numpy.copy "numpy.copy"), [`empty`](../reference/generated/numpy.empty.html#numpy.empty
    "numpy.empty"), [`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`eye`](../reference/generated/numpy.eye.html#numpy.eye "numpy.eye"),
    [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile"),
    [`fromfunction`](../reference/generated/numpy.fromfunction.html#numpy.fromfunction
    "numpy.fromfunction"), [`identity`](../reference/generated/numpy.identity.html#numpy.identity
    "numpy.identity"), [`linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), [`logspace`](../reference/generated/numpy.logspace.html#numpy.logspace
    "numpy.logspace"), [`mgrid`](../reference/generated/numpy.mgrid.html#numpy.mgrid
    "numpy.mgrid"), [`ogrid`](../reference/generated/numpy.ogrid.html#numpy.ogrid
    "numpy.ogrid"), [`ones`](../reference/generated/numpy.ones.html#numpy.ones "numpy.ones"),
    [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like "numpy.ones_like"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_"), [`zeros`](../reference/generated/numpy.zeros.html#numpy.zeros
    "numpy.zeros"), [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like")'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: Conversions
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: '[`ndarray.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype"), [`atleast_1d`](../reference/generated/numpy.atleast_1d.html#numpy.atleast_1d
    "numpy.atleast_1d"), [`atleast_2d`](../reference/generated/numpy.atleast_2d.html#numpy.atleast_2d
    "numpy.atleast_2d"), [`atleast_3d`](../reference/generated/numpy.atleast_3d.html#numpy.atleast_3d
    "numpy.atleast_3d"), [`mat`](../reference/generated/numpy.mat.html#numpy.mat "numpy.mat")'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: Manipulations
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: '[`array_split`](../reference/generated/numpy.array_split.html#numpy.array_split
    "numpy.array_split"), [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack"), [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate"), [`diagonal`](../reference/generated/numpy.diagonal.html#numpy.diagonal
    "numpy.diagonal"), [`dsplit`](../reference/generated/numpy.dsplit.html#numpy.dsplit
    "numpy.dsplit"), [`dstack`](../reference/generated/numpy.dstack.html#numpy.dstack
    "numpy.dstack"), [`hsplit`](../reference/generated/numpy.hsplit.html#numpy.hsplit
    "numpy.hsplit"), [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack"), [`ndarray.item`](../reference/generated/numpy.ndarray.item.html#numpy.ndarray.item
    "numpy.ndarray.item"), [`newaxis`](../reference/constants.html#numpy.newaxis "numpy.newaxis"),
    [`ravel`](../reference/generated/numpy.ravel.html#numpy.ravel "numpy.ravel"),
    [`repeat`](../reference/generated/numpy.repeat.html#numpy.repeat "numpy.repeat"),
    [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape "numpy.reshape"),
    [`resize`](../reference/generated/numpy.resize.html#numpy.resize "numpy.resize"),
    [`squeeze`](../reference/generated/numpy.squeeze.html#numpy.squeeze "numpy.squeeze"),
    [`swapaxes`](../reference/generated/numpy.swapaxes.html#numpy.swapaxes "numpy.swapaxes"),
    [`take`](../reference/generated/numpy.take.html#numpy.take "numpy.take"), [`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose
    "numpy.transpose"), [`vsplit`](../reference/generated/numpy.vsplit.html#numpy.vsplit
    "numpy.vsplit"), [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack")'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: '[`all`](../reference/generated/numpy.all.html#numpy.all "numpy.all"), [`any`](../reference/generated/numpy.any.html#numpy.any
    "numpy.any"), [`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero"), [`where`](../reference/generated/numpy.where.html#numpy.where
    "numpy.where")'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: Ordering
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: '[`argmax`](../reference/generated/numpy.argmax.html#numpy.argmax "numpy.argmax"),
    [`argmin`](../reference/generated/numpy.argmin.html#numpy.argmin "numpy.argmin"),
    [`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort "numpy.argsort"),
    [`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max"), [`min`](../reference/generated/numpy.min.html#numpy.min
    "numpy.min"), [`ptp`](../reference/generated/numpy.ptp.html#numpy.ptp "numpy.ptp"),
    [`searchsorted`](../reference/generated/numpy.searchsorted.html#numpy.searchsorted
    "numpy.searchsorted"), [`sort`](../reference/generated/numpy.sort.html#numpy.sort
    "numpy.sort")'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: '[`choose`](../reference/generated/numpy.choose.html#numpy.choose "numpy.choose"),
    [`compress`](../reference/generated/numpy.compress.html#numpy.compress "numpy.compress"),
    [`cumprod`](../reference/generated/numpy.cumprod.html#numpy.cumprod "numpy.cumprod"),
    [`cumsum`](../reference/generated/numpy.cumsum.html#numpy.cumsum "numpy.cumsum"),
    [`inner`](../reference/generated/numpy.inner.html#numpy.inner "numpy.inner"),
    [`ndarray.fill`](../reference/generated/numpy.ndarray.fill.html#numpy.ndarray.fill
    "numpy.ndarray.fill"), [`imag`](../reference/generated/numpy.imag.html#numpy.imag
    "numpy.imag"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put"), [`putmask`](../reference/generated/numpy.putmask.html#numpy.putmask
    "numpy.putmask"), [`real`](../reference/generated/numpy.real.html#numpy.real "numpy.real"),
    [`sum`](../reference/generated/numpy.sum.html#numpy.sum "numpy.sum")'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: Basic Statistics
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[`cov`](../reference/generated/numpy.cov.html#numpy.cov "numpy.cov"), [`mean`](../reference/generated/numpy.mean.html#numpy.mean
    "numpy.mean"), [`std`](../reference/generated/numpy.std.html#numpy.std "numpy.std"),
    [`var`](../reference/generated/numpy.var.html#numpy.var "numpy.var")'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: Basic Linear Algebra
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[`cross`](../reference/generated/numpy.cross.html#numpy.cross "numpy.cross"),
    [`dot`](../reference/generated/numpy.dot.html#numpy.dot "numpy.dot"), [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer"), [`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd"), [`vdot`](../reference/generated/numpy.vdot.html#numpy.vdot
    "numpy.vdot")'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: No Copy at All
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Simple assignments make no copy of objects or their data.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Python passes mutable objects as references, so function calls make no copy.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: View or Shallow Copy
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Different array objects can share the same data. The `view` method creates a
    new array object that looks at the same data.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Slicing an array returns a view of it:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Deep Copy
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `copy` method makes a complete copy of the array and its data.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Sometimes `copy` should be called after slicing if the original array is not
    required anymore. For example, suppose `a` is a huge intermediate result and the
    final result `b` only contains a small fraction of `a`, a deep copy should be
    made when constructing `b` with slicing:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: If `b = a[:100]` is used instead, `a` is referenced by `b` and will persist
    in memory even if `del a` is executed.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: Functions and Methods Overview
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here is a list of some useful NumPy functions and methods names ordered in categories.
    See [Routines](../reference/routines.html#routines) for the full list.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: Array Creation
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[`arange`](../reference/generated/numpy.arange.html#numpy.arange "numpy.arange"),
    [`array`](../reference/generated/numpy.array.html#numpy.array "numpy.array"),
    [`copy`](../reference/generated/numpy.copy.html#numpy.copy "numpy.copy"), [`empty`](../reference/generated/numpy.empty.html#numpy.empty
    "numpy.empty"), [`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`eye`](../reference/generated/numpy.eye.html#numpy.eye "numpy.eye"),
    [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile"),
    [`fromfunction`](../reference/generated/numpy.fromfunction.html#numpy.fromfunction
    "numpy.fromfunction"), [`identity`](../reference/generated/numpy.identity.html#numpy.identity
    "numpy.identity"), [`linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), [`logspace`](../reference/generated/numpy.logspace.html#numpy.logspace
    "numpy.logspace"), [`mgrid`](../reference/generated/numpy.mgrid.html#numpy.mgrid
    "numpy.mgrid"), [`ogrid`](../reference/generated/numpy.ogrid.html#numpy.ogrid
    "numpy.ogrid"), [`ones`](../reference/generated/numpy.ones.html#numpy.ones "numpy.ones"),
    [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like "numpy.ones_like"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_"), [`zeros`](../reference/generated/numpy.zeros.html#numpy.zeros
    "numpy.zeros"), [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like")'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: Conversions
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[`ndarray.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype"), [`atleast_1d`](../reference/generated/numpy.atleast_1d.html#numpy.atleast_1d
    "numpy.atleast_1d"), [`atleast_2d`](../reference/generated/numpy.atleast_2d.html#numpy.atleast_2d
    "numpy.atleast_2d"), [`atleast_3d`](../reference/generated/numpy.atleast_3d.html#numpy.atleast_3d
    "numpy.atleast_3d"), [`mat`](../reference/generated/numpy.mat.html#numpy.mat "numpy.mat")'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: Manipulations
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[`array_split`](../reference/generated/numpy.array_split.html#numpy.array_split
    "numpy.array_split"), [`column_stack`](../reference/generated/numpy.column_stack.html#numpy.column_stack
    "numpy.column_stack"), [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate"), [`diagonal`](../reference/generated/numpy.diagonal.html#numpy.diagonal
    "numpy.diagonal"), [`dsplit`](../reference/generated/numpy.dsplit.html#numpy.dsplit
    "numpy.dsplit"), [`dstack`](../reference/generated/numpy.dstack.html#numpy.dstack
    "numpy.dstack"), [`hsplit`](../reference/generated/numpy.hsplit.html#numpy.hsplit
    "numpy.hsplit"), [`hstack`](../reference/generated/numpy.hstack.html#numpy.hstack
    "numpy.hstack"), [`ndarray.item`](../reference/generated/numpy.ndarray.item.html#numpy.ndarray.item
    "numpy.ndarray.item"), [`newaxis`](../reference/constants.html#numpy.newaxis "numpy.newaxis"),
    [`ravel`](../reference/generated/numpy.ravel.html#numpy.ravel "numpy.ravel"),
    [`repeat`](../reference/generated/numpy.repeat.html#numpy.repeat "numpy.repeat"),
    [`reshape`](../reference/generated/numpy.reshape.html#numpy.reshape "numpy.reshape"),
    [`resize`](../reference/generated/numpy.resize.html#numpy.resize "numpy.resize"),
    [`squeeze`](../reference/generated/numpy.squeeze.html#numpy.squeeze "numpy.squeeze"),
    [`swapaxes`](../reference/generated/numpy.swapaxes.html#numpy.swapaxes "numpy.swapaxes"),
    [`take`](../reference/generated/numpy.take.html#numpy.take "numpy.take"), [`transpose`](../reference/generated/numpy.transpose.html#numpy.transpose
    "numpy.transpose"), [`vsplit`](../reference/generated/numpy.vsplit.html#numpy.vsplit
    "numpy.vsplit"), [`vstack`](../reference/generated/numpy.vstack.html#numpy.vstack
    "numpy.vstack")'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: '[`all`](../reference/generated/numpy.all.html#numpy.all "numpy.all"), [`any`](../reference/generated/numpy.any.html#numpy.any
    "numpy.any"), [`nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero"), [`where`](../reference/generated/numpy.where.html#numpy.where
    "numpy.where")'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: Ordering
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: '[`argmax`](../reference/generated/numpy.argmax.html#numpy.argmax "numpy.argmax"),
    [`argmin`](../reference/generated/numpy.argmin.html#numpy.argmin "numpy.argmin"),
    [`argsort`](../reference/generated/numpy.argsort.html#numpy.argsort "numpy.argsort"),
    [`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max"), [`min`](../reference/generated/numpy.min.html#numpy.min
    "numpy.min"), [`ptp`](../reference/generated/numpy.ptp.html#numpy.ptp "numpy.ptp"),
    [`searchsorted`](../reference/generated/numpy.searchsorted.html#numpy.searchsorted
    "numpy.searchsorted"), [`sort`](../reference/generated/numpy.sort.html#numpy.sort
    "numpy.sort")'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: '[`choose`](../reference/generated/numpy.choose.html#numpy.choose "numpy.choose"),
    [`compress`](../reference/generated/numpy.compress.html#numpy.compress "numpy.compress"),
    [`cumprod`](../reference/generated/numpy.cumprod.html#numpy.cumprod "numpy.cumprod"),
    [`cumsum`](../reference/generated/numpy.cumsum.html#numpy.cumsum "numpy.cumsum"),
    [`inner`](../reference/generated/numpy.inner.html#numpy.inner "numpy.inner"),
    [`ndarray.fill`](../reference/generated/numpy.ndarray.fill.html#numpy.ndarray.fill
    "numpy.ndarray.fill"), [`imag`](../reference/generated/numpy.imag.html#numpy.imag
    "numpy.imag"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put"), [`putmask`](../reference/generated/numpy.putmask.html#numpy.putmask
    "numpy.putmask"), [`real`](../reference/generated/numpy.real.html#numpy.real "numpy.real"),
    [`sum`](../reference/generated/numpy.sum.html#numpy.sum "numpy.sum")'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: Basic Statistics
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '[`cov`](../reference/generated/numpy.cov.html#numpy.cov "numpy.cov"), [`mean`](../reference/generated/numpy.mean.html#numpy.mean
    "numpy.mean"), [`std`](../reference/generated/numpy.std.html#numpy.std "numpy.std"),
    [`var`](../reference/generated/numpy.var.html#numpy.var "numpy.var")'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: Basic Linear Algebra
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[`cross`](../reference/generated/numpy.cross.html#numpy.cross "numpy.cross"),
    [`dot`](../reference/generated/numpy.dot.html#numpy.dot "numpy.dot"), [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer"), [`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd"), [`vdot`](../reference/generated/numpy.vdot.html#numpy.vdot
    "numpy.vdot")'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
- en: Less Basic
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Broadcasting rules'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting allows universal functions to deal in a meaningful way with inputs
    that do not have exactly the same shape.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: The first rule of broadcasting is that if all input arrays do not have the same
    number of dimensions, a “1” will be repeatedly prepended to the shapes of the
    smaller arrays until all the arrays have the same number of dimensions.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: The second rule of broadcasting ensures that arrays with a size of 1 along a
    particular dimension act as if they had the size of the array with the largest
    shape along that dimension. The value of the array element is assumed to be the
    same along that dimension for the “broadcast” array.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: 'After application of the broadcasting rules, the sizes of all arrays must match.
    More details can be found in [Broadcasting](basics.broadcasting.html#basics-broadcasting).  ###
    Broadcasting rules'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting allows universal functions to deal in a meaningful way with inputs
    that do not have exactly the same shape.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: The first rule of broadcasting is that if all input arrays do not have the same
    number of dimensions, a “1” will be repeatedly prepended to the shapes of the
    smaller arrays until all the arrays have the same number of dimensions.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: The second rule of broadcasting ensures that arrays with a size of 1 along a
    particular dimension act as if they had the size of the array with the largest
    shape along that dimension. The value of the array element is assumed to be the
    same along that dimension for the “broadcast” array.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: After application of the broadcasting rules, the sizes of all arrays must match.
    More details can be found in [Broadcasting](basics.broadcasting.html#basics-broadcasting).
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: Advanced indexing and index tricks
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy offers more indexing facilities than regular Python sequences. In addition
    to indexing by integers and slices, as we saw before, arrays can be indexed by
    arrays of integers and arrays of booleans.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with Arrays of Indices
  id: totrans-546
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: When the indexed array `a` is multidimensional, a single array of indices refers
    to the first dimension of `a`. The following example shows this behavior by converting
    an image of labels into a color image using a palette.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: We can also give indexes for more than one dimension. The arrays of indices
    for each dimension must have the same shape.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: In Python, `arr[i, j]` is exactly the same as `arr[(i, j)]`—so we can put `i`
    and `j` in a `tuple` and then do the indexing with that.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: However, we can not do this by putting `i` and `j` into an array, because this
    array will be interpreted as indexing the first dimension of `a`.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'Another common use of indexing with arrays is the search of the maximum value
    of time-dependent series:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'You can also use indexing with arrays as a target to assign to:'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-559
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'However, when the list of indices contains repetitions, the assignment is done
    several times, leaving behind the last value:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'This is reasonable enough, but watch out if you want to use Python’s `+=` construct,
    as it may not do what you expect:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Even though 0 occurs twice in the list of indices, the 0th element is only incremented
    once. This is because Python requires `a += 1` to be equivalent to `a = a + 1`.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with Boolean Arrays
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we index arrays with arrays of (integer) indices we are providing the list
    of indices to pick. With boolean indices the approach is different; we explicitly
    choose which items in the array we want and which ones we don’t.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'The most natural way one can think of for boolean indexing is to use boolean
    arrays that have *the same shape* as the original array:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'This property can be very useful in assignments:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'You can look at the following example to see how to use boolean indexing to
    generate an image of the [Mandelbrot set](https://en.wikipedia.org/wiki/Mandelbrot_set):'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '![../_images/quickstart-1.png](../Images/f14ba9a03da211bbacbafc982923e1f4.png)'
  id: totrans-573
  prefs: []
  type: TYPE_IMG
- en: 'The second way of indexing with booleans is more similar to integer indexing;
    for each dimension of the array we give a 1D boolean array selecting the slices
    we want:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Note that the length of the 1D boolean array must coincide with the length of
    the dimension (or axis) you want to slice. In the previous example, `b1` has length
    3 (the number of *rows* in `a`), and `b2` (of length 4) is suitable to index the
    2nd axis (columns) of `a`.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: The ix_() function
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`ix_`](../reference/generated/numpy.ix_.html#numpy.ix_ "numpy.ix_") function
    can be used to combine different vectors so as to obtain the result for each n-uplet.
    For example, if you want to compute all the a+b*c for all the triplets taken from
    each of the vectors a, b and c:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'You could also implement the reduce as follows:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'and then use it as:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The advantage of this version of reduce compared to the normal ufunc.reduce
    is that it makes use of the [broadcasting rules](#broadcasting-rules) in order
    to avoid creating an argument array the size of the output times the number of
    vectors.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with strings
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [Structured arrays](basics.rec.html#structured-arrays).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with Arrays of Indices
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: When the indexed array `a` is multidimensional, a single array of indices refers
    to the first dimension of `a`. The following example shows this behavior by converting
    an image of labels into a color image using a palette.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: We can also give indexes for more than one dimension. The arrays of indices
    for each dimension must have the same shape.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: In Python, `arr[i, j]` is exactly the same as `arr[(i, j)]`—so we can put `i`
    and `j` in a `tuple` and then do the indexing with that.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: However, we can not do this by putting `i` and `j` into an array, because this
    array will be interpreted as indexing the first dimension of `a`.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Another common use of indexing with arrays is the search of the maximum value
    of time-dependent series:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'You can also use indexing with arrays as a target to assign to:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'However, when the list of indices contains repetitions, the assignment is done
    several times, leaving behind the last value:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'This is reasonable enough, but watch out if you want to use Python’s `+=` construct,
    as it may not do what you expect:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Even though 0 occurs twice in the list of indices, the 0th element is only incremented
    once. This is because Python requires `a += 1` to be equivalent to `a = a + 1`.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with Boolean Arrays
  id: totrans-606
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we index arrays with arrays of (integer) indices we are providing the list
    of indices to pick. With boolean indices the approach is different; we explicitly
    choose which items in the array we want and which ones we don’t.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'The most natural way one can think of for boolean indexing is to use boolean
    arrays that have *the same shape* as the original array:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'This property can be very useful in assignments:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'You can look at the following example to see how to use boolean indexing to
    generate an image of the [Mandelbrot set](https://en.wikipedia.org/wiki/Mandelbrot_set):'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '![../_images/quickstart-1.png](../Images/f14ba9a03da211bbacbafc982923e1f4.png)'
  id: totrans-614
  prefs: []
  type: TYPE_IMG
- en: 'The second way of indexing with booleans is more similar to integer indexing;
    for each dimension of the array we give a 1D boolean array selecting the slices
    we want:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Note that the length of the 1D boolean array must coincide with the length of
    the dimension (or axis) you want to slice. In the previous example, `b1` has length
    3 (the number of *rows* in `a`), and `b2` (of length 4) is suitable to index the
    2nd axis (columns) of `a`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: The ix_() function
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`ix_`](../reference/generated/numpy.ix_.html#numpy.ix_ "numpy.ix_") function
    can be used to combine different vectors so as to obtain the result for each n-uplet.
    For example, if you want to compute all the a+b*c for all the triplets taken from
    each of the vectors a, b and c:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'You could also implement the reduce as follows:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'and then use it as:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: The advantage of this version of reduce compared to the normal ufunc.reduce
    is that it makes use of the [broadcasting rules](#broadcasting-rules) in order
    to avoid creating an argument array the size of the output times the number of
    vectors.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: Indexing with strings
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See [Structured arrays](basics.rec.html#structured-arrays).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: Tricks and Tips
  id: totrans-628
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we give a list of short and useful tips.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
- en: “Automatic” Reshaping
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To change the dimensions of an array, you can omit one of the sizes which will
    then be deduced automatically:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Vector Stacking
  id: totrans-633
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How do we construct a 2D array from a list of equally-sized row vectors? In
    MATLAB this is quite easy: if `x` and `y` are two vectors of the same length you
    only need do `m=[x;y]`. In NumPy this works via the functions `column_stack`,
    `dstack`, `hstack` and `vstack`, depending on the dimension in which the stacking
    is to be done. For example:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The logic behind those functions in more than two dimensions can be strange.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[NumPy for MATLAB users](numpy-for-matlab-users.html)'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: Histograms
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The NumPy `histogram` function applied to an array returns a pair of vectors:
    the histogram of the array and a vector of the bin edges. Beware: `matplotlib`
    also has a function to build histograms (called `hist`, as in Matlab) that differs
    from the one in NumPy. The main difference is that `pylab.hist` plots the histogram
    automatically, while `numpy.histogram` only generates the data.'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '![../_images/quickstart-2.png](../Images/6e8a719f3f733b746d4f0762a37ae4e0.png)'
  id: totrans-642
  prefs: []
  type: TYPE_IMG
- en: With Matplotlib >=3.4 you can also use `plt.stairs(n, bins)`.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: “Automatic” Reshaping
  id: totrans-644
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To change the dimensions of an array, you can omit one of the sizes which will
    then be deduced automatically:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Vector Stacking
  id: totrans-647
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How do we construct a 2D array from a list of equally-sized row vectors? In
    MATLAB this is quite easy: if `x` and `y` are two vectors of the same length you
    only need do `m=[x;y]`. In NumPy this works via the functions `column_stack`,
    `dstack`, `hstack` and `vstack`, depending on the dimension in which the stacking
    is to be done. For example:'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: The logic behind those functions in more than two dimensions can be strange.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[NumPy for MATLAB users](numpy-for-matlab-users.html)'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
- en: Histograms
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The NumPy `histogram` function applied to an array returns a pair of vectors:
    the histogram of the array and a vector of the bin edges. Beware: `matplotlib`
    also has a function to build histograms (called `hist`, as in Matlab) that differs
    from the one in NumPy. The main difference is that `pylab.hist` plots the histogram
    automatically, while `numpy.histogram` only generates the data.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '![../_images/quickstart-2.png](../Images/6e8a719f3f733b746d4f0762a37ae4e0.png)'
  id: totrans-656
  prefs: []
  type: TYPE_IMG
- en: With Matplotlib >=3.4 you can also use `plt.stairs(n, bins)`.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-658
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [Python tutorial](https://docs.python.org/tutorial/)
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[NumPy reference](../reference/index.html#reference)'
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SciPy Tutorial](https://docs.scipy.org/doc/scipy/tutorial/index.html)'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SciPy Lecture Notes](https://scipy-lectures.org)'
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A [matlab, R, IDL, NumPy/SciPy dictionary](http://mathesaurus.sf.net/)
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[tutorial-svd](https://numpy.org/numpy-tutorials/content/tutorial-svd.html
    "(in NumPy tutorials)")'
  id: totrans-664
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
