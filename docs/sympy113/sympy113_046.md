# 术语表

> 原文：[`docs.sympy.org/latest/explanation/glossary.html`](https://docs.sympy.org/latest/explanation/glossary.html)

这一页是 SymPy 文档中使用的各种术语的术语表。该术语表主要用于特定于 SymPy 的术语。有关更一般的 Python 术语，请参阅[Python 术语表](https://docs.python.org/3/glossary.html)。数学术语仅在 SymPy 中具有特定含义时包含在此处。有关一般数学定义，请参考其他来源，如[Wikipedia](https://www.wikipedia.org/)或[MathWorld](https://mathworld.wolfram.com/)，以及特定 SymPy 函数文档中的参考资料。

反导数

函数 \(f(x)\) 关于 \(x\) 的一个*反导数*是一个函数 \(F(x)\)，使得 \(\frac{d}{dx}F(x) = f(x).\) 有时也称为 \(f(x)\) 的“不定积分”，并写作 \(\int f(x)\,dx.\) 在 SymPy 中，可以用`integrate()`计算反导数。请注意，某些来源称之为 \(f(x)\) 的“原函数”，但 SymPy 中不使用此术语，因为它不像“反导数”一样被普遍使用，并且“原函数”在数学和`SymPy`中有其他含义。

`args`

SymPy 表达式的*`args`* 属性是用于创建它的顶级子表达式的元组。它们是用于创建表达式的类的参数。任何表达式的 `args` 可以通过 `.args` 属性获取。例如，`(1 + x*y).args` 是 `(1, x*y)`，因为它等于 `Add(1, x*y)`。`args` 与 func 一起完全定义了一个表达式。可以通过反复使用 `.args` 来遍历表达式树并提取 SymPy 表达式的任何子表达式。通过 `func` 和 `args`，始终可以准确重建任何 SymPy 表达式，即 `expr.func(*expr.args) == expr` 对于任何 SymPy 表达式 `expr` 都是真实的。一个表达式的 `args` 可能是空元组 `()`，这意味着表达式是一个原子。

Assumptions

*Assumptions* 是对符号或表达式的一组谓词，定义其可以取的可能值集合。一些假设的示例包括 `positive`、`real` 和 `integer`。假设在逻辑上相互关联，例如，一个 `integer` 的假设自动意味着 `real`。假设使用三值逻辑系统，其中谓词可以是 `True`、`False` 或 `None`。

假设可以是*假设*或*查询*。例如，一个符号 `x` 可能通过将其定义为 `x = symbols('x', positive=True)` 来*假设*为正数。然后可以在包含此符号的表达式上*查询*一个假设，如 `(x + 1).is_real`，在这种情况下将返回 `True`。

如果在符号上没有假设，则默认情况下假设符号是一般复数。设置假设是重要的，因为某些简化只在受限域内数学上成立，例如，\(\sqrt{x²} = x\) 对一般复数 \(x\) 不成立，但当 \(x\) 是正数时成立。除非表达式的所有允许值都符合其假设，否则 SymPy 函数不会对表达式执行操作。

SymPy 有两个独立的假设系统，它们彼此紧密相关。在第一个系统中，有时被称为“旧假设”，因为它更老，假设是在符号对象上假设并使用 is_*属性查询。在第二个系统中，有时被称为“新假设”，假设是使用像`Q.positive`这样的单独谓词对象假设的，并使用`ask()`函数查询。较新的假设系统能够支持更复杂的查询，但也不像较旧的那样发展得好。目前大多数 SymPy 用户应该偏好较旧的假设系统。

查看假设指南了解更多关于假设的细节。

原子

一个*原子*是一个表达式，其 args 是空元组`()`。原子是表达式树的叶子节点。例如，如果一个函数使用递归来遍历表达式树使用`args`，那么原子表达式将是递归的基本情况。

请注意，类`Atom`有时被用作原子表达式的基类，但不要求原子表达式必须是这个类的子类。表达式要成为原子表达式的唯一要求是它的 args 为空。

自动简化

*自动简化* 指的是在类构造函数内部自动进行的任何简化。例如，在 `Add` 构造函数中，`x + x` 会自动简化为 `2*x`。与手动 简化 不同，自动简化只能通过设置 `evaluate=False` 来禁用 (参见 未评估)。通常进行自动简化是为了使表达式 规范化。过度的自动简化是不鼓励的，因为这样做会使表达式无法表示为非简化形式，除非使用 `evaluate=False` 等技巧，而且在类构造函数中这样做通常是一件昂贵的事情。相比之下，通常更倾向于进行手动 简化/规范化。

`基本`

*`基本`* 是所有 SymPy 表达式的超类。它定义了 SymPy 表达式所需的基本方法，比如 args，func，equality，immutability，以及一些有用的表达式操作函数，比如 替换。大多数 SymPy 类将会作为更具体的 `Basic` 子类，比如 布尔，表达式，函数，或 矩阵 进行子类化。通常情况下，如果一个对象不是 `Basic` 实例，它就不能在 SymPy 函数中使用，除非可以通过 sympify() 转换为一个。

`布尔`

*`布尔`* 是 `logic` 模块中类的基类。`Boolean` 实例代表布尔代数中的逻辑谓词，并且可以被视为具有“真”或“假”值 (注意 `Boolean` 对象不使用 三值逻辑，而是使用 假设）。

绑定符号

表达式中的一个 symbol 如果是*bound*，则表示它不是 free。一个 bound 符号可以被新符号替换，得到的表达式仍然在数学上等价。例子包括定积分中的积分变量和`Subs`中的替换变量。有时用 dummy 符号表示 bound 符号，但它们不总是`Dummy`对象，而`Dummy`对象也不总是 bound 符号。

规范形式

规范化

表达式通常可以用多种数学等价的方式写出。*规范形式*是表达式的一种单一写法，所有等价的表达式都可以转换为这种形式。将表达式放入规范形式称为*规范化*。通常规范形式是唯一的，并具有使其更易于处理的属性。例如，有理函数的常见规范形式是\(\frac{p}{q}\)，其中\(p\)和\(q\)是无公因式的展开多项式。

代码生成

*代码生成*指的是将 SymPy 表达式转换为特定语言或库的代码，以便进行数值评估的过程。SymPy 支持几十种语言和库的代码生成，包括 C、C++、Fortran 和 NumPy。

核心

*核心*是包含所有 SymPy 对象使用的重要功能的子模块。这包括 Basic 和 Expr 基类，如`Add`、`Mul`和`Pow`等类，以及假设。

哑元

*dummy* symbol 是一个符号，即使它与同名的其他 dummy 符号不相等，也会自动返回其自身。dummy 符号用于当函数需要返回带有新符号的表达式时，以避免意外与同名的 symbol 冲突。可以使用`Dummy`创建 dummy 符号。

方程

*方程*是具有等号 \(=\) 的 expression。在 SymPy 中，方程使用`Eq`类表示。方程不是使用`==`运算符创建的。`==`运算符执行两个表达式之间的结构相等性检查，并始终返回`True`或`False`。相比之下，符号方程可能是 unevaluated 的。方程被视为 booleans，因为它们在数学上表示一个谓词值，即真或假。

`_eval_*`

Basic 和 Expr 上的各种方法可以通过特殊的*`_eval_*`*方法在子类中定义。例如，对象可以通过定义`_eval_derivative`方法来定义在`diff()`函数中如何处理它。使用的`_eval_*`方法是替代重写方法本身，以便在基类上定义的方法在调度到`_eval_*`方法之前进行预处理。

`evalf`

*`evalf`*是每个 Expr 对象上的方法，用于将其评估为浮点数值，或者如果表达式包含 symbols，则将表达式的常数部分转换为数值。`.n()`方法和`N()`函数都是`evalf`的简写。 `evalf`代表“evaluate floating-point”。 `evalf`在内部使用 mpmath 来对表达式进行任意精度评估。

评估

*评估*可以指：

+   将 expression 转换为数值的过程（见 evalf)

+   创建表达式时发生的自动简化过程（参见 Unevaluated）。

+   将表达式中的一个或多个 symbols 用数值或使用 substitution 替换的过程。

`Expr`

*`Expr`*是所有代数 SymPy 表达式的超类。它本身是 Basic 的子类。可以在`Add`、`Mul`或`Pow`中的 SymPy 表达式应该是`Expr`的子类。并非所有 SymPy 类都是`Expr`的子类，例如，布尔对象是 Basic，但不是`Expr`，因为布尔表达式在像`Add`或`Mul`这样的类中没有数学意义。

表达式

任何 SymPy 对象，即任何 Basic 的实例，都可以称为*表达式*。有时，“表达式”一词保留给 Expr 对象，这些是代数表达式。表达式不应与方程混淆，后者是表示数学等式的特定类型的表达式。

表达树

*表达树*是[树](https://zh.wikipedia.org/wiki/%E6%A0%91_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84))的表达式。每个表达式都是从较小的表达式构建而成的树。表达树的节点是表达式，每个节点的子节点是构成该表达式的直接子表达式。或者，可以将表达树视为一棵树，其中非叶节点是函数，叶节点是原子。例如，教程中展示了一个表达式树的示例。通过递归遍历 args，可以获得任何 SymPy 表达式的表达树。请注意，由于 SymPy 表达式是不可变的，并且严格按照结构相等性处理，因此也可以将表达树视为是[DAG](https://zh.wikipedia.org/wiki/%E5%9F%BA%E4%BA%8E%E6%9C%AC%E4%BD%93%E7%9A%84%E7%9B%B8%E7%AD%89%E7%BB%93%E6%9E%84)，其中相同的子表达式在图中只表示一次。

自由符号

表达式中的符号如果数学上依赖于该符号的值，则为*自由*。也就是说，如果该符号被替换为一个新符号，结果将是不同的表达式。不是自由的符号是绑定的。可以通过`free_symbols`属性访问表达式的自由符号。

`func`

*`func`*属性是 expression 的函数，可以通过`expr.func`获取。这通常与`type(expr)`相同，但在某些情况下可能会有所不同，因此在重建具有 args 的表达式时，应优先使用`expr.func`而不是`type(expr)`。每个 SymPy 表达式都可以使用`func`和`args`完全重建，即`expr.func(*expr.args) == expr`对于任何 SymPy 表达式`expr`都将始终为真。

函数

*函数*可能指：

+   数学函数，即将域中的值映射到范围中的某些内容。有时，包含 symbol 的 expression 在口语上称为“函数”，因为该符号可以使用 substitution 替换为值，从而 evaluating 表达式。这种用法是口语化的，因为必须使用`subs`方法来执行替换，而不是典型的 Python 函数调用语法，并且它不具体说明表达式是哪些变量的函数，因此通常应优先使用术语“expression”，除非某些内容确实是函数。可以使用`Lambda`将表达式转换为可以使用 Python `f(x)`语法调用的函数对象。

+   SymPy Function 类的一个实例。

+   Python 函数，即使用`def`关键字定义的函数。 Python 函数不是 symbolic，因为它们必须始终返回一个值，因此不能是 unevaluated。

`Function`（类）

*`Function`*是 SymPy 中符号函数的基类。这包括常见函数如`sin()`和`exp()`，特殊函数如`zeta()`和`hyper()`，以及积分函数如`primepi()`和`divisor_sigma()`。函数类总是符号化，这意味着当传递一个符号，如`f(x)`时，它们通常保持未评估状态。并非所有符号表达式类都是`Function`子类，例如，像`Add`和`Mul`这样的核心类不是`Function`子类。

`Function`也可以用于通过传递函数的字符串名称（如`Function('f')`）创建一个未定义函数。

并非所有 SymPy 中的函数都是符号`Function`类；有些只是始终返回值的 Python 函数。例如，大多数简化函数（如 simplify()）无法以符号形式表示。

Immutable

在 Python 中，如果对象无法原地修改，则称其为*不可变*。为了改变一个不可变对象，必须创建一个新的对象。在 SymPy 中，所有的基础对象都是不可变的。这意味着所有操作表达式的函数都会返回一个新的表达式，并且不会改变原始对象。对表达式进行操作不会改变引用该表达式的其他对象或表达式。这也意味着任何两个相等的对象完全可以互换，并且可以被视为同一个对象，即使它们在内存中是两个不同的对象。不可变性使得更容易维护代码的心智模型，因为没有隐藏状态。SymPy 对象的不可变性也意味着它们是可哈希的，可以用作字典键。

交互式

*交互* 使用指的是在交互式 REPL 环境中使用 SymPy，例如 Python 提示符、isympy、[IPython](https://ipython.org/) 或 [Jupyter 笔记本](https://jupyter.org/)。在交互式使用 SymPy 时，所有命令由用户实时输入，并显示所有中间结果。*交互* 使用与*程序化* 使用相对应，后者是指代码写入文件，然后作为脚本执行或作为较大 Python 库的一部分。一些 SymPy 习惯用法仅推荐在交互式使用时使用，当在程序化使用时被视为反模式。例如，在交互式使用 SymPy 时运行 `from sympy import *` 是方便的，但在程序化使用时通常不建议，应优先显式导入名称 `import sympy`。

`is_*`

在 SymPy 中以 *`is_`* 开头并使用*小写*名称的属性查询对象的给定假设（注意：有少数属性是例外，因为它们不使用假设系统，请参阅假设指南）。例如，`x.is_integer` 将查询 `x` 的 `integer` 假设。使用*大写*名称的 `is_*` 属性测试对象是否是给定类的实例。有时相同名称将同时存在于小写和大写属性中，但它们代表不同的事物。例如，只有当 `x` 是 `Integer` 的实例时，`x.is_Integer` 才为 `True`，而 `x.is_integer` 只有在 `x` 是假设系统中的 `integer` 时才为 `True`，如 `x = symbols('x', integer=True)`。一般建议不使用 `is_Capitalized` 属性。它们存在是为了历史目的，但是使用 `isinstance()` 可以达到同样的效果。另请参阅 Number。

`isympy`

*`isympy`* 是一个与 SymPy 一起提供的命令，它在命令行上启动一个交互会话，导入所有 SymPy 名称并启用打印功能。默认情况下，安装时使用 [IPython](https://ipython.org/)。

类型

SymPy 对象的*类型*表示其代表的数学对象的种类。对象的类型可以通过 `kind` 属性访问。例如，`NumberKind` 代表复数，`MatrixKind` 代表其他某种矩阵，以及 `BooleanKind` 代表布尔谓词。SymPy 对象的类型与其 Python 类型不同，因为有时一个单一的 Python 类型可能代表许多不同种类的对象。例如，`Matrix` 可能是复数矩阵，也可能是某些其他值环中的对象矩阵。详见 SymPy 对象的分类页面关于类型的分类了解更多详情。

lamda

“*Lamda*” 只是希腊字母`lambda`的另一种拼写方式。在 SymPy 中有时会使用这个拼写，因为在 Python 中 `lambda` 是一个保留关键字，所以表示 λ 的符号必须取别的名字。

`lambdify()`

*`lambdify()`* 是一个函数，将 SymPy 表达式转换为可以进行数值评估的 Python 函数，通常使用类似 NumPy 的数值库。

矩阵

*矩阵* 是 SymPy 用于表示矩阵的一组类。SymPy 有几个内部类用于表示矩阵，取决于矩阵是否是符号化的（`MatrixExpr`）、显式的、可变的或不可变的、稠密的或稀疏的，以及底层元素的类型是什么，但通常统称为“矩阵”。

mpmath

[*mpmath*](https://mpmath.org/) 是一个纯 Python 库，用于任意精度数值计算。它是 SymPy 的一个硬依赖。mpmath 能够计算数值函数至任意精度位数。每当 SymPy 对表达式进行数值评估时（例如使用 evalf），mpmath 就在幕后发挥作用。

数值

*数值* 表示或算法直接操作数值输入。它与 *符号* 表示或算法相对，后者可以处理未求值形式的对象。通常数值算法与符号算法有很大不同。例如，数值求解常微分方程通常意味着使用像 [Runge–Kutta](https://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods) 这样的算法来在给定初始条件下找到一组数值点，而符号求解常微分方程（例如使用 SymPy 的 `dsolve()`）意味着数学上操纵常微分方程以生成一个 符号 方程，该方程表示解。符号常微分方程的解可能包含符号常数，这些符号常数可以表示任何数值。数值算法通常围绕浮点数引起的问题设计，如精度损失和数值稳定性，而符号算法则不涉及这些问题，因为它们可以精确计算。

大多数科学库，如 NumPy 或 SciPy，严格是数值的，意味着这些库中的函数只能操作特定的数值输入。它们无法处理 SymPy 表达式，因为它们的算法不是设计用于符号输入。SymPy 主要关注符号函数，将纯数值代码留给像 NumPy 这样的其他工具。然而，SymPy 通过工具如 代码生成 和 lambdify() 与数值库进行接口。

Number

*Number* 可以指 SymPy 中的两种东西：

+   类 `Number` 是显式数值（`Integer`、`Rational` 和 `Float`）的基类。符号数值常量如 `pi` 不是 `Number` 的实例。

+   小写的 "*number*"，例如 `is_number` 属性，指的是可以 evalfed 成显式 `Number` 的任何 表达式。这包括像 `pi` 这样的符号常数。注意，`is_number` 不是 假设 系统的一部分。

对于 `is_Number` 和 `is_number` 属性，这种区别非常重要。`x.is_Number` 将检查 `x` 是否是 `Number` 类的一个实例。

`oo`

*`oo`*是 SymPy 表示正无穷大的对象。它以这种方式拼写，作为两个小写字母 O，因为它类似于符号\(\infty\)且易于输入。另见 zoo。

Polys

*polys*指的是`sympy.polys`子模块，它实现了多项式操作的基本数据结构和算法。polys 是 SymPy 的关键部分（虽然通常不被认为是核心的一部分），因为许多基本的符号操作可以表示为对多项式的操作。SymPy 中的许多算法在内部使用多项式。例如，`factor()`是对多项式因式分解算法的一种封装，这些算法在多项式中实现。polys 中的类使用高效的数据结构实现，并且不像 SymPy 中的其他类一样，不是 Basic 的子类。

打印

*打印*指的是将一个表达式转换为可以在屏幕上查看的形式。打印通常也用于指代代码生成。SymPy 有几个打印机，可以使用不同格式表示表达式。一些更常见的打印机是字符串打印机（`str()`），漂亮的打印机(`pprint()`)，LaTeX 打印机(`latex()`)和代码打印机。

关系

*关系*是一个表达式，它是符号 等式（比如\(a=b\)），或者一个象征着“小于”（\(a<b\)）的符号不等式。等式（\(=\)）和不等式（\(\neq\)）的关系是用`Eq`和`Ne`创建的。例如，`Eq(x, 0)`表示\(x=0\)。这些应该用于代替`==`或`!=`，因为这些用于结构而不是象征性的相等。不等关系可以直接使用`<`，`<=`，`>`和`>=`来创建，比如`x < 0`。

`S`

SymPy 中的*`S`*对象有两个用途：

+   它将所有单例类作为属性保存。SymPy 中的一些特殊类被设计为单例化，意味着它们始终只有一个实例。这是一种优化方法，可以节省内存。例如，`Integer(0)` 只有一个实例，可以通过 `S.Zero` 获取。

+   它充当 sympify() 的缩写，即 `S(a)` 等同于 `sympify(a)`。这在将整数转换为 SymPy 整数以避免在表达式中使用 Python 整数进行除法时非常有用（参见 教程的注意事项部分）。

简化

*简化*（不要与 sympify 混淆）指的是将一个 表达式 转换为另一个在数学上等价但在某种意义上“更简单”的表达式的过程。“简单”的形容词实际上并不十分明确。什么算简单取决于具体的用例和个人审美观。

SymPy 函数 `simplify()` 根据启发式方法尝试各种简化算法，以找到表达式的“更简单”形式。如果你对“简化”想要什么并不是特别确定，它可能是一个不错的选择。但如果你对想要应用的简化有一个具体的想法，通常最好使用一个或多个目标化的 简化函数，这些函数对表达式应用非常具体的数学操作。

解决

求解器

对于 *解* 一个 方程 或方程组意味着找到一组 表达式，当给定的 符号 被它们替换时，方程（们）为真。例如，对于方程 \(x² = 1\) 关于 \(x\) 的解是集合 \(\{-1, 1\}\)。SymPy 可以使用不同的 *求解器* 函数来解决不同类型的方程。例如，代数方程可以用 `solve()` 解决，微分方程可以用 `dsolve()` 解决，等等。

SymPy 通常使用“solve”和“solvers”来表示这种意义上的方程求解。它不用于“解决问题”的意义。例如，通常会更倾向于说“计算一个积分”或“评估一个积分”，而不是“解决一个积分”，来表示使用函数 `integrate()` 进行符号积分。

结构相等性

两个 SymPy 对象如果作为表达式相等，则它们被认为是*结构相等*的，即它们具有相同的表达式树。在 SymPy 中，两个结构相等的表达式被认为是相同的，因为所有 SymPy 表达式都是不可变的。结构相等可以通过`==`操作符来检查，它总是返回`True`或`False`。符号等式可以用`Eq`来表示。

通常，如果两个表达式是相同的类，并且（递归地）具有相同的 args，那么它们就是结构相等的。两个表达式可能在数学上是相同的，但在结构上不相等。例如，`(x + 1)**2` 和 `x**2 + 2*x + 1` 在数学上是相等的，但它们在结构上不相等，因为前者是一个 `Pow`，其 args 包括一个`Add` 和一个`Integer`，而后者是一个`Add`，其 args 包括一个`Pow`，一个`Mul` 和一个`Integer`。

两个表面上不同的表达式，如果它们经过规范化后变成相同的形式，那么它们就是结构相等的。例如，`x + y` 和 `y + x` 结构上是相等的，因为`Add` 构造器会自动排序其参数，使它们变成相同的形式。

子表达式

*子表达式* 是一个包含在较大表达式中的表达式。子表达式出现在表达式树的某处。对于`Add`和`Mul`项，当确定什么是子表达式时，可以考虑交换律和结合律。例如，`x + y` 有时可能被认为是 `x + y + z` 的子表达式，即使`Add(x, y)`的表达式树不是`Add(x, y, z)`的直接子节点。

替换

*替换*是指用另一个表达式替换 expression 内部的 symbol 或 subexpression 的行为。在 SymPy 中有不同的方法执行替换，包括`subs`、`replace`和`xreplace`。这些方法可能因是否只使用严格的 structural equality 或在确定子表达式在表达式中出现的位置时利用数学知识而有所不同。替换是将表达式视为数学 function 并在某点评估的标准方法。

符号

*符号*表示一个数学对象的表示，在运行时部分或完全未评估。它可能包括以命名的 symbolic constants 代替显式数值。符号表示通常与 numeric 表示形成对比。符号表达是数学上精确的，与通常舍入以适应浮点值的数值表示相对。符号表示数学对象的表达可能意识到这些对象的数学属性，并能够利用这些属性简化为等效的符号表达式。SymPy 的目标是表示和操作代表各种数学对象的符号表达式。

一些来源使用术语“分析解”或“闭合形式”来指代“符号”的概念，但这种术语在 SymPy 中不使用。如果在 SymPy 中使用，“分析”将指代[解析函数](https://en.wikipedia.org/wiki/Analytic_function)的特性，在 SymPy 中 solve 仅指特定类型的符号操作。“闭合形式”在 SymPy 中通常指数学上的意义，而“符号”通常指的是数学概念如何实现的实现细节，并与相同数学概念的 numeric 实现形成对比。

`Symbol`

*`Symbol`*是符号对象的类。符号代表表达式中的单个数学变量。`Symbol`类是 Expr 的子类，是 atomic 的。一个`Symbol`包含一个名称，可以是任何字符串，以及 assumptions。符号通常使用`Symbol`构造函数或`symbols()`函数定义。具有相同名称和假设的两个 Symbols 被认为是 equal 的。Symbols 通常被隐式地假设是彼此独立或常数。常量、变量和参数都由 Symbols 表示。在给定的 SymPy 函数中，通常通过 Symbols 的使用方式来区分它们。

`sympify()`

*`sympify()`*（不要与*simplify()*混淆）是将非 SymPy 对象转换为 SymPy 对象的函数。`sympify()`的结果将是 Basic 的一个实例。可以被*sympified*的对象包括本地 Python 数值类型如`int`和`float`，可以解析为 SymPy 表达式的字符串以及包含*sympifiable*对象的可迭代对象（详见`sympify()`的文档了解更多信息）。

因为所有 SymPy 表达式必须是 Basic 的实例，所有 SymPy 函数和操作在其输入上会隐式调用`sympify()`。例如，`x + 1`会隐式调用`sympify(1)`将 Python `int`类型的`1`转换为 SymPy 的`Integer`。接受 SymPy 表达式的函数通常应该在其参数上调用`sympify()`，以确保它们在输入不是 SymPy 类型时也能正常工作。

三值逻辑

*三值逻辑*是一种具有三个值 `True`、`False` 和 `None` 的逻辑。有时它也被称为*模糊逻辑*，尽管在数学文献中这个术语也有不同的含义，因此“三值逻辑”更受推荐。`True` 和 `False` 的作用与通常的二值谓词逻辑相同。`None` 是一个额外的术语，表示“未知”、“不可计算”或“可以是 True 或 False”（从哲学上讲这些是不同的概念，但逻辑上它们完全相同）。`None` 的语义是在逻辑操作中吸收其他术语，每当如果将其替换为 `True` 或 `False` 结果将会不同时。例如，`None OR False` 是 `None`，但 `None OR True` 是 `True`，因为谓词是 `True`，无论 `None` “实际上”代表 `True` 还是 `False`。在使用通常的 Python 逻辑运算符如 `and`、`or` 和 `not` 时，必须小心处理三值逻辑，因为 `None` 为假。有关如何使用三值逻辑编码的更多详细信息，请参阅符号和模糊布尔值指南。

假设系统使用三值逻辑表示未知的假设。例如，如果在给定的假设下 `x.is_positive` 可能是 `None`，因为 `x` 可以是正数或负数。请注意，由布尔子类定义的谓词逻辑表示标准的二值逻辑，而不是三值逻辑。

未定义函数

*未定义函数*是函数的一种，在其上没有定义数学属性。它始终保持未评估，例如 `f(x)`。通过将函数的字符串名称传递给 `Function`，例如 `f = Function('f')`，可以创建未定义函数。在处理 ODEs 时，通常使用未定义函数。未定义函数还是制造符号的最简单方法，这些符号在数学上依赖于其他符号。例如，如果 `f = Function('f')` 和 `x = Symbol('x')`，那么 SymPy 将知道 `f(x)` 取决于 `x`，这意味着例如导数 `diff(f(x), x)` 不会被评估为 `0`。

未评估

如果自动化简在创建表达式时被禁用，则表达式是*未评估*的。通常通过设置 `evaluate=False`，使用 `with evaluate(False)` 或使用 `UnevaluatedExpr` 来完成这一点。虽然支持未评估表达式，但有时会导致意外行为，因为表达式未正确规范化。

术语*未评估*有时也用来表示当其参数是符号的时，表达式不会评估为特定值。

`zoo`

*`zoo`* 代表[复无穷](https://mathworld.wolfram.com/ComplexInfinity.html)，即[Riemann 球面](https://en.wikipedia.org/wiki/Riemann_sphere)的北极。它这样拼写的原因是，“z-oo”，其中“z”通常用于复变量的符号，而 oo 则是 SymPy 用于正无穷的符号。
