- en: Assume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/assumptions/assume.html](https://docs.sympy.org/latest/modules/assumptions/assume.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A module which implements predicates and assumption context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The class of expressions resulting from applying `Predicate` to the arguments.
    `AppliedPredicate` merely wraps its argument and remain unevaluated. To evaluate
    it, use the `ask()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `function` attribute returns the predicate, and the `arguments` attribute
    returns the tuple of arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Applied predicates can be evaluated to a boolean value with `ask`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Return the expression used by this assumption.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Return the arguments which are applied to the predicate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Return the predicate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Set containing default assumptions which are applied to the `ask()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This is used to represent global assumptions, but you can also use this class
    to create your own local assumptions contexts. It is basically a thin wrapper
    to Python’s set, so see its documentation for advanced usage.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'The default assumption context is `global_assumptions`, which is initially
    empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can add default assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And remove them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clear()` method removes every assumption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`assuming`](#sympy.assumptions.assume.assuming "sympy.assumptions.assume.assuming")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Add assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Base class for mathematical predicates. It also serves as a constructor for
    undefined predicate objects.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Predicate is a function that returns a boolean value [1].
  prefs: []
  type: TYPE_NORMAL
- en: Predicate function is object, and it is instance of predicate class. When a
    predicate is applied to arguments, `AppliedPredicate` instance is returned. This
    merely wraps the argument and remain unevaluated. To obtain the truth value of
    applied predicate, use the function `ask`.
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation of predicate is done by multiple dispatching. You can register new
    handler to the predicate to support new types.
  prefs: []
  type: TYPE_NORMAL
- en: Every predicate in SymPy can be accessed via the property of `Q`. For example,
    `Q.even` returns the predicate which checks if the argument is even number.
  prefs: []
  type: TYPE_NORMAL
- en: To define a predicate which can be evaluated, you must subclass this class,
    make an instance of it, and register it to `Q`. After then, dispatch the handler
    by argument types.
  prefs: []
  type: TYPE_NORMAL
- en: If you directly construct predicate using this class, you will get `UndefinedPredicate`
    which cannot be dispatched. This is useful when you are building boolean expressions
    which do not need to be evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Applying and evaluating to boolean value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can define a new predicate by subclassing and dispatching. Here, we define
    a predicate for sexy primes [2] as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Direct constructing returns `UndefinedPredicate`, which can be applied but cannot
    be dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R5](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Predicate_%28mathematical_logic%29](https://en.wikipedia.org/wiki/Predicate_%28mathematical_logic%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R6](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Sexy_prime](https://en.wikipedia.org/wiki/Sexy_prime)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Evaluate `self(*args)` under the given assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: This uses only direct resolution methods, not logical inference.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Register the signature to the handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Register multiple signatures to same handler.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Predicate without handler.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This predicate is generated by using `Predicate` directly for construction.
    It does not have a handler, and evaluating this with arguments is done by SAT
    solver.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Context manager for assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
