# 遍历数组

> 原文：[`numpy.org/doc/1.26/reference/arrays.nditer.html`](https://numpy.org/doc/1.26/reference/arrays.nditer.html)

注意

数组支持迭代器协议，可以像 Python 列表一样进行迭代。查看快速入门指南中的“索引、切片和迭代”部分，了解基本用法和示例。本文档的其余部分介绍了`nditer`对象，并涵盖了更高级的用法。

`nditer`迭代器对象在 NumPy 1.6 中引入，提供了许多灵活的方式以系统化的方式访问一个或多个数组的所有元素。本页面介绍了如何在 Python 中对数组进行计算的一些基本方法，然后总结了如何可以在 Cython 中加速内部循环。由于 Python 对`nditer`的暴露相对直接地映射了 C 数组迭代器 API，这些想法也将对使用 C 或 C++进行数组迭代工作提供帮助。

## 单数组迭代

`nditer`最基本的任务是访问数组的每个元素。使用标准的 Python 迭代器接口逐个提供每个元素。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a):
...     print(x, end=' ')
...
0 1 2 3 4 5 
```

对于这种迭代需要注意的重要事项是，顺序是选择与数组的内存布局匹配而不是使用标准的 C 或 Fortran 顺序。这样做是为了访问效率，体现了默认情况下只需访问每个元素而不考虑特定顺序的思想。通过迭代前一数组的转置，与以 C 顺序复制该转置进行比较，我们可以看到这一点。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a.T):
...     print(x, end=' ')
...
0 1 2 3 4 5 
```

```py
>>> for x in np.nditer(a.T.copy(order='C')):
...     print(x, end=' ')
...
0 3 1 4 2 5 
```

*a*和*a.T*的元素以相同顺序遍历，即它们在内存中存储的顺序，而*a.T.copy(order=’C’)*的元素以不同顺序访问，因为它们已经放置到不同的内存布局中。

### 控制迭代顺序

有时重要的是按照特定顺序访问数组的元素，而不考虑内存中元素的布局。`nditer`对象提供了一个*order*参数来控制迭代的这个方面。默认情况下，具有上述行为的行为是 order=’K’以保持现有顺序。这可以通过 order=’C’覆盖为 C 顺序和 order=’F’为 Fortran 顺序。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a, order='F'):
...     print(x, end=' ')
...
0 3 1 4 2 5
>>> for x in np.nditer(a.T, order='C'):
...     print(x, end=' ')
...
0 3 1 4 2 5 
```

### 修改数组值

默认情况下，`nditer`将输入操作数视为只读对象。要能够修改数组元素，必须使用*‘readwrite’*或*‘writeonly’*每个操作数标记来指定读写或仅写模式。

nditer 然后将生成可修改的缓冲区数组。然而，因为 nditer 必须在迭代结束时将此缓冲区数据复制回原始数组，所以必须通过两种方法之一来标志迭代何时结束。您可以选择：

> +   以*with*语句使用 nditer 作为上下文管理器，并在上下文退出时将临时数据写回。
> +   
> +   在迭代结束时调用迭代器的*close*方法，这将触发写回操作。

迭代器不能在*close*被调用或者它的上下文退出后继续迭代。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> a
array([[0, 1, 2],
 [3, 4, 5]])
>>> with np.nditer(a, op_flags=['readwrite']) as it:
...    for x in it:
...        x[...] = 2 * x
...
>>> a
array([[ 0,  2,  4],
 [ 6,  8, 10]]) 
```

如果你正在编写需要支持较旧版本的 numpy 的代码，请注意，在 1.15 之前，`nditer`不是一个上下文管理器，并且没有*close*方法。相反，它依靠析构函数来初始化缓冲区的写回。

### 使用外部循环

到目前为止，所有的示例中，*a*的元素都是由迭代器逐个提供的，因为所有的循环逻辑都是迭代器内部的。虽然这很简单和方便，但效率不高。更好的方法是将一维内层循环移到你的代码中，迭代器之外。这样，NumPy 的矢量化操作可以在更大的元素块上使用。

`nditer`将尝试提供尽可能大的块给内部循环。通过强制使用'C'和'F'顺序，我们可以得到不同的外部循环大小。通过指定迭代器标志来启用此模式。

注意，默认情况下保持本机内存顺序，迭代器能够提供一个单一的一维块，而当强制使用 Fortran 顺序时，它必须提供三个块，每个块有两个元素。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a, flags=['external_loop']):
...     print(x, end=' ')
...
[0 1 2 3 4 5] 
```

```py
>>> for x in np.nditer(a, flags=['external_loop'], order='F'):
...     print(x, end=' ')
...
[0 3] [1 4] [2 5] 
```

### 跟踪一个索引或多索引

在迭代过程中，您可能希望在计算中使用当前元素的索引。例如，您可能希望以内存顺序访问数组的元素，但使用 C 顺序、Fortran 顺序或多维索引在不同的数组中查找值。

索引由迭代器对象本身跟踪，并通过*index*或*multi_index*属性访问，具体取决于请求了哪个。下面的示例展示了打印输出，展示了索引的进展：

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> it = np.nditer(a, flags=['f_index'])
>>> for x in it:
...     print("%d <%d>" % (x, it.index), end=' ')
...
0 <0> 1 <2> 2 <4> 3 <1> 4 <3> 5 <5> 
```

```py
>>> it = np.nditer(a, flags=['multi_index'])
>>> for x in it:
...     print("%d <%s>" % (x, it.multi_index), end=' ')
...
0 <(0, 0)> 1 <(0, 1)> 2 <(0, 2)> 3 <(1, 0)> 4 <(1, 1)> 5 <(1, 2)> 
```

```py
>>> with np.nditer(a, flags=['multi_index'], op_flags=['writeonly']) as it:
...     for x in it:
...         x[...] = it.multi_index[1] - it.multi_index[0]
...
>>> a
array([[ 0,  1,  2],
 [-1,  0,  1]]) 
```

跟踪一个索引或多索引与使用外部循环不兼容，因为它需要每个元素一个不同的索引值。如果尝试组合这些标志，`nditer`对象将引发异常。

示例

```py
>>> a = np.zeros((2,3))
>>> it = np.nditer(a, flags=['c_index', 'external_loop'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: Iterator flag EXTERNAL_LOOP cannot be used if an index or multi-index is being tracked 
```

### 替代循环和元素访问

为了在迭代时更方便地访问其属性，`nditer`具有与迭代器对象本身明确工作的用于迭代的替代语法。通过这种循环结构，可以通过对迭代器进行索引来访问当前值。其它属性，例如跟踪的索引，保持与之前相同。下面的示例产生了与前一节中相同的结果。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> it = np.nditer(a, flags=['f_index'])
>>> while not it.finished:
...     print("%d <%d>" % (it[0], it.index), end=' ')
...     is_not_finished = it.iternext()
...
0 <0> 1 <2> 2 <4> 3 <1> 4 <3> 5 <5> 
```

```py
>>> it = np.nditer(a, flags=['multi_index'])
>>> while not it.finished:
...     print("%d <%s>" % (it[0], it.multi_index), end=' ')
...     is_not_finished = it.iternext()
...
0 <(0, 0)> 1 <(0, 1)> 2 <(0, 2)> 3 <(1, 0)> 4 <(1, 1)> 5 <(1, 2)> 
```

```py
>>> with np.nditer(a, flags=['multi_index'], op_flags=['writeonly']) as it:
...     while not it.finished:
...         it[0] = it.multi_index[1] - it.multi_index[0]
...         is_not_finished = it.iternext()
...
>>> a
array([[ 0,  1,  2],
 [-1,  0,  1]]) 
```

### 对数组元素进行缓冲

在强制迭代顺序时，我们观察到外部循环选项可能以较小的块提供元素，因为元素不能以恒定步长按适当顺序访问。在编写 C 代码时，这通常没问题，但在纯 Python 代码中，这可能会导致性能显着降低。

通过启用缓冲模式，迭代器提供给内部循环的块可以变得更大，从而显着减少了 Python 解释器的开销。在强制 Fortran 迭代顺序的示例中，启用缓冲时，内部循环可以一次看到所有元素。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a, flags=['external_loop'], order='F'):
...     print(x, end=' ')
...
[0 3] [1 4] [2 5] 
```

```py
>>> for x in np.nditer(a, flags=['external_loop','buffered'], order='F'):
...     print(x, end=' ')
...
[0 3 1 4 2 5] 
```

### 迭代特定数据类型

有时有必要将数组视为与其存储方式不同的数据类型。例如，即使被操作的数组是 32 位浮点数，也可能希望在 64 位浮点数上进行所有计算。除了编写低级 C 代码时，通常最好让迭代器处理复制或缓冲，而不是在内部循环中自己进行数据类型转换。

有两种机制可以实现这一点，临时复制和缓冲模式。通过临时复制，使用新数据类型制作整个数组的副本，然后对副本进行迭代。在所有迭代完成之后，可以通过更新原始数组的方式进行写访问。临时复制的主要缺点是，如果迭代数据类型的 itemsize 比原始数据类型更大，临时副本可能会占用大量内存。

缓冲模式减轻了内存使用问题，并且比制作临时副本更加缓存友好。除了特殊情况，在迭代器外需要一次性整个数组的情况下，推荐使用缓冲而不是临时复制。在 NumPy 中，ufuncs 和其他函数使用缓冲来支持以最小内存开销支持灵活输入。

在我们的示例中，我们将以复杂数据类型处理输入数组，以便我们可以对负数取平方根。在不启用复制或缓冲模式的情况下，如果数据类型与迭代器不精确匹配，迭代器将引发异常。

示例

```py
>>> a = np.arange(6).reshape(2,3) - 3
>>> for x in np.nditer(a, op_dtypes=['complex128']):
...     print(np.sqrt(x), end=' ')
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Iterator operand required copying or buffering, but neither copying nor buffering was enabled 
```

在复制模式中，“copy”被指定为每个操作数的标志。这是为了以每个操作数的方式提供控制。缓冲模式被指定为迭代器标志。

示例

```py
>>> a = np.arange(6).reshape(2,3) - 3
>>> for x in np.nditer(a, op_flags=['readonly','copy'],
...                 op_dtypes=['complex128']):
...     print(np.sqrt(x), end=' ')
...
1.7320508075688772j 1.4142135623730951j 1j 0j (1+0j) (1.4142135623730951+0j) 
```

```py
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['complex128']):
...     print(np.sqrt(x), end=' ')
...
1.7320508075688772j 1.4142135623730951j 1j 0j (1+0j) (1.4142135623730951+0j) 
```

迭代器使用 NumPy 的转换规则来确定是否允许特定的转换。默认情况下，它强制执行‘safe’转换。这意味着，例如，如果您尝试将 64 位浮点数数组视为 32 位浮点数数组，它会引发异常。在许多情况下，‘same_kind’规则是最合理的规则，因为它允许从 64 位转换为 32 位浮点数，但不允许从浮点数转换为整数或从复数转换为浮点数。

实例

```py
>>> a = np.arange(6.)
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['float32']):
...     print(x, end=' ')
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Iterator operand 0 dtype could not be cast from dtype('float64') to dtype('float32') according to the rule 'safe' 
```

```py
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['float32'],
...                 casting='same_kind'):
...     print(x, end=' ')
...
0.0 1.0 2.0 3.0 4.0 5.0 
```

```py
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['int32'], casting='same_kind'):
...     print(x, end=' ')
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Iterator operand 0 dtype could not be cast from dtype('float64') to dtype('int32') according to the rule 'same_kind' 
```

当使用读写或仅写操作数时，要注意的一点是在转换回原始数据类型时可能会遇到问题。一个常见情况是用 64 位浮点数实现内部循环，使用‘same_kind’转换来允许处理其他浮点类型。在只读模式下，可以提供一个整数数组，但在读写模式下会抛出异常，因为转换回数组会违反转换规则。

实例

```py
>>> a = np.arange(6)
>>> for x in np.nditer(a, flags=['buffered'], op_flags=['readwrite'],
...                 op_dtypes=['float64'], casting='same_kind'):
...     x[...] = x / 2.0
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: Iterator requested dtype could not be cast from dtype('float64') to dtype('int64'), the operand 0 dtype, according to the rule 'same_kind' 
```

## 广播数组迭代

NumPy 有一组规则用于处理形状不同的数组，惯例上在函数接受多个操作数时会对这些规则进行应用，这些操作数合并在一起进行元素级操作。这称为广播。`nditer`对象可以在需要编写这样一个函数时为您应用这些规则。

举个例子，我们打印出一个一维数组和一个二维数组进行广播的结果。

实例

```py
>>> a = np.arange(3)
>>> b = np.arange(6).reshape(2,3)
>>> for x, y in np.nditer([a,b]):
...     print("%d:%d" % (x,y), end=' ')
...
0:0 1:1 2:2 0:3 1:4 2:5 
```

当广播错误发生时，迭代器会引发一个异常，其中包括输入形状，以帮助诊断问题。

实例

```py
>>> a = np.arange(2)
>>> b = np.arange(6).reshape(2,3)
>>> for x, y in np.nditer([a,b]):
...     print("%d:%d" % (x,y), end=' ')
...
Traceback (most recent call last):
...
ValueError: operands could not be broadcast together with shapes (2,) (2,3) 
```

### 迭代器分配输出数组

NumPy 函数中的一个常见情况是根据输入的广播分配输出，并且还有一个名为‘out’的可选参数，用于提供结果位置。`nditer`对象提供了一个方便的习语，使得支持这种机制变得非常容易。

我们将通过创建一个`square`函数来展示它是如何工作的，该函数将输入的平方。让我们从一个最小的函数定义开始，不包括‘out’参数支持。

实例

```py
>>> def square(a):
...     with np.nditer([a, None]) as it:
...         for x, y in it:
...             y[...] = x*x
...         return it.operands[1]
...
>>> square([1,2,3])
array([1, 4, 9]) 
```

默认情况下，`nditer`对传入的为 None 的操作数使用标志‘allocate’和‘writeonly’。这意味着我们只需提供迭代器的两个操作数，它就会处理其余部分。

在添加‘out’参数时，我们必须显式提供这些标志，因为如果有人将数组作为‘out’传入，迭代器将默认为‘readonly’，而我们的内部循环会失败。‘readonly’是输入数组的默认选项是为了防止意外触发减少操作的混淆。如果默认选项是‘readwrite’，任何广播操作都会触发减少操作，这个主题稍后在本文档中会讨论。

顺便提一句，我们还要介绍‘no_broadcast’标志，它将阻止输出被广播。这很重要，因为我们只希望每个输出具有一个输入值。聚合多个输入值是一个需要特殊处理的约简操作。虽然会因为迭代器标志未明确启用约简而引发错误，但其结果仅限于禁用广播的错误消息对最终用户更加易懂。要查看如何将平方函数推广为约简函数，请查看有关 Cython 部分中的平方和函数。

为了完整起见，我们还将添加‘external_loop’和‘buffered’标志，因为出于性能原因，这些通常是您想要的。

示例

```py
>>> def square(a, out=None):
...     it = np.nditer([a, out],
...             flags = ['external_loop', 'buffered'],
...             op_flags = [['readonly'],
...                         ['writeonly', 'allocate', 'no_broadcast']])
...     with it:
...         for x, y in it:
...             y[...] = x*x
...         return it.operands[1]
... 
```

```py
>>> square([1,2,3])
array([1, 4, 9]) 
```

```py
>>> b = np.zeros((3,))
>>> square([1,2,3], out=b)
array([1.,  4.,  9.])
>>> b
array([1.,  4.,  9.]) 
```

```py
>>> square(np.arange(6).reshape(2,3), out=b)
Traceback (most recent call last):
  ...
ValueError: non-broadcastable output operand with shape (3,) doesn't
match the broadcast shape (2,3) 
```

### 外积迭代

任何二进制操作都可以像`outer`中一样以外积方式扩展为数组操作，`nditer`对象通过显式映射操作数的轴提供了一种实现这一点的方法。也可以使用`newaxis`索引来完成这个操作，但我们将向您展示如何直接使用 nditer 的*op_axes*参数来在没有中间视图的情况下完成此操作。

我们将进行一个简单的外积计算，将第一个操作数的维度放在第二个操作数的维度之前。*op_axes*参数需要为每个操作数提供一个包含轴的列表，并提供了一个从迭代器的轴到操作数的轴的映射。

假设第一个操作数是一维的，第二个操作数是二维的。迭代器将具有三个维度，因此*op_axes*将有两个包含三个元素的列表。第一个列表选择第一个操作数的一个轴，其余迭代器轴为-1，最终结果为[0, -1, -1]。第二个列表选择第二个操作数的两个轴，但不应与第一个操作数中选择的轴重叠。它的列表是[-1, 0, 1]。输出操作数按照标准方式映射到迭代器轴上，因此我们可以提供 None 而不是构造另一个列表。

在内部循环中的操作是直接乘法。所有外积相关的事情都由迭代器设置处理。

示例

```py
>>> a = np.arange(3)
>>> b = np.arange(8).reshape(2,4)
>>> it = np.nditer([a, b, None], flags=['external_loop'],
...             op_axes=[[0, -1, -1], [-1, 0, 1], None])
>>> with it:
...     for x, y, z in it:
...         z[...] = x*y
...     result = it.operands[2]  # same as z
...
>>> result
array([[[ 0,  0,  0,  0],
 [ 0,  0,  0,  0]],
 [[ 0,  1,  2,  3],
 [ 4,  5,  6,  7]],
 [[ 0,  2,  4,  6],
 [ 8, 10, 12, 14]]]) 
```

请注意，一旦迭代器关闭，我们就无法访问`operands`，而必须使用在上下文管理器中创建的引用。

### 约简迭代

每当可写操作数的元素少于完整迭代空间时，该操作数正在进行约简。`nditer`对象要求任何约简操作数都被标记为读写，并且仅在提供‘reduce_ok’作为迭代器标志时允许约简。

以简单的例子为例，考虑计算数组中所有元素的和。

例子

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> b = np.array(0)
>>> with np.nditer([a, b], flags=['reduce_ok'],
...                     op_flags=[['readonly'], ['readwrite']]) as it:
...     for x,y in it:
...         y[...] += x
...
>>> b
array(276)
>>> np.sum(a)
276 
```

当组合约简和分配操作数时，情况变得有点棘手。在开始迭代之前，任何约简操作数必须初始化为其起始值。以下是我们如何做到这一点，对*a*的最后一个轴进行求和。

例子

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> it = np.nditer([a, None], flags=['reduce_ok'],
...             op_flags=[['readonly'], ['readwrite', 'allocate']],
...             op_axes=[None, [0,1,-1]])
>>> with it:
...     it.operands[1][...] = 0
...     for x, y in it:
...         y[...] += x
...     result = it.operands[1]
...
>>> result
array([[ 6, 22, 38],
 [54, 70, 86]])
>>> np.sum(a, axis=2)
array([[ 6, 22, 38],
 [54, 70, 86]]) 
```

进行缓冲进行约简需要在设置期间进行另一个调整。通常，迭代器构造涉及将可读数组的第一个缓冲区复制到缓冲区中。任何约简操作数都是可读的，所以它可能被读入缓冲区。不幸的是，在这个缓冲操作完成后初始化操作数的值将不会反映在迭代开始时的缓冲区中，将产生垃圾结果。

迭代器标志“delay_bufalloc”用于允许迭代器分配的约简操作数与缓冲共存。设置此标志时，迭代器将保留其缓冲区，直到接收到重置信号，之后将准备好进行常规迭代。如果我们同时启用缓冲，那么前面的例子看起来是这样的。

例子

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> it = np.nditer([a, None], flags=['reduce_ok',
...                                  'buffered', 'delay_bufalloc'],
...             op_flags=[['readonly'], ['readwrite', 'allocate']],
...             op_axes=[None, [0,1,-1]])
>>> with it:
...     it.operands[1][...] = 0
...     it.reset()
...     for x, y in it:
...         y[...] += x
...     result = it.operands[1]
...
>>> result
array([[ 6, 22, 38],
 [54, 70, 86]]) 
```

## 将内部循环放入 Cython 中

那些希望从他们的低级操作中获得真正好的性能的人应该强烈考虑直接使用 C 提供的迭代 API，但对于那些不熟悉 C 或 C++的人来说，Cython 是一个性能合理的中间选择。对于`nditer`对象，这意味着让迭代器负责广播、数据类型转换和缓冲，同时将内部循环交给 Cython 处理。

举个例子，我们将创建一个平方和函数。首先，让我们在简单的 Python 中实现这个函数。我们想要支持一个类似于 numpy `sum` 函数的‘axis’参数，因此我们需要为*op_axes*参数构建一个列表。这是看起来的样子。

例子

```py
>>> def axis_to_axeslist(axis, ndim):
...     if axis is None:
...         return [-1] * ndim
...     else:
...         if type(axis) is not tuple:
...             axis = (axis,)
...         axeslist = [1] * ndim
...         for i in axis:
...             axeslist[i] = -1
...         ax = 0
...         for i in range(ndim):
...             if axeslist[i] != -1:
...                 axeslist[i] = ax
...                 ax += 1
...         return axeslist
...
>>> def sum_squares_py(arr, axis=None, out=None):
...     axeslist = axis_to_axeslist(axis, arr.ndim)
...     it = np.nditer([arr, out], flags=['reduce_ok',
...                                       'buffered', 'delay_bufalloc'],
...                 op_flags=[['readonly'], ['readwrite', 'allocate']],
...                 op_axes=[None, axeslist],
...                 op_dtypes=['float64', 'float64'])
...     with it:
...         it.operands[1][...] = 0
...         it.reset()
...         for x, y in it:
...             y[...] += x*x
...         return it.operands[1]
...
>>> a = np.arange(6).reshape(2,3)
>>> sum_squares_py(a)
array(55.)
>>> sum_squares_py(a, axis=-1)
array([  5.,  50.]) 
```

要将这个函数 Cython 化，我们将内部循环（y[…] += x*x）替换为针对 float64 数据类型专门化的 Cython 代码。启用‘external_loop’标志后，提供给内部循环的数组将始终是一维的，因此几乎不需要进行太多的检查。

这是 sum_squares.pyx 的代码清单：

```py
import numpy as np
cimport numpy as np
cimport cython

def axis_to_axeslist(axis, ndim):
    if axis is None:
        return [-1] * ndim
    else:
        if type(axis) is not tuple:
            axis = (axis,)
        axeslist = [1] * ndim
        for i in axis:
            axeslist[i] = -1
        ax = 0
        for i in range(ndim):
            if axeslist[i] != -1:
                axeslist[i] = ax
                ax += 1
        return axeslist

@cython.boundscheck(False)
def sum_squares_cy(arr, axis=None, out=None):
    cdef np.ndarray[double] x
    cdef np.ndarray[double] y
    cdef int size
    cdef double value

    axeslist = axis_to_axeslist(axis, arr.ndim)
    it = np.nditer([arr, out], flags=['reduce_ok', 'external_loop',
                                      'buffered', 'delay_bufalloc'],
                op_flags=[['readonly'], ['readwrite', 'allocate']],
                op_axes=[None, axeslist],
                op_dtypes=['float64', 'float64'])
    with it:
        it.operands[1][...] = 0
        it.reset()
        for xarr, yarr in it:
            x = xarr
            y = yarr
            size = x.shape[0]
            for i in range(size):
               value = x[i]
               y[i] = y[i] + value * value
        return it.operands[1] 
```

在这台机器上，将 .pyx 文件构建为一个模块如下，但你可能需要找一些 Cython 教程来告诉你系统配置的具体情况。：

```py
$ cython sum_squares.pyx
$ gcc -shared -pthread -fPIC -fwrapv -O2 -Wall -I/usr/include/python2.7 -fno-strict-aliasing -o sum_squares.so sum_squares.c 
```

从 Python 解释器运行这个函数会产生与我们原生的 Python/NumPy 代码相同的答案。

例子

```py
>>> from sum_squares import sum_squares_cy 
>>> a = np.arange(6).reshape(2,3)
>>> sum_squares_cy(a) 
array(55.0)
>>> sum_squares_cy(a, axis=-1) 
array([  5.,  50.]) 
```

在 IPython 中进行一点时间测试显示，Cython 内部循环减少的开销和内存分配为我们提供了一个非常好的加速效果，比起直接的 Python 代码和使用 NumPy 内置的求和函数表达式要好得多。

```py
>>> a = np.random.rand(1000,1000)

>>> timeit sum_squares_py(a, axis=-1)
10 loops, best of 3: 37.1 ms per loop

>>> timeit np.sum(a*a, axis=-1)
10 loops, best of 3: 20.9 ms per loop

>>> timeit sum_squares_cy(a, axis=-1)
100 loops, best of 3: 11.8 ms per loop

>>> np.all(sum_squares_cy(a, axis=-1) == np.sum(a*a, axis=-1))
True

>>> np.all(sum_squares_py(a, axis=-1) == np.sum(a*a, axis=-1))
True 
```

## 单个数组迭代

使用`nditer`可以完成的最基本任务是访问数组的每个元素。使用标准的 Python 迭代器接口，每个元素会逐个提供。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a):
...     print(x, end=' ')
...
0 1 2 3 4 5 
```

对于这种迭代，需要注意的一点是迭代顺序是选择与数组的内存布局匹配，而不是使用标准的 C 或 Fortran 顺序。这样做是为了提高访问效率，反映了默认情况下，简单地希望访问每个元素而不关注特定的顺序的想法。我们可以通过迭代我们上一个数组的转置来看到这一点，与以 C 顺序复制该转置的方式进行比较。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a.T):
...     print(x, end=' ')
...
0 1 2 3 4 5 
```

```py
>>> for x in np.nditer(a.T.copy(order='C')):
...     print(x, end=' ')
...
0 3 1 4 2 5 
```

*a*和*a.T*的元素以相同的顺序遍历，即它们在内存中存储的顺序，而*a.T.copy(order='C')*的元素以不同的顺序访问，因为它们已经被放置在不同的内存布局中。

### 控制迭代顺序

有时候，重要的是按照特定的顺序访问数组的元素，而不论内存中元素的布局如何。`nditer`对象提供了一个*order*参数来控制迭代的这个方面。默认情况下，该参数的行为如上所述，为 order='K'，保持现有顺序。可以使用 order='C'来强制使用 C 顺序，order='F'来强制使用 Fortran 顺序。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a, order='F'):
...     print(x, end=' ')
...
0 3 1 4 2 5
>>> for x in np.nditer(a.T, order='C'):
...     print(x, end=' ')
...
0 3 1 4 2 5 
```

### 修改数组值

默认情况下，`nditer`将输入操作数视为只读对象。要能够修改数组元素，必须使用*‘readwrite’*或*‘writeonly’*的每个操作数标志指定读写或只写模式。

nditer 将产生可写入的缓冲数组，您可以修改这些数组。然而，由于 nditer 必须在迭代结束时将该缓冲区数据复制回原始数组，因此您必须在迭代结束时发出信号，可以采用以下两种方法之一。可以选择：

> +   当使用*with*语句将`nditer`作为上下文管理器时，临时数据将在退出上下文时写回。
> +   
> +   迭代结束后，调用迭代器的*close*方法，将触发写回。

一旦调用*close*或退出上下文，`nditer`将无法再迭代。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> a
array([[0, 1, 2],
 [3, 4, 5]])
>>> with np.nditer(a, op_flags=['readwrite']) as it:
...    for x in it:
...        x[...] = 2 * x
...
>>> a
array([[ 0,  2,  4],
 [ 6,  8, 10]]) 
```

如果你正在编写需要支持旧版本 numpy 的代码，请注意在 1.15 之前，`nditer`不是上下文管理器，也没有*close*方法。相反，它依赖于析构函数来启动缓冲区的写回。

### 使用外部循环

到目前为止的所有示例中，迭代器一次只提供一个元素，因为所有循环逻辑都是迭代器内部的。虽然这很简单和方便，但效率不高。更好的方法是将一维最内层循环移到你的代码中，外部超过迭代器。这样，NumPy 的向量化操作可以用于正在访问的元素的更大块。

`nditer`将尝试为内部循环提供尽可能大的块。强制使用‘C’和‘F’顺序时，我们得到不同的外部循环大小。可以通过指定迭代器标志来启用此模式。

注意，默认保留本机内存顺序，迭代器能够提供单个一维块，而强制 Fortran 顺序时，它必须提供三个每个两个元素的块。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a, flags=['external_loop']):
...     print(x, end=' ')
...
[0 1 2 3 4 5] 
```

```py
>>> for x in np.nditer(a, flags=['external_loop'], order='F'):
...     print(x, end=' ')
...
[0 3] [1 4] [2 5] 
```

### 跟踪索引或多索引

在迭代过程中，您可能希望在计算中使用当前元素的索引。例如，您可能希望以内存顺序访问数组的元素，但使用 C 顺序、Fortran 顺序或多维索引来查找不同数组中的值。

索引由迭代器对象本身跟踪，并通过*index*或*multi_index*属性访问，具体取决于所请求的内容。下面的示例显示了打印输出，用于演示索引的变化：

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> it = np.nditer(a, flags=['f_index'])
>>> for x in it:
...     print("%d <%d>" % (x, it.index), end=' ')
...
0 <0> 1 <2> 2 <4> 3 <1> 4 <3> 5 <5> 
```

```py
>>> it = np.nditer(a, flags=['multi_index'])
>>> for x in it:
...     print("%d <%s>" % (x, it.multi_index), end=' ')
...
0 <(0, 0)> 1 <(0, 1)> 2 <(0, 2)> 3 <(1, 0)> 4 <(1, 1)> 5 <(1, 2)> 
```

```py
>>> with np.nditer(a, flags=['multi_index'], op_flags=['writeonly']) as it:
...     for x in it:
...         x[...] = it.multi_index[1] - it.multi_index[0]
...
>>> a
array([[ 0,  1,  2],
 [-1,  0,  1]]) 
```

跟踪索引或多索引与使用外部循环不兼容，因为每个元素需要不同的索引值。如果尝试结合这些标志，`nditer`对象将引发异常。

示例

```py
>>> a = np.zeros((2,3))
>>> it = np.nditer(a, flags=['c_index', 'external_loop'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: Iterator flag EXTERNAL_LOOP cannot be used if an index or multi-index is being tracked 
```

### 替代循环和元素访问

为了在迭代过程中更容易地使用其属性，`nditer`具有一种替代语法，可以显式地使用迭代器对象本身进行迭代。使用这种循环结构，可以通过对迭代器进行索引来访问当前值。其他属性，如跟踪的索引与之前一样。下面的示例产生与前一节中相同的结果。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> it = np.nditer(a, flags=['f_index'])
>>> while not it.finished:
...     print("%d <%d>" % (it[0], it.index), end=' ')
...     is_not_finished = it.iternext()
...
0 <0> 1 <2> 2 <4> 3 <1> 4 <3> 5 <5> 
```

```py
>>> it = np.nditer(a, flags=['multi_index'])
>>> while not it.finished:
...     print("%d <%s>" % (it[0], it.multi_index), end=' ')
...     is_not_finished = it.iternext()
...
0 <(0, 0)> 1 <(0, 1)> 2 <(0, 2)> 3 <(1, 0)> 4 <(1, 1)> 5 <(1, 2)> 
```

```py
>>> with np.nditer(a, flags=['multi_index'], op_flags=['writeonly']) as it:
...     while not it.finished:
...         it[0] = it.multi_index[1] - it.multi_index[0]
...         is_not_finished = it.iternext()
...
>>> a
array([[ 0,  1,  2],
 [-1,  0,  1]]) 
```

### 缓冲数组元素

在强制迭代顺序时，我们观察到外部循环选项可能会以较小的块提供元素，因为元素不能以恒定的步长以恰当的顺序访问。在编写 C 代码时，这通常没问题，然而在纯 Python 代码中，这可能会导致性能显著下降。

通过启用缓冲模式，迭代器传递给内部循环的块可以更大，大大减少了 Python 解释器的开销。在例子中强制 Fortran 迭代顺序时，启用缓冲时，内部循环可以一次性看到所有元素。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a, flags=['external_loop'], order='F'):
...     print(x, end=' ')
...
[0 3] [1 4] [2 5] 
```

```py
>>> for x in np.nditer(a, flags=['external_loop','buffered'], order='F'):
...     print(x, end=' ')
...
[0 3 1 4 2 5] 
```

### 作为特定数据类型迭代

有时候需要将数组视为与其存储的不同数据类型。例如，即使被操作的数组是 32 位浮点数，可以要求在所有计算中都使用 64 位浮点数进行。除非编写低级 C 代码，通常最好让迭代器处理拷贝或缓冲，而不是在内部循环中自己进行数据类型转换。

有两种机制可以实现这个目标，即临时拷贝和缓冲模式。使用临时拷贝，会使用新的数据类型创建整个数组的副本，然后对副本进行迭代。在所有迭代完成后，可以通过一种模式对原始数组进行写入访问。临时拷贝的主要缺点是，如果迭代数据类型的 itemsize 大于原始数据类型的 itemsize，临时拷贝可能会消耗大量内存。

缓冲模式可以减少内存使用，并且比临时拷贝更加高效。除了一些特殊情况，例如在迭代器外部需要使用整个数组时，建议使用缓冲模式代替临时拷贝。在 NumPy 中，缓冲模式被 ufuncs 和其他函数用于支持灵活输入，并且内存开销很小。

在我们的示例中，我们将使用复杂数据类型处理输入数组，以便我们可以对负数进行平方根运算。如果不启用拷贝或缓冲模式，迭代器将在数据类型不精确匹配时引发异常。

示例

```py
>>> a = np.arange(6).reshape(2,3) - 3
>>> for x in np.nditer(a, op_dtypes=['complex128']):
...     print(np.sqrt(x), end=' ')
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Iterator operand required copying or buffering, but neither copying nor buffering was enabled 
```

在拷贝模式下，可以通过每个操作数的标志“copy”来指定。这样可以提供按操作数的方式进行控制。缓冲模式可以通过一个迭代器标志来指定。

示例

```py
>>> a = np.arange(6).reshape(2,3) - 3
>>> for x in np.nditer(a, op_flags=['readonly','copy'],
...                 op_dtypes=['complex128']):
...     print(np.sqrt(x), end=' ')
...
1.7320508075688772j 1.4142135623730951j 1j 0j (1+0j) (1.4142135623730951+0j) 
```

```py
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['complex128']):
...     print(np.sqrt(x), end=' ')
...
1.7320508075688772j 1.4142135623730951j 1j 0j (1+0j) (1.4142135623730951+0j) 
```

迭代器使用 NumPy 的类型转换规则来确定是否允许特定的转换。默认情况下，它实施“safe”类型转换。这意味着，例如，如果尝试将 64 位浮点数组视为 32 位浮点数组，它将引发异常。在许多情况下，“same_kind”规则是最合理的规则，因为它允许从 64 位转换为 32 位浮点数，但不允许从浮点数转换为整数或从复数转换为浮点数。

示例

```py
>>> a = np.arange(6.)
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['float32']):
...     print(x, end=' ')
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Iterator operand 0 dtype could not be cast from dtype('float64') to dtype('float32') according to the rule 'safe' 
```

```py
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['float32'],
...                 casting='same_kind'):
...     print(x, end=' ')
...
0.0 1.0 2.0 3.0 4.0 5.0 
```

```py
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['int32'], casting='same_kind'):
...     print(x, end=' ')
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Iterator operand 0 dtype could not be cast from dtype('float64') to dtype('int32') according to the rule 'same_kind' 
```

使用读写或只写操作数进行转换回原始数据类型时需注意。常见的情况是使用 64 位浮点数实现内部循环，并使用“same_kind”类型转换以便处理其他浮点数类型。虽然在只读模式下可以提供整数数组，但在读写模式下将引发异常，因为转换回数组将违反类型转换规则。

示例

```py
>>> a = np.arange(6)
>>> for x in np.nditer(a, flags=['buffered'], op_flags=['readwrite'],
...                 op_dtypes=['float64'], casting='same_kind'):
...     x[...] = x / 2.0
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: Iterator requested dtype could not be cast from dtype('float64') to dtype('int64'), the operand 0 dtype, according to the rule 'same_kind' 
```

### 控制迭代顺序

有时重要的是以特定顺序访问数组的元素，不管元素在内存中的布局如何。`nditer` 对象提供了一个*order*参数来控制迭代的这个方面。默认情况下，保持上述行为的是 order=’K’以保持现有顺序。可以用 order=’C’覆盖为 C 顺序和 order=’F’为 Fortran 顺序。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a, order='F'):
...     print(x, end=' ')
...
0 3 1 4 2 5
>>> for x in np.nditer(a.T, order='C'):
...     print(x, end=' ')
...
0 3 1 4 2 5 
```

### 修改数组值

默认情况下，`nditer` 将输入操作数视为只读对象。要能够修改数组元素，必须使用*‘readwrite’*或*‘writeonly’*逐操作数标志指定读写或仅写模式。

然后 nditer 将生成可写入的缓冲区数组，您可以修改。然而，由于 nditer 在迭代结束后必须将此缓冲区数据复制回原始数组，因此必须通过两种方法之一来信号迭代结束。您可以：

> +   使用*with*语句将 nditer 作为上下文管理器使用，并且在退出上下文时将临时数据写回。
> +   
> +   在迭代完成后调用迭代器的*close*方法，这将触发写回。

一旦调用*close*或退出其上下文，nditer 将不再可迭代。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> a
array([[0, 1, 2],
 [3, 4, 5]])
>>> with np.nditer(a, op_flags=['readwrite']) as it:
...    for x in it:
...        x[...] = 2 * x
...
>>> a
array([[ 0,  2,  4],
 [ 6,  8, 10]]) 
```

如果您正在编写需要支持较旧版本的 numpy 的代码，请注意，在 1.15 之前，`nditer` 不是上下文管理器，也没有*close*方法。相反，它依赖析构函数来启动缓冲区的写回。

### 使用外部循环

到目前为止，所有示例中，*a* 中的元素都是由迭代器逐个提供的，因为所有循环逻辑都是迭代器内部的。虽然这种方法简单方便，但并不是很高效。更好的方法是将一维的内部循环移动到您的代码中，即在迭代器外部。这样，NumPy 的向量化操作可以用于正在访问的元素的更大块。

`nditer` 将尝试提供尽可能大的块给内部循环。通过强制‘C’和‘F’顺序，我们得到不同的外部循环大小。通过指定迭代器标志来启用此模式。

请注意，保持本机内存顺序的默认设置下，迭代器可以提供一个单一的一维块，而当强制 Fortran 顺序时，它必须提供三个每个两个元素的块。

示例

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a, flags=['external_loop']):
...     print(x, end=' ')
...
[0 1 2 3 4 5] 
```

```py
>>> for x in np.nditer(a, flags=['external_loop'], order='F'):
...     print(x, end=' ')
...
[0 3] [1 4] [2 5] 
```

### 跟踪一个索引或多维索引

在迭代过程中，您可能希望在计算中使用当前元素的索引。例如，您可能希望按内存顺序访问数组的元素，但使用 C 顺序、Fortran 顺序或多维索引来查找不同数组中的值。

索引由迭代器对象本身跟踪，并可以通过 *index* 或 *multi_index* 属性访问，具体取决于所请求的内容。下面的示例展示了打印输出，以演示索引的进展情况：

例子

```py
>>> a = np.arange(6).reshape(2,3)
>>> it = np.nditer(a, flags=['f_index'])
>>> for x in it:
...     print("%d <%d>" % (x, it.index), end=' ')
...
0 <0> 1 <2> 2 <4> 3 <1> 4 <3> 5 <5> 
```

```py
>>> it = np.nditer(a, flags=['multi_index'])
>>> for x in it:
...     print("%d <%s>" % (x, it.multi_index), end=' ')
...
0 <(0, 0)> 1 <(0, 1)> 2 <(0, 2)> 3 <(1, 0)> 4 <(1, 1)> 5 <(1, 2)> 
```

```py
>>> with np.nditer(a, flags=['multi_index'], op_flags=['writeonly']) as it:
...     for x in it:
...         x[...] = it.multi_index[1] - it.multi_index[0]
...
>>> a
array([[ 0,  1,  2],
 [-1,  0,  1]]) 
```

跟踪索引或多索引不兼容于使用外部循环，因为它需要每个元素一个不同的索引值。如果尝试结合这些标志，则`nditer`对象将引发异常。

例子

```py
>>> a = np.zeros((2,3))
>>> it = np.nditer(a, flags=['c_index', 'external_loop'])
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: Iterator flag EXTERNAL_LOOP cannot be used if an index or multi-index is being tracked 
```

### 替代循环和元素访问

为了在迭代过程中更容易访问其属性，`nditer`提供了另一种迭代的语法，它直接与迭代器对象本身一起工作。使用这种循环结构，可以通过对迭代器进行索引来访问当前值。其他属性，如跟踪的索引，保持不变。下面的示例生成了与前一节中相同的结果。

例子

```py
>>> a = np.arange(6).reshape(2,3)
>>> it = np.nditer(a, flags=['f_index'])
>>> while not it.finished:
...     print("%d <%d>" % (it[0], it.index), end=' ')
...     is_not_finished = it.iternext()
...
0 <0> 1 <2> 2 <4> 3 <1> 4 <3> 5 <5> 
```

```py
>>> it = np.nditer(a, flags=['multi_index'])
>>> while not it.finished:
...     print("%d <%s>" % (it[0], it.multi_index), end=' ')
...     is_not_finished = it.iternext()
...
0 <(0, 0)> 1 <(0, 1)> 2 <(0, 2)> 3 <(1, 0)> 4 <(1, 1)> 5 <(1, 2)> 
```

```py
>>> with np.nditer(a, flags=['multi_index'], op_flags=['writeonly']) as it:
...     while not it.finished:
...         it[0] = it.multi_index[1] - it.multi_index[0]
...         is_not_finished = it.iternext()
...
>>> a
array([[ 0,  1,  2],
 [-1,  0,  1]]) 
```

### 缓冲数组元素

在强制迭代顺序时，我们观察到外循环选项可能会以较小的块提供元素，因为元素不能以恒定的步幅按适当的顺序访问。在编写 C 代码时，这通常没问题，但在纯 Python 代码中，这可能会导致性能显著下降。

通过启用缓冲模式，可以使迭代器提供给内循环的块变得更大，从而显著降低 Python 解释器的开销。例如，强制使用 Fortran 迭代顺序时，当启用缓冲时，内循环可以一次性看到所有元素。

例子

```py
>>> a = np.arange(6).reshape(2,3)
>>> for x in np.nditer(a, flags=['external_loop'], order='F'):
...     print(x, end=' ')
...
[0 3] [1 4] [2 5] 
```

```py
>>> for x in np.nditer(a, flags=['external_loop','buffered'], order='F'):
...     print(x, end=' ')
...
[0 3 1 4 2 5] 
```

### 作为特定数据类型进行迭代

有时需要将数组视为存储时的不同数据类型。例如，即使被操作的数组是 32 位浮点数，也可能希望在 64 位浮点数上进行所有计算。除了编写低级 C 代码时，通常最好让迭代器处理复制或缓冲，而不是在内部循环中自己转换数据类型。

有两种机制可以实现这个目标，即临时副本和缓冲模式。使用临时副本时，会对整个数组进行新数据类型的复制，然后在副本上进行迭代。在迭代完成后，可以通过一种更新原数组的模式进行写入。临时副本的主要缺点在于，如果迭代数据类型的 itemsize 大于原始数据类型，临时副本可能会消耗大量内存。

缓冲模式缓解了内存使用问题，并且比制作临时副本更符合缓存的工作方式。除了一些特殊情况，需要在迭代器之外一次性使用整个数组时，建议使用缓冲而不是临时复制。在 NumPy 中，ufuncs 和其他函数使用缓冲支持具有最小内存开销的灵活输入。

在我们的例子中，我们将处理具有复杂数据类型的输入数组，以便我们可以对负数取平方根。如果数据类型不精确匹配，迭代器将在不启用复制或缓冲模式时引发异常。

例子

```py
>>> a = np.arange(6).reshape(2,3) - 3
>>> for x in np.nditer(a, op_dtypes=['complex128']):
...     print(np.sqrt(x), end=' ')
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Iterator operand required copying or buffering, but neither copying nor buffering was enabled 
```

在复制模式中，‘copy’被指定为每个操作数的标志。这样做是为了以每个操作数的方式来提供控制。缓冲模式被指定为迭代器标志。

例子

```py
>>> a = np.arange(6).reshape(2,3) - 3
>>> for x in np.nditer(a, op_flags=['readonly','copy'],
...                 op_dtypes=['complex128']):
...     print(np.sqrt(x), end=' ')
...
1.7320508075688772j 1.4142135623730951j 1j 0j (1+0j) (1.4142135623730951+0j) 
```

```py
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['complex128']):
...     print(np.sqrt(x), end=' ')
...
1.7320508075688772j 1.4142135623730951j 1j 0j (1+0j) (1.4142135623730951+0j) 
```

迭代器使用 NumPy 的转换规则来确定特定转换是否被允许。默认情况下，它执行‘safe’转换。这意味着，例如，如果尝试将 64 位浮点数组视为 32 位浮点数组，它会引发异常。在许多情况下，‘same_kind’规则是最合理的规则，因为它允许从 64 位转换为 32 位浮点，但不允许从浮点转换为整数或从复数转换为浮点。

例子

```py
>>> a = np.arange(6.)
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['float32']):
...     print(x, end=' ')
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Iterator operand 0 dtype could not be cast from dtype('float64') to dtype('float32') according to the rule 'safe' 
```

```py
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['float32'],
...                 casting='same_kind'):
...     print(x, end=' ')
...
0.0 1.0 2.0 3.0 4.0 5.0 
```

```py
>>> for x in np.nditer(a, flags=['buffered'], op_dtypes=['int32'], casting='same_kind'):
...     print(x, end=' ')
...
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: Iterator operand 0 dtype could not be cast from dtype('float64') to dtype('int32') according to the rule 'same_kind' 
```

要注意的一点是当使用可读写或仅写入操作数时，将数据类型转换回原始数据类型。一个常见情况是根据 64 位浮点实现内部循环，并使用‘same_kind’转换来允许处理其他浮点类型。在只读模式下，可以提供一个整数数组，而在读写模式下，将引发异常，因为转换回数组将违反转换规则。

例子

```py
>>> a = np.arange(6)
>>> for x in np.nditer(a, flags=['buffered'], op_flags=['readwrite'],
...                 op_dtypes=['float64'], casting='same_kind'):
...     x[...] = x / 2.0
...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
TypeError: Iterator requested dtype could not be cast from dtype('float64') to dtype('int64'), the operand 0 dtype, according to the rule 'same_kind' 
```

## 广播数组迭代

NumPy 有一组规则来处理具有不同形状的数组，这些规则适用于函数接受多个操作数并进行逐元素结合时。这被称为广播。当需要编写这样一个函数时，`nditer` 对象可以为您应用这些规则。

举个例子，我们打印出将一维和二维数组进行广播的结果。

例子

```py
>>> a = np.arange(3)
>>> b = np.arange(6).reshape(2,3)
>>> for x, y in np.nditer([a,b]):
...     print("%d:%d" % (x,y), end=' ')
...
0:0 1:1 2:2 0:3 1:4 2:5 
```

当发生广播错误时，迭代器会引发异常，其中包含输入形状以帮助诊断问题。

例子

```py
>>> a = np.arange(2)
>>> b = np.arange(6).reshape(2,3)
>>> for x, y in np.nditer([a,b]):
...     print("%d:%d" % (x,y), end=' ')
...
Traceback (most recent call last):
...
ValueError: operands could not be broadcast together with shapes (2,) (2,3) 
```

### 迭代器分配的输出数组

在 NumPy 函数中的一个常见情况是根据输入的广播分配输出，并且还有一个可选参数称为 ‘out’，为提供结果时提供位置。`nditer`对象提供了一个方便的习语，使得支持这一机制变得非常容易。

通过创建一个名为`square`的函数来展示它是如何工作的，该函数的作用是对输入进行平方。让我们从一个最简的函数定义开始，不包括‘out’参数支持。

例子

```py
>>> def square(a):
...     with np.nditer([a, None]) as it:
...         for x, y in it:
...             y[...] = x*x
...         return it.operands[1]
...
>>> square([1,2,3])
array([1, 4, 9]) 
```

默认情况下，`nditer` 对传入的 None 作为操作数使用‘allocate’和‘writeonly’标志。这意味着我们只需为迭代器提供这两个操作数，它会处理其余的。

当添加“out”参数时，我们必须明确提供这些标志，因为如果有人将数组作为“out”传入，则迭代器将默认为“readonly”，我们的内部循环将失败。 “readonly” 是输入数组的默认值的原因是为了防止意外触发缩减操作而引起混淆。 如果默认值为“readwrite”，任何广播操作也将触发缩减操作，这是本文档后面将涉及的一个主题。

在此之际，让我们也引入“no_broadcast”标志，这将阻止输出进行广播。 这很重要，因为我们只想要每个输出一个输入值。 聚合多个输入值是一个需要特殊处理的缩减操作。 它已经会引发错误，因为缩减必须在迭代器标志中明确启用，但是由于禁用广播而产生的错误消息对终端用户来说更容易理解。 要了解如何将平方函数推广到缩减，请查看有关 Cython 部分中的平方和函数。

为了完整起见，我们还将添加“external_loop”和“buffered”标志，因为出于性能原因，这通常是您所需要的。

示例

```py
>>> def square(a, out=None):
...     it = np.nditer([a, out],
...             flags = ['external_loop', 'buffered'],
...             op_flags = [['readonly'],
...                         ['writeonly', 'allocate', 'no_broadcast']])
...     with it:
...         for x, y in it:
...             y[...] = x*x
...         return it.operands[1]
... 
```

```py
>>> square([1,2,3])
array([1, 4, 9]) 
```

```py
>>> b = np.zeros((3,))
>>> square([1,2,3], out=b)
array([1.,  4.,  9.])
>>> b
array([1.,  4.,  9.]) 
```

```py
>>> square(np.arange(6).reshape(2,3), out=b)
Traceback (most recent call last):
  ...
ValueError: non-broadcastable output operand with shape (3,) doesn't
match the broadcast shape (2,3) 
```

### 外积迭代

任何二元操作都可以以类似于 `outer` 中的外积方式扩展为数组操作，并且 `nditer` 对象通过显式映射操作数的轴提供了一种实现此目的的方法。 也可以使用 `newaxis` 索引来完成此操作，但我们将向您展示如何直接使用 nditer 的 *op_axes* 参数来完成此操作，而无需中间视图。

我们将执行一个简单的外积，将第一个操作数的维度放在第二个操作数的维度之前。 *op_axes* 参数需要每个操作数的一个轴列表，并提供迭代器轴到操作数轴的映射。

假设第一个操作数是一维的，第二个操作数是二维的。 迭代器将有三个维度，因此 *op_axes* 将有两个 3 元素列表。 第一个列表选择第一个操作数的一个轴，并且对于迭代器的其余轴，它为 -1，最终结果为 [0, -1, -1]。 第二个列表选择第二个操作数的两个轴，但不应与第一个操作数中选择的轴重叠。 其列表为 [-1, 0, 1]。 输出操作数以标准方式映射到迭代器轴，因此我们可以提供 None 而不是构造另一个列表。

内循环中的操作是直接的乘法。 关于外积的所有内容都由迭代器设置处理。

示例

```py
>>> a = np.arange(3)
>>> b = np.arange(8).reshape(2,4)
>>> it = np.nditer([a, b, None], flags=['external_loop'],
...             op_axes=[[0, -1, -1], [-1, 0, 1], None])
>>> with it:
...     for x, y, z in it:
...         z[...] = x*y
...     result = it.operands[2]  # same as z
...
>>> result
array([[[ 0,  0,  0,  0],
 [ 0,  0,  0,  0]],
 [[ 0,  1,  2,  3],
 [ 4,  5,  6,  7]],
 [[ 0,  2,  4,  6],
 [ 8, 10, 12, 14]]]) 
```

请注意，一旦迭代器被关闭，我们就无法访问`operands`，必须使用在上下文管理器中创建的引用。

### 减少迭代

每当可写操作数的元素少于完整迭代空间时，该操作数都将经历一个减少。`nditer`对象要求任何减少操作数标记为读写，并且只允许在提供‘reduce_ok’作为迭代器标志时进行减少。

举个简单的例子，考虑对数组中所有元素进行求和。

例如

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> b = np.array(0)
>>> with np.nditer([a, b], flags=['reduce_ok'],
...                     op_flags=[['readonly'], ['readwrite']]) as it:
...     for x,y in it:
...         y[...] += x
...
>>> b
array(276)
>>> np.sum(a)
276 
```

将缩减和分配的操作数组合时会有一些复杂。在开始迭代之前，任何减少操作数都必须被初始化为其开始值。以下是我们如何做到这一点，对*a*的最后一个轴求和。

例如

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> it = np.nditer([a, None], flags=['reduce_ok'],
...             op_flags=[['readonly'], ['readwrite', 'allocate']],
...             op_axes=[None, [0,1,-1]])
>>> with it:
...     it.operands[1][...] = 0
...     for x, y in it:
...         y[...] += x
...     result = it.operands[1]
...
>>> result
array([[ 6, 22, 38],
 [54, 70, 86]])
>>> np.sum(a, axis=2)
array([[ 6, 22, 38],
 [54, 70, 86]]) 
```

要做缓冲减少需要在设置期间进行另一个调整。通常，迭代器构造涉及从可读数组中复制数据的第一个缓冲区。任何减少操作数都是可读取的，因此它可以被读取到缓冲区中。不幸的是，在这个缓冲操作完成之后初始化操作数不会反映在迭代开始时的缓冲区中，并且将产生垃圾结果。

迭代器标志“delay_bufalloc”是为了允许迭代器分配的缩减操作数与缓冲存在在一起。当设置了这个标志时，迭代器将保持其缓冲区未初始化，直到收到重置信号，之后它将准备好进行常规迭代。如果我们还启用缓冲，前面的示例将如下所示。

例如

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> it = np.nditer([a, None], flags=['reduce_ok',
...                                  'buffered', 'delay_bufalloc'],
...             op_flags=[['readonly'], ['readwrite', 'allocate']],
...             op_axes=[None, [0,1,-1]])
>>> with it:
...     it.operands[1][...] = 0
...     it.reset()
...     for x, y in it:
...         y[...] += x
...     result = it.operands[1]
...
>>> result
array([[ 6, 22, 38],
 [54, 70, 86]]) 
```

### 迭代器分配的输出数组

在 NumPy 函数中的一个常见情况是，根据输入的广播来分配输出，并且还有一个名为‘out’的可选参数，在提供结果时将其放置在那里。`nditer`对象提供了一个方便的习语，使得支持这种机制非常容易。

我们将通过创建一个函数`square`来展示这是如何工作的，它会对其输入进行平方操作。让我们从一个排除‘out’参数支持的最小函数定义开始。

例如

```py
>>> def square(a):
...     with np.nditer([a, None]) as it:
...         for x, y in it:
...             y[...] = x*x
...         return it.operands[1]
...
>>> square([1,2,3])
array([1, 4, 9]) 
```

默认情况下，`nditer`对于以 None 传入的操作数使用了‘allocate’和‘writeonly’标志。这意味着我们只需向迭代器提供两个操作数，剩下的交给它处理。

当添加‘out’参数时，必须明确提供这些标志，因为如果有人将数组传递给‘out’，迭代器将默认为‘readonly’，而我们的内部循环将失败。输入数组的默认值为‘readonly’是为了防止意外触发减少操作产生混淆。如果默认值是‘readwrite’，任何广播操作也会触发减少操作，这个主题稍后在本文档中讨论。

在这个过程中，让我们也介绍‘no_broadcast’标志，它将阻止输出被广播。这很重要，因为我们只想要每个输出一个输入值。聚合多于一个输入值是一个需要特殊处理的减少操作。尽管因为减少操作必须在迭代器标志中显式启用，这会引发错误，但禁用广播导致的错误消息对最终用户来说更容易理解。要了解如何将平方函数推广为减少函数，请参阅有关 Cython 的平方和函数的部分。

为了完整起见，我们还将添加‘external_loop’和‘buffered’标志，因为这通常是出于性能原因。

例子

```py
>>> def square(a, out=None):
...     it = np.nditer([a, out],
...             flags = ['external_loop', 'buffered'],
...             op_flags = [['readonly'],
...                         ['writeonly', 'allocate', 'no_broadcast']])
...     with it:
...         for x, y in it:
...             y[...] = x*x
...         return it.operands[1]
... 
```

```py
>>> square([1,2,3])
array([1, 4, 9]) 
```

```py
>>> b = np.zeros((3,))
>>> square([1,2,3], out=b)
array([1.,  4.,  9.])
>>> b
array([1.,  4.,  9.]) 
```

```py
>>> square(np.arange(6).reshape(2,3), out=b)
Traceback (most recent call last):
  ...
ValueError: non-broadcastable output operand with shape (3,) doesn't
match the broadcast shape (2,3) 
```

### 外部积迭代

任何二进制操作都可以像`outer`中那样以外部积方式扩展为数组操作，而`nditer`对象通过显式映射操作数的轴提供了一种方法。还可以通过`newaxis`索引来做到这一点，但我们将向您展示如何直接使用 nditer 的 *op_axes* 参数来实现这一点，而不需要中间视图。

我们将进行一个简单的外部积，将第一个操作数的维度放在第二个操作数的维度之前。*op_axes* 参数需要为每个操作数提供一个轴列表，并且提供了一个从迭代器的轴到操作数的轴的映射。

假设第一个操作数是一维的，而第二个操作数是二维的。迭代器将有三个维度，因此 *op_axes* 将有两个包含三个元素的列表。第一个列表选择第一个操作数的一个轴，并且对于迭代器的其他轴，为-1，最终结果是[0，-1，-1]。第二个列表选择第二个操作数的两个轴，但不应与第一个操作数选择的轴重叠。它的列表是[-1，0，1]。输出操作数以标准方式映射到迭代器轴，因此我们可以使用 None 代替构造另一个列表。

内循环中的操作是直接的乘法。与外部积有关的所有事情都由迭代器设置处理。

例子

```py
>>> a = np.arange(3)
>>> b = np.arange(8).reshape(2,4)
>>> it = np.nditer([a, b, None], flags=['external_loop'],
...             op_axes=[[0, -1, -1], [-1, 0, 1], None])
>>> with it:
...     for x, y, z in it:
...         z[...] = x*y
...     result = it.operands[2]  # same as z
...
>>> result
array([[[ 0,  0,  0,  0],
 [ 0,  0,  0,  0]],
 [[ 0,  1,  2,  3],
 [ 4,  5,  6,  7]],
 [[ 0,  2,  4,  6],
 [ 8, 10, 12, 14]]]) 
```

请注意，一旦迭代器关闭，我们就无法访问 `operands` ，必须使用在上下文管理器内创建的引用。

### 归约迭代

每当可写操作数的元素少于完整迭代空间时，该操作数正在进行归约。 `nditer` 对象要求任何归约操作数都必须标记为读写，只有在提供“reduce_ok”作为迭代器标志时才允许进行归约。

举个简单的例子，考虑对数组中所有元素求和。

示例

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> b = np.array(0)
>>> with np.nditer([a, b], flags=['reduce_ok'],
...                     op_flags=[['readonly'], ['readwrite']]) as it:
...     for x,y in it:
...         y[...] += x
...
>>> b
array(276)
>>> np.sum(a)
276 
```

在合并归约和分配操作数时，事情变得有些棘手。在启动迭代之前，任何归约操作数都必须初始化为其起始值。这是我们如何做到这一点的，沿着 *a* 的最后一个轴求和。

示例

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> it = np.nditer([a, None], flags=['reduce_ok'],
...             op_flags=[['readonly'], ['readwrite', 'allocate']],
...             op_axes=[None, [0,1,-1]])
>>> with it:
...     it.operands[1][...] = 0
...     for x, y in it:
...         y[...] += x
...     result = it.operands[1]
...
>>> result
array([[ 6, 22, 38],
 [54, 70, 86]])
>>> np.sum(a, axis=2)
array([[ 6, 22, 38],
 [54, 70, 86]]) 
```

要进行缓冲归约需要在设置过程中进行另一个调整。通常，迭代器构建涉及将可读数组的第一个缓冲区数据复制到缓冲区中。任何归约操作数都是可读的，因此可能会被读入缓冲区。不幸的是，在此缓冲操作完成后初始化操作数不会反映在迭代开始时的缓冲区中，将产生垃圾结果。

迭代器标志“delay_bufalloc”允许迭代器分配的归约操作数与缓冲存在在一起。设置此标志后，迭代器将保持其缓冲区未初始化，直到收到重置之后，才会准备好进行常规迭代。如果我们还启用缓冲，前面的例子将如何呈现。

示例

```py
>>> a = np.arange(24).reshape(2,3,4)
>>> it = np.nditer([a, None], flags=['reduce_ok',
...                                  'buffered', 'delay_bufalloc'],
...             op_flags=[['readonly'], ['readwrite', 'allocate']],
...             op_axes=[None, [0,1,-1]])
>>> with it:
...     it.operands[1][...] = 0
...     it.reset()
...     for x, y in it:
...         y[...] += x
...     result = it.operands[1]
...
>>> result
array([[ 6, 22, 38],
 [54, 70, 86]]) 
```

## 将内部循环放入 Cython 中

那些希望在低级操作中获得非常好性能的人应该认真考虑直接使用 C 中提供的迭代 API，但对于那些不熟悉 C 或 C++ 的人来说，Cython 是一个性能合理的好中间地带。对于 `nditer` 对象来说，这意味着让迭代器处理广播、数据类型转换和缓冲，同时将内部循环交给 Cython。

对于我们的示例，我们将创建一个求平方和的函数。首先，让我们在直接的 Python 中实现这个函数。我们想支持类似于 numpy `sum` 函数的 'axis' 参数，因此我们需要为 *op_axes* 参数构造一个列表。这是实现的方式。

示例

```py
>>> def axis_to_axeslist(axis, ndim):
...     if axis is None:
...         return [-1] * ndim
...     else:
...         if type(axis) is not tuple:
...             axis = (axis,)
...         axeslist = [1] * ndim
...         for i in axis:
...             axeslist[i] = -1
...         ax = 0
...         for i in range(ndim):
...             if axeslist[i] != -1:
...                 axeslist[i] = ax
...                 ax += 1
...         return axeslist
...
>>> def sum_squares_py(arr, axis=None, out=None):
...     axeslist = axis_to_axeslist(axis, arr.ndim)
...     it = np.nditer([arr, out], flags=['reduce_ok',
...                                       'buffered', 'delay_bufalloc'],
...                 op_flags=[['readonly'], ['readwrite', 'allocate']],
...                 op_axes=[None, axeslist],
...                 op_dtypes=['float64', 'float64'])
...     with it:
...         it.operands[1][...] = 0
...         it.reset()
...         for x, y in it:
...             y[...] += x*x
...         return it.operands[1]
...
>>> a = np.arange(6).reshape(2,3)
>>> sum_squares_py(a)
array(55.)
>>> sum_squares_py(a, axis=-1)
array([  5.,  50.]) 
```

要将此函数进行 Cython-化，我们用针对 float64 数据类型专门设计的 Cython 代码替换内部循环（y […] += x*x）。启用 'external_loop' 标志后，提供给内部循环的数组始终是一维的，因此很少需要进行检查。

这里是 sum_squares.pyx 的代码清单：

```py
import numpy as np
cimport numpy as np
cimport cython

def axis_to_axeslist(axis, ndim):
    if axis is None:
        return [-1] * ndim
    else:
        if type(axis) is not tuple:
            axis = (axis,)
        axeslist = [1] * ndim
        for i in axis:
            axeslist[i] = -1
        ax = 0
        for i in range(ndim):
            if axeslist[i] != -1:
                axeslist[i] = ax
                ax += 1
        return axeslist

@cython.boundscheck(False)
def sum_squares_cy(arr, axis=None, out=None):
    cdef np.ndarray[double] x
    cdef np.ndarray[double] y
    cdef int size
    cdef double value

    axeslist = axis_to_axeslist(axis, arr.ndim)
    it = np.nditer([arr, out], flags=['reduce_ok', 'external_loop',
                                      'buffered', 'delay_bufalloc'],
                op_flags=[['readonly'], ['readwrite', 'allocate']],
                op_axes=[None, axeslist],
                op_dtypes=['float64', 'float64'])
    with it:
        it.operands[1][...] = 0
        it.reset()
        for xarr, yarr in it:
            x = xarr
            y = yarr
            size = x.shape[0]
            for i in range(size):
               value = x[i]
               y[i] = y[i] + value * value
        return it.operands[1] 
```

在这台机器上，将 .pyx 文件构建为一个模块看起来像下面这样，但是你可能需要找一些 Cython 教程来告诉你系统配置的具体信息。：

```py
$ cython sum_squares.pyx
$ gcc -shared -pthread -fPIC -fwrapv -O2 -Wall -I/usr/include/python2.7 -fno-strict-aliasing -o sum_squares.so sum_squares.c 
```

从 Python 解释器中运行这段代码会产生与我们本地 Python/NumPy 代码相同的答案。

例子

```py
>>> from sum_squares import sum_squares_cy 
>>> a = np.arange(6).reshape(2,3)
>>> sum_squares_cy(a) 
array(55.0)
>>> sum_squares_cy(a, axis=-1) 
array([  5.,  50.]) 
```

在 IPython 中进行一点计时显示，Cython 内循环的减少开销和内存分配提供了对直接 Python 代码和使用 NumPy 内置 sum 函数的表达式都有很好的加速。:

```py
>>> a = np.random.rand(1000,1000)

>>> timeit sum_squares_py(a, axis=-1)
10 loops, best of 3: 37.1 ms per loop

>>> timeit np.sum(a*a, axis=-1)
10 loops, best of 3: 20.9 ms per loop

>>> timeit sum_squares_cy(a, axis=-1)
100 loops, best of 3: 11.8 ms per loop

>>> np.all(sum_squares_cy(a, axis=-1) == np.sum(a*a, axis=-1))
True

>>> np.all(sum_squares_py(a, axis=-1) == np.sum(a*a, axis=-1))
True 
```
