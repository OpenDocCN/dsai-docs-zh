- en: Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/core.html](https://docs.sympy.org/latest/modules/core.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## sympify'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Converts an arbitrary expression to a type that can be used inside SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a :**'
  prefs: []
  type: TYPE_NORMAL
- en: any object defined in SymPy
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'standard numeric Python types: `int`, `long`, `float`, `Decimal`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: strings (like `"0.09"`, `"2e-19"` or `'sin(x)'`)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: booleans, including `None` (will leave `None` unchanged)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: dicts, lists, sets or tuples containing any of the above
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**convert_xor** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If true, treats `^` as exponentiation. If False, treats `^` as XOR itself. Used
    only when input is a string.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**locals** : any object defined in SymPy, optional'
  prefs: []
  type: TYPE_NORMAL
- en: In order to have strings be recognized it can be imported into a namespace dictionary
    and passed as locals.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**strict** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If the option strict is set to `True`, only the types for which an explicit
    conversion has been defined are converted. In the other cases, a SympifyError
    is raised.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**rational** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, converts floats into [`Rational`](#sympy.core.numbers.Rational "sympy.core.numbers.Rational").
    If `False`, it lets floats remain as it is. Used only when input is a string.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**evaluate** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If False, then arithmetic and operators will be converted into their SymPy equivalents.
    If True the expression will be evaluated and the result will be returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: It will convert Python ints into instances of [`Integer`](#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), floats into instances of [`Float`](#sympy.core.numbers.Float
    "sympy.core.numbers.Float"), etc. It is also able to coerce symbolic expressions
    which inherit from [`Basic`](#sympy.core.basic.Basic "sympy.core.basic.Basic").
    This can be useful in cooperation with SAGE.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Note that this function uses `eval`, and thus shouldn’t be used on unsanitized
    input.
  prefs: []
  type: TYPE_NORMAL
- en: If the argument is already a type that SymPy understands, it will do nothing
    but return that value. This can be used at the beginning of a function to ensure
    you are working with the correct type.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the expression could not be converted, a SympifyError is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When attempting to parse non-Python syntax using `sympify`, it raises a `SympifyError`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To parse non-Python syntax, use `parse_expr` from `sympy.parsing.sympy_parser`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'For more details about `transformations`: see [`parse_expr()`](parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr")'
  prefs: []
  type: TYPE_NORMAL
- en: Locals
  prefs: []
  type: TYPE_NORMAL
- en: 'The sympification happens with access to everything that is loaded by `from
    sympy import *`; anything used in a string that is not defined by that import
    will be converted to a symbol. In the following, the `bitcount` function is treated
    as a symbol and the `O` is interpreted as the [`Order`](series/series.html#sympy.series.order.Order
    "sympy.series.order.Order") object (used with series) and it raises an error when
    used improperly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to have `bitcount` be recognized it can be imported into a namespace
    dictionary and passed as locals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to have the `O` interpreted as a Symbol, identify it as such in the
    namespace dictionary. This can be done in a variety of ways; all three of the
    following are possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want *all* single-letter and Greek-letter variables to be symbols then
    you can use the clashing-symbols dictionaries that have been defined there as
    private variables: `_clash1` (single-letter variables), `_clash2` (the multi-letter
    Greek names) or `_clash` (both single and multi-letter names that are defined
    in `abc`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Strict
  prefs: []
  type: TYPE_NORMAL
- en: If the option `strict` is set to `True`, only the types for which an explicit
    conversion has been defined are converted. In the other cases, a SympifyError
    is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.6: `sympify(obj)` automatically falls back to `str(obj)`
    when all other conversion methods fail, but this is deprecated. `strict=True`
    will disable this deprecated behavior. See [The string fallback in sympify()](../explanation/active-deprecations.html#deprecated-sympify-string-fallback).'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluation
  prefs: []
  type: TYPE_NORMAL
- en: If the option `evaluate` is set to `False`, then arithmetic and operators will
    be converted into their SymPy equivalents and the `evaluate=False` option will
    be added. Nested `Add` or `Mul` will be denested first. This is done via an AST
    transformation that replaces operators with their SymPy equivalents, so if an
    operand redefines any of those operations, the redefined operators will not be
    used. If argument a is not a string, the mathematical expression is evaluated
    before being passed to sympify, so adding `evaluate=False` will still return the
    evaluated result of expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Extending
  prefs: []
  type: TYPE_NORMAL
- en: To extend `sympify` to convert custom objects (not derived from `Basic`), just
    define a `_sympy_` method to your class. You can do that even to classes that
    you do not own by subclassing or adding the method at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do not have control over the class definition you could also use the
    `converter` global dictionary. The key is the class and the value is a function
    that takes a single argument and returns the desired SymPy object, e.g. `converter[MyList]
    = lambda x: Matrix(x)`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The keywords `rational` and `convert_xor` are only used when the input is a
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Convert_xor
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Rational
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes autosimplification during sympification results in expressions that
    are very different in structure than what was entered. Until such autosimplification
    is no longer done, the `kernS` function might be of some use. In the example below
    you can see how an expression reduces to \(-1\) by autosimplification, but does
    not do so when `kernS` is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]  ## assumptions'
  prefs: []
  type: TYPE_NORMAL
- en: This module contains the machinery handling assumptions. Do also consider the
    guide [Assumptions](../guides/assumptions.html#assumptions-guide).
  prefs: []
  type: TYPE_NORMAL
- en: All symbolic objects have assumption attributes that can be accessed via `.is_<assumption
    name>` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assumptions determine certain properties of symbolic objects and can have 3
    possible values: `True`, `False`, `None`. `True` is returned if the object has
    the property and `False` is returned if it does not or cannot (i.e. does not make
    sense):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When the property cannot be determined (or when a method is not implemented)
    `None` will be returned. For example, a generic symbol, `x`, may or may not be
    positive so a value of `None` is returned for `x.is_positive`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all symbolic values are in the largest set in the given context
    without specifying the property. For example, a symbol that has a property being
    integer, is also real, complex, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here follows a list of possible assumption names:'
  prefs: []
  type: TYPE_NORMAL
- en: commutative
  prefs: []
  type: TYPE_NORMAL
- en: object commutes with any other object with respect to multiplication operation.
    See [[12]](#id16).
  prefs: []
  type: TYPE_NORMAL
- en: complex
  prefs: []
  type: TYPE_NORMAL
- en: object can have only values from the set of complex numbers. See [[13]](#id17).
  prefs: []
  type: TYPE_NORMAL
- en: imaginary
  prefs: []
  type: TYPE_NORMAL
- en: 'object value is a number that can be written as a real number multiplied by
    the imaginary unit `I`. See [[R112]](#r112). Please note that `0` is not considered
    to be an imaginary number, see [issue #7649](https://github.com/sympy/sympy/issues/7649).'
  prefs: []
  type: TYPE_NORMAL
- en: real
  prefs: []
  type: TYPE_NORMAL
- en: object can have only values from the set of real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: extended_real
  prefs: []
  type: TYPE_NORMAL
- en: object can have only values from the set of real numbers, `oo` and `-oo`.
  prefs: []
  type: TYPE_NORMAL
- en: integer
  prefs: []
  type: TYPE_NORMAL
- en: object can have only values from the set of integers.
  prefs: []
  type: TYPE_NORMAL
- en: odd
  prefs: []
  type: TYPE_NORMAL
- en: even
  prefs: []
  type: TYPE_NORMAL
- en: object can have only values from the set of odd (even) integers [[R111]](#r111).
  prefs: []
  type: TYPE_NORMAL
- en: prime
  prefs: []
  type: TYPE_NORMAL
- en: object is a natural number greater than 1 that has no positive divisors other
    than 1 and itself. See [[R115]](#r115).
  prefs: []
  type: TYPE_NORMAL
- en: composite
  prefs: []
  type: TYPE_NORMAL
- en: object is a positive integer that has at least one positive divisor other than
    1 or the number itself. See [[R113]](#r113).
  prefs: []
  type: TYPE_NORMAL
- en: zero
  prefs: []
  type: TYPE_NORMAL
- en: object has the value of 0.
  prefs: []
  type: TYPE_NORMAL
- en: nonzero
  prefs: []
  type: TYPE_NORMAL
- en: object is a real number that is not zero.
  prefs: []
  type: TYPE_NORMAL
- en: rational
  prefs: []
  type: TYPE_NORMAL
- en: object can have only values from the set of rationals.
  prefs: []
  type: TYPE_NORMAL
- en: algebraic
  prefs: []
  type: TYPE_NORMAL
- en: object can have only values from the set of algebraic numbers [[11]](#id15).
  prefs: []
  type: TYPE_NORMAL
- en: transcendental
  prefs: []
  type: TYPE_NORMAL
- en: object can have only values from the set of transcendental numbers [[10]](#id14).
  prefs: []
  type: TYPE_NORMAL
- en: irrational
  prefs: []
  type: TYPE_NORMAL
- en: object value cannot be represented exactly by [`Rational`](#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational"), see [[R114]](#r114).
  prefs: []
  type: TYPE_NORMAL
- en: finite
  prefs: []
  type: TYPE_NORMAL
- en: infinite
  prefs: []
  type: TYPE_NORMAL
- en: object absolute value is bounded (arbitrarily large). See [[R116]](#r116), [[R117]](#r117),
    [[R118]](#r118).
  prefs: []
  type: TYPE_NORMAL
- en: negative
  prefs: []
  type: TYPE_NORMAL
- en: nonnegative
  prefs: []
  type: TYPE_NORMAL
- en: object can have only negative (nonnegative) values [[R110]](#r110).
  prefs: []
  type: TYPE_NORMAL
- en: positive
  prefs: []
  type: TYPE_NORMAL
- en: nonpositive
  prefs: []
  type: TYPE_NORMAL
- en: object can have only positive (nonpositive) values.
  prefs: []
  type: TYPE_NORMAL
- en: extended_negative
  prefs: []
  type: TYPE_NORMAL
- en: extended_nonnegative
  prefs: []
  type: TYPE_NORMAL
- en: extended_positive
  prefs: []
  type: TYPE_NORMAL
- en: extended_nonpositive
  prefs: []
  type: TYPE_NORMAL
- en: extended_nonzero
  prefs: []
  type: TYPE_NORMAL
- en: as without the extended part, but also including infinity with corresponding
    sign, e.g., extended_positive includes `oo`
  prefs: []
  type: TYPE_NORMAL
- en: hermitian
  prefs: []
  type: TYPE_NORMAL
- en: antihermitian
  prefs: []
  type: TYPE_NORMAL
- en: object belongs to the field of Hermitian (antihermitian) operators.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.numbers.ImaginaryUnit`](#sympy.core.numbers.ImaginaryUnit "sympy.core.numbers.ImaginaryUnit")
    [`sympy.core.numbers.Zero`](#sympy.core.numbers.Zero "sympy.core.numbers.Zero")
    [`sympy.core.numbers.One`](#sympy.core.numbers.One "sympy.core.numbers.One") [`sympy.core.numbers.Infinity`](#sympy.core.numbers.Infinity
    "sympy.core.numbers.Infinity") [`sympy.core.numbers.NegativeInfinity`](#sympy.core.numbers.NegativeInfinity
    "sympy.core.numbers.NegativeInfinity") [`sympy.core.numbers.ComplexInfinity`](#sympy.core.numbers.ComplexInfinity
    "sympy.core.numbers.ComplexInfinity")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The fully-resolved assumptions for any SymPy expression can be obtained as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Developers Notes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current (and possibly incomplete) values are stored in the `obj._assumptions
    dictionary`; queries to getter methods (with property decorators) or attributes
    of objects/classes will return values and update the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For a [`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol"), there
    are two locations for assumptions that may be of interest. The `assumptions0`
    attribute gives the full set of assumptions derived from a given set of initial
    assumptions. The latter assumptions are stored as `Symbol._assumptions_orig`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `_assumptions_orig` are not necessarily canonical nor are they filtered
    in any way: they records the assumptions used to instantiate a Symbol and (for
    storage purposes) represent a more compact representation of the assumptions needed
    to recreate the full set in `Symbol.assumptions0`.'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[[R110](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Negative_number](https://en.wikipedia.org/wiki/Negative_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R111](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Parity_%28mathematics%29](https://en.wikipedia.org/wiki/Parity_%28mathematics%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R112](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Imaginary_number](https://en.wikipedia.org/wiki/Imaginary_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R113](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Composite_number](https://en.wikipedia.org/wiki/Composite_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R114](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Irrational_number](https://en.wikipedia.org/wiki/Irrational_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R115](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Prime_number](https://en.wikipedia.org/wiki/Prime_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R116](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Finite](https://en.wikipedia.org/wiki/Finite)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R117](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.python.org/3/library/math.html#math.isfinite](https://docs.python.org/3/library/math.html#math.isfinite)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R118](#id12)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://numpy.org/doc/stable/reference/generated/numpy.isfinite.html](https://numpy.org/doc/stable/reference/generated/numpy.isfinite.html)  ##
    cache'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: caching decorator.
  prefs: []
  type: TYPE_NORMAL
- en: 'important: the result of cached function must be *immutable*'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'to force cacheit to check returned results mutability and consistency, set
    environment variable SYMPY_USE_CACHE to ‘debug’  ## basic'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Base class for all SymPy objects.
  prefs: []
  type: TYPE_NORMAL
- en: Notes And Conventions
  prefs: []
  type: TYPE_NORMAL
- en: 'Always use `.args`, when accessing parameters of some instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Never use internal methods or variables (the ones prefixed with `_`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'By “SymPy object” we mean something that can be returned by `sympify`. But
    not all objects one encounters using SymPy are subclasses of Basic. For example,
    mutable objects are not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Returns a tuple of arguments of ‘self’.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Never use self._args, always use self.args. Only use _args in __new__ when creating
    a new function. Do not override .args() from Basic (so that it is easy to change
    the interface in the future if needed).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: A stub to allow Basic args (like Tuple) to be skipped when computing the content
    and primitive components of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.expr.Expr.as_content_primitive`](#sympy.core.expr.Expr.as_content_primitive
    "sympy.core.expr.Expr.as_content_primitive")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Return the expression with any objects having structurally bound symbols replaced
    with unique, canonical symbols within the object in which they appear and having
    only the default assumption for commutativity being True. When applied to a symbol
    a new symbol having only the same commutativity will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Any object that has structurally bound variables should have a property, \(bound_symbols\)
    that returns those symbols appearing in the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Return object \(type\) assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Symbol(‘x’, real=True) Symbol(‘x’, integer=True)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: are different objects. In other words, besides Python type (Symbol in this case),
    the initial assumptions are also forming their typeinfo.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Returns the atoms that form the current object.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, only objects that are truly atomic and cannot be divided into smaller
    pieces are returned: symbols, numbers, and number symbols like I and pi. It is
    possible to request atoms of any type, however, as demonstrated below.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If one or more types are given, the results will contain only those types of
    atoms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note that I (imaginary unit) and zoo (complex infinity) are special types of
    number symbols and are not part of the NumberSymbol class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The type can be given implicitly, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful to check your assumptions when using the implicit option since `S(1).is_Integer
    = True` but `type(S(1))` is `One`, a special type of SymPy atom, while `type(S(2))`
    is type `Integer` and will find all integers in an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, arguments to atoms() can select more than atomic atoms: any SymPy
    type (loaded in core/__init__.py) can be listed as an argument and those types
    of “atoms” as found in scanning the arguments of the expression recursively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Return a dictionary mapping any variable defined in `self.bound_symbols` to
    Symbols that do not clash with any free symbols in the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Nice order of classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Return -1, 0, 1 if the object is less than, equal, or greater than other in
    a canonical sense. Non-Basic are always greater than Basic. If both names of the
    classes being compared appear in the \(ordering_of_classes\) then the ordering
    will depend on the appearance of the names there. If either does not appear in
    that list, then the comparison is based on the class name. If the names are the
    same then a comparison is made on the length of the hashable content. Items of
    the equal-lengthed contents are then successively compared using the same rules.
    If there is never a difference then 0 is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Count the number of matching subexpressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper for count_ops that returns the operation count.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Evaluate objects that are not evaluated by default like limits, integrals, sums
    and products. All objects of this kind will be evaluated recursively, unless some
    species were excluded via ‘hints’ or unless the ‘deep’ hint was set to ‘False’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Compare two expressions and handle dummy symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Find all subexpressions matching a query.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Return from the atoms of self those which are free symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all free symbols are `Symbol`. Eg: IndexedBase(‘I’)[0].free_symbols'
  prefs: []
  type: TYPE_NORMAL
- en: For most expressions, all symbols are free symbols. For some classes this is
    not true. e.g. Integrals use Symbols for the dummy variables which are bound variables,
    so Integral has a method to return all symbols except those. Derivative keeps
    track of symbols with respect to which it will perform a derivative; those are
    bound variables, too, so it has its own free_symbols method.
  prefs: []
  type: TYPE_NORMAL
- en: Any other method that uses bound variables should implement a free_symbols method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Create a new object from an iterable.
  prefs: []
  type: TYPE_NORMAL
- en: This is a convenience function that allows one to create objects from any iterable,
    without having to convert to a list or tuple first.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The top-level function in an expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following should hold for all objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Test whether any subexpression matches any of the patterns.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Note `has` is a structural algorithm with no knowledge of mathematics. Consider
    the following half-open interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, use `contains` to determine whether a number is in the interval or
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Note that `expr.has(*patterns)` is exactly equivalent to `any(expr.has(p) for
    p in patterns)`. In particular, `False` is returned when the list of patterns
    is empty.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Return True if self has object(s) `x` as a free expression else False.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'This works for subexpressions and types, too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Return True if self has any of the patterns in s as a free argument, else False.
    This is like \(Basic.has_free\) but this will only report exact argument matches.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Return True if self can be computed to a real number (or already is a real number)
    with precision, else False.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'A False result does not mean that \(self\) cannot be rewritten into a form
    that would be comparable. For example, the difference computed below is zero but
    without simplification it does not evaluate to a zero with precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Return True if a and b are structurally the same, else False. If \(approx\)
    is supplied, it will be used to test whether two numbers are the same or not.
    By default, only numbers of the same type will compare equal, so S.Half != Float(0.5).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'In SymPy (unlike Python) two numbers do not compare the same if they are not
    of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: By supplying a function with which to compare two numbers, such differences
    can be ignored. e.g. \(equal_valued\) will return True for decimal numbers having
    a denominator that is a power of 2, regardless of precision.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: But decimals without a power of 2 denominator will compare as not being the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'But arbitrary differences can be ignored by supplying a function to test the
    equivalence of two numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Other objects might compare the same even though types are not the same. This
    routine will only return True if two expressions are identical in terms of class
    types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Wild symbols match all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return `None` when expression (self) does not match with pattern. Otherwise
    return a dictionary such that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Structurally bound symbols are ignored during matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'But they can be identified if desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The `old` flag will give the old-style pattern matching where expressions and
    patterns are essentially solved to give the match. Both of the following give
    None unless `old=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Helper method for match() that looks for a match between Wild symbols in self
    and expressions in expr.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Apply on the argument recursively through the expression tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method is used to simulate a common abuse of notation for operators. For
    instance, in SymPy the following will not work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`(x+Lambda(y, 2*y))(z) == x+2*z`,'
  prefs: []
  type: TYPE_NORMAL
- en: 'however, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: See the refine function in sympy.assumptions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Replace matching subexpressions of `self` with `value`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `map = True` then also return the mapping {old: new} where `old` was a sub-expression
    found with query and `new` is the replacement value for it. If the expression
    itself does not match the query, then the returned value will be `self.xreplace(map)`
    otherwise it should be `self.subs(ordered(map.items()))`.'
  prefs: []
  type: TYPE_NORMAL
- en: Traverses an expression tree and performs replacement of matching subexpressions
    from the bottom to the top of the tree. The default approach is to do the replacement
    in a simultaneous fashion so changes made are targeted only once. If this is not
    desired or causes problems, `simultaneous` can be set to False.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, if an expression containing more than one Wild symbol is being
    used to match subexpressions and the `exact` flag is None it will be set to True
    so the match will only succeed if all non-zero values are received for each Wild
    that appears in the match pattern. Setting this to False accepts a match of 0;
    while setting it True accepts all matches that have a 0 in them. See example below
    for cautions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of possible combinations of queries and replacement values is listed
    below:'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Initial setup
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 1.1\. type -> type
  prefs: []
  type: TYPE_NORMAL
- en: obj.replace(type, newtype)
  prefs: []
  type: TYPE_NORMAL
- en: When object of type `type` is found, replace it with the result of passing its
    argument(s) to `newtype`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 1.2\. type -> func
  prefs: []
  type: TYPE_NORMAL
- en: obj.replace(type, func)
  prefs: []
  type: TYPE_NORMAL
- en: When object of type `type` is found, apply `func` to its argument(s). `func`
    must be written to handle the number of arguments of `type`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 2.1\. pattern -> expr
  prefs: []
  type: TYPE_NORMAL
- en: obj.replace(pattern(wild), expr(wild))
  prefs: []
  type: TYPE_NORMAL
- en: Replace subexpressions matching `pattern` with the expression written in terms
    of the Wild symbols in `pattern`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Matching is exact by default when more than one Wild symbol is used: matching
    fails unless the match gives non-zero values for all Wild symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'When set to False, the results may be non-intuitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 2.2\. pattern -> func
  prefs: []
  type: TYPE_NORMAL
- en: 'obj.replace(pattern(wild), lambda wild: expr(wild))'
  prefs: []
  type: TYPE_NORMAL
- en: 'All behavior is the same as in 2.1 but now a function in terms of pattern variables
    is used rather than an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 3.1\. func -> func
  prefs: []
  type: TYPE_NORMAL
- en: obj.replace(filter, func)
  prefs: []
  type: TYPE_NORMAL
- en: Replace subexpression `e` with `func(e)` if `filter(e)` is True.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: The expression itself is also targeted by the query but is done in such a fashion
    that changes are not made twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'When matching a single symbol, \(exact\) will default to True, but this may
    or may not be the behavior that is desired:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we want \(exact=False\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'But here, the nature of matching makes selecting the right setting tricky:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'It is probably better to use a different form of the query that describes the
    target expression more precisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`subs`](#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")'
  prefs: []
  type: TYPE_NORMAL
- en: substitution of subexpressions as defined by the objects themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '[`xreplace`](#sympy.core.basic.Basic.xreplace "sympy.core.basic.Basic.xreplace")'
  prefs: []
  type: TYPE_NORMAL
- en: exact node replacement in expr tree; also capable of using matching rules
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Rewrite *self* using a defined rule.
  prefs: []
  type: TYPE_NORMAL
- en: Rewriting transforms an expression to another, which is mathematically equivalent
    but structurally different. For example you can rewrite trigonometric functions
    as complex exponentials or combinatorial functions as gamma function.
  prefs: []
  type: TYPE_NORMAL
- en: This method takes a *pattern* and a *rule* as positional arguments. *pattern*
    is optional parameter which defines the types of expressions that will be transformed.
    If it is not passed, all possible expressions will be rewritten. *rule* defines
    how the expression will be rewritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**args** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: A *rule*, or *pattern* and *rule*. - *pattern* is a type or an iterable of types.
    - *rule* can be any object.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**deep** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, subexpressions are recursively transformed. Default is `True`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: If *pattern* is unspecified, all possible expressions are transformed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Pattern can be a type or an iterable of types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Rewriting behavior can be implemented by defining `_eval_rewrite()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Defining `_eval_rewrite_as_[...]()` method is supported for backwards compatibility
    reason. This may be removed in the future and using it is discouraged.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: See the simplify function in sympy.simplify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Return a sort key.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Substitutes old for new in an expression after sympifying args.
  prefs: []
  type: TYPE_NORMAL
- en: '\(args\) is either:'
  prefs: []
  type: TYPE_NORMAL
- en: two arguments, e.g. foo.subs(old, new)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: one iterable argument, e.g. foo.subs(iterable). The iterable may be
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: o an iterable container with (old, new) pairs. In this case the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: replacements are processed in the order given with successive patterns possibly
    affecting replacements already made.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: o a dict or set whose key/value items correspond to old/new pairs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this case the old/new pairs will be sorted by op count and in case of a tie,
    by number of args and the default_sort_key. The resulting sorted list is then
    processed as an iterable container (see previous).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the keyword `simultaneous` is True, the subexpressions will not be evaluated
    until all the substitutions have been made.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'To replace only the x**2 but not the x**4, use xreplace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'To delay evaluation until all substitutions have been made, set the keyword
    `simultaneous` to True:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'This has the added feature of not allowing subsequent substitutions to affect
    those already made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: In order to obtain a canonical result, unordered iterables are sorted by count_op
    length, number of arguments and by the default_sort_key to break any ties. All
    other iterables are left unsorted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting expression represents a literal replacement of the old arguments
    with the new arguments. This may not reflect the limiting behavior of the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: If the substitution will be followed by numerical evaluation, it is better to
    pass the substitution to evalf as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: rather than
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: as the former will ensure that the desired level of precision is obtained.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`replace`](#sympy.core.basic.Basic.replace "sympy.core.basic.Basic.replace")'
  prefs: []
  type: TYPE_NORMAL
- en: replacement capable of doing wildcard-like matching, parsing of match, and conditional
    replacements
  prefs: []
  type: TYPE_NORMAL
- en: '[`xreplace`](#sympy.core.basic.Basic.xreplace "sympy.core.basic.Basic.xreplace")'
  prefs: []
  type: TYPE_NORMAL
- en: exact node replacement in expr tree; also capable of using matching rules
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.evalf.EvalfMixin.evalf`](#sympy.core.evalf.EvalfMixin.evalf "sympy.core.evalf.EvalfMixin.evalf")'
  prefs: []
  type: TYPE_NORMAL
- en: calculates the given formula to a desired level of precision
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Replace occurrences of objects within the expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rule** : dict-like'
  prefs: []
  type: TYPE_NORMAL
- en: Expresses a replacement rule
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**xreplace** : the result of the replacement'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Replacements occur only if an entire node in the expression tree is matched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'xreplace does not differentiate between free and bound symbols. In the following,
    subs(x, y) would not change x since it is a bound symbol, but xreplace does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to replace x with an expression raises an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`replace`](#sympy.core.basic.Basic.replace "sympy.core.basic.Basic.replace")'
  prefs: []
  type: TYPE_NORMAL
- en: replacement capable of doing wildcard-like matching, parsing of match, and conditional
    replacements
  prefs: []
  type: TYPE_NORMAL
- en: '[`subs`](#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")'
  prefs: []
  type: TYPE_NORMAL
- en: substitution of subexpressions as defined by the objects themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: A parent class for atomic things. An atom is an expression with no subexpressions.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Symbol, Number, Rational, Integer, … But not: Add, Mul, Pow, …  ## singleton'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: The registry for the singleton classes (accessible as `S`).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This class serves as two separate things.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing it is is the `SingletonRegistry`. Several classes in SymPy appear
    so often that they are singletonized, that is, using some metaprogramming they
    are made so that they can only be instantiated once (see the [`sympy.core.singleton.Singleton`](#sympy.core.singleton.Singleton
    "sympy.core.singleton.Singleton") class for details). For instance, every time
    you create `Integer(0)`, this will return the same instance, [`sympy.core.numbers.Zero`](#sympy.core.numbers.Zero
    "sympy.core.numbers.Zero"). All singleton instances are attributes of the `S`
    object, so `Integer(0)` can also be accessed as `S.Zero`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Singletonization offers two advantages: it saves memory, and it allows fast
    comparison. It saves memory because no matter how many times the singletonized
    objects appear in expressions in memory, they all point to the same single instance
    in memory. The fast comparison comes from the fact that you can use `is` to compare
    exact instances in Python (usually, you need to use `==` to compare things). `is`
    compares objects by memory address, and is very fast.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: For the most part, the fact that certain objects are singletonized is an implementation
    detail that users should not need to worry about. In SymPy library code, `is`
    comparison is often used for performance purposes The primary advantage of `S`
    for end users is the convenient access to certain instances that are otherwise
    difficult to type, like `S.Half` (instead of `Rational(1, 2)`).
  prefs: []
  type: TYPE_NORMAL
- en: When using `is` comparison, make sure the argument is sympified. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'This problem is not an issue when using `==`, which is recommended for most
    use-cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The second thing `S` is is a shortcut for [`sympy.core.sympify.sympify()`](#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify"). [`sympy.core.sympify.sympify()`](#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") is the function that converts Python objects such
    as `int(1)` into SymPy objects such as `Integer(1)`. It also converts the string
    form of an expression into a SymPy expression, like `sympify("x**2")` -> `Symbol("x")**2`.
    `S(1)` is the same thing as `sympify(1)` (basically, `S.__call__` has been defined
    to call `sympify`).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is for convenience, since `S` is a single letter. It’s mostly useful for
    defining rational numbers. Consider an expression like `x + 1/2`. If you enter
    this directly in Python, it will evaluate the `1/2` and give `0.5`, because both
    arguments are ints (see also [Two Final Notes: ^ and /](../tutorials/intro-tutorial/gotchas.html#tutorial-gotchas-final-notes)).
    However, in SymPy, you usually want the quotient of two integers to give an exact
    rational number. The way Python’s evaluation works, at least one side of an operator
    needs to be a SymPy object for the SymPy evaluation to take over. You could write
    this as `x + Rational(1, 2)`, but this is a lot more typing. A shorter version
    is `x + S(1)/2`. Since `S(1)` returns `Integer(1)`, the division will return a
    `Rational` type, since it will call `Integer.__truediv__`, which knows how to
    return a `Rational`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Metaclass for singleton classes.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A singleton class has only one instance which is returned every time the class
    is instantiated. Additionally, this instance can be accessed through the global
    registry object `S` as `S.<class_name>`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Instance creation is delayed until the first time the value is accessed. (SymPy
    versions before 1.0 would create the instance during class creation time, which
    would be prone to import cycles.)  ## expr'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Base class for algebraic expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Everything that requires arithmetic operations to be defined should subclass
    this class, instead of Basic (which should be used only for argument storage and
    expression manipulation, i.e. pattern matching, substitutions, etc).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to override the comparisons of expressions: Should use _eval_is_ge
    for inequality, or _eval_is_eq, with multiple dispatch. _eval_is_ge return true
    if x >= y, false if x < y, and None if the two types are not comparable or the
    comparison is indeterminate'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.basic.Basic`](#sympy.core.basic.Basic "sympy.core.basic.Basic")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: See the apart function in sympy.polys
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Return [commutative factors, non-commutative factors] of self.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: self is treated as a Mul and the ordering of the factors is maintained. If `cset`
    is True the commutative factors will be returned in a set. If there were repeated
    factors (as may happen with an unevaluated Mul) then an error will be raised unless
    it is explicitly suppressed by setting `warn` to False.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: -1 is always separated from a Number unless split_1 is False.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'The arg is always treated as a Mul:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Efficiently extract the coefficient of a summation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Efficiently extract the coefficient of a product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Return the tuple (c, args) where self is written as an Add, `a`.
  prefs: []
  type: TYPE_NORMAL
- en: c should be a Rational added to any terms of the Add that are independent of
    deps.
  prefs: []
  type: TYPE_NORMAL
- en: args should be a tuple of all other terms of `a`; args is empty if self is a
    Number or if self is independent of deps (when given).
  prefs: []
  type: TYPE_NORMAL
- en: This should be used when you do not know if self is an Add or not but you want
    to treat self as an Add or if you want to process the individual arguments of
    the tail of self as an Add.
  prefs: []
  type: TYPE_NORMAL
- en: if you know self is an Add and want only the head, use self.args[0];
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if you do not want to process the arguments of the tail but need the tail then
    use self.as_two_terms() which gives the head and tail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if you want to split self into an independent and dependent parts use `self.as_independent(*deps)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '`c*x**e -> c,e` where x can be any symbolic expression.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Return the tuple (c, args) where self is written as a Mul, `m`.
  prefs: []
  type: TYPE_NORMAL
- en: c should be a Rational multiplied by any factors of the Mul that are independent
    of deps.
  prefs: []
  type: TYPE_NORMAL
- en: args should be a tuple of all other factors of m; args is empty if self is a
    Number or if self is independent of deps (when given).
  prefs: []
  type: TYPE_NORMAL
- en: This should be used when you do not know if self is a Mul or not but you want
    to treat self as a Mul or if you want to process the individual arguments of the
    tail of self as a Mul.
  prefs: []
  type: TYPE_NORMAL
- en: if you know self is a Mul and want only the head, use self.args[0];
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if you do not want to process the arguments of the tail but need the tail then
    use self.as_two_terms() which gives the head and tail;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if you want to split self into an independent and dependent parts use `self.as_independent(*deps)`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Extracts symbolic coefficient at the given expression. In other words, this
    functions separates ‘self’ into the product of ‘expr’ and ‘expr’-free coefficient.
    If such separation is not possible it will return None.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Two terms have E in them so a sum is returned. (If one were desiring the coefficient
    of the term exactly matching E then the constant from the returned expression
    could be selected. Or, for greater precision, a method of Poly can be used to
    indicate the desired term from which the coefficient is desired.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Since the following cannot be written as a product containing E as a factor,
    None is returned. (If the coefficient `2*x` is desired then the `coeff` method
    should be used.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`coeff`](#sympy.core.expr.Expr.coeff "sympy.core.expr.Expr.coeff")'
  prefs: []
  type: TYPE_NORMAL
- en: return sum of terms have a given factor
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_coeff_Add`](#sympy.core.expr.Expr.as_coeff_Add "sympy.core.expr.Expr.as_coeff_Add")'
  prefs: []
  type: TYPE_NORMAL
- en: separate the additive constant from an expression
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_coeff_Mul`](#sympy.core.expr.Expr.as_coeff_Mul "sympy.core.expr.Expr.as_coeff_Mul")'
  prefs: []
  type: TYPE_NORMAL
- en: separate the multiplicative constant from an expression
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_independent`](#sympy.core.expr.Expr.as_independent "sympy.core.expr.Expr.as_independent")'
  prefs: []
  type: TYPE_NORMAL
- en: separate x-dependent terms/factors from others
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.polys.polytools.Poly.coeff_monomial`](polys/reference.html#sympy.polys.polytools.Poly.coeff_monomial
    "sympy.polys.polytools.Poly.coeff_monomial")'
  prefs: []
  type: TYPE_NORMAL
- en: efficiently find the single coefficient of a monomial in Poly
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.polys.polytools.Poly.nth`](polys/reference.html#sympy.polys.polytools.Poly.nth
    "sympy.polys.polytools.Poly.nth")'
  prefs: []
  type: TYPE_NORMAL
- en: like coeff_monomial but powers of monomial terms are used
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Return a dictionary mapping terms to their Rational coefficient. Since the dictionary
    is a defaultdict, inquiries about terms which were not present will return a coefficient
    of 0.
  prefs: []
  type: TYPE_NORMAL
- en: If symbols `syms` are provided, any multiplicative terms independent of them
    will be considered a coefficient and a regular dictionary of syms-dependent generators
    as keys and their corresponding coefficients as values will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: This method should recursively remove a Rational from all arguments and return
    that (content) and the new self (primitive). The content should always be positive
    and `Mul(*foo.as_content_primitive()) == foo`. The primitive need not be in canonical
    form and should try to preserve the underlying structure if possible (i.e. expand_mul
    should not be applied to self).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'The as_content_primitive function is recursive and retains structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'Integer powers will have Rationals extracted from the base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'Terms may end up joining once their as_content_primitives are added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Radical content can also be factored out of the primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: If clear=False (default is True) then content will not be removed from an Add
    if it can be distributed to leave one or more terms with integer coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Convert a polynomial to a SymPy expression.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'A mostly naive separation of a Mul or Add into arguments that are not are dependent
    on deps. To obtain as complete a separation of variables as possible, use a separation
    method first, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: separatevars() to change Mul, Add and Pow (including exp) into Mul
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .expand(mul=True) to change Add or Mul into Add
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .expand(log=True) to change log expr into an Add
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The only non-naive thing that is done here is to respect noncommutative ordering
    of variables and to always return (0, 0) for \(self\) of zero regardless of hints.
  prefs: []
  type: TYPE_NORMAL
- en: 'For nonzero \(self\), the returned tuple (i, d) has the following interpretation:'
  prefs: []
  type: TYPE_NORMAL
- en: i will has no variable that appears in deps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: d will either have terms that contain variables that are in deps, or be equal
    to 0 (when self is an Add) or 1 (when self is a Mul)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if self is an Add then self = i + d
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if self is a Mul then self = i*d
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: otherwise (self, S.One) or (S.One, self) is returned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To force the expression to be treated as an Add, use the hint as_Add=True
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: – self is an Add
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: – self is a Mul
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: non-commutative terms cannot always be separated out when self is a Mul
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '– self is anything else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '– force self to be treated as an Add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '– force self to be treated as a Mul:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Note how the below differs from the above in making the constant on the dep
    term positive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: – use .as_independent() for true independence testing instead
  prefs: []
  type: TYPE_NORMAL
- en: of .has(). The former considers only symbols in the free symbols while the latter
    considers all symbols
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: when trying to get independent terms, a separation method might need
    to be used first. In this case, it is important to keep track of what you send
    to this routine so you know how to interpret the returned values'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`separatevars`](simplify/simplify.html#sympy.simplify.simplify.separatevars
    "sympy.simplify.simplify.separatevars"), [`expand_log`](#sympy.core.function.expand_log
    "sympy.core.function.expand_log"), [`sympy.core.add.Add.as_two_terms`](#sympy.core.add.Add.as_two_terms
    "sympy.core.add.Add.as_two_terms"), [`sympy.core.mul.Mul.as_two_terms`](#sympy.core.mul.Mul.as_two_terms
    "sympy.core.mul.Mul.as_two_terms"), [`as_coeff_mul`](#sympy.core.expr.Expr.as_coeff_mul
    "sympy.core.expr.Expr.as_coeff_mul")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Returns the leading (nonzero) term of the series expansion of self.
  prefs: []
  type: TYPE_NORMAL
- en: The _eval_as_leading_term routines are used to do this, and they must always
    return a non-zero value.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Return the numerator and the denominator of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: expression -> a/b -> a, b
  prefs: []
  type: TYPE_NORMAL
- en: This is just a stub that should be defined by an object’s class methods to get
    anything else.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`normal`](#sympy.core.expr.Expr.normal "sympy.core.expr.Expr.normal")'
  prefs: []
  type: TYPE_NORMAL
- en: return `a/b` instead of `(a, b)`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: Return list of ordered factors (if Mul) else [self].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Transform an expression to an ordered list of terms.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Converts `self` to a polynomial or returns `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Return self as a dictionary of factors with each factor being treated as a power.
    The keys are the bases of the factors and the values, the corresponding exponents.
    The resulting dictionary should be used with caution if the expression is a Mul
    and contains non- commutative factors since the order that they appeared will
    be lost in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_ordered_factors`](#sympy.core.expr.Expr.as_ordered_factors "sympy.core.expr.Expr.as_ordered_factors")'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative for noncommutative applications, returning an ordered list of
    factors.
  prefs: []
  type: TYPE_NORMAL
- en: '[`args_cnc`](#sympy.core.expr.Expr.args_cnc "sympy.core.expr.Expr.args_cnc")'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to as_ordered_factors, but guarantees separation of commutative and
    noncommutative factors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: Performs complex expansion on ‘self’ and returns a tuple containing collected
    both real and imaginary parts. This method cannot be confused with re() and im()
    functions, which does not perform complex expansion at evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: However it is possible to expand both re() and im() functions and get exactly
    the same results as with a single call to this function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Transform an expression to a list of terms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Asymptotic Series expansion of self. This is equivalent to `self.series(x, oo,
    n)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**self** : Expression'
  prefs: []
  type: TYPE_NORMAL
- en: The expression whose series is to be expanded.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**x** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: It is the variable of the expression to be calculated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n** : Value'
  prefs: []
  type: TYPE_NORMAL
- en: The value used to represent the order in terms of `x**n`, up to which the series
    is to be expanded.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**hir** : Boolean'
  prefs: []
  type: TYPE_NORMAL
- en: Set this parameter to be True to produce hierarchical series. It stops the recursion
    at an early level and may provide nicer and more useful results.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**bound** : Value, Integer'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `bound` parameter to give limit on rewriting coefficients in its normalised
    form.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Expr
  prefs: []
  type: TYPE_NORMAL
- en: Asymptotic series expansion of the expression.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: For rational expressions this method may return original expression without
    the Order term. >>> (1/x).aseries(x, n=8) 1/x
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is directly induced from the limit computational algorithm provided
    by Gruntz. It majorly uses the mrv and rewrite sub-routines. The overall idea
    of this algorithm is first to look for the most rapidly varying subexpression
    w of a given expression f and then expands f in a series in w. Then same thing
    is recursively done on the leading coefficient till we get constant coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: If the most rapidly varying subexpression of a given expression f is f itself,
    the algorithm tries to find a normalised representation of the mrv set and rewrites
    f using this normalised representation.
  prefs: []
  type: TYPE_NORMAL
- en: If the expansion contains an order term, it will be either `O(x ** (-n))` or
    `O(w ** (-n))` where `w` belongs to the most rapidly varying expression of `self`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Expr.aseries`](#sympy.core.expr.Expr.aseries "sympy.core.expr.Expr.aseries")'
  prefs: []
  type: TYPE_NORMAL
- en: See the docstring of this function for complete details of this wrapper.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R119](#id18)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Gruntz, Dominik. A new algorithm for computing asymptotic series. In: Proc.
    1993 Int. Symp. Symbolic and Algebraic Computation. 1993. pp. 239-244.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R120](#id19)]'
  prefs: []
  type: TYPE_NORMAL
- en: Gruntz thesis - p90
  prefs: []
  type: TYPE_NORMAL
- en: '[[R121](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Asymptotic_expansion](https://en.wikipedia.org/wiki/Asymptotic_expansion)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: See the cancel function in sympy.polys
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Returns the coefficient from the term(s) containing `x**n`. If `n` is zero then
    all terms independent of `x` will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: When `x` is noncommutative, the coefficient to the left (default) or right of
    `x` can be returned. The keyword ‘right’ is ignored when `x` is commutative.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'You can select terms that have an explicit negative in front of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'You can select terms with no Rational coefficient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'You can select terms independent of x by making n=0; in this case expr.as_independent(x)[0]
    is returned (and 0 will be returned instead of None):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'You can select terms that have a numerical term in front of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'The matching is exact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, no factoring is done, so 1 + z*(1 + y) is not obtained from the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'If such factoring is desired, factor_terms can be used first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is more than one possible coefficient 0 is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is only one possible coefficient, it is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_coefficient`](#sympy.core.expr.Expr.as_coefficient "sympy.core.expr.Expr.as_coefficient")'
  prefs: []
  type: TYPE_NORMAL
- en: separate the expression into a coefficient and factor
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_coeff_Add`](#sympy.core.expr.Expr.as_coeff_Add "sympy.core.expr.Expr.as_coeff_Add")'
  prefs: []
  type: TYPE_NORMAL
- en: separate the additive constant from an expression
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_coeff_Mul`](#sympy.core.expr.Expr.as_coeff_Mul "sympy.core.expr.Expr.as_coeff_Mul")'
  prefs: []
  type: TYPE_NORMAL
- en: separate the multiplicative constant from an expression
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_independent`](#sympy.core.expr.Expr.as_independent "sympy.core.expr.Expr.as_independent")'
  prefs: []
  type: TYPE_NORMAL
- en: separate x-dependent terms/factors from others
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.polys.polytools.Poly.coeff_monomial`](polys/reference.html#sympy.polys.polytools.Poly.coeff_monomial
    "sympy.polys.polytools.Poly.coeff_monomial")'
  prefs: []
  type: TYPE_NORMAL
- en: efficiently find the single coefficient of a monomial in Poly
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.polys.polytools.Poly.nth`](polys/reference.html#sympy.polys.polytools.Poly.nth
    "sympy.polys.polytools.Poly.nth")'
  prefs: []
  type: TYPE_NORMAL
- en: like coeff_monomial but powers of monomial terms are used
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: See the collect function in sympy.simplify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: See the combsimp function in sympy.simplify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Deprecated function to compute the leading term of a series.
  prefs: []
  type: TYPE_NORMAL
- en: as_leading_term is only allowed for results of .series() This is a wrapper to
    compute a series first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Returns the complex conjugate of ‘self’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Return True if self has -1 as a leading factor or has more literal negative
    signs than positive signs in a sum, otherwise False.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: 'Though the `y - x` is considered like `-(x - y)`, since it is in a product
    without a leading factor of -1, the result is false below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: 'To put something in canonical form wrt to sign, use \(signsimp\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Return True if self == other, False if it does not, or None. If failing_expression
    is True then the expression which did not simplify to a 0 will be returned instead
    of None.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If `self` is a Number (or complex number) that is not zero, then the result
    is False.
  prefs: []
  type: TYPE_NORMAL
- en: If `self` is a number and has not evaluated to zero, evalf will be used to test
    whether the expression evaluates to zero. If it does so and the result has significance
    (i.e. the precision is either -1, for a Rational result, or is greater than 1)
    then the evalf value will be used to return True or False.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Expand an expression using hints.
  prefs: []
  type: TYPE_NORMAL
- en: See the docstring of the expand() function in sympy.core.function for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Like `free_symbols`, but returns the free symbols only if they are contained
    in an expression node.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'If the expression is contained in a non-expression object, do not return the
    free symbols. Compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: Return self - c if it’s possible to subtract c from self and make all matching
    coefficients move towards zero, else return None.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`extract_multiplicatively`](#sympy.core.expr.Expr.extract_multiplicatively
    "sympy.core.expr.Expr.extract_multiplicatively"), [`coeff`](#sympy.core.expr.Expr.coeff
    "sympy.core.expr.Expr.coeff"), [`as_coefficient`](#sympy.core.expr.Expr.as_coefficient
    "sympy.core.expr.Expr.as_coefficient")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: Try to write self as `exp_polar(2*pi*I*n)*z` in a nice way. Return (z, n).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'If allow_half is True, also extract exp_polar(I*pi):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Return None if it’s not possible to make self in the form c * something in a
    nice way, i.e. preserving the properties of arguments of self.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: See the factor() function in sympy.polys.polytools
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: Compute fourier sine/cosine series of self.
  prefs: []
  type: TYPE_NORMAL
- en: See the docstring of the [`fourier_series()`](#sympy.core.expr.Expr.fourier_series
    "sympy.core.expr.Expr.fourier_series") in sympy.series.fourier for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Compute formal power power series of self.
  prefs: []
  type: TYPE_NORMAL
- en: See the docstring of the [`fps()`](#sympy.core.expr.Expr.fps "sympy.core.expr.Expr.fps")
    function in sympy.series.formal for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: See the gammasimp function in sympy.simplify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Returns the additive O(..) symbol if there is one, else None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: Returns the order of the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The order is determined either from the O(…) term. If there is no O(…) term,
    it returns None.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: See the integrate function in sympy.integrals
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Return the multiplicative inverse of `self` mod `g` where `self` (and `g`) may
    be symbolic expressions).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.intfunc.mod_inverse`](#sympy.core.intfunc.mod_inverse "sympy.core.intfunc.mod_inverse"),
    [`sympy.polys.polytools.invert`](polys/reference.html#sympy.polys.polytools.invert
    "sympy.polys.polytools.invert")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: This tests whether a given expression is algebraic or not, in the given symbols,
    syms. When syms is not given, all free symbols will be used. The rational function
    does not have to be in expanded or in any kind of canonical form.
  prefs: []
  type: TYPE_NORMAL
- en: This function returns False for expressions that are “algebraic expressions”
    with symbolic exponents. This is a simple extension to the is_rational_function,
    including rational exponentiation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: This function does not attempt any nontrivial simplifications that may result
    in an expression that does not appear to be an algebraic expression to become
    one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_rational_function`](#sympy.core.expr.Expr.is_rational_function "sympy.core.expr.Expr.is_rational_function")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R122](#id21)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Algebraic_expression](https://en.wikipedia.org/wiki/Algebraic_expression)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: Return True if self is constant, False if not, or None if the constancy could
    not be determined conclusively.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'If an expression has no free symbols then it is a constant. If there are free
    symbols it is possible that the expression is a constant, perhaps (but not necessarily)
    zero. To test such expressions, a few strategies are tried:'
  prefs: []
  type: TYPE_NORMAL
- en: 1) numerical evaluation at two random points. If two such evaluations give two
    different values and the values have a precision greater than 1 then self is not
    constant. If the evaluations agree or could not be obtained with any precision,
    no decision is made. The numerical testing is done only if `wrt` is different
    than the free symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 2) differentiation with respect to variables in ‘wrt’ (or all free symbols if
    omitted) to see if the expression is constant or not. This will not always lead
    to an expression that is zero even though an expression is constant (see added
    test in test_expr.py). If all derivatives are zero then self is constant with
    respect to the given symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 3) finding out zeros of denominator expression with free_symbols. It will not
    be constant if there are zeros. It gives more negative answers for expression
    that are not constant.
  prefs: []
  type: TYPE_NORMAL
- en: If neither evaluation nor differentiation can prove the expression is constant,
    None is returned unless two numerical values happened to be the same and the flag
    `failing_number` is True – in that case the numerical value will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: If flag simplify=False is passed, self will not be simplified; the default is
    True since self should be simplified before testing.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: This tests whether an expression is meromorphic as a function of the given symbol
    `x` at the point `a`.
  prefs: []
  type: TYPE_NORMAL
- en: This method is intended as a quick test that will return None if no decision
    can be made without simplification or more detailed analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Multivalued functions are considered meromorphic when their branches are meromorphic.
    Thus most functions are meromorphic everywhere except at essential singularities
    and branch points. In particular, they will be meromorphic also on branch cuts
    except at their endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if `self` has no free symbols and no undefined functions (AppliedUndef,
    to be precise). It will be faster than `if not self.free_symbols`, however, since
    `is_number` will fail as soon as it hits a free symbol or undefined function.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'Not all numbers are Numbers in the SymPy sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: If something is a number it should evaluate to a number with real and imaginary
    parts that are Numbers; the result may not be comparable, however, since the real
    and/or imaginary part of the result may not have precision.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.basic.Basic.is_comparable`](#sympy.core.basic.Basic.is_comparable
    "sympy.core.basic.Basic.is_comparable")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Return True if self is a polynomial in syms and False otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: This checks if self is an exact polynomial in syms. This function returns False
    for expressions that are “polynomials” with symbolic exponents. Thus, you should
    be able to apply polynomial algorithms to expressions for which this returns True,
    and Poly(expr, *syms) should work if and only if expr.is_polynomial(*syms) returns
    True. The polynomial does not have to be in expanded form. If no symbols are given,
    all free symbols in the expression will be used.
  prefs: []
  type: TYPE_NORMAL
- en: This is not part of the assumptions system. You cannot do Symbol(‘z’, polynomial=True).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: This function does not attempt any nontrivial simplifications that may result
    in an expression that does not appear to be a polynomial to become one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: See also .is_rational_function()
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: Test whether function is a ratio of two polynomials in the given symbols, syms.
    When syms is not given, all free symbols will be used. The rational function does
    not have to be in expanded or in any kind of canonical form.
  prefs: []
  type: TYPE_NORMAL
- en: This function returns False for expressions that are “rational functions” with
    symbolic exponents. Thus, you should be able to call .as_numer_denom() and apply
    polynomial algorithms to the result for expressions for which this returns True.
  prefs: []
  type: TYPE_NORMAL
- en: This is not part of the assumptions system. You cannot do Symbol(‘z’, rational_function=True).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: This function does not attempt any nontrivial simplifications that may result
    in an expression that does not appear to be a rational function to become one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: See also is_algebraic_expr().
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: Returns the leading term a*x**b as a tuple (a, b).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: Compute limit x->xlim.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper for series yielding an iterator of the terms of the series.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: an infinite series will yield an infinite iterator. The following, for
    exaxmple, will never terminate. It will just keep printing terms of the sin(x)
    series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: The advantage of lseries() over nseries() is that many times you are just interested
    in the next term in the series (i.e. the first term for example), but you do not
    know how many you should ask for in nseries() using the “n” parameter.
  prefs: []
  type: TYPE_NORMAL
- en: See also nseries().
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: Return the expression as a fraction.
  prefs: []
  type: TYPE_NORMAL
- en: expression -> a/b
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_numer_denom`](#sympy.core.expr.Expr.as_numer_denom "sympy.core.expr.Expr.as_numer_denom")'
  prefs: []
  type: TYPE_NORMAL
- en: return `(a, b)` instead of `a/b`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper to _eval_nseries if assumptions allow, else to series.
  prefs: []
  type: TYPE_NORMAL
- en: If x is given, x0 is 0, dir=’+’, and self has x, then _eval_nseries is called.
    This calculates “n” terms in the innermost expressions and then builds up the
    final series just by “cross-multiplying” everything out.
  prefs: []
  type: TYPE_NORMAL
- en: The optional `logx` parameter can be used to replace any log(x) in the returned
    series with a symbolic value to avoid evaluating log(x) at 0\. A symbol to use
    in place of log(x) should be provided.
  prefs: []
  type: TYPE_NORMAL
- en: Advantage – it’s fast, because we do not have to determine how many terms we
    need to calculate in advance.
  prefs: []
  type: TYPE_NORMAL
- en: Disadvantage – you may end up with less terms than you may have expected, but
    the O(x**n) term appended will always be correct and so the result, though perhaps
    shorter, will also be correct.
  prefs: []
  type: TYPE_NORMAL
- en: If any of those assumptions is not met, this is treated like a wrapper to series
    which will try harder to return the correct number of terms.
  prefs: []
  type: TYPE_NORMAL
- en: See also lseries().
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling of the `logx` parameter — in the following example the expansion fails
    since `sin` does not have an asymptotic expansion at -oo (the limit of log(x)
    as x approaches 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following example, the expansion works but only returns self unless
    the `logx` parameter is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: See the nsimplify function in sympy.simplify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: See the powsimp function in sympy.simplify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: Return the positive Rational that can be extracted non-recursively from every
    term of self (i.e., self is treated like an Add). This is like the as_coeff_Mul()
    method but primitive always extracts a positive Rational (never a negative or
    a Float).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: See the radsimp function in sympy.simplify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: See the ratsimp function in sympy.simplify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: Removes the additive O(..) symbol if there is one
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: Return x rounded to the given decimal place.
  prefs: []
  type: TYPE_NORMAL
- en: If a complex number would results, apply round to the real and imaginary components
    of the number.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'The round method has a chopping effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `round` function uses the SymPy `round` method so it will always
    return a SymPy number (not a Python float or int):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: See the separate function in sympy.simplify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: Series expansion of “self” around `x = x0` yielding either terms of the series
    one by one (the lazy series given when n=None), else all the terms at once when
    n != None.
  prefs: []
  type: TYPE_NORMAL
- en: Returns the series expansion of “self” around the point `x = x0` with respect
    to `x` up to `O((x - x0)**n, x, x0)` (default n is 6).
  prefs: []
  type: TYPE_NORMAL
- en: If `x=None` and `self` is univariate, the univariate symbol will be supplied,
    otherwise an error will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**expr** : Expression'
  prefs: []
  type: TYPE_NORMAL
- en: The expression whose series is to be expanded.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**x** : Symbol'
  prefs: []
  type: TYPE_NORMAL
- en: It is the variable of the expression to be calculated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**x0** : Value'
  prefs: []
  type: TYPE_NORMAL
- en: The value around which `x` is calculated. Can be any value from `-oo` to `oo`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n** : Value'
  prefs: []
  type: TYPE_NORMAL
- en: The value used to represent the order in terms of `x**n`, up to which the series
    is to be expanded.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**dir** : String, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The series-expansion can be bi-directional. If `dir="+"`, then (x->x0+). If
    [PRE333] (`oo` or `-oo`), the `dir` argument is determined from the direction
    of the infinity (i.e., `dir="-"` for `oo`).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**logx** : optional'
  prefs: []
  type: TYPE_NORMAL
- en: It is used to replace any log(x) in the returned series with a symbolic value
    rather than evaluating the actual value.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**cdir** : optional'
  prefs: []
  type: TYPE_NORMAL
- en: It stands for complex direction, and indicates the direction from which the
    expansion needs to be evaluated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Expr** : Expression'
  prefs: []
  type: TYPE_NORMAL
- en: Series expansion of the expression about x0
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TypeError**'
  prefs: []
  type: TYPE_NORMAL
- en: If “n” and “x0” are infinity objects
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**PoleError**'
  prefs: []
  type: TYPE_NORMAL
- en: If “x0” is an infinity object
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: If `n=None` then a generator of the series terms will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: For `dir=+` (default) the series is calculated from the right and for `dir=-`
    the series from the left. For smooth functions this flag will not alter the results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: For rational expressions this method may return original expression without
    the Order term. >>> (1/x).series(x, n=8) 1/x
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: General method for the taylor term.
  prefs: []
  type: TYPE_NORMAL
- en: This method is slow, because it differentiates n-times. Subclasses can redefine
    it to make it faster by using the “previous_terms”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: See the together function in sympy.polys
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: See the trigsimp function in sympy.simplify
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: Expression that is not evaluated unless released.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: A parent class for object which are both atoms and Exprs.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example: Symbol, Number, Rational, Integer, … But not: Add, Mul, Pow, …  ##
    symbol'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: Symbol class is used to create symbolic variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**AtomicExpr: variable name**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Boolean: Assumption with a boolean value(True or False)**'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic variables are placeholders for mathematical symbols that can represent
    numbers, constants, or any other mathematical entities and can be used in mathematical
    expressions and to perform symbolic computations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assumptions:'
  prefs: []
  type: TYPE_NORMAL
- en: commutative = True positive = True real = True imaginary = True complex = True
    complete list of more assumptions- [Predicates](assumptions/predicates.html#predicates)
  prefs: []
  type: TYPE_NORMAL
- en: You can override the default assumptions in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'passing in greek letters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'Trailing digits are automatically treated like subscripts of what precedes
    them in the name. General format to add subscript to a symbol : `<var_name> =
    Symbol(''<symbol_name>_<subscript>'')`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: A Wild symbol matches anything, or anything without whatever is explicitly excluded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**name** : str'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the Wild instance.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**exclude** : iterable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Instances in `exclude` will not be matched.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**properties** : iterable of functions, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Functions, each taking an expressions as input and returns a `bool`. All functions
    in `properties` need to return `True` in order for the Wild instance to match
    the expression.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Tips
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Wild, be sure to use the exclude keyword to make the pattern more
    precise. Without the exclude pattern, you may get matches that are technically
    correct, but not what you wanted. For example, using the above without exclude:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: This is technically correct, because (2/x)*x + 3*y == 2 + 3*y, but you probably
    wanted it to not match at all. The issue is that you really did not want a and
    b to include x and y, and the exclude parameter lets you specify exactly this.
    With the exclude parameter, the pattern will not match.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: Exclude also helps remove ambiguity from matches.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: 'Wild also accepts a `properties` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'Dummy symbols are each unique, even if they have the same name:'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: If a name is not supplied then a string value of an internal count will be used.
    This is useful when a temporary variable is needed and the name of the variable
    used in the expression is not important.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: Transform strings into instances of [`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols") function
    returns a sequence of symbols with names taken from `names` argument, which can
    be a comma or whitespace delimited string, or a sequence of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: 'The type of output is dependent on the properties of input arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'If an iterable container is needed for a single symbol, set the `seq` argument
    to `True` or terminate the symbol name with a comma:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'To reduce typing, range syntax is supported to create indexed symbols. Ranges
    are indicated by a colon and the type of range is determined by the character
    to the right of the colon. If the character is a digit then all contiguous digits
    to the left are taken as the nonnegative starting value (or 0 if there is no digit
    left of the colon) and all contiguous digits to the right are taken as 1 greater
    than the ending value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: 'If the character to the right of the colon is a letter, then the single letter
    to the left (or ‘a’ if there is none) is taken as the start and all characters
    in the lexicographic range *through* the letter to the right are used as the range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple ranges are supported; contiguous numerical ranges should be separated
    by parentheses to disambiguate the ending number of one range from the starting
    number of the next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: 'Only one pair of parentheses surrounding ranges are removed, so to include
    parentheses around ranges, double them. And to include spaces, commas, or colons,
    escape them with a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'All newly created symbols have assumptions set according to `args`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'Despite its name, [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    can create symbol-like objects like instances of Function or Wild classes. To
    achieve this, set `cls` keyword argument to the desired type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: Create symbols and inject them into the global namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'This calls [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    with the same arguments and puts the results into the *global* namespace. It’s
    recommended not to use [`var()`](#sympy.core.symbol.var "sympy.core.symbol.var")
    in library code, where [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    has to be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'See [`symbols()`](#sympy.core.symbol.symbols "sympy.core.symbol.symbols") documentation
    for more details on what kinds of arguments can be passed to [`var()`](#sympy.core.symbol.var
    "sympy.core.symbol.var").  ## intfunc'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: Return the number of digits needed to express n in give base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n: integer**'
  prefs: []
  type: TYPE_NORMAL
- en: The number whose digits are counted.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**b: integer**'
  prefs: []
  type: TYPE_NORMAL
- en: The base in which digits are computed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.digits.digits`](ntheory.html#sympy.ntheory.digits.digits "sympy.ntheory.digits.digits"),
    [`sympy.ntheory.digits.count_digits`](ntheory.html#sympy.ntheory.digits.count_digits
    "sympy.ntheory.digits.count_digits")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: Count the number of trailing zero digits in the binary representation of n,
    i.e. determine the largest power of 2 that divides n.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.factor_.multiplicity`](ntheory.html#sympy.ntheory.factor_.multiplicity
    "sympy.ntheory.factor_.multiplicity")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: Computes integer least common multiple.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: Computes nonnegative integer greatest common divisor.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is based on the well known Euclid’s algorithm [[R123]](#r123).
    To improve speed, `igcd()` has its own caching mechanism. If you do not need the
    cache mechanism, using `sympy.external.gmpy.gcd`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R123] ([1](#id22),[2](#id23))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Euclidean_algorithm](https://en.wikipedia.org/wiki/Euclidean_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: Computes greatest common divisor of two integers.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Euclid’s algorithm for the computation of the greatest common divisor `gcd(a,
    b)` of two (positive) integers \(a\) and \(b\) is based on the division identity
    $$ a = q \times b + r$$, where the quotient \(q\) and the remainder \(r\) are
    integers and \(0 \le r < b\). Then each common divisor of \(a\) and \(b\) divides
    \(r\), and it follows that `gcd(a, b) == gcd(b, r)`. The algorithm works by constructing
    the sequence r0, r1, r2, …, where r0 = a, r1 = b, and each rn is the remainder
    from the division of the two preceding elements.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, `q = a // b` and `r = a % b` are obtained by the floor division and
    the remainder operations, respectively. These are the most expensive arithmetic
    operations, especially for large a and b.
  prefs: []
  type: TYPE_NORMAL
- en: Lehmer’s algorithm [[R124]](#r124) is based on the observation that the quotients
    `qn = r(n-1) // rn` are in general small integers even when a and b are very large.
    Hence the quotients can be usually determined from a relatively small number of
    most significant bits.
  prefs: []
  type: TYPE_NORMAL
- en: The efficiency of the algorithm is further enhanced by not computing each long
    remainder in Euclid’s sequence. The remainders are linear combinations of a and
    b with integer coefficients derived from the quotients. The coefficients can be
    computed as far as the quotients can be determined from the chosen most significant
    parts of a and b. Only then a new pair of consecutive remainders is computed and
    the algorithm starts anew with this pair.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R124] ([1](#id24),[2](#id25))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm](https://en.wikipedia.org/wiki/Lehmer%27s_GCD_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: Returns x, y, g such that g = x*a + y*b = gcd(a, b).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: Return the largest integer less than or equal to \(\sqrt{n}\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : non-negative integer'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**int** : \(\left\lfloor\sqrt{n}\right\rfloor\)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If n is negative.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**TypeError**'
  prefs: []
  type: TYPE_NORMAL
- en: If n is of a type that cannot be compared to `int`. Therefore, a TypeError is
    raised for `str`, but not for `float`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: Return a tuple containing x = floor(y**(1/n)) and a boolean indicating whether
    the result is exact (that is, whether x**n == y).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: 'To simply determine if a number is a perfect square, the is_square function
    should be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.ntheory.primetest.is_square`](ntheory.html#sympy.ntheory.primetest.is_square
    "sympy.ntheory.primetest.is_square"), [`integer_log`](#sympy.core.intfunc.integer_log
    "sympy.core.intfunc.integer_log")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: Returns `(e, bool)` where e is the largest nonnegative integer such that \(|n|
    \geq |b^e|\) and `bool` is True if \(n = b^e\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: 'If the base is positive and the number negative the return value will always
    be the same except for 2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'When the base is negative, the returned value will only be True if the parity
    of the exponent is correct for the sign of the base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`integer_nthroot`](#sympy.core.intfunc.integer_nthroot "sympy.core.intfunc.integer_nthroot"),
    [`sympy.ntheory.primetest.is_square`](ntheory.html#sympy.ntheory.primetest.is_square
    "sympy.ntheory.primetest.is_square"), [`sympy.ntheory.factor_.multiplicity`](ntheory.html#sympy.ntheory.factor_.multiplicity
    "sympy.ntheory.factor_.multiplicity"), [`sympy.ntheory.factor_.perfect_power`](ntheory.html#sympy.ntheory.factor_.perfect_power
    "sympy.ntheory.factor_.perfect_power")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: Return the number \(c\) such that, \(a \times c = 1 \pmod{m}\) where \(c\) has
    the same sign as \(m\). If no such value exists, a ValueError is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we wish to find multiplicative inverse \(x\) of 3 modulo 11\. This
    is the same as finding \(x\) such that \(3x = 1 \pmod{11}\). One value of x that
    satisfies this congruence is 4\. Because \(3 \times 4 = 12\) and \(12 = 1 \pmod{11}\).
    This is the value returned by `mod_inverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: 'When there is a common factor between the numerators of \(a\) and \(m\) the
    inverse does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R125](#id26)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Modular_multiplicative_inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R126](#id27)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)  ##
    numbers'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Represents atomic numbers in SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Floating point numbers are represented by the Float class. Rational numbers
    (of any size) are represented by the Rational class. Integer numbers (of any size)
    are represented by the Integer class. Float and Rational are subclasses of Number;
    Integer is a subclass of Rational.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `2/3` is represented as `Rational(2, 3)` which is a different object
    from the floating point number obtained with Python division `2/3`. Even for numbers
    that are exactly represented in binary, there is a difference between how two
    forms, such as `Rational(1, 2)` and `Float(0.5)`, are used in SymPy. The rational
    form is to be preferred in symbolic computations.
  prefs: []
  type: TYPE_NORMAL
- en: Other kinds of numbers, such as algebraic numbers `sqrt(2)` or complex numbers
    `3 + 4*I`, are not instances of Number class as they are not atomic.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Float`](#sympy.core.numbers.Float "sympy.core.numbers.Float"), [`Integer`](#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), [`Rational`](#sympy.core.numbers.Rational "sympy.core.numbers.Rational")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: Efficiently extract the coefficient of a summation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: Efficiently extract the coefficient of a product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: Compute GCD and cofactors of \(self\) and \(other\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: Compute GCD of \(self\) and \(other\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: Compute LCM of \(self\) and \(other\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: Represent a floating-point number of arbitrary precision.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: Creating Floats from strings (and Python `int` and `long` types) will give a
    minimum precision of 15 digits, but the precision will automatically increase
    to capture all digits entered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: 'However, *floating-point* numbers (Python `float` types) retain only 15 digits
    of precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: 'It may be preferable to enter high-precision decimal numbers as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: 'The desired number of digits can also be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: Float can automatically count significant figures if a null string is sent for
    the precision; spaces or underscores are also allowed. (Auto- counting is only
    allowed for strings, ints and longs).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: 'If a number is written in scientific notation, only the digits before the exponent
    are considered significant if a decimal appears, otherwise the “e” signifies only
    how to move the decimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Floats are inexact by their nature unless their value is a binary-exact value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: 'For calculation purposes, evalf needs to be able to change the precision but
    this will not increase the accuracy of the inexact value. The following is the
    most accurate 5-digit approximation of a value of 0.1 that had only 1 digit of
    precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'By contrast, 0.125 is exact in binary (as it is in base 10) and so it can be
    passed to Float or evalf to obtain an arbitrary precision with matching accuracy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to make a high-precision Float from a float is not disallowed, but one
    must keep in mind that the *underlying float* (not the apparent decimal value)
    is being obtained with high precision. For example, 0.3 does not have a finite
    binary representation. The closest rational is the fraction 5404319552844595/2**54\.
    So if you try to obtain a Float of 0.3 to 20 digits of precision you will not
    see the same thing as 0.3 followed by 19 zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want a 20-digit value of the decimal 0.3 (not the floating point approximation
    of 0.3) you should send the 0.3 as a string. The underlying representation is
    still binary but a higher precision than Python’s float is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'Although you can increase the precision of an existing Float using Float it
    will not increase the accuracy – the underlying value is not changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'The same thing happens when evalf is used on a Float:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Floats can be instantiated with an mpf tuple (n, c, p) to produce
    the number (-1)**n*c*2**p:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: 'An actual mpf tuple also contains the number of bits in c as the last element
    of the tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: This is not needed for instantiation and is not the same thing as the precision.
    The mpf tuple and the precision are two separate quantities that Float tracks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In SymPy, a Float is a number that can be computed with arbitrary precision.
    Although floating point ‘inf’ and ‘nan’ are not such numbers, Float can create
    these numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: Zero in Float only has a single value. Values are not separate for positive
    and negative zeroes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: Represents rational numbers (p/q) of any size.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'Rational is unprejudiced in accepting input. If a float is passed, the underlying
    value of the binary representation will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'If the simpler representation of the float is desired then consider limiting
    the denominator to the desired value or convert the float to a string (which is
    roughly equivalent to limiting the denominator to 10**12):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: 'An arbitrarily precise Rational is obtained when a string literal is passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: 'The conversion of other types of strings can be handled by the sympify() function,
    and conversion of floats to expressions or simple fractions can be handled with
    nsimplify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: 'But if the input does not reduce to a literal Rational, an error will be raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: Low-level
  prefs: []
  type: TYPE_NORMAL
- en: 'Access numerator and denominator as .p and .q:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that p and q return integers (not SymPy Integers) so some care is needed
    when using them in expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: If an unevaluated Rational is desired, `gcd=1` can be passed and this will keep
    common divisors of the numerator and denominator from being eliminated. It is
    not possible, however, to leave a negative value in the denominator.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.sympify.sympify`](#sympy.core.sympify.sympify "sympy.core.sympify.sympify"),
    [`sympy.simplify.simplify.nsimplify`](simplify/simplify.html#sympy.simplify.simplify.nsimplify
    "sympy.simplify.simplify.nsimplify")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: Efficiently extract the coefficient of a summation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: Efficiently extract the coefficient of a product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: Return the tuple (R, self/R) where R is the positive Rational extracted from
    self.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: See docstring of Expr.as_content_primitive for more examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: A wrapper to factorint which return factors of self that are smaller than limit
    (or cheap to compute). Special methods of factoring are disabled by default so
    that only trial division is used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: Closest Rational to self with denominator at most max_denominator.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: Represents integer numbers of any size.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: If a float or a rational is passed to Integer, the fractional part will be discarded;
    the effect is of rounding toward zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: 'A string is acceptable input if it can be parsed as an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: It is rarely needed to explicitly instantiate an Integer, because Python integers
    are automatically converted to Integer when they are used in SymPy expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: Class for representing algebraic numbers in SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolically, an instance of this class represents an element \(\alpha \in \mathbb{Q}(\theta)
    \hookrightarrow \mathbb{C}\). That is, the algebraic number \(\alpha\) is represented
    as an element of a particular number field \(\mathbb{Q}(\theta)\), with a particular
    embedding of this field into the complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Formally, the primitive element \(\theta\) is given by two data points: (1)
    its minimal polynomial (which defines \(\mathbb{Q}(\theta)\)), and (2) a particular
    complex number that is a root of this polynomial (which defines the embedding
    \(\mathbb{Q}(\theta) \hookrightarrow \mathbb{C}\)). Finally, the algebraic number
    \(\alpha\) which we represent is then given by the coefficients of a polynomial
    in \(\theta\).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new algebraic number \(\alpha\) belonging to a number field \(k
    = \mathbb{Q}(\theta)\).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four instance attributes to be determined:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Type/Meaning |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `root` | [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr") for \(\theta\)
    as a complex number |'
  prefs: []
  type: TYPE_TB
- en: '| `minpoly` | [`Poly`](polys/reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly"),
    the minimal polynomial of \(\theta\) |'
  prefs: []
  type: TYPE_TB
- en: '| `rep` | [`DMP`](polys/domainsref.html#sympy.polys.polyclasses.DMP "sympy.polys.polyclasses.DMP")
    giving \(\alpha\) as poly in \(\theta\) |'
  prefs: []
  type: TYPE_TB
- en: '| `alias` | [`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")
    for \(\theta\), or `None` |'
  prefs: []
  type: TYPE_TB
- en: See Parameters section for how they are determined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**expr** : [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr"), or pair
    \((m, r)\)'
  prefs: []
  type: TYPE_NORMAL
- en: There are three distinct modes of construction, depending on what is passed
    as *expr*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**(1)** *expr* is an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber"): In this case we begin by copying all four
    instance attributes from *expr*. If *coeffs* were also given, we compose the two
    coeff polynomials (see below). If an *alias* was given, it overrides.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**(2)** *expr* is any other type of [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr"):
    Then `root` will equal *expr*. Therefore it must express an algebraic quantity,
    and we will compute its `minpoly`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**(3)** *expr* is an ordered pair \((m, r)\) giving the `minpoly` \(m\), and
    a `root` \(r\) thereof, which together define \(\theta\). In this case \(m\) may
    be either a univariate [`Poly`](polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") or any [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr")
    which represents the same, while \(r\) must be some [`Expr`](#sympy.core.expr.Expr
    "sympy.core.expr.Expr") representing a complex number that is a root of \(m\),
    including both explicit expressions in radicals, and instances of [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf") or [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber").'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**coeffs** : list, [`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP"), None, optional (default=None)'
  prefs: []
  type: TYPE_NORMAL
- en: This defines `rep`, giving the algebraic number \(\alpha\) as a polynomial in
    \(\theta\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a list, the elements should be integers or rational numbers. If an [`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP"), we take its coefficients (using its [`to_list()`](polys/domainsref.html#sympy.polys.polyclasses.ANP.to_list
    "sympy.polys.polyclasses.ANP.to_list") method). If `None`, then the list of coefficients
    defaults to `[1, 0]`, meaning that \(\alpha = \theta\) is the primitive element
    of the field.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If *expr* was an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber"),
    let \(g(x)\) be its `rep` polynomial, and let \(f(x)\) be the polynomial defined
    by *coeffs*. Then `self.rep` will represent the composition \((f \circ g)(x)\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**alias** : str, [`Symbol`](#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol"),
    None, optional (default=None)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a way to provide a name for the primitive element. We described several
    ways in which the *expr* argument can define the value of the primitive element,
    but none of these methods gave it a name. Here, for example, *alias* could be
    set as `Symbol('theta')`, in order to make this symbol appear when \(\alpha\)
    is printed, or rendered as a polynomial, using the [`as_poly()`](#sympy.core.numbers.AlgebraicNumber.as_poly
    "sympy.core.numbers.AlgebraicNumber.as_poly") method.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we are constructing an algebraic number as a field element \(\alpha
    \in \mathbb{Q}(\theta)\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: 'Example (1): \(\alpha = \theta = \sqrt{2}\)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: 'Example (2): \(\alpha = 3 \sqrt{2} - 5\), \(\theta = \sqrt{2}\). We can either
    build on the last example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs: []
  type: TYPE_PRE
- en: 'or start from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: 'Example (3): \(\alpha = 6 \sqrt{2} - 11\), \(\theta = \sqrt{2}\). Again we
    can build on the previous example, and we see that the coeff polys are composed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: reflecting the fact that \((2x - 1) \circ (3x - 5) = 6x - 11\).
  prefs: []
  type: TYPE_NORMAL
- en: 'Example (4): \(\alpha = \sqrt{2}\), \(\theta = \sqrt{2} + \sqrt{3}\). The easiest
    way is to use the [`to_number_field()`](polys/numberfields.html#sympy.polys.numberfields.subfield.to_number_field
    "sympy.polys.numberfields.subfield.to_number_field") function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs: []
  type: TYPE_PRE
- en: 'but if you already knew the right coefficients, you could construct it directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: 'Example (5): Construct the Golden Ratio as an element of the 5th cyclotomic
    field, supposing we already know its coefficients. This time we introduce the
    alias \(\zeta\) for the primitive element of the field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: (The index `-1` to `CRootOf` selects the complex root with the largest real
    and imaginary parts, which in this case is \(\mathrm{e}^{2i\pi/5}\). See [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf").)
  prefs: []
  type: TYPE_NORMAL
- en: 'Example (6): Building on the last example, construct the number \(2 \phi \in
    \mathbb{Q}(\phi)\), where \(\phi\) is the Golden Ratio:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we needed to use `a5.to_root()`, since passing `a5` as the first
    argument would have constructed the number \(2 \phi\) as an element of the field
    \(\mathbb{Q}(\zeta)\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: Create a Basic expression from `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: Create a Poly instance from `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: Returns all SymPy coefficients of an algebraic number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: Form another element of the same number field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**coeffs** : list, [`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP")'
  prefs: []
  type: TYPE_NORMAL
- en: Like the *coeffs* arg to the class [`constructor`](#sympy.core.numbers.AlgebraicNumber.__new__
    "sympy.core.numbers.AlgebraicNumber.__new__"), defines the new element as a polynomial
    in the primitive element.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If a list, the elements should be integers or rational numbers. If an [`ANP`](polys/domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP"), we take its coefficients (using its [`to_list()`](polys/domainsref.html#sympy.polys.polyclasses.ANP.to_list
    "sympy.polys.polyclasses.ANP.to_list") method).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If we represent \(\alpha \in \mathbb{Q}(\theta)\), form another element \(\beta
    \in \mathbb{Q}(\theta)\) of the same number field.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: Returns `True` if `alias` was set.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: Say whether this algebraic number \(\alpha \in \mathbb{Q}(\theta)\) is equal
    to the primitive element \(\theta\) for its field.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: Compute the minimal polynomial for this algebraic number.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Recall that we represent an element \(\alpha \in \mathbb{Q}(\theta)\). Our instance
    attribute `self.minpoly` is the minimal polynomial for our primitive element \(\theta\).
    This method computes the minimal polynomial for \(\alpha\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: Returns all native coefficients of an algebraic number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: Get the primitive element \(\theta\) for the number field \(\mathbb{Q}(\theta)\)
    to which this algebraic number \(\alpha\) belongs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: AlgebraicNumber
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: Convert `self` to an algebraic integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: Convert `self` to an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber") instance that is equal to its own primitive
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**radicals** : boolean, optional (default=True)'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, then we will try to return an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber") whose `root` is an expression in radicals.
    If that is not possible (or if *radicals* is `False`), `root` will be a [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: AlgebraicNumber
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If we represent \(\alpha \in \mathbb{Q}(\theta)\), \(\alpha \neq \theta\), construct
    a new [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")
    that represents \(\alpha \in \mathbb{Q}(\alpha)\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: The [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")
    `a` represents the number \(\sqrt{2}\) in the field \(\mathbb{Q}(\sqrt{2} + \sqrt{3})\).
    Rendering `a` as a polynomial,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: reflects the fact that \(\sqrt{2} = \theta^3/2 - 9 \theta/2\), where \(\theta
    = \sqrt{2} + \sqrt{3}\).
  prefs: []
  type: TYPE_NORMAL
- en: '`a` is not equal to its own primitive element. Its minpoly'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: is that of \(\theta\).
  prefs: []
  type: TYPE_NORMAL
- en: Converting to a primitive element,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: we obtain an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")
    whose `minpoly` is that of the number itself.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_primitive_element`](#sympy.core.numbers.AlgebraicNumber.is_primitive_element
    "sympy.core.numbers.AlgebraicNumber.is_primitive_element")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: Convert to an [`Expr`](#sympy.core.expr.Expr "sympy.core.expr.Expr") that is
    not an [`AlgebraicNumber`](#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber"),
    specifically, either a [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf"), or, optionally and where possible, an
    expression in radicals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**radicals** : boolean, optional (default=True)'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, then we will try to return the root as an expression in radicals.
    If that is not possible, we will return a [`ComplexRootOf`](polys/reference.html#sympy.polys.rootoftools.ComplexRootOf
    "sympy.polys.rootoftools.ComplexRootOf").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**minpoly** : [`Poly`](polys/reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")'
  prefs: []
  type: TYPE_NORMAL
- en: If the minimal polynomial for \(self\) has been pre-computed, it can be passed
    in order to save time.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: Return an interval with number_cls endpoints that contains the value of NumberSymbol.
    If not implemented, then return None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Float`](#sympy.core.numbers.Float "sympy.core.numbers.Float")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: Should SymPy raise an exception on 0/0 or return a nan?
  prefs: []
  type: TYPE_NORMAL
- en: divide == True …. raise an exception divide == False … return nan
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: The number zero.
  prefs: []
  type: TYPE_NORMAL
- en: Zero is a singleton, and can be accessed by `S.Zero`
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R127](#id28)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Zero](https://en.wikipedia.org/wiki/Zero)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: The number one.
  prefs: []
  type: TYPE_NORMAL
- en: One is a singleton, and can be accessed by `S.One`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R128](#id29)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/1_%28number%29](https://en.wikipedia.org/wiki/1_%28number%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: The number negative one.
  prefs: []
  type: TYPE_NORMAL
- en: NegativeOne is a singleton, and can be accessed by `S.NegativeOne`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`One`](#sympy.core.numbers.One "sympy.core.numbers.One")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R129](#id30)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/%E2%88%921_%28number%29](https://en.wikipedia.org/wiki/%E2%88%921_%28number%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: The rational number 1/2.
  prefs: []
  type: TYPE_NORMAL
- en: Half is a singleton, and can be accessed by `S.Half`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R130](#id31)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/One_half](https://en.wikipedia.org/wiki/One_half)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: Not a Number.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This serves as a place holder for numeric values that are indeterminate. Most
    operations on NaN, produce another NaN. Most indeterminate forms, such as `0/0`
    or [PRE486] and `oo**0`, which all produce `1` (this is consistent with Python’s
    float).
  prefs: []
  type: TYPE_NORMAL
- en: NaN is loosely related to floating point nan, which is defined in the IEEE 754
    floating point standard, and corresponds to the Python `float('nan')`. Differences
    are noted below.
  prefs: []
  type: TYPE_NORMAL
- en: NaN is mathematically not equal to anything else, even NaN itself. This explains
    the initially counter-intuitive results with `Eq` and `==` in the examples below.
  prefs: []
  type: TYPE_NORMAL
- en: NaN is not comparable so inequalities raise a TypeError. This is in contrast
    with floating point nan where all inequalities are false.
  prefs: []
  type: TYPE_NORMAL
- en: NaN is a singleton, and can be accessed by `S.NaN`, or can be imported as `nan`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R131](#id32)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/NaN](https://en.wikipedia.org/wiki/NaN)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: Positive infinite quantity.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'In real analysis the symbol \(\infty\) denotes an unbounded limit: \(x\to\infty\)
    means that \(x\) grows without bound.'
  prefs: []
  type: TYPE_NORMAL
- en: Infinity is often used not only to define a limit but as a value in the affinely
    extended real number system. Points labeled \(+\infty\) and \(-\infty\) can be
    added to the topological space of the real numbers, producing the two-point compactification
    of the real numbers. Adding algebraic properties to this gives us the extended
    real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Infinity is a singleton, and can be accessed by `S.Infinity`, or can be imported
    as `oo`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`NegativeInfinity`](#sympy.core.numbers.NegativeInfinity "sympy.core.numbers.NegativeInfinity"),
    [`NaN`](#sympy.core.numbers.NaN "sympy.core.numbers.NaN")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R132](#id33)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Infinity](https://en.wikipedia.org/wiki/Infinity)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: Negative infinite quantity.
  prefs: []
  type: TYPE_NORMAL
- en: NegativeInfinity is a singleton, and can be accessed by `S.NegativeInfinity`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Infinity`](#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: Complex infinity.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: In complex analysis the symbol \(\tilde\infty\), called “complex infinity”,
    represents a quantity with infinite magnitude, but undetermined complex phase.
  prefs: []
  type: TYPE_NORMAL
- en: ComplexInfinity is a singleton, and can be accessed by `S.ComplexInfinity`,
    or can be imported as `zoo`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Infinity`](#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: The \(e\) constant.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The transcendental number \(e = 2.718281828\ldots\) is the base of the natural
    logarithm and of the exponential function, \(e = \exp(1)\). Sometimes called Euler’s
    number or Napier’s constant.
  prefs: []
  type: TYPE_NORMAL
- en: Exp1 is a singleton, and can be accessed by `S.Exp1`, or can be imported as
    `E`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R133](#id34)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/E_%28mathematical_constant%29](https://en.wikipedia.org/wiki/E_%28mathematical_constant%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: The imaginary unit, \(i = \sqrt{-1}\).
  prefs: []
  type: TYPE_NORMAL
- en: I is a singleton, and can be accessed by `S.I`, or can be imported as `I`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R134](#id35)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Imaginary_unit](https://en.wikipedia.org/wiki/Imaginary_unit)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: The \(\pi\) constant.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The transcendental number \(\pi = 3.141592654\ldots\) represents the ratio of
    a circle’s circumference to its diameter, the area of the unit circle, the half-period
    of trigonometric functions, and many other things in mathematics.
  prefs: []
  type: TYPE_NORMAL
- en: Pi is a singleton, and can be accessed by `S.Pi`, or can be imported as `pi`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R135](#id36)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Pi](https://en.wikipedia.org/wiki/Pi)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: The Euler-Mascheroni constant.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '\(\gamma = 0.5772157\ldots\) (also called Euler’s constant) is a mathematical
    constant recurring in analysis and number theory. It is defined as the limiting
    difference between the harmonic series and the natural logarithm:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\gamma = \lim\limits_{n\to\infty} \left(\sum\limits_{k=1}^n\frac{1}{k} - \ln
    n\right)\]
  prefs: []
  type: TYPE_NORMAL
- en: EulerGamma is a singleton, and can be accessed by `S.EulerGamma`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R136](#id37)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant](https://en.wikipedia.org/wiki/Euler%E2%80%93Mascheroni_constant)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: Catalan’s constant.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: \(G = 0.91596559\ldots\) is given by the infinite series
  prefs: []
  type: TYPE_NORMAL
- en: \[G = \sum_{k=0}^{\infty} \frac{(-1)^k}{(2k+1)^2}\]
  prefs: []
  type: TYPE_NORMAL
- en: Catalan is a singleton, and can be accessed by `S.Catalan`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R137](#id38)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Catalan%27s_constant](https://en.wikipedia.org/wiki/Catalan%27s_constant)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: The golden ratio, \(\phi\).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: \(\phi = \frac{1 + \sqrt{5}}{2}\) is an algebraic number. Two quantities are
    in the golden ratio if their ratio is the same as the ratio of their sum to the
    larger of the two quantities, i.e. their maximum.
  prefs: []
  type: TYPE_NORMAL
- en: GoldenRatio is a singleton, and can be accessed by `S.GoldenRatio`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R138](#id39)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Golden_ratio](https://en.wikipedia.org/wiki/Golden_ratio)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: The tribonacci constant.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The tribonacci numbers are like the Fibonacci numbers, but instead of starting
    with two predetermined terms, the sequence starts with three predetermined terms
    and each term afterwards is the sum of the preceding three terms.
  prefs: []
  type: TYPE_NORMAL
- en: The tribonacci constant is the ratio toward which adjacent tribonacci numbers
    tend. It is a root of the polynomial \(x^3 - x^2 - x - 1 = 0\), and also satisfies
    the equation \(x + x^{-3} = 2\).
  prefs: []
  type: TYPE_NORMAL
- en: TribonacciConstant is a singleton, and can be accessed by `S.TribonacciConstant`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R139](#id40)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers](https://en.wikipedia.org/wiki/Generalizations_of_Fibonacci_numbers#Tribonacci_numbers)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Return the number \(c\) such that, \(a \times c = 1 \pmod{m}\) where \(c\) has
    the same sign as \(m\). If no such value exists, a ValueError is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose we wish to find multiplicative inverse \(x\) of 3 modulo 11\. This
    is the same as finding \(x\) such that \(3x = 1 \pmod{11}\). One value of x that
    satisfies this congruence is 4\. Because \(3 \times 4 = 12\) and \(12 = 1 \pmod{11}\).
    This is the value returned by `mod_inverse`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: 'When there is a common factor between the numerators of \(a\) and \(m\) the
    inverse does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R140](#id41)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Modular_multiplicative_inverse](https://en.wikipedia.org/wiki/Modular_multiplicative_inverse)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R141](#id42)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm](https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: Compare expressions treating plain floats as rationals.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: 'In SymPy expressions with Floats compare unequal to corresponding expressions
    with rationals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: 'However an individual Float compares equal to a Rational:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: In a future version of SymPy this might change so that Rational and Float compare
    unequal. This function provides the behavior currently expected of `==` so that
    it could still be used if the behavior of `==` were to change in future.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: In future SymPy verions Float and Rational might compare unequal and floats
    with different precisions might compare unequal. In that context a function is
    needed that can check if a number is equal to 1 or 0 etc. The idea is that instead
    of testing `if x == 1:` if we want to accept floats like `1.0` as well then the
    test can be written as `if equal_valued(x, 1):` or `if equal_valued(x, 2):`. Since
    this function is intended to be used in situations where one or both operands
    are expected to be concrete numbers like 1 or 0 the function does not recurse
    through the args of any compound expression to compare any nested floats.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R142](#id43)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/sympy/sympy/pull/20033](https://github.com/sympy/sympy/pull/20033)  ##
    power'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: Defines the expression x**y as “x raised to a power y”
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.7: Using arguments that aren’t subclasses of [`Expr`](#sympy.core.expr.Expr
    "sympy.core.expr.Expr") in core operators ([`Mul`](#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    [`Add`](#sympy.core.add.Add "sympy.core.add.Add"), and [`Pow`](#sympy.core.power.Pow
    "sympy.core.power.Pow")) is deprecated. See [Core operators no longer accept non-Expr
    args](../explanation/active-deprecations.html#non-expr-args-deprecated) for details.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Singleton definitions involving (0, 1, -1, oo, -oo, I, -I):'
  prefs: []
  type: TYPE_NORMAL
- en: '| expr | value | reason |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| z**0 | 1 | Although arguments over 0**0 exist, see [2]. |'
  prefs: []
  type: TYPE_TB
- en: '| z**1 | z |  |'
  prefs: []
  type: TYPE_TB
- en: '| (-oo)**(-1) | 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| (-1)**-1 | -1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| S.Zero**-1 | zoo | This is not strictly true, as 0**-1 may be undefined,
    but is convenient in some contexts where the base is assumed to be positive. |'
  prefs: []
  type: TYPE_TB
- en: '| 1**-1 | 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| oo**-1 | 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 0**oo | 0 | Because for all complex numbers z near 0, z**oo -> 0. |'
  prefs: []
  type: TYPE_TB
- en: '| 0**-oo | zoo | This is not strictly true, as 0**oo may be oscillating between
    positive and negative values or rotating in the complex plane. It is convenient,
    however, when the base is positive. |'
  prefs: []
  type: TYPE_TB
- en: '| 1**oo 1**-oo | nan | Because there are various cases where lim(x(t),t)=1,
    lim(y(t),t)=oo (or -oo), but lim( x(t)**y(t), t) != 1\. See [3]. |'
  prefs: []
  type: TYPE_TB
- en: '| b**zoo | nan | Because b**z has no limit as z -> zoo |'
  prefs: []
  type: TYPE_TB
- en: '| (-1)**oo (-1)**(-oo) | nan | Because of oscillations in the limit. |'
  prefs: []
  type: TYPE_TB
- en: '| oo**oo | oo |  |'
  prefs: []
  type: TYPE_TB
- en: '| oo**-oo | 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| (-oo)**oo (-oo)**-oo | nan |  |'
  prefs: []
  type: TYPE_TB
- en: '| oo**I (-oo)**I | nan | oo**e could probably be best thought of as the limit
    of x**e for real x as x tends to oo. If e is I, then the limit does not exist
    and nan is used to indicate that. |'
  prefs: []
  type: TYPE_TB
- en: '| oo**(1+I) (-oo)**(1+I) | zoo | If the real part of e is positive, then the
    limit of abs(x**e) is oo. So the limit value is zoo. |'
  prefs: []
  type: TYPE_TB
- en: '| oo**(-1+I) -oo**(-1+I) | 0 | If the real part of e is negative, then the
    limit is 0. |'
  prefs: []
  type: TYPE_TB
- en: Because symbolic computations are more flexible than floating point calculations
    and we prefer to never return an incorrect answer, we choose not to conform to
    all IEEE 754 conventions. This helps us avoid extra test-case code in the calculation
    of limits.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.numbers.Infinity`](#sympy.core.numbers.Infinity "sympy.core.numbers.Infinity"),
    [`sympy.core.numbers.NegativeInfinity`](#sympy.core.numbers.NegativeInfinity "sympy.core.numbers.NegativeInfinity"),
    [`sympy.core.numbers.NaN`](#sympy.core.numbers.NaN "sympy.core.numbers.NaN")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R143](#id44)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Exponentiation](https://en.wikipedia.org/wiki/Exponentiation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R144](#id45)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Zero_to_the_power_of_zero](https://en.wikipedia.org/wiki/Zero_to_the_power_of_zero)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R145](#id46)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Indeterminate_forms](https://en.wikipedia.org/wiki/Indeterminate_forms)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: Return base and exp of self.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If base a Rational less than 1, then return 1/Rational, -exp. If this extra
    processing is not needed, the base and exp properties will give the raw arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: Return the tuple (R, self/R) where R is the positive Rational extracted from
    self.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: 'See docstring of Expr.as_content_primitive for more examples.  ## mul'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: Expression representing multiplication operation for algebraic field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.7: Using arguments that aren’t subclasses of [`Expr`](#sympy.core.expr.Expr
    "sympy.core.expr.Expr") in core operators ([`Mul`](#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    [`Add`](#sympy.core.add.Add "sympy.core.add.Add"), and [`Pow`](#sympy.core.power.Pow
    "sympy.core.power.Pow")) is deprecated. See [Core operators no longer accept non-Expr
    args](../explanation/active-deprecations.html#non-expr-args-deprecated) for details.'
  prefs: []
  type: TYPE_NORMAL
- en: Every argument of `Mul()` must be `Expr`. Infix operator `*` on most scalar
    objects in SymPy calls this class.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of `Mul()` is to represent the structure of abstract multiplication
    so that its arguments can be substituted to return different class. Refer to examples
    section for this.
  prefs: []
  type: TYPE_NORMAL
- en: '`Mul()` evaluates the argument unless `evaluate=False` is passed. The evaluation
    logic includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Flattening
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Mul(x, Mul(y, z))` -> `Mul(x, y, z)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identity removing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Mul(x, 1, y)` -> `Mul(x, y)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Exponent collecting by `.as_base_exp()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Mul(x, x**2)` -> `Pow(x, 3)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Term sorting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Mul(y, x, 2)` -> `Mul(2, x, y)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Since multiplication can be vector space operation, arguments may have the different
    [`sympy.core.kind.Kind()`](#sympy.core.kind.Kind "sympy.core.kind.Kind"). Kind
    of the resulting object is automatically inferred.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: If `evaluate=False` is passed, result is not evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs: []
  type: TYPE_PRE
- en: '`Mul()` also represents the general structure of multiplication operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MatMul`](matrices/expressions.html#sympy.matrices.expressions.MatMul "sympy.matrices.expressions.MatMul")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: Efficiently extract the coefficient of a product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: Return the tuple (R, self/R) where R is the positive Rational extracted from
    self.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: See docstring of Expr.as_content_primitive for more examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: Transform an expression into an ordered list of factors.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE535]'
  prefs: []
  type: TYPE_PRE
- en: Return head and tail of self.
  prefs: []
  type: TYPE_NORMAL
- en: This is the most efficient way to get the head and tail of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: if you want only the head, use self.args[0];
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if you want to process the arguments of the tail then use self.as_coef_mul()
    which gives the head and a tuple containing the arguments of the tail when treated
    as a Mul.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if you want the coefficient when self is treated as an Add then use self.as_coeff_add()[0]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: Return commutative, noncommutative and order arguments by combining related
    terms.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: In an expression like `a*b*c`, Python process this through SymPy as `Mul(Mul(a,
    b), c)`. This can have undesirable consequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sometimes terms are not combined as one would like: {c.f. [https://github.com/sympy/sympy/issues/4596](https://github.com/sympy/sympy/issues/4596)}'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Powers with compound bases may not find a single base to combine with unless
    all arguments are processed at once. Post-processing may be necessary in such
    cases. {c.f. [https://github.com/sympy/sympy/issues/5728](https://github.com/sympy/sympy/issues/5728)}
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_PRE
- en: 'If more than two terms are being multiplied then all the previous terms will
    be re-processed for each new argument. So if each of `a`, `b` and `c` were [`Mul`](#sympy.core.mul.Mul
    "sympy.core.mul.Mul") expression, then `a*b*c` (or building up the product with
    `*=`) will process all the arguments of `a` and `b` twice: once when `a*b` is
    computed and again when `c` is multiplied.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `Mul(a, b, c)` will process all arguments once.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The results of Mul are cached according to arguments, so flatten will only be
    called once for `Mul(a, b, c)`. If you can structure a calculation so the arguments
    are most likely to be repeats then this can save time in computing the answer.
    For example, say you had a Mul, M, that you wished to divide by `d[i]` and multiply
    by `n[i]` and you suspect there are many repeats in `n`. It would be better to
    compute `M*n[i]/d[i]` rather than `M/d[i]*n[i]` since every time n[i] is a repeat,
    the product, `M*n[i]` will be returned without flattening – the cached value will
    be returned. If you divide by the `d[i]` first (and those are more unique than
    the `n[i]`) then that will create a new Mul, `M/d[i]` the args of which will be
    traversed again when it is multiplied by `n[i]`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '{c.f. [https://github.com/sympy/sympy/issues/5706](https://github.com/sympy/sympy/issues/5706)}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This consideration is moot if the cache is turned off.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Nb
  prefs: []
  type: TYPE_NORMAL
- en: The validity of the above notes depends on the implementation details of Mul
    and flatten which may change at any time. Therefore, you should only consider
    them when your code is highly performance sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Removal of 1 from the sequence is already handled by AssocOp.__new__.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: Return product of elements of a. Start with int 1 so if only
  prefs: []
  type: TYPE_NORMAL
- en: ints are included then an int result is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: 'You can start the product at something other than 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]  ## add'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: Expression representing addition operation for algebraic group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.7: Using arguments that aren’t subclasses of [`Expr`](#sympy.core.expr.Expr
    "sympy.core.expr.Expr") in core operators ([`Mul`](#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    [`Add`](#sympy.core.add.Add "sympy.core.add.Add"), and [`Pow`](#sympy.core.power.Pow
    "sympy.core.power.Pow")) is deprecated. See [Core operators no longer accept non-Expr
    args](../explanation/active-deprecations.html#non-expr-args-deprecated) for details.'
  prefs: []
  type: TYPE_NORMAL
- en: Every argument of `Add()` must be `Expr`. Infix operator `+` on most scalar
    objects in SymPy calls this class.
  prefs: []
  type: TYPE_NORMAL
- en: Another use of `Add()` is to represent the structure of abstract addition so
    that its arguments can be substituted to return different class. Refer to examples
    section for this.
  prefs: []
  type: TYPE_NORMAL
- en: '`Add()` evaluates the argument unless `evaluate=False` is passed. The evaluation
    logic includes:'
  prefs: []
  type: TYPE_NORMAL
- en: Flattening
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Add(x, Add(y, z))` -> `Add(x, y, z)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identity removing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Add(x, 0, y)` -> `Add(x, y)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Coefficient collecting by `.as_coeff_Mul()`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Add(x, 2*x)` -> `Mul(3, x)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Term sorting
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Add(y, x, 2)` -> `Add(2, x, y)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If no argument is passed, identity element 0 is returned. If single element
    is passed, that element is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `Add(*args)` is more efficient than `sum(args)` because it flattens
    the arguments. `sum(a, b, c, ...)` recursively adds the arguments as `a + (b +
    (c + ...))`, which has quadratic complexity. On the other hand, `Add(a, b, c,
    d)` does not assume nested structure, making the complexity linear.
  prefs: []
  type: TYPE_NORMAL
- en: Since addition is group operation, every argument should have the same [`sympy.core.kind.Kind()`](#sympy.core.kind.Kind
    "sympy.core.kind.Kind").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: If `evaluate=False` is passed, result is not evaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: '`Add()` also represents the general structure of addition operation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: Note that the printers do not display in args order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MatAdd`](matrices/expressions.html#sympy.matrices.expressions.MatAdd "sympy.matrices.expressions.MatAdd")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs: []
  type: TYPE_PRE
- en: Efficiently extract the coefficient of a summation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs: []
  type: TYPE_PRE
- en: Returns a tuple (coeff, args) where self is treated as an Add and coeff is the
    Number term and args is a tuple of all other terms.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: Return the tuple (R, self/R) where R is the positive Rational extracted from
    self. If radical is True (default is False) then common radicals will be removed
    and included as a factor of the primitive expression.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: 'Radical content can also be factored out of the primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: See docstring of Expr.as_content_primitive for more examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Decomposes an expression to its numerator part and its denominator part.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.expr.Expr.as_numer_denom`](#sympy.core.expr.Expr.as_numer_denom
    "sympy.core.expr.Expr.as_numer_denom")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: Return a tuple representing a complex number.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: Return head and tail of self.
  prefs: []
  type: TYPE_NORMAL
- en: This is the most efficient way to get the head and tail of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: if you want only the head, use self.args[0];
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if you want to process the arguments of the tail then use self.as_coef_add()
    which gives the head and a tuple containing the arguments of the tail when treated
    as an Add.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if you want the coefficient when self is treated as a Mul then use self.as_coeff_mul()[0]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: Returns the leading term and its order.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: Takes the sequence “seq” of nested Adds and returns a flatten list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns: (commutative_part, noncommutative_part, order_symbols)'
  prefs: []
  type: TYPE_NORMAL
- en: Applies associativity, all terms are commutable with respect to addition.
  prefs: []
  type: TYPE_NORMAL
- en: 'NB: the removal of 0 is already handled by AssocOp.__new__'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.mul.Mul.flatten`](#sympy.core.mul.Mul.flatten "sympy.core.mul.Mul.flatten")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: Return `(R, self/R)` where `` R` `` is the Rational GCD of `` self` ``.
  prefs: []
  type: TYPE_NORMAL
- en: '`R` is collected only from the leading coefficient of each term.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: 'No subprocessing of term factors is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: 'Recursive processing can be done with the `as_content_primitive()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: 'See also: primitive() function in polytools.py  ## mod'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: Represents a modulo operation on symbolic expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: Dividend.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**q** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: Divisor.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'The convention used is the same as Python’s: the remainder always has the same
    sign as the divisor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many objects can be evaluated modulo `n` much faster than they can be evaluated
    directly (or at all). For this, `evaluate=False` is necessary to prevent eager
    evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]  ## relational'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: Base class for all relation types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rop** : str or None'
  prefs: []
  type: TYPE_NORMAL
- en: Indicates what subclass to instantiate. Valid values can be found in the keys
    of Relational.ValidRelationOperator.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Subclasses of Relational should generally be instantiated directly, but Relational
    can be instantiated with a valid `rop` value to dispatch to the appropriate subclass.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs: []
  type: TYPE_PRE
- en: 'A relation’s type can be defined upon creation using `rop`. The relation type
    of an existing expression can be obtained using its `rel_op` property. Here is
    a table of all the relation types, along with their `rop` and `rel_op` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Relation | `rop` | `rel_op` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Equality` | `==` or `eq` or `None` | `==` |'
  prefs: []
  type: TYPE_TB
- en: '| `Unequality` | `!=` or `ne` | `!=` |'
  prefs: []
  type: TYPE_TB
- en: '| `GreaterThan` | `>=` or `ge` | `>=` |'
  prefs: []
  type: TYPE_TB
- en: '| `LessThan` | `<=` or `le` | `<=` |'
  prefs: []
  type: TYPE_TB
- en: '| `StrictGreaterThan` | `>` or `gt` | `>` |'
  prefs: []
  type: TYPE_TB
- en: '| `StrictLessThan` | `<` or `lt` | `<` |'
  prefs: []
  type: TYPE_TB
- en: 'For example, setting `rop` to `==` produces an `Equality` relation, `Eq()`.
    So does setting `rop` to `eq`, or leaving `rop` unspecified. That is, the first
    three `Rel()` below all produce the same result. Using a `rop` from a different
    row in the table produces a different relation type. For example, the fourth `Rel()`
    below using `lt` for `rop` produces a `StrictLessThan` inequality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs: []
  type: TYPE_PRE
- en: 'To obtain the relation type of an existing expression, get its `rel_op` property.
    For example, `rel_op` is `==` for the `Equality` relation above, and `<` for the
    strict less than inequality above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE577]'
  prefs: []
  type: TYPE_PRE
- en: Return a canonical form of the relational by putting a number on the rhs, canonically
    removing a sign or else ordering the args canonically. No other simplification
    is attempted.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs: []
  type: TYPE_PRE
- en: 'The canonicalization is recursively applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the sides of the relationship are mathematically identical and
    the type of relationship is the same. If failing_expression is True, return the
    expression whose truth value was unknown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: The left-hand side of the relation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: Return the negated relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This works more or less identical to `~`/`Not`. The difference is that `negated`
    returns the relationship even if `evaluate=False`. Hence, this is useful in code
    when checking for e.g. negated relations to existing ones as it will not be affected
    by the \(evaluate\) flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs: []
  type: TYPE_PRE
- en: Return the relationship with sides reversed.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: Return the relationship with signs reversed.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: The right-hand side of the relation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: return the strict version of the inequality or self
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: return the non-strict version of the inequality or self
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Relational`](#sympy.core.relational.Relational "sympy.core.relational.Relational")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Equality`](#sympy.core.relational.Equality "sympy.core.relational.Equality")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Unequality`](#sympy.core.relational.Unequality "sympy.core.relational.Unequality")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`StrictLessThan`](#sympy.core.relational.StrictLessThan "sympy.core.relational.StrictLessThan")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`LessThan`](#sympy.core.relational.LessThan "sympy.core.relational.LessThan")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`StrictGreaterThan`](#sympy.core.relational.StrictGreaterThan "sympy.core.relational.StrictGreaterThan")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`GreaterThan`](#sympy.core.relational.GreaterThan "sympy.core.relational.GreaterThan")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: An equal relation between two objects.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Represents that two objects are equal. If they can be easily shown to be definitively
    equal (or unequal), this will reduce to True (or False). Otherwise, the relation
    is maintained as an unevaluated Equality object. Use the `simplify` function on
    this object for more nontrivial evaluation of the equality relation.
  prefs: []
  type: TYPE_NORMAL
- en: As usual, the keyword argument `evaluate=False` can be used to prevent any evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Python treats 1 and True (and 0 and False) as being equal; SymPy does not.
    And integer will always compare as unequal to a Boolean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: This class is not the same as the == operator. The == operator tests for exact
    structural equality between two expressions; this class compares expressions mathematically.
  prefs: []
  type: TYPE_NORMAL
- en: If either object defines an `_eval_Eq` method, it can be used in place of the
    default algorithm. If `lhs._eval_Eq(rhs)` or `rhs._eval_Eq(lhs)` returns anything
    other than None, that return value will be substituted for the Equality. If None
    is returned by `_eval_Eq`, an Equality object will be created as usual.
  prefs: []
  type: TYPE_NORMAL
- en: Since this object is already an expression, it does not respond to the method
    `as_expr` if one tries to create \(x - y\) from `Eq(x, y)`. If `eq = Eq(x, y)`
    then write \(eq.lhs - eq.rhs\) to get `x - y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.5: `Eq(expr)` with a single argument is a shorthand
    for `Eq(expr, 0)`, but this behavior is deprecated and will be removed in a future
    version of SymPy.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.logic.boolalg.Equivalent`](logic.html#sympy.logic.boolalg.Equivalent
    "sympy.logic.boolalg.Equivalent")'
  prefs: []
  type: TYPE_NORMAL
- en: for representing equality between two boolean expressions
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: Returns lhs-rhs as a Poly
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: See the integrate function in sympy.integrals
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: Class representations of inequalities.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*Than` classes represent inequal relationships, where the left-hand side
    is generally bigger or smaller than the right-hand side. For example, the GreaterThan
    class represents an inequal relationship where the left-hand side is at least
    as big as the right side, if not bigger. In mathematical notation:'
  prefs: []
  type: TYPE_NORMAL
- en: lhs \(\ge\) rhs
  prefs: []
  type: TYPE_NORMAL
- en: 'In total, there are four `*Than` classes, to represent the four inequalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class Name | Symbol |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GreaterThan | `>=` |'
  prefs: []
  type: TYPE_TB
- en: '| LessThan | `<=` |'
  prefs: []
  type: TYPE_TB
- en: '| StrictGreaterThan | `>` |'
  prefs: []
  type: TYPE_TB
- en: '| StrictLessThan | `<` |'
  prefs: []
  type: TYPE_TB
- en: All classes take two arguments, lhs and rhs.
  prefs: []
  type: TYPE_NORMAL
- en: '| Signature Example | Math Equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to the normal .lhs and .rhs of Relations, `*Than` inequality objects
    also have the .lts and .gts properties, which represent the “less than side” and
    “greater than side” of the operator. Use of .lts and .gts in an algorithm rather
    than .lhs and .rhs as an assumption of inequality direction will make more explicit
    the intent of a certain section of code, and will make it similarly more robust
    to client code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE608]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'One generally does not instantiate these classes directly, but uses various
    convenience methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: Another option is to use the Python inequality operators (`>=`, `>`, `<=`, `<`)
    directly. Their main advantage over the `Ge`, `Gt`, `Le`, and `Lt` counterparts,
    is that one can write a more “mathematical looking” statement rather than littering
    the math with oddball function calls. However there are certain (minor) caveats
    of which to be aware (search for ‘gotcha’, below).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is also perfectly valid to instantiate a `*Than` class less succinctly
    and less conveniently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of “gotchas” to be aware of when using Python’s operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is that what your write is not always what you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Due to the order that Python parses a statement, it may not immediately find
    two objects comparable. When `1 < x` is evaluated, Python recognizes that the
    number 1 is a native number and that x is *not*. Because a native Python number
    does not know how to compare itself with a SymPy object Python will try the reflective
    operation, `x > 1` and that is the form that gets evaluated, hence returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the order of the statement is important (for visual output to the console,
    perhaps), one can work around this annoyance in a couple ways:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “sympify” the literal before comparison
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (2) use one of the wrappers or less succinct methods described above
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The second gotcha involves writing equality tests between relationals when
    one or both sides of the test involve a literal relational:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The solution for this case is to wrap literal relationals in parentheses:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The third gotcha involves chained inequalities not involving `==` or `!=`.
    Occasionally, one may be tempted to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Due to an implementation detail or decision of Python [[R146]](#r146), there
    is no way for SymPy to create a chained inequality with that syntax so one must
    use And:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although this can also be done with the ‘&’ operator, it cannot be done with
    the ‘and’ operarator:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '[[R146](#id47)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation detail is that Python provides no reliable method to determine
    that a chained inequality is being built. Chained comparison operators are evaluated
    pairwise, using “and” logic (see [https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)).
    This is done in an efficient way, so that each object being compared is only evaluated
    once and the comparison can short-circuit. For example, `1 > 2 > 3` is evaluated
    by Python as `(1 > 2) and (2 > 3)`. The `and` operator coerces each side into
    a bool, returning the object itself when it short-circuits. The bool of the –Than
    operators will raise TypeError on purpose, because SymPy cannot determine the
    mathematical ordering of symbolic expressions. Thus, if we were to compute `x
    > y > z`, with `x`, `y`, and `z` being Symbols, Python converts the statement
    (roughly) into these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: x > y > z
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (x > y) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject.__bool__()) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: TypeError
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of the `and` added at step 2, the statement gets turned into a weak
    ternary statement, and the first object’s `__bool__` method will raise TypeError.
    Thus, creating a chained inequality is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, there is no way to override the `and` operator, or to control how
    it short circuits, so it is impossible to make something like `x > y > z` work.
    There was a PEP to change this, [**PEP 335**](https://peps.python.org/pep-0335/),
    but it was officially closed in March, 2012.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: Class representations of inequalities.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*Than` classes represent inequal relationships, where the left-hand side
    is generally bigger or smaller than the right-hand side. For example, the GreaterThan
    class represents an inequal relationship where the left-hand side is at least
    as big as the right side, if not bigger. In mathematical notation:'
  prefs: []
  type: TYPE_NORMAL
- en: lhs \(\ge\) rhs
  prefs: []
  type: TYPE_NORMAL
- en: 'In total, there are four `*Than` classes, to represent the four inequalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class Name | Symbol |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GreaterThan | `>=` |'
  prefs: []
  type: TYPE_TB
- en: '| LessThan | `<=` |'
  prefs: []
  type: TYPE_TB
- en: '| StrictGreaterThan | `>` |'
  prefs: []
  type: TYPE_TB
- en: '| StrictLessThan | `<` |'
  prefs: []
  type: TYPE_TB
- en: All classes take two arguments, lhs and rhs.
  prefs: []
  type: TYPE_NORMAL
- en: '| Signature Example | Math Equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to the normal .lhs and .rhs of Relations, `*Than` inequality objects
    also have the .lts and .gts properties, which represent the “less than side” and
    “greater than side” of the operator. Use of .lts and .gts in an algorithm rather
    than .lhs and .rhs as an assumption of inequality direction will make more explicit
    the intent of a certain section of code, and will make it similarly more robust
    to client code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'One generally does not instantiate these classes directly, but uses various
    convenience methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: Another option is to use the Python inequality operators (`>=`, `>`, `<=`, `<`)
    directly. Their main advantage over the `Ge`, `Gt`, `Le`, and `Lt` counterparts,
    is that one can write a more “mathematical looking” statement rather than littering
    the math with oddball function calls. However there are certain (minor) caveats
    of which to be aware (search for ‘gotcha’, below).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is also perfectly valid to instantiate a `*Than` class less succinctly
    and less conveniently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of “gotchas” to be aware of when using Python’s operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is that what your write is not always what you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Due to the order that Python parses a statement, it may not immediately find
    two objects comparable. When `1 < x` is evaluated, Python recognizes that the
    number 1 is a native number and that x is *not*. Because a native Python number
    does not know how to compare itself with a SymPy object Python will try the reflective
    operation, `x > 1` and that is the form that gets evaluated, hence returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the order of the statement is important (for visual output to the console,
    perhaps), one can work around this annoyance in a couple ways:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “sympify” the literal before comparison
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (2) use one of the wrappers or less succinct methods described above
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The second gotcha involves writing equality tests between relationals when
    one or both sides of the test involve a literal relational:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The solution for this case is to wrap literal relationals in parentheses:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The third gotcha involves chained inequalities not involving `==` or `!=`.
    Occasionally, one may be tempted to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE633]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Due to an implementation detail or decision of Python [[R147]](#r147), there
    is no way for SymPy to create a chained inequality with that syntax so one must
    use And:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although this can also be done with the ‘&’ operator, it cannot be done with
    the ‘and’ operarator:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '[[R147](#id48)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation detail is that Python provides no reliable method to determine
    that a chained inequality is being built. Chained comparison operators are evaluated
    pairwise, using “and” logic (see [https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)).
    This is done in an efficient way, so that each object being compared is only evaluated
    once and the comparison can short-circuit. For example, `1 > 2 > 3` is evaluated
    by Python as `(1 > 2) and (2 > 3)`. The `and` operator coerces each side into
    a bool, returning the object itself when it short-circuits. The bool of the –Than
    operators will raise TypeError on purpose, because SymPy cannot determine the
    mathematical ordering of symbolic expressions. Thus, if we were to compute `x
    > y > z`, with `x`, `y`, and `z` being Symbols, Python converts the statement
    (roughly) into these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: x > y > z
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (x > y) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject.__bool__()) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: TypeError
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of the `and` added at step 2, the statement gets turned into a weak
    ternary statement, and the first object’s `__bool__` method will raise TypeError.
    Thus, creating a chained inequality is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, there is no way to override the `and` operator, or to control how
    it short circuits, so it is impossible to make something like `x > y > z` work.
    There was a PEP to change this, [**PEP 335**](https://peps.python.org/pep-0335/),
    but it was officially closed in March, 2012.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: An unequal relation between two objects.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Represents that two objects are not equal. If they can be shown to be definitively
    equal, this will reduce to False; if definitively unequal, this will reduce to
    True. Otherwise, the relation is maintained as an Unequality object.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This class is not the same as the != operator. The != operator tests for exact
    structural equality between two expressions; this class compares expressions mathematically.
  prefs: []
  type: TYPE_NORMAL
- en: This class is effectively the inverse of Equality. As such, it uses the same
    algorithms, including any available \(_eval_Eq\) methods.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Equality`](#sympy.core.relational.Equality "sympy.core.relational.Equality")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: Class representations of inequalities.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*Than` classes represent inequal relationships, where the left-hand side
    is generally bigger or smaller than the right-hand side. For example, the GreaterThan
    class represents an inequal relationship where the left-hand side is at least
    as big as the right side, if not bigger. In mathematical notation:'
  prefs: []
  type: TYPE_NORMAL
- en: lhs \(\ge\) rhs
  prefs: []
  type: TYPE_NORMAL
- en: 'In total, there are four `*Than` classes, to represent the four inequalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class Name | Symbol |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GreaterThan | `>=` |'
  prefs: []
  type: TYPE_TB
- en: '| LessThan | `<=` |'
  prefs: []
  type: TYPE_TB
- en: '| StrictGreaterThan | `>` |'
  prefs: []
  type: TYPE_TB
- en: '| StrictLessThan | `<` |'
  prefs: []
  type: TYPE_TB
- en: All classes take two arguments, lhs and rhs.
  prefs: []
  type: TYPE_NORMAL
- en: '| Signature Example | Math Equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to the normal .lhs and .rhs of Relations, `*Than` inequality objects
    also have the .lts and .gts properties, which represent the “less than side” and
    “greater than side” of the operator. Use of .lts and .gts in an algorithm rather
    than .lhs and .rhs as an assumption of inequality direction will make more explicit
    the intent of a certain section of code, and will make it similarly more robust
    to client code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'One generally does not instantiate these classes directly, but uses various
    convenience methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: Another option is to use the Python inequality operators (`>=`, `>`, `<=`, `<`)
    directly. Their main advantage over the `Ge`, `Gt`, `Le`, and `Lt` counterparts,
    is that one can write a more “mathematical looking” statement rather than littering
    the math with oddball function calls. However there are certain (minor) caveats
    of which to be aware (search for ‘gotcha’, below).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is also perfectly valid to instantiate a `*Than` class less succinctly
    and less conveniently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of “gotchas” to be aware of when using Python’s operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is that what your write is not always what you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Due to the order that Python parses a statement, it may not immediately find
    two objects comparable. When `1 < x` is evaluated, Python recognizes that the
    number 1 is a native number and that x is *not*. Because a native Python number
    does not know how to compare itself with a SymPy object Python will try the reflective
    operation, `x > 1` and that is the form that gets evaluated, hence returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the order of the statement is important (for visual output to the console,
    perhaps), one can work around this annoyance in a couple ways:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “sympify” the literal before comparison
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (2) use one of the wrappers or less succinct methods described above
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The second gotcha involves writing equality tests between relationals when
    one or both sides of the test involve a literal relational:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The solution for this case is to wrap literal relationals in parentheses:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The third gotcha involves chained inequalities not involving `==` or `!=`.
    Occasionally, one may be tempted to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Due to an implementation detail or decision of Python [[R148]](#r148), there
    is no way for SymPy to create a chained inequality with that syntax so one must
    use And:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although this can also be done with the ‘&’ operator, it cannot be done with
    the ‘and’ operarator:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '[[R148](#id49)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation detail is that Python provides no reliable method to determine
    that a chained inequality is being built. Chained comparison operators are evaluated
    pairwise, using “and” logic (see [https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)).
    This is done in an efficient way, so that each object being compared is only evaluated
    once and the comparison can short-circuit. For example, `1 > 2 > 3` is evaluated
    by Python as `(1 > 2) and (2 > 3)`. The `and` operator coerces each side into
    a bool, returning the object itself when it short-circuits. The bool of the –Than
    operators will raise TypeError on purpose, because SymPy cannot determine the
    mathematical ordering of symbolic expressions. Thus, if we were to compute `x
    > y > z`, with `x`, `y`, and `z` being Symbols, Python converts the statement
    (roughly) into these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: x > y > z
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (x > y) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject.__bool__()) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: TypeError
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of the `and` added at step 2, the statement gets turned into a weak
    ternary statement, and the first object’s `__bool__` method will raise TypeError.
    Thus, creating a chained inequality is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: In Python, there is no way to override the `and` operator, or to control how
    it short circuits, so it is impossible to make something like `x > y > z` work.
    There was a PEP to change this, [**PEP 335**](https://peps.python.org/pep-0335/),
    but it was officially closed in March, 2012.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: Class representations of inequalities.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The `*Than` classes represent inequal relationships, where the left-hand side
    is generally bigger or smaller than the right-hand side. For example, the GreaterThan
    class represents an inequal relationship where the left-hand side is at least
    as big as the right side, if not bigger. In mathematical notation:'
  prefs: []
  type: TYPE_NORMAL
- en: lhs \(\ge\) rhs
  prefs: []
  type: TYPE_NORMAL
- en: 'In total, there are four `*Than` classes, to represent the four inequalities:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class Name | Symbol |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GreaterThan | `>=` |'
  prefs: []
  type: TYPE_TB
- en: '| LessThan | `<=` |'
  prefs: []
  type: TYPE_TB
- en: '| StrictGreaterThan | `>` |'
  prefs: []
  type: TYPE_TB
- en: '| StrictLessThan | `<` |'
  prefs: []
  type: TYPE_TB
- en: All classes take two arguments, lhs and rhs.
  prefs: []
  type: TYPE_NORMAL
- en: '| Signature Example | Math Equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| GreaterThan(lhs, rhs) | lhs \(\ge\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| LessThan(lhs, rhs) | lhs \(\le\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| StrictGreaterThan(lhs, rhs) | lhs \(>\) rhs |'
  prefs: []
  type: TYPE_TB
- en: '| StrictLessThan(lhs, rhs) | lhs \(<\) rhs |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to the normal .lhs and .rhs of Relations, `*Than` inequality objects
    also have the .lts and .gts properties, which represent the “less than side” and
    “greater than side” of the operator. Use of .lts and .gts in an algorithm rather
    than .lhs and .rhs as an assumption of inequality direction will make more explicit
    the intent of a certain section of code, and will make it similarly more robust
    to client code changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'One generally does not instantiate these classes directly, but uses various
    convenience methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: Another option is to use the Python inequality operators (`>=`, `>`, `<=`, `<`)
    directly. Their main advantage over the `Ge`, `Gt`, `Le`, and `Lt` counterparts,
    is that one can write a more “mathematical looking” statement rather than littering
    the math with oddball function calls. However there are certain (minor) caveats
    of which to be aware (search for ‘gotcha’, below).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is also perfectly valid to instantiate a `*Than` class less succinctly
    and less conveniently:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of “gotchas” to be aware of when using Python’s operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first is that what your write is not always what you get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Due to the order that Python parses a statement, it may not immediately find
    two objects comparable. When `1 < x` is evaluated, Python recognizes that the
    number 1 is a native number and that x is *not*. Because a native Python number
    does not know how to compare itself with a SymPy object Python will try the reflective
    operation, `x > 1` and that is the form that gets evaluated, hence returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If the order of the statement is important (for visual output to the console,
    perhaps), one can work around this annoyance in a couple ways:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “sympify” the literal before comparison
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: (2) use one of the wrappers or less succinct methods described above
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE662]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The second gotcha involves writing equality tests between relationals when
    one or both sides of the test involve a literal relational:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The solution for this case is to wrap literal relationals in parentheses:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'The third gotcha involves chained inequalities not involving `==` or `!=`.
    Occasionally, one may be tempted to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Due to an implementation detail or decision of Python [[R149]](#r149), there
    is no way for SymPy to create a chained inequality with that syntax so one must
    use And:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Although this can also be done with the ‘&’ operator, it cannot be done with
    the ‘and’ operarator:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '[[R149](#id50)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation detail is that Python provides no reliable method to determine
    that a chained inequality is being built. Chained comparison operators are evaluated
    pairwise, using “and” logic (see [https://docs.python.org/3/reference/expressions.html#not-in](https://docs.python.org/3/reference/expressions.html#not-in)).
    This is done in an efficient way, so that each object being compared is only evaluated
    once and the comparison can short-circuit. For example, `1 > 2 > 3` is evaluated
    by Python as `(1 > 2) and (2 > 3)`. The `and` operator coerces each side into
    a bool, returning the object itself when it short-circuits. The bool of the –Than
    operators will raise TypeError on purpose, because SymPy cannot determine the
    mathematical ordering of symbolic expressions. Thus, if we were to compute `x
    > y > z`, with `x`, `y`, and `z` being Symbols, Python converts the statement
    (roughly) into these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: x > y > z
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (x > y) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: (GreaterThanObject.__bool__()) and (y > z)
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: TypeError
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Because of the `and` added at step 2, the statement gets turned into a weak
    ternary statement, and the first object’s `__bool__` method will raise TypeError.
    Thus, creating a chained inequality is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Python, there is no way to override the `and` operator, or to control how
    it short circuits, so it is impossible to make something like `x > y > z` work.
    There was a PEP to change this, [**PEP 335**](https://peps.python.org/pep-0335/),
    but it was officially closed in March, 2012.  ## multidimensional'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: Generalizes a function taking scalars to accept multidimensional arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE673]  ## function'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: 'Lambda(x, expr) represents a lambda function similar to Python’s ‘lambda x:
    expr’. A function of several variables is written as Lambda((x, y, …), expr).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: 'For multivariate functions, use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to unpack tuple arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: 'A handy shortcut for lots of arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: The variables used in the internal representation of the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs: []
  type: TYPE_PRE
- en: The return value of the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if this `Lambda` is an identity function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs: []
  type: TYPE_PRE
- en: The expected form of the arguments to be unpacked into variables
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs: []
  type: TYPE_PRE
- en: The variables used in the internal representation of the function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: A WildFunction function matches any function (with its arguments).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: 'To match functions with a given number of arguments, set `nargs` to the desired
    value at instantiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: To match functions with a range of arguments, set `nargs` to a tuple containing
    the desired number of arguments, e.g. if `nargs = (1, 2)` then functions with
    1 or 2 arguments will be matched.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: Carries out differentiation of the given expression with respect to symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: 'Denesting of derivatives retains the ordering of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: 'Contiguously identical symbols are merged into a tuple giving the symbol and
    the count:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: 'If the derivative cannot be performed, and evaluate is True, the order of the
    variables of differentiation will be made canonical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: 'Derivatives with respect to undefined functions can be calculated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: 'Such derivatives will show up when the chain rule is used to evalulate a derivative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: 'Substitution is used to represent derivatives of functions with arguments that
    are not symbols or functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Simplification of high-order derivatives:'
  prefs: []
  type: TYPE_NORMAL
- en: Because there can be a significant amount of simplification that can be done
    when multiple differentiations are performed, results will be automatically simplified
    in a fairly conservative fashion unless the keyword `simplify` is set to False.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: 'Ordering of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: If evaluate is set to True and the expression cannot be evaluated, the list
    of differentiation symbols will be sorted, that is, the expression is assumed
    to have continuous derivatives up to the order asked.
  prefs: []
  type: TYPE_NORMAL
- en: 'Derivative wrt non-Symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the most part, one may not differentiate wrt non-symbols. For example,
    we do not allow differentiation wrt \(x*y\) because there are multiple ways of
    structurally defining where x*y appears in an expression: a very strict definition
    would make (x*y*z).diff(x*y) == 0\. Derivatives wrt defined functions (like cos(x))
    are not allowed, either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it easier to work with variational calculus, however, derivatives wrt
    AppliedUndef and Derivatives are allowed. For example, in the Euler-Lagrange method
    one may write F(t, u, v) where u = f(t) and v = f’(t). These variables can be
    written explicitly as functions of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs: []
  type: TYPE_PRE
- en: 'The derivative wrt f(t) can be obtained directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs: []
  type: TYPE_PRE
- en: 'When differentiation wrt a non-Symbol is attempted, the non-Symbol is temporarily
    converted to a Symbol while the differentiation is performed and the same answer
    is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs: []
  type: TYPE_PRE
- en: 'The implication of this non-symbol replacement is that all functions are treated
    as independent of other functions and the symbols are independent of the functions
    that contain them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: 'It also means that derivatives are assumed to depend only on the variables
    of differentiation, not on anything contained within the expression being differentiated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example can be made explicit by showing the replacement of Fx in Fxx
    with y:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Since that in itself will evaluate to zero, differentiating wrt Fx will also
    be zero:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Replacing undefined functions with concrete expressions
  prefs: []
  type: TYPE_NORMAL
- en: 'One must be careful to replace undefined functions with expressions that contain
    variables consistent with the function definition and the variables of differentiation
    or else insconsistent result will be obtained. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs: []
  type: TYPE_PRE
- en: The results differ because \(f(x)\) was replaced with an expression that involved
    both variables of differentiation. In the abstract case, differentiation of \(f(x)\)
    by \(y\) is 0; in the concrete case, the presence of \(y\) made that derivative
    nonvanishing and produced the extra \(g(y)\) term.
  prefs: []
  type: TYPE_NORMAL
- en: Defining differentiation for an object
  prefs: []
  type: TYPE_NORMAL
- en: An object must define ._eval_derivative(symbol) method that returns the differentiation
    result. This function only needs to consider the non-trivial case where expr contains
    symbol and it should call the diff() method internally (not _eval_derivative);
    Derivative should be the only one to call _eval_derivative.
  prefs: []
  type: TYPE_NORMAL
- en: Any class can allow derivatives to be taken with respect to itself (while indicating
    its scalar nature). See the docstring of Expr._diff_wrt.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`_sort_variable_count`](#sympy.core.function.Derivative._sort_variable_count
    "sympy.core.function.Derivative._sort_variable_count")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs: []
  type: TYPE_PRE
- en: An expression may be differentiated wrt a Derivative if it is in elementary
    form.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: A Derivative might be an unevaluated form of what will not be a valid variable
    of differentiation if evaluated. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: 'Such an expression will present the same ambiguities as arise when dealing
    with any other product, like `2*x`, so `_diff_wrt` is False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: 'Sort (variable, count) pairs into canonical order while retaining order of
    variables that do not commute during differentiation:'
  prefs: []
  type: TYPE_NORMAL
- en: symbols and functions commute with each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: derivatives commute with each other
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a derivative does not commute with anything it contains
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: any other object is not allowed to commute if it has free symbols in common
    with another object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: 'Contiguous items are collapsed into one pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: Ordering is canonical.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE717]'
  prefs: []
  type: TYPE_PRE
- en: 'Symbols are sorted as far to the left as possible but never move to the left
    of a derivative having the same symbol in its variables; the same applies to AppliedUndef
    which are always sorted after Symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE719]'
  prefs: []
  type: TYPE_PRE
- en: Expresses a Derivative instance as a finite difference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**points** : sequence or coefficient, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'If sequence: discrete values (length >= order+1) of the independent variable
    used for generating the finite difference weights. If it is a coefficient, it
    will be used as the step-size for generating an equidistant sequence of length
    order+1 centered around `x0`. Default: 1 (step-size 1)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**x0** : number or Symbol, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'the value of the independent variable (`wrt`) at which the derivative is to
    be approximated. Default: same as `wrt`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**wrt** : Symbol, optional'
  prefs: []
  type: TYPE_NORMAL
- en: '“with respect to” the variable for which the (partial) derivative is to be
    approximated for. If not provided it is required that the derivative is ordinary.
    Default: `None`.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: 'The default step size and number of points are 1 and `order + 1` respectively.
    We can change the step size by passing a symbol as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also specify the discretized values to be used in a sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: 'The algorithm is not restricted to use equidistant spacing, nor do we need
    to make the approximation around `x0`, but we can get an expression estimating
    the derivative at an offset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: 'To approximate `Derivative` around `x0` using a non-equidistant spacing step,
    the algorithm supports assignment of undefined functions to `points`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: 'Partial derivatives are also supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: 'We can apply `as_finite_difference` to `Derivative` instances in compound expressions
    using `replace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.calculus.finite_diff.apply_finite_diff`](calculus/index.html#sympy.calculus.finite_diff.apply_finite_diff
    "sympy.calculus.finite_diff.apply_finite_diff"), [`sympy.calculus.finite_diff.differentiate_finite`](calculus/index.html#sympy.calculus.finite_diff.differentiate_finite
    "sympy.calculus.finite_diff.differentiate_finite"), [`sympy.calculus.finite_diff.finite_diff_weights`](calculus/index.html#sympy.calculus.finite_diff.finite_diff_weights
    "sympy.calculus.finite_diff.finite_diff_weights")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: Evaluate the derivative at z numerically.
  prefs: []
  type: TYPE_NORMAL
- en: When we can represent derivatives at a point, this should be folded into the
    normal evalf. For now, we need a special method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: Differentiate f with respect to symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This is just a wrapper to unify .diff() and the Derivative class; its interface
    is similar to that of integrate(). You can use the same shortcuts for multiple
    variables as with Derivative. For example, diff(f(x), x, x, x) and diff(f(x),
    x, 3) both return the third derivative of f(x).
  prefs: []
  type: TYPE_NORMAL
- en: You can pass evaluate=False to get an unevaluated Derivative class. Note that
    if there are 0 symbols (such as diff(f(x), x, 0), then the result will be the
    function (the zeroth derivative), even if evaluate=False.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: Note that `diff(sin(x))` syntax is meant only for convenience in interactive
    sessions and should be avoided in library code.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Derivative`](#sympy.core.function.Derivative "sympy.core.function.Derivative")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`idiff`](geometry/utils.html#sympy.geometry.util.idiff "sympy.geometry.util.idiff")'
  prefs: []
  type: TYPE_NORMAL
- en: computes the derivative implicitly
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R150](#id51)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://reference.wolfram.com/legacy/v5_2/Built-inFunctions/AlgebraicComputation/Calculus/D.html](https://reference.wolfram.com/legacy/v5_2/Built-inFunctions/AlgebraicComputation/Calculus/D.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: Base class for function classes. FunctionClass is a subclass of type.
  prefs: []
  type: TYPE_NORMAL
- en: Use Function(‘<function name>’ [ , signature ]) to create undefined function
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: Return a set of the allowed number of arguments for the function.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function can take any number of arguments, the set of whole numbers
    is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function was initialized to accept one or more arguments, a corresponding
    set will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: 'The undefined function, after application, also has the nargs attribute; the
    actual number of arguments is always available by checking the `args` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
- en: Base class for applied mathematical functions.
  prefs: []
  type: TYPE_NORMAL
- en: It also serves as a constructor for undefined function classes.
  prefs: []
  type: TYPE_NORMAL
- en: See the [Writing Custom Functions](../guides/custom-functions.html#custom-functions)
    guide for details on how to subclass `Function` and what methods can be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '**Undefined Functions**'
  prefs: []
  type: TYPE_NORMAL
- en: To create an undefined function, pass a string of the function name to `Function`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE740]'
  prefs: []
  type: TYPE_PRE
- en: 'Assumptions can be passed to `Function` the same as with a [`Symbol`](#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol"). Alternatively, you can use a `Symbol` with assumptions
    for the function name and the function will inherit the name and assumptions associated
    with the `Symbol`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE741]'
  prefs: []
  type: TYPE_PRE
- en: Note that assumptions on a function are unrelated to the assumptions on the
    variables it is called on. If you want to add a relationship, subclass `Function`
    and define custom assumptions handler methods. See the [Assumptions](../guides/custom-functions.html#custom-functions-assumptions)
    section of the [Writing Custom Functions](../guides/custom-functions.html#custom-functions)
    guide for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Custom Function Subclasses**'
  prefs: []
  type: TYPE_NORMAL
- en: The [Writing Custom Functions](../guides/custom-functions.html#custom-functions)
    guide has several [Complete Examples](../guides/custom-functions.html#custom-functions-complete-examples)
    of how to subclass `Function` to create a custom function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE742]'
  prefs: []
  type: TYPE_PRE
- en: Returns the method as the 2-tuple (base, exponent).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE743]'
  prefs: []
  type: TYPE_PRE
- en: Returns the first derivative of the function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE744]'
  prefs: []
  type: TYPE_PRE
- en: Tests whether the argument is an essential singularity or a branch point, or
    the functions is non-holomorphic.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Not all functions are the same
  prefs: []
  type: TYPE_NORMAL
- en: 'SymPy defines many functions (like `cos` and `factorial`). It also allows the
    user to create generic functions which act as argument holders. Such functions
    are created just like symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE745]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to see which functions appear in an expression you can use the
    atoms method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE746]'
  prefs: []
  type: TYPE_PRE
- en: 'If you just want the function you defined, not SymPy functions, the thing to
    search for is AppliedUndef:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE747]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE748]'
  prefs: []
  type: TYPE_PRE
- en: Represents unevaluated substitutions of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: '`Subs(expr, x, x0)` represents the expression resulting from substituting x
    with x0 in expr.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**expr** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: An expression.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**x** : tuple, variable'
  prefs: []
  type: TYPE_NORMAL
- en: A variable or list of distinct variables.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**x0** : tuple or list of tuples'
  prefs: []
  type: TYPE_NORMAL
- en: A point or list of evaluation points corresponding to those variables.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE749]'
  prefs: []
  type: TYPE_PRE
- en: 'Subs are created when a particular substitution cannot be made. The x in the
    derivative cannot be replaced with 0 because 0 is not a valid variables of differentiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE750]'
  prefs: []
  type: TYPE_PRE
- en: 'Once f is known, the derivative and evaluation at 0 can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE751]'
  prefs: []
  type: TYPE_PRE
- en: 'Subs can also be created directly with one or more variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE752]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: '`Subs` objects are generally useful to represent unevaluated derivatives calculated
    at a point.'
  prefs: []
  type: TYPE_NORMAL
- en: The variables may be expressions, but they are subjected to the limitations
    of subs(), so it is usually a good practice to use only symbols for variables,
    since in that case there can be no ambiguity.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no automatic expansion - use the method .doit() to effect all possible
    substitutions of the object and also of objects inside the expression.
  prefs: []
  type: TYPE_NORMAL
- en: When evaluating derivatives at a point that is not a symbol, a Subs object is
    returned. One is also able to calculate derivatives of Subs objects - in this
    case the expression is always expanded (for the unevaluated form, use Derivative()).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to allow expressions to combine before doit is done, a representation
    of the Subs expression is used internally to make expressions that are superficially
    different compare the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE753]'
  prefs: []
  type: TYPE_PRE
- en: 'This can lead to unexpected consequences when using methods like \(has\) that
    are cached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE754]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE755]'
  prefs: []
  type: TYPE_PRE
- en: The variables to be evaluated
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE756]'
  prefs: []
  type: TYPE_PRE
- en: The expression on which the substitution operates
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE757]'
  prefs: []
  type: TYPE_PRE
- en: The values for which the variables are to be substituted
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE758]'
  prefs: []
  type: TYPE_PRE
- en: The variables to be evaluated
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE759]'
  prefs: []
  type: TYPE_PRE
- en: Expand an expression using methods given as hints.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Hints evaluated unless explicitly set to False are: `basic`, `log`, `multinomial`,
    `mul`, `power_base`, and `power_exp` The following hints are supported but not
    applied unless set to True: `complex`, `func`, and `trig`. In addition, the following
    meta-hints are supported by some or all of the other hints: `frac`, `numer`, `denom`,
    `modulus`, and `force`. `deep` is supported by all hints. Additionally, subclasses
    of Expr may define their own hints or meta-hints.'
  prefs: []
  type: TYPE_NORMAL
- en: The `basic` hint is used for any special rewriting of an object that should
    be done automatically (along with the other hints like `mul`) when expand is called.
    This is a catch-all hint to handle any sort of expansion that may not be described
    by the existing hint names. To use this hint an object should override the `_eval_expand_basic`
    method. Objects may also define their own expand methods, which are not run by
    default. See the API section below.
  prefs: []
  type: TYPE_NORMAL
- en: If `deep` is set to `True` (the default), things like arguments of functions
    are recursively expanded. Use `deep=False` to only expand on the top level.
  prefs: []
  type: TYPE_NORMAL
- en: If the `force` hint is used, assumptions about variables will be ignored in
    making the expansion.
  prefs: []
  type: TYPE_NORMAL
- en: Hints
  prefs: []
  type: TYPE_NORMAL
- en: These hints are run by default
  prefs: []
  type: TYPE_NORMAL
- en: Mul
  prefs: []
  type: TYPE_NORMAL
- en: 'Distributes multiplication over addition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE760]'
  prefs: []
  type: TYPE_PRE
- en: Multinomial
  prefs: []
  type: TYPE_NORMAL
- en: Expand (x + y + …)**n where n is a positive integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE761]'
  prefs: []
  type: TYPE_PRE
- en: Power_exp
  prefs: []
  type: TYPE_NORMAL
- en: Expand addition in exponents into multiplied bases.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE762]'
  prefs: []
  type: TYPE_PRE
- en: Power_base
  prefs: []
  type: TYPE_NORMAL
- en: Split powers of multiplied bases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This only happens by default if assumptions allow, or if the `force` meta-hint
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE763]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in some cases where this expansion always holds, SymPy performs it
    automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE764]'
  prefs: []
  type: TYPE_PRE
- en: Log
  prefs: []
  type: TYPE_NORMAL
- en: Pull out power of an argument as a coefficient and split logs products into
    sums of logs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that these only work if the arguments of the log function have the proper
    assumptions–the arguments must be positive and the exponents must be real–or else
    the `force` hint must be True:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE765]'
  prefs: []
  type: TYPE_PRE
- en: Basic
  prefs: []
  type: TYPE_NORMAL
- en: This hint is intended primarily as a way for custom subclasses to enable expansion
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'These hints are not run by default:'
  prefs: []
  type: TYPE_NORMAL
- en: Complex
  prefs: []
  type: TYPE_NORMAL
- en: Split an expression into real and imaginary parts.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE766]'
  prefs: []
  type: TYPE_PRE
- en: Note that this is just a wrapper around `as_real_imag()`. Most objects that
    wish to redefine `_eval_expand_complex()` should consider redefining `as_real_imag()`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: Func
  prefs: []
  type: TYPE_NORMAL
- en: Expand other functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE767]'
  prefs: []
  type: TYPE_PRE
- en: Trig
  prefs: []
  type: TYPE_NORMAL
- en: Do trigonometric expansions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE768]'
  prefs: []
  type: TYPE_PRE
- en: Note that the forms of `sin(n*x)` and `cos(n*x)` in terms of `sin(x)` and `cos(x)`
    are not unique, due to the identity \(\sin^2(x) + \cos^2(x) = 1\). The current
    implementation uses the form obtained from Chebyshev polynomials, but this may
    change. See [this MathWorld article](https://mathworld.wolfram.com/Multiple-AngleFormulas.html)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'You can shut off unwanted methods:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE769]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use deep=False to only expand on the top level:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE770]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Hints are applied in an arbitrary, but consistent order (in the current implementation,
    they are applied in alphabetical order, except multinomial comes before mul, but
    this may change). Because of this, some hints may prevent expansion by other hints
    if they are applied first. For example, `mul` may distribute multiplications and
    prevent `log` and `power_base` from expanding them. Also, if `mul` is applied
    before [PRE771] helper functions or to use `hint=False` to this function to finely
    control which hints are applied. Here are some examples:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE772]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we see that `log` was applied before `mul`. To get the mul expanded form,
    either of the following will work:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE773]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A similar thing can happen with the `power_base` hint:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE774]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To get the `power_base` expanded form, either of the following will work:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE775]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parts of a rational expression can be targeted:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE776]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `modulus` meta-hint can be used to reduce the coefficients of an expression
    post-expansion:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE777]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Either `expand()` the function or `.expand()` the method can be used. Both
    are equivalent:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE778]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Api
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects can define their own expand hints by defining `_eval_expand_hint()`.
    The function should take the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE779]'
  prefs: []
  type: TYPE_PRE
- en: See also the example below. Objects should define `_eval_expand_hint()` methods
    only if `hint` applies to that specific object. The generic `_eval_expand_hint()`
    method defined in Expr will handle the no-op case.
  prefs: []
  type: TYPE_NORMAL
- en: Each hint should be responsible for expanding that hint only. Furthermore, the
    expansion should be applied to the top-level expression only. `expand()` takes
    care of the recursion that happens when `deep=True`.
  prefs: []
  type: TYPE_NORMAL
- en: You should only call `_eval_expand_hint()` methods directly if you are 100%
    sure that the object has the method, as otherwise you are liable to get unexpected
    [PRE780]. `_eval_expand_hint()` should generally not be used at all outside of
    an `_eval_expand_hint()` method. If you want to apply a specific expansion from
    within another method, use the public `expand()` function, method, or `expand_hint()`
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: In order for expand to work, objects must be rebuildable by their args, i.e.,
    `obj.func(*obj.args) == obj` must hold.
  prefs: []
  type: TYPE_NORMAL
- en: Expand methods are passed `**hints` so that expand hints may use ‘metahints’–hints
    that control how different expand methods are applied. For example, the `force=True`
    hint described above that causes `expand(log=True)` to ignore assumptions is such
    a metahint. The `deep` meta-hint is handled exclusively by `expand()` and is not
    passed to `_eval_expand_hint()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note that expansion hints should generally be methods that perform some kind
    of ‘expansion’. For hints that simply rewrite an expression, use the .rewrite()
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE781]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE782]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`expand_log`](#sympy.core.function.expand_log "sympy.core.function.expand_log"),
    [`expand_mul`](#sympy.core.function.expand_mul "sympy.core.function.expand_mul"),
    [`expand_multinomial`](#sympy.core.function.expand_multinomial "sympy.core.function.expand_multinomial"),
    [`expand_complex`](#sympy.core.function.expand_complex "sympy.core.function.expand_complex"),
    [`expand_trig`](#sympy.core.function.expand_trig "sympy.core.function.expand_trig"),
    [`expand_power_base`](#sympy.core.function.expand_power_base "sympy.core.function.expand_power_base"),
    [`expand_power_exp`](#sympy.core.function.expand_power_exp "sympy.core.function.expand_power_exp"),
    [`expand_func`](#sympy.core.function.expand_func "sympy.core.function.expand_func"),
    [`sympy.simplify.hyperexpand.hyperexpand`](simplify/simplify.html#sympy.simplify.hyperexpand.hyperexpand
    "sympy.simplify.hyperexpand.hyperexpand")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE783]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE784]'
  prefs: []
  type: TYPE_PRE
- en: Return a representation (integer or expression) of the operations in expr.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**expr** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: If expr is an iterable, the sum of the op counts of the items will be returned.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**visual** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `False` (default) then the sum of the coefficients of the visual expression
    will be returned. If `True` then the number of each type of operation is shown
    with the core class types (or their virtual equivalent) multiplied by the number
    of times they occur.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE785]'
  prefs: []
  type: TYPE_PRE
- en: 'Although there is not a SUB object, minus signs are interpreted as either negations
    or subtractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE786]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there are two Adds and a Pow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE787]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following, an Add, Mul, Pow and two functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE788]'
  prefs: []
  type: TYPE_PRE
- en: 'for a total of 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE789]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that “what you type” is not always what you get. The expression 1/x/y
    is translated by sympy into 1/(x*y) so it gives a DIV and MUL rather than two
    DIVs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE790]'
  prefs: []
  type: TYPE_PRE
- en: 'The visual option can be used to demonstrate the difference in operations for
    expressions in different forms. Here, the Horner representation is compared with
    the expanded form of a polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE791]'
  prefs: []
  type: TYPE_PRE
- en: 'The count_ops function also handles iterables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE792]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE793]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper around expand that only uses the mul hint. See the expand docstring
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE794]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE795]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper around expand that only uses the log hint. See the expand docstring
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE796]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE797]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper around expand that only uses the func hint. See the expand docstring
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE798]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE799]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper around expand that only uses the trig hint. See the expand docstring
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE800]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE801]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper around expand that only uses the complex hint. See the expand docstring
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE802]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.expr.Expr.as_real_imag`](#sympy.core.expr.Expr.as_real_imag "sympy.core.expr.Expr.as_real_imag")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE803]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper around expand that only uses the multinomial hint. See the expand docstring
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE804]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE805]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper around expand that only uses the power_exp hint.
  prefs: []
  type: TYPE_NORMAL
- en: See the expand docstring for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE806]'
  prefs: []
  type: TYPE_PRE
- en: 'If `x = 0` the value of the expression depends on the value of `y`; if the
    expression were expanded the result would be 0\. So expansion is only done if
    `x != 0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE807]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE808]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper around expand that only uses the power_base hint.
  prefs: []
  type: TYPE_NORMAL
- en: A wrapper to expand(power_base=True) which separates a power with a base that
    is a Mul into a product of powers, without performing any other expansions, provided
    that assumptions about the power’s base and exponent allow.
  prefs: []
  type: TYPE_NORMAL
- en: deep=False (default is True) will only apply to the top-level expression.
  prefs: []
  type: TYPE_NORMAL
- en: force=True (default is False) will cause the expansion to ignore assumptions
    about the base and exponent. When False, the expansion will only happen if the
    base is non-negative or the exponent is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE809]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE810]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE811]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE812]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE813]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE814]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE815]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that sums are left untouched. If this is not the desired behavior, apply
    full `expand()` to the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE816]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE817]'
  prefs: []
  type: TYPE_PRE
- en: 'The power that is unexpanded can be expanded safely when `y != 0`, otherwise
    different values might be obtained for the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE818]'
  prefs: []
  type: TYPE_PRE
- en: 'If we indicate that `y` is positive but then replace it with a value of 0 after
    expansion, the expression becomes 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE819]'
  prefs: []
  type: TYPE_PRE
- en: 'But if `z = -1` the expression would not be zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE820]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`expand`](#sympy.core.function.expand "sympy.core.function.expand")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE821]'
  prefs: []
  type: TYPE_PRE
- en: Make all Rationals in expr Floats except those in exponents (unless the exponents
    flag is set to True) and those in undefined functions. When processing dictionaries,
    do not modify the keys unless `dkeys=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE822]'
  prefs: []
  type: TYPE_PRE
- en: 'Container types are not modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE823]  ## evalf'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE824]'
  prefs: []
  type: TYPE_PRE
- en: Mixin class adding evalf capability.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE825]'
  prefs: []
  type: TYPE_PRE
- en: Evaluate the given formula to an accuracy of *n* digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**subs** : dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Substitute numerical values for symbols, e.g. `subs={x:3, y:1+pi}`. The substitutions
    must be given as a dictionary.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**maxn** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Allow a maximum temporary working precision of maxn digits.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**chop** : bool or number, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies how to replace tiny real or imaginary parts in subresults by exact
    zeros.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When `True` the chop value defaults to standard precision.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Otherwise the chop value is used to determine the magnitude of “small” for purposes
    of chopping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE826]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '**strict** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Raise `PrecisionExhausted` if any subresult fails to evaluate to full accuracy,
    given the available maxprec.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**quad** : str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature
    is used. For oscillatory integrals on an infinite interval, try `quad='osc'`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**verbose** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Print debug information.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'When Floats are naively substituted into an expression, precision errors may
    adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate
    to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what
    happens in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE827]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the subs argument for evalf is the accurate way to evaluate such an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE828]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE829]'
  prefs: []
  type: TYPE_PRE
- en: Evaluate the given formula to an accuracy of *n* digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**subs** : dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Substitute numerical values for symbols, e.g. `subs={x:3, y:1+pi}`. The substitutions
    must be given as a dictionary.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**maxn** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Allow a maximum temporary working precision of maxn digits.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**chop** : bool or number, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies how to replace tiny real or imaginary parts in subresults by exact
    zeros.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When `True` the chop value defaults to standard precision.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Otherwise the chop value is used to determine the magnitude of “small” for purposes
    of chopping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE830]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '**strict** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Raise `PrecisionExhausted` if any subresult fails to evaluate to full accuracy,
    given the available maxprec.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**quad** : str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Choose algorithm for numerical quadrature. By default, tanh-sinh quadrature
    is used. For oscillatory integrals on an infinite interval, try `quad='osc'`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**verbose** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Print debug information.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'When Floats are naively substituted into an expression, precision errors may
    adversely affect the result. For example, adding 1e16 (a Float) to 1 will truncate
    to 1e16; if 1e16 is then subtracted, the result will be 0. That is exactly what
    happens in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE831]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the subs argument for evalf is the accurate way to evaluate such an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE832]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE833]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE834]'
  prefs: []
  type: TYPE_PRE
- en: Calls x.evalf(n, **options).
  prefs: []
  type: TYPE_NORMAL
- en: Explanations
  prefs: []
  type: TYPE_NORMAL
- en: Both .n() and N() are equivalent to .evalf(); use the one that you like better.
    See also the docstring of .evalf() for information on the options.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE835]  ## containers'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE836]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper around the builtin tuple object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sympify** : bool'
  prefs: []
  type: TYPE_NORMAL
- en: If `False`, `sympify` is not called on `args`. This can be used for speedups
    for very large tuples where the elements are known to already be SymPy objects.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The Tuple is a subclass of Basic, so that it works well in the SymPy framework.
    The wrapped tuple is available as self.args, but you can also access elements
    or slices with [:] syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE837]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE838]'
  prefs: []
  type: TYPE_PRE
- en: Searches and returns the first index of the value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE839]'
  prefs: []
  type: TYPE_PRE
- en: The kind of a Tuple instance.
  prefs: []
  type: TYPE_NORMAL
- en: The kind of a Tuple is always of [`TupleKind`](#sympy.core.containers.TupleKind
    "sympy.core.containers.TupleKind") but parametrised by the number of elements
    and the kind of each element.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE840]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.kind.MatrixKind`](matrices/kind.html#sympy.matrices.kind.MatrixKind
    "sympy.matrices.kind.MatrixKind"), [`sympy.core.kind.NumberKind`](#sympy.core.kind.NumberKind
    "sympy.core.kind.NumberKind")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE841]'
  prefs: []
  type: TYPE_PRE
- en: Return number of occurrences of value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE842]'
  prefs: []
  type: TYPE_PRE
- en: TupleKind is a subclass of Kind, which is used to define Kind of `Tuple`.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters of TupleKind will be kinds of all the arguments in Tuples, for example
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**args** : tuple(element_kind)'
  prefs: []
  type: TYPE_NORMAL
- en: element_kind is kind of element. args is tuple of kinds of element
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE843]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.core.kind.NumberKind`](#sympy.core.kind.NumberKind "sympy.core.kind.NumberKind"),
    [`MatrixKind`](matrices/kind.html#sympy.matrices.kind.MatrixKind "sympy.matrices.kind.MatrixKind"),
    [`sympy.sets.sets.SetKind`](sets.html#sympy.sets.conditionset.SetKind "sympy.sets.sets.SetKind")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE844]'
  prefs: []
  type: TYPE_PRE
- en: Wrapper around the builtin dict object.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The Dict is a subclass of Basic, so that it works well in the SymPy framework.
    Because it is immutable, it may be included in sets, but its values must all be
    given at instantiation and cannot be changed afterwards. Otherwise it behaves
    identically to the Python dict.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE845]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE846]'
  prefs: []
  type: TYPE_PRE
- en: 'The args are sympified so the 1 and 2 are Integers and the values are Symbols.
    Queries automatically sympify args so the following work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE847]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE848]'
  prefs: []
  type: TYPE_PRE
- en: Returns the value for key if the key is in the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE849]'
  prefs: []
  type: TYPE_PRE
- en: Returns a set-like object providing a view on dict’s items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE850]'
  prefs: []
  type: TYPE_PRE
- en: Returns the list of the dict’s keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE851]'
  prefs: []
  type: TYPE_PRE
- en: 'Returns the list of the dict’s values.  ## exprtools'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE852]'
  prefs: []
  type: TYPE_PRE
- en: Compute the GCD of `terms` and put them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**terms** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: Can be an expression or a non-Basic sequence of expressions which will be handled
    as though they are terms from a sum.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**isprimitive** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If `isprimitive` is True the _gcd_terms will not run the primitive method on
    the terms.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**clear** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: It controls the removal of integers from the denominator of an Add expression.
    When True (default), all numerical denominator will be cleared; when False the
    denominators will be cleared only if all terms had numerical denominators other
    than 1.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**fraction** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: When True (default), will put the expression over a common denominator.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE853]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE854]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE855]'
  prefs: []
  type: TYPE_PRE
- en: The `clear` flag was ignored in this case because the returned expression was
    a rational expression, not a simple sum.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`factor_terms`](#sympy.core.exprtools.factor_terms "sympy.core.exprtools.factor_terms"),
    [`sympy.polys.polytools.terms_gcd`](polys/reference.html#sympy.polys.polytools.terms_gcd
    "sympy.polys.polytools.terms_gcd")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE856]'
  prefs: []
  type: TYPE_PRE
- en: Remove common factors from terms in all arguments without changing the underlying
    structure of the expr. No expansion or simplification (and no processing of non-commutatives)
    is performed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**radical: bool, optional**'
  prefs: []
  type: TYPE_NORMAL
- en: If radical=True then a radical common to all terms will be factored out of any
    Add sub-expressions of the expr.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**clear** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If clear=False (default) then coefficients will not be separated from a single
    Add if they can be distributed to leave one or more terms with integer coefficients.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**fraction** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If fraction=True (default is False) then a common denominator will be constructed
    for the expression.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**sign** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If sign=True (default) then even if the only factor in common is a -1, it will
    be factored out of the expression.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE857]'
  prefs: []
  type: TYPE_PRE
- en: 'When `clear` is False, a rational will only be factored out of an Add expression
    if all terms of the Add have coefficients that are fractions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE858]'
  prefs: []
  type: TYPE_PRE
- en: 'If a -1 is all that can be factored out, to *not* factor it out, the flag `sign`
    must be False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE859]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`gcd_terms`](#sympy.core.exprtools.gcd_terms "sympy.core.exprtools.gcd_terms"),
    [`sympy.polys.polytools.terms_gcd`](polys/reference.html#sympy.polys.polytools.terms_gcd
    "sympy.polys.polytools.terms_gcd")  ## kind'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE860]'
  prefs: []
  type: TYPE_PRE
- en: Base class for kinds.
  prefs: []
  type: TYPE_NORMAL
- en: Kind of the object represents the mathematical classification that the entity
    falls into. It is expected that functions and classes recognize and filter the
    argument by its kind.
  prefs: []
  type: TYPE_NORMAL
- en: Kind of every object must be carefully selected so that it shows the intention
    of design. Expressions may have different kind according to the kind of its arguments.
    For example, arguments of `Add` must have common kind since addition is group
    operator, and the resulting `Add()` has the same kind.
  prefs: []
  type: TYPE_NORMAL
- en: For the performance, each kind is as broad as possible and is not based on set
    theory. For example, `NumberKind` includes not only complex number but expression
    containing `S.Infinity` or `S.NaN` which are not strictly number.
  prefs: []
  type: TYPE_NORMAL
- en: Kind may have arguments as parameter. For example, `MatrixKind()` may be constructed
    with one element which represents the kind of its elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`Kind` behaves in singleton-like fashion. Same signature will return the same
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE861]'
  prefs: []
  type: TYPE_PRE
- en: alias of NumberKind
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE862]'
  prefs: []
  type: TYPE_PRE
- en: alias of UndefinedKind
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE863]'
  prefs: []
  type: TYPE_PRE
- en: alias of BooleanKind
  prefs: []
  type: TYPE_NORMAL
- en: Sorting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE864]'
  prefs: []
  type: TYPE_PRE
- en: Return a key that can be used for sorting.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key has the structure:'
  prefs: []
  type: TYPE_NORMAL
- en: (class_key, (len(args), args), exponent.sort_key(), coefficient)
  prefs: []
  type: TYPE_NORMAL
- en: This key is supplied by the sort_key routine of Basic objects when `item` is
    a Basic object or an object (other than a string) that sympifies to a Basic object.
    Otherwise, this function produces the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `order` argument is passed along to the sort_key routine and is used to
    determine how the terms *within* an expression are ordered. (See examples below)
    `order` options are: ‘lex’, ‘grlex’, ‘grevlex’, and reversed values of the same
    (e.g. ‘rev-lex’). The default order value is None (which translates to ‘lex’).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE865]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are equivalent ways of getting the key for an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE866]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are some examples of the key that is produced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE867]'
  prefs: []
  type: TYPE_PRE
- en: 'While sort_key is a method only defined for SymPy objects, default_sort_key
    will accept anything as an argument so it is more robust as a sorting key. For
    the following, using key= lambda i: i.sort_key() would fail because 2 does not
    have a sort_key method; that’s why default_sort_key is used. Note, that it also
    handles sympification of non-string items likes ints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE868]'
  prefs: []
  type: TYPE_PRE
- en: 'The returned key can be used anywhere that a key can be specified for a function,
    e.g. sort, min, max, etc…:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE869]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'The key returned is useful for getting items into a canonical order that will
    be the same across platforms. It is not directly useful for sorting lists of expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE870]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `a` has only 1 term, its value of sort_key is unaffected by `order`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE871]'
  prefs: []
  type: TYPE_PRE
- en: 'If `a` and `b` are combined then the key will differ because there are terms
    that can be ordered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE872]'
  prefs: []
  type: TYPE_PRE
- en: 'But since the keys for each of these terms are independent of `order`’s value,
    they do not sort differently when they appear separately in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE873]'
  prefs: []
  type: TYPE_PRE
- en: The order of terms obtained when using these keys is the order that would be
    obtained if those terms were *factors* in a product.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although it is useful for quickly putting expressions in canonical order, it
    does not sort expressions based on their complexity defined by the number of operations,
    power of variables and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE874]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ordered`](#sympy.core.sorting.ordered "sympy.core.sorting.ordered"), [`sympy.core.expr.Expr.as_ordered_factors`](#sympy.core.expr.Expr.as_ordered_factors
    "sympy.core.expr.Expr.as_ordered_factors"), [`sympy.core.expr.Expr.as_ordered_terms`](#sympy.core.expr.Expr.as_ordered_terms
    "sympy.core.expr.Expr.as_ordered_terms")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE875]'
  prefs: []
  type: TYPE_PRE
- en: 'Return an iterator of the seq where keys are used to break ties in a conservative
    fashion: if, after applying a key, there are no ties then no other keys will be
    computed.'
  prefs: []
  type: TYPE_NORMAL
- en: Two default keys will be applied if 1) keys are not provided or 2) the given
    keys do not resolve all ties (but only if `default` is True). The two keys are
    `_nodes` (which places smaller expressions before large) and `default_sort_key`
    which (if the `sort_key` for an object is defined properly) should resolve any
    ties. This strategy is similar to sorting done by `Basic.compare`, but differs
    in that `ordered` never makes a decision based on an objects name.
  prefs: []
  type: TYPE_NORMAL
- en: If `warn` is True then an error will be raised if there were no keys remaining
    to break ties. This can be used if it was expected that there should be no ties
    between items that are not identical.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE876]'
  prefs: []
  type: TYPE_PRE
- en: 'The count_ops is not sufficient to break ties in this list and the first two
    items appear in their original order (i.e. the sorting is stable):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE877]'
  prefs: []
  type: TYPE_PRE
- en: 'The default_sort_key allows the tie to be broken:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE878]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, sequences are sorted by length, then sum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE879]'
  prefs: []
  type: TYPE_PRE
- en: 'If `warn` is True, an error will be raised if there were not enough keys to
    break ties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE880]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'The decorated sort is one of the fastest ways to sort a sequence for which
    special item comparison is desired: the sequence is decorated, sorted on the basis
    of the decoration (e.g. making all letters lower case) and then undecorated. If
    one wants to break ties for items that have the same decorated value, a second
    key can be used. But if the second key is expensive to compute then it is inefficient
    to decorate all items with both keys: only those items having identical first
    key values need to be decorated. This function applies keys successively only
    when needed to break ties. By yielding an iterator, use of the tie-breaker is
    delayed as long as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: This function is best used in cases when use of the first key is expected to
    be a good hashing function; if there are no unique hashes from application of
    a key, then that key should not have been used. The exception, however, is that
    even if there are many collisions, if the first group is small and one does not
    need to process all items in the list then time will not be wasted sorting what
    one was not interested in. For example, if one were looking for the minimum in
    a list and there were several criteria used to define the sort order, then this
    function would be good at returning that quickly if the first group of candidates
    is small relative to the number of items being processed.
  prefs: []
  type: TYPE_NORMAL
- en: '## Random'
  prefs: []
  type: TYPE_NORMAL
- en: When you need to use random numbers in SymPy library code, import from here
    so there is only one generator working for SymPy. Imports from here should behave
    the same as if they were being imported from Python’s random module. But only
    the routines currently used in SymPy are included here. To use others import `rng`
    and access the method directly. For example, to capture the current state of the
    generator use `rng.getstate()`.
  prefs: []
  type: TYPE_NORMAL
- en: There is intentionally no Random to import from here. If you want to control
    the state of the generator, import `seed` and call it with or without an argument
    to set the state.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE881]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE882]'
  prefs: []
  type: TYPE_PRE
- en: Return a random complex number.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce chance of hitting branch cuts or anything, we guarantee b <= Im z
    <= d, a <= Re z <= c
  prefs: []
  type: TYPE_NORMAL
- en: When rational is True, a rational approximation to a random number is obtained
    within specified tolerance, if any.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE883]'
  prefs: []
  type: TYPE_PRE
- en: Test numerically that f and g agree when evaluated in the argument z.
  prefs: []
  type: TYPE_NORMAL
- en: If z is None, all symbols will be tested. This routine does not test whether
    there are Floats present with precision higher than 15 digits so if there are,
    your results may not be what you expect due to round- off errors.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE884]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE885]'
  prefs: []
  type: TYPE_PRE
- en: Test numerically that the symbolically computed derivative of f with respect
    to z is correct.
  prefs: []
  type: TYPE_NORMAL
- en: This routine does not test whether there are Floats present with precision higher
    than 15 digits so if there are, your results may not be what you expect due to
    round-off errors.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE886]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE887]'
  prefs: []
  type: TYPE_PRE
- en: Return a randrange generator.
  prefs: []
  type: TYPE_NORMAL
- en: '`seed` can be'
  prefs: []
  type: TYPE_NORMAL
- en: None - return randomly seeded generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: int - return a generator seeded with the int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: list - the values to be returned will be taken from the list in the order given;
    the provided list is not modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE888]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE889]'
  prefs: []
  type: TYPE_PRE
- en: Return a randint generator.
  prefs: []
  type: TYPE_NORMAL
- en: '`seed` can be'
  prefs: []
  type: TYPE_NORMAL
- en: None - return randomly seeded generator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: int - return a generator seeded with the int
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: list - the values to be returned will be taken from the list in the order given;
    the provided list is not modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE890]  ## Traversal'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE891]'
  prefs: []
  type: TYPE_PRE
- en: Apply `F` to all expressions in an expression tree from the bottom up. If `atoms`
    is True, apply `F` even if there are no args; if `nonbasic` is True, try to apply
    `F` to non-Basic objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE892]'
  prefs: []
  type: TYPE_PRE
- en: Do a postorder traversal of a tree.
  prefs: []
  type: TYPE_NORMAL
- en: This generator recursively yields nodes that it has visited in a postorder fashion.
    That is, it descends through the tree depth-first to yield all of a node’s children’s
    postorder traversal before yielding the node itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**node** : SymPy expression'
  prefs: []
  type: TYPE_NORMAL
- en: The expression to traverse.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**keys** : (default None) sort key(s)'
  prefs: []
  type: TYPE_NORMAL
- en: The key(s) used to sort args of Basic objects. When None, args of Basic objects
    are processed in arbitrary order. If key is defined, it will be passed along to
    ordered() as the only key(s) to use to sort the arguments; if `key` is simply
    True then the default keys of `ordered` will be used (node count and default_sort_key).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**subtree** : SymPy expression'
  prefs: []
  type: TYPE_NORMAL
- en: All of the subtrees in the tree.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE893]'
  prefs: []
  type: TYPE_PRE
- en: The nodes are returned in the order that they are encountered unless key is
    given; simply passing key=True will guarantee that the traversal is unique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE894]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE895]'
  prefs: []
  type: TYPE_PRE
- en: Do a pre-order traversal of a tree.
  prefs: []
  type: TYPE_NORMAL
- en: This iterator recursively yields nodes that it has visited in a pre-order fashion.
    That is, it yields the current node then descends through the tree breadth-first
    to yield all of a node’s children’s pre-order traversal.
  prefs: []
  type: TYPE_NORMAL
- en: For an expression, the order of the traversal depends on the order of .args,
    which in many cases can be arbitrary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**node** : SymPy expression'
  prefs: []
  type: TYPE_NORMAL
- en: The expression to traverse.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**keys** : (default None) sort key(s)'
  prefs: []
  type: TYPE_NORMAL
- en: The key(s) used to sort args of Basic objects. When None, args of Basic objects
    are processed in arbitrary order. If key is defined, it will be passed along to
    ordered() as the only key(s) to use to sort the arguments; if `key` is simply
    True then the default keys of ordered will be used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Yields:'
  prefs: []
  type: TYPE_NORMAL
- en: '**subtree** : SymPy expression'
  prefs: []
  type: TYPE_NORMAL
- en: All of the subtrees in the tree.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE896]'
  prefs: []
  type: TYPE_PRE
- en: The nodes are returned in the order that they are encountered unless key is
    given; simply passing key=True will guarantee that the traversal is unique.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE897]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE898]'
  prefs: []
  type: TYPE_PRE
- en: Use `func` to transform `expr` at the given level.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE899]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE900]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE901]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE902]'
  prefs: []
  type: TYPE_PRE
- en: Iterate through the args that are the given types (target) and return a list
    of the args that were traversed; arguments that are not of the specified types
    are not traversed.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE903]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`bottom_up`](#sympy.core.traversal.bottom_up "sympy.core.traversal.bottom_up")'
  prefs: []
  type: TYPE_NORMAL
