# scipy.special.ncfdtri

> Original textï¼š[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.special.ncfdtri.html#scipy.special.ncfdtri](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.special.ncfdtri.html#scipy.special.ncfdtri)

```py
scipy.special.ncfdtri(dfn, dfd, nc, p, out=None) = <ufunc 'ncfdtri'>
```

Inverse with respect to *f* of the CDF of the non-central F distribution.

See [`ncfdtr`](scipy.special.ncfdtr.html#scipy.special.ncfdtr "scipy.special.ncfdtr") for more details.

Parameters:

**dfn**array_like

Degrees of freedom of the numerator sum of squares. Range (0, inf).

**dfd**array_like

Degrees of freedom of the denominator sum of squares. Range (0, inf).

**nc**array_like

Noncentrality parameter. Should be in range (0, 1e4).

**p**array_like

Value of the cumulative distribution function. Must be in the range [0, 1].

**out**ndarray, optional

Optional output array for the function results

Returns:

**f**scalar or ndarray

Quantiles, i.e., the upper limit of integration.

See also

[`ncfdtr`](scipy.special.ncfdtr.html#scipy.special.ncfdtr "scipy.special.ncfdtr")

CDF of the non-central F distribution.

[`ncfdtridfd`](scipy.special.ncfdtridfd.html#scipy.special.ncfdtridfd "scipy.special.ncfdtridfd")

Inverse of [`ncfdtr`](scipy.special.ncfdtr.html#scipy.special.ncfdtr "scipy.special.ncfdtr") with respect to *dfd*.

[`ncfdtridfn`](scipy.special.ncfdtridfn.html#scipy.special.ncfdtridfn "scipy.special.ncfdtridfn")

Inverse of [`ncfdtr`](scipy.special.ncfdtr.html#scipy.special.ncfdtr "scipy.special.ncfdtr") with respect to *dfn*.

[`ncfdtrinc`](scipy.special.ncfdtrinc.html#scipy.special.ncfdtrinc "scipy.special.ncfdtrinc")

Inverse of [`ncfdtr`](scipy.special.ncfdtr.html#scipy.special.ncfdtr "scipy.special.ncfdtr") with respect to *nc*.

Examples

```py
>>> from scipy.special import ncfdtr, ncfdtri 
```

Compute the CDF for several values of *f*:

```py
>>> f = [0.5, 1, 1.5]
>>> p = ncfdtr(2, 3, 1.5, f)
>>> p
array([ 0.20782291,  0.36107392,  0.47345752]) 
```

Compute the inverse. We recover the values of *f*, as expected:

```py
>>> ncfdtri(2, 3, 1.5, p)
array([ 0.5,  1\. ,  1.5]) 
```
