# 信号处理（scipy.signal）

> 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/signal.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/signal.html)

信号处理工具箱目前包含一些滤波函数，有限的滤波器设计工具集，以及一些用于一维和二维数据的B-样条插值算法。虽然B-样条算法技术上可以归类为插值类别，但它们包含在此处是因为它们仅适用于等间距数据，并且广泛利用滤波理论和传递函数形式学来提供快速的B-样条变换。要理解本节，您需要理解SciPy中信号是实数或复数数组。

## B-样条

B-样条是在有限区间内以B-样条系数和结点点的形式对连续函数的近似。如果结点点等间距，间距为 \(\Delta x\)，那么对一维函数的B-样条近似是有限基函数展开。

\[y\left(x\right)\approx\sum_{j}c_{j}\beta^{o}\left(\frac{x}{\Delta x}-j\right).\]

在结点间距 \(\Delta x\) 和 \(\Delta y\) 的二维情况下，函数表示为

\[z\left(x,y\right)\approx\sum_{j}\sum_{k}c_{jk}\beta^{o}\left(\frac{x}{\Delta x}-j\right)\beta^{o}\left(\frac{y}{\Delta y}-k\right).\]

在这些表达式中，\(\beta^{o}\left(\cdot\right)\) 是阶数为 \(o\) 的空间限制B-样条基函数。等间距结点和等间距数据点的要求，允许从样本值 \(y_{n}\) 中相对轻松地计算系数 \(c_{j}\) 的快速（逆滤波）算法。与一般样条插值算法不同，这些算法可以快速找到大图像的样条系数。

通过B-样条基函数表示一组样本的优势在于，可以相对轻松地从样条系数中计算连续域操作（导数、重采样、积分等）。例如，样条的二阶导数是

\[y{}^{\prime\prime}\left(x\right)=\frac{1}{\Delta x^{2}}\sum_{j}c_{j}\beta^{o\prime\prime}\left(\frac{x}{\Delta x}-j\right).\]

利用B-样条的性质，

\[\frac{d^{2}\beta^{o}\left(w\right)}{dw^{2}}=\beta^{o-2}\left(w+1\right)-2\beta^{o-2}\left(w\right)+\beta^{o-2}\left(w-1\right),\]

可以看出

\[y^{\prime\prime}\left(x\right)=\frac{1}{\Delta x^{2}}\sum_{j}c_{j}\left[\beta^{o-2}\left(\frac{x}{\Delta x}-j+1\right)-2\beta^{o-2}\left(\frac{x}{\Delta x}-j\right)+\beta^{o-2}\left(\frac{x}{\Delta x}-j-1\right)\right].\]

如果 \(o=3\)，则在采样点：

\begin{eqnarray*} \Delta x^{2}\left.y^{\prime}\left(x\right)\right|_{x=n\Delta x} & = & \sum_{j}c_{j}\delta_{n-j+1}-2c_{j}\delta_{n-j}+c_{j}\delta_{n-j-1},\\ & = & c_{n+1}-2c_{n}+c_{n-1}.\end{eqnarray*}

因此，可以轻松地从样条拟合中计算出二阶导数信号。如果需要，可以找到平滑样条，使得二阶导数对随机误差不太敏感。

精明的读者可能已经注意到，数据样本通过卷积算子与结节系数相关联，因此，简单地使用采样的B样条函数进行卷积可以从样条系数中恢复原始数据。卷积的输出可以根据边界处理方式而改变（随着数据集维度的增加，这一点变得越来越重要）。信号处理子包中关于B样条的算法假定镜像对称边界条件。因此，基于该假设计算样条系数，并且通过假设它们也是镜像对称的，可以精确地从样条系数中恢复数据样本。

目前，该包提供了在一维和二维等间距样本中确定二阶和三阶立方样条系数的函数（[`qspline1d`](../reference/generated/scipy.signal.qspline1d.html#scipy.signal.qspline1d "scipy.signal.qspline1d"), [`qspline2d`](../reference/generated/scipy.signal.qspline2d.html#scipy.signal.qspline2d "scipy.signal.qspline2d"), [`cspline1d`](../reference/generated/scipy.signal.cspline1d.html#scipy.signal.cspline1d "scipy.signal.cspline1d"), [`cspline2d`](../reference/generated/scipy.signal.cspline2d.html#scipy.signal.cspline2d "scipy.signal.cspline2d"))。对于较大的 \(o\)，B样条基函数可以很好地近似为标准偏差为 \(\sigma_{o}=\left(o+1\right)/12\) 的零均值高斯函数：

\[\beta^{o}\left(x\right)\approx\frac{1}{\sqrt{2\pi\sigma_{o}^{2}}}\exp\left(-\frac{x^{2}}{2\sigma_{o}}\right).\]

可用于任意 \(x\) 和 \(o\) 计算该高斯函数的函数为 [`gauss_spline`](../reference/generated/scipy.signal.gauss_spline.html#scipy.signal.gauss_spline "scipy.signal.gauss_spline") 。以下代码和图像使用样条滤波计算浣熊面部的边缘图像（平滑样条的二阶导数），浣熊面部是通过命令 [`scipy.datasets.face`](../reference/generated/scipy.datasets.face.html#scipy.datasets.face "scipy.datasets.face") 返回的数组。命令 [`sepfir2d`](../reference/generated/scipy.signal.sepfir2d.html#scipy.signal.sepfir2d "scipy.signal.sepfir2d") 用于应用具有镜像对称边界条件的可分离2-D FIR滤波器到样条系数。该函数非常适合从样条系数中重建样本，并且比 [`convolve2d`](../reference/generated/scipy.signal.convolve2d.html#scipy.signal.convolve2d "scipy.signal.convolve2d") 更快，后者可以卷积任意2-D滤波器并允许选择镜像对称边界条件。

```py
>>> import numpy as np
>>> from scipy import signal, datasets
>>> import matplotlib.pyplot as plt 
```

```py
>>> image = datasets.face(gray=True).astype(np.float32)
>>> derfilt = np.array([1.0, -2, 1.0], dtype=np.float32)
>>> ck = signal.cspline2d(image, 8.0)
>>> deriv = (signal.sepfir2d(ck, derfilt, [1]) +
...          signal.sepfir2d(ck, [1], derfilt)) 
```

或者，我们可以这样做：

```py
laplacian = np.array([[0,1,0], [1,-4,1], [0,1,0]], dtype=np.float32)
deriv2 = signal.convolve2d(ck,laplacian,mode='same',boundary='symm') 
```

```py
>>> plt.figure()
>>> plt.imshow(image)
>>> plt.gray()
>>> plt.title('Original image')
>>> plt.show() 
```

!["This code displays two plots. The first plot is a normal grayscale photo of a raccoon climbing on a palm plant. The second plot has the 2-D spline filter applied to the photo and is completely grey except the edges of the photo have been emphasized, especially on the raccoon fur and palm fronds."](../Images/6afce5c3a77c44be51837f10c7459f44.png)

```py
>>> plt.figure()
>>> plt.imshow(deriv)
>>> plt.gray()
>>> plt.title('Output of spline edge filter')
>>> plt.show() 
```

!["This code displays two plots. The first plot is a normal grayscale photo of a raccoon climbing on a palm plant. The second plot has the 2-D spline filter applied to the photo and is completely grey except the edges of the photo have been emphasized, especially on the raccoon fur and palm fronds."](../Images/2d7bb4e70d091dce966908ca963a5b43.png)

## 过滤

过滤是修改输入信号的任何系统的通用名称。在 SciPy 中，信号可以被看作是一个 NumPy 数组。有不同类型的滤波器用于不同类型的操作。有两种广泛的滤波操作：线性和非线性。线性滤波器总是可以简化为通过适当矩阵的乘积来实现另一个扁平化的 NumPy 数组。当然，这通常不是计算滤波器的最佳方式，因为涉及的矩阵和向量可能非常庞大。例如，使用这种方法对 \(512 \times 512\) 图像进行滤波将需要将 \(512^2 \times 512^2\) 矩阵与 \(512^2\) 向量相乘。仅尝试使用标准 NumPy 数组存储 \(512^2 \times 512^2\) 矩阵将需要 \(68,719,476,736\) 个元素。每个元素占 4 字节，这将需要 \(256\textrm{GB}\) 内存。在大多数应用中，该矩阵的大多数元素为零，并且采用了不同的方法来计算滤波器的输出。

### 卷积/相关

许多线性滤波器还具有平移不变性的特性。这意味着滤波操作在信号的不同位置上是相同的，并且这意味着可以仅从矩阵的一行（或列）的知识构造滤波矩阵。在这种情况下，可以使用傅里叶变换来实现矩阵乘法。

让 \(x\left[n\right]\) 定义为以整数 \(n\) 为索引的一维信号。两个一维信号的完全卷积可以表示为

\[y\left[n\right]=\sum_{k=-\infty}^{\infty}x\left[k\right]h\left[n-k\right].\]

只有在我们将序列限制为可以存储在计算机中的有限支持序列时，才能直接实现此方程。选择 \(n=0\) 作为两个序列的起始点，让 \(K+1\) 是使得对所有 \(n\geq K+1\) 有 \(x\left[n\right]=0\) 的值，\(M+1\) 是使得对所有 \(n\geq M+1\) 有 \(h\left[n\right]=0\) 的值，那么离散卷积表达式为

\[y\left[n\right]=\sum_{k=\max\left(n-M,0\right)}^{\min\left(n,K\right)}x\left[k\right]h\left[n-k\right].\]

为了方便起见，假设 \(K\geq M.\) 那么，更明确地，此操作的输出是

\begin{eqnarray*} y\left[0\right] & = & x\left[0\right]h\left[0\right]\\ y\left[1\right] & = & x\left[0\right]h\left[1\right]+x\left[1\right]h\left[0\right]\\ y\left[2\right] & = & x\left[0\right]h\left[2\right]+x\left[1\right]h\left[1\right]+x\left[2\right]h\left[0\right]\\ \vdots & \vdots & \vdots\\ y\left[M\right] & = & x\left[0\right]h\left[M\right]+x\left[1\right]h\left[M-1\right]+\cdots+x\left[M\right]h\left[0\right]\\ y\left[M+1\right] & = & x\left[1\right]h\left[M\right]+x\left[2\right]h\left[M-1\right]+\cdots+x\left[M+1\right]h\left[0\right]\\ \vdots & \vdots & \vdots\\ y\left[K\right] & = & x\left[K-M\right]h\left[M\right]+\cdots+x\left[K\right]h\left[0\right]\\ y\left[K+1\right] & = & x\left[K+1-M\right]h\left[M\right]+\cdots+x\left[K\right]h\left[1\right]\\ \vdots & \vdots & \vdots\\ y\left[K+M-1\right] & = & x\left[K-1\right]h\left[M\right]+x\left[K\right]h\left[M-1\right]\\ y\left[K+M\right] & = & x\left[K\right]h\left[M\right].\end{eqnarray*}

因此，两个长度分别为\(K+1\)和\(M+1\)的有限序列的完全离散卷积结果是一个长度为\(K+M+1=\left(K+1\right)+\left(M+1\right)-1\)的有限序列。

SciPy中实现了1-D卷积，使用函数[`convolve`](../reference/generated/scipy.signal.convolve.html#scipy.signal.convolve "scipy.signal.convolve")。此函数接受信号\(x\)、\(h\)和两个可选标志‘mode’和‘method’作为输入，并返回信号\(y\)。

第一个可选标志‘mode’允许指定要返回的输出信号的哪个部分。默认值‘full’返回整个信号。如果标志的值为‘same’，则只返回长度与第一个输入相同的中间\(K\)个值，从\(y\left[\left\lfloor \frac{M-1}{2}\right\rfloor \right]\)开始。如果标志的值为‘valid’，则只返回中间\(K-M+1=\left(K+1\right)-\left(M+1\right)+1\)个输出值，其中\(z\)取决于从\(h\left[0\right]\)到\(h\left[M\right]\)的最小输入的所有值。换句话说，只返回\(y\left[M\right]\)到\(y\left[K\right]\)（含）的值。

第二个可选标志‘method’确定如何计算卷积，可以通过傅里叶变换方法使用[`fftconvolve`](../reference/generated/scipy.signal.fftconvolve.html#scipy.signal.fftconvolve "scipy.signal.fftconvolve")或直接方法。默认情况下，选择预期较快的方法。傅里叶变换方法的时间复杂度为\(O(N\log N)\)，而直接方法的时间复杂度为\(O(N^2)\)。根据大O常数和\(N\)的值，其中一种方法可能更快。默认值‘auto’执行粗略计算并选择预期较快的方法，而值‘direct’和‘fft’则强制使用另外两种方法计算。

下面的代码展示了两个序列的卷积的简单示例：

```py
>>> x = np.array([1.0, 2.0, 3.0])
>>> h = np.array([0.0, 1.0, 0.0, 0.0, 0.0])
>>> signal.convolve(x, h)
array([ 0.,  1.,  2.,  3.,  0.,  0.,  0.])
>>> signal.convolve(x, h, 'same')
array([ 2.,  3.,  0.]) 
```

这个相同的函数[`convolve`](../reference/generated/scipy.signal.convolve.html#scipy.signal.convolve "scipy.signal.convolve")实际上可以接受N-D数组作为输入，并返回两个数组的N-D卷积，如下面的代码示例所示。对于这种情况，相同的输入标志也是可用的。

```py
>>> x = np.array([[1., 1., 0., 0.], [1., 1., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]])
>>> h = np.array([[1., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 0.]])
>>> signal.convolve(x, h)
array([[ 1.,  1.,  0.,  0.,  0.,  0.,  0.],
 [ 1.,  1.,  0.,  0.,  0.,  0.,  0.],
 [ 0.,  0.,  1.,  1.,  0.,  0.,  0.],
 [ 0.,  0.,  1.,  1.,  0.,  0.,  0.],
 [ 0.,  0.,  0.,  0.,  0.,  0.,  0.],
 [ 0.,  0.,  0.,  0.,  0.,  0.,  0.],
 [ 0.,  0.,  0.,  0.,  0.,  0.,  0.]]) 
```

相关性非常类似于卷积，只是减号变为加号。因此，

\[w\left[n\right]=\sum_{k=-\infty}^{\infty}y\left[k\right]x\left[n+k\right],\]

是信号\(y\)和\(x\)的(交)相关性。对于长度有限的信号，其中\(y\left[n\right]=0\)超出范围\(\left[0,K\right]\)，\(x\left[n\right]=0\)超出范围\(\left[0,M\right]\)，求和可以简化为

\[w\left[n\right]=\sum_{k=\max\left(0,-n\right)}^{\min\left(K,M-n\right)}y\left[k\right]x\left[n+k\right].\]

再次假设\(K\geq M\)，这是

\begin{eqnarray*} w\left[-K\right] & = & y\left[K\right]x\left[0\right]\\ w\left[-K+1\right] & = & y\left[K-1\right]x\left[0\right]+y\left[K\right]x\left[1\right]\\ \vdots & \vdots & \vdots\\ w\left[M-K\right] & = & y\left[K-M\right]x\left[0\right]+y\left[K-M+1\right]x\left[1\right]+\cdots+y\left[K\right]x\left[M\right]\\ w\left[M-K+1\right] & = & y\left[K-M-1\right]x\left[0\right]+\cdots+y\left[K-1\right]x\left[M\right]\\ \vdots & \vdots & \vdots\\ w\left[-1\right] & = & y\left[1\right]x\left[0\right]+y\left[2\right]x\left[1\right]+\cdots+y\left[M+1\right]x\left[M\right]\\ w\left[0\right] & = & y\left[0\right]x\left[0\right]+y\left[1\right]x\left[1\right]+\cdots+y\left[M\right]x\left[M\right]\\ w\left[1\right] & = & y\left[0\right]x\left[1\right]+y\left[1\right]x\left[2\right]+\cdots+y\left[M-1\right]x\left[M\right]\\ w\left[2\right] & = & y\left[0\right]x\left[2\right]+y\left[1\right]x\left[3\right]+\cdots+y\left[M-2\right]x\left[M\right]\\ \vdots & \vdots & \vdots\\ w\left[M-1\right] & = & y\left[0\right]x\left[M-1\right]+y\left[1\right]x\left[M\right]\\ w\left[M\right] & = & y\left[0\right]x\left[M\right].\end{eqnarray*}

SciPy函数[`correlate`](../reference/generated/scipy.signal.correlate.html#scipy.signal.correlate "scipy.signal.correlate")实现了这个操作。同样的标志也适用于此操作，以返回完整的\(K+M+1\)长度序列（‘full’），或一个从\(w\left[-K+\left\lfloor \frac{M-1}{2}\right\rfloor \right]\)开始大小相同的序列（‘same’），或一个值取决于最小序列所有值的序列（‘valid’）。最后一种选项返回从\(w\left[M-K\right]\)到\(w\left[0\right]\)（包括）的\(K-M+1\)个值。

函数[`correlate`](../reference/generated/scipy.signal.correlate.html#scipy.signal.correlate "scipy.signal.correlate")还可以接受任意的N-D数组作为输入，并返回两个数组的N-D卷积。

当 \(N=2,\) 可以使用[`correlate`](../reference/generated/scipy.signal.correlate.html#scipy.signal.correlate "scipy.signal.correlate") 和/或 [`convolve`](../reference/generated/scipy.signal.convolve.html#scipy.signal.convolve "scipy.signal.convolve") 构建任意图像滤波器，执行模糊化、增强和边缘检测等操作。

```py
>>> import numpy as np
>>> from scipy import signal, datasets
>>> import matplotlib.pyplot as plt 
```

```py
>>> image = datasets.face(gray=True)
>>> w = np.zeros((50, 50))
>>> w[0][0] = 1.0
>>> w[49][25] = 1.0
>>> image_new = signal.fftconvolve(image, w) 
```

```py
>>> plt.figure()
>>> plt.imshow(image)
>>> plt.gray()
>>> plt.title('Original image')
>>> plt.show() 
```

!["此代码显示两个图。第一张图是熟悉的浣熊攀爬在棕榈树上的照片。第二张图应用了FIR滤波器，并且由于在滤波核定义中手动设置的双峰，照片被叠加显示了两份。"](../Images/a031ed887fc96d3573976234c0dfd09c.png)

```py
>>> plt.figure()
>>> plt.imshow(image_new)
>>> plt.gray()
>>> plt.title('Filtered image')
>>> plt.show() 
```

!["此代码显示两个图。第一张图是熟悉的浣熊攀爬在棕榈树上的照片。第二张图应用了FIR滤波器，并且由于在滤波核定义中手动设置的双峰，照片被叠加显示了两份。"](../Images/4b0f1c5eb2856c5db5187362206d3d41.png)

在时间域中计算卷积，通常用于当信号之一远小于另一个时进行滤波（ \(K\gg M\) ），否则提供由函数[`fftconvolve`](../reference/generated/scipy.signal.fftconvolve.html#scipy.signal.fftconvolve "scipy.signal.fftconvolve") 提供的频域进行线性滤波计算更有效。默认情况下，[`convolve`](../reference/generated/scipy.signal.convolve.html#scipy.signal.convolve "scipy.signal.convolve") 使用[`choose_conv_method`](../reference/generated/scipy.signal.choose_conv_method.html#scipy.signal.choose_conv_method "scipy.signal.choose_conv_method") 估算最快的方法。

如果滤波函数 \(w[n,m]\) 可以按如下分解：

\[h[n, m] = h_1[n] h_2[m],\]

卷积可以通过函数[`sepfir2d`](../reference/generated/scipy.signal.sepfir2d.html#scipy.signal.sepfir2d "scipy.signal.sepfir2d") 计算。例如，我们考虑一个高斯滤波器[`gaussian`](../reference/generated/scipy.signal.windows.gaussian.html#scipy.signal.windows.gaussian "scipy.signal.windows.gaussian")。

\[h[n, m] \propto e^{-x^2-y^2} = e^{-x^2} e^{-y^2},\]

通常用于模糊处理。

```py
>>> import numpy as np
>>> from scipy import signal, datasets
>>> import matplotlib.pyplot as plt 
```

```py
>>> image = np.asarray(datasets.ascent(), np.float64)
>>> w = signal.windows.gaussian(51, 10.0)
>>> image_new = signal.sepfir2d(image, w, w) 
```

```py
>>> plt.figure()
>>> plt.imshow(image)
>>> plt.gray()
>>> plt.title('Original image')
>>> plt.show() 
```

!["此代码显示两个图。第一张图是从下方拍摄的两人攀爬木楼梯的灰度照片。第二张图应用了2-D高斯FIR窗口，看起来非常模糊。你仍然可以看出这是一张照片，但主题不太明确。"](../Images/59bdee04f14114a099cb447b708f1ddc.png)

```py
>>> plt.figure()
>>> plt.imshow(image_new)
>>> plt.gray()
>>> plt.title('Filtered image')
>>> plt.show() 
```

!["此代码显示两个图。第一张图是从下方拍摄的两人攀爬木楼梯的灰度照片。第二张图应用了2-D高斯FIR窗口，看起来非常模糊。你仍然可以看出这是一张照片，但主题不太明确。"](../Images/2c9cde3dce93eb73a57f57a70703af7f.png)

### 差分方程滤波

一般的线性1-D滤波器类（包括卷积滤波器）由差分方程描述。

\[\sum_{k=0}^{N}a_{k}y\left[n-k\right]=\sum_{k=0}^{M}b_{k}x\left[n-k\right],\]

其中 \(x\left[n\right]\) 是输入序列，\(y\left[n\right]\) 是输出序列。如果假定初始休息使得对于 \(n<0\)，\(y\left[n\right]=0\)，那么这种类型的滤波器可以使用卷积来实现。然而，如果 \(a_{k}\neq0\) 对于 \(k\geq1\)，则卷积滤波器序列 \(h\left[n\right]\) 可能是无限的。此外，这种一般的线性滤波器允许对 \(y\left[n\right]\) 的初始条件进行放置，以使得对于 \(n<0\) 的滤波器不能使用卷积来表示。

差分方程滤波器可以被视为在前一个值的基础上递归地找到 \(y\left[n\right]\)。

\[a_{0}y\left[n\right]=-a_{1}y\left[n-1\right]-\cdots-a_{N}y\left[n-N\right]+\cdots+b_{0}x\left[n\right]+\cdots+b_{M}x\left[n-M\right].\]

通常情况下，选择 \(a_{0}=1\) 进行归一化。SciPy中这种一般差分方程滤波器的实现比前述方程复杂一些。实现方式是只需要延迟一个信号。实际的实现方程为（假设 \(a_{0}=1\) ）：

\begin{eqnarray*} y\left[n\right] & = & b_{0}x\left[n\right]+z_{0}\left[n-1\right]\\ z_{0}\left[n\right] & = & b_{1}x\left[n\right]+z_{1}\left[n-1\right]-a_{1}y\left[n\right]\\ z_{1}\left[n\right] & = & b_{2}x\left[n\right]+z_{2}\left[n-1\right]-a_{2}y\left[n\right]\\ \vdots & \vdots & \vdots\\ z_{K-2}\left[n\right] & = & b_{K-1}x\left[n\right]+z_{K-1}\left[n-1\right]-a_{K-1}y\left[n\right]\\ z_{K-1}\left[n\right] & = & b_{K}x\left[n\right]-a_{K}y\left[n\right],\end{eqnarray*}

这里 \(K=\max\left(N,M\right)\)。注意，如果 \(K>M\) 则 \(b_{K}=0\)，如果 \(K>N\) 则 \(a_{K}=0\)。因此，输出在时间 \(n\) 只依赖于时间 \(n\) 的输入以及前一个时间的 \(z_{0}\) 的值。只要计算和存储每个时间步骤中的 \(K\) 值 \(z_{0}\left[n-1\right]\ldots z_{K-1}\left[n-1\right]\)，就可以始终计算这些值。

在SciPy中，可以使用命令[`lfilter`](../reference/generated/scipy.signal.lfilter.html#scipy.signal.lfilter "scipy.signal.lfilter")调用这种差分方程滤波器。该命令的输入为向量 \(b\)、向量 \(a\)、信号 \(x\)，并返回与上述方程计算出的长度相同的向量 \(y\)。如果 \(x\) 是 N-D，则沿提供的轴计算滤波器。如果需要，可以提供初始条件，以提供 \(z_{0}\left[-1\right]\) 到 \(z_{K-1}\left[-1\right]\) 的值，否则将假定它们全部为零。如果提供了初始条件，则中间变量的最终条件也会被返回。例如，这些条件可以用来在相同状态下重新启动计算。

有时，用信号\(x\left[n\right]\)和\(y\left[n\right]\)来表达初始条件更加方便。换句话说，也许你有\(x\left[-M\right]\)到\(x\left[-1\right]\)的值和\(y\left[-N\right]\)到\(y\left[-1\right]\)的值，希望确定应该作为差分方程滤波器初始条件的\(z_{m}\left[-1\right]\)的值。不难证明，对于\(0\leq m<K\)，

\[z_{m}\left[n\right]=\sum_{p=0}^{K-m-1}\left(b_{m+p+1}x\left[n-p\right]-a_{m+p+1}y\left[n-p\right]\right).\]

使用这个公式，我们可以找到给定\(y\)（和\(x\))的初始条件向量\(z_{0}\left[-1\right]\)到\(z_{K-1}\left[-1\right]\)。命令[`lfiltic`](../reference/generated/scipy.signal.lfiltic.html#scipy.signal.lfiltic "scipy.signal.lfiltic")执行此功能。

例如，考虑以下系统：

\[y[n] = \frac{1}{2} x[n] + \frac{1}{4} x[n-1] + \frac{1}{3} y[n-1]\]

该代码计算给定信号\(x[n]\)的信号\(y[n]\)；首先对于初始条件\(y[-1] = 0\)（默认情况），然后通过[`lfiltic`](../reference/generated/scipy.signal.lfiltic.html#scipy.signal.lfiltic "scipy.signal.lfiltic")将其设置为\(y[-1] = 2\)。

```py
>>> import numpy as np
>>> from scipy import signal 
```

```py
>>> x = np.array([1., 0., 0., 0.])
>>> b = np.array([1.0/2, 1.0/4])
>>> a = np.array([1.0, -1.0/3])
>>> signal.lfilter(b, a, x)
array([0.5, 0.41666667, 0.13888889, 0.0462963])
>>> zi = signal.lfiltic(b, a, y=[2.])
>>> signal.lfilter(b, a, x, zi=zi)
(array([ 1.16666667,  0.63888889,  0.21296296,  0.07098765]), array([0.02366])) 
```

注意，输出信号\(y[n]\)的长度与输入信号\(x[n]\)的长度相同。

#### 线性系统分析

描述线性差分方程的线性系统可以完全由上述系数向量\(a\)和\(b\)描述；另一种表示是通过其传递函数\(H(z)\)提供因子\(k\)、\(N_z\)个零点\(z_k\)和\(N_p\)个极点\(p_k\)。

\[H(z) = k \frac{ (z-z_1)(z-z_2)...(z-z_{N_z})}{ (z-p_1)(z-p_2)...(z-p_{N_p})}.\]

这种替代表示可以通过SciPy函数[`tf2zpk`](../reference/generated/scipy.signal.tf2zpk.html#scipy.signal.tf2zpk "scipy.signal.tf2zpk")获得；逆操作由[`zpk2tf`](../reference/generated/scipy.signal.zpk2tf.html#scipy.signal.zpk2tf "scipy.signal.zpk2tf")提供。

对于上述例子，我们有

```py
>>> b = np.array([1.0/2, 1.0/4])
>>> a = np.array([1.0, -1.0/3])
>>> signal.tf2zpk(b, a)
(array([-0.5]), array([ 0.33333333]), 0.5) 
```

即，该系统在\(z=-1/2\)处有一个零点，在\(z=1/3\)处有一个极点。

SciPy函数[`freqz`](../reference/generated/scipy.signal.freqz.html#scipy.signal.freqz "scipy.signal.freqz")允许计算由系数\(a_k\)和\(b_k\)描述的系统的频率响应。查看[`freqz`](../reference/generated/scipy.signal.freqz.html#scipy.signal.freqz "scipy.signal.freqz")函数的帮助以获取详细示例。

### 滤波器设计

时间离散滤波器可以分为有限响应（FIR）滤波器和无限响应（IIR）滤波器。FIR滤波器可以提供线性相位响应，而IIR滤波器则不能。SciPy提供了设计这两种类型滤波器的函数。

#### FIR滤波器

函数 [`firwin`](../reference/generated/scipy.signal.firwin.html#scipy.signal.firwin "scipy.signal.firwin") 根据窗口方法设计滤波器。根据提供的参数，函数返回不同类型的滤波器（如低通、带通等）。

下面的示例分别设计了低通和带阻滤波器。

```py
>>> import numpy as np
>>> import scipy.signal as signal
>>> import matplotlib.pyplot as plt 
```

```py
>>> b1 = signal.firwin(40, 0.5)
>>> b2 = signal.firwin(41, [0.3, 0.8])
>>> w1, h1 = signal.freqz(b1)
>>> w2, h2 = signal.freqz(b2) 
```

```py
>>> plt.title('Digital filter frequency response')
>>> plt.plot(w1, 20*np.log10(np.abs(h1)), 'b')
>>> plt.plot(w2, 20*np.log10(np.abs(h2)), 'r')
>>> plt.ylabel('Amplitude Response (dB)')
>>> plt.xlabel('Frequency (rad/sample)')
>>> plt.grid()
>>> plt.show() 
```

!["此代码显示了一个振幅响应在 Y 轴上 vs 频率在 X 轴上的 X-Y 图。第一个（低通）蓝色迹线从 0 dB 的通带开始，并在中途左右开始下降，阻带约下降 80 dB。第二个（带阻）红色迹线从 0 dB 开始并结束，但中间部分从峰值下降约 60 dB，滤波器会抑制信号时带有波动。"](../Images/66ab465cd54eb94754df36204b24c4b0.png)

注意 [`firwin`](../reference/generated/scipy.signal.firwin.html#scipy.signal.firwin "scipy.signal.firwin") 默认使用归一化频率，其中值 \(1\) 对应于 Nyquist 频率，而函数 [`freqz`](../reference/generated/scipy.signal.freqz.html#scipy.signal.freqz "scipy.signal.freqz") 定义为值 \(\pi\) 对应于 Nyquist 频率。

函数 [`firwin2`](../reference/generated/scipy.signal.firwin2.html#scipy.signal.firwin2 "scipy.signal.firwin2") 允许通过指定一组角频率和对应增益来设计几乎任意频率响应。

下面的示例设计了一个具有任意振幅响应的滤波器。

```py
>>> import numpy as np
>>> import scipy.signal as signal
>>> import matplotlib.pyplot as plt 
```

```py
>>> b = signal.firwin2(150, [0.0, 0.3, 0.6, 1.0], [1.0, 2.0, 0.5, 0.0])
>>> w, h = signal.freqz(b) 
```

```py
>>> plt.title('Digital filter frequency response')
>>> plt.plot(w, np.abs(h))
>>> plt.title('Digital filter frequency response')
>>> plt.ylabel('Amplitude Response')
>>> plt.xlabel('Frequency (rad/sample)')
>>> plt.grid()
>>> plt.show() 
```

!["此代码显示了一个振幅响应在 Y 轴上 vs 频率在 X 轴上的 X-Y 图。单个迹线形状类似于心跳信号。"](../Images/b7567b74c92211d8eb58a2663a7bb2fa.png)

请注意 [`firwin2`](../reference/generated/scipy.signal.firwin2.html#scipy.signal.firwin2 "scipy.signal.firwin2") 和 [`freqz`](../reference/generated/scipy.signal.freqz.html#scipy.signal.freqz "scipy.signal.freqz") 的 y 轴的线性缩放以及 Nyquist 频率的不同定义（如上所述）。

#### IIR 滤波器

SciPy 提供了两个函数来直接设计 IIR 滤波器 [`iirdesign`](../reference/generated/scipy.signal.iirdesign.html#scipy.signal.iirdesign "scipy.signal.iirdesign") 和 [`iirfilter`](../reference/generated/scipy.signal.iirfilter.html#scipy.signal.iirfilter "scipy.signal.iirfilter")，其中滤波器类型（如椭圆）作为参数传递，并提供了几个特定类型滤波器设计函数，例如 [`ellip`](../reference/generated/scipy.signal.ellip.html#scipy.signal.ellip "scipy.signal.ellip")。

下面的示例设计了一个椭圆低通滤波器，并分别定义了通带和阻带波动。请注意，为了达到相同的阻带衰减（约 60 dB），滤波器阶数（4 阶）比上面示例中的 FIR 滤波器低得多。

```py
>>> import numpy as np
>>> import scipy.signal as signal
>>> import matplotlib.pyplot as plt 
```

```py
>>> b, a = signal.iirfilter(4, Wn=0.2, rp=5, rs=60, btype='lowpass', ftype='ellip')
>>> w, h = signal.freqz(b, a) 
```

```py
>>> plt.title('Digital filter frequency response')
>>> plt.plot(w, 20*np.log10(np.abs(h)))
>>> plt.title('Digital filter frequency response')
>>> plt.ylabel('Amplitude Response [dB]')
>>> plt.xlabel('Frequency (rad/sample)')
>>> plt.grid()
>>> plt.show() 
```

!["此代码生成一个振幅响应在X轴上频率的X-Y图。单个迹线显示一个平滑的低通滤波器，左侧的第三个通带接近0 dB。右侧的三分之二约为60 dB，有两个锐利的狭窄谷，向下跌至-100 dB。"](../Images/61983117829df044b63c4428667f34f3.png)

#### 滤波器系数

滤波器系数可以用几种不同的格式存储：

+   ‘ba’ 或 ‘tf’ = 传递函数系数

+   ‘zpk’ = 零点、极点和总增益

+   ‘ss’ = 状态空间系统表示

+   ‘sos’ = 二阶段传递函数系数

函数，如 [`tf2zpk`](../reference/generated/scipy.signal.tf2zpk.html#scipy.signal.tf2zpk "scipy.signal.tf2zpk") 和 [`zpk2ss`](../reference/generated/scipy.signal.zpk2ss.html#scipy.signal.zpk2ss "scipy.signal.zpk2ss")，可以在它们之间进行转换。

##### 传递函数表示

`ba` 或 `tf` 格式是一个 2 元组 `(b, a)`，表示传递函数，其中 *b* 是长度为 `M+1` 的系数数组，表示 *M* 阶分子多项式，*a* 是长度为 `N+1` 的系数数组，表示 *N* 阶分母多项式，系数按传递函数变量的正降幂排列。因此，元组 \(b = [b_0, b_1, ..., b_M]\) 和 \(a =[a_0, a_1, ..., a_N]\) 可以表示形如下的模拟滤波器：

\[H(s) = \frac {b_0 s^M + b_1 s^{(M-1)} + \cdots + b_M} {a_0 s^N + a_1 s^{(N-1)} + \cdots + a_N} = \frac {\sum_{i=0}^M b_i s^{(M-i)}} {\sum_{i=0}^N a_i s^{(N-i)}}\]

或者离散时间滤波器的形式：

\[H(z) = \frac {b_0 z^M + b_1 z^{(M-1)} + \cdots + b_M} {a_0 z^N + a_1 z^{(N-1)} + \cdots + a_N} = \frac {\sum_{i=0}^M b_i z^{(M-i)}} {\sum_{i=0}^N a_i z^{(N-i)}}.\]

此“正幂”形式在控制工程中更常见。如果 *M* 和 *N* 相等（这对所有通过双线性变换生成的滤波器都是真的），则这等同于 DSP 中首选的“负幂”离散时间形式：

\[H(z) = \frac {b_0 + b_1 z^{-1} + \cdots + b_M z^{-M}} {a_0 + a_1 z^{-1} + \cdots + a_N z^{-N}} = \frac {\sum_{i=0}^M b_i z^{-i}} {\sum_{i=0}^N a_i z^{-i}}.\]

尽管这对于常见的滤波器是真的，但请记住，这在一般情况下并非如此。如果 *M* 和 *N* 不相等，则在找到极点和零点之前，必须先将离散时间传递函数系数转换为“正幂”形式。

此表示在高阶存在数值误差，因此在可能的情况下，更喜欢使用其他格式。

##### 零点和极点表示

`zpk` 格式是一个 3 元组 `(z, p, k)`，其中 *z* 是长度为 *M* 的复零点数组 \(z = [z_0, z_1, ..., z_{M-1}]\)，*p* 是长度为 *N* 的复极点数组 \(p = [p_0, p_1, ..., p_{N-1}]\)，*k* 是标量增益。这些表示数字传递函数：

\[H(z) = k \cdot \frac {(z - z_0) (z - z_1) \cdots (z - z_{(M-1)})} {(z - p_0) (z - p_1) \cdots (z - p_{(N-1)})} = k \frac {\prod_{i=0}^{M-1} (z - z_i)} {\prod_{i=0}^{N-1} (z - p_i)}\]

或者模拟传递函数：

\[H(s) = k \cdot \frac {(s - z_0) (s - z_1) \cdots (s - z_{(M-1)})} {(s - p_0) (s - p_1) \cdots (s - p_{(N-1)})} = k \frac {\prod_{i=0}^{M-1} (s - z_i)} {\prod_{i=0}^{N-1} (s - p_i)}.\]

尽管根集存储为有序的 NumPy 数组，但它们的顺序并不重要： `([-1, -2], [-3, -4], 1)` 和 `([-2, -1], [-4, -3], 1)` 是相同的滤波器。

##### 状态空间系统表示

`ss` 格式是一个四元组 `(A, B, C, D)`，表示一个 *N* 阶数字/离散时间系统的状态空间形式：

\[\begin{split}\mathbf{x}[k+1] = A \mathbf{x}[k] + B \mathbf{u}[k]\\ \mathbf{y}[k] = C \mathbf{x}[k] + D \mathbf{u}[k]\end{split}\]

或者连续/模拟系统的形式：

\[\begin{split}\dot{\mathbf{x}}(t) = A \mathbf{x}(t) + B \mathbf{u}(t)\\ \mathbf{y}(t) = C \mathbf{x}(t) + D \mathbf{u}(t),\end{split}\]

具有 *P* 输入，*Q* 输出和 *N* 状态变量的系统，其中：

+   *x* 是状态向量

+   *y* 是长度为 *Q* 的输出向量

+   *u* 是长度为 *P* 的输入向量

+   *A* 是状态矩阵，形状为 `(N, N)`

+   *B* 是形状为`(N, P)`的输入矩阵

+   *C* 是形状为`(Q, N)`的输出矩阵

+   *D* 是形状为`(Q, P)`的前馈或反馈矩阵。 （在系统没有直接前馈的情况下，*D* 中的所有值均为零。）

状态空间是最一般的表示形式，也是唯一允许多输入多输出（MIMO）系统的表示形式。 对于给定的传递函数，有多种状态空间表示。 具体来说，“可控规范形式”和“可观测规范形式”的系数与 `tf` 表示相同，因此会遭受相同的数值误差。

##### 二阶段表示

`sos` 格式是形状为`(n_sections, 6)`的单个二维数组，表示串联的二阶传递函数序列，以最小的数值误差实现更高阶的滤波器。 每行对应于一个二阶 `tf` 表示，前三列提供分子系数，后三列提供分母系数：

\[[b_0, b_1, b_2, a_0, a_1, a_2]\]

系数通常是标准化的，使得 \(a_0\) 始终为1。 在浮点计算中通常不重要，滤波器输出将相同，无论顺序如何。

#### 滤波器转换

IIR 滤波器设计函数首先生成一个标准化截止频率为1 rad/sec 的模拟低通滤波器原型。 然后使用以下替换将其转换为其他频率和带类型：

| 类型 | 转换 |
| --- | --- |
| [`lp2lp`](../reference/generated/scipy.signal.lp2lp.html#scipy.signal.lp2lp "scipy.signal.lp2lp") | \(s \rightarrow \frac{s}{\omega_0}\) |
| [`lp2hp`](../reference/generated/scipy.signal.lp2hp.html#scipy.signal.lp2hp "scipy.signal.lp2hp") | \(s \rightarrow \frac{\omega_0}{s}\) |
| [`lp2bp`](../reference/generated/scipy.signal.lp2bp.html#scipy.signal.lp2bp "scipy.signal.lp2bp") | \(s \rightarrow \frac{s^2 + {\omega_0}^2}{s \cdot \mathrm{BW}}\) |
| [`lp2bs`](../reference/generated/scipy.signal.lp2bs.html#scipy.signal.lp2bs "scipy.signal.lp2bs") | \(s \rightarrow \frac{s \cdot \mathrm{BW}}{s^2 + {\omega_0}^2}\) |

在这里，\(\omega_0\) 是新的截止频率或中心频率，而 \(\mathrm{BW}\) 是带宽。这些在对数频率轴上保持对称。

要将转换后的模拟滤波器转换为数字滤波器，使用 [`bilinear`](../reference/generated/scipy.signal.bilinear.html#scipy.signal.bilinear "scipy.signal.bilinear") 变换，进行以下替换：

\[s \rightarrow \frac{2}{T} \frac{z - 1}{z + 1},\]

当中 T 是采样时间（采样频率的倒数）。

### 其他滤波器

信号处理包还提供了许多其他滤波器。

#### 中值滤波器

当噪声明显非高斯或者希望保留边缘时，通常会应用中值滤波器。中值滤波器通过对感兴趣点周围的像素值进行排序来工作。这个邻域像素值列表的样本中位数被用作输出数组的值。如果邻域中有偶数个元素，则使用中间两个值的平均值作为中位数。一个适用于 N-D 数组的通用中值滤波器是 [`medfilt`](../reference/generated/scipy.signal.medfilt.html#scipy.signal.medfilt "scipy.signal.medfilt")。一个专门针对 2-D 数组的版本是 [`medfilt2d`](../reference/generated/scipy.signal.medfilt2d.html#scipy.signal.medfilt2d "scipy.signal.medfilt2d")。

#### 顺序滤波器

中值滤波器是更一般的称为顺序滤波器的滤波器类的一个特定示例。要计算特定像素的输出，所有顺序滤波器使用周围区域内的数组值。这些数组值被排序，然后从中选择一个作为输出值。对于中值滤波器，数组值列表的样本中位数用作输出。一般顺序滤波器允许用户选择在排序值中哪一个作为输出。例如，可以选择在列表中选择最大值或最小值。顺序滤波器除了输入数组和区域掩码之外，还接受一个指定哪些邻居数组值在排序列表中应该作为输出的元素。执行顺序滤波器的命令是[`order_filter`](../reference/generated/scipy.signal.order_filter.html#scipy.signal.order_filter "scipy.signal.order_filter").

#### Wiener滤波器

Wiener滤波器是一种简单的去模糊滤波器，用于图像去噪。这不是通常描述的图像重建问题中的Wiener滤波器，而是一种简单的局部均值滤波器。设\(x\)为输入信号，则输出为

\[\begin{split}y=\left\{ \begin{array}{cc} \frac{\sigma^{2}}{\sigma_{x}^{2}}m_{x}+\left(1-\frac{\sigma^{2}}{\sigma_{x}^{2}}\right)x & \sigma_{x}^{2}\geq\sigma^{2},\\ m_{x} & \sigma_{x}^{2}<\sigma^{2},\end{array}\right.\end{split}\]

其中\(m_{x}\)是均值的局部估计，\(\sigma_{x}^{2}\)是方差的局部估计。这些估计的窗口是一个可选的输入参数（默认为\(3\times3\)）。参数\(\sigma^{2}\)是一个阈值噪声参数。如果未提供\(\sigma\)，则将其估计为局部方差的平均值。

#### Hilbert滤波器

Hilbert变换从实信号构造复值解析信号。例如，如果\(x=\cos\omega n\)，那么\(y=\textrm{hilbert}\left(x\right)\)会返回（除了接近边缘的地方）\(y=\exp\left(j\omega n\right)\)。在频率域中，Hilbert变换执行

\[Y=X\cdot H,\]

其中\(H\)对于正频率为\(2\)，对于负频率为\(0\)，对于零频率为\(1\)。

### 模拟滤波器设计

函数[`iirdesign`](../reference/generated/scipy.signal.iirdesign.html#scipy.signal.iirdesign "scipy.signal.iirdesign")、[`iirfilter`](../reference/generated/scipy.signal.iirfilter.html#scipy.signal.iirfilter "scipy.signal.iirfilter")以及特定滤波器类型的滤波器设计函数（例如[`ellip`](../reference/generated/scipy.signal.ellip.html#scipy.signal.ellip "scipy.signal.ellip")）都具有一个*analog*标志，允许设计模拟滤波器。

下面的示例设计了一个模拟（IIR）滤波器，通过[`tf2zpk`](../reference/generated/scipy.signal.tf2zpk.html#scipy.signal.tf2zpk "scipy.signal.tf2zpk")获得极点和零点，并在复平面中绘制它们。在幅度响应中可以清楚地看到大约在\(\omega \approx 150\)和\(\omega \approx 300\)处的零点。

```py
>>> import numpy as np
>>> import scipy.signal as signal
>>> import matplotlib.pyplot as plt 
```

```py
>>> b, a = signal.iirdesign(wp=100, ws=200, gpass=2.0, gstop=40., analog=True)
>>> w, h = signal.freqs(b, a) 
```

```py
>>> plt.title('Analog filter frequency response')
>>> plt.plot(w, 20*np.log10(np.abs(h)))
>>> plt.ylabel('Amplitude Response [dB]')
>>> plt.xlabel('Frequency')
>>> plt.grid()
>>> plt.show() 
```

![这段代码显示了两个图。第一个图是IIR滤波器响应的X-Y图，其中Y轴是幅度响应，X轴是频率。所示的低通滤波器在0到100 Hz的通带内具有0 dB响应，并且在约175 Hz到1 KHz之间的阻带下降约40 dB。滤波器在约175 Hz和300 Hz附近有两个明显的不连续点。第二个图是在复平面上显示传递函数的X-Y图。Y轴是实值，X轴是复值。滤波器在[300+0j, 175+0j, -175+0j, -300+0j]附近有四个零点，显示为蓝色X标记。滤波器还在[50-30j, -50-30j, 100-8j, -100-8j]附近有四个极点，显示为红色点。](../Images/ef56198e3fe8c328f78fd995cbf8b28c.png)

```py
>>> z, p, k = signal.tf2zpk(b, a) 
```

```py
>>> plt.plot(np.real(z), np.imag(z), 'ob', markerfacecolor='none')
>>> plt.plot(np.real(p), np.imag(p), 'xr')
>>> plt.legend(['Zeros', 'Poles'], loc=2) 
```

```py
>>> plt.title('Pole / Zero Plot')
>>> plt.xlabel('Real')
>>> plt.ylabel('Imaginary')
>>> plt.grid()
>>> plt.show() 
```

![这段代码显示了两个图。第一个图是IIR滤波器响应的X-Y图，其中Y轴是幅度响应，X轴是频率。所示的低通滤波器在0到100 Hz的通带内具有0 dB响应，并且在约175 Hz到1 KHz之间的阻带下降约40 dB。滤波器在约175 Hz和300 Hz附近有两个明显的不连续点。第二个图是在复平面上显示传递函数的X-Y图。Y轴是实值，X轴是复值。滤波器在[300+0j, 175+0j, -175+0j, -300+0j]附近有四个零点，显示为蓝色X标记。滤波器还在[50-30j, -50-30j, 100-8j, -100-8j]附近有四个极点，显示为红色点。](../Images/866a45da1ada45b6dc922f9841041db2.png)

## 频谱分析

### 周期图测量

scipy函数[`periodogram`](../reference/generated/scipy.signal.periodogram.html#scipy.signal.periodogram "scipy.signal.periodogram")提供了使用周期图方法估算频谱密度的方法。

下面的示例计算了白高斯噪声中正弦信号的周期图。

```py
>>> import numpy as np
>>> import scipy.signal as signal
>>> import matplotlib.pyplot as plt 
```

```py
>>> fs = 10e3
>>> N = 1e5
>>> amp = 2*np.sqrt(2)
>>> freq = 1270.0
>>> noise_power = 0.001 * fs / 2
>>> time = np.arange(N) / fs
>>> x = amp*np.sin(2*np.pi*freq*time)
>>> x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape) 
```

```py
>>> f, Pper_spec = signal.periodogram(x, fs, 'flattop', scaling='spectrum') 
```

```py
>>> plt.semilogy(f, Pper_spec)
>>> plt.xlabel('frequency [Hz]')
>>> plt.ylabel('PSD')
>>> plt.grid()
>>> plt.show() 
```

![这段代码显示了单个X-Y对数线性图，其中Y轴上的功率谱密度与X轴上的频率相对应。单条蓝色曲线显示了一个功率级别为1e-3的噪声底线，1270 Hz处有一个功率为1的单峰。噪声底线的测量显示噪声波动下降到1e-7。](../Images/bd13d12026ea7a24dbdb043941cc7cde.png)

### 使用Welch方法进行频谱分析

特别是在抗噪性方面改进的方法是Welch方法，由scipy函数[`welch`](../reference/generated/scipy.signal.welch.html#scipy.signal.welch "scipy.signal.welch")实现。

下面的示例使用了**Welch方法**来估算频谱，并使用与上述示例相同的参数。请注意频谱图的噪声底线要平滑得多。

```py
>>> import numpy as np
>>> import scipy.signal as signal
>>> import matplotlib.pyplot as plt 
```

```py
>>> fs = 10e3
>>> N = 1e5
>>> amp = 2*np.sqrt(2)
>>> freq = 1270.0
>>> noise_power = 0.001 * fs / 2
>>> time = np.arange(N) / fs
>>> x = amp*np.sin(2*np.pi*freq*time)
>>> x += np.random.normal(scale=np.sqrt(noise_power), size=time.shape) 
```

```py
>>> f, Pwelch_spec = signal.welch(x, fs, scaling='spectrum') 
```

```py
>>> plt.semilogy(f, Pwelch_spec)
>>> plt.xlabel('frequency [Hz]')
>>> plt.ylabel('PSD')
>>> plt.grid()
>>> plt.show() 
```

!["此代码显示一个X-Y对数线性图，Y轴上是功率谱密度，X轴上是频率。单个蓝色追踪显示了一个平滑的噪声底部，功率水平为6e-2，一个峰值功率高达2，频率为1270 Hz。"](../Images/70e228d72e7156d89e9a53245321fc30.png)

### 朗伯-斯卡戈尔周期图 ([`lombscargle`](../reference/generated/scipy.signal.lombscargle.html#scipy.signal.lombscargle "scipy.signal.lombscargle"))

最小二乘谱分析（LSSA）[[1]](#id11) [[2]](#id12) 是一种基于对数据样本进行正弦拟合的最小二乘拟合来估计频谱的方法，类似于傅里叶分析。傅里叶分析是科学中使用最广泛的谱方法，通常会增加长周期噪声在长时间间隔记录中；LSSA减少了这类问题。

朗伯-斯卡戈尔方法对不均匀采样数据执行频谱分析，已知是发现和检验弱周期信号的有效方法。

对于包含\(N_{t}\)个测量\(X_{j}\equiv X(t_{j})\)的时间序列，采样时间为\(t_{j}\)，假设已经进行了缩放和移位，使其平均值为零，方差为单位，频率为\(f\)的归一化朗伯-斯卡戈尔周期图为

\[P_{n}(f) = \frac{1}{2}\left\{\frac{\left[\sum_{j}^{N_{t}}X_{j}\cos\omega(t_{j}-\tau)\right]^{2}}{\sum_{j}^{N_{t}}\cos^{2}\omega(t_{j}-\tau)}+\frac{\left[\sum_{j}^{N_{t}}X_{j}\sin\omega(t_{j}-\tau)\right]^{2}}{\sum_{j}^{N_{t}}\sin^{2}\omega(t_{j}-\tau)}\right\}.\]

这里，\(\omega \equiv 2\pi f\) 是角频率。频率依赖的时间偏移 \(\tau\) 由以下公式给出

\[\tan 2\omega\tau = \frac{\sum_{j}^{N_{t}}\sin 2\omega t_{j}}{\sum_{j}^{N_{t}}\cos 2\omega t_{j}}.\]

[`lombscargle`](../reference/generated/scipy.signal.lombscargle.html#scipy.signal.lombscargle "scipy.signal.lombscargle")函数使用了由汤森德[[3]](#id13)提出的稍微修改的算法，允许在每个频率下通过输入数组的单次遍历计算周期图。

方程被重构为：

\[P_{n}(f) = \frac{1}{2}\left[\frac{(c_{\tau}XC + s_{\tau}XS)^{2}}{c_{\tau}^{2}CC + 2c_{\tau}s_{\tau}CS + s_{\tau}^{2}SS} + \frac{(c_{\tau}XS - s_{\tau}XC)^{2}}{c_{\tau}^{2}SS - 2c_{\tau}s_{\tau}CS + s_{\tau}^{2}CC}\right]\]

和

\[\tan 2\omega\tau = \frac{2CS}{CC-SS}.\]

这里，

\[c_{\tau} = \cos\omega\tau,\qquad s_{\tau} = \sin\omega\tau,\]

当求和时

\[\begin{split}XC &= \sum_{j}^{N_{t}} X_{j}\cos\omega t_{j}\\ XS &= \sum_{j}^{N_{t}} X_{j}\sin\omega t_{j}\\ CC &= \sum_{j}^{N_{t}} \cos^{2}\omega t_{j}\\ SS &= \sum_{j}^{N_{t}} \sin^{2}\omega t_{j}\\ CS &= \sum_{j}^{N_{t}} \cos\omega t_{j}\sin\omega t_{j}.\end{split}\]

需要进行\(N_{f}(2N_{t}+3)\)次三角函数求值，相较于简单实现，速度提升约\(\sim 2\)倍。

\[% LaTeX 宏使 LaTeX 公式更易读： \newcommand{\IC}{{\mathbb{C}}} % 复数集合 \newcommand{\IN}{{\mathbb{N}}} % 自然数集合 \newcommand{\IR}{{\mathbb{R}}} % 实数集合 \newcommand{\IZ}{{\mathbb{Z}}} % 整数集合 \newcommand{\jj}{{\mathbb{j}}} % 虚数单位 \newcommand{\e}{\operatorname{e}} % 自然对数的底 \newcommand{\dd}{\operatorname{d}} % 无穷小算子 \newcommand{\conj}[1]{\overline{#1}} % 复共轭 \newcommand{\conjT}[1]{\overline{#1^T}} % 转置复共轭 \newcommand{\inv}[1]{\left(#1\right)^{\!-1}} % 逆 % 因为未加载物理包，我们自己定义宏： \newcommand{\vb}[1]{\mathbf{#1}} % 向量和矩阵加粗\] ## 短时傅里叶变换

这一节提供了有关使用[`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT")类的一些背景信息：短时傅里叶变换（STFT）可用于分析信号随时间的频谱特性。它通过滑动窗口将信号分成重叠的块，并计算每个块的傅里叶变换。对于连续时间的复值信号 \(x(t)\)，STFT 定义为[[4]](#id14)

\[S(f, t) := \int_\IR x(\xi)\, \conj{w(\xi-t)}\,\e^{-\jj2\pi f \xi}\dd\xi\ ,\]

其中 \(w(t)\) 是复值窗口函数，其复共轭为 \(\conj{w(t)}\)。可以解释为确定 \(x\) 与窗口 \(w\) 的标量积，该窗口由时间 \(t\) 平移，然后被频率 \(f\) 调制（即频移）。对于采样信号 \(x[k] := x(kT)\)，\(k\in\IZ\)，采样间隔 \(T\)（即采样频率 [`fs`](../reference/generated/scipy.signal.ShortTimeFFT.fs.html#scipy.signal.ShortTimeFFT.fs "scipy.signal.ShortTimeFFT.fs") 的倒数），需要使用离散版本，即仅在离散网格点 \(S[q, p] := S(q \Delta f, p\Delta t)\)，\(q,p\in\IZ\) 上进行评估。可以表达为

(1)\[S[q,p] = \sum_{k=0}^{N-1} x[k]\,\conj{w[k-p h]}\, \e^{-\jj2\pi q k / N}\ , \quad q,p\in\IZ\ ,\]

其中 *p* 表示 \(S\) 的时间索引，时间间隔为 \(\Delta t := h T\)，\(h\in\IN\)（参见 [`delta_t`](../reference/generated/scipy.signal.ShortTimeFFT.delta_t.html#scipy.signal.ShortTimeFFT.delta_t "scipy.signal.ShortTimeFFT.delta_t")），它可以表达为 \(h\) 个样本的 [`hop`](../reference/generated/scipy.signal.ShortTimeFFT.hop.html#scipy.signal.ShortTimeFFT.hop "scipy.signal.ShortTimeFFT.hop") 大小。\(q\) 表示 \(S\) 的频率索引，步长为 \(\Delta f := 1 / (N T)\)（参见 [`delta_f`](../reference/generated/scipy.signal.ShortTimeFFT.delta_f.html#scipy.signal.ShortTimeFFT.delta_f "scipy.signal.ShortTimeFFT.delta_f")），使其与 FFT 兼容。\(w[m] := w(mT)\)，\(m\in\IZ\) 是采样窗口函数。

要更符合[`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT")的实现，重构方程 [(1)](#equation-eq-dstft) 为两个步骤是有意义的：

1.  通过窗口 \(w[m]\) 提取由 \(M\) 个样本组成的第 \(p\) 个切片（参见[`m_num`](../reference/generated/scipy.signal.ShortTimeFFT.m_num.html#scipy.signal.ShortTimeFFT.m_num "scipy.signal.ShortTimeFFT.m_num")），其中心位于 \(t[p] := p \Delta t = h T\)（参见[`delta_t`](../reference/generated/scipy.signal.ShortTimeFFT.delta_t.html#scipy.signal.ShortTimeFFT.delta_t "scipy.signal.ShortTimeFFT.delta_t")），即，

    > (2)\[x_p[m] = x\!\big[m - \lfloor M/2\rfloor + h p\big]\, \conj{w[m]}\ , \quad m = 0, \ldots M-1\ ,\]

    整数 \(\lfloor M/2\rfloor\) 表示 `M//2`，即窗口的中点（[`m_num_mid`](../reference/generated/scipy.signal.ShortTimeFFT.m_num_mid.html#scipy.signal.ShortTimeFFT.m_num_mid "scipy.signal.ShortTimeFFT.m_num_mid")）。为了符号方便，假设对于 \(k\not\in\{0, 1, \ldots, N-1\}\)，有 \(x[k]:=0\)。在子节[滑动窗口](#tutorial-stft-sliding-win)中详细讨论了切片的索引。

1.  然后执行离散傅立叶变换（即，一个[FFT](fft.html#tutorial-fft)）对 \(x_p[m]\) 进行操作。

    (3)\[S[q, p] = \sum_{m=0}^{M-1} x_p[m] \exp\!\big\{% -2\jj\pi (q + \phi_m)\, m / M\big\}\ .\]

    注意可以指定线性相位 \(\phi_m\)（参见[`phase_shift`](../reference/generated/scipy.signal.ShortTimeFFT.phase_shift.html#scipy.signal.ShortTimeFFT.phase_shift "scipy.signal.ShortTimeFFT.phase_shift")），它对应于将输入向右移动 \(\phi_m\) 个样本。默认值为 \(\phi_m = \lfloor M/2\rfloor\)（与 `phase_shift = 0` 定义对应），这样可以抑制未移动信号的线性相位成分。此外，FFT 可能通过用零填充 \(w[m]\) 来进行过采样。这可以通过指定[`mfft`](../reference/generated/scipy.signal.ShortTimeFFT.mfft.html#scipy.signal.ShortTimeFFT.mfft "scipy.signal.ShortTimeFFT.mfft")大于窗口长度[`m_num`](../reference/generated/scipy.signal.ShortTimeFFT.m_num.html#scipy.signal.ShortTimeFFT.m_num "scipy.signal.ShortTimeFFT.m_num")来实现——这将把 \(M\) 设置为[`mfft`](../reference/generated/scipy.signal.ShortTimeFFT.mfft.html#scipy.signal.ShortTimeFFT.mfft "scipy.signal.ShortTimeFFT.mfft")（这意味着对于 \(m\not\in\{0, 1, \ldots, M-1\}\)，也有 \(w[m]:=0\)）。

反短时傅立叶变换（[`istft`](../reference/generated/scipy.signal.ShortTimeFFT.istft.html#scipy.signal.ShortTimeFFT.istft "scipy.signal.ShortTimeFFT.istft")）通过颠倒这两个步骤来实现：

1.  执行逆离散傅立叶变换，即，

    \[x_p[m] = \frac{1}{M}\sum_{q=0}^M S[q, p]\, \exp\!\big\{ 2\jj\pi (q + \phi_m)\, m / M\big\}\ .\]

1.  加权求和偏移的切片，以重构原始信号，即，

    \[x[k] = \sum_p x_p\!\big[\mu_p(k)\big]\, w_d\!\big[\mu_p(k)\big]\ ,\quad \mu_p(k) = k + \lfloor M/2\rfloor - h p\]

    对于 \(k \in [0, \ldots, n-1]\)。\(w_d[m]\) 是称为规范对偶窗口的 \(w[m]\)，也由 \(M\) 个样本组成。

注意，并非所有窗口和跳跃大小都必然存在逆 STFT。对于给定的窗口 \(w[m]\)，跳跃大小 \(h\) 必须足够小，以确保 \(x[k]\) 的每个样本都受到至少一个窗口片段的非零值影响。这有时被称为“非零重叠条件”（参见[`check_NOLA`](../reference/generated/scipy.signal.check_NOLA.html#scipy.signal.check_NOLA "scipy.signal.check_NOLA")）。有关更多细节，请参阅小节 [Inverse STFT and Dual Windows](#tutorial-stft-dual-win)。

### 滑动窗口

本小节讨论了如何通过一个例子来索引[`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT") 中的滑动窗口：考虑一个长度为 6 的窗口，`hop` 间隔为 2，采样间隔为 [`T`](../reference/generated/scipy.signal.ShortTimeFFT.T.html#scipy.signal.ShortTimeFFT.T "scipy.signal.ShortTimeFFT.T") 为 1，例如 `ShortTimeFFT (np.ones(6), 2, fs=1)`。下图以示意图的方式展示了前四个窗口位置，也称为时间片段：

[![../_images/tutorial_stft_sliding_win_start.svg](../Images/590d72d6177cc14fc3a3fabdc9c4e8db.png)](../_images/tutorial_stft_sliding_win_start.svg)

x轴表示时间 \(t\)，对应于底部蓝色框的样本索引 *k*。y轴表示时间片段索引 \(p\)。信号 \(x[k]\) 从索引 \(k=0\) 开始，并以浅蓝色背景标出。按定义，零片段 (\(p=0\)) 居中于 \(t=0\)。每个片段的中心点 ([`m_num_mid`](../reference/generated/scipy.signal.ShortTimeFFT.m_num_mid.html#scipy.signal.ShortTimeFFT.m_num_mid "scipy.signal.ShortTimeFFT.m_num_mid"))，这里是样本 `6//2=3`，用文本“mid”标记。默认情况下，[`stft`](../reference/generated/scipy.signal.ShortTimeFFT.stft.html#scipy.signal.ShortTimeFFT.stft "scipy.signal.ShortTimeFFT.stft") 计算所有与信号有重叠的片段。因此，第一个片段在 [`p_min`](../reference/generated/scipy.signal.ShortTimeFFT.p_min.html#scipy.signal.ShortTimeFFT.p_min "scipy.signal.ShortTimeFFT.p_min") = -1，最低样本索引为 [`k_min`](../reference/generated/scipy.signal.ShortTimeFFT.k_min.html#scipy.signal.ShortTimeFFT.k_min "scipy.signal.ShortTimeFFT.k_min") = -5。第一个不被片段左边伸出影响的样本索引为 \(p_{lb} = 2\)，第一个不受边界影响的样本索引为 \(k_{lb} = 5\)。属性[`lower_border_end`](../reference/generated/scipy.signal.ShortTimeFFT.lower_border_end.html#scipy.signal.ShortTimeFFT.lower_border_end "scipy.signal.ShortTimeFFT.lower_border_end") 返回元组 \((k_{lb}, p_{lb})\)。

信号末端的行为如下所示，信号具有 \(n=50\) 个样本，如下所示，以蓝色背景标示：

[![../_images/tutorial_stft_sliding_win_stop.svg](../Images/02f510b38185a0f60e9de8ba3c331a6f.png)](../_images/tutorial_stft_sliding_win_stop.svg)

这里最后一个片段索引为 \(p=26\)。因此，遵循Python约定的结束索引在范围之外，[`p_max`](../reference/generated/scipy.signal.ShortTimeFFT.p_max.html#scipy.signal.ShortTimeFFT.p_max "scipy.signal.ShortTimeFFT.p_max") = 27 表示第一个不接触信号的片段。相应的样本索引为 [`k_max`](../reference/generated/scipy.signal.ShortTimeFFT.k_max.html#scipy.signal.ShortTimeFFT.k_max "scipy.signal.ShortTimeFFT.k_max") = 55。第一个向右伸出的片段是 \(p_{ub} = 24\)，其第一个样本为 \(k_{ub}=45\)。函数[`upper_border_begin`](../reference/generated/scipy.signal.ShortTimeFFT.upper_border_begin.html#scipy.signal.ShortTimeFFT.upper_border_begin "scipy.signal.ShortTimeFFT.upper_border_begin") 返回元组 \((k_{ub}, p_{ub})\)。  ### 逆STFT和双窗口

双窗口术语源于框架理论 [[5]](#id15)，在那里，框架是一种能够表示给定希尔伯特空间中任何函数的级数展开。在那里，展开式 \(\{g_k\}\) 和 \(\{h_k\}\) 如果对于给定希尔伯特空间 \(\mathcal{H}\) 中的所有函数 \(f\)，它们是双框架。

\[f = \sum_{k\in\IN} \langle f, g_k\rangle h_k = \sum_{k\in\IN} \langle f, h_k\rangle g_k\ , \quad f \in \mathcal{H}\ ,

holds，其中 \(\langle ., .\rangle\) 表示 \(\mathcal{H}\) 的标量积。所有框架都有对偶框架 [[5]](#id15)。

在文献中，仅在离散网格点 \(S(q \Delta f, p\Delta t)\) 处评估的 STFT 被称为 “Gabor 框架” [[4]](#id14) [[5]](#id15)。由于窗口 \(w[m]\) 的支持仅限于有限区间，[`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT") 属于所谓的 “无痛非正交展开” 类别 [[4]](#id14)。在这种情况下，对偶窗口始终具有相同的支持，并且可以通过反转对角矩阵来计算。以下将粗略推导需要理解矩阵操作的过程：

由于 Eq. [(1)](#equation-eq-dstft) 中给出的 STFT 是 \(x[k]\) 的线性映射，可以用向量-矩阵表示法表达。这使得通过线性最小二乘方法的形式解可以表达其逆（如 [`lstsq`](../reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq "scipy.linalg.lstsq")），从而导出了一个漂亮而简单的结果。

我们从重新表述 Eq. [(2)](#equation-eq-stft-windowing) 的窗函数开始。

(4)\[\begin{split} \vb{x}_p = \vb{W}_{\!p}\,\vb{x} = \begin{bmatrix} \cdots & 0 & w[0] & 0 & \cdots&&&\\ & \cdots & 0 & w[1] & 0 & \cdots&&\\ & & & & \ddots&&&\\ &&\cdots & 0 & 0 & w[M-1] & 0 & \cdots \end{bmatrix}\begin{bmatrix} x[0]\\ x[1]\\ \vdots\\ x[N-1] \end{bmatrix}\ ,\end{split}\]

其中 \(M \times N\) 矩阵 \(\vb{W}_{\!p}\) 在 \((ph)\) 主对角线上具有非零条目，即，

(5)\[\begin{split} W_p[m,k] = w[m]\, \delta_{m+ph,k}\ ,\quad \delta_{k,l} &= \begin{cases} 1 & \text{ for } k=l\ ,\\ 0 & \text{ elsewhere ,} \end{cases}\end{split}\]

其中 \(\delta_{k,l}\) 是 Kronecker Delta。Eq. [(3)](#equation-eq-stft-dft) 可以表示为

\[\vb{s}_p = \vb{F}\,\vb{x}_p \quad\text{with}\quad F[q,m] =\exp\!\big\{-2\jj\pi (q + \phi_m)\, m / M\big\}\ ,\]

允许将第 \(p\) 切片的 STFT 写为

(6)\[\vb{s}_p = \vb{F}\vb{W}_{\!p}\,\vb{x} =: \vb{G}_p\,\vb{x} \quad\text{with}\quad s_p[q] = S[p,q]\ .

注意 \(\vb{F}\) 是酉的，即其逆等于其共轭转置，意味着 \(\conjT{\vb{F}}\vb{F} = \vb{I}\)。

为了获得 STFT 的单个向量-矩阵方程，这些切片被堆叠成一个向量。

\[\begin{split}\vb{s} := \begin{bmatrix} \vb{s}_0\\ \vb{s}_1\\ \vdots\\ \vb{s}_{P-1} \end{bmatrix} = \begin{bmatrix} \vb{G}_0\\ \vb{G}_1\\ \vdots\\ \vb{G}_{P-1} \end{bmatrix}\, \vb{x} =: \vb{G}\, \vb{x}\ ,

其中 \(P\) 是生成的 STFT 的列数。为了反演这个方程，可以利用 Moore-Penrose 逆 \(\vb{G}^\dagger\)。

(7)\[\vb{x} = \inv{\conjT{\vb{G}}\vb{G}}\, \conjT{\vb{G}} \vb{s} =: \vb{G}^\dagger \vb{s}\ ,\]

如果存在

\[\begin{split}\vb{D} := \conjT{\vb{G}}\vb{G} = \begin{bmatrix} \conjT{\vb{G}_0}& \conjT{\vb{G}_1}& \cdots & \conjT{\vb{G}_{P-1}} \end{bmatrix}^T \begin{bmatrix} \vb{G}_0\\ \vb{G}_1\\ \vdots\\ \vb{G}_{P-1} \end{bmatrix} = \sum_{p=0}^{P-1} \conjT{\vb{G}_p}\vb{G}_p \ .\end{split}\]

是可逆的。因此\(\vb{x} = \vb{G}^\dagger\vb{G}\,\vb{x} = \inv{\conjT{\vb{G}}\vb{G}}\,\conjT{\vb{G}}\vb{G}\,\vb{x}\)显然成立。\(\vb{D}\)始终是一个具有非负对角条目的对角矩阵。这在进一步简化\(\vb{D}\)时变得清晰，

(8)\[\vb{D} = \sum_{p=0}^{P-1} \conjT{\vb{G}_p}\vb{G}_p = \sum_{p=0}^{P-1} \conjT{(\vb{F}\,\vb{W}_{\!p})}\, \vb{F}\,\vb{W}_{\!p} = \sum_{p=0}^{P-1} \conjT{\vb{W}_{\!p}}\vb{W}_{\!p} =: \sum_{p=0}^{P-1} \vb{D}_p\]

由于\(\vb{F}\)是酉矩阵。此外，

(9)\[\begin{split}D_p[r,s] &= \sum_{m=0}^{M-1} \conj{W_p^T[r,m]}\,W_p[m,s] = \sum_{m=0}^{M-1} \left(\conj{w[m]}\, \delta_{m+ph,r}\right) \left(w[m]\, \delta_{m+ph,s}\right)\\ &= \sum_{m=0}^{M-1} \big|w[m]\big|^2\, \delta_{r,s}\, \delta_{r,m+ph}\ .\end{split}\]

表明\(\vb{D}_p\)是一个具有非负实数条目的对角矩阵。因此，对\(\vb{D}_p\)求和保持这一性质。这允许进一步简化方程[(7)](#equation-eq-stft-moorepenrose)，即

(10)\[\begin{split}\vb{x} &= \vb{D}^{-1} \conjT{\vb{G}}\vb{s} = \sum_{p=0}^{P-1} \vb{D}^{-1}\conjT{\vb{W}_{\!p}}\, \conjT{\vb{F}}\vb{s}_p = \sum_{p=0}^{P-1} (\conj{\vb{W}_{\!p}\vb{D}^{-1}})^T\, \conjT{\vb{F}}\vb{s}_p\\ &=: \sum_{p=0}^{P-1}\conjT{\vb{U}_p}\,\conjT{\vb{F}}\vb{s}_p\ .\end{split}\]

利用方程[(5)](#equation-eq-stft-winmatrix1)，[(8)](#equation-eq-stft-diagm2)，[(9)](#equation-eq-stft-diagm3)，\(\vb{U}_p=\vb{W}_{\!p}\vb{D}^{-1}\)可以表达为

(11)\[\begin{split}U_p[m, k] &= W[m,k]\, D^{-1}[k,k] = \left(w[m] \delta_{m+ph,k}\right) \inv{\sum_{\eta=0}^{P-1} \vb{D}_\eta[k,k]} \delta_{m+ph,k}\\ &= w[m] \inv{\sum_{\eta=0}^{P-1}\sum_{\mu=0}^{M-1} \big|w[\mu]\big|^2\,\delta_{m+ph, \mu+\eta h}} \delta_{m+ph,k}\\ &= w[m] \inv{\sum_{\eta=0}^{P-1} \big|w[m+(p-\eta)h]\big|^2} \delta_{m+ph,k} \ .\end{split}\]

这表明\(\vb{U}_p\)在方程[(5)](#equation-eq-stft-winmatrix1)中与\(\vb{W}_p\)具有相同的结构，即只在\(ph\)次副对角线上有非零条目。逆中的求和项可以解释为将\(w[\mu]^2\)滑动到\(w[m]\)（带有反演），因此只有与\(w[m]\)重叠的分量才会起作用。因此，所有远离边界的\(U_p[m, k]\)都是相同的窗口。为了避免边界效应，\(x[k]\)用零填充，扩大\(\vb{U}\)，使所有接触到\(x[k]\)的切片都包含相同的双窗口。

\[w_d[m] = w[m] \inv{\sum_{\eta\in\IZ} \big|w[m + \eta\, h]\big|^2}\ .\]

由于 \(w[m] = 0\) 对 \(m \not\in\{0, \ldots, M-1\}\) 成立，因此只需要对满足 \(|\eta| < M/h\) 的索引 \(\eta\) 进行求和。插入方程 [(6)](#equation-eq-stft-slice-p) 到方程 [(10)](#equation-eq-stft-istftm)，可以证明名为双窗口的名称，

\[\vb{x} = \sum_{p=0}^{P-1} \conjT{\vb{U}_p}\,\conjT{\vb{F}}\, \vb{F}\,\vb{W}_{\!p}\,\vb{x} = \left(\sum_{p=0}^{P-1} \conjT{\vb{U}_p}\,\vb{W}_{\!p}\right)\vb{x}\ ,\]

表明 \(\vb{U}_p\) 和 \(\vb{W}_{\!p}\) 是可互换的。因此，\(w_d[m]\) 也是具有双窗口 \(w[m]\) 的有效窗口。注意 \(w_d[m]\) 不是唯一的双窗口，因为通常 \(\vb{s}\) 的条目比 \(\vb{x}\) 多。可以证明，\(w_d[m]\) 具有最小能量（或 \(L_2\) 范数）[[4](#id14)]，这就是被称为“规范双窗口”的原因。### 与旧版本实现的比较

函数 [`stft`](../reference/generated/scipy.signal.stft.html#scipy.signal.stft "scipy.signal.stft")，[`istft`](../reference/generated/scipy.signal.istft.html#scipy.signal.istft "scipy.signal.istft") 和 [`spectrogram`](../reference/generated/scipy.signal.spectrogram.html#scipy.signal.spectrogram "scipy.signal.spectrogram") 的实现早于 [`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT")。本节讨论了旧的“遗留”版本和新的 [`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT") 实现之间的关键区别。重写的主要动机是认识到集成 [双窗口](#tutorial-stft-dual-win) 不能在不破坏兼容性的情况下以合理的方式进行。这为重新思考代码结构和参数化提供了机会，从而使一些隐含的行为更加显式。

以下示例比较了具有负斜率的复值啁啾信号的两个 STFTs:

```py
>>> import matplotlib.pyplot as plt
>>> import numpy as np
>>> from scipy.fft import fftshift
>>> from scipy.signal import stft, istft, spectrogram, ShortTimeFFT
...
>>> fs, N = 200, 1001  # 200 Hz sampling rate for 5 s signal
>>> t_z = np.arange(N) / fs  # time indexes for signal
>>> z = np.exp(2j*np.pi*70 * (t_z - 0.2*t_z**2))  # complex-valued chirp
...
>>> nperseg, noverlap = 50, 40
>>> win = ('gaussian', 1e-2 * fs)  # Gaussian with 0.01 s standard dev.
...
>>> # Legacy STFT:
>>> f0_u, t0, Sz0_u = stft(z, fs, win, nperseg, noverlap,
...                        return_onesided=False, scaling='spectrum')
>>> f0, Sz0 = fftshift(f0_u), fftshift(Sz0_u, axes=0)
...
>>> # New STFT:
>>> SFT = ShortTimeFFT.from_window(win, fs, nperseg, noverlap,
...                                fft_mode='centered',
...                                scale_to='magnitude', phase_shift=None)
>>> Sz1 = SFT.stft(z)
...
>>> # Plot results:
>>> fig1, axx = plt.subplots(2, 1, sharex='all', sharey='all',
...                          figsize=(6., 5.))  # enlarge figure a bit
>>> t_lo, t_hi, f_lo, f_hi = SFT.extent(N, center_bins=True)
>>> t_str0 = r"Legacy stft() produces $%d\times%d$ points" % Sz0.T.shape
>>> t_str1 = r"ShortTimeFFT produces $%d\times%d$ points" % Sz1.T.shape
>>> _ = axx[0].set(title=t_str0, xlim=(t_lo, t_hi), ylim=(f_lo, f_hi))
>>> _ = axx[1].set(title=t_str1, xlabel="Time $t$ in seconds " +
...                rf"($\Delta t= %g\,$s)" % SFT.delta_t)
...
>>> # Calculate extent of plot with centered bins since imshow
... # does not interpolate by default:
... dt2 = (nperseg-noverlap) / fs  / 2 # equals SFT.delta_t / 2
>>> df2 = fs / nperseg / 2 # equals SFT.delta_f / 2
>>> extent0 = (-dt2, t0[-1] + dt2, f0[0] - df2, f0[-1] - df2)
>>> extent1 = SFT.extent(N, center_bins=True)
...
>>> kw = dict(origin='lower', aspect='auto', cmap='viridis')
>>> im1a = axx[0].imshow(abs(Sz0), extent=extent0, **kw)
>>> im1b = axx[1].imshow(abs(Sz1), extent=extent1, **kw)
>>> fig1.colorbar(im1b, ax=axx, label="Magnitude $|S_z(t, f)|$")
>>> _ = fig1.supylabel(rf"Frequency $f$ in Hertz ($\Delta f = %g\,$Hz)" %
...                    SFT.delta_f)
>>> plt.show() 
```

![../_images/signal-10.png](../Images/92e6559bfae39d3827d8e9f0d15bc682.png)

[`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT") 生成比旧版本多 3 个时间切片是主要的不同点。正如在 [滑动窗口](#tutorial-stft-sliding-win) 部分中所述，所有接触信号的切片都包含在新版本中。这具有将 STFT 切片和重新组装的优势，如 [`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT") 的代码示例所示。此外，使用所有接触切片使得 ISTFT 在某些位置为零的窗口情况下更加稳健。

注意具有相同时间戳的切片产生相等的结果（在数值精度上），即：

```py
>>> np.allclose(Sz0, Sz1[:, 2:-1])
True 
```

通常，这些额外的切片包含非零值。由于我们示例中的大重叠，它们非常小。例如：

```py
>>> abs(Sz1[:, 1]).min(), abs(Sz1[:, 1]).max()
(6.925060911593139e-07, 8.00271269218721e-07) 
```

ISTFT 可用于重建原始信号：

```py
>>> t0_r, z0_r = istft(Sz0_u, fs, win, nperseg, noverlap,
...                    input_onesided=False, scaling='spectrum')
>>> z1_r = SFT.istft(Sz1, k1=N)
...
>>> len(z0_r), len(z)
(1010, 1001)
>>> np.allclose(z0_r[:N], z)
True
>>> np.allclose(z1_r, z)
True 
```

请注意，旧实现返回的信号比原始信号更长。另一方面，新版 [`istft`](../reference/generated/scipy.signal.ShortTimeFFT.istft.html#scipy.signal.ShortTimeFFT.istft "scipy.signal.ShortTimeFFT.istft") 允许明确指定重建信号的起始索引 *k0* 和结束索引 *k1*。旧实现中的长度差异是因为信号长度不是切片的倍数。

在这个示例中，新版和旧版之间的进一步差异包括：

+   参数 `fft_mode='centered'` 确保在图中的双边 FFT 中，零频率垂直居中。在旧实现中，需要使用 [`fftshift`](../reference/generated/scipy.fft.fftshift.html#scipy.fft.fftshift "scipy.fft.fftshift")。`fft_mode='twosided'` 产生与旧版本相同的行为。

+   参数 `phase_shift=None` 确保两个版本的相位相同。[`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT") 的默认值 `0` 产生带有额外线性相位项的 STFT 切片。

谱图被定义为 STFT 的绝对平方 [[4]](#id14)。[`spectrogram`](../reference/generated/scipy.signal.ShortTimeFFT.spectrogram.html#scipy.signal.ShortTimeFFT.spectrogram "scipy.signal.ShortTimeFFT.spectrogram") 提供的是与该定义一致的内容，即：

```py
>>> np.allclose(SFT.spectrogram(z), abs(Sz1)**2)
True 
```

另一方面，旧版 [`spectrogram`](../reference/generated/scipy.signal.spectrogram.html#scipy.signal.spectrogram "scipy.signal.spectrogram") 提供了另一种带有不同信号边界处理的 STFT 实现。以下示例展示了如何使用 [`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT") 来获取与旧版 [`spectrogram`](../reference/generated/scipy.signal.spectrogram.html#scipy.signal.spectrogram "scipy.signal.spectrogram") 生成的相同 SFT：

```py
>>> # Legacy spectrogram (detrending for complex signals not useful):
>>> f2_u, t2, Sz2_u = spectrogram(z, fs, win, nperseg, noverlap,
...                               detrend=None, return_onesided=False,
...                               scaling='spectrum', mode='complex')
>>> f2, Sz2 = fftshift(f2_u), fftshift(Sz2_u, axes=0)
...
>>> # New STFT:
... SFT = ShortTimeFFT.from_window(win, fs, nperseg, noverlap,
...                                fft_mode='centered',
...                                scale_to='magnitude', phase_shift=None)
>>> Sz3 = SFT.stft(z, p0=0, p1=(N-noverlap)//SFT.hop, k_offset=nperseg//2)
>>> t3 = SFT.t(N, p0=0, p1=(N-noverlap)//SFT.hop, k_offset=nperseg//2)
...
>>> np.allclose(t2, t3)
True
>>> np.allclose(f2, SFT.f)
True
>>> np.allclose(Sz2, Sz3)
True 
```

与其他 STFT 不同的是，时间切片不是从 0 开始，而是从 `nperseg//2` 开始，即：

```py
>>> t2
array([0.125, 0.175, 0.225, 0.275, 0.325, 0.375, 0.425, 0.475, 0.525,
 ...
 4.625, 4.675, 4.725, 4.775, 4.825, 4.875]) 
```

此外，只返回不突出到右侧的切片，将最后一个切片居中于 4.875 秒，使其比默认的 [`stft`](../reference/generated/scipy.signal.ShortTimeFFT.stft.html#scipy.signal.ShortTimeFFT.stft "scipy.signal.ShortTimeFFT.stft") 参数化更短。

使用 `mode` 参数，传统 [`频谱图`](../reference/generated/scipy.signal.spectrogram.html#scipy.signal.spectrogram "scipy.signal.spectrogram") 还可以返回 ‘角度’、‘相位’、‘PSD’ 或 ‘幅度’。传统 [`频谱图`](../reference/generated/scipy.signal.spectrogram.html#scipy.signal.spectrogram "scipy.signal.spectrogram") 的 [`缩放`](../reference/generated/scipy.signal.ShortTimeFFT.scaling.html#scipy.signal.ShortTimeFFT.scaling "scipy.signal.ShortTimeFFT.scaling") 行为并不简单，因为它取决于参数 `mode`、`scaling` 和 `return_onesided`。在 [`短时傅里叶变换`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT") 中，并没有所有组合的直接对应关系，因为它仅提供窗口的 ‘幅度’、‘PSD’ 或根本没有 [`缩放`](../reference/generated/scipy.signal.ShortTimeFFT.scaling.html#scipy.signal.ShortTimeFFT.scaling "scipy.signal.ShortTimeFFT.scaling")。以下表格展示了这些对应关系：

| 传统 [`频谱图`](../reference/generated/scipy.signal.spectrogram.html#scipy.signal.spectrogram "scipy.signal.spectrogram") |  | [`短时傅里叶变换`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT") |
| --- | --- | --- |
| 模式 | 缩放 | return_onesided |  | [`fft模式`](../reference/generated/scipy.signal.ShortTimeFFT.fft_mode.html#scipy.signal.ShortTimeFFT.fft_mode "scipy.signal.ShortTimeFFT.fft_mode") | [`缩放`](../reference/generated/scipy.signal.ShortTimeFFT.scaling.html#scipy.signal.ShortTimeFFT.scaling "scipy.signal.ShortTimeFFT.scaling") |
| --- | --- | --- | --- | --- | --- |
| PSD | 密度 | 真实 |  | 单边2X | PSD |
| PSD | 密度 | 错误 |  | 双边 | PSD |
| 幅度 | 谱 | 真实 |  | 单边 | 幅度 |
| 幅度 | 谱 | 错误 |  | 双边 | 幅度 |
| 复数 | 谱 | 真实 |  | 单边 | 幅度 |
| 复数 | 谱 | 错误 |  | 双边 | 幅度 |
| PSD | 谱 | 真实 |  | — | — |
| PSD | 谱 | 错误 |  | — | — |
| 复数 | 密度 | 真实 |  | — | — |
| 复数 | 密度 | 错误 |  | — | — |
| 幅度 | 密度 | 真实 |  | — | — |
| 幅度 | 密度 | 错误 |  | — | — |
| — | — | — |  | `*` | `None` |

当在复值输入信号上使用`onesided`输出时，旧的[`spectrogram`](../reference/generated/scipy.signal.spectrogram.html#scipy.signal.spectrogram "scipy.signal.spectrogram")切换到`two-sided`模式。[`ShortTimeFFT`](../reference/generated/scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT")引发了一个[`TypeError`](https://docs.python.org/3/library/exceptions.html#TypeError "（在Python v3.12中）")，因为所使用的[`rfft`](../reference/generated/scipy.fft.rfft.html#scipy.fft.rfft "scipy.fft.rfft")函数只接受实值输入。这个[评论](https://github.com/scipy/scipy/issues/14903#issuecomment-1100249704)讨论了旧的[`spectrogram`](../reference/generated/scipy.signal.spectrogram.html#scipy.signal.spectrogram "scipy.signal.spectrogram")参数在单个余弦输入时的变化。

## 去趋势

SciPy提供了函数[`detrend`](../reference/generated/scipy.signal.detrend.html#scipy.signal.detrend "scipy.signal.detrend")，用于去除数据系列中的常数或线性趋势，以查看更高阶效果。

下面的示例去除了二阶多项式时间序列的常数和线性趋势，并绘制了剩余的信号分量。

```py
>>> import numpy as np
>>> import scipy.signal as signal
>>> import matplotlib.pyplot as plt 
```

```py
>>> t = np.linspace(-10, 10, 20)
>>> y = 1 + t + 0.01*t**2
>>> yconst = signal.detrend(y, type='constant')
>>> ylin = signal.detrend(y, type='linear') 
```

```py
>>> plt.plot(t, y, '-rx')
>>> plt.plot(t, yconst, '-bo')
>>> plt.plot(t, ylin, '-k+')
>>> plt.grid()
>>> plt.legend(['signal', 'const. detrend', 'linear detrend'])
>>> plt.show() 
```

![“此代码生成一个没有单位的X-Y图。红色轨迹对应于原始信号曲线，从左下到右上。蓝色轨迹具有常数去趋势，并位于红色轨迹下方，Y轴偏移为零。最后的黑色轨迹具有线性去趋势，并且从左到右几乎平坦，突出显示原始信号的曲线。这最后的轨迹具有平均斜率为零，并且看起来非常不同。”](../Images/490b1d459a50a325dd605fac2835b18a.png)

参考资料

一些进一步阅读和相关软件：
