- en: Scalar and Vector Field Functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/vector/fields.html](https://docs.sympy.org/latest/modules/vector/fields.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Implementation in sympy.vector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scalar and vector fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [`sympy.vector`](index.html#module-sympy.vector "sympy.vector"), every `CoordSys3D`
    instance is assigned basis vectors corresponding to the \(X\), \(Y\) and \(Z\)
    axes. These can be accessed using the properties named `i`, `j` and `k` respectively.
    Hence, to define a vector \(\mathbf{v}\) of the form \(3\mathbf{\hat{i}} + 4\mathbf{\hat{j}}
    + 5\mathbf{\hat{k}}\) with respect to a given frame \(\mathbf{R}\), you would
    do
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Vector math and basic calculus operations with respect to vectors have already
    been elaborated upon in the earlier section of this module’s documentation.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, base scalars (or coordinate variables) are implemented in
    a special class called `BaseScalar`, and are assigned to every coordinate system,
    one for each axis from \(X\), \(Y\) and \(Z\). These coordinate variables are
    used to form the expressions of vector or scalar fields in 3D space. For a system
    `R`, the \(X\), \(Y\) and \(Z\) `BaseScalars` instances can be accessed using
    the `R.x`, `R.y` and `R.z` expressions respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, to generate the expression for the aforementioned electric potential
    field \(2{x}^{2}y\), you would have to do
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It is to be noted that `BaseScalar` instances can be used just like any other
    SymPy `Symbol`, except that they store the information about the coordinate system
    and axis they correspond to.
  prefs: []
  type: TYPE_NORMAL
- en: Scalar fields can be treated just as any other SymPy expression, for any math/calculus
    functionality. Hence, to differentiate the above electric potential with respect
    to \(x\) (i.e. `R.x`), you would use the `diff` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting that having a `BaseScalar` in the expression implies that
    a ‘field’ changes with position, in 3D space. Technically speaking, a simple `Expr`
    with no `BaseScalar` s is still a field, though constant.
  prefs: []
  type: TYPE_NORMAL
- en: Like scalar fields, vector fields that vary with position can also be constructed
    using `BaseScalar` s in the measure-number expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Del operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Del, or ‘Nabla’ operator - written as \(\mathbf{\nabla}\) is commonly known
    as the vector differential operator. Depending on its usage in a mathematical
    expression, it may denote the gradient of a scalar field, the divergence of a
    vector field, or the curl of a vector field.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, \(\mathbf{\nabla}\) is not technically an ‘operator’, but a convenient
    mathematical notation to denote any one of the aforementioned field operations.
  prefs: []
  type: TYPE_NORMAL
- en: In [`sympy.vector`](index.html#module-sympy.vector "sympy.vector"), \(\mathbf{\nabla}\)
    has been implemented as the `Del()` class. The instance of this class is independent
    of coordinate system. Hence, the \(\mathbf{\nabla}\) operator would be accessible
    as `Del()`.
  prefs: []
  type: TYPE_NORMAL
- en: Given below is an example of usage of the `Del()` class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The above expression can be evaluated using the SymPy `doit()` routine.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Usage of the \(\mathbf{\nabla}\) notation in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector") has been described in greater detail in the subsequent subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Field operators and related functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we describe some basic field-related functionality implemented in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector").
  prefs: []
  type: TYPE_NORMAL
- en: Curl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A curl is a mathematical operator that describes an infinitesimal rotation of
    a vector in 3D space. The direction is determined by the right-hand rule (along
    the axis of rotation), and the magnitude is given by the magnitude of rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the 3D Cartesian system, the curl of a 3D vector \(\mathbf{F}\) , denoted
    by \(\nabla \times \mathbf{F}\) is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \(\nabla \times \mathbf{F} = \left(\frac{\partial F_z}{\partial y} - \frac{\partial
    F_y}{\partial z}\right) \mathbf{\hat{i}} + \left(\frac{\partial F_x}{\partial
    z} - \frac{\partial F_z}{\partial x}\right) \mathbf{\hat{j}} + \left(\frac{\partial
    F_y}{\partial x} - \frac{\partial F_x}{\partial y}\right) \mathbf{\hat{k}}\)
  prefs: []
  type: TYPE_NORMAL
- en: where \(F_x\) denotes the \(X\) component of vector \(\mathbf{F}\).
  prefs: []
  type: TYPE_NORMAL
- en: Computing the curl of a vector field in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector") can be accomplished in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: One, by using the `Del()` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Or by using the dedicated function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Divergence
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Divergence is a vector operator that measures the magnitude of a vector field’s
    source or sink at a given point, in terms of a signed scalar.
  prefs: []
  type: TYPE_NORMAL
- en: The divergence operator always returns a scalar after operating on a vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the 3D Cartesian system, the divergence of a 3D vector \(\mathbf{F}\), denoted
    by \(\nabla\cdot\mathbf{F}\) is given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \(\nabla\cdot\mathbf{F} =\frac{\partial U}{\partial x} +\frac{\partial V}{\partial
    y} +\frac{\partial W}{\partial z }\)
  prefs: []
  type: TYPE_NORMAL
- en: where \(U\), \(V\) and \(W\) denote the \(X\), \(Y\) and \(Z\) components of
    \(\mathbf{F}\) respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Computing the divergence of a vector field in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector") can be accomplished in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: One, by using the `Del()` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Or by using the dedicated function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Gradient
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider a scalar field \(f(x, y, z)\) in 3D space. The gradient of this field
    is defined as the vector of the 3 partial derivatives of \(f\) with respect to
    \(x\), \(y\) and \(z\) in the \(X\), \(Y\) and \(Z\) axes respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the 3D Cartesian system, the divergence of a scalar field \(f\), denoted
    by \(\nabla f\) is given by -
  prefs: []
  type: TYPE_NORMAL
- en: \(\nabla f = \frac{\partial f}{\partial x} \mathbf{\hat{i}} + \frac{\partial
    f}{\partial y} \mathbf{\hat{j}} + \frac{\partial f}{\partial z} \mathbf{\hat{k}}\)
  prefs: []
  type: TYPE_NORMAL
- en: Computing the divergence of a vector field in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector") can be accomplished in two ways.
  prefs: []
  type: TYPE_NORMAL
- en: One, by using the `Del()` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Or by using the dedicated function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Directional Derivative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apart from the above three common applications of \(\mathbf{\nabla}\), it is
    also possible to compute the directional derivative of a field wrt a `Vector`
    in [`sympy.vector`](index.html#module-sympy.vector "sympy.vector").
  prefs: []
  type: TYPE_NORMAL
- en: 'By definition, the directional derivative of a field \(\mathbf{F}\) along a
    vector \(v\) at point \(x\) represents the instantaneous rate of change of \(\mathbf{F}\)
    moving through \(x\) with the velocity \(v\). It is represented mathematically
    as: \((\vec v \cdot \nabla) \, \mathbf{F}(x)\).'
  prefs: []
  type: TYPE_NORMAL
- en: Directional derivatives of vector and scalar fields can be computed in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector") using the `Del()` class
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Or by using the dedicated function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Field operator in orthogonal curvilinear coordinate system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`vector` package supports calculation in different kind of orthogonal curvilinear
    coordinate system. To do that, scaling factor (also known as Lame coefficients)
    are used to express `curl`, `divergence` or `gradient` in desired type of coordinate
    system.'
  prefs: []
  type: TYPE_NORMAL
- en: For example if we want to calculate `gradient` in cylindrical coordinate system
    all we need to do is to create proper coordinate system
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Conservative and Solenoidal fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In vector calculus, a conservative field is a field that is the gradient of
    some scalar field. Conservative fields have the property that their line integral
    over any path depends only on the end-points, and is independent of the path travelled.
    A conservative vector field is also said to be ‘irrotational’, since the curl
    of a conservative field is always zero.
  prefs: []
  type: TYPE_NORMAL
- en: In physics, conservative fields represent forces in physical systems where energy
    is conserved.
  prefs: []
  type: TYPE_NORMAL
- en: To check if a vector field is conservative in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector"), the `is_conservative` function can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A solenoidal field, on the other hand, is a vector field whose divergence is
    zero at all points in space.
  prefs: []
  type: TYPE_NORMAL
- en: To check if a vector field is solenoidal in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector"), the `is_solenoidal` function can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Scalar potential functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have previously mentioned that every conservative field can be defined as
    the gradient of some scalar field. This scalar field is also called the ‘scalar
    potential field’ corresponding to the aforementioned conservative field.
  prefs: []
  type: TYPE_NORMAL
- en: The `scalar_potential` function in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector") calculates the scalar potential field corresponding to a given
    conservative vector field in 3D space - minus the extra constant of integration,
    of course.
  prefs: []
  type: TYPE_NORMAL
- en: Example of usage -
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Providing a non-conservative vector field as an argument to `scalar_potential`
    raises a `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: The scalar potential difference, or simply ‘potential difference’, corresponding
    to a conservative vector field can be defined as the difference between the values
    of its scalar potential function at two points in space. This is useful in calculating
    a line integral with respect to a conservative function, since it depends only
    on the endpoints of the path.
  prefs: []
  type: TYPE_NORMAL
- en: This computation is performed as follows in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If provided with a scalar expression instead of a vector field, `scalar_potential_difference`
    returns the difference between the values of that scalar field at the two given
    points in space.
  prefs: []
  type: TYPE_NORMAL
