- en: NumPy 1.15.0 Release Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/release/1.15.0-notes.html](https://numpy.org/doc/1.26/release/1.15.0-notes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: NumPy 1.15.0 is a release with an unusual number of cleanups, many deprecations
    of old functions, and improvements to many existing functions. Please read the
    detailed descriptions below to see if you are affected.
  prefs: []
  type: TYPE_NORMAL
- en: For testing, we have switched to pytest as a replacement for the no longer maintained
    nose framework. The old nose based interface remains for downstream projects who
    may still be using it.
  prefs: []
  type: TYPE_NORMAL
- en: The Python versions supported by this release are 2.7, 3.4-3.7\. The wheels
    are linked with OpenBLAS v0.3.0, which should fix some of the linalg problems
    reported for NumPy 1.14.
  prefs: []
  type: TYPE_NORMAL
- en: Highlights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy has switched to pytest for testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new [`numpy.printoptions`](../reference/generated/numpy.printoptions.html#numpy.printoptions
    "numpy.printoptions") context manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many improvements to the histogram functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for unicode field names in python 2.7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved support for PyPy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixes and improvements to [`numpy.einsum`](../reference/generated/numpy.einsum.html#numpy.einsum
    "numpy.einsum").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`numpy.gcd`](../reference/generated/numpy.gcd.html#numpy.gcd "numpy.gcd")
    and [`numpy.lcm`](../reference/generated/numpy.lcm.html#numpy.lcm "numpy.lcm"),
    to compute the greatest common divisor and least common multiple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`numpy.ma.stack`](../reference/generated/numpy.ma.stack.html#numpy.ma.stack
    "numpy.ma.stack"), the [`numpy.stack`](../reference/generated/numpy.stack.html#numpy.stack
    "numpy.stack") array-joining function generalized to masked arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`numpy.quantile`](../reference/generated/numpy.quantile.html#numpy.quantile
    "numpy.quantile") function, an interface to `percentile` without factors of 100'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`numpy.nanquantile`](../reference/generated/numpy.nanquantile.html#numpy.nanquantile
    "numpy.nanquantile") function, an interface to `nanpercentile` without factors
    of 100'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`numpy.printoptions`](../reference/generated/numpy.printoptions.html#numpy.printoptions
    "numpy.printoptions"), a context manager that sets print options temporarily for
    the scope of the `with` block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`numpy.histogram_bin_edges`](../reference/generated/numpy.histogram_bin_edges.html#numpy.histogram_bin_edges
    "numpy.histogram_bin_edges"), a function to get the edges of the bins used by
    a histogram without needing to calculate the histogram.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C functions *npy_get_floatstatus_barrier* and *npy_clear_floatstatus_barrier*
    have been added to deal with compiler optimization changing the order of operations.
    See below for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aliases of builtin [`pickle`](https://docs.python.org/3/library/pickle.html#module-pickle
    "(in Python v3.11)") functions are deprecated, in favor of their unaliased `pickle.<func>`
    names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.loads*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.core.numeric.load*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.core.numeric.loads*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.ma.loads*, *numpy.ma.dumps*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.ma.load*, *numpy.ma.dump* - these functions already failed on python
    3 when called with a string.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Multidimensional indexing with anything but a tuple is deprecated. This means
    that the index list in `ind = [slice(None), 0]; arr[ind]` should be changed to
    a tuple, e.g., `ind = [slice(None), 0]; arr[tuple(ind)]` or `arr[(slice(None),
    0)]`. That change is necessary to avoid ambiguity in expressions such as `arr[[[0,
    1], [0, 1]]]`, currently interpreted as `arr[array([0, 1]), array([0, 1])]`, that
    will be interpreted as `arr[array([[0, 1], [0, 1]])]` in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports from the following sub-modules are deprecated, they will be removed
    at some future date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.testing.utils*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.testing.decorators*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.testing.nosetester*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.testing.noseclasses*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.core.umath_tests*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving a generator to [`numpy.sum`](../reference/generated/numpy.sum.html#numpy.sum
    "numpy.sum") is now deprecated. This was undocumented behavior, but worked. Previously,
    it would calculate the sum of the generator expression. In the future, it might
    return a different result. Use `np.sum(np.from_iter(generator))` or the built-in
    Python `sum` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users of the C-API should call `PyArrayResolveWriteBackIfCopy` or `PyArray_DiscardWritebackIfCopy`
    on any array with the `WRITEBACKIFCOPY` flag set, before deallocating the array.
    A deprecation warning will be emitted if those calls are not used when needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users of `nditer` should use the nditer object as a context manager anytime
    one of the iterator operands is writeable, so that numpy can manage writeback
    semantics, or should call `it.close()`. A *RuntimeWarning* may be emitted otherwise
    in these cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `normed` argument of `np.histogram`, deprecated long ago in 1.6.0, now emits
    a `DeprecationWarning`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy 1.16 will drop support for Python 3.4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy 1.17 will drop support for Python 2.7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compiled testing modules renamed and made private
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following compiled modules have been renamed and made private:'
  prefs: []
  type: TYPE_NORMAL
- en: '`umath_tests` -> `_umath_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_rational` -> `_rational_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiarray_tests` -> `_multiarray_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct_ufunc_test` -> `_struct_ufunc_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operand_flag_tests` -> `_operand_flag_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `umath_tests` module is still available for backwards compatibility, but
    will be removed in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The `NpzFile` returned by `np.savez` is now a `collections.abc.Mapping`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means it behaves like a readonly dictionary, and has a new `.values()`
    method and `len()` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For python 3, this means that `.iteritems()`, `.iterkeys()` have been deprecated,
    and `.keys()` and `.items()` now return views and not lists. This is consistent
    with how the builtin `dict` type changed between python 2 and python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Under certain conditions, `nditer` must be used in a context manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using an [`numpy.nditer`](../reference/generated/numpy.nditer.html#numpy.nditer
    "numpy.nditer") with the `"writeonly"` or `"readwrite"` flags, there are some
    circumstances where nditer doesn’t actually give you a view of the writable array.
    Instead, it gives you a copy, and if you make changes to the copy, nditer later
    writes those changes back into your actual array. Currently, this writeback occurs
    when the array objects are garbage collected, which makes this API error-prone
    on CPython and entirely broken on PyPy. Therefore, `nditer` should now be used
    as a context manager whenever it is used with writeable arrays, e.g., `with np.nditer(...)
    as it: ...`. You may also explicitly call `it.close()` for cases where a context
    manager is unusable, for instance in generator expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Numpy has switched to using pytest instead of nose for testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last nose release was 1.3.7 in June, 2015, and development of that tool
    has ended, consequently NumPy has now switched to using pytest. The old decorators
    and nose tools that were previously used by some downstream projects remain available,
    but will not be maintained. The standard testing utilities, `assert_almost_equal`
    and such, are not be affected by this change except for the nose specific functions
    `import_nose` and `raises`. Those functions are not used in numpy, but are kept
    for downstream compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Numpy no longer monkey-patches `ctypes` with `__array_interface__`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously numpy added `__array_interface__` attributes to all the integer types
    from `ctypes`.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.ma.notmasked_contiguous` and `np.ma.flatnotmasked_contiguous` always return
    lists'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the documented behavior, but previously the result could be any of slice,
    None, or list.
  prefs: []
  type: TYPE_NORMAL
- en: All downstream users seem to check for the `None` result from `flatnotmasked_contiguous`
    and replace it with `[]`. Those callers will continue to work as before.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.squeeze` restores old behavior of objects that cannot handle an `axis`
    argument'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to version `1.7.0`, [`numpy.squeeze`](../reference/generated/numpy.squeeze.html#numpy.squeeze
    "numpy.squeeze") did not have an `axis` argument and all empty axes were removed
    by default. The incorporation of an `axis` argument made it possible to selectively
    squeeze single or multiple empty axes, but the old API expectation was not respected
    because axes could still be selectively removed (silent success) from an object
    expecting all empty axes to be removed. That silent, selective removal of empty
    axes for objects expecting the old behavior has been fixed and the old behavior
    restored.
  prefs: []
  type: TYPE_NORMAL
- en: unstructured void array’s `.item` method now returns a bytes object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`.item` now returns a `bytes` object instead of a buffer or byte array. This
    may affect code which assumed the return value was mutable, which is no longer
    the case.'
  prefs: []
  type: TYPE_NORMAL
- en: '`copy.copy` and `copy.deepcopy` no longer turn `masked` into an array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `np.ma.masked` is a readonly scalar, copying should be a no-op. These
    functions now behave consistently with `np.copy()`.
  prefs: []
  type: TYPE_NORMAL
- en: Multifield Indexing of Structured Arrays will still return a copy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The change that multi-field indexing of structured arrays returns a view instead
    of a copy is pushed back to 1.16\. A new method `numpy.lib.recfunctions.repack_fields`
    has been introduced to help mitigate the effects of this change, which can be
    used to write code compatible with both numpy 1.15 and 1.16\. For more information
    on how to update code to account for this future change see the “accessing multiple
    fields” section of the [user guide](https://docs.scipy.org/doc/numpy/user/basics.rec.html).
  prefs: []
  type: TYPE_NORMAL
- en: C API changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New functions `npy_get_floatstatus_barrier` and `npy_clear_floatstatus_barrier`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions `npy_get_floatstatus_barrier` and `npy_clear_floatstatus_barrier`
    have been added and should be used in place of the `npy_get_floatstatus``and ``npy_clear_status`
    functions. Optimizing compilers like GCC 8.1 and Clang were rearranging the order
    of operations when the previous functions were used in the ufunc SIMD functions,
    resulting in the floatstatus flags being checked before the operation whose status
    we wanted to check was run. See [#10339](https://github.com/numpy/numpy/issues/10370).
  prefs: []
  type: TYPE_NORMAL
- en: Changes to `PyArray_GetDTypeTransferFunction`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PyArray_GetDTypeTransferFunction` now defaults to using user-defined `copyswapn`
    / `copyswap` for user-defined dtypes. If this causes a significant performance
    hit, consider implementing `copyswapn` to reflect the implementation of `PyArray_GetStridedCopyFn`.
    See [#10898](https://github.com/numpy/numpy/pull/10898).'
  prefs: []
  type: TYPE_NORMAL
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`np.gcd` and `np.lcm` ufuncs added for integer and objects types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These compute the greatest common divisor, and lowest common multiple, respectively.
    These work on all the numpy integer types, as well as the builtin arbitrary-precision
    `Decimal` and `long` types.
  prefs: []
  type: TYPE_NORMAL
- en: Support for cross-platform builds for iOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The build system has been modified to add support for the `_PYTHON_HOST_PLATFORM`
    environment variable, used by `distutils` when compiling on one platform for another
    platform. This makes it possible to compile NumPy for iOS targets.
  prefs: []
  type: TYPE_NORMAL
- en: This only enables you to compile NumPy for one specific platform at a time.
    Creating a full iOS-compatible NumPy package requires building for the 5 architectures
    supported by iOS (i386, x86_64, armv7, armv7s and arm64), and combining these
    5 compiled builds products into a single “fat” binary.
  prefs: []
  type: TYPE_NORMAL
- en: '`return_indices` keyword added for `np.intersect1d`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New keyword `return_indices` returns the indices of the two input arrays that
    correspond to the common elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.quantile` and `np.nanquantile`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like `np.percentile` and `np.nanpercentile`, but takes quantiles in [0, 1] rather
    than percentiles in [0, 100]. `np.percentile` is now a thin wrapper around `np.quantile`
    with the extra step of dividing by 100.
  prefs: []
  type: TYPE_NORMAL
- en: Build system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Added experimental support for the 64-bit RISC-V architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`np.einsum` updates'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Syncs einsum path optimization tech between [`numpy`](../reference/index.html#module-numpy
    "numpy") and *opt_einsum*. In particular, the *greedy* path has received many
    enhancements by @jcmgray. A full list of issues fixed are:'
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary memory can be passed into the *greedy* path. Fixes gh-11210.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The greedy path has been updated to contain more dynamic programming ideas preventing
    a large number of duplicate (and expensive) calls that figure out the actual pair
    contraction that takes place. Now takes a few seconds on several hundred input
    tensors. Useful for matrix product state theories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reworks the broadcasting dot error catching found in gh-11218 gh-10352 to be
    a bit earlier in the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhances the *can_dot* functionality that previous missed an edge case (part
    of gh-11308).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.ufunc.reduce` and related functions now accept an initial value'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.ufunc.reduce`, `np.sum`, `np.prod`, `np.min` and `np.max` all now accept
    an `initial` keyword argument that specifies the value to start the reduction
    with.'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.flip` can operate over multiple axes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.flip` now accepts None, or tuples of int, in its `axis` argument. If axis
    is None, it will flip over all the axes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` and `histogramdd` functions have moved to `np.lib.histograms`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These were originally found in `np.lib.function_base`. They are still available
    under their un-scoped `np.histogram(dd)` names, and to maintain compatibility,
    aliased at `np.lib.function_base.histogram(dd)`.
  prefs: []
  type: TYPE_NORMAL
- en: Code that does `from np.lib.function_base import *` will need to be updated
    with the new location, and should consider not using `import *` in future.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` will accept NaN values when explicit bins are given'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously it would fail when trying to compute a finite range for the data.
    Since the range is ignored anyway when the bins are given explicitly, this error
    was needless.
  prefs: []
  type: TYPE_NORMAL
- en: Note that calling `histogram` on NaN values continues to raise the `RuntimeWarning`
    s typical of working with nan values, which can be silenced as usual with `errstate`.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` works on datetime types, when explicit bin edges are given'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dates, times, and timedeltas can now be histogrammed. The bin edges must be
    passed explicitly, and are not yet computed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` “auto” estimator handles limited variance better'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No longer does an IQR of 0 result in `n_bins=1`, rather the number of bins chosen
    is related to the data size in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: The edges returned by *histogram`* and `histogramdd` now match the data float
    type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When passed `np.float16`, `np.float32`, or `np.longdouble` data, the returned
    edges are now of the same dtype. Previously, `histogram` would only return the
    same type if explicit bins were given, and `histogram` would produce `float64`
    bins no matter what the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogramdd` allows explicit ranges to be given in a subset of axes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `range` argument of [`numpy.histogramdd`](../reference/generated/numpy.histogramdd.html#numpy.histogramdd
    "numpy.histogramdd") can now contain `None` values to indicate that the range
    for the corresponding axis should be computed from the data. Previously, this
    could not be specified on a per-axis basis.
  prefs: []
  type: TYPE_NORMAL
- en: The normed arguments of `histogramdd` and `histogram2d` have been renamed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These arguments are now called `density`, which is consistent with `histogram`.
    The old argument continues to work, but the new name should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.r_` works with 0d arrays, and `np.ma.mr_` works with `np.ma.masked`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 0d arrays passed to the *r_* and *mr_* concatenation helpers are now treated
    as though they are arrays of length 1\. Previously, passing these was an error.
    As a result, [`numpy.ma.mr_`](../reference/generated/numpy.ma.mr_.html#numpy.ma.mr_
    "numpy.ma.mr_") now works correctly on the `masked` constant.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.ptp` accepts a `keepdims` argument, and extended axis tuples'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.ptp` (peak-to-peak) can now work over multiple axes, just like `np.max`
    and `np.min`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MaskedArray.astype` now is identical to `ndarray.astype`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means it takes all the same arguments, making more code written for ndarray
    work for masked array too.
  prefs: []
  type: TYPE_NORMAL
- en: Enable AVX2/AVX512 at compile time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Change to simd.inc.src to allow use of AVX2 or AVX512 at compile time. Previously
    compilation for avx2 (or 512) with -march=native would still use the SSE code
    for the simd functions even when the rest of the code got AVX2.
  prefs: []
  type: TYPE_NORMAL
- en: '`nan_to_num` always returns scalars when receiving scalar or 0d inputs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously an array was returned for integer scalar inputs, which is inconsistent
    with the behavior for float inputs, and that of ufuncs in general. For all types
    of scalar or 0d input, the result is now a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.flatnonzero` works on numpy-convertible types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.flatnonzero` now uses `np.ravel(a)` instead of `a.ravel()`, so it works
    for lists, tuples, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.interp` returns numpy scalars rather than builtin scalars'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `np.interp(0.5, [0, 1], [10, 20])` would return a `float`, but now
    it returns a `np.float64` object, which more closely matches the behavior of other
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the special case of `np.interp(object_array_0d, ...)` is no longer
    supported, as `np.interp(object_array_nd)` was never supported anyway.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this change, the `period` argument can now be used on 0d arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Allow dtype field names to be unicode in Python 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `np.dtype([(u'name', float)])` would raise a `TypeError` in Python
    2, as only bytestrings were allowed in field names. Now any unicode string field
    names will be encoded with the `ascii` codec, raising a `UnicodeEncodeError` upon
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: This change makes it easier to write Python 2/3 compatible code using `from
    __future__ import unicode_literals`, which previously would cause string literal
    field names to raise a TypeError in Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison ufuncs accept `dtype=object`, overriding the default `bool`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This allows object arrays of symbolic types, which override `==` and other operators
    to return expressions, to be compared elementwise with `np.equal(a, b, dtype=object)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`sort` functions accept `kind=''stable''`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up until now, to perform a stable sort on the data, the user must do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: because merge sort is the only stable sorting algorithm available in NumPy.
    However, having kind=’mergesort’ does not make it explicit that the user wants
    to perform a stable sort thus harming the readability.
  prefs: []
  type: TYPE_NORMAL
- en: This change allows the user to specify kind=’stable’ thus clarifying the intent.
  prefs: []
  type: TYPE_NORMAL
- en: Do not make temporary copies for in-place accumulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When ufuncs perform accumulation they no longer make temporary copies because
    of the overlap between input an output, that is, the next element accumulated
    is added before the accumulated result is stored in its place, hence the overlap
    is safe. Avoiding the copy results in faster execution.
  prefs: []
  type: TYPE_NORMAL
- en: '`linalg.matrix_power` can now handle stacks of matrices'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like other functions in `linalg`, `matrix_power` can now deal with arrays of
    dimension larger than 2, which are treated as stacks of matrices. As part of the
    change, to further improve consistency, the name of the first argument has been
    changed to `a` (from `M`), and the exceptions for non-square matrices have been
    changed to `LinAlgError` (from `ValueError`).
  prefs: []
  type: TYPE_NORMAL
- en: Increased performance in `random.permutation` for multidimensional arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`permutation` uses the fast path in `random.shuffle` for all input array dimensions.
    Previously the fast path was only used for 1-d arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Generalized ufuncs now accept `axes`, `axis` and `keepdims` arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One can control over which axes a generalized ufunc operates by passing in an
    `axes` argument, a list of tuples with indices of particular axes. For instance,
    for a signature of `(i,j),(j,k)->(i,k)` appropriate for matrix multiplication,
    the base elements are two-dimensional matrices and these are taken to be stored
    in the two last axes of each argument. The corresponding axes keyword would be
    `[(-2, -1), (-2, -1), (-2, -1)]`. If one wanted to use leading dimensions instead,
    one would pass in `[(0, 1), (0, 1), (0, 1)]`.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, for generalized ufuncs that operate on 1-dimensional arrays
    (vectors), a single integer is accepted instead of a single-element tuple, and
    for generalized ufuncs for which all outputs are scalars, the (empty) output tuples
    can be omitted. Hence, for a signature of `(i),(i)->()` appropriate for an inner
    product, one could pass in `axes=[0, 0]` to indicate that the vectors are stored
    in the first dimensions of the two inputs arguments.
  prefs: []
  type: TYPE_NORMAL
- en: As a short-cut for generalized ufuncs that are similar to reductions, i.e.,
    that act on a single, shared core dimension such as the inner product example
    above, one can pass an `axis` argument. This is equivalent to passing in `axes`
    with identical entries for all arguments with that core dimension (e.g., for the
    example above, `axes=[(axis,), (axis,)]`).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, like for reductions, for generalized ufuncs that have inputs that
    all have the same number of core dimensions and outputs with no core dimension,
    one can pass in `keepdims` to leave a dimension with size 1 in the outputs, thus
    allowing proper broadcasting against the original inputs. The location of the
    extra dimension can be controlled with `axes`. For instance, for the inner-product
    example, `keepdims=True, axes=[-2, -2, -2]` would act on the inner-product example,
    `keepdims=True, axis=-2` would act on the one-but-last dimension of the input
    arguments, and leave a size 1 dimension in that place in the output.
  prefs: []
  type: TYPE_NORMAL
- en: float128 values now print correctly on ppc systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously printing float128 values was buggy on ppc, since the special double-double
    floating-point-format on these systems was not accounted for. float128s now print
    with correct rounding and uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning to ppc users: You should upgrade glibc if it is version <=2.23, especially
    if using float128\. On ppc, glibc’s malloc in these version often misaligns allocated
    memory which can crash numpy when using float128 values.'
  prefs: []
  type: TYPE_NORMAL
- en: New `np.take_along_axis` and `np.put_along_axis` functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When used on multidimensional arrays, `argsort`, `argmin`, `argmax`, and `argpartition`
    return arrays that are difficult to use as indices. `take_along_axis` provides
    an easy way to use these indices to lookup values within an array, so that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`np.put_along_axis` acts as the dual operation for writing to these indices
    within an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Highlights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy has switched to pytest for testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new [`numpy.printoptions`](../reference/generated/numpy.printoptions.html#numpy.printoptions
    "numpy.printoptions") context manager.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many improvements to the histogram functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for unicode field names in python 2.7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved support for PyPy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixes and improvements to [`numpy.einsum`](../reference/generated/numpy.einsum.html#numpy.einsum
    "numpy.einsum").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`numpy.gcd`](../reference/generated/numpy.gcd.html#numpy.gcd "numpy.gcd")
    and [`numpy.lcm`](../reference/generated/numpy.lcm.html#numpy.lcm "numpy.lcm"),
    to compute the greatest common divisor and least common multiple.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`numpy.ma.stack`](../reference/generated/numpy.ma.stack.html#numpy.ma.stack
    "numpy.ma.stack"), the [`numpy.stack`](../reference/generated/numpy.stack.html#numpy.stack
    "numpy.stack") array-joining function generalized to masked arrays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`numpy.quantile`](../reference/generated/numpy.quantile.html#numpy.quantile
    "numpy.quantile") function, an interface to `percentile` without factors of 100'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`numpy.nanquantile`](../reference/generated/numpy.nanquantile.html#numpy.nanquantile
    "numpy.nanquantile") function, an interface to `nanpercentile` without factors
    of 100'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`numpy.printoptions`](../reference/generated/numpy.printoptions.html#numpy.printoptions
    "numpy.printoptions"), a context manager that sets print options temporarily for
    the scope of the `with` block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`numpy.histogram_bin_edges`](../reference/generated/numpy.histogram_bin_edges.html#numpy.histogram_bin_edges
    "numpy.histogram_bin_edges"), a function to get the edges of the bins used by
    a histogram without needing to calculate the histogram.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: C functions *npy_get_floatstatus_barrier* and *npy_clear_floatstatus_barrier*
    have been added to deal with compiler optimization changing the order of operations.
    See below for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Aliases of builtin [`pickle`](https://docs.python.org/3/library/pickle.html#module-pickle
    "(in Python v3.11)") functions are deprecated, in favor of their unaliased `pickle.<func>`
    names:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.loads*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.core.numeric.load*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.core.numeric.loads*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.ma.loads*, *numpy.ma.dumps*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.ma.load*, *numpy.ma.dump* - these functions already failed on python
    3 when called with a string.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Multidimensional indexing with anything but a tuple is deprecated. This means
    that the index list in `ind = [slice(None), 0]; arr[ind]` should be changed to
    a tuple, e.g., `ind = [slice(None), 0]; arr[tuple(ind)]` or `arr[(slice(None),
    0)]`. That change is necessary to avoid ambiguity in expressions such as `arr[[[0,
    1], [0, 1]]]`, currently interpreted as `arr[array([0, 1]), array([0, 1])]`, that
    will be interpreted as `arr[array([[0, 1], [0, 1]])]` in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imports from the following sub-modules are deprecated, they will be removed
    at some future date.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.testing.utils*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.testing.decorators*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.testing.nosetester*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.testing.noseclasses*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*numpy.core.umath_tests*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving a generator to [`numpy.sum`](../reference/generated/numpy.sum.html#numpy.sum
    "numpy.sum") is now deprecated. This was undocumented behavior, but worked. Previously,
    it would calculate the sum of the generator expression. In the future, it might
    return a different result. Use `np.sum(np.from_iter(generator))` or the built-in
    Python `sum` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users of the C-API should call `PyArrayResolveWriteBackIfCopy` or `PyArray_DiscardWritebackIfCopy`
    on any array with the `WRITEBACKIFCOPY` flag set, before deallocating the array.
    A deprecation warning will be emitted if those calls are not used when needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users of `nditer` should use the nditer object as a context manager anytime
    one of the iterator operands is writeable, so that numpy can manage writeback
    semantics, or should call `it.close()`. A *RuntimeWarning* may be emitted otherwise
    in these cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `normed` argument of `np.histogram`, deprecated long ago in 1.6.0, now emits
    a `DeprecationWarning`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Future Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: NumPy 1.16 will drop support for Python 3.4.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy 1.17 will drop support for Python 2.7.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compatibility notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compiled testing modules renamed and made private
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following compiled modules have been renamed and made private:'
  prefs: []
  type: TYPE_NORMAL
- en: '`umath_tests` -> `_umath_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_rational` -> `_rational_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiarray_tests` -> `_multiarray_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct_ufunc_test` -> `_struct_ufunc_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operand_flag_tests` -> `_operand_flag_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `umath_tests` module is still available for backwards compatibility, but
    will be removed in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The `NpzFile` returned by `np.savez` is now a `collections.abc.Mapping`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means it behaves like a readonly dictionary, and has a new `.values()`
    method and `len()` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For python 3, this means that `.iteritems()`, `.iterkeys()` have been deprecated,
    and `.keys()` and `.items()` now return views and not lists. This is consistent
    with how the builtin `dict` type changed between python 2 and python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Under certain conditions, `nditer` must be used in a context manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using an [`numpy.nditer`](../reference/generated/numpy.nditer.html#numpy.nditer
    "numpy.nditer") with the `"writeonly"` or `"readwrite"` flags, there are some
    circumstances where nditer doesn’t actually give you a view of the writable array.
    Instead, it gives you a copy, and if you make changes to the copy, nditer later
    writes those changes back into your actual array. Currently, this writeback occurs
    when the array objects are garbage collected, which makes this API error-prone
    on CPython and entirely broken on PyPy. Therefore, `nditer` should now be used
    as a context manager whenever it is used with writeable arrays, e.g., `with np.nditer(...)
    as it: ...`. You may also explicitly call `it.close()` for cases where a context
    manager is unusable, for instance in generator expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Numpy has switched to using pytest instead of nose for testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last nose release was 1.3.7 in June, 2015, and development of that tool
    has ended, consequently NumPy has now switched to using pytest. The old decorators
    and nose tools that were previously used by some downstream projects remain available,
    but will not be maintained. The standard testing utilities, `assert_almost_equal`
    and such, are not be affected by this change except for the nose specific functions
    `import_nose` and `raises`. Those functions are not used in numpy, but are kept
    for downstream compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Numpy no longer monkey-patches `ctypes` with `__array_interface__`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously numpy added `__array_interface__` attributes to all the integer types
    from `ctypes`.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.ma.notmasked_contiguous` and `np.ma.flatnotmasked_contiguous` always return
    lists'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the documented behavior, but previously the result could be any of slice,
    None, or list.
  prefs: []
  type: TYPE_NORMAL
- en: All downstream users seem to check for the `None` result from `flatnotmasked_contiguous`
    and replace it with `[]`. Those callers will continue to work as before.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.squeeze` restores old behavior of objects that cannot handle an `axis`
    argument'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to version `1.7.0`, [`numpy.squeeze`](../reference/generated/numpy.squeeze.html#numpy.squeeze
    "numpy.squeeze") did not have an `axis` argument and all empty axes were removed
    by default. The incorporation of an `axis` argument made it possible to selectively
    squeeze single or multiple empty axes, but the old API expectation was not respected
    because axes could still be selectively removed (silent success) from an object
    expecting all empty axes to be removed. That silent, selective removal of empty
    axes for objects expecting the old behavior has been fixed and the old behavior
    restored.
  prefs: []
  type: TYPE_NORMAL
- en: unstructured void array’s `.item` method now returns a bytes object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`.item` now returns a `bytes` object instead of a buffer or byte array. This
    may affect code which assumed the return value was mutable, which is no longer
    the case.'
  prefs: []
  type: TYPE_NORMAL
- en: '`copy.copy` and `copy.deepcopy` no longer turn `masked` into an array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `np.ma.masked` is a readonly scalar, copying should be a no-op. These
    functions now behave consistently with `np.copy()`.
  prefs: []
  type: TYPE_NORMAL
- en: Multifield Indexing of Structured Arrays will still return a copy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The change that multi-field indexing of structured arrays returns a view instead
    of a copy is pushed back to 1.16\. A new method `numpy.lib.recfunctions.repack_fields`
    has been introduced to help mitigate the effects of this change, which can be
    used to write code compatible with both numpy 1.15 and 1.16\. For more information
    on how to update code to account for this future change see the “accessing multiple
    fields” section of the [user guide](https://docs.scipy.org/doc/numpy/user/basics.rec.html).
  prefs: []
  type: TYPE_NORMAL
- en: Compiled testing modules renamed and made private
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following compiled modules have been renamed and made private:'
  prefs: []
  type: TYPE_NORMAL
- en: '`umath_tests` -> `_umath_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test_rational` -> `_rational_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`multiarray_tests` -> `_multiarray_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`struct_ufunc_test` -> `_struct_ufunc_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operand_flag_tests` -> `_operand_flag_tests`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `umath_tests` module is still available for backwards compatibility, but
    will be removed in the future.
  prefs: []
  type: TYPE_NORMAL
- en: The `NpzFile` returned by `np.savez` is now a `collections.abc.Mapping`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means it behaves like a readonly dictionary, and has a new `.values()`
    method and `len()` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: For python 3, this means that `.iteritems()`, `.iterkeys()` have been deprecated,
    and `.keys()` and `.items()` now return views and not lists. This is consistent
    with how the builtin `dict` type changed between python 2 and python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Under certain conditions, `nditer` must be used in a context manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using an [`numpy.nditer`](../reference/generated/numpy.nditer.html#numpy.nditer
    "numpy.nditer") with the `"writeonly"` or `"readwrite"` flags, there are some
    circumstances where nditer doesn’t actually give you a view of the writable array.
    Instead, it gives you a copy, and if you make changes to the copy, nditer later
    writes those changes back into your actual array. Currently, this writeback occurs
    when the array objects are garbage collected, which makes this API error-prone
    on CPython and entirely broken on PyPy. Therefore, `nditer` should now be used
    as a context manager whenever it is used with writeable arrays, e.g., `with np.nditer(...)
    as it: ...`. You may also explicitly call `it.close()` for cases where a context
    manager is unusable, for instance in generator expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: Numpy has switched to using pytest instead of nose for testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The last nose release was 1.3.7 in June, 2015, and development of that tool
    has ended, consequently NumPy has now switched to using pytest. The old decorators
    and nose tools that were previously used by some downstream projects remain available,
    but will not be maintained. The standard testing utilities, `assert_almost_equal`
    and such, are not be affected by this change except for the nose specific functions
    `import_nose` and `raises`. Those functions are not used in numpy, but are kept
    for downstream compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Numpy no longer monkey-patches `ctypes` with `__array_interface__`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously numpy added `__array_interface__` attributes to all the integer types
    from `ctypes`.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.ma.notmasked_contiguous` and `np.ma.flatnotmasked_contiguous` always return
    lists'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the documented behavior, but previously the result could be any of slice,
    None, or list.
  prefs: []
  type: TYPE_NORMAL
- en: All downstream users seem to check for the `None` result from `flatnotmasked_contiguous`
    and replace it with `[]`. Those callers will continue to work as before.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.squeeze` restores old behavior of objects that cannot handle an `axis`
    argument'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Prior to version `1.7.0`, [`numpy.squeeze`](../reference/generated/numpy.squeeze.html#numpy.squeeze
    "numpy.squeeze") did not have an `axis` argument and all empty axes were removed
    by default. The incorporation of an `axis` argument made it possible to selectively
    squeeze single or multiple empty axes, but the old API expectation was not respected
    because axes could still be selectively removed (silent success) from an object
    expecting all empty axes to be removed. That silent, selective removal of empty
    axes for objects expecting the old behavior has been fixed and the old behavior
    restored.
  prefs: []
  type: TYPE_NORMAL
- en: unstructured void array’s `.item` method now returns a bytes object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`.item` now returns a `bytes` object instead of a buffer or byte array. This
    may affect code which assumed the return value was mutable, which is no longer
    the case.'
  prefs: []
  type: TYPE_NORMAL
- en: '`copy.copy` and `copy.deepcopy` no longer turn `masked` into an array'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since `np.ma.masked` is a readonly scalar, copying should be a no-op. These
    functions now behave consistently with `np.copy()`.
  prefs: []
  type: TYPE_NORMAL
- en: Multifield Indexing of Structured Arrays will still return a copy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The change that multi-field indexing of structured arrays returns a view instead
    of a copy is pushed back to 1.16\. A new method `numpy.lib.recfunctions.repack_fields`
    has been introduced to help mitigate the effects of this change, which can be
    used to write code compatible with both numpy 1.15 and 1.16\. For more information
    on how to update code to account for this future change see the “accessing multiple
    fields” section of the [user guide](https://docs.scipy.org/doc/numpy/user/basics.rec.html).
  prefs: []
  type: TYPE_NORMAL
- en: C API changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: New functions `npy_get_floatstatus_barrier` and `npy_clear_floatstatus_barrier`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions `npy_get_floatstatus_barrier` and `npy_clear_floatstatus_barrier`
    have been added and should be used in place of the `npy_get_floatstatus``and ``npy_clear_status`
    functions. Optimizing compilers like GCC 8.1 and Clang were rearranging the order
    of operations when the previous functions were used in the ufunc SIMD functions,
    resulting in the floatstatus flags being checked before the operation whose status
    we wanted to check was run. See [#10339](https://github.com/numpy/numpy/issues/10370).
  prefs: []
  type: TYPE_NORMAL
- en: Changes to `PyArray_GetDTypeTransferFunction`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PyArray_GetDTypeTransferFunction` now defaults to using user-defined `copyswapn`
    / `copyswap` for user-defined dtypes. If this causes a significant performance
    hit, consider implementing `copyswapn` to reflect the implementation of `PyArray_GetStridedCopyFn`.
    See [#10898](https://github.com/numpy/numpy/pull/10898).'
  prefs: []
  type: TYPE_NORMAL
- en: New functions `npy_get_floatstatus_barrier` and `npy_clear_floatstatus_barrier`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions `npy_get_floatstatus_barrier` and `npy_clear_floatstatus_barrier`
    have been added and should be used in place of the `npy_get_floatstatus``and ``npy_clear_status`
    functions. Optimizing compilers like GCC 8.1 and Clang were rearranging the order
    of operations when the previous functions were used in the ufunc SIMD functions,
    resulting in the floatstatus flags being checked before the operation whose status
    we wanted to check was run. See [#10339](https://github.com/numpy/numpy/issues/10370).
  prefs: []
  type: TYPE_NORMAL
- en: Changes to `PyArray_GetDTypeTransferFunction`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`PyArray_GetDTypeTransferFunction` now defaults to using user-defined `copyswapn`
    / `copyswap` for user-defined dtypes. If this causes a significant performance
    hit, consider implementing `copyswapn` to reflect the implementation of `PyArray_GetStridedCopyFn`.
    See [#10898](https://github.com/numpy/numpy/pull/10898).'
  prefs: []
  type: TYPE_NORMAL
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`np.gcd` and `np.lcm` ufuncs added for integer and objects types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These compute the greatest common divisor, and lowest common multiple, respectively.
    These work on all the numpy integer types, as well as the builtin arbitrary-precision
    `Decimal` and `long` types.
  prefs: []
  type: TYPE_NORMAL
- en: Support for cross-platform builds for iOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The build system has been modified to add support for the `_PYTHON_HOST_PLATFORM`
    environment variable, used by `distutils` when compiling on one platform for another
    platform. This makes it possible to compile NumPy for iOS targets.
  prefs: []
  type: TYPE_NORMAL
- en: This only enables you to compile NumPy for one specific platform at a time.
    Creating a full iOS-compatible NumPy package requires building for the 5 architectures
    supported by iOS (i386, x86_64, armv7, armv7s and arm64), and combining these
    5 compiled builds products into a single “fat” binary.
  prefs: []
  type: TYPE_NORMAL
- en: '`return_indices` keyword added for `np.intersect1d`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New keyword `return_indices` returns the indices of the two input arrays that
    correspond to the common elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.quantile` and `np.nanquantile`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like `np.percentile` and `np.nanpercentile`, but takes quantiles in [0, 1] rather
    than percentiles in [0, 100]. `np.percentile` is now a thin wrapper around `np.quantile`
    with the extra step of dividing by 100.
  prefs: []
  type: TYPE_NORMAL
- en: Build system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Added experimental support for the 64-bit RISC-V architecture.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.gcd` and `np.lcm` ufuncs added for integer and objects types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These compute the greatest common divisor, and lowest common multiple, respectively.
    These work on all the numpy integer types, as well as the builtin arbitrary-precision
    `Decimal` and `long` types.
  prefs: []
  type: TYPE_NORMAL
- en: Support for cross-platform builds for iOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The build system has been modified to add support for the `_PYTHON_HOST_PLATFORM`
    environment variable, used by `distutils` when compiling on one platform for another
    platform. This makes it possible to compile NumPy for iOS targets.
  prefs: []
  type: TYPE_NORMAL
- en: This only enables you to compile NumPy for one specific platform at a time.
    Creating a full iOS-compatible NumPy package requires building for the 5 architectures
    supported by iOS (i386, x86_64, armv7, armv7s and arm64), and combining these
    5 compiled builds products into a single “fat” binary.
  prefs: []
  type: TYPE_NORMAL
- en: '`return_indices` keyword added for `np.intersect1d`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New keyword `return_indices` returns the indices of the two input arrays that
    correspond to the common elements.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.quantile` and `np.nanquantile`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like `np.percentile` and `np.nanpercentile`, but takes quantiles in [0, 1] rather
    than percentiles in [0, 100]. `np.percentile` is now a thin wrapper around `np.quantile`
    with the extra step of dividing by 100.
  prefs: []
  type: TYPE_NORMAL
- en: Build system
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Added experimental support for the 64-bit RISC-V architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`np.einsum` updates'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Syncs einsum path optimization tech between [`numpy`](../reference/index.html#module-numpy
    "numpy") and *opt_einsum*. In particular, the *greedy* path has received many
    enhancements by @jcmgray. A full list of issues fixed are:'
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary memory can be passed into the *greedy* path. Fixes gh-11210.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The greedy path has been updated to contain more dynamic programming ideas preventing
    a large number of duplicate (and expensive) calls that figure out the actual pair
    contraction that takes place. Now takes a few seconds on several hundred input
    tensors. Useful for matrix product state theories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reworks the broadcasting dot error catching found in gh-11218 gh-10352 to be
    a bit earlier in the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhances the *can_dot* functionality that previous missed an edge case (part
    of gh-11308).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.ufunc.reduce` and related functions now accept an initial value'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.ufunc.reduce`, `np.sum`, `np.prod`, `np.min` and `np.max` all now accept
    an `initial` keyword argument that specifies the value to start the reduction
    with.'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.flip` can operate over multiple axes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.flip` now accepts None, or tuples of int, in its `axis` argument. If axis
    is None, it will flip over all the axes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` and `histogramdd` functions have moved to `np.lib.histograms`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These were originally found in `np.lib.function_base`. They are still available
    under their un-scoped `np.histogram(dd)` names, and to maintain compatibility,
    aliased at `np.lib.function_base.histogram(dd)`.
  prefs: []
  type: TYPE_NORMAL
- en: Code that does `from np.lib.function_base import *` will need to be updated
    with the new location, and should consider not using `import *` in future.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` will accept NaN values when explicit bins are given'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously it would fail when trying to compute a finite range for the data.
    Since the range is ignored anyway when the bins are given explicitly, this error
    was needless.
  prefs: []
  type: TYPE_NORMAL
- en: Note that calling `histogram` on NaN values continues to raise the `RuntimeWarning`
    s typical of working with nan values, which can be silenced as usual with `errstate`.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` works on datetime types, when explicit bin edges are given'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dates, times, and timedeltas can now be histogrammed. The bin edges must be
    passed explicitly, and are not yet computed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` “auto” estimator handles limited variance better'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No longer does an IQR of 0 result in `n_bins=1`, rather the number of bins chosen
    is related to the data size in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: The edges returned by *histogram`* and `histogramdd` now match the data float
    type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When passed `np.float16`, `np.float32`, or `np.longdouble` data, the returned
    edges are now of the same dtype. Previously, `histogram` would only return the
    same type if explicit bins were given, and `histogram` would produce `float64`
    bins no matter what the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogramdd` allows explicit ranges to be given in a subset of axes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `range` argument of [`numpy.histogramdd`](../reference/generated/numpy.histogramdd.html#numpy.histogramdd
    "numpy.histogramdd") can now contain `None` values to indicate that the range
    for the corresponding axis should be computed from the data. Previously, this
    could not be specified on a per-axis basis.
  prefs: []
  type: TYPE_NORMAL
- en: The normed arguments of `histogramdd` and `histogram2d` have been renamed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These arguments are now called `density`, which is consistent with `histogram`.
    The old argument continues to work, but the new name should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.r_` works with 0d arrays, and `np.ma.mr_` works with `np.ma.masked`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 0d arrays passed to the *r_* and *mr_* concatenation helpers are now treated
    as though they are arrays of length 1\. Previously, passing these was an error.
    As a result, [`numpy.ma.mr_`](../reference/generated/numpy.ma.mr_.html#numpy.ma.mr_
    "numpy.ma.mr_") now works correctly on the `masked` constant.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.ptp` accepts a `keepdims` argument, and extended axis tuples'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.ptp` (peak-to-peak) can now work over multiple axes, just like `np.max`
    and `np.min`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MaskedArray.astype` now is identical to `ndarray.astype`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means it takes all the same arguments, making more code written for ndarray
    work for masked array too.
  prefs: []
  type: TYPE_NORMAL
- en: Enable AVX2/AVX512 at compile time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Change to simd.inc.src to allow use of AVX2 or AVX512 at compile time. Previously
    compilation for avx2 (or 512) with -march=native would still use the SSE code
    for the simd functions even when the rest of the code got AVX2.
  prefs: []
  type: TYPE_NORMAL
- en: '`nan_to_num` always returns scalars when receiving scalar or 0d inputs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously an array was returned for integer scalar inputs, which is inconsistent
    with the behavior for float inputs, and that of ufuncs in general. For all types
    of scalar or 0d input, the result is now a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.flatnonzero` works on numpy-convertible types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.flatnonzero` now uses `np.ravel(a)` instead of `a.ravel()`, so it works
    for lists, tuples, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.interp` returns numpy scalars rather than builtin scalars'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `np.interp(0.5, [0, 1], [10, 20])` would return a `float`, but now
    it returns a `np.float64` object, which more closely matches the behavior of other
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the special case of `np.interp(object_array_0d, ...)` is no longer
    supported, as `np.interp(object_array_nd)` was never supported anyway.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this change, the `period` argument can now be used on 0d arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Allow dtype field names to be unicode in Python 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `np.dtype([(u'name', float)])` would raise a `TypeError` in Python
    2, as only bytestrings were allowed in field names. Now any unicode string field
    names will be encoded with the `ascii` codec, raising a `UnicodeEncodeError` upon
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: This change makes it easier to write Python 2/3 compatible code using `from
    __future__ import unicode_literals`, which previously would cause string literal
    field names to raise a TypeError in Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison ufuncs accept `dtype=object`, overriding the default `bool`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This allows object arrays of symbolic types, which override `==` and other operators
    to return expressions, to be compared elementwise with `np.equal(a, b, dtype=object)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`sort` functions accept `kind=''stable''`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up until now, to perform a stable sort on the data, the user must do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: because merge sort is the only stable sorting algorithm available in NumPy.
    However, having kind=’mergesort’ does not make it explicit that the user wants
    to perform a stable sort thus harming the readability.
  prefs: []
  type: TYPE_NORMAL
- en: This change allows the user to specify kind=’stable’ thus clarifying the intent.
  prefs: []
  type: TYPE_NORMAL
- en: Do not make temporary copies for in-place accumulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When ufuncs perform accumulation they no longer make temporary copies because
    of the overlap between input an output, that is, the next element accumulated
    is added before the accumulated result is stored in its place, hence the overlap
    is safe. Avoiding the copy results in faster execution.
  prefs: []
  type: TYPE_NORMAL
- en: '`linalg.matrix_power` can now handle stacks of matrices'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like other functions in `linalg`, `matrix_power` can now deal with arrays of
    dimension larger than 2, which are treated as stacks of matrices. As part of the
    change, to further improve consistency, the name of the first argument has been
    changed to `a` (from `M`), and the exceptions for non-square matrices have been
    changed to `LinAlgError` (from `ValueError`).
  prefs: []
  type: TYPE_NORMAL
- en: Increased performance in `random.permutation` for multidimensional arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`permutation` uses the fast path in `random.shuffle` for all input array dimensions.
    Previously the fast path was only used for 1-d arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Generalized ufuncs now accept `axes`, `axis` and `keepdims` arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One can control over which axes a generalized ufunc operates by passing in an
    `axes` argument, a list of tuples with indices of particular axes. For instance,
    for a signature of `(i,j),(j,k)->(i,k)` appropriate for matrix multiplication,
    the base elements are two-dimensional matrices and these are taken to be stored
    in the two last axes of each argument. The corresponding axes keyword would be
    `[(-2, -1), (-2, -1), (-2, -1)]`. If one wanted to use leading dimensions instead,
    one would pass in `[(0, 1), (0, 1), (0, 1)]`.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, for generalized ufuncs that operate on 1-dimensional arrays
    (vectors), a single integer is accepted instead of a single-element tuple, and
    for generalized ufuncs for which all outputs are scalars, the (empty) output tuples
    can be omitted. Hence, for a signature of `(i),(i)->()` appropriate for an inner
    product, one could pass in `axes=[0, 0]` to indicate that the vectors are stored
    in the first dimensions of the two inputs arguments.
  prefs: []
  type: TYPE_NORMAL
- en: As a short-cut for generalized ufuncs that are similar to reductions, i.e.,
    that act on a single, shared core dimension such as the inner product example
    above, one can pass an `axis` argument. This is equivalent to passing in `axes`
    with identical entries for all arguments with that core dimension (e.g., for the
    example above, `axes=[(axis,), (axis,)]`).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, like for reductions, for generalized ufuncs that have inputs that
    all have the same number of core dimensions and outputs with no core dimension,
    one can pass in `keepdims` to leave a dimension with size 1 in the outputs, thus
    allowing proper broadcasting against the original inputs. The location of the
    extra dimension can be controlled with `axes`. For instance, for the inner-product
    example, `keepdims=True, axes=[-2, -2, -2]` would act on the inner-product example,
    `keepdims=True, axis=-2` would act on the one-but-last dimension of the input
    arguments, and leave a size 1 dimension in that place in the output.
  prefs: []
  type: TYPE_NORMAL
- en: float128 values now print correctly on ppc systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously printing float128 values was buggy on ppc, since the special double-double
    floating-point-format on these systems was not accounted for. float128s now print
    with correct rounding and uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning to ppc users: You should upgrade glibc if it is version <=2.23, especially
    if using float128\. On ppc, glibc’s malloc in these version often misaligns allocated
    memory which can crash numpy when using float128 values.'
  prefs: []
  type: TYPE_NORMAL
- en: New `np.take_along_axis` and `np.put_along_axis` functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When used on multidimensional arrays, `argsort`, `argmin`, `argmax`, and `argpartition`
    return arrays that are difficult to use as indices. `take_along_axis` provides
    an easy way to use these indices to lookup values within an array, so that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`np.put_along_axis` acts as the dual operation for writing to these indices
    within an array.'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.einsum` updates'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Syncs einsum path optimization tech between [`numpy`](../reference/index.html#module-numpy
    "numpy") and *opt_einsum*. In particular, the *greedy* path has received many
    enhancements by @jcmgray. A full list of issues fixed are:'
  prefs: []
  type: TYPE_NORMAL
- en: Arbitrary memory can be passed into the *greedy* path. Fixes gh-11210.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The greedy path has been updated to contain more dynamic programming ideas preventing
    a large number of duplicate (and expensive) calls that figure out the actual pair
    contraction that takes place. Now takes a few seconds on several hundred input
    tensors. Useful for matrix product state theories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reworks the broadcasting dot error catching found in gh-11218 gh-10352 to be
    a bit earlier in the process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhances the *can_dot* functionality that previous missed an edge case (part
    of gh-11308).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.ufunc.reduce` and related functions now accept an initial value'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.ufunc.reduce`, `np.sum`, `np.prod`, `np.min` and `np.max` all now accept
    an `initial` keyword argument that specifies the value to start the reduction
    with.'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.flip` can operate over multiple axes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.flip` now accepts None, or tuples of int, in its `axis` argument. If axis
    is None, it will flip over all the axes.'
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` and `histogramdd` functions have moved to `np.lib.histograms`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These were originally found in `np.lib.function_base`. They are still available
    under their un-scoped `np.histogram(dd)` names, and to maintain compatibility,
    aliased at `np.lib.function_base.histogram(dd)`.
  prefs: []
  type: TYPE_NORMAL
- en: Code that does `from np.lib.function_base import *` will need to be updated
    with the new location, and should consider not using `import *` in future.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` will accept NaN values when explicit bins are given'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously it would fail when trying to compute a finite range for the data.
    Since the range is ignored anyway when the bins are given explicitly, this error
    was needless.
  prefs: []
  type: TYPE_NORMAL
- en: Note that calling `histogram` on NaN values continues to raise the `RuntimeWarning`
    s typical of working with nan values, which can be silenced as usual with `errstate`.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` works on datetime types, when explicit bin edges are given'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Dates, times, and timedeltas can now be histogrammed. The bin edges must be
    passed explicitly, and are not yet computed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogram` “auto” estimator handles limited variance better'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No longer does an IQR of 0 result in `n_bins=1`, rather the number of bins chosen
    is related to the data size in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: The edges returned by *histogram`* and `histogramdd` now match the data float
    type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When passed `np.float16`, `np.float32`, or `np.longdouble` data, the returned
    edges are now of the same dtype. Previously, `histogram` would only return the
    same type if explicit bins were given, and `histogram` would produce `float64`
    bins no matter what the inputs.
  prefs: []
  type: TYPE_NORMAL
- en: '`histogramdd` allows explicit ranges to be given in a subset of axes'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `range` argument of [`numpy.histogramdd`](../reference/generated/numpy.histogramdd.html#numpy.histogramdd
    "numpy.histogramdd") can now contain `None` values to indicate that the range
    for the corresponding axis should be computed from the data. Previously, this
    could not be specified on a per-axis basis.
  prefs: []
  type: TYPE_NORMAL
- en: The normed arguments of `histogramdd` and `histogram2d` have been renamed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These arguments are now called `density`, which is consistent with `histogram`.
    The old argument continues to work, but the new name should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.r_` works with 0d arrays, and `np.ma.mr_` works with `np.ma.masked`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 0d arrays passed to the *r_* and *mr_* concatenation helpers are now treated
    as though they are arrays of length 1\. Previously, passing these was an error.
    As a result, [`numpy.ma.mr_`](../reference/generated/numpy.ma.mr_.html#numpy.ma.mr_
    "numpy.ma.mr_") now works correctly on the `masked` constant.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.ptp` accepts a `keepdims` argument, and extended axis tuples'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.ptp` (peak-to-peak) can now work over multiple axes, just like `np.max`
    and `np.min`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`MaskedArray.astype` now is identical to `ndarray.astype`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means it takes all the same arguments, making more code written for ndarray
    work for masked array too.
  prefs: []
  type: TYPE_NORMAL
- en: Enable AVX2/AVX512 at compile time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Change to simd.inc.src to allow use of AVX2 or AVX512 at compile time. Previously
    compilation for avx2 (or 512) with -march=native would still use the SSE code
    for the simd functions even when the rest of the code got AVX2.
  prefs: []
  type: TYPE_NORMAL
- en: '`nan_to_num` always returns scalars when receiving scalar or 0d inputs'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously an array was returned for integer scalar inputs, which is inconsistent
    with the behavior for float inputs, and that of ufuncs in general. For all types
    of scalar or 0d input, the result is now a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '`np.flatnonzero` works on numpy-convertible types'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.flatnonzero` now uses `np.ravel(a)` instead of `a.ravel()`, so it works
    for lists, tuples, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.interp` returns numpy scalars rather than builtin scalars'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `np.interp(0.5, [0, 1], [10, 20])` would return a `float`, but now
    it returns a `np.float64` object, which more closely matches the behavior of other
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the special case of `np.interp(object_array_0d, ...)` is no longer
    supported, as `np.interp(object_array_nd)` was never supported anyway.
  prefs: []
  type: TYPE_NORMAL
- en: As a result of this change, the `period` argument can now be used on 0d arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Allow dtype field names to be unicode in Python 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `np.dtype([(u'name', float)])` would raise a `TypeError` in Python
    2, as only bytestrings were allowed in field names. Now any unicode string field
    names will be encoded with the `ascii` codec, raising a `UnicodeEncodeError` upon
    failure.
  prefs: []
  type: TYPE_NORMAL
- en: This change makes it easier to write Python 2/3 compatible code using `from
    __future__ import unicode_literals`, which previously would cause string literal
    field names to raise a TypeError in Python 2.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison ufuncs accept `dtype=object`, overriding the default `bool`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This allows object arrays of symbolic types, which override `==` and other operators
    to return expressions, to be compared elementwise with `np.equal(a, b, dtype=object)`.
  prefs: []
  type: TYPE_NORMAL
- en: '`sort` functions accept `kind=''stable''`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Up until now, to perform a stable sort on the data, the user must do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: because merge sort is the only stable sorting algorithm available in NumPy.
    However, having kind=’mergesort’ does not make it explicit that the user wants
    to perform a stable sort thus harming the readability.
  prefs: []
  type: TYPE_NORMAL
- en: This change allows the user to specify kind=’stable’ thus clarifying the intent.
  prefs: []
  type: TYPE_NORMAL
- en: Do not make temporary copies for in-place accumulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When ufuncs perform accumulation they no longer make temporary copies because
    of the overlap between input an output, that is, the next element accumulated
    is added before the accumulated result is stored in its place, hence the overlap
    is safe. Avoiding the copy results in faster execution.
  prefs: []
  type: TYPE_NORMAL
- en: '`linalg.matrix_power` can now handle stacks of matrices'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Like other functions in `linalg`, `matrix_power` can now deal with arrays of
    dimension larger than 2, which are treated as stacks of matrices. As part of the
    change, to further improve consistency, the name of the first argument has been
    changed to `a` (from `M`), and the exceptions for non-square matrices have been
    changed to `LinAlgError` (from `ValueError`).
  prefs: []
  type: TYPE_NORMAL
- en: Increased performance in `random.permutation` for multidimensional arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`permutation` uses the fast path in `random.shuffle` for all input array dimensions.
    Previously the fast path was only used for 1-d arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: Generalized ufuncs now accept `axes`, `axis` and `keepdims` arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One can control over which axes a generalized ufunc operates by passing in an
    `axes` argument, a list of tuples with indices of particular axes. For instance,
    for a signature of `(i,j),(j,k)->(i,k)` appropriate for matrix multiplication,
    the base elements are two-dimensional matrices and these are taken to be stored
    in the two last axes of each argument. The corresponding axes keyword would be
    `[(-2, -1), (-2, -1), (-2, -1)]`. If one wanted to use leading dimensions instead,
    one would pass in `[(0, 1), (0, 1), (0, 1)]`.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, for generalized ufuncs that operate on 1-dimensional arrays
    (vectors), a single integer is accepted instead of a single-element tuple, and
    for generalized ufuncs for which all outputs are scalars, the (empty) output tuples
    can be omitted. Hence, for a signature of `(i),(i)->()` appropriate for an inner
    product, one could pass in `axes=[0, 0]` to indicate that the vectors are stored
    in the first dimensions of the two inputs arguments.
  prefs: []
  type: TYPE_NORMAL
- en: As a short-cut for generalized ufuncs that are similar to reductions, i.e.,
    that act on a single, shared core dimension such as the inner product example
    above, one can pass an `axis` argument. This is equivalent to passing in `axes`
    with identical entries for all arguments with that core dimension (e.g., for the
    example above, `axes=[(axis,), (axis,)]`).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, like for reductions, for generalized ufuncs that have inputs that
    all have the same number of core dimensions and outputs with no core dimension,
    one can pass in `keepdims` to leave a dimension with size 1 in the outputs, thus
    allowing proper broadcasting against the original inputs. The location of the
    extra dimension can be controlled with `axes`. For instance, for the inner-product
    example, `keepdims=True, axes=[-2, -2, -2]` would act on the inner-product example,
    `keepdims=True, axis=-2` would act on the one-but-last dimension of the input
    arguments, and leave a size 1 dimension in that place in the output.
  prefs: []
  type: TYPE_NORMAL
- en: float128 values now print correctly on ppc systems
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously printing float128 values was buggy on ppc, since the special double-double
    floating-point-format on these systems was not accounted for. float128s now print
    with correct rounding and uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Warning to ppc users: You should upgrade glibc if it is version <=2.23, especially
    if using float128\. On ppc, glibc’s malloc in these version often misaligns allocated
    memory which can crash numpy when using float128 values.'
  prefs: []
  type: TYPE_NORMAL
- en: New `np.take_along_axis` and `np.put_along_axis` functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When used on multidimensional arrays, `argsort`, `argmin`, `argmax`, and `argpartition`
    return arrays that are difficult to use as indices. `take_along_axis` provides
    an easy way to use these indices to lookup values within an array, so that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'is the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`np.put_along_axis` acts as the dual operation for writing to these indices
    within an array.'
  prefs: []
  type: TYPE_NORMAL
