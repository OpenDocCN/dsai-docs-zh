- en: numpy.lib.Arrayterator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.lib.Arrayterator.html](https://numpy.org/doc/1.26/reference/generated/numpy.lib.Arrayterator.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Buffered iterator for big arrays.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Arrayterator`](#numpy.lib.Arrayterator "numpy.lib.Arrayterator") creates
    a buffered iterator for reading big arrays in small contiguous blocks. The class
    is useful for objects stored in the file system. It allows iteration over the
    object *without* reading everything in memory; instead, small blocks are read
    and iterated over.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Arrayterator`](#numpy.lib.Arrayterator "numpy.lib.Arrayterator") can be used
    with any object that supports multidimensional slices. This includes NumPy arrays,
    but also variables from Scientific.IO.NetCDF or pynetcdf for example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**var**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: The object to iterate over.
  prefs: []
  type: TYPE_NORMAL
- en: '**buf_size**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The buffer size. If *buf_size* is supplied, the maximum amount of data that
    will be read into memory is *buf_size* elements. Default is None, which will read
    as many element as possible into memory.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '`ndenumerate`'
  prefs: []
  type: TYPE_NORMAL
- en: Multidimensional array iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '`flatiter`'
  prefs: []
  type: TYPE_NORMAL
- en: Flat array iterator.
  prefs: []
  type: TYPE_NORMAL
- en: '`memmap`'
  prefs: []
  type: TYPE_NORMAL
- en: Create a memory-map to an array stored in a binary file on disk.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm works by first finding a “running dimension”, along which the
    blocks will be extracted. Given an array of dimensions `(d1, d2, ..., dn)`, e.g.
    if *buf_size* is smaller than `d1`, the first dimension will be used. If, on the
    other hand, `d1 < buf_size < d1*d2` the second dimension will be used, and so
    on. Blocks are extracted along this dimension, and when the last block is returned
    the process continues from the next dimension, until all elements have been read.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can iterate over `a_itor`, and it will return arrays of size two. Since
    *buf_size* was smaller than any dimension, the first dimension will be iterated
    over first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**var**'
  prefs: []
  type: TYPE_NORMAL
- en: '**buf_size**'
  prefs: []
  type: TYPE_NORMAL
- en: '**start**'
  prefs: []
  type: TYPE_NORMAL
- en: '**stop**'
  prefs: []
  type: TYPE_NORMAL
- en: '**step**'
  prefs: []
  type: TYPE_NORMAL
- en: '[`shape`](numpy.lib.Arrayterator.shape.html#numpy.lib.Arrayterator.shape "numpy.lib.Arrayterator.shape")'
  prefs: []
  type: TYPE_NORMAL
- en: The shape of the array to be iterated over.
  prefs: []
  type: TYPE_NORMAL
- en: '[`flat`](numpy.lib.Arrayterator.flat.html#numpy.lib.Arrayterator.flat "numpy.lib.Arrayterator.flat")'
  prefs: []
  type: TYPE_NORMAL
- en: A 1-D flat iterator for Arrayterator objects.
  prefs: []
  type: TYPE_NORMAL
