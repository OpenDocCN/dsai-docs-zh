["```py\nnpy_intp  PyArray_CountNonzero(PyArrayObject*  self)\n{\n  /* Nonzero boolean function */\n  PyArray_NonzeroFunc*  nonzero  =  PyArray_DESCR(self)->f->nonzero;\n\n  NpyIter*  iter;\n  NpyIter_IterNextFunc  *iternext;\n  char**  dataptr;\n  npy_intp  nonzero_count;\n  npy_intp*  strideptr,*  innersizeptr;\n\n  /* Handle zero-sized arrays specially */\n  if  (PyArray_SIZE(self)  ==  0)  {\n  return  0;\n  }\n\n  /*\n * Create and use an iterator to count the nonzeros.\n *   flag NPY_ITER_READONLY\n *     - The array is never written to.\n *   flag NPY_ITER_EXTERNAL_LOOP\n *     - Inner loop is done outside the iterator for efficiency.\n *   flag NPY_ITER_NPY_ITER_REFS_OK\n *     - Reference types are acceptable.\n *   order NPY_KEEPORDER\n *     - Visit elements in memory order, regardless of strides.\n *       This is good for performance when the specific order\n *       elements are visited is unimportant.\n *   casting NPY_NO_CASTING\n *     - No casting is required for this operation.\n */\n  iter  =  NpyIter_New(self,  NPY_ITER_READONLY|\n  NPY_ITER_EXTERNAL_LOOP|\n  NPY_ITER_REFS_OK,\n  NPY_KEEPORDER,  NPY_NO_CASTING,\n  NULL);\n  if  (iter  ==  NULL)  {\n  return  -1;\n  }\n\n  /*\n * The iternext function gets stored in a local variable\n * so it can be called repeatedly in an efficient manner.\n */\n  iternext  =  NpyIter_GetIterNext(iter,  NULL);\n  if  (iternext  ==  NULL)  {\n  NpyIter_Deallocate(iter);\n  return  -1;\n  }\n  /* The location of the data pointer which the iterator may update */\n  dataptr  =  NpyIter_GetDataPtrArray(iter);\n  /* The location of the stride which the iterator may update */\n  strideptr  =  NpyIter_GetInnerStrideArray(iter);\n  /* The location of the inner loop size which the iterator may update */\n  innersizeptr  =  NpyIter_GetInnerLoopSizePtr(iter);\n\n  nonzero_count  =  0;\n  do  {\n  /* Get the inner loop data/stride/count values */\n  char*  data  =  *dataptr;\n  npy_intp  stride  =  *strideptr;\n  npy_intp  count  =  *innersizeptr;\n\n  /* This is a typical inner loop for NPY_ITER_EXTERNAL_LOOP */\n  while  (count--)  {\n  if  (nonzero(data,  self))  {\n  ++nonzero_count;\n  }\n  data  +=  stride;\n  }\n\n  /* Increment the iterator to the next inner loop */\n  }  while(iternext(iter));\n\n  NpyIter_Deallocate(iter);\n\n  return  nonzero_count;\n} \n```", "```py\nPyObject  *CopyArray(PyObject  *arr,  NPY_ORDER  order)\n{\n  NpyIter  *iter;\n  NpyIter_IterNextFunc  *iternext;\n  PyObject  *op[2],  *ret;\n  npy_uint32  flags;\n  npy_uint32  op_flags[2];\n  npy_intp  itemsize,  *innersizeptr,  innerstride;\n  char  **dataptrarray;\n\n  /*\n * No inner iteration - inner loop is handled by CopyArray code\n */\n  flags  =  NPY_ITER_EXTERNAL_LOOP;\n  /*\n * Tell the constructor to automatically allocate the output.\n * The data type of the output will match that of the input.\n */\n  op[0]  =  arr;\n  op[1]  =  NULL;\n  op_flags[0]  =  NPY_ITER_READONLY;\n  op_flags[1]  =  NPY_ITER_WRITEONLY  |  NPY_ITER_ALLOCATE;\n\n  /* Construct the iterator */\n  iter  =  NpyIter_MultiNew(2,  op,  flags,  order,  NPY_NO_CASTING,\n  op_flags,  NULL);\n  if  (iter  ==  NULL)  {\n  return  NULL;\n  }\n\n  /*\n * Make a copy of the iternext function pointer and\n * a few other variables the inner loop needs.\n */\n  iternext  =  NpyIter_GetIterNext(iter,  NULL);\n  innerstride  =  NpyIter_GetInnerStrideArray(iter)[0];\n  itemsize  =  NpyIter_GetDescrArray(iter)[0]->elsize;\n  /*\n * The inner loop size and data pointers may change during the\n * loop, so just cache the addresses.\n */\n  innersizeptr  =  NpyIter_GetInnerLoopSizePtr(iter);\n  dataptrarray  =  NpyIter_GetDataPtrArray(iter);\n\n  /*\n * Note that because the iterator allocated the output,\n * it matches the iteration order and is packed tightly,\n * so we don't need to check it like the input.\n */\n  if  (innerstride  ==  itemsize)  {\n  do  {\n  memcpy(dataptrarray[1],  dataptrarray[0],\n  itemsize  *  (*innersizeptr));\n  }  while  (iternext(iter));\n  }  else  {\n  /* For efficiency, should specialize this based on item size... */\n  npy_intp  i;\n  do  {\n  npy_intp  size  =  *innersizeptr;\n  char  *src  =  dataptrarray[0],  *dst  =  dataptrarray[1];\n  for(i  =  0;  i  <  size;  i++,  src  +=  innerstride,  dst  +=  itemsize)  {\n  memcpy(dst,  src,  itemsize);\n  }\n  }  while  (iternext(iter));\n  }\n\n  /* Get the result from the iterator object array */\n  ret  =  NpyIter_GetOperandArray(iter)[1];\n  Py_INCREF(ret);\n\n  if  (NpyIter_Deallocate(iter)  !=  NPY_SUCCEED)  {\n  Py_DECREF(ret);\n  return  NULL;\n  }\n\n  return  ret;\n} \n```", "```py\nint  PrintMultiIndex(PyArrayObject  *arr)  {\n  NpyIter  *iter;\n  NpyIter_IterNextFunc  *iternext;\n  npy_intp  multi_index[2];\n\n  iter  =  NpyIter_New(\n  arr,  NPY_ITER_READONLY  |  NPY_ITER_MULTI_INDEX  |  NPY_ITER_REFS_OK,\n  NPY_KEEPORDER,  NPY_NO_CASTING,  NULL);\n  if  (iter  ==  NULL)  {\n  return  -1;\n  }\n  if  (NpyIter_GetNDim(iter)  !=  2)  {\n  NpyIter_Deallocate(iter);\n  PyErr_SetString(PyExc_ValueError,  \"Array must be 2-D\");\n  return  -1;\n  }\n  if  (NpyIter_GetIterSize(iter)  !=  0)  {\n  iternext  =  NpyIter_GetIterNext(iter,  NULL);\n  if  (iternext  ==  NULL)  {\n  NpyIter_Deallocate(iter);\n  return  -1;\n  }\n  NpyIter_GetMultiIndexFunc  *get_multi_index  =\n  NpyIter_GetGetMultiIndex(iter,  NULL);\n  if  (get_multi_index  ==  NULL)  {\n  NpyIter_Deallocate(iter);\n  return  -1;\n  }\n\n  do  {\n  get_multi_index(iter,  multi_index);\n  printf(\"multi_index is [%\"  NPY_INTP_FMT  \", %\"  NPY_INTP_FMT  \"]\\n\",\n  multi_index[0],  multi_index[1]);\n  }  while  (iternext(iter));\n  }\n  if  (!NpyIter_Deallocate(iter))  {\n  return  -1;\n  }\n  return  0;\n} \n```", "```py\nmulti_index  is  [0,  0]\nmulti_index  is  [0,  1]\nmulti_index  is  [0,  2]\nmulti_index  is  [1,  0]\nmulti_index  is  [1,  1]\nmulti_index  is  [1,  2] \n```", "```py\ntype NpyIter\n```", "```py\ntype NpyIter_Type\n```", "```py\ntype NpyIter_IterNextFunc\n```", "```py\ntype NpyIter_GetMultiIndexFunc\n```", "```py\n*NpyIter_New( *op, flags, order, casting, *dtype)\n```", "```py\niter  =  NpyIter_New(op,  NPY_ITER_READWRITE,\n  NPY_CORDER,  NPY_NO_CASTING,  NULL); \n```", "```py\ndtype  =  PyArray_DescrFromType(NPY_DOUBLE);\niter  =  NpyIter_New(op,  NPY_ITER_READWRITE|\n  NPY_ITER_BUFFERED|\n  NPY_ITER_NBO|\n  NPY_ITER_ALIGNED,\n  NPY_KEEPORDER,\n  NPY_SAME_KIND_CASTING,\n  dtype);\nPy_DECREF(dtype); \n```", "```py\n*NpyIter_MultiNew( nop, **op, flags, order, casting, *op_flags, **op_dtypes)\n```", "```py\nNPY_ITER_C_INDEX\n```", "```py\nNPY_ITER_F_INDEX\n```", "```py\nNPY_ITER_MULTI_INDEX\n```", "```py\nNPY_ITER_EXTERNAL_LOOP\n```", "```py\nNPY_ITER_DONT_NEGATE_STRIDES\n```", "```py\nNPY_ITER_COMMON_DTYPE\n```", "```py\nNPY_ITER_REFS_OK\n```", "```py\nNPY_ITER_ZEROSIZE_OK\n```", "```py\nNPY_ITER_REDUCE_OK\n```", "```py\nNPY_ITER_RANGED\n```", "```py\nNPY_ITER_BUFFERED\n```", "```py\nNPY_ITER_GROWINNER\n```", "```py\nNPY_ITER_DELAY_BUFALLOC\n```", "```py\nNPY_ITER_COPY_IF_OVERLAP\n```", "```py\nNPY_ITER_READWRITE\n```", "```py\nNPY_ITER_READONLY\n```", "```py\nNPY_ITER_WRITEONLY\n```", "```py\nNPY_ITER_COPY\n```", "```py\nNPY_ITER_UPDATEIFCOPY\n```", "```py\nNPY_ITER_NBO\n```", "```py\nNPY_ITER_ALIGNED\n```", "```py\nNPY_ITER_CONTIG\n```", "```py\nNPY_ITER_ALLOCATE\n```", "```py\nNPY_ITER_NO_SUBTYPE\n```", "```py\nNPY_ITER_NO_BROADCAST\n```", "```py\nNPY_ITER_ARRAYMASK\n```", "```py\nNPY_ITER_WRITEMASKED\n```", "```py\nNPY_ITER_OVERLAP_ASSUME_ELEMENTWISE\n```", "```py\n*NpyIter_AdvancedNew( nop, **op, flags, order, casting, *op_flags, **op_dtypes, int oa_ndim, int **op_axes, const *itershape, buffersize)\n```", "```py\nint  oa_ndim  =  3;  /* # iteration axes */\nint  op0_axes[]  =  {0,  1,  2};  /* 3-D operand */\nint  op1_axes[]  =  {-1,  0,  1};  /* 2-D operand */\nint  op2_axes[]  =  {-1,  -1,  0};  /* 1-D operand */\nint  op3_axes[]  =  {-1,  -1,  -1}  /* 0-D (scalar) operand */\nint*  op_axes[]  =  {op0_axes,  op1_axes,  op2_axes,  op3_axes}; \n```", "```py\n*NpyIter_Copy( *iter)\n```", "```py\nint NpyIter_RemoveAxis( *iter, int axis)\n```", "```py\nint NpyIter_RemoveMultiIndex( *iter)\n```", "```py\nint NpyIter_EnableExternalLoop( *iter)\n```", "```py\nint NpyIter_Deallocate( *iter)\n```", "```py\nint NpyIter_Reset( *iter, char **errmsg)\n```", "```py\nint NpyIter_ResetToIterIndexRange( *iter, istart, iend, char **errmsg)\n```", "```py\n/* Set to a trivial empty range */\nNpyIter_ResetToIterIndexRange(iter,  0,  0);\n/* Set the base pointers */\nNpyIter_ResetBasePointers(iter,  baseptrs);\n/* Set to the desired range */\nNpyIter_ResetToIterIndexRange(iter,  istart,  iend); \n```", "```py\nint NpyIter_ResetBasePointers( *iter, char **baseptrs, char **errmsg)\n```", "```py\nNpyIter  *iter1,  *iter1;\nNpyIter_IterNextFunc  *iternext1,  *iternext2;\nchar  **dataptrs1;\n\n/*\n * With the exact same operands, no copies allowed, and\n * no axis in op_axes used both in iter1 and iter2.\n * Buffering may be enabled for iter2, but not for iter1.\n */\niter1  =  ...;  iter2  =  ...;\n\niternext1  =  NpyIter_GetIterNext(iter1);\niternext2  =  NpyIter_GetIterNext(iter2);\ndataptrs1  =  NpyIter_GetDataPtrArray(iter1);\n\ndo  {\n  NpyIter_ResetBasePointers(iter2,  dataptrs1);\n  do  {\n  /* Use the iter2 values */\n  }  while  (iternext2(iter2));\n}  while  (iternext1(iter1)); \n```", "```py\nint NpyIter_GotoMultiIndex( *iter, const *multi_index)\n```", "```py\nint NpyIter_GotoIndex( *iter, index)\n```", "```py\nNpyIter_GetIterSize( *iter)\n```", "```py\nNpyIter_GetIterIndex( *iter)\n```", "```py\nvoid NpyIter_GetIterIndexRange( *iter, *istart, *iend)\n```", "```py\nint NpyIter_GotoIterIndex( *iter, iterindex)\n```", "```py\nNpyIter_HasDelayedBufAlloc( *iter)\n```", "```py\nNpyIter_HasExternalLoop( *iter)\n```", "```py\nNpyIter_HasMultiIndex( *iter)\n```", "```py\nNpyIter_HasIndex( *iter)\n```", "```py\nNpyIter_RequiresBuffering( *iter)\n```", "```py\nNpyIter_IsBuffered( *iter)\n```", "```py\nNpyIter_IsGrowInner( *iter)\n```", "```py\nNpyIter_GetBufferSize( *iter)\n```", "```py\nint NpyIter_GetNDim( *iter)\n```", "```py\nint NpyIter_GetNOp( *iter)\n```", "```py\n*NpyIter_GetAxisStrideArray( *iter, int axis)\n```", "```py\nint NpyIter_GetShape( *iter, *outshape)\n```", "```py\n**NpyIter_GetDescrArray( *iter)\n```", "```py\n**NpyIter_GetOperandArray( *iter)\n```", "```py\n*NpyIter_GetIterView( *iter, i)\n```", "```py\nvoid NpyIter_GetReadFlags( *iter, char *outreadflags)\n```", "```py\nvoid NpyIter_GetWriteFlags( *iter, char *outwriteflags)\n```", "```py\nint NpyIter_CreateCompatibleStrides( *iter, itemsize, *outstrides)\n```", "```py\nNpyIter_IsFirstVisit( *iter, int iop)\n```", "```py\n*NpyIter_GetIterNext( *iter, char **errmsg)\n```", "```py\nNpyIter_IterNextFunc  *iternext  =  NpyIter_GetIterNext(iter,  NULL);\nchar**  dataptr  =  NpyIter_GetDataPtrArray(iter);\n\ndo  {\n  /* use the addresses dataptr[0], ... dataptr[nop-1] */\n}  while(iternext(iter)); \n```", "```py\nNpyIter_IterNextFunc  *iternext  =  NpyIter_GetIterNext(iter,  NULL);\nchar**  dataptr  =  NpyIter_GetDataPtrArray(iter);\nnpy_intp*  stride  =  NpyIter_GetInnerStrideArray(iter);\nnpy_intp*  size_ptr  =  NpyIter_GetInnerLoopSizePtr(iter),  size;\nnpy_intp  iop,  nop  =  NpyIter_GetNOp(iter);\n\ndo  {\n  size  =  *size_ptr;\n  while  (size--)  {\n  /* use the addresses dataptr[0], ... dataptr[nop-1] */\n  for  (iop  =  0;  iop  <  nop;  ++iop)  {\n  dataptr[iop]  +=  stride[iop];\n  }\n  }\n}  while  (iternext()); \n```", "```py\n/* The constructor should have buffersize passed as this value */\n#define FIXED_BUFFER_SIZE 1024\n\nNpyIter_IterNextFunc  *iternext  =  NpyIter_GetIterNext(iter,  NULL);\nchar  **dataptr  =  NpyIter_GetDataPtrArray(iter);\nnpy_intp  *stride  =  NpyIter_GetInnerStrideArray(iter);\nnpy_intp  *size_ptr  =  NpyIter_GetInnerLoopSizePtr(iter),  size;\nnpy_intp  i,  iop,  nop  =  NpyIter_GetNOp(iter);\n\n/* One loop with a fixed inner size */\nsize  =  *size_ptr;\nwhile  (size  ==  FIXED_BUFFER_SIZE)  {\n  /*\n * This loop could be manually unrolled by a factor\n * which divides into FIXED_BUFFER_SIZE\n */\n  for  (i  =  0;  i  <  FIXED_BUFFER_SIZE;  ++i)  {\n  /* use the addresses dataptr[0], ... dataptr[nop-1] */\n  for  (iop  =  0;  iop  <  nop;  ++iop)  {\n  dataptr[iop]  +=  stride[iop];\n  }\n  }\n  iternext();\n  size  =  *size_ptr;\n}\n\n/* Finish-up loop with variable inner size */\nif  (size  >  0)  do  {\n  size  =  *size_ptr;\n  while  (size--)  {\n  /* use the addresses dataptr[0], ... dataptr[nop-1] */\n  for  (iop  =  0;  iop  <  nop;  ++iop)  {\n  dataptr[iop]  +=  stride[iop];\n  }\n  }\n}  while  (iternext()); \n```", "```py\n*NpyIter_GetGetMultiIndex( *iter, char **errmsg)\n```", "```py\nchar **NpyIter_GetDataPtrArray( *iter)\n```", "```py\nchar **NpyIter_GetInitialDataPtrArray( *iter)\n```", "```py\n*NpyIter_GetIndexPtr( *iter)\n```", "```py\n*NpyIter_GetInnerStrideArray( *iter)\n```", "```py\n*NpyIter_GetInnerLoopSizePtr( *iter)\n```", "```py\nvoid NpyIter_GetInnerFixedStrideArray( *iter, *out_strides)\n```", "```py\nnpy_intp  PyArray_CountNonzero(PyArrayObject*  self)\n{\n  /* Nonzero boolean function */\n  PyArray_NonzeroFunc*  nonzero  =  PyArray_DESCR(self)->f->nonzero;\n\n  NpyIter*  iter;\n  NpyIter_IterNextFunc  *iternext;\n  char**  dataptr;\n  npy_intp  nonzero_count;\n  npy_intp*  strideptr,*  innersizeptr;\n\n  /* Handle zero-sized arrays specially */\n  if  (PyArray_SIZE(self)  ==  0)  {\n  return  0;\n  }\n\n  /*\n * Create and use an iterator to count the nonzeros.\n *   flag NPY_ITER_READONLY\n *     - The array is never written to.\n *   flag NPY_ITER_EXTERNAL_LOOP\n *     - Inner loop is done outside the iterator for efficiency.\n *   flag NPY_ITER_NPY_ITER_REFS_OK\n *     - Reference types are acceptable.\n *   order NPY_KEEPORDER\n *     - Visit elements in memory order, regardless of strides.\n *       This is good for performance when the specific order\n *       elements are visited is unimportant.\n *   casting NPY_NO_CASTING\n *     - No casting is required for this operation.\n */\n  iter  =  NpyIter_New(self,  NPY_ITER_READONLY|\n  NPY_ITER_EXTERNAL_LOOP|\n  NPY_ITER_REFS_OK,\n  NPY_KEEPORDER,  NPY_NO_CASTING,\n  NULL);\n  if  (iter  ==  NULL)  {\n  return  -1;\n  }\n\n  /*\n * The iternext function gets stored in a local variable\n * so it can be called repeatedly in an efficient manner.\n */\n  iternext  =  NpyIter_GetIterNext(iter,  NULL);\n  if  (iternext  ==  NULL)  {\n  NpyIter_Deallocate(iter);\n  return  -1;\n  }\n  /* The location of the data pointer which the iterator may update */\n  dataptr  =  NpyIter_GetDataPtrArray(iter);\n  /* The location of the stride which the iterator may update */\n  strideptr  =  NpyIter_GetInnerStrideArray(iter);\n  /* The location of the inner loop size which the iterator may update */\n  innersizeptr  =  NpyIter_GetInnerLoopSizePtr(iter);\n\n  nonzero_count  =  0;\n  do  {\n  /* Get the inner loop data/stride/count values */\n  char*  data  =  *dataptr;\n  npy_intp  stride  =  *strideptr;\n  npy_intp  count  =  *innersizeptr;\n\n  /* This is a typical inner loop for NPY_ITER_EXTERNAL_LOOP */\n  while  (count--)  {\n  if  (nonzero(data,  self))  {\n  ++nonzero_count;\n  }\n  data  +=  stride;\n  }\n\n  /* Increment the iterator to the next inner loop */\n  }  while(iternext(iter));\n\n  NpyIter_Deallocate(iter);\n\n  return  nonzero_count;\n} \n```", "```py\nPyObject  *CopyArray(PyObject  *arr,  NPY_ORDER  order)\n{\n  NpyIter  *iter;\n  NpyIter_IterNextFunc  *iternext;\n  PyObject  *op[2],  *ret;\n  npy_uint32  flags;\n  npy_uint32  op_flags[2];\n  npy_intp  itemsize,  *innersizeptr,  innerstride;\n  char  **dataptrarray;\n\n  /*\n * No inner iteration - inner loop is handled by CopyArray code\n */\n  flags  =  NPY_ITER_EXTERNAL_LOOP;\n  /*\n * Tell the constructor to automatically allocate the output.\n * The data type of the output will match that of the input.\n */\n  op[0]  =  arr;\n  op[1]  =  NULL;\n  op_flags[0]  =  NPY_ITER_READONLY;\n  op_flags[1]  =  NPY_ITER_WRITEONLY  |  NPY_ITER_ALLOCATE;\n\n  /* Construct the iterator */\n  iter  =  NpyIter_MultiNew(2,  op,  flags,  order,  NPY_NO_CASTING,\n  op_flags,  NULL);\n  if  (iter  ==  NULL)  {\n  return  NULL;\n  }\n\n  /*\n * Make a copy of the iternext function pointer and\n * a few other variables the inner loop needs.\n */\n  iternext  =  NpyIter_GetIterNext(iter,  NULL);\n  innerstride  =  NpyIter_GetInnerStrideArray(iter)[0];\n  itemsize  =  NpyIter_GetDescrArray(iter)[0]->elsize;\n  /*\n * The inner loop size and data pointers may change during the\n * loop, so just cache the addresses.\n */\n  innersizeptr  =  NpyIter_GetInnerLoopSizePtr(iter);\n  dataptrarray  =  NpyIter_GetDataPtrArray(iter);\n\n  /*\n * Note that because the iterator allocated the output,\n * it matches the iteration order and is packed tightly,\n * so we don't need to check it like the input.\n */\n  if  (innerstride  ==  itemsize)  {\n  do  {\n  memcpy(dataptrarray[1],  dataptrarray[0],\n  itemsize  *  (*innersizeptr));\n  }  while  (iternext(iter));\n  }  else  {\n  /* For efficiency, should specialize this based on item size... */\n  npy_intp  i;\n  do  {\n  npy_intp  size  =  *innersizeptr;\n  char  *src  =  dataptrarray[0],  *dst  =  dataptrarray[1];\n  for(i  =  0;  i  <  size;  i++,  src  +=  innerstride,  dst  +=  itemsize)  {\n  memcpy(dst,  src,  itemsize);\n  }\n  }  while  (iternext(iter));\n  }\n\n  /* Get the result from the iterator object array */\n  ret  =  NpyIter_GetOperandArray(iter)[1];\n  Py_INCREF(ret);\n\n  if  (NpyIter_Deallocate(iter)  !=  NPY_SUCCEED)  {\n  Py_DECREF(ret);\n  return  NULL;\n  }\n\n  return  ret;\n} \n```", "```py\nint  PrintMultiIndex(PyArrayObject  *arr)  {\n  NpyIter  *iter;\n  NpyIter_IterNextFunc  *iternext;\n  npy_intp  multi_index[2];\n\n  iter  =  NpyIter_New(\n  arr,  NPY_ITER_READONLY  |  NPY_ITER_MULTI_INDEX  |  NPY_ITER_REFS_OK,\n  NPY_KEEPORDER,  NPY_NO_CASTING,  NULL);\n  if  (iter  ==  NULL)  {\n  return  -1;\n  }\n  if  (NpyIter_GetNDim(iter)  !=  2)  {\n  NpyIter_Deallocate(iter);\n  PyErr_SetString(PyExc_ValueError,  \"Array must be 2-D\");\n  return  -1;\n  }\n  if  (NpyIter_GetIterSize(iter)  !=  0)  {\n  iternext  =  NpyIter_GetIterNext(iter,  NULL);\n  if  (iternext  ==  NULL)  {\n  NpyIter_Deallocate(iter);\n  return  -1;\n  }\n  NpyIter_GetMultiIndexFunc  *get_multi_index  =\n  NpyIter_GetGetMultiIndex(iter,  NULL);\n  if  (get_multi_index  ==  NULL)  {\n  NpyIter_Deallocate(iter);\n  return  -1;\n  }\n\n  do  {\n  get_multi_index(iter,  multi_index);\n  printf(\"multi_index is [%\"  NPY_INTP_FMT  \", %\"  NPY_INTP_FMT  \"]\\n\",\n  multi_index[0],  multi_index[1]);\n  }  while  (iternext(iter));\n  }\n  if  (!NpyIter_Deallocate(iter))  {\n  return  -1;\n  }\n  return  0;\n} \n```", "```py\nmulti_index  is  [0,  0]\nmulti_index  is  [0,  1]\nmulti_index  is  [0,  2]\nmulti_index  is  [1,  0]\nmulti_index  is  [1,  1]\nmulti_index  is  [1,  2] \n```", "```py\ntype NpyIter\n```", "```py\ntype NpyIter_Type\n```", "```py\ntype NpyIter_IterNextFunc\n```", "```py\ntype NpyIter_GetMultiIndexFunc\n```", "```py\n*NpyIter_New( *op, flags, order, casting, *dtype)\n```", "```py\niter  =  NpyIter_New(op,  NPY_ITER_READWRITE,\n  NPY_CORDER,  NPY_NO_CASTING,  NULL); \n```", "```py\ndtype  =  PyArray_DescrFromType(NPY_DOUBLE);\niter  =  NpyIter_New(op,  NPY_ITER_READWRITE|\n  NPY_ITER_BUFFERED|\n  NPY_ITER_NBO|\n  NPY_ITER_ALIGNED,\n  NPY_KEEPORDER,\n  NPY_SAME_KIND_CASTING,\n  dtype);\nPy_DECREF(dtype); \n```", "```py\n*NpyIter_MultiNew( nop, **op, flags, order, casting, *op_flags, **op_dtypes)\n```", "```py\nNPY_ITER_C_INDEX\n```", "```py\nNPY_ITER_F_INDEX\n```", "```py\nNPY_ITER_MULTI_INDEX\n```", "```py\nNPY_ITER_EXTERNAL_LOOP\n```", "```py\nNPY_ITER_DONT_NEGATE_STRIDES\n```", "```py\nNPY_ITER_COMMON_DTYPE\n```", "```py\nNPY_ITER_REFS_OK\n```", "```py\nNPY_ITER_ZEROSIZE_OK\n```", "```py\nNPY_ITER_REDUCE_OK\n```", "```py\nNPY_ITER_RANGED\n```", "```py\nNPY_ITER_BUFFERED\n```", "```py\nNPY_ITER_GROWINNER\n```", "```py\nNPY_ITER_DELAY_BUFALLOC\n```", "```py\nNPY_ITER_COPY_IF_OVERLAP\n```", "```py\nNPY_ITER_READWRITE\n```", "```py\nNPY_ITER_READONLY\n```", "```py\nNPY_ITER_WRITEONLY\n```", "```py\nNPY_ITER_COPY\n```", "```py\nNPY_ITER_UPDATEIFCOPY\n```", "```py\nNPY_ITER_NBO\n```", "```py\nNPY_ITER_ALIGNED\n```", "```py\nNPY_ITER_CONTIG\n```", "```py\nNPY_ITER_ALLOCATE\n```", "```py\nNPY_ITER_NO_SUBTYPE\n```", "```py\nNPY_ITER_NO_BROADCAST\n```", "```py\nNPY_ITER_ARRAYMASK\n```", "```py\nNPY_ITER_WRITEMASKED\n```", "```py\nNPY_ITER_OVERLAP_ASSUME_ELEMENTWISE\n```", "```py\n*NpyIter_AdvancedNew( nop, **op, flags, order, casting, *op_flags, **op_dtypes, int oa_ndim, int **op_axes, const *itershape, buffersize)\n```", "```py\nint  oa_ndim  =  3;  /* # iteration axes */\nint  op0_axes[]  =  {0,  1,  2};  /* 3-D operand */\nint  op1_axes[]  =  {-1,  0,  1};  /* 2-D operand */\nint  op2_axes[]  =  {-1,  -1,  0};  /* 1-D operand */\nint  op3_axes[]  =  {-1,  -1,  -1}  /* 0-D (scalar) operand */\nint*  op_axes[]  =  {op0_axes,  op1_axes,  op2_axes,  op3_axes}; \n```", "```py\n*NpyIter_Copy( *iter)\n```", "```py\nint NpyIter_RemoveAxis( *iter, int axis)\n```", "```py\nint NpyIter_RemoveMultiIndex( *iter)\n```", "```py\nint NpyIter_EnableExternalLoop( *iter)\n```", "```py\nint NpyIter_Deallocate( *iter)\n```", "```py\nint NpyIter_Reset( *iter, char **errmsg)\n```", "```py\nint NpyIter_ResetToIterIndexRange( *iter, istart, iend, char **errmsg)\n```", "```py\n/* Set to a trivial empty range */\nNpyIter_ResetToIterIndexRange(iter,  0,  0);\n/* Set the base pointers */\nNpyIter_ResetBasePointers(iter,  baseptrs);\n/* Set to the desired range */\nNpyIter_ResetToIterIndexRange(iter,  istart,  iend); \n```", "```py\nint NpyIter_ResetBasePointers( *iter, char **baseptrs, char **errmsg)\n```", "```py\nNpyIter  *iter1,  *iter1;\nNpyIter_IterNextFunc  *iternext1,  *iternext2;\nchar  **dataptrs1;\n\n/*\n * With the exact same operands, no copies allowed, and\n * no axis in op_axes used both in iter1 and iter2.\n * Buffering may be enabled for iter2, but not for iter1.\n */\niter1  =  ...;  iter2  =  ...;\n\niternext1  =  NpyIter_GetIterNext(iter1);\niternext2  =  NpyIter_GetIterNext(iter2);\ndataptrs1  =  NpyIter_GetDataPtrArray(iter1);\n\ndo  {\n  NpyIter_ResetBasePointers(iter2,  dataptrs1);\n  do  {\n  /* Use the iter2 values */\n  }  while  (iternext2(iter2));\n}  while  (iternext1(iter1)); \n```", "```py\nint NpyIter_GotoMultiIndex( *iter, const *multi_index)\n```", "```py\nint NpyIter_GotoIndex( *iter, index)\n```", "```py\nNpyIter_GetIterSize( *iter)\n```", "```py\nNpyIter_GetIterIndex( *iter)\n```", "```py\nvoid NpyIter_GetIterIndexRange( *iter, *istart, *iend)\n```", "```py\nint NpyIter_GotoIterIndex( *iter, iterindex)\n```", "```py\nNpyIter_HasDelayedBufAlloc( *iter)\n```", "```py\nNpyIter_HasExternalLoop( *iter)\n```", "```py\nNpyIter_HasMultiIndex( *iter)\n```", "```py\nNpyIter_HasIndex( *iter)\n```", "```py\nNpyIter_RequiresBuffering( *iter)\n```", "```py\nNpyIter_IsBuffered( *iter)\n```", "```py\nNpyIter_IsGrowInner( *iter)\n```", "```py\nNpyIter_GetBufferSize( *iter)\n```", "```py\nint NpyIter_GetNDim( *iter)\n```", "```py\nint NpyIter_GetNOp( *iter)\n```", "```py\n*NpyIter_GetAxisStrideArray( *iter, int axis)\n```", "```py\nint NpyIter_GetShape( *iter, *outshape)\n```", "```py\n**NpyIter_GetDescrArray( *iter)\n```", "```py\n**NpyIter_GetOperandArray( *iter)\n```", "```py\n*NpyIter_GetIterView( *iter, i)\n```", "```py\nvoid NpyIter_GetReadFlags( *iter, char *outreadflags)\n```", "```py\nvoid NpyIter_GetWriteFlags( *iter, char *outwriteflags)\n```", "```py\nint NpyIter_CreateCompatibleStrides( *iter, itemsize, *outstrides)\n```", "```py\nNpyIter_IsFirstVisit( *iter, int iop)\n```", "```py\n*NpyIter_GetIterNext( *iter, char **errmsg)\n```", "```py\nNpyIter_IterNextFunc  *iternext  =  NpyIter_GetIterNext(iter,  NULL);\nchar**  dataptr  =  NpyIter_GetDataPtrArray(iter);\n\ndo  {\n  /* use the addresses dataptr[0], ... dataptr[nop-1] */\n}  while(iternext(iter)); \n```", "```py\nNpyIter_IterNextFunc  *iternext  =  NpyIter_GetIterNext(iter,  NULL);\nchar**  dataptr  =  NpyIter_GetDataPtrArray(iter);\nnpy_intp*  stride  =  NpyIter_GetInnerStrideArray(iter);\nnpy_intp*  size_ptr  =  NpyIter_GetInnerLoopSizePtr(iter),  size;\nnpy_intp  iop,  nop  =  NpyIter_GetNOp(iter);\n\ndo  {\n  size  =  *size_ptr;\n  while  (size--)  {\n  /* use the addresses dataptr[0], ... dataptr[nop-1] */\n  for  (iop  =  0;  iop  <  nop;  ++iop)  {\n  dataptr[iop]  +=  stride[iop];\n  }\n  }\n}  while  (iternext()); \n```", "```py\n/* The constructor should have buffersize passed as this value */\n#define FIXED_BUFFER_SIZE 1024\n\nNpyIter_IterNextFunc  *iternext  =  NpyIter_GetIterNext(iter,  NULL);\nchar  **dataptr  =  NpyIter_GetDataPtrArray(iter);\nnpy_intp  *stride  =  NpyIter_GetInnerStrideArray(iter);\nnpy_intp  *size_ptr  =  NpyIter_GetInnerLoopSizePtr(iter),  size;\nnpy_intp  i,  iop,  nop  =  NpyIter_GetNOp(iter);\n\n/* One loop with a fixed inner size */\nsize  =  *size_ptr;\nwhile  (size  ==  FIXED_BUFFER_SIZE)  {\n  /*\n * This loop could be manually unrolled by a factor\n * which divides into FIXED_BUFFER_SIZE\n */\n  for  (i  =  0;  i  <  FIXED_BUFFER_SIZE;  ++i)  {\n  /* use the addresses dataptr[0], ... dataptr[nop-1] */\n  for  (iop  =  0;  iop  <  nop;  ++iop)  {\n  dataptr[iop]  +=  stride[iop];\n  }\n  }\n  iternext();\n  size  =  *size_ptr;\n}\n\n/* Finish-up loop with variable inner size */\nif  (size  >  0)  do  {\n  size  =  *size_ptr;\n  while  (size--)  {\n  /* use the addresses dataptr[0], ... dataptr[nop-1] */\n  for  (iop  =  0;  iop  <  nop;  ++iop)  {\n  dataptr[iop]  +=  stride[iop];\n  }\n  }\n}  while  (iternext()); \n```", "```py\n*NpyIter_GetGetMultiIndex( *iter, char **errmsg)\n```", "```py\nchar **NpyIter_GetDataPtrArray( *iter)\n```", "```py\nchar **NpyIter_GetInitialDataPtrArray( *iter)\n```", "```py\n*NpyIter_GetIndexPtr( *iter)\n```", "```py\n*NpyIter_GetInnerStrideArray( *iter)\n```", "```py\n*NpyIter_GetInnerLoopSizePtr( *iter)\n```", "```py\nvoid NpyIter_GetInnerFixedStrideArray( *iter, *out_strides)\n```"]