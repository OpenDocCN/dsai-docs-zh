- en: Simplify
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简化
- en: Original text：[https://docs.sympy.org/latest/modules/simplify/simplify.html](https://docs.sympy.org/latest/modules/simplify/simplify.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/modules/simplify/simplify.html](https://docs.sympy.org/latest/modules/simplify/simplify.html)
- en: '[PRE0]'
  id: totrans-2
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Simplifies the given expression.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 简化给定的表达式。
- en: Explanation
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Simplification is not a well defined term and the exact strategies this function
    tries can change in the future versions of SymPy. If your algorithm relies on
    “simplification” (whatever it is), try to determine what you need exactly - is
    it powsimp()?, radsimp()?, together()?, logcombine()?, or something else? And
    use this particular function directly, because those are well defined and thus
    your algorithm will be robust.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 简化并不是一个明确定义的术语，而且此函数尝试的确切策略可能会在SymPy的未来版本中改变。如果你的算法依赖于“简化”（无论是什么），请尝试确定你确切需要什么
    - 是`powsimp()`？`radsimp()`？`together()`？`logcombine()`？还是其他什么？然后直接使用这个特定的函数，因为这些都是明确定义的，因此你的算法将更加健壮。
- en: 'Nonetheless, especially for interactive use, or when you do not know anything
    about the structure of the expression, simplify() tries to apply intelligent heuristics
    to make the input expression “simpler”. For example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，特别是对于交互式使用或者当你对表达式的结构一无所知时，`simplify()`会尝试应用智能启发式方法使输入表达式“更简单”。例如：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note that we could have obtained the same result by using specific simplification
    functions:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们可以通过使用特定的简化函数获得相同的结果：
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In some cases, applying [`simplify()`](#sympy.simplify.simplify.simplify "sympy.simplify.simplify.simplify")
    may actually result in some more complicated expression. The default `ratio=1.7`
    prevents more extreme cases: if (result length)/(input length) > ratio, then input
    is returned unmodified. The `measure` parameter lets you specify the function
    used to determine how complex an expression is. The function should take a single
    argument as an expression and return a number such that if expression `a` is more
    complex than expression `b`, then `measure(a) > measure(b)`. The default measure
    function is [`count_ops()`](../core.html#sympy.core.function.count_ops "sympy.core.function.count_ops"),
    which returns the total number of operations in the expression.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，应用[`simplify()`](#sympy.simplify.simplify.simplify "sympy.simplify.simplify.simplify")实际上可能会导致一些更复杂的表达式。默认情况下，`ratio=1.7`防止更极端的情况：如果（结果长度）/（输入长度）>
    ratio，则返回未修改的输入。`measure`参数允许您指定用于确定表达式复杂性的函数。该函数应接受一个表达式作为唯一参数，并返回一个数字，以便如果表达式`a`比表达式`b`更复杂，则`measure(a)
    > measure(b)`。默认的度量函数是[`count_ops()`](../core.html#sympy.core.function.count_ops
    "sympy.core.function.count_ops")，它返回表达式中操作的总数。
- en: For example, if `ratio=1`, `simplify` output cannot be longer than input.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果`ratio=1`，`simplify`的输出不能比输入更长。
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Since `simplify(root)` would result in a slightly longer expression, root is
    returned unchanged instead:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`simplify(root)`会导致略长一些的表达式，所以root将原样返回：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If `ratio=oo`, simplify will be applied anyway:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ratio=oo`，简化将无论如何被应用：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the shortest expression is not necessary the simplest, so setting
    `ratio` to 1 may not be a good idea. Heuristically, the default value `ratio=1.7`
    seems like a reasonable choice.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最短的表达式未必是最简单的，因此将`ratio`设置为1可能并不是一个好主意。从启发式的角度来看，默认值`ratio=1.7`似乎是一个合理的选择。
- en: 'You can easily define your own measure function based on what you feel should
    represent the “size” or “complexity” of the input expression. Note that some choices,
    such as `lambda expr: len(str(expr))` may appear to be good metrics, but have
    other problems (in this case, the measure function may slow down simplify too
    much for very large expressions). If you do not know what a good metric would
    be, the default, `count_ops`, is a good one.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '您可以根据您认为应该表示输入表达式的“大小”或“复杂性”的内容轻松定义自己的度量函数。请注意，某些选择，例如`lambda expr: len(str(expr))`可能看起来是良好的度量标准，但可能存在其他问题（在这种情况下，度量函数可能会因非常大的表达式而使简化变慢）。如果您不知道什么是一个好的度量标准，那么默认的`count_ops`是一个不错的选择。'
- en: 'For example:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE6]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'So you can see that `h` is simpler than `g` using the count_ops metric. However,
    we may not like how `simplify` (in this case, using `logcombine`) has created
    the `b**(log(1/a) + 1)` term. A simple way to reduce this would be to give more
    weight to powers as operations in `count_ops`. We can do this by using the `visual=True`
    option:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以看到，使用`count_ops`度量标准时，`h`比`g`更简单。然而，我们可能不喜欢`简化`（在这种情况下，使用`logcombine`）如何创建了`b**(log(1/a)
    + 1)`项。减少这种情况的简单方法是在`count_ops`中给予幂运算更多的权重。我们可以通过使用`visual=True`选项来实现这一点：
- en: '[PRE7]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that because `simplify()` internally tries many different simplification
    strategies and then compares them using the measure function, we get a completely
    different result that is still different from the input expression by doing this.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，因为`simplify()`内部尝试许多不同的简化策略，然后使用度量函数进行比较，所以通过这种方式得到一个完全不同的结果，仍然与输入表达式不同。
- en: If `rational=True`, Floats will be recast as Rationals before simplification.
    If `rational=None`, Floats will be recast as Rationals but the result will be
    recast as Floats. If rational=False(default) then nothing will be done to the
    Floats.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `rational=True`，则在简化之前，浮点数将重新转换为有理数。如果 `rational=None`，则浮点数将转换为有理数，但结果将重新转换为浮点数。如果
    `rational=False`（默认值），则浮点数将不做任何处理。
- en: If `inverse=True`, it will be assumed that a composition of inverse functions,
    such as sin and asin, can be cancelled in any order. For example, `asin(sin(x))`
    will yield `x` without checking whether x belongs to the set where this relation
    is true. The default is False.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `inverse=True`，将假定可以按任意顺序取消反函数的组合，例如，`asin(sin(x))`将返回 `x`，而不检查 x 是否属于此关系为真的集合。默认值为
    False。
- en: Note that `simplify()` automatically calls `doit()` on the final expression.
    You can avoid this behavior by passing `doit=False` as an argument.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`simplify()`会自动在最终表达式上调用 `doit()`。可以通过传递 `doit=False` 参数来避免这种行为。
- en: Also, it should be noted that simplifying a boolean expression is not well defined.
    If the expression prefers automatic evaluation (such as [`Eq()`](../core.html#sympy.core.relational.Eq
    "sympy.core.relational.Eq") or [`Or()`](../logic.html#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")),
    simplification will return `True` or `False` if truth value can be determined.
    If the expression is not evaluated by default (such as [`Predicate()`](../assumptions/assume.html#sympy.assumptions.assume.Predicate
    "sympy.assumptions.assume.Predicate")), simplification will not reduce it and
    you should use [`refine()`](../assumptions/refine.html#sympy.assumptions.refine.refine
    "sympy.assumptions.refine.refine") or [`ask()`](../assumptions/ask.html#sympy.assumptions.ask.ask
    "sympy.assumptions.ask.ask") function. This inconsistency will be resolved in
    future version.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，应注意简化布尔表达式并不是完全定义良好的。如果表达式偏向于自动评估（例如 [`Eq()`](../core.html#sympy.core.relational.Eq
    "sympy.core.relational.Eq") 或 [`Or()`](../logic.html#sympy.logic.boolalg.Or "sympy.logic.boolalg.Or")），简化将返回
    `True` 或 `False`，如果可以确定其真值。如果表达式默认不被评估（例如 [`Predicate()`](../assumptions/assume.html#sympy.assumptions.assume.Predicate
    "sympy.assumptions.assume.Predicate")），简化将不会减少它，并且您应该使用 [`refine()`](../assumptions/refine.html#sympy.assumptions.refine.refine
    "sympy.assumptions.refine.refine") 或 [`ask()`](../assumptions/ask.html#sympy.assumptions.ask.ask
    "sympy.assumptions.ask.ask") 函数。此不一致性将在将来版本中解决。
- en: See also
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 见也
- en: '[`sympy.assumptions.refine.refine`](../assumptions/refine.html#sympy.assumptions.refine.refine
    "sympy.assumptions.refine.refine")'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.assumptions.refine.refine`](../assumptions/refine.html#sympy.assumptions.refine.refine
    "sympy.assumptions.refine.refine")'
- en: Simplification using assumptions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用假设进行简化。
- en: '[`sympy.assumptions.ask.ask`](../assumptions/ask.html#sympy.assumptions.ask.ask
    "sympy.assumptions.ask.ask")'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.assumptions.ask.ask`](../assumptions/ask.html#sympy.assumptions.ask.ask
    "sympy.assumptions.ask.ask")'
- en: Query for boolean expressions using assumptions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使用假设查询布尔表达式。
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Separates variables in an expression, if possible. By default, it separates
    with respect to all symbols in an expression and collects constant coefficients
    that are independent of symbols.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，分离表达式中的变量。默认情况下，它会根据表达式中的所有符号进行分离，并收集与符号无关的常数系数。
- en: Explanation
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: If `dict=True` then the separated terms will be returned in a dictionary keyed
    to their corresponding symbols. By default, all symbols in the expression will
    appear as keys; if symbols are provided, then all those symbols will be used as
    keys, and any terms in the expression containing other symbols or non-symbols
    will be returned keyed to the string ‘coeff’. (Passing None for symbols will return
    the expression in a dictionary keyed to ‘coeff’.)
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `dict=True`，则分离的项将以符号为键返回为字典。默认情况下，表达式中的所有符号都会出现为键；如果提供了符号，则所有这些符号将被用作键，表达式中包含其他符号或非符号的任何项将以字符串
    `'coeff'` 为键返回。（对于符号为 None 的情况，将返回以 `'coeff'` 为键的表达式字典。）
- en: If `force=True`, then bases of powers will be separated regardless of assumptions
    on the symbols involved.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `force=True`，则会分离幂的基数，而不考虑所涉及符号的假设。
- en: Notes
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The order of the factors is determined by Mul, so that the separated expressions
    may not necessarily be grouped together.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，因为乘法的顺序由 `Mul` 决定，分离的表达式可能不一定被分组在一起。
- en: Although factoring is necessary to separate variables in some expressions, it
    is not necessary in all cases, so one should not count on the returned factors
    being factored.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在某些表达式中分解是必要的以分离变量，但并非所有情况都需要，因此不应指望返回的因子是分解的。
- en: Examples
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If the expression is not really separable, or is only partially separable, separatevars
    will do the best it can to separate it by using factoring.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式实际上不可分离，或者仅部分可分离，则 separatevars 将尽力使用分解进行分离。
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If the expression is not separable then expr is returned unchanged or (if dict=True)
    then None is returned.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式不可分离，则返回未更改的 expr 或（如果 dict=True）则返回 None。
- en: '[PRE13]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Compute a real nth-root of a sum of surds.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 计算和的根号的实数第 n 次根。
- en: 'Parameters:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**expr** : sum of surds'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr**：根号和的和'
- en: '**n** : integer'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**n**：整数'
- en: '**max_len** : maximum number of surds passed as constants to `nsimplify`'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**max_len**：作为常数传递给 `nsimplify` 的根号的最大数目'
- en: Algorithm
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 算法
- en: First `nsimplify` is used to get a candidate root; if it is not a root the minimal
    polynomial is computed; the answer is one of its roots.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用 `nsimplify` 获取一个候选根；如果它不是根，则计算最小多项式；答案是其根之一。
- en: Examples
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Simplify expressions with KroneckerDelta.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 用 KroneckerDelta 简化表达式。
- en: 'The only simplification currently attempted is to identify multiplicative cancellation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当前尝试的唯一简化是识别乘法取消：
- en: Examples
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Simplify bessel-type functions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 简化贝塞尔类型函数。
- en: Explanation
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This routine tries to simplify bessel-type functions. Currently it only works
    on the Bessel J and I functions, however. It works by looking at all such functions
    in turn, and eliminating factors of “I” and “-1” (actually their polar equivalents)
    in front of the argument. Then, functions of half-integer order are rewritten
    using trigonometric functions and functions of integer order (> 1) are rewritten
    using functions of low order. Finally, if the expression was changed, compute
    factorization of the result with factor().
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此例程试图简化贝塞尔类型函数。目前仅适用于 Bessel J 和 I 函数，然而。它通过依次查看所有这样的函数，并消除参数前的 “I” 和 “-1” 的因子（实际上是它们的极坐标等效物）。然后，使用三角函数重写半整数阶的函数，并使用低阶函数重写整数阶（>
    1）的函数。最后，如果表达式已更改，则使用 factor() 计算结果的因式分解。
- en: '[PRE19]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Given combinatorial term f(k) simplify its consecutive term ratio i.e. f(k+1)/f(k).
    The input term can be composed of functions and integer sequences which have equivalent
    representation in terms of gamma special function.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 给定组合项 f(k)，简化其连续项比率即 f(k+1)/f(k)。输入项可以由具有 gamma 特殊函数等效表示的函数和整数序列组成。
- en: Explanation
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'The algorithm performs three basic steps:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法执行三个基本步骤：
- en: Rewrite all functions in terms of gamma, if possible.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽可能用 gamma 重写所有函数。
- en: Rewrite all occurrences of gamma in terms of products of gamma and rising factorial
    with integer, absolute constant exponent.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用整数、绝对常数指数的 gamma 的乘积重写所有 gamma 的出现。
- en: Perform simplification of nested fractions, powers and if the resulting expression
    is a quotient of polynomials, reduce their total degree.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于嵌套分数、幂的简化操作，如果结果表达式是多项式的商，则减少它们的总次数。
- en: If f(k) is hypergeometric then as result we arrive with a quotient of polynomials
    of minimal degree. Otherwise None is returned.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 f(k) 是超几何的，则结果是最小次数的多项式商。否则返回 None。
- en: 'For more information on the implemented algorithm refer to:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 有关实现算法的更多信息，请参考：
- en: W. Koepf, Algorithms for m-fold Hypergeometric Summation, Journal of Symbolic
    Computation (1995) 20, 399-417
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: W. Koepf，《m倍超几何求和的算法》，符号计算杂志（1995）20，399-417
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Returns True if `f` and `g` are hyper-similar.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `f` 和 `g` 是超相似的，则返回 True。
- en: Explanation
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Similarity in hypergeometric sense means that a quotient of f(k) and g(k) is
    a rational function in `k`. This procedure is useful in solving recurrence relations.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 超几何意义上的相似性意味着 f(k) 和 g(k) 的商是 `k` 的有理函数。这个过程在解决递推关系中很有用。
- en: For more information see hypersimp().
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有关详细信息，请参见 hypersimp()。
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Find a simple representation for a number or, if there are free symbols or if
    `rational=True`, then replace Floats with their Rational equivalents. If no change
    is made and rational is not False then Floats will at least be converted to Rationals.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为一个数字找到简单的表示，或者如果存在自由符号或者 `rational=True`，则用它们的有理数等价物替换 Floats。如果没有更改且 rational
    不为 False，则 Floats 将至少被转换为 Rationals。
- en: Explanation
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: For numerical expressions, a simple formula that numerically matches the given
    numerical expression is sought (and the input should be possible to evalf to a
    precision of at least 30 digits).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数值表达式，寻找一个能够数值匹配给定数值表达式的简单公式（输入应至少能够 `evalf` 到30位精度）。
- en: Optionally, a list of (rationally independent) constants to include in the formula
    may be given.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，可以给出包含在公式中的（有理数独立的）常数列表。
- en: A lower tolerance may be set to find less exact matches. If no tolerance is
    given then the least precise value will set the tolerance (e.g. Floats default
    to 15 digits of precision, so would be tolerance=10**-15).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以设置更低的容差来寻找不那么精确的匹配。如果未给出容差，则最不精确的值将设置容差（例如，浮点数默认精度为15位数字，因此容差为10**-15）。
- en: With `full=True`, a more extensive search is performed (this is useful to find
    simpler numbers when the tolerance is set low).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `full=True` 进行更广泛的搜索（当设置容差较低时寻找更简单的数字非常有用）。
- en: When converting to rational, if rational_conversion=’base10’ (the default),
    then convert floats to rationals using their base-10 (string) representation.
    When rational_conversion=’exact’ it uses the exact, base-2 representation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换为有理数时，如果 `rational_conversion='base10'`（默认），则使用其基于十进制的浮点数表示来转换浮点数为有理数。当 `rational_conversion='exact'`
    时，则使用精确的基于二进制的表示来转换。
- en: Examples
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE23]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`sympy.core.function.nfloat`](../core.html#sympy.core.function.nfloat "sympy.core.function.nfloat")'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.function.nfloat`](../core.html#sympy.core.function.nfloat "sympy.core.function.nfloat")'
- en: '[PRE25]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Return `eq` (with generic symbols made positive) and a dictionary containing
    the mapping between the old and new symbols.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 返回 `eq`（使通用符号变为正的）和包含旧符号与新符号映射的字典。
- en: Explanation
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Any symbol that has positive=None will be replaced with a positive dummy symbol
    having the same name. This replacement will allow more symbolic processing of
    expressions, especially those involving powers and logarithms.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有 `positive=None` 的符号将被替换为具有相同名称的正虚拟符号。这种替换将允许更多的符号处理表达式，特别是涉及幂次和对数的表达式。
- en: A dictionary that can be sent to subs to restore `eq` to its original symbols
    is also returned.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 还返回一个可以发送到 `subs` 以将 `eq` 恢复为其原始符号的字典。
- en: '[PRE26]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'It is possible to apply the same transformations to an iterable of expressions:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对表达式的可迭代项应用相同的转换方法：
- en: '[PRE28]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Takes logarithms and combines them using the following rules:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下规则取对数并将它们结合起来：
- en: log(x) + log(y) == log(x*y) if both are positive
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果两者均为正，则 `log(x) + log(y) == log(x*y)`。
- en: a*log(x) == log(x**a) if x is positive and a is real
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `x` 是正数且 `a` 是实数，则 `a*log(x) == log(x**a)`。
- en: If `force` is `True` then the assumptions above will be assumed to hold if there
    is no assumption already in place on a quantity. For example, if `a` is imaginary
    or the argument negative, force will not perform a combination but if `a` is a
    symbol with no assumptions the change will take place.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `force` 是 `True`，则假设以上假设将被认为在数量上不存在任何假设的情况下成立。例如，如果 `a` 是虚数或参数为负数，则 `force`
    不会执行组合；但如果 `a` 是一个没有假设的符号，则变化将发生。
- en: Examples
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The transformation is limited to factors and/or terms that contain logs, so
    the result depends on the initial state of expansion:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 转换仅限于包含对数的因子和/或项，因此结果取决于展开的初始状态：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`posify`](#sympy.simplify.simplify.posify "sympy.simplify.simplify.posify")'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[`posify`](#sympy.simplify.simplify.posify "sympy.simplify.simplify.posify")'
- en: replace all symbols with symbols having positive assumptions
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 用具有正假设的符号替换所有符号。
- en: '[`sympy.core.function.expand_log`](../core.html#sympy.core.function.expand_log
    "sympy.core.function.expand_log")'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.core.function.expand_log`](../core.html#sympy.core.function.expand_log
    "sympy.core.function.expand_log")'
- en: expand the logarithms of products and powers; the opposite of logcombine
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 展开产品和幂的对数；与 `logcombine` 的相反操作。
- en: '[PRE32]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Rationalize the denominator by removing square roots.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过去除平方根来有理化分母。
- en: Explanation
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'The expression returned from radsimp must be used with caution since if the
    denominator contains symbols, it will be possible to make substitutions that violate
    the assumptions of the simplification process: that for a denominator matching
    a + b*sqrt(c), a != +/-b*sqrt(c). (If there are no symbols, this assumptions is
    made valid by collecting terms of sqrt(c) so the match variable `a` does not contain
    `sqrt(c)`.) If you do not want the simplification to occur for symbolic denominators,
    set `symbolic` to False.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，从`radsimp`返回的表达式必须谨慎使用，因为如果分母包含符号，可能会进行违反简化过程假设的替换：对于分母匹配`a + b*sqrt(c)`的情况，要求`a
    != +/-b*sqrt(c)`。（如果没有符号，通过收集`sqrt(c)`项来使得变量`a`不包含`sqrt(c)`来使该假设成立。）如果不希望对符号分母进行简化，请将`symbolic`设为`False`。
- en: If there are more than `max_terms` radical terms then the expression is returned
    unchanged.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果超过`max_terms`个根式项，则返回原始表达式。
- en: Examples
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE33]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'No simplification beyond removal of the gcd is done. One might want to polish
    the result a little, however, by collecting square root terms:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 除去gcd外不进行任何简化。但是，可以通过收集平方根项稍微优化结果：
- en: '[PRE35]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If radicals in the denominator cannot be removed or there is no denominator,
    the original expression will be returned.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果分母中的根式无法移除或没有分母，则将返回原始表达式。
- en: '[PRE37]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Results with symbols will not always be valid for all substitutions:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 带有符号的结果并不总是对所有替换有效：
- en: '[PRE38]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If `symbolic=False`, symbolic denominators will not be transformed (but numeric
    denominators will still be processed):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`symbolic=False`，则符号分母将不会转换（但数字分母仍将被处理）：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Rationalize `num/den` by removing square roots in the denominator; num and den
    are sum of terms whose squares are positive rationals.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过移除分母中的平方根来使`num/den`有理化；`num`和`den`是其平方是正有理数的项的和。
- en: Examples
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE41]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Collect additive terms of an expression.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 收集表达式的加法项。
- en: Explanation
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This function collects additive terms of an expression with respect to a list
    of expression up to powers with rational exponents. By the term symbol here are
    meant arbitrary expressions, which can contain powers, products, sums etc. In
    other words symbol is a pattern which will be searched for in the expression’s
    terms.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数根据表达式中的符号（术语）的列表收集表达式的加法项，直到有理指数幂为止。这里的术语符号指的是任意表达式，可以包含幂、乘积、和等。换句话说，符号是一个模式，将在表达式的术语中搜索。
- en: The input expression is not expanded by [`collect()`](#sympy.simplify.radsimp.collect
    "sympy.simplify.radsimp.collect"), so user is expected to provide an expression
    in an appropriate form. This makes [`collect()`](#sympy.simplify.radsimp.collect
    "sympy.simplify.radsimp.collect") more predictable as there is no magic happening
    behind the scenes. However, it is important to note, that powers of products are
    converted to products of powers using the [`expand_power_base()`](../core.html#sympy.core.function.expand_power_base
    "sympy.core.function.expand_power_base") function.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 输入表达式不会被[`collect()`](#sympy.simplify.radsimp.collect "sympy.simplify.radsimp.collect")扩展，因此用户应提供一个适当形式的表达式。这使得[`collect()`](#sympy.simplify.radsimp.collect
    "sympy.simplify.radsimp.collect")更加可预测，因为没有任何神奇的背后操作。然而，需要注意的是，通过[`expand_power_base()`](../core.html#sympy.core.function.expand_power_base
    "sympy.core.function.expand_power_base")函数将乘积的幂转换为幂的乘积。
- en: There are two possible types of output. First, if `evaluate` flag is set, this
    function will return an expression with collected terms or else it will return
    a dictionary with expressions up to rational powers as keys and collected coefficients
    as values.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种可能的输出类型。首先，如果设置了`evaluate`标志，则该函数将返回带有收集项的表达式，否则将返回带有直到有理幂为键的字典和收集系数为值。
- en: Examples
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE43]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This function can collect symbolic coefficients in polynomials or rational
    expressions. It will manage to find all integer or rational powers of collection
    variable:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以收集多项式或有理表达式中的符号系数。它将能够找到所有整数或有理的收集变量的幂：
- en: '[PRE44]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The same result can be achieved in dictionary form:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 结果可以以字典形式达到相同效果：
- en: '[PRE45]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You can also work with multivariate polynomials. However, remember that this
    function is greedy so it will care only about a single symbol at time, in specification
    order:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以处理多变量多项式。但请记住，此函数是贪婪的，因此它一次只关心一个符号，按照规定的顺序：
- en: '[PRE46]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Also more complicated expressions can be used as patterns:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用更复杂的表达式作为模式：
- en: '[PRE47]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'You can use wildcards in the pattern:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在模式中使用通配符：
- en: '[PRE48]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'It is also possible to work with symbolic powers, although it has more complicated
    behavior, because in this case power’s base and symbolic part of the exponent
    are treated as a single symbol:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以处理符号幂，尽管它具有更复杂的行为，因为在这种情况下，幂的基数和指数的符号部分被视为单个符号：
- en: '[PRE49]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'However if you incorporate rationals to the exponents, then you will get well
    known behavior:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果您将有理数合并到指数中，则会得到众所周知的行为：
- en: '[PRE50]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Note also that all previously stated facts about [`collect()`](#sympy.simplify.radsimp.collect
    "sympy.simplify.radsimp.collect") function apply to the exponential function,
    so you can get:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，关于 [`collect()`](#sympy.simplify.radsimp.collect "sympy.simplify.radsimp.collect")
    函数的所有先前陈述事实也适用于指数函数，因此您可以获得：
- en: '[PRE51]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'If you are interested only in collecting specific powers of some symbols then
    set `exact` flag to True:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想收集某些符号的特定幂次，则将 `exact` 标志设置为 True：
- en: '[PRE52]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If you want to collect on any object containing symbols, set `exact` to None:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要对包含符号的任何对象进行收集，请将 `exact` 设置为 None：
- en: '[PRE53]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You can also apply this function to differential equations, where derivatives
    of arbitrary order can be collected. Note that if you collect with respect to
    a function or a derivative of a function, all derivatives of that function will
    also be collected. Use `exact=True` to prevent this from happening:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将此函数应用于微分方程，其中可以收集任意阶导数。请注意，如果针对函数或函数的导数进行收集，则该函数的所有导数也将被收集。使用 `exact=True`
    可以防止此情况发生：
- en: '[PRE54]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Or you can even match both derivative order and exponent at the same time:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 或者您甚至可以同时匹配导数顺序和指数：
- en: '[PRE55]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Finally, you can apply a function to each of the collected coefficients. For
    example you can factorize symbolic coefficients of polynomial:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以对每个收集的系数应用一个函数。例如，您可以因式分解多项式的符号系数：
- en: '[PRE56]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Note
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Arguments are expected to be in expanded form, so you might have to call [`expand()`](../core.html#sympy.core.function.expand
    "sympy.core.function.expand") prior to calling this function.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 参数应当以展开形式给出，因此在调用该函数之前，可能需要调用 [`expand()`](../core.html#sympy.core.function.expand
    "sympy.core.function.expand") 函数。
- en: See also
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`collect_const`](#sympy.simplify.radsimp.collect_const "sympy.simplify.radsimp.collect_const"),
    [`collect_sqrt`](#sympy.simplify.radsimp.collect_sqrt "sympy.simplify.radsimp.collect_sqrt"),
    [`rcollect`](#sympy.simplify.radsimp.rcollect "sympy.simplify.radsimp.rcollect")'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[`collect_const`](#sympy.simplify.radsimp.collect_const "sympy.simplify.radsimp.collect_const"),
    [`collect_sqrt`](#sympy.simplify.radsimp.collect_sqrt "sympy.simplify.radsimp.collect_sqrt"),
    [`rcollect`](#sympy.simplify.radsimp.rcollect "sympy.simplify.radsimp.rcollect")'
- en: '[PRE57]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Recursively collect sums in an expression.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 递归地收集表达式中的和项。
- en: Examples
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE58]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: See also
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`collect`](#sympy.simplify.radsimp.collect "sympy.simplify.radsimp.collect"),
    [`collect_const`](#sympy.simplify.radsimp.collect_const "sympy.simplify.radsimp.collect_const"),
    [`collect_sqrt`](#sympy.simplify.radsimp.collect_sqrt "sympy.simplify.radsimp.collect_sqrt")'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[`collect`](#sympy.simplify.radsimp.collect "sympy.simplify.radsimp.collect"),
    [`collect_const`](#sympy.simplify.radsimp.collect_const "sympy.simplify.radsimp.collect_const"),
    [`collect_sqrt`](#sympy.simplify.radsimp.collect_sqrt "sympy.simplify.radsimp.collect_sqrt")'
- en: '[PRE61]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Return expr with terms having common square roots collected together. If `evaluate`
    is False a count indicating the number of sqrt-containing terms will be returned
    and, if non-zero, the terms of the Add will be returned, else the expression itself
    will be returned as a single term. If `evaluate` is True, the expression with
    any collected terms will be returned.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将具有公共平方根的项合并在一起的表达式返回。如果 `evaluate` 参数为 False，则将返回包含有平方根项的 Add 的项数，如果非零，则将返回
    Add 的项，否则将返回表达式本身作为单个项。如果 `evaluate` 参数为 True，则将返回包含任何已收集项的表达式。
- en: 'Note: since I = sqrt(-1), it is collected, too.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：因为 I = sqrt(-1)，它也被收集了。
- en: Examples
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE62]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'If evaluate is False then the arguments will be sorted and returned as a list
    and a count of the number of sqrt-containing terms will be returned:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 evaluate 参数为 False，则参数将被排序并作为列表返回，并返回包含平方根项的数量：
- en: '[PRE64]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: See also
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`collect`](#sympy.simplify.radsimp.collect "sympy.simplify.radsimp.collect"),
    [`collect_const`](#sympy.simplify.radsimp.collect_const "sympy.simplify.radsimp.collect_const"),
    [`rcollect`](#sympy.simplify.radsimp.rcollect "sympy.simplify.radsimp.rcollect")'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[`collect`](#sympy.simplify.radsimp.collect "sympy.simplify.radsimp.collect"),
    [`collect_const`](#sympy.simplify.radsimp.collect_const "sympy.simplify.radsimp.collect_const"),
    [`rcollect`](#sympy.simplify.radsimp.rcollect "sympy.simplify.radsimp.rcollect")'
- en: '[PRE65]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: A non-greedy collection of terms with similar number coefficients in an Add
    expr. If `vars` is given then only those constants will be targeted. Although
    any Number can also be targeted, if this is not desired set `Numbers=False` and
    no Float or Rational will be collected.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在Add表达式中，以非贪婪方式收集具有相似数值系数的项。如果提供了`vars`，则只会针对这些常数进行收集。尽管任何数值也可以被收集，如果不希望这样，请设置`Numbers=False`，则不会收集任何浮点数或有理数。
- en: 'Parameters:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**expr** : SymPy expression'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr** : SymPy表达式'
- en: This parameter defines the expression the expression from which terms with similar
    coefficients are to be collected. A non-Add expression is returned as it is.
  id: totrans-201
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 此参数定义了要从中收集具有相似系数的项的表达式。非Add表达式原样返回。
- en: '**vars** : variable length collection of Numbers, optional'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**vars** : 变量长度的数字集合，可选'
- en: Specifies the constants to target for collection. Can be multiple in number.
  id: totrans-203
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指定要收集的常数。可以是多个。
- en: '**Numbers** : bool'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**Numbers** : bool'
- en: Specifies to target all instance of [`sympy.core.numbers.Number`](../core.html#sympy.core.numbers.Number
    "sympy.core.numbers.Number") class. If `Numbers=False`, then no Float or Rational
    will be collected.
  id: totrans-205
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指定是否针对所有[`sympy.core.numbers.Number`](../core.html#sympy.core.numbers.Number
    "sympy.core.numbers.Number")类的实例。如果`Numbers=False`，则不会收集任何浮点数或有理数。
- en: 'Returns:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**expr** : Expr'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr** : 表达式'
- en: Returns an expression with similar coefficient terms collected.
  id: totrans-208
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回一个具有相似系数项的表达式。
- en: Examples
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE66]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The collection is sign-sensitive, giving higher precedence to the unsigned
    values:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 收集时保持符号敏感，给无符号值更高的优先级：
- en: '[PRE67]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: See also
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`collect`](#sympy.simplify.radsimp.collect "sympy.simplify.radsimp.collect"),
    [`collect_sqrt`](#sympy.simplify.radsimp.collect_sqrt "sympy.simplify.radsimp.collect_sqrt"),
    [`rcollect`](#sympy.simplify.radsimp.rcollect "sympy.simplify.radsimp.rcollect")'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[`collect`](#sympy.simplify.radsimp.collect "sympy.simplify.radsimp.collect"),
    [`collect_sqrt`](#sympy.simplify.radsimp.collect_sqrt "sympy.simplify.radsimp.collect_sqrt"),
    [`rcollect`](#sympy.simplify.radsimp.rcollect "sympy.simplify.radsimp.rcollect")'
- en: '[PRE68]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Returns a pair with expression’s numerator and denominator. If the given expression
    is not a fraction then this function will return the tuple (expr, 1).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个表达式的分子和分母。如果给定的表达式不是分数，则该函数将返回元组`(expr, 1)`。
- en: This function will not make any attempt to simplify nested fractions or to do
    any term rewriting at all.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数不会尝试简化嵌套分数或进行任何项重写。
- en: If only one of the numerator/denominator pair is needed then use numer(expr)
    or denom(expr) functions respectively.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只需要分子/分母中的一个，则分别使用`numer(expr)`或`denom(expr)`函数。
- en: '[PRE69]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This function will also work fine with assumptions:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数也可以与假设一起使用良好：
- en: '[PRE73]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If we know nothing about sign of some exponent and `exact` flag is unset, then
    the exponent’s structure will be analyzed and pretty fraction will be returned:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们对某些指数的符号一无所知，并且未设置`exact`标志，则将分析指数的结构，并返回漂亮的分数：
- en: '[PRE74]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `exact` flag will also keep any unevaluated Muls from being evaluated:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`exact`标志还将保留任何未评估的乘积：'
- en: '[PRE77]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Put an expression over a common denominator, cancel and reduce.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将表达式放置在公共分母上，取消并化简。
- en: Examples
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE79]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Simplifies a rational expression `expr` modulo the prime ideal generated by
    `G`. `G` should be a Groebner basis of the ideal.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用由`G`生成的素理想归一化有理表达式`expr`。`G`应为理想的Groebner基础。
- en: Examples
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE81]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If `polynomial` is `False`, the algorithm computes a rational simplification
    which minimizes the sum of the total degrees of the numerator and the denominator.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`polynomial`是`False`，算法计算一个有理化简，该简化最小化了分子和分母的总次数之和。
- en: If `polynomial` is `True`, this function just brings numerator and denominator
    into a canonical form. This is much faster, but has potentially worse results.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`polynomial`是`True`，该函数只将分子和分母置于标准形式中。这样做速度更快，但结果可能更差。
- en: References
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 引用
- en: '[[R855](#id1)]'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R855](#id1)]'
- en: M. Monagan, R. Pearce, Rational Simplification Modulo a Polynomial Ideal, [https://dl.acm.org/doi/pdf/10.1145/1145768.1145809](https://dl.acm.org/doi/pdf/10.1145/1145768.1145809)
    (specifically, the second algorithm)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: M. Monagan, R. Pearce, 有理化简模多项式理想，[https://dl.acm.org/doi/pdf/10.1145/1145768.1145809](https://dl.acm.org/doi/pdf/10.1145/1145768.1145809)（特别是第二个算法）
- en: '[PRE82]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Returns a reduced expression by using known trig identities.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 通过已知的三角恒等式返回简化的表达式。
- en: 'Parameters:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**inverse** : bool, optional'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**inverse** : bool, 可选'
- en: 'If `inverse=True`, it will be assumed that a composition of inverse functions,
    such as sin and asin, can be cancelled in any order. For example, `asin(sin(x))`
    will yield `x` without checking whether x belongs to the set where this relation
    is true. The default is False. Default : True'
  id: totrans-248
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 `inverse=True`，则将假定可以以任意顺序取消反函数的组合，例如 `asin(sin(x))` 将在不检查 x 是否属于此关系为真的集合的情况下产生
    `x`。默认为 False。默认值：True
- en: '**method** : string, optional'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**method**：字符串，可选'
- en: 'Specifies the method to use. Valid choices are:'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指定要使用的方法。有效选择为：
- en: ''
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`''matching''`, default'
  id: totrans-252
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''matching''`，默认'
- en: ''
  id: totrans-253
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-254
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''groebner''`'
  id: totrans-255
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''groebner''`'
- en: ''
  id: totrans-256
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-257
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''combined''`'
  id: totrans-258
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''combined''`'
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-260
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''fu''`'
  id: totrans-261
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''fu''`'
- en: ''
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`''old''`'
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`''old''`'
- en: ''
  id: totrans-265
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-266
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-267
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `'matching'`, simplify the expression recursively by targeting common patterns.
    If `'groebner'`, apply an experimental groebner basis algorithm. In this case
    further options are forwarded to `trigsimp_groebner`, please refer to its docstring.
    If `'combined'`, it first runs the groebner basis algorithm with small default
    parameters, then runs the `'matching'` algorithm. If `'fu'`, run the collection
    of trigonometric transformations described by Fu, et al. (see the [`fu()`](fu.html#sympy.simplify.fu.fu
    "sympy.simplify.fu.fu") docstring). If `'old'`, the original SymPy trig simplification
    function is run.
  id: totrans-268
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果选择 `'matching'`，则通过针对常见模式进行递归简化表达式。如果选择 `'groebner'`，则应用试验性的Groebner基算法。在这种情况下，进一步的选项将被传递给
    `trigsimp_groebner`，请参阅其文档字符串。如果选择 `'combined'`，它首先使用默认较小的参数运行Groebner基础算法，然后运行
    `'matching'` 算法。如果选择 `'fu'`，则运行Fu等人描述的三角变换集合（参见[`fu()`](fu.html#sympy.simplify.fu.fu
    "sympy.simplify.fu.fu") 的文档字符串）。如果选择 `'old'`，则运行原始的SymPy三角简化函数。
- en: '**opts :**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**opts：**'
- en: Optional keyword arguments passed to the method. See each method’s function
    docstring for details.
  id: totrans-270
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 可选的关键字参数传递给该方法。请查看每个方法的函数文档字符串以获取详细信息。
- en: Examples
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE83]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Simplification occurs wherever trigonometric functions are located.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 简化发生在三角函数所在的任何地方。
- en: '[PRE84]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Using `method='groebner'` (or `method='combined'`) might lead to greater simplification.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `method='groebner'`（或 `method='combined'`）可能会导致更大的简化。
- en: The old trigsimp routine can be accessed as with method `method='old'`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `method='old'` 访问旧的 trigsimp 例程。
- en: '[PRE85]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Reduce expression by combining powers with similar bases and exponents.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 通过合并具有相似基数和指数的幂来减少表达式。
- en: Explanation
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: If `deep` is `True` then powsimp() will also simplify arguments of functions.
    By default `deep` is set to `False`.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `deep=True`，则 powsimp() 还将简化函数参数。默认情况下，`deep` 设置为 `False`。
- en: If `force` is `True` then bases will be combined without checking for assumptions,
    e.g. sqrt(x)*sqrt(y) -> sqrt(x*y) which is not true if x and y are both negative.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `force` 为 `True`，则会在不检查假设的情况下合并基数，例如 `sqrt(x)*sqrt(y)` -> `sqrt(x*y)`，如果
    x 和 y 都为负数则不成立。
- en: 'You can make powsimp() only combine bases or only combine exponents by changing
    combine=’base’ or combine=’exp’. By default, combine=’all’, which does both. combine=’base’
    will only combine:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改 `combine='base'` 或 `combine='exp'` 使 powsimp() 仅合并基数或仅合并指数。默认情况下，`combine='all'`
    即同时进行两者合并。`combine='base'` 只会合并：
- en: '[PRE87]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: and combine=’exp’ will only combine
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `combine='exp'` 只会合并
- en: '[PRE88]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: combine=’exp’ will strictly only combine exponents in the way that used to be
    automatic. Also use deep=True if you need the old behavior.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`combine=''exp''` 严格只会按照以前的自动方式合并指数。如果需要旧的行为，请同时使用 `deep=True`。'
- en: When combine=’all’, ‘exp’ is evaluated first. Consider the first example below
    for when there could be an ambiguity relating to this. This is done so things
    like the second example can be completely combined. If you want ‘base’ combined
    first, do something like powsimp(powsimp(expr, combine=’base’), combine=’exp’).
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `combine='all'` 时，首先评估 `exp`。考虑下面的第一个示例，以了解可能与此相关的歧义。这样做是为了能够完全合并第二个示例。如果希望首先合并
    `base`，请执行像 `powsimp(powsimp(expr, combine='base'), combine='exp')` 这样的操作。
- en: Examples
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE89]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Radicals with Mul bases will be combined if combine=’exp’
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `combine='exp'`，则基数为Mul的根式将被合并
- en: '[PRE92]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Two radicals are automatically joined through Mul:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 两个根式将通过Mul自动连接：
- en: '[PRE93]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'But if an integer power of that radical has been autoexpanded then Mul does
    not join the resulting factors:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果该根式的整数幂已经自动展开，则Mul不会连接生成的因子：
- en: '[PRE94]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Collect exponents on powers as assumptions allow.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 根据假设允许的幂来收集幂。
- en: Explanation
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: 'Given `(bb**be)**e`, this can be simplified as follows:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `(bb**be)**e`，可以按以下方式简化：
- en: if `bb` is positive, or
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `bb` 为正数，或
- en: '`e` is an integer, or'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`e` 是一个整数，或'
- en: '`|be| < 1` then this simplifies to `bb**(be*e)`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `|be| < 1`，则简化为 `bb**(be*e)`
- en: 'Given a product of powers raised to a power, `(bb1**be1 * bb2**be2...)**e`,
    simplification can be done as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 给定幂的乘积 `(bb1**be1 * bb2**be2...)**e`，可以按以下方式简化：
- en: if e is positive, the gcd of all bei can be joined with e;
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果e为正，则所有bei的gcd可以与e结合；
- en: all non-negative bb can be separated from those that are negative and their
    gcd can be joined with e; autosimplification already handles this separation.
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有非负的bb可以从那些是负的分开，并且它们的gcd可以与e结合；autosimplification已处理此分离。
- en: integer factors from powers that have integers in the denominator of the exponent
    can be removed from any term and the gcd of such integers can be joined with e
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有分母指数中的整数的整数因子可以从任何项中移除，并且这些整数的gcd可以与e结合
- en: Setting `force` to `True` will make symbols that are not explicitly negative
    behave as though they are positive, resulting in more denesting.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将`force`设置为`True`将使不显式为负的符号表现得像它们是正的，从而导致更多去嵌套。
- en: Setting `polar` to `True` will do simplifications on the Riemann surface of
    the logarithm, also resulting in more denestings.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 将`polar`设置为`True`将在对数的黎曼曲面上进行简化，从而导致更多去嵌套。
- en: When there are sums of logs in exp() then a product of powers may be obtained
    e.g. `exp(3*(log(a) + 2*log(b)))` - > `a**3*b**6`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 当exp()中存在对数和的和时，可能会得到幂的乘积，例如`exp(3*(log(a) + 2*log(b)))` -> `a**3*b**6`。
- en: Examples
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE96]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Assumptions may prevent expansion:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 假设可能阻止扩展：
- en: '[PRE98]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: No other expansion is done.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 不进行其他扩展。
- en: '[PRE100]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'But exp() will be denested by moving all non-log terms outside of the function;
    this may result in the collapsing of the exp to a power with a different base:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 但通过将所有非对数项移到函数外部来去嵌套exp()；这可能导致exp折叠成具有不同底数的幂：
- en: '[PRE101]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'If assumptions allow, symbols can also be moved to the outermost exponent:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果假设允许，符号也可以移动到最外层的指数：
- en: '[PRE102]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Simplify combinatorial expressions.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 简化组合表达式。
- en: Explanation
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This function takes as input an expression containing factorials, binomials,
    Pochhammer symbol and other “combinatorial” functions, and tries to minimize the
    number of those functions and reduce the size of their arguments.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数以包含阶乘、二项式系数、Pochhammer符号和其他“组合”函数的表达式作为输入，并尝试最小化这些函数的数量并减少其参数的大小。
- en: The algorithm works by rewriting all combinatorial functions as gamma functions
    and applying gammasimp() except simplification steps that may make an integer
    argument non-integer. See docstring of gammasimp for more information.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通过将所有组合函数重写为伽玛函数并应用gammasimp()来工作，除了可能使整数参数非整数的简化步骤。有关更多信息，请参阅gammasimp的文档字符串。
- en: Then it rewrites expression in terms of factorials and binomials by rewriting
    gammas as factorials and converting (a+b)!/a!b! into binomials.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过将伽玛函数重写为阶乘并将(a+b)!/a!b!转换为二项式来以阶乘和二项式的术语重写表达式。
- en: If expression has gamma functions or combinatorial functions with non-integer
    argument, it is automatically passed to gammasimp.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式具有伽玛函数或具有非整数参数的组合函数，则将其自动传递给gammasimp。
- en: Examples
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE107]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Denests sqrts in an expression that contain other square roots if possible,
    otherwise returns the expr unchanged. This is based on the algorithms of [1].
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可能，对表达式中包含其他平方根的表达式进行去嵌套，否则返回未更改的表达式。这基于[1]的算法。
- en: Examples
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE110]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: See also
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见
- en: '[`sympy.solvers.solvers.unrad`](../solvers/solvers.html#sympy.solvers.solvers.unrad
    "sympy.solvers.solvers.unrad")'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sympy.solvers.solvers.unrad`](../solvers/solvers.html#sympy.solvers.solvers.unrad
    "sympy.solvers.solvers.unrad")'
- en: References
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 参考
- en: '[[R856](#id2)]'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R856](#id2)]'
- en: '[https://web.archive.org/web/20210806201615/https://researcher.watson.ibm.com/researcher/files/us-fagin/symb85.pdf](https://web.archive.org/web/20210806201615/https://researcher.watson.ibm.com/researcher/files/us-fagin/symb85.pdf)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://web.archive.org/web/20210806201615/https://researcher.watson.ibm.com/researcher/files/us-fagin/symb85.pdf](https://web.archive.org/web/20210806201615/https://researcher.watson.ibm.com/researcher/files/us-fagin/symb85.pdf)'
- en: '[[R857](#id3)]'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R857](#id3)]'
- en: D. J. Jeffrey and A. D. Rich, ‘Symplifying Square Roots of Square Roots by Denesting’
    (available at [https://www.cybertester.com/data/denest.pdf](https://www.cybertester.com/data/denest.pdf))
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: D. J. Jeffrey 和 A. D. Rich，《通过去嵌套简化平方根的平方根》（可在[https://www.cybertester.com/data/denest.pdf](https://www.cybertester.com/data/denest.pdf)找到）
- en: '[PRE111]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Perform common subexpression elimination on an expression.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 对表达式执行常见子表达式消除。
- en: 'Parameters:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**exprs** : list of SymPy expressions, or a single SymPy expression'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '**exprs**：SymPy表达式的列表或单个SymPy表达式'
- en: The expressions to reduce.
  id: totrans-353
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要简化的表达式。
- en: '**symbols** : infinite iterator yielding unique Symbols'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**symbols**：无限迭代器，生成唯一的Symbols'
- en: The symbols used to label the common subexpressions which are pulled out. The
    `numbered_symbols` generator is useful. The default is a stream of symbols of
    the form “x0”, “x1”, etc. This must be an infinite iterator.
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于标记提取出的公共子表达式的符号。`numbered_symbols`生成器很有用。默认情况下是形如“x0”、“x1”等的符号流。这必须是一个无限迭代器。
- en: '**optimizations** : list of (callable, callable) pairs'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**optimizations**：（callable，callable）对列表。'
- en: The (preprocessor, postprocessor) pairs of external optimization functions.
    Optionally ‘basic’ can be passed for a set of predefined basic optimizations.
    Such ‘basic’ optimizations were used by default in old implementation, however
    they can be really slow on larger expressions. Now, no pre or post optimizations
    are made by default.
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 外部优化函数的预处理器、后处理器对。可选地，可以传递‘basic’以获取一组预定义的基本优化。这些‘basic’优化在旧实现中默认使用，但在处理较大表达式时可能非常慢。现在，默认情况下不进行任何预处理或后处理优化。
- en: '**postprocess** : a function which accepts the two return values of cse and'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**后处理**：接受CSE的两个返回值的函数。'
- en: 'returns the desired form of output from cse, e.g. if you want the replacements
    reversed the function might be the following lambda: lambda r, e: return reversed(r),
    e'
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回所需的cse输出形式，例如如果想要反转替换，则函数可能是以下lambda：lambda r，e：return reversed(r)，e
- en: '**order** : string, ‘none’ or ‘canonical’'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序**：字符串，‘none’或‘canonical’。'
- en: The order by which Mul and Add arguments are processed. If set to ‘canonical’,
    arguments will be canonically ordered. If set to ‘none’, ordering will be faster
    but dependent on expressions hashes, thus machine dependent and variable. For
    large expressions where speed is a concern, use the setting order=’none’.
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 处理Mul和Add参数的顺序。如果设置为‘canonical’，参数将按照规范顺序排列。如果设置为‘none’，排序将更快，但依赖于表达式哈希，因此是机器相关和可变的。对于大表达式而言，如果关注速度，使用order=‘none’设置。
- en: '**ignore** : iterable of Symbols'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**ignore**：Symbol的可迭代对象。'
- en: Substitutions containing any Symbol from `ignore` will be ignored.
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含任何`ignore`中符号的替换将被忽略。
- en: '**list** : bool, (default True)'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**：布尔值，（默认为真）。'
- en: Returns expression in list or else with same type as input (when False).
  id: totrans-365
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回以列表形式或与输入相同类型的表达式（当为False时）。
- en: 'Returns:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**replacements** : list of (Symbol, expression) pairs'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**替换**：（Symbol，表达式）对列表。'
- en: All of the common subexpressions that were replaced. Subexpressions earlier
    in this list might show up in subexpressions later in this list.
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有被替换的公共子表达式。此列表中较早的子表达式可能会出现在较晚的子表达式中。
- en: '**reduced_exprs** : list of SymPy expressions'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**reduced_exprs**：SymPy表达式列表。'
- en: The reduced expressions with all of the replacements above.
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 所有上述替换后的简化表达式。
- en: Examples
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 示例。
- en: '[PRE112]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'List of expressions with recursive substitutions:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 具有递归替换的表达式列表。
- en: '[PRE113]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Note: the type and mutability of input matrices is retained.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：输入矩阵的类型和可变性保持不变。
- en: '[PRE114]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The user may disallow substitutions containing certain symbols:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以禁止包含特定符号的替换。
- en: '[PRE115]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The default return value for the reduced expression(s) is a list, even if there
    is only one expression. The \(list\) flag preserves the type of the input in the
    output:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 缩减表达式的默认返回值是一个列表，即使只有一个表达式。`list`标志保留了输出中输入的类型：
- en: '[PRE116]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Find optimization opportunities in Adds, Muls, Pows and negative coefficient
    Muls.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 查找Adds、Muls、Pows和负系数Muls中的优化机会。
- en: 'Parameters:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**exprs** : list of SymPy expressions'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '**exprs**：SymPy表达式列表。'
- en: The expressions to optimize.
  id: totrans-385
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要优化的表达式。
- en: '**order** : string, ‘none’ or ‘canonical’'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序**：字符串，‘none’或‘canonical’。'
- en: The order by which Mul and Add arguments are processed. For large expressions
    where speed is a concern, use the setting order=’none’.
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 处理Mul和Add参数的顺序。对于大表达式而言，如果关注速度，使用order=‘none’设置。
- en: 'Returns:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '**opt_subs** : dictionary of expression substitutions'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**opt_subs**：表达式替换的字典。'
- en: The expression substitutions which can be useful to optimize CSE.
  id: totrans-390
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于优化公共子表达式消除的表达式替换。
- en: Examples
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 示例。
- en: '[PRE118]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Perform raw CSE on expression tree, taking opt_subs into account.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑opt_subs的情况下在表达式树上执行原始CSE。
- en: 'Parameters:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**exprs** : list of SymPy expressions'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '**exprs**：SymPy表达式列表。'
- en: The expressions to reduce.
  id: totrans-397
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要减少的表达式。
- en: '**symbols** : infinite iterator yielding unique Symbols'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**symbols**：生成唯一Symbol的无限迭代器。'
- en: The symbols used to label the common subexpressions which are pulled out.
  id: totrans-399
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 用于标记提取出的公共子表达式的符号。
- en: '**opt_subs** : dictionary of expression substitutions'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**opt_subs**：表达式替换的字典。'
- en: The expressions to be substituted before any CSE action is performed.
  id: totrans-401
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在执行任何CSE操作之前要替换的表达式。
- en: '**order** : string, ‘none’ or ‘canonical’'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '**顺序**：字符串，‘none’或‘canonical’。'
- en: The order by which Mul and Add arguments are processed. For large expressions
    where speed is a concern, use the setting order=’none’.
  id: totrans-403
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 处理 Mul 和 Add 参数的顺序。对于速度是关键的大型表达式，请使用 order='none' 设置。
- en: '**ignore** : iterable of Symbols'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '**ignore**：Symbol 的可迭代对象'
- en: Substitutions containing any Symbol from `ignore` will be ignored.
  id: totrans-405
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 包含来自 `ignore` 的任何符号的替换将被忽略。
- en: '[PRE120]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Expand hypergeometric functions. If allow_hyper is True, allow partial simplification
    (that is a result different from input, but still containing hypergeometric functions).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 展开超几何函数。如果 allow_hyper 为 True，则允许部分简化（即与输入不同但仍包含超几何函数）。
- en: If a G-function has expansions both at zero and at infinity, `place` can be
    set to `0` or `zoo` to indicate the preferred choice.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 G 函数在零点和无穷远处均有展开，可以将 `place` 设置为 `0` 或 `zoo` 表示首选选择。
- en: Examples
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE121]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Non-hyperegeometric parts of the expression and hypergeometric expressions
    that are not recognised are left unchanged:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式的非超几何部分和未被识别的超几何表达式保持不变：
- en: '[PRE122]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Manipulate expressions using paths.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 使用路径操作表达式。
- en: 'EPath grammar in EBNF notation:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: EPath 的 EBNF 表示法语法：
- en: '[PRE124]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: See the docstring of the epath() function.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 epath() 函数的文档字符串。
- en: '[PRE125]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Modify parts of an expression selected by a path.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 修改由路径选择的表达式的部分。
- en: Examples
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE126]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Retrieve parts of an expression selected by a path.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 检索由路径选择的表达式的部分。
- en: Examples
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE132]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Manipulate parts of an expression selected by a path.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 操作表达式中路径选择的部分。
- en: 'Parameters:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**path** : str | EPath'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '**path**：字符串 | EPath'
- en: A path as a string or a compiled EPath.
  id: totrans-438
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 作为字符串或编译的 EPath 的路径。
- en: '**expr** : Basic | iterable'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '**expr**：基本类型 | 可迭代对象'
- en: An expression or a container of expressions.
  id: totrans-440
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 表达式或表达式容器。
- en: '**func** : callable (optional)'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '**func**：可调用对象（可选）'
- en: A callable that will be applied to matching parts.
  id: totrans-442
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将应用于匹配部分的可调用对象。
- en: '**args** : tuple (optional)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**args**：元组（可选）'
- en: Additional positional arguments to `func`.
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`func` 的额外位置参数。'
- en: '**kwargs** : dict (optional)'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**kwargs**：字典（可选）'
- en: Additional keyword arguments to `func`.
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`func` 的额外关键字参数。'
- en: Explanation
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: This function allows to manipulate large nested expressions in single line of
    code, utilizing techniques to those applied in XML processing standards (e.g.
    XPath).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数允许在单行代码中操作大型嵌套表达式，利用在 XML 处理标准中应用的技术（例如 XPath）。
- en: If `func` is `None`, [`epath()`](#sympy.simplify.epathtools.epath "sympy.simplify.epathtools.epath")
    retrieves elements selected by the `path`. Otherwise it applies `func` to each
    matching element.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `func` 为 `None`，[`epath()`](#sympy.simplify.epathtools.epath "sympy.simplify.epathtools.epath")
    检索由 `path` 选择的元素。否则，将 `func` 应用于每个匹配的元素。
- en: Note that it is more efficient to create an EPath object and use the select
    and apply methods of that object, since this will compile the path string only
    once. This function should only be used as a convenient shortcut for interactive
    use.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，创建一个 EPath 对象并使用该对象的 select 和 apply 方法更有效，因为这样只会编译一次路径字符串。这个函数应该只用作交互式使用的便捷快捷方式。
- en: 'This is the supported syntax:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 这是支持的语法：
- en: 'select all: `/*`'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择全部：`/*`
- en: Equivalent of `for arg in args:`.
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 等同于 `for arg in args:`。
- en: 'select slice: `/[0]` or `/[1:5]` or `/[1:5:2]`'
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择切片：`/[0]` 或 `/[1:5]` 或 `/[1:5:2]`
- en: Supports standard Python’s slice syntax.
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 支持标准 Python 的切片语法。
- en: 'select by type: `/list` or `/list|tuple`'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按类型选择：`/list` 或 `/list|tuple`
- en: Emulates `isinstance()`.
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模拟 `isinstance()`。
- en: 'select by attribute: `/__iter__?`'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按属性选择：`/__iter__?`
- en: Emulates `hasattr()`.
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模拟 `hasattr()`。
- en: Examples
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE138]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
