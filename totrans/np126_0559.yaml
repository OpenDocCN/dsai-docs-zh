- en: numpy.einsum_path
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.einsum_path.html](https://numpy.org/doc/1.26/reference/generated/numpy.einsum_path.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates the lowest cost contraction order for an einsum expression by considering
    the creation of intermediate arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**subscripts**str'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the subscripts for summation.
  prefs: []
  type: TYPE_NORMAL
- en: '***operands**list of array_like'
  prefs: []
  type: TYPE_NORMAL
- en: These are the arrays for the operation.
  prefs: []
  type: TYPE_NORMAL
- en: '**optimize**{bool, list, tuple, ‘greedy’, ‘optimal’}'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the type of path. If a tuple is provided, the second argument is assumed
    to be the maximum intermediate size created. If only a single argument is provided
    the largest input or output array size is used as a maximum intermediate size.
  prefs: []
  type: TYPE_NORMAL
- en: if a list is given that starts with `einsum_path`, uses this as the contraction
    path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if False no optimization is taken
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True defaults to the ‘greedy’ algorithm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‘optimal’ An algorithm that combinatorially explores all possible ways of contracting
    the listed tensors and chooses the least costly path. Scales exponentially with
    the number of terms in the contraction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ‘greedy’ An algorithm that chooses the best pair contraction at each step. Effectively,
    this algorithm searches the largest inner, Hadamard, and then outer products at
    each step. Scales cubically with the number of terms in the contraction. Equivalent
    to the ‘optimal’ path for most contractions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default is ‘greedy’.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**path**list of tuples'
  prefs: []
  type: TYPE_NORMAL
- en: A list representation of the einsum path.
  prefs: []
  type: TYPE_NORMAL
- en: '**string_repr**str'
  prefs: []
  type: TYPE_NORMAL
- en: A printable representation of the einsum path.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`einsum`](numpy.einsum.html#numpy.einsum "numpy.einsum"), [`linalg.multi_dot`](numpy.linalg.multi_dot.html#numpy.linalg.multi_dot
    "numpy.linalg.multi_dot")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The resulting path indicates which terms of the input contraction should be
    contracted first, the result of this contraction is then appended to the end of
    the contraction list. This list can then be iterated over until all intermediate
    contractions are complete.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: We can begin with a chain dot example. In this case, it is optimal to contract
    the `b` and `c` tensors first as represented by the first element of the path
    `(1, 2)`. The resulting tensor is added to the end of the contraction and the
    remaining contraction `(0, 1)` is then completed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A more complex index transformation example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
