- en: NumPy 1.13.0 Release Notes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 1.13.0 发布说明
- en: 原文：[https://numpy.org/doc/1.26/release/1.13.0-notes.html](https://numpy.org/doc/1.26/release/1.13.0-notes.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://numpy.org/doc/1.26/release/1.13.0-notes.html](https://numpy.org/doc/1.26/release/1.13.0-notes.html)
- en: This release supports Python 2.7 and 3.4 - 3.6.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 该版本支持 Python 2.7 和 3.4 - 3.6。
- en: Highlights
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重点
- en: Operations like `a + b + c` will reuse temporaries on some platforms, resulting
    in less memory use and faster execution.
  id: totrans-4
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些平台上，类似 `a + b + c` 的操作将重用临时空间，从而减少内存使用和加快执行速度。
- en: ''
  id: totrans-5
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-6
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Inplace operations check if inputs overlap outputs and create temporaries to
    avoid problems.
  id: totrans-7
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就地操作检查输入是否与输出重叠，并创建临时变量以避免问题。
- en: ''
  id: totrans-8
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-9
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: New `__array_ufunc__` attribute provides improved ability for classes to override
    default ufunc behavior.
  id: totrans-10
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增 `__array_ufunc__` 属性，提供了对类以覆盖默认 ufunc 行为的改进能力。
- en: ''
  id: totrans-11
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-12
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: New `np.block` function for creating blocked arrays.
  id: totrans-13
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增 `np.block` 函数，用于创建阻塞数组。
- en: New functions
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新函数
- en: New `np.positive` ufunc.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增 `np.positive` ufunc。
- en: New `np.divmod` ufunc provides more efficient divmod.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `np.divmod` ufunc 提供更有效的 divmod 操作。
- en: New `np.isnat` ufunc tests for NaT special values.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `np.isnat` ufunc 用于测试 NaT 特殊值。
- en: New `np.heaviside` ufunc computes the Heaviside function.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增 `np.heaviside` ufunc 用于计算 Heaviside 函数。
- en: New `np.isin` function, improves on `in1d`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增 `np.isin` 函数，改进了 `in1d`。
- en: New `np.block` function for creating blocked arrays.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增 `np.block` 函数，用于创建阻塞数组。
- en: New `PyArray_MapIterArrayCopyIfOverlap` added to NumPy C-API.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增到 NumPy C-API 的 `PyArray_MapIterArrayCopyIfOverlap`。
- en: See below for details.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 详情请参见下文。
- en: Deprecations
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弃用功能
- en: Calling `np.fix`, `np.isposinf`, and `np.isneginf` with `f(x, y=out)` is deprecated
    - the argument should be passed as `f(x, out=out)`, which matches other ufunc-like
    interfaces.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `f(x, y=out)` 方式调用 `np.fix`、`np.isposinf` 和 `np.isneginf` 已被弃用 - 参数应该以 `f(x,
    out=out)` 的方式传递，这与其他类似 ufunc 的接口相匹配。
- en: Use of the C-API `NPY_CHAR` type number deprecated since version 1.7 will now
    raise deprecation warnings at runtime. Extensions built with older f2py versions
    need to be recompiled to remove the warning.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 C-API `NPY_CHAR` 类型数字自 1.7 版本以来已被弃用，现在会在运行时引发弃用警告。使用旧版 f2py 构建的扩展需要重新编译以消除警告。
- en: '`np.ma.argsort`, `np.ma.minimum.reduce`, and `np.ma.maximum.reduce` should
    be called with an explicit *axis* argument when applied to arrays with more than
    2 dimensions, as the default value of this argument (`None`) is inconsistent with
    the rest of numpy (`-1`, `0`, and `0`, respectively).'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.ma.argsort`、`np.ma.minimum.reduce` 和 `np.ma.maximum.reduce` 在应用于超过两个维度的数组时，应该显式调用
    *axis* 参数，因为此参数的默认值 (`None`) 与 numpy 的其他部分不一致 (`-1`, `0` 和 `0`)。'
- en: '`np.ma.MaskedArray.mini` is deprecated, as it almost duplicates the functionality
    of `np.MaskedArray.min`. Exactly equivalent behaviour can be obtained with `np.ma.minimum.reduce`.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.ma.MaskedArray.mini` 已被弃用，因为它几乎与 `np.MaskedArray.min` 的功能重复。可以通过 `np.ma.minimum.reduce`
    来完全获得相同的行为。'
- en: The single-argument form of `np.ma.minimum` and `np.ma.maximum` is deprecated.
    `np.maximum`. `np.ma.minimum(x)` should now be spelt `np.ma.minimum.reduce(x)`,
    which is consistent with how this would be done with `np.minimum`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已弃用 `np.ma.minimum` 和 `np.ma.maximum` 的单参数形式。现在应该这样写 `np.ma.minimum.reduce(x)`，这与
    `np.minimum` 的用法一致。
- en: Calling `ndarray.conjugate` on non-numeric dtypes is deprecated (it should match
    the behavior of `np.conjugate`, which throws an error).
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用非数值数据类型的 `ndarray.conjugate` 已被弃用（应与 `np.conjugate` 的行为一致，后者会引发错误）。
- en: Calling `expand_dims` when the `axis` keyword does not satisfy `-a.ndim - 1
    <= axis <= a.ndim`, where `a` is the array being reshaped, is deprecated.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 `expand_dims` 时，如果 `axis` 关键字不满足 `-a.ndim - 1 <= axis <= a.ndim` 的条件，将会被弃用。
- en: Future Changes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来更改
- en: 'Assignment between structured arrays with different field names will change
    in NumPy 1.14\. Previously, fields in the dst would be set to the value of the
    identically-named field in the src. In numpy 1.14 fields will instead be assigned
    ‘by position’: The n-th field of the dst will be set to the n-th field of the
    src array. Note that the `FutureWarning` raised in NumPy 1.12 incorrectly reported
    this change as scheduled for NumPy 1.13 rather than NumPy 1.14.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 NumPy 1.14 中，具有不同字段名称的结构化数组之间的赋值将发生改变。
- en: Build System Changes
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建系统更改
- en: '`numpy.distutils` now automatically determines C-file dependencies with GCC
    compatible compilers.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.distutils` 现在可以使用 GCC 兼容的编译器自动确定 C 文件的依赖关系。'
- en: Compatibility notes
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兼容性注意事项
- en: Error type changes
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误类型更改
- en: '`numpy.hstack()` now throws `ValueError` instead of `IndexError` when input
    is empty.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当输入为空时，`numpy.hstack()`现在会抛出`ValueError`而不是`IndexError`。
- en: Functions taking an axis argument, when that argument is out of range, now throw
    `np.AxisError` instead of a mixture of `IndexError` and `ValueError`. For backwards
    compatibility, `AxisError` subclasses both of these.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递轴参数的函数，当该参数超出范围时，现在会抛出`np.AxisError`而不是一个`IndexError`和`ValueError`混合的情况。为了向后兼容，`AxisError`子类化了这两种异常。
- en: Tuple object dtypes
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组对象dtypes
- en: Support has been removed for certain obscure dtypes that were unintentionally
    allowed, of the form `(old_dtype, new_dtype)`, where either of the dtypes is or
    contains the `object` dtype. As an exception, dtypes of the form `(object, [('name',
    object)])` are still supported due to evidence of existing use.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一些意外允许的某些不常见的dtypes(形式为`(old_dtype, new_dtype)`)的支持已经被移除，其中任一dtype是或包含`object`
    dtype。作为一个例外，由于已有使用证据，仍然支持形式为`(object, [('name', object)])`的dtypes。
- en: DeprecationWarning to error
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DeprecationWarning变为错误
- en: See Changes section for more detail.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 详情请查看变更章节。
- en: '`partition`, TypeError when non-integer partition index is used.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition`，使用非整数分区索引时会产生TypeError。'
- en: '`NpyIter_AdvancedNew`, ValueError when `oa_ndim == 0` and `op_axes` is NULL'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NpyIter_AdvancedNew`当`oa_ndim == 0`并且`op_axes`为空时会产生ValueError'
- en: '`negative(bool_)`, TypeError when negative applied to booleans.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`negative(bool_)`对布尔值应用negative时会产生TypeError。'
- en: '`subtract(bool_, bool_)`, TypeError when subtracting boolean from boolean.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtract(bool_, bool_)`，从布尔值中减去布尔值会产生TypeError。'
- en: '`np.equal, np.not_equal`, object identity doesn’t override failed comparison.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.equal, np.not_equal`，对象身份不覆盖失败的比较。'
- en: '`np.equal, np.not_equal`, object identity doesn’t override non-boolean comparison.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.equal, np.not_equal`，对象身份不覆盖非布尔比较。'
- en: Deprecated boolean indexing behavior dropped. See Changes below for details.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已弃用的布尔索引行为已删除。详细信息请查看下面的变更。
- en: Deprecated `np.alterdot()` and `np.restoredot()` removed.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已弃用的`np.alterdot()`和`np.restoredot()`已移除。
- en: FutureWarning to changed behavior
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FutureWarning变化的行为
- en: See Changes section for more detail.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 详情请查看变更章节。
- en: '`numpy.average` preserves subclasses'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.average`保留子类'
- en: '`array == None` and `array != None` do element-wise comparison.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array == None`和`array != None`进行逐元素比较。'
- en: '`np.equal, np.not_equal`, object identity doesn’t override comparison result.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.equal, np.not_equal`，对象身份不覆盖比较结果。'
- en: dtypes are now always true
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在dtypes始终为true
- en: Previously `bool(dtype)` would fall back to the default python implementation,
    which checked if `len(dtype) > 0`. Since `dtype` objects implement `__len__` as
    the number of record fields, `bool` of scalar dtypes would evaluate to `False`,
    which was unintuitive. Now `bool(dtype) == True` for all dtypes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`bool(dtype)`将退回到默认的Python实现，即检查`len(dtype) > 0`。由于`dtype`对象实现`__len__`作为记录字段的数量，标量dtypes的`bool`将评估为`False`，这是不直观的。现在对于所有dtypes，`bool(dtype)==True`。
- en: '`__getslice__` and `__setslice__` are no longer needed in `ndarray` subclasses'
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`ndarray`子类中已不再需要`__getslice__`和`__setslice__`。
- en: When subclassing np.ndarray in Python 2.7, it is no longer _necessary_ to implement
    `__*slice__` on the derived class, as `__*item__` will intercept these calls correctly.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.7中，当对np.ndarray进行子类化时，不再需要在派生类上实现`__*slice__`，因为`__*item__`将正确拦截这些调用。
- en: Any code that did implement these will work exactly as before. Code that invokes``ndarray.__getslice__``
    (e.g. through `super(...).__getslice__`) will now issue a DeprecationWarning -
    `.__getitem__(slice(start, end))` should be used instead.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现这些的代码将与以前完全相同。调用``ndarray.__getslice__``（例如通过`super(...).__getslice__`）现在将发出DeprecationWarning
    - `.__getitem__(slice(start, end))`应该被代替使用。
- en: Indexing MaskedArrays/Constants with `...` (ellipsis) now returns MaskedArray
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`...`（省略号）对MaskedArrays/Constants进行索引现在将返回MaskedArray
- en: This behavior mirrors that of np.ndarray, and accounts for nested arrays in
    MaskedArrays of object dtype, and ellipsis combined with other forms of indexing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此行为反映了np.ndarray的行为，并考虑了object dtype的MaskedArrays中的嵌套数组，以及与其他形式的索引结合使用的省略号。
- en: C API changes
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C API变更
- en: GUfuncs on empty arrays and NpyIter axis removal
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 空数组和NpyIter轴删除的GUfuncs
- en: It is now allowed to remove a zero-sized axis from NpyIter. Which may mean that
    code removing axes from NpyIter has to add an additional check when accessing
    the removed dimensions later on.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在允许从NpyIter中删除大小为零的轴。这可能意味着从NpyIter中删除轴的代码在以后访问已删除的维度时必须添加额外的检查。
- en: The largest followup change is that gufuncs are now allowed to have zero-sized
    inner dimensions. This means that a gufunc now has to anticipate an empty inner
    dimension, while this was never possible and an error raised instead.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的后续更改是gufunc现在允许具有大小为零的内部维度。这意味着gufunc现在必须预料到一个空的内部维度，而这以前是不可能的，会引发错误。
- en: For most gufuncs no change should be necessary. However, it is now possible
    for gufuncs with a signature such as `(..., N, M) -> (..., M)` to return a valid
    result if `N=0` without further wrapping code.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数gufuncs，通常不需要进行任何更改。但是，如果gufunc的签名为`(..., N, M) -> (..., M)`，并且在`N=0`的情况下可以返回有效结果而无需进一步的包装代码。
- en: '`PyArray_MapIterArrayCopyIfOverlap` added to NumPy C-API'
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在NumPy C-API中添加了`PyArray_MapIterArrayCopyIfOverlap`
- en: Similar to `PyArray_MapIterArray` but with an additional `copy_if_overlap` argument.
    If `copy_if_overlap != 0`, checks if input has memory overlap with any of the
    other arrays and make copies as appropriate to avoid problems if the input is
    modified during the iteration. See the documentation for more complete documentation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于`PyArray_MapIterArray`，但有一个额外的`copy_if_overlap`参数。如果`copy_if_overlap != 0`，则检查输入与其他数组是否存在内存重叠，并适当复制以避免在迭代期间修改输入时出现问题。有关更完整的文档，请参阅文档。
- en: New Features
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新特性
- en: '`__array_ufunc__` added'
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加了`__array_ufunc__`
- en: This is the renamed and redesigned `__numpy_ufunc__`. Any class, ndarray subclass
    or not, can define this method or set it to `None` in order to override the behavior
    of NumPy’s ufuncs. This works quite similarly to Python’s `__mul__` and other
    binary operation routines. See the documentation for a more detailed description
    of the implementation and behavior of this new option. The API is provisional,
    we do not yet guarantee backward compatibility as modifications may be made pending
    feedback. See [NEP 13](http://www.numpy.org/neps/nep-0013-ufunc-overrides.html)
    and [documentation](https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst)
    for more details.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重新命名和重新设计的`__numpy_ufunc__`。任何类，无论是否是ndarray子类，都可以定义此方法或将其设置为`None`，以覆盖NumPy的ufunc行为。这与Python的`__mul__`和其他二进制操作例程非常相似。有关此新选项实现和行为的更详细描述，请参阅文档。API是临时的，我们还不能保证向后兼容性，因为可能会根据反馈做出修改。有关更多详细信息，请参阅[NEP
    13](http://www.numpy.org/neps/nep-0013-ufunc-overrides.html)和[文档](https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst)。
- en: New `positive` ufunc
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的`positive` ufunc
- en: This ufunc corresponds to unary *+*, but unlike *+* on an ndarray it will raise
    an error if array values do not support numeric operations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ufunc对应于一元的*+*，但与ndarray上的*+*不同，如果数组值不支持数值运算，它将引发错误。
- en: New `divmod` ufunc
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的`divmod` ufunc
- en: This ufunc corresponds to the Python builtin *divmod*, and is used to implement
    *divmod* when called on numpy arrays. `np.divmod(x, y)` calculates a result equivalent
    to `(np.floor_divide(x, y), np.remainder(x, y))` but is approximately twice as
    fast as calling the functions separately.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ufunc对应于Python内置的*divmod*，用于在numpy数组上调用*divmod*时。`np.divmod(x, y)`计算的结果相当于`(np.floor_divide(x,
    y), np.remainder(x, y))`，但调用这两个函数的速度大约快两倍。
- en: '`np.isnat` ufunc tests for NaT special datetime and timedelta values'
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.isnat` ufunc测试特殊的NaT日期时间和时间差值数值'
- en: The new ufunc `np.isnat` finds the positions of special NaT values within datetime
    and timedelta arrays. This is analogous to `np.isnan`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 新的ufunc `np.isnat`在日期时间和时间差值数组中查找特殊的NaT数值的位置。这类似于`np.isnan`。
- en: '`np.heaviside` ufunc computes the Heaviside function'
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.heaviside` ufunc计算Heaviside函数'
- en: 'The new function `np.heaviside(x, h0)` (a ufunc) computes the Heaviside function:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 新的函数`np.heaviside(x, h0)`（一个ufunc）计算Heaviside函数：
- en: '[PRE0]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`np.block` function for creating blocked arrays'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于创建块状数组的`np.block`函数
- en: 'Add a new `block` function to the current stacking functions `vstack`, `hstack`,
    and `stack`. This allows concatenation across multiple axes simultaneously, with
    a similar syntax to array creation, but where elements can themselves be arrays.
    For instance:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前的堆叠函数`vstack`、`hstack`和`stack`中添加一个新的`block`函数。这允许同时跨多个轴进行连接，具有类似于数组创建的语法，但其中的元素本身可以是数组。例如：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: While primarily useful for block matrices, this works for arbitrary dimensions
    of arrays.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然主要用于块矩阵，但对数组的任意维度都适用。
- en: It is similar to Matlab’s square bracket notation for creating block matrices.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 它类似于Matlab的方括号表示法用于创建块矩阵。
- en: '`isin` function, improving on `in1d`'
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`isin`函数，对`in1d`进行改进'
- en: The new function `isin` tests whether each element of an N-dimensional array
    is present anywhere within a second array. It is an enhancement of `in1d` that
    preserves the shape of the first array.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 新的函数`isin`测试N维数组的每个元素是否存在于第二个数组中的任何位置。这是对`in1d`的增强，它保留了第一个数组的形状。
- en: Temporary elision
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时省略
- en: On platforms providing the `backtrace` function NumPy will try to avoid creating
    temporaries in expression involving basic numeric types. For example `d = a +
    b + c` is transformed to `d = a + b; d += c` which can improve performance for
    large arrays as less memory bandwidth is required to perform the operation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供`backtrace`函数的平台上，NumPy将尝试避免在涉及基本数值类型的表达式中创建临时变量。例如`d = a + b + c`被转换为`d
    = a + b; d += c`，这可以提高大数组的性能，因为执行操作需要更少的内存带宽。
- en: '`axes` argument for `unique`'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`unique`的`axes`参数'
- en: In an N-dimensional array, the user can now choose the axis along which to look
    for duplicate N-1-dimensional elements using `numpy.unique`. The original behaviour
    is recovered if `axis=None` (default).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在N维数组中，用户现在可以选择沿着哪个轴寻找重复的N-1维元素，使用`numpy.unique`。如果`axis=None`（默认），则恢复原始行为。
- en: '`np.gradient` now supports unevenly spaced data'
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.gradient`现在支持不均匀间距的数据。'
- en: 'Users can now specify a not-constant spacing for data. In particular `np.gradient`
    can now take:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以为数据指定非恒定的间距。特别是`np.gradient`现在可以接受：
- en: A single scalar to specify a sample distance for all dimensions.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用单个标量来指定所有维度的采样距离。
- en: N scalars to specify a constant sample distance for each dimension. i.e. `dx`,
    `dy`, `dz`, …
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用N个标量来指定每个维度的恒定采样间距。例如`dx`、`dy`、`dz`等。
- en: N arrays to specify the coordinates of the values along each dimension of F.
    The length of the array must match the size of the corresponding dimension
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用N个数组来指定F的每个维度上的值的坐标。数组的长度必须与相应维度的大小相匹配。
- en: Any combination of N scalars/arrays with the meaning of 2\. and 3.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任意组合的N个标量/数组，具有第2和第3点的含义。
- en: 'This means that, e.g., it is now possible to do the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，例如，现在可以执行以下操作：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Support for returning arrays of arbitrary dimensions in `apply_along_axis`
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`apply_along_axis`中支持返回任意维度的数组
- en: Previously, only scalars or 1D arrays could be returned by the function passed
    to `apply_along_axis`. Now, it can return an array of any dimensionality (including
    0D), and the shape of this array replaces the axis of the array being iterated
    over.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`apply_along_axis`传递的函数只能返回标量或1D数组。现在，它可以返回任意维度的数组（包括0维），并且该数组的形状将替换正在迭代的数组的轴。
- en: '`.ndim` property added to `dtype` to complement `.shape`'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`.形状`属性已添加到`dtype`以补充`.形状`。'
- en: For consistency with `ndarray` and `broadcast`, `d.ndim` is a shorthand for
    `len(d.shape)`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与`ndarray`和`broadcast`保持一致，`d.ndim`是`len(d.shape)`的简写。
- en: Support for tracemalloc in Python 3.6
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对Python 3.6的tracemalloc的支持
- en: NumPy now supports memory tracing with [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    module of Python 3.6 or newer. Memory allocations from NumPy are placed into the
    domain defined by `numpy.lib.tracemalloc_domain`. Note that NumPy allocation will
    not show up in [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    of earlier Python versions.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy现在支持Python 3.6或更新版本的[tracemalloc](https://docs.python.org/3/library/tracemalloc.html)模块进行内存跟踪。来自NumPy的内存分配被放入由`numpy.lib.tracemalloc_domain`定义的域中。请注意，NumPy分配不会显示在早期Python版本的[tracemalloc](https://docs.python.org/3/library/tracemalloc.html)中。
- en: NumPy may be built with relaxed stride checking debugging
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy可能会使用宽松步幅检查调试构建
- en: Setting NPY_RELAXED_STRIDES_DEBUG=1 in the environment when relaxed stride checking
    is enabled will cause NumPy to be compiled with the affected strides set to the
    maximum value of npy_intp in order to help detect invalid usage of the strides
    in downstream projects. When enabled, invalid usage often results in an error
    being raised, but the exact type of error depends on the details of the code.
    TypeError and OverflowError have been observed in the wild.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用宽松步幅检查时，在环境中设置NPY_RELAXED_STRIDES_DEBUG=1将导致NumPy在受影响的步幅中设置为npy_intp的最大值，以帮助检测下游项目中对步幅的无效使用。当启用时，无效使用通常会导致错误被引发，但错误类型的具体类型取决于代码的细节。在现实中观察到了TypeError和OverflowError。
- en: It was previously the case that this option was disabled for releases and enabled
    in master and changing between the two required editing the code. It is now disabled
    by default but can be enabled for test builds.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，该选项在发布版中被禁用，在主分支中被启用，而在两者之间切换需要编辑代码。现在默认情况下禁用，但可以在测试版本中启用。
- en: Improvements
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进
- en: Ufunc behavior for overlapping inputs
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重叠输入的`Ufunc`行为
- en: Operations where ufunc input and output operands have memory overlap produced
    undefined results in previous NumPy versions, due to data dependency issues. In
    NumPy 1.13.0, results from such operations are now defined to be the same as for
    equivalent operations where there is no memory overlap.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的NumPy版本中，`Ufunc`输入和输出操作数存在内存重叠的操作会产生未定义的结果，因为存在数据依赖性问题。 在NumPy 1.13.0中，这类操作的结果现在被定义为与没有内存重叠的等效操作的结果相同。
- en: Operations affected now make temporary copies, as needed to eliminate data dependency.
    As detecting these cases is computationally expensive, a heuristic is used, which
    may in rare cases result to needless temporary copies. For operations where the
    data dependency is simple enough for the heuristic to analyze, temporary copies
    will not be made even if the arrays overlap, if it can be deduced copies are not
    necessary. As an example,``np.add(a, b, out=a)`` will not involve copies.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在受影响的操作会根据需要制作临时拷贝，以消除数据依赖性。 由于检测这些情况是计算昂贵的，因此使用了启发式方法，这在罕见情况下可能导致不必要的临时拷贝。
    对于启发式方法可以分析的数据依赖性简单到足以使临时拷贝的操作，即使数组重叠，也将不制作任何拷贝，如果可以推断不需要拷贝。 例如，``np.add(a, b,
    out=a)``将不涉及拷贝。
- en: 'To illustrate a previously undefined operation:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明以前未定义的操作：
- en: '[PRE3]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In NumPy 1.13.0 the last line is guaranteed to be equivalent to:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy 1.13.0中，最后一行保证等同于：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A similar operation with simple non-problematic data dependence is:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 具有简单，无问题数据依赖的类似操作是：
- en: '[PRE5]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It will continue to produce the same results as in previous NumPy versions,
    and will not involve unnecessary temporary copies.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它将继续产生与之前NumPy版本相同的结果，并且不会涉及不必要的临时拷贝。
- en: 'The change applies also to in-place binary operations, for example:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改也适用于原地二进制操作，例如：
- en: '[PRE6]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This statement is now guaranteed to be equivalent to `x[...] = x + x.T`, whereas
    in previous NumPy versions the results were undefined.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 该语句现在保证等同于`x[...] = x + x.T`，而在以前的NumPy版本中，结果是未定义的。
- en: Partial support for 64-bit f2py extensions with MinGW
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 部分支持使用MinGW的64位f2py扩展
- en: Extensions that incorporate Fortran libraries can now be built using the free
    [MinGW](https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/)
    toolset, also under Python 3.5\. This works best for extensions that only do calculations
    and uses the runtime modestly (reading and writing from files, for instance).
    Note that this does not remove the need for Mingwpy; if you make extensive use
    of the runtime, you will most likely run into [issues](https://mingwpy.github.io/issues.html).
    Instead, it should be regarded as a band-aid until Mingwpy is fully functional.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用免费的[MinGW](https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/)工具集构建包含Fortran库的扩展，也可以在Python
    3.5下使用。 这对于只进行计算并适度使用运行时（例如读写文件）的扩展效果最好。 请注意，这并不消除了Mingwpy的需要；如果您大量使用运行时，您很可能会遇到[问题](https://mingwpy.github.io/issues.html)。
    相反，它应该被视为一种应急措施，直到Mingwpy能够充分发挥作用。
- en: Extensions can also be compiled using the MinGW toolset using the runtime library
    from the (moveable) WinPython 3.4 distribution, which can be useful for programs
    with a PySide1/Qt4 front-end.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用可移动的WinPython 3.4分发中的运行时库，使用MinGW工具集编译扩展，这对于具有PySide1/Qt4前端的程序可能会有用。
- en: Performance improvements for `packbits` and `unpackbits`
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对`packbits`和`unpackbits`的性能改进
- en: The functions `numpy.packbits` with boolean input and `numpy.unpackbits` have
    been optimized to be a significantly faster for contiguous data.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`numpy.packbits`与布尔输入和`numpy.unpackbits`已经被优化为对于连续数据来说更快。
- en: Fix for PPC long double floating point information
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复了PPC长双浮点信息
- en: In previous versions of NumPy, the `finfo` function returned invalid information
    about the [double double](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic)
    format of the `longdouble` float type on Power PC (PPC). The invalid values resulted
    from the failure of the NumPy algorithm to deal with the variable number of digits
    in the significand that are a feature of *PPC long doubles*. This release by-passes
    the failing algorithm by using heuristics to detect the presence of the PPC double
    double format. A side-effect of using these heuristics is that the `finfo` function
    is faster than previous releases.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的NumPy版本中，`finfo`函数返回的`longdouble`浮点类型的[双倍浮点数](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic)格式有无效信息。无效值是由于NumPy算法无法处理*PPC
    long doubles*中变化数量的尾数位数。这个版本通过使用启发式算法来检测PPC双倍浮点格式绕过了失败的算法。使用这些启发式算法的一个副作用是`finfo`函数比以前的版本更快。
- en: Better default repr for `ndarray` subclasses
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好的`ndarray`子类的默认repr
- en: Subclasses of ndarray with no `repr` specialization now correctly indent their
    data and type lines.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`repr`专业化的ndarray子类现在正确地缩进其数据和类型行。
- en: More reliable comparisons of masked arrays
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 掩码数组的比较更可靠
- en: Comparisons of masked arrays were buggy for masked scalars and failed for structured
    arrays with dimension higher than one. Both problems are now solved. In the process,
    it was ensured that in getting the result for a structured array, masked fields
    are properly ignored, i.e., the result is equal if all fields that are non-masked
    in both are equal, thus making the behaviour identical to what one gets by comparing
    an unstructured masked array and then doing `.all()` over some axis.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 掩码数组的比较对于掩码标量存在问题，并且对于维度大于1的结构化数组是失败的。这两个问题现在都得到解决。在此过程中，确保在获取结构化数组的结果时，正确地忽略掩码字段，即如果两个数组中的所有非掩码字段相等，则结果相等，从而使得行为与通过比较无结构的掩码数组然后在某个轴上进行`.all()`的行为相同。
- en: np.matrix with booleans elements can now be created using the string syntax
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: np.matrix现在可以使用字符串语法创建包含布尔元素的矩阵
- en: '`np.matrix` failed whenever one attempts to use it with booleans, e.g., `np.matrix(''True'')`.
    Now, this works as expected.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.matrix`每当尝试与布尔值一起使用时都会失败，例如`np.matrix(''True'')`。现在，这可以正常工作。'
- en: More `linalg` operations now accept empty vectors and matrices
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多的`linalg`操作现在接受空向量和矩阵
- en: 'All of the following functions in `np.linalg` now work when given input arrays
    with a 0 in the last two dimensions: `det`, `slogdet`, `pinv`, `eigvals`, `eigvalsh`,
    `eig`, `eigh`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`np.linalg`中的所有以下函数现在在给定在最后两个维度中有0的输入数组时工作：`det`，`slogdet`，`pinv`，`eigvals`，`eigvalsh`，`eig`，`eigh`。'
- en: Bundled version of LAPACK is now 3.2.2
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 捆绑的LAPACK版本现在是3.2.2
- en: NumPy comes bundled with a minimal implementation of lapack for systems without
    a lapack library installed, under the name of `lapack_lite`. This has been upgraded
    from LAPACK 3.0.0 (June 30, 1999) to LAPACK 3.2.2 (June 30, 2010). See the [LAPACK
    changelogs](http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases)
    for details on the all the changes this entails.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy捆绑了lapack的最小实现，供没有安装lapack库的系统使用，命名为`lapack_lite`。这已经从LAPACK 3.0.0（1999年6月30日）升级到LAPACK
    3.2.2（2010年6月30日）。有关所有这些变化的详细信息，请参阅[LAPACK更新日志](http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases)。
- en: While no new features are exposed through `numpy`, this fixes some bugs regarding
    “workspace” sizes, and in some places may use faster algorithms.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有通过`numpy`公开新功能，但这修复了一些关于“工作空间”大小的错误，并且在某些情况下可能使用更快的算法。
- en: '`reduce` of `np.hypot.reduce` and `np.logical_xor` allowed in more cases'
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.hypot.reduce`和`np.logical_xor`的`reduce`现在在更多情况下被允许'
- en: This now works on empty arrays, returning 0, and can reduce over multiple axes.
    Previously, a `ValueError` was thrown in these cases.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这在空数组上运行，返回0，并且可以沿多个轴进行缩减。在这些情况下以前会抛出一个`ValueError`。
- en: Better `repr` of object arrays
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更好的对象数组`repr`
- en: Object arrays that contain themselves no longer cause a recursion error.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 包含自身的对象数组不再引起递归错误。
- en: Object arrays that contain `list` objects are now printed in a way that makes
    clear the difference between a 2d object array, and a 1d object array of lists.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在以一种明显区分2D对象数组和1D对象数组的列表的方式打印包含`list`对象的对象数组。
- en: Changes
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改
- en: '`argsort` on masked arrays takes the same default arguments as `sort`'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 掩码数组上的`argsort`采用与`sort`相同的默认参数
- en: By default, `argsort` now places the masked values at the end of the sorted
    array, in the same way that `sort` already did. Additionally, the `end_with` argument
    is added to `argsort`, for consistency with `sort`. Note that this argument is
    not added at the end, so breaks any code that passed `fill_value` as a positional
    argument.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`argsort` 现在将屏蔽的值放在排序后的数组末尾，就像 `sort` 已经做的那样。另外，`argsort` 还添加了 `end_with`
    参数，以保持与 `sort` 的一致性。请注意，此参数不是添加在最后，因此会破坏将 `fill_value` 作为位置参数传递的任何代码。
- en: '`average` now preserves subclasses'
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`average` 现在保留子类'
- en: For ndarray subclasses, `numpy.average` will now return an instance of the subclass,
    matching the behavior of most other NumPy functions such as `mean`. As a consequence,
    also calls that returned a scalar may now return a subclass array scalar.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对于子类 ndarray，`numpy.average` 现在将返回子类的实例，与大多数其他 NumPy 函数（如 `mean`）的行为匹配。因此，也可能返回子类数组标量的调用现在可能返回一个子类数组标量。
- en: '`array == None` and `array != None` do element-wise comparison'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`array == None` 和 `array != None` 进行逐元素比较'
- en: Previously these operations returned scalars `False` and `True` respectively.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这些操作分别返回标量 `False` 和 `True`。
- en: '`np.equal, np.not_equal` for object arrays ignores object identity'
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于对象数组，`np.equal, np.not_equal` 忽略对象标识
- en: Previously, these functions always treated identical objects as equal. This
    had the effect of overriding comparison failures, comparison of objects that did
    not return booleans, such as np.arrays, and comparison of objects where the results
    differed from object identity, such as NaNs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这些函数总是将相同的对象视为相等。这会覆盖比较失败、对象的比较未返回布尔值（例如 np.arrays）、以及对象的比较结果与对象标识的不同的情况，例如
    NaNs。
- en: Boolean indexing changes
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔索引更改
- en: Boolean array-likes (such as lists of python bools) are always treated as boolean
    indexes.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔数组型（如 python 布尔列表）始终被视为布尔索引。
- en: Boolean scalars (including python `True`) are legal boolean indexes and never
    treated as integers.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔标量（包括 python 的 `True`）是合法的布尔索引，不会被视为整数。
- en: Boolean indexes must match the dimension of the axis that they index.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔索引必须匹配它们索引的轴的维度。
- en: Boolean indexes used on the lhs of an assignment must match the dimensions of
    the rhs.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在赋值的左手边使用布尔索引必须与右手边的维度匹配。
- en: Boolean indexing into scalar arrays return a new 1-d array. This means that
    `array(1)[array(True)]` gives `array([1])` and not the original array.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对标量数组进行布尔索引将返回一个新的一维数组。这意味着 `array(1)[array(True)]` 返回的是 `array([1])` 而不是原始数组。
- en: '`np.random.multivariate_normal` behavior with bad covariance matrix'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.random.multivariate_normal` 处理不好的协方差矩阵的行为'
- en: 'It is now possible to adjust the behavior the function will have when dealing
    with the covariance matrix by using two new keyword arguments:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理协方差矩阵时，现在可以通过使用两个新的关键字参数来调整函数的行为：
- en: '`tol` can be used to specify a tolerance to use when checking that the covariance
    matrix is positive semidefinite.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tol` 可以用于指定检查协方差矩阵是否为正定时使用的公差。'
- en: '`check_valid` can be used to configure what the function will do in the presence
    of a matrix that is not positive semidefinite. Valid options are `ignore`, `warn`
    and `raise`. The default value, `warn` keeps the the behavior used on previous
    releases.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_valid` 可用于配置在存在非正定矩阵时函数的行为。有效选项为 `ignore`、`warn` 和 `raise`。默认值 `warn`
    保持了之前版本的行为。'
- en: '`assert_array_less` compares `np.inf` and `-np.inf` now'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`assert_array_less` 现在比较 `np.inf` 和 `-np.inf`'
- en: Previously, `np.testing.assert_array_less` ignored all infinite values. This
    is not the expected behavior both according to documentation and intuitively.
    Now, -inf < x < inf is considered `True` for any real number x and all other cases
    fail.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`np.testing.assert_array_less` 忽略了所有无限值。这不符合文档和直观上的预期行为。现在，对于任何实数 x，都会考虑
    -inf < x < inf 为 `True`，所有其他情况失败。
- en: '`assert_array_` and masked arrays `assert_equal` hide less warnings'
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`assert_array_` 和屏蔽数组 `assert_equal` 隐藏了更少的警告'
- en: Some warnings that were previously hidden by the `assert_array_` functions are
    not hidden anymore. In most cases the warnings should be correct and, should they
    occur, will require changes to the tests using these functions. For the masked
    array `assert_equal` version, warnings may occur when comparing NaT. The function
    presently does not handle NaT or NaN specifically and it may be best to avoid
    it at this time should a warning show up due to this change.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 以前被 `assert_array_` 函数隐藏的一些警告现在不再隐藏。在大多数情况下，警告应该是正确的，如果发生了这些警告，则需要对使用这些函数的测试进行更改。对于掩码数组
    `assert_equal` 版本，在比较 NaT 时可能会出现警告。该函数目前不专门处理 NaT 或 NaN，因此如果由于此更改而出现警告，最好在此时避免使用它。
- en: '`offset` attribute value in `memmap` objects'
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`memmap` 对象中的 `offset` 属性值'
- en: The `offset` attribute in a `memmap` object is now set to the offset into the
    file. This is a behaviour change only for offsets greater than `mmap.ALLOCATIONGRANULARITY`.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`memmap` 对象中的 `offset` 属性现在设置为文件中的偏移量。这仅适用于偏移大于 `mmap.ALLOCATIONGRANULARITY`
    的行为更改。'
- en: '`np.real` and `np.imag` return scalars for scalar inputs'
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当标量输入时，`np.real` 和 `np.imag` 返回标量。
- en: Previously, `np.real` and `np.imag` used to return array objects when provided
    a scalar input, which was inconsistent with other functions like `np.angle` and
    `np.conj`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，当提供标量输入时，`np.real` 和 `np.imag` 用于返回数组对象，这与 `np.angle` 和 `np.conj` 等其他函数不一致。
- en: The polynomial convenience classes cannot be passed to ufuncs
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项式便利类无法传递给 ufuncs。
- en: The ABCPolyBase class, from which the convenience classes are derived, sets
    `__array_ufun__ = None` in order of opt out of ufuncs. If a polynomial convenience
    class instance is passed as an argument to a ufunc, a `TypeError` will now be
    raised.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 从方便类派生的 ABCPolyBase 类将 `__array_ufunc__ = None`，以便退出 ufuncs。如果将一个多项式便利类实例作为参数传递给一个
    ufunc，则现在会引发 `TypeError`。
- en: Output arguments to ufuncs can be tuples also for ufunc methods
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于 ufunc 方法，输出参数可以是元组。
- en: For calls to ufuncs, it was already possible, and recommended, to use an `out`
    argument with a tuple for ufuncs with multiple outputs. This has now been extended
    to output arguments in the `reduce`, `accumulate`, and `reduceat` methods. This
    is mostly for compatibility with `__array_ufunc`; there are no ufuncs yet that
    have more than one output.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对 ufuncs 的调用，已经可以并且建议使用一个元组作为多个输出的 ufunc 的输出参数。现在，这已经扩展到 `reduce`，`accumulate`
    和 `reduceat` 方法中的输出参数。这主要是为了与 `__array_ufunc` 兼容；目前还没有超过一个输出的 ufunc。
- en: Highlights
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亮点
- en: Operations like `a + b + c` will reuse temporaries on some platforms, resulting
    in less memory use and faster execution.
  id: totrans-179
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一些平台上，像 `a + b + c` 的操作将重复使用临时变量，减少内存使用量和更快的执行速度。
- en: ''
  id: totrans-180
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Inplace operations check if inputs overlap outputs and create temporaries to
    avoid problems.
  id: totrans-182
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 立即操作检查输入是否与输出重叠，并创建临时变量以避免问题。
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: New `__array_ufunc__` attribute provides improved ability for classes to override
    default ufunc behavior.
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `__array_ufunc__` 属性提供了类能够覆盖默认 ufunc 行为的更强大能力。
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: New `np.block` function for creating blocked arrays.
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `np.block` 函数用于创建分块数组。
- en: New functions
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能
- en: New `np.positive` ufunc.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `np.positive` 函数。
- en: New `np.divmod` ufunc provides more efficient divmod.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `np.divmod` 函数提供更高效的 divmod。
- en: New `np.isnat` ufunc tests for NaT special values.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `np.isnat` 函数用于测试 NaT 特殊值。
- en: New `np.heaviside` ufunc computes the Heaviside function.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `np.heaviside` 函数计算重函数。
- en: New `np.isin` function, improves on `in1d`.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `np.isin` 函数，改进了 `in1d`。
- en: New `np.block` function for creating blocked arrays.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的 `np.block` 函数用于创建分块数组。
- en: New `PyArray_MapIterArrayCopyIfOverlap` added to NumPy C-API.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新增 `PyArray_MapIterArrayCopyIfOverlap` 到 NumPy C-API。
- en: See below for details.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 详情请参见下文。
- en: Deprecations
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 废弃
- en: Calling `np.fix`, `np.isposinf`, and `np.isneginf` with `f(x, y=out)` is deprecated
    - the argument should be passed as `f(x, out=out)`, which matches other ufunc-like
    interfaces.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `f(x, y=out)` 调用 `np.fix`，`np.isposinf` 和 `np.isneginf` 已被废弃 - 参数应该传递为 `f(x,
    out=out)`，这与其他类似 ufunc 的接口相匹配。
- en: Use of the C-API `NPY_CHAR` type number deprecated since version 1.7 will now
    raise deprecation warnings at runtime. Extensions built with older f2py versions
    need to be recompiled to remove the warning.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自版本 1.7 起弃用 C-API `NPY_CHAR` 类型编号，现在将在运行时引发弃用警告。使用旧版本 f2py 构建的扩展需要重新编译以消除警告。
- en: '`np.ma.argsort`, `np.ma.minimum.reduce`, and `np.ma.maximum.reduce` should
    be called with an explicit *axis* argument when applied to arrays with more than
    2 dimensions, as the default value of this argument (`None`) is inconsistent with
    the rest of numpy (`-1`, `0`, and `0`, respectively).'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当应用于超过2维数组时，`np.ma.argsort`，`np.ma.minimum.reduce`和`np.ma.maximum.reduce`应该在调用时使用显式的*axis*参数，因为这个参数的默认值（`None`）与numpy的其余部分（分别是`-1`，`0`和`0`）不一致。
- en: '`np.ma.MaskedArray.mini` is deprecated, as it almost duplicates the functionality
    of `np.MaskedArray.min`. Exactly equivalent behaviour can be obtained with `np.ma.minimum.reduce`.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.ma.MaskedArray.mini`已被弃用，因为它几乎重复了`np.MaskedArray.min`的功能。可以通过`np.ma.minimum.reduce`获得完全等效的行为。'
- en: The single-argument form of `np.ma.minimum` and `np.ma.maximum` is deprecated.
    `np.maximum`. `np.ma.minimum(x)` should now be spelt `np.ma.minimum.reduce(x)`,
    which is consistent with how this would be done with `np.minimum`.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单参数形式的`np.ma.minimum`和`np.ma.maximum`已被废弃。 现在应该用`np.ma.minimum.reduce(x)`来替代`np.ma.minimum(x)`，这与使用`np.minimum`是一致的。
- en: Calling `ndarray.conjugate` on non-numeric dtypes is deprecated (it should match
    the behavior of `np.conjugate`, which throws an error).
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在非数字数据类型上调用`ndarray.conjugate`已被弃用（应该与`np.conjugate`的行为相匹配，该行为会引发错误）。
- en: Calling `expand_dims` when the `axis` keyword does not satisfy `-a.ndim - 1
    <= axis <= a.ndim`, where `a` is the array being reshaped, is deprecated.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在重塑数组时，当`axis`关键字不满足`-a.ndim - 1 <= axis <= a.ndim`，其中`a`是数组时，调用`expand_dims`已被弃用。
- en: Future Changes
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来更改
- en: 'Assignment between structured arrays with different field names will change
    in NumPy 1.14\. Previously, fields in the dst would be set to the value of the
    identically-named field in the src. In numpy 1.14 fields will instead be assigned
    ‘by position’: The n-th field of the dst will be set to the n-th field of the
    src array. Note that the `FutureWarning` raised in NumPy 1.12 incorrectly reported
    this change as scheduled for NumPy 1.13 rather than NumPy 1.14.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在NumPy 1.14中，将会改变具有不同字段名称的结构化数组之间的赋值。在以前的版本中，目标数组中的字段将设置为源数组中同名字段的值。在numpy 1.14中，字段将被按位置分配：目标数组的第n个字段将被设置为源数组的第n个字段。请注意，在NumPy
    1.12中引发的`FutureWarning`错误报告了这个更改被安排在NumPy 1.13而不是NumPy 1.14。
- en: Build System Changes
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建系统更改
- en: '`numpy.distutils` now automatically determines C-file dependencies with GCC
    compatible compilers.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.distutils`现在会使用兼容的GCC编译器自动确定C文件的依赖关系。'
- en: Compatibility notes
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兼容性说明
- en: Error type changes
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误类型更改
- en: '`numpy.hstack()` now throws `ValueError` instead of `IndexError` when input
    is empty.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.hstack()`现在在输入为空时会抛出`ValueError`而不是`IndexError`。'
- en: Functions taking an axis argument, when that argument is out of range, now throw
    `np.AxisError` instead of a mixture of `IndexError` and `ValueError`. For backwards
    compatibility, `AxisError` subclasses both of these.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当带有超出范围的轴参数时，接受轴参数的函数现在会抛出`np.AxisError`而不是混合抛出`IndexError`和`ValueError`。为了向后兼容，`AxisError`继承了这两个异常。
- en: Tuple object dtypes
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组对象数据类型
- en: Support has been removed for certain obscure dtypes that were unintentionally
    allowed, of the form `(old_dtype, new_dtype)`, where either of the dtypes is or
    contains the `object` dtype. As an exception, dtypes of the form `(object, [('name',
    object)])` are still supported due to evidence of existing use.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 已删除对某些意外允许的某些模糊数据类型的支持，例如`(old_dtype, new_dtype)`，其中任一数据类型是或包含`object`数据类型。作为例外，由于存在使用证据，仍然支持`(object,
    [('name', object)])`形式的数据类型。
- en: DeprecationWarning to error
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DeprecationWarning to error
- en: See Changes section for more detail.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息请参阅更改部分。
- en: '`partition`, TypeError when non-integer partition index is used.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition`，使用非整数分区索引会引发TypeError。'
- en: '`NpyIter_AdvancedNew`, ValueError when `oa_ndim == 0` and `op_axes` is NULL'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NpyIter_AdvancedNew`，当`oa_ndim == 0`且`op_axes`为空时，会引发ValueError。'
- en: '`negative(bool_)`, TypeError when negative applied to booleans.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`negative(bool_)`，当对布尔数应用负数时，会引发TypeError。'
- en: '`subtract(bool_, bool_)`, TypeError when subtracting boolean from boolean.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtract(bool_, bool_)`，当从布尔数中减去布尔数时，会引发TypeError。'
- en: '`np.equal, np.not_equal`, object identity doesn’t override failed comparison.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.equal, np.not_equal`，对象标识不重载失败的比较。'
- en: '`np.equal, np.not_equal`, object identity doesn’t override non-boolean comparison.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.equal, np.not_equal`，对象标识不重载非布尔比较。'
- en: Deprecated boolean indexing behavior dropped. See Changes below for details.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已弃用布尔索引行为。有关详细信息，请参阅下面的更改。
- en: Deprecated `np.alterdot()` and `np.restoredot()` removed.
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已删除`np.alterdot()`和`np.restoredot()`的过时内容。
- en: FutureWarning to changed behavior
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FutureWarning to changed behavior
- en: See Changes section for more detail.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息请参阅更改部分。
- en: '`numpy.average` preserves subclasses'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.average`保留了子类'
- en: '`array == None` and `array != None` do element-wise comparison.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array == None` 和 `array != None` 进行逐个元素比较。'
- en: '`np.equal, np.not_equal`, object identity doesn’t override comparison result.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.equal, np.not_equal`，对象标识并不会覆盖比较结果。'
- en: dtypes are now always true
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型现在一直为真。
- en: Previously `bool(dtype)` would fall back to the default python implementation,
    which checked if `len(dtype) > 0`. Since `dtype` objects implement `__len__` as
    the number of record fields, `bool` of scalar dtypes would evaluate to `False`,
    which was unintuitive. Now `bool(dtype) == True` for all dtypes.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`bool(dtype)`会回到默认的python实现，即检查`len(dtype) > 0`。由于`dtype`对象实现`__len__`为记录字段的数量，标量数据类型的`bool`会求值为`False`，这是不直观的。现在对所有数据类型，`bool(dtype)
    == True`。
- en: '`__getslice__` and `__setslice__` are no longer needed in `ndarray` subclasses'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`__getslice__`和`__setslice__`在`ndarray`子类中不再需要。'
- en: When subclassing np.ndarray in Python 2.7, it is no longer _necessary_ to implement
    `__*slice__` on the derived class, as `__*item__` will intercept these calls correctly.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.7中，以`np.ndarray`为基类的子类，不再是在派生类中必须实现`__*slice__`，因为`__*item__`会正确拦截这些调用。
- en: Any code that did implement these will work exactly as before. Code that invokes``ndarray.__getslice__``
    (e.g. through `super(...).__getslice__`) will now issue a DeprecationWarning -
    `.__getitem__(slice(start, end))` should be used instead.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现这些功能的代码将与以前完全相同。调用`ndarray.__getslice__`的代码（例如通过`super(...).__getslice__`）现在会发出`DeprecationWarning`，应该使用`.__getitem__(slice(start,
    end))`代替。
- en: Indexing MaskedArrays/Constants with `...` (ellipsis) now returns MaskedArray
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`...`（省略号）索引`MaskedArrays/Constants`现在返回`MaskedArray`。
- en: This behavior mirrors that of np.ndarray, and accounts for nested arrays in
    MaskedArrays of object dtype, and ellipsis combined with other forms of indexing.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与`np.ndarray`相似，并适用于对象数据类型的`MaskedArrays`中的嵌套数组，以及与其他形式的索引结合使用的省略号。
- en: Error type changes
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 错误类型更改。
- en: '`numpy.hstack()` now throws `ValueError` instead of `IndexError` when input
    is empty.'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.hstack()` 现在在输入为空时抛出`ValueError`，而不是`IndexError`。'
- en: Functions taking an axis argument, when that argument is out of range, now throw
    `np.AxisError` instead of a mixture of `IndexError` and `ValueError`. For backwards
    compatibility, `AxisError` subclasses both of these.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当那个轴参数超出范围时，接受轴参数的函数现在会抛出`np.AxisError`，而不是`IndexError`和`ValueError`混合。为了向后兼容，`AxisError`会继承这两个错误。
- en: Tuple object dtypes
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组对象数据类型。
- en: Support has been removed for certain obscure dtypes that were unintentionally
    allowed, of the form `(old_dtype, new_dtype)`, where either of the dtypes is or
    contains the `object` dtype. As an exception, dtypes of the form `(object, [('name',
    object)])` are still supported due to evidence of existing use.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 已删除对某些意外允许的模糊数据类型的支持，这些模糊数据类型的形式为`(old_dtype, new_dtype)`，其中任一数据类型为含有`object`数据类型的`object`数据类型。作为一个例外，由于存在使用证据，形式为`(object,
    [('name', object)])`的数据类型仍然受支持。
- en: DeprecationWarning to error
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 废弃警告变为错误。
- en: See Changes section for more detail.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息，请参见更改部分。
- en: '`partition`, TypeError when non-integer partition index is used.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`partition`，在使用非整数分区索引时会引发`TypeError`。'
- en: '`NpyIter_AdvancedNew`, ValueError when `oa_ndim == 0` and `op_axes` is NULL'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NpyIter_AdvancedNew`，当`oa_ndim == 0`且`op_axes`为`NULL`时会引发`ValueError`。'
- en: '`negative(bool_)`, TypeError when negative applied to booleans.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`negative(bool_)`，当对布尔值应用负数时会引发`TypeError`。'
- en: '`subtract(bool_, bool_)`, TypeError when subtracting boolean from boolean.'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subtract(bool_, bool_)`，当从布尔值中减去布尔值时会引发`TypeError`。'
- en: '`np.equal, np.not_equal`, object identity doesn’t override failed comparison.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.equal, np.not_equal`，对象标识并不会覆盖比较错误。'
- en: '`np.equal, np.not_equal`, object identity doesn’t override non-boolean comparison.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.equal, np.not_equal`，对象标识并不会覆盖非布尔比较。'
- en: Deprecated boolean indexing behavior dropped. See Changes below for details.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的布尔索引行为已删除。有关详细信息，请参见下面的更改。
- en: Deprecated `np.alterdot()` and `np.restoredot()` removed.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的`np.alterdot()`和`np.restoredot()`已移除。
- en: FutureWarning to changed behavior
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 未来警告变为更改的行为。
- en: See Changes section for more detail.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 更多详细信息，请参见更改部分。
- en: '`numpy.average` preserves subclasses'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`numpy.average` 保留子类。'
- en: '`array == None` and `array != None` do element-wise comparison.'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`array == None` 和 `array != None` 进行逐个元素比较。'
- en: '`np.equal, np.not_equal`, object identity doesn’t override comparison result.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`np.equal, np.not_equal`，对象标识并不会覆盖比较结果。'
- en: dtypes are now always true
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类型现在一直为真。
- en: Previously `bool(dtype)` would fall back to the default python implementation,
    which checked if `len(dtype) > 0`. Since `dtype` objects implement `__len__` as
    the number of record fields, `bool` of scalar dtypes would evaluate to `False`,
    which was unintuitive. Now `bool(dtype) == True` for all dtypes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`bool(dtype)`会回退到默认的Python实现，该实现会检查`len(dtype) > 0`。由于`dtype`对象将`__len__`实现为记录字段的数量，标量dtype的`bool`评估为`False`，这是令人困惑的。现在对于所有dtype，`bool(dtype)
    == True`。
- en: '`__getslice__` and `__setslice__` are no longer needed in `ndarray` subclasses'
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在`ndarray`子类中不再需要`__getslice__`和`__setslice__`
- en: When subclassing np.ndarray in Python 2.7, it is no longer _necessary_ to implement
    `__*slice__` on the derived class, as `__*item__` will intercept these calls correctly.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在Python 2.7中派生np.ndarray时，不再需要在派生类上实现`__*slice__`，因为`__*item__`将正确拦截这些调用。
- en: Any code that did implement these will work exactly as before. Code that invokes``ndarray.__getslice__``
    (e.g. through `super(...).__getslice__`) will now issue a DeprecationWarning -
    `.__getitem__(slice(start, end))` should be used instead.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 实现了这些的任何代码将完全与以前相同。调用`ndarray.__getslice__`的代码（例如通过`super(...).__getslice__`）现在将发出DeprecationWarning
    - 应该改用`.__getitem__(slice(start, end))`。
- en: Indexing MaskedArrays/Constants with `...` (ellipsis) now returns MaskedArray
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`...`（省略号）索引MaskedArrays/Constants现在返回MaskedArray
- en: This behavior mirrors that of np.ndarray, and accounts for nested arrays in
    MaskedArrays of object dtype, and ellipsis combined with other forms of indexing.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 此行为与np.ndarray的行为类似，并且考虑了对象dtype的MaskedArrays中的嵌套数组以及与其他索引形式组合的省略号。
- en: C API changes
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C API更改
- en: GUfuncs on empty arrays and NpyIter axis removal
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对空数组和NpyIter轴的GUfuncs的处理
- en: It is now allowed to remove a zero-sized axis from NpyIter. Which may mean that
    code removing axes from NpyIter has to add an additional check when accessing
    the removed dimensions later on.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在允许从NpyIter中删除零大小的轴。这意味着从NpyIter中删除轴的代码在访问稍后被删除的维度时必须添加额外的检查。
- en: The largest followup change is that gufuncs are now allowed to have zero-sized
    inner dimensions. This means that a gufunc now has to anticipate an empty inner
    dimension, while this was never possible and an error raised instead.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的后续更改是，现在允许gufuncs具有零大小的内部维度。这意味着gufunc现在必须预期一个空的内部维度，而以前是不可能的，并且会引发错误。
- en: For most gufuncs no change should be necessary. However, it is now possible
    for gufuncs with a signature such as `(..., N, M) -> (..., M)` to return a valid
    result if `N=0` without further wrapping code.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数gufuncs，不需要进行任何更改。然而，现在对于具有`(..., N, M) -> (..., M)`这样的签名的gufuncs，如果`N=0`，则可以返回有效结果，而无需进一步的包装代码。
- en: '`PyArray_MapIterArrayCopyIfOverlap` added to NumPy C-API'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加了`PyArray_MapIterArrayCopyIfOverlap`到NumPy C-API
- en: Similar to `PyArray_MapIterArray` but with an additional `copy_if_overlap` argument.
    If `copy_if_overlap != 0`, checks if input has memory overlap with any of the
    other arrays and make copies as appropriate to avoid problems if the input is
    modified during the iteration. See the documentation for more complete documentation.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与`PyArray_MapIterArray`类似，但具有附加的`copy_if_overlap`参数。如果`copy_if_overlap != 0`，则检查输入是否与任何其他数组重叠，并根据需要进行复制，以避免在迭代期间修改输入时出现问题。有关更完整的文档，请参阅文档。
- en: GUfuncs on empty arrays and NpyIter axis removal
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对空数组和NpyIter轴的GUfuncs的处理
- en: It is now allowed to remove a zero-sized axis from NpyIter. Which may mean that
    code removing axes from NpyIter has to add an additional check when accessing
    the removed dimensions later on.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在允许从NpyIter中删除零大小的轴。这意味着从NpyIter中删除轴的代码在访问稍后被删除的维度时必须添加额外的检查。
- en: The largest followup change is that gufuncs are now allowed to have zero-sized
    inner dimensions. This means that a gufunc now has to anticipate an empty inner
    dimension, while this was never possible and an error raised instead.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的后续更改是，现在允许gufuncs具有零大小的内部维度。这意味着gufunc现在必须预期一个空的内部维度，而以前是不可能的，并且会引发错误。
- en: For most gufuncs no change should be necessary. However, it is now possible
    for gufuncs with a signature such as `(..., N, M) -> (..., M)` to return a valid
    result if `N=0` without further wrapping code.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数gufuncs，不需要进行任何更改。然而，现在对于具有`(..., N, M) -> (..., M)`这样的签名的gufuncs，如果`N=0`，则可以返回有效结果，而无需进行进一步的包装代码。
- en: '`PyArray_MapIterArrayCopyIfOverlap` added to NumPy C-API'
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加了`PyArray_MapIterArrayCopyIfOverlap`到NumPy C-API
- en: Similar to `PyArray_MapIterArray` but with an additional `copy_if_overlap` argument.
    If `copy_if_overlap != 0`, checks if input has memory overlap with any of the
    other arrays and make copies as appropriate to avoid problems if the input is
    modified during the iteration. See the documentation for more complete documentation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 与`PyArray_MapIterArray`类似，但有额外的`copy_if_overlap`参数。如果`copy_if_overlap != 0`，则检查输入是否与其他数组重叠，并根据需要进行复制，以避免在迭代过程中修改输入时出现问题。有关更完整的文档，请参阅文档。
- en: New Features
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新特性
- en: '`__array_ufunc__` added'
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加了`__array_ufunc__`
- en: This is the renamed and redesigned `__numpy_ufunc__`. Any class, ndarray subclass
    or not, can define this method or set it to `None` in order to override the behavior
    of NumPy’s ufuncs. This works quite similarly to Python’s `__mul__` and other
    binary operation routines. See the documentation for a more detailed description
    of the implementation and behavior of this new option. The API is provisional,
    we do not yet guarantee backward compatibility as modifications may be made pending
    feedback. See [NEP 13](http://www.numpy.org/neps/nep-0013-ufunc-overrides.html)
    and [documentation](https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst)
    for more details.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重命名和重新设计的`__numpy_ufunc__`。任何类，无论是否是ndarray子类，都可以定义这个方法或将其设置为`None`，以覆盖NumPy的ufunc行为。这与Python的`__mul__`和其他二进制操作例程非常相似。有关实现和此新选项行为的更详细描述，请参阅文档。API是临时的，我们尚未保证向后兼容性，因为可能会根据反馈意见做出修改。有关更多详细信息，请参阅[NEP
    13](http://www.numpy.org/neps/nep-0013-ufunc-overrides.html)和[文档](https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst)。
- en: New `positive` ufunc
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的`positive` ufunc
- en: This ufunc corresponds to unary *+*, but unlike *+* on an ndarray it will raise
    an error if array values do not support numeric operations.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ufunc对应于一元的*+*运算符，但与ndarray上的*+*不同，如果数组值不支持数值运算，它将引发错误。
- en: New `divmod` ufunc
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的`divmod` ufunc
- en: This ufunc corresponds to the Python builtin *divmod*, and is used to implement
    *divmod* when called on numpy arrays. `np.divmod(x, y)` calculates a result equivalent
    to `(np.floor_divide(x, y), np.remainder(x, y))` but is approximately twice as
    fast as calling the functions separately.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ufunc对应于Python内置的*divmod*，用于在numpy数组上调用*divmod*时使用。`np.divmod(x, y)`计算的结果等效于`(np.floor_divide(x,
    y), np.remainder(x, y))`，但速度大约是分别调用这些函数的两倍。
- en: '`np.isnat` ufunc tests for NaT special datetime and timedelta values'
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.isnat` ufunc 用于测试NaT特殊的日期时间和时间差数值'
- en: The new ufunc `np.isnat` finds the positions of special NaT values within datetime
    and timedelta arrays. This is analogous to `np.isnan`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 新的ufunc`np.isnat`可以在日期时间和时间差数组中找到特殊NaT值的位置。这类似于`np.isnan`。
- en: '`np.heaviside` ufunc computes the Heaviside function'
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.heaviside` ufunc计算Heaviside函数'
- en: 'The new function `np.heaviside(x, h0)` (a ufunc) computes the Heaviside function:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数`np.heaviside(x, h0)`（一个ufunc）计算Heaviside函数：
- en: '[PRE7]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`np.block` function for creating blocked arrays'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为创建块数组的`np.block`函数
- en: 'Add a new `block` function to the current stacking functions `vstack`, `hstack`,
    and `stack`. This allows concatenation across multiple axes simultaneously, with
    a similar syntax to array creation, but where elements can themselves be arrays.
    For instance:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新的`block`函数到当前的叠加函数`vstack`、`hstack`和`stack`中。这允许同时沿多个轴进行连接，具有类似数组创建的语法，不同之处在于元素本身可以是数组。例如：
- en: '[PRE8]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: While primarily useful for block matrices, this works for arbitrary dimensions
    of arrays.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然主要用于块矩阵，但对于数组的任意维度也适用。
- en: It is similar to Matlab’s square bracket notation for creating block matrices.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于Matlab用于创建块矩阵的方括号表示法。
- en: '`isin` function, improving on `in1d`'
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`isin`函数，对`in1d`进行了改进'
- en: The new function `isin` tests whether each element of an N-dimensional array
    is present anywhere within a second array. It is an enhancement of `in1d` that
    preserves the shape of the first array.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 新函数`isin`测试N维数组的每个元素是否存在于第二个数组中的任何位置。它是`in1d`的增强版，保留了第一个数组的形状。
- en: Temporary elision
  id: totrans-297
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时省略
- en: On platforms providing the `backtrace` function NumPy will try to avoid creating
    temporaries in expression involving basic numeric types. For example `d = a +
    b + c` is transformed to `d = a + b; d += c` which can improve performance for
    large arrays as less memory bandwidth is required to perform the operation.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供`backtrace`函数的平台上，NumPy将尝试避免在涉及基本数值类型的表达式中创建临时变量。例如`d = a + b + c`被转换为`d
    = a + b; d += c`，这样可以提高大数组的性能，因为执行操作需要更少的内存带宽。
- en: '`axes` argument for `unique`'
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`unique`的`axes`参数'
- en: In an N-dimensional array, the user can now choose the axis along which to look
    for duplicate N-1-dimensional elements using `numpy.unique`. The original behaviour
    is recovered if `axis=None` (default).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在N维数组中，用户现在可以选择沿其进行查找重复N-1维元素的轴，使用`numpy.unique`。如果`axis=None`（默认值），则恢复原始行为。
- en: '`np.gradient` now supports unevenly spaced data'
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.gradient`现在支持不均匀间距数据'
- en: 'Users can now specify a not-constant spacing for data. In particular `np.gradient`
    can now take:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以为数据指定不均匀间距。特别是`np.gradient`现在可以使用：
- en: A single scalar to specify a sample distance for all dimensions.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单个标量用于指定所有维度的采样距离。
- en: N scalars to specify a constant sample distance for each dimension. i.e. `dx`,
    `dy`, `dz`, …
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: N个标量用于指定每个维度的常量采样距离。即`dx`，`dy`，`dz`，…
- en: N arrays to specify the coordinates of the values along each dimension of F.
    The length of the array must match the size of the corresponding dimension
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: N个数组用于指定F的每个维度上数值的坐标。数组的长度必须与相应维度的大小相匹配
- en: Any combination of N scalars/arrays with the meaning of 2\. and 3.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任意数量的N个标量/数组，表示第2和第3个含义。
- en: 'This means that, e.g., it is now possible to do the following:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '这意味着现在可以做以下操作： '
- en: '[PRE9]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Support for returning arrays of arbitrary dimensions in `apply_along_axis`
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持在`apply_along_axis`中返回任意维度的数组
- en: Previously, only scalars or 1D arrays could be returned by the function passed
    to `apply_along_axis`. Now, it can return an array of any dimensionality (including
    0D), and the shape of this array replaces the axis of the array being iterated
    over.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，只能通过传递给`apply_along_axis`的函数返回标量或1D数组。现在可以返回任意维度（包括0D）的数组，并且这个数组的形状将替换正在迭代的数组的轴。
- en: '`.ndim` property added to `dtype` to complement `.shape`'
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为`dtype`添加了`.ndim`属性，以补充`.shape`。
- en: For consistency with `ndarray` and `broadcast`, `d.ndim` is a shorthand for
    `len(d.shape)`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与`ndarray`和`broadcast`保持一致，`d.ndim`是`len(d.shape)`的简写。
- en: Support for tracemalloc in Python 3.6
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 3.6中支持tracemalloc
- en: NumPy now supports memory tracing with [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    module of Python 3.6 or newer. Memory allocations from NumPy are placed into the
    domain defined by `numpy.lib.tracemalloc_domain`. Note that NumPy allocation will
    not show up in [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    of earlier Python versions.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy现在支持与Python 3.6或更新版本的[tracemalloc](https://docs.python.org/3/library/tracemalloc.html)模块一起进行内存跟踪。NumPy的内存分配被放置到由`numpy.lib.tracemalloc_domain`定义的域中。请注意，NumPy分配将不会在早期Python版本的[tracemalloc](https://docs.python.org/3/library/tracemalloc.html)中显示出来。
- en: NumPy may be built with relaxed stride checking debugging
  id: totrans-315
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy可能使用放松的步幅检查调试构建
- en: Setting NPY_RELAXED_STRIDES_DEBUG=1 in the environment when relaxed stride checking
    is enabled will cause NumPy to be compiled with the affected strides set to the
    maximum value of npy_intp in order to help detect invalid usage of the strides
    in downstream projects. When enabled, invalid usage often results in an error
    being raised, but the exact type of error depends on the details of the code.
    TypeError and OverflowError have been observed in the wild.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 当放松步幅检查时，在启用放松步幅检查时，将环境中的NPY_RELAXED_STRIDES_DEBUG=1设置为npy_intp的最大值，以帮助检测下游项目中步幅的无效使用。启用后，无效使用通常会导致错误被引发，但确切的错误类型取决于代码的细节。在实际应用中观察到了TypeError和OverflowError。
- en: It was previously the case that this option was disabled for releases and enabled
    in master and changing between the two required editing the code. It is now disabled
    by default but can be enabled for test builds.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的情况是该选项在发布时被禁用，在主分支中启用，并且在两者之间切换需要编辑代码。现在默认情况下被禁用，但可以在测试构建中启用。
- en: '`__array_ufunc__` added'
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加了`__array_ufunc__`
- en: This is the renamed and redesigned `__numpy_ufunc__`. Any class, ndarray subclass
    or not, can define this method or set it to `None` in order to override the behavior
    of NumPy’s ufuncs. This works quite similarly to Python’s `__mul__` and other
    binary operation routines. See the documentation for a more detailed description
    of the implementation and behavior of this new option. The API is provisional,
    we do not yet guarantee backward compatibility as modifications may be made pending
    feedback. See [NEP 13](http://www.numpy.org/neps/nep-0013-ufunc-overrides.html)
    and [documentation](https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst)
    for more details.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这是重命名和重新设计的`__numpy_ufunc__`. 任何类，无论是否是ndarray子类，都可以定义这个方法或将其设置为`None`，以覆盖NumPy的ufunc的行为。
    这与Python的`__mul__`和其他二元操作例程相似。 有关此新选项的实现和行为的更详细描述，请参阅文档。 API 是临时的，我们尚未保证向后兼容性，因为可能会根据反馈做出修改。
    有关更多详细信息，请参阅[NEP 13](http://www.numpy.org/neps/nep-0013-ufunc-overrides.html)和[文档](https://github.com/numpy/numpy/blob/master/doc/source/reference/arrays.classes.rst)。
- en: New `positive` ufunc
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的`positive` ufunc
- en: This ufunc corresponds to unary *+*, but unlike *+* on an ndarray it will raise
    an error if array values do not support numeric operations.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ufunc对应于一元*+*，但与ndarray上的*+*不同，如果数组值不支持数值操作，它将引发错误。
- en: New `divmod` ufunc
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的`divmod` ufunc
- en: This ufunc corresponds to the Python builtin *divmod*, and is used to implement
    *divmod* when called on numpy arrays. `np.divmod(x, y)` calculates a result equivalent
    to `(np.floor_divide(x, y), np.remainder(x, y))` but is approximately twice as
    fast as calling the functions separately.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这个ufunc对应于Python内置的*divmod*，用于在numpy数组上调用*divmod*时使用。`np.divmod(x, y)` 计算等同于
    `(np.floor_divide(x, y), np.remainder(x, y))` 的结果，但是调用这两个函数的速度大约快两倍。
- en: '`np.isnat` ufunc tests for NaT special datetime and timedelta values'
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.isnat` ufunc 用于测试 NaT 日期时间和时间差值的特殊值'
- en: The new ufunc `np.isnat` finds the positions of special NaT values within datetime
    and timedelta arrays. This is analogous to `np.isnan`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 新的ufunc `np.isnat` 在日期时间数组中查找特殊NaT值的位置。这类似于`np.isnan`。
- en: '`np.heaviside` ufunc computes the Heaviside function'
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.heaviside` ufunc 计算 Heaviside 函数'
- en: 'The new function `np.heaviside(x, h0)` (a ufunc) computes the Heaviside function:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 新的函数`np.heaviside(x, h0)`（一个ufunc）计算 Heaviside 函数：
- en: '[PRE10]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`np.block` function for creating blocked arrays'
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.block` 函数用于创建块数组'
- en: 'Add a new `block` function to the current stacking functions `vstack`, `hstack`,
    and `stack`. This allows concatenation across multiple axes simultaneously, with
    a similar syntax to array creation, but where elements can themselves be arrays.
    For instance:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个新的`block`函数到当前的叠加函数`vstack`，`hstack`和`stack`。这允许同时沿多个轴进行连接，语法类似于数组创建，但元素本身可以是数组。
    例如：
- en: '[PRE11]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: While primarily useful for block matrices, this works for arbitrary dimensions
    of arrays.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然主要用于块矩阵，但它适用于数组的任意维度。
- en: It is similar to Matlab’s square bracket notation for creating block matrices.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于 Matlab 用于创建块矩阵的方括号符号表示法。
- en: '`isin` function, improving on `in1d`'
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`isin` 函数，对`in1d`进行了改进'
- en: The new function `isin` tests whether each element of an N-dimensional array
    is present anywhere within a second array. It is an enhancement of `in1d` that
    preserves the shape of the first array.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 新的函数`isin` 用于测试N维数组中每个元素是否出现在第二个数组中的任何位置。这是对`in1d`的增强，它保留了第一个数组的形状。
- en: Temporary elision
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时省略
- en: On platforms providing the `backtrace` function NumPy will try to avoid creating
    temporaries in expression involving basic numeric types. For example `d = a +
    b + c` is transformed to `d = a + b; d += c` which can improve performance for
    large arrays as less memory bandwidth is required to perform the operation.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 在提供`backtrace`函数的平台上，NumPy 将尽量避免在涉及基本数值类型的表达式中创建临时变量。例如 `d = a + b + c` 被转换为
    `d = a + b; d += c`，这样可以提高大数组的性能，因为执行操作所需的内存带宽更少。
- en: '`axes` argument for `unique`'
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`unique` 的 `axes` 参数'
- en: In an N-dimensional array, the user can now choose the axis along which to look
    for duplicate N-1-dimensional elements using `numpy.unique`. The original behaviour
    is recovered if `axis=None` (default).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个N维数组中，用户现在可以选择沿着哪个轴查找重复的N-1维元素，使用`numpy.unique`。如果`axis=None`（默认值），将恢复原始行为。
- en: '`np.gradient` now supports unevenly spaced data'
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.gradient` 现在支持不均匀间隔的数据'
- en: 'Users can now specify a not-constant spacing for data. In particular `np.gradient`
    can now take:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 用户现在可以指定非常量间距的数据。特别是，`np.gradient`现在可以接受：
- en: A single scalar to specify a sample distance for all dimensions.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个单一的标量用于指定所有维度的样本距离。
- en: N scalars to specify a constant sample distance for each dimension. i.e. `dx`,
    `dy`, `dz`, …
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: N 个标量用于指定每个维度的常量样本距离。例如 `dx`、`dy`、`dz` 等。
- en: N arrays to specify the coordinates of the values along each dimension of F.
    The length of the array must match the size of the corresponding dimension
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: N 个数组用于指定 F 沿每个维度的值的坐标。数组的长度必须与相应维度的大小相匹配
- en: Any combination of N scalars/arrays with the meaning of 2\. and 3.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有2.和3.含义的 N 个标量/数组的任意组合。
- en: 'This means that, e.g., it is now possible to do the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，例如，现在可以执行以下操作：
- en: '[PRE12]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Support for returning arrays of arbitrary dimensions in `apply_along_axis`
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持在 `apply_along_axis` 中返回任意维度的数组
- en: Previously, only scalars or 1D arrays could be returned by the function passed
    to `apply_along_axis`. Now, it can return an array of any dimensionality (including
    0D), and the shape of this array replaces the axis of the array being iterated
    over.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，`apply_along_axis`中传递给函数的函数只能返回标量或一维数组。现在，它可以返回任意维度的数组（包括0维），并且此数组的形状取代了正在迭代的数组的轴。
- en: '`.ndim` property added to `dtype` to complement `.shape`'
  id: totrans-350
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`.ndim` 属性被添加到 `dtype` 中以补充`.shape`'
- en: For consistency with `ndarray` and `broadcast`, `d.ndim` is a shorthand for
    `len(d.shape)`.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与 `ndarray` 和 `broadcast` 保持一致，`d.ndim` 是 `len(d.shape)` 的简写。
- en: Support for tracemalloc in Python 3.6
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 3.6 支持 tracemalloc
- en: NumPy now supports memory tracing with [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    module of Python 3.6 or newer. Memory allocations from NumPy are placed into the
    domain defined by `numpy.lib.tracemalloc_domain`. Note that NumPy allocation will
    not show up in [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    of earlier Python versions.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy 现在支持使用 Python 3.6 或更新版本的 [tracemalloc](https://docs.python.org/3/library/tracemalloc.html)
    模块进行内存跟踪。来自 NumPy 的内存分配被放入了由 `numpy.lib.tracemalloc_domain` 定义的领域中。注意，NumPy 分配不会显示在早期
    Python 版本的 [tracemalloc](https://docs.python.org/3/library/tracemalloc.html) 中。
- en: NumPy may be built with relaxed stride checking debugging
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy 可能编译时启用松弛步幅检查调试
- en: Setting NPY_RELAXED_STRIDES_DEBUG=1 in the environment when relaxed stride checking
    is enabled will cause NumPy to be compiled with the affected strides set to the
    maximum value of npy_intp in order to help detect invalid usage of the strides
    in downstream projects. When enabled, invalid usage often results in an error
    being raised, but the exact type of error depends on the details of the code.
    TypeError and OverflowError have been observed in the wild.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在启用松弛步幅检查时，在环境中设置 NPY_RELAXED_STRIDES_DEBUG=1 会导致 NumPy 被编译时受影响的步幅设置为 npy_intp
    的最大值，以帮助检测下游项目中步幅的无效使用。启用时，无效使用通常会导致错误被引发，但确切的错误类型取决于代码的细节。观察到过 TypeError 和 OverflowError。
- en: It was previously the case that this option was disabled for releases and enabled
    in master and changing between the two required editing the code. It is now disabled
    by default but can be enabled for test builds.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 之前这个选项默认情况是在发布版中禁用的，并在主代码中启用，转变两者之间需要编辑代码。现在默认情况下禁用，但可以在测试构建中启用。
- en: Improvements
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进
- en: Ufunc behavior for overlapping inputs
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重叠输入的ufunc行为
- en: Operations where ufunc input and output operands have memory overlap produced
    undefined results in previous NumPy versions, due to data dependency issues. In
    NumPy 1.13.0, results from such operations are now defined to be the same as for
    equivalent operations where there is no memory overlap.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的 NumPy 版本中，ufunc 输入和输出操作数有内存重叠会产生未定义结果，这是由于数据依赖性问题。在 NumPy 1.13.0 中，从这些操作中产生的结果现在被定义为与不存在内存重叠的等效操作相同。
- en: Operations affected now make temporary copies, as needed to eliminate data dependency.
    As detecting these cases is computationally expensive, a heuristic is used, which
    may in rare cases result to needless temporary copies. For operations where the
    data dependency is simple enough for the heuristic to analyze, temporary copies
    will not be made even if the arrays overlap, if it can be deduced copies are not
    necessary. As an example,``np.add(a, b, out=a)`` will not involve copies.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 受影响的操作现在会产生临时副本，以消除数据依赖性所需的副本。由于检测这些情况在计算上是昂贵的，因此使用了一种启发式方法，可能在极少数情况下导致不必要的临时副本。对于启发式算法能够分析数据依赖性足够简单的操作，即使数组重叠，也不会产生临时副本，如果可以推断不需要副本的话。例如，``np.add(a,
    b, out=a)`` 不会涉及副本。
- en: 'To illustrate a previously undefined operation:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个以前未定义的操作：
- en: '[PRE13]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In NumPy 1.13.0 the last line is guaranteed to be equivalent to:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在 NumPy 1.13.0 中，最后一行保证等同于：
- en: '[PRE14]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A similar operation with simple non-problematic data dependence is:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 与简单的非有问题的数据依赖关系进行类似的操作是：
- en: '[PRE15]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It will continue to produce the same results as in previous NumPy versions,
    and will not involve unnecessary temporary copies.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 它将继续产生与以前的NumPy版本相同的结果，并且不会涉及不必要的临时副本。
- en: 'The change applies also to in-place binary operations, for example:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化也适用于就地二进制操作，例如：
- en: '[PRE16]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This statement is now guaranteed to be equivalent to `x[...] = x + x.T`, whereas
    in previous NumPy versions the results were undefined.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这个语句保证等同于`x[...] = x + x.T`，而在之前的NumPy版本中，结果是未定义的。
- en: Partial support for 64-bit f2py extensions with MinGW
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于MinGW的64位f2py扩展的部分支持
- en: Extensions that incorporate Fortran libraries can now be built using the free
    [MinGW](https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/)
    toolset, also under Python 3.5\. This works best for extensions that only do calculations
    and uses the runtime modestly (reading and writing from files, for instance).
    Note that this does not remove the need for Mingwpy; if you make extensive use
    of the runtime, you will most likely run into [issues](https://mingwpy.github.io/issues.html).
    Instead, it should be regarded as a band-aid until Mingwpy is fully functional.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用自由的[MinGW](https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/)工具集来构建包含Fortran库的扩展，也可以在Python
    3.5下使用。这对于仅进行计算并且适度使用运行时（例如读写文件）的扩展非常有效。请注意，这不会消除Mingwpy的需求；如果你大量使用运行时，你很可能会遇到[问题](https://mingwpy.github.io/issues.html)。相反，它应该被视为一种临时措施，直到Mingwpy完全可用。
- en: Extensions can also be compiled using the MinGW toolset using the runtime library
    from the (moveable) WinPython 3.4 distribution, which can be useful for programs
    with a PySide1/Qt4 front-end.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展还可以使用MinGW工具集和(movable) WinPython 3.4发行版的运行库进行编译，这对具有PySide1/Qt4前端的程序非常有用。
- en: Performance improvements for `packbits` and `unpackbits`
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`packbits`和`unpackbits`的性能改进'
- en: The functions `numpy.packbits` with boolean input and `numpy.unpackbits` have
    been optimized to be a significantly faster for contiguous data.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.packbits`函数对布尔输入和`numpy.unpackbits`进行了优化，使其在连续数据上显著更快。'
- en: Fix for PPC long double floating point information
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复了PPC长双精度浮点信息
- en: In previous versions of NumPy, the `finfo` function returned invalid information
    about the [double double](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic)
    format of the `longdouble` float type on Power PC (PPC). The invalid values resulted
    from the failure of the NumPy algorithm to deal with the variable number of digits
    in the significand that are a feature of *PPC long doubles*. This release by-passes
    the failing algorithm by using heuristics to detect the presence of the PPC double
    double format. A side-effect of using these heuristics is that the `finfo` function
    is faster than previous releases.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的NumPy版本中，`finfo`函数返回了有关Power PC（PPC）上`longdouble`浮点类型的[双倍浮点数](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic)格式的无效信息。无效值是由于NumPy算法未能处理*PPC长双精度*中变化位数的尾数所导致的。此版本通过启发式方法检测PPC双重浮点格式来绕过失败的算法。使用这些启发式方法的副作用是，`finfo`函数比以前的版本快。
- en: Better default repr for `ndarray` subclasses
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ndarray`子类的更好默认repr'
- en: Subclasses of ndarray with no `repr` specialization now correctly indent their
    data and type lines.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`repr`特殊化的ndarray子类现在正确缩进其数据和类型行。
- en: More reliable comparisons of masked arrays
  id: totrans-380
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更可靠的掩码数组比较
- en: Comparisons of masked arrays were buggy for masked scalars and failed for structured
    arrays with dimension higher than one. Both problems are now solved. In the process,
    it was ensured that in getting the result for a structured array, masked fields
    are properly ignored, i.e., the result is equal if all fields that are non-masked
    in both are equal, thus making the behaviour identical to what one gets by comparing
    an unstructured masked array and then doing `.all()` over some axis.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 掩码数组的比较对于掩码标量存在错误，并且对于维数大于1的结构化数组存在失败。这两个问题现在都已解决。在此过程中，确保在获取结构化数组的结果时，正确忽略掩码字段，即，如果两者中所有非掩码字段相等，则结果相等，使行为等同于比较一个非结构化掩码数组然后在某个轴上执行`.all()`的行为。
- en: np.matrix with booleans elements can now be created using the string syntax
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: np.matrix现在可以使用布尔元素的字符串语法创建
- en: '`np.matrix` failed whenever one attempts to use it with booleans, e.g., `np.matrix(''True'')`.
    Now, this works as expected.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 每当尝试使用布尔值时，`np.matrix`都会失败，例如`np.matrix('True')`。现在，这将按预期运行。
- en: More `linalg` operations now accept empty vectors and matrices
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在更多的`linalg`操作接受空向量和矩阵
- en: 'All of the following functions in `np.linalg` now work when given input arrays
    with a 0 in the last two dimensions: `det`, `slogdet`, `pinv`, `eigvals`, `eigvalsh`,
    `eig`, `eigh`.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 当最后两个维度中有0时，`np.linalg`中的所有以下函数现在在给定输入数组时都会有作用：`det`、`slogdet`、`pinv`、`eigvals`、`eigvalsh`、`eig`、`eigh`。
- en: Bundled version of LAPACK is now 3.2.2
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LAPACK的捆绑版本现在是3.2.2
- en: NumPy comes bundled with a minimal implementation of lapack for systems without
    a lapack library installed, under the name of `lapack_lite`. This has been upgraded
    from LAPACK 3.0.0 (June 30, 1999) to LAPACK 3.2.2 (June 30, 2010). See the [LAPACK
    changelogs](http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases)
    for details on the all the changes this entails.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy随附了最小的lapack实现，适用于未安装lapack库的系统，名为`lapack_lite`。这已经从LAPACK 3.0.0（1999年6月30日）升级到LAPACK
    3.2.2（2010年6月30日）。详情请参阅[LAPACK更改日志](http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases)。
- en: While no new features are exposed through `numpy`, this fixes some bugs regarding
    “workspace” sizes, and in some places may use faster algorithms.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有通过`numpy`暴露新功能，但这解决了有关“工作空间”大小的一些错误，并且在某些情况下可能使用更快的算法。
- en: '`reduce` of `np.hypot.reduce` and `np.logical_xor` allowed in more cases'
  id: totrans-389
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.hypot.reduce`和`np.logical_xor`的`reduce`在更多情况下被允许'
- en: This now works on empty arrays, returning 0, and can reduce over multiple axes.
    Previously, a `ValueError` was thrown in these cases.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在空数组上运行，并返回0，并且可以在多个轴上进行缩减。在这些情况下以前会抛出`ValueError`。
- en: Better `repr` of object arrays
  id: totrans-391
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化对象数组的`repr`
- en: Object arrays that contain themselves no longer cause a recursion error.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 不再出现包含自身的对象数组导致递归错误的情况。
- en: Object arrays that contain `list` objects are now printed in a way that makes
    clear the difference between a 2d object array, and a 1d object array of lists.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`list`对象的对象数组现在以一种清晰地区分二维对象数组和包含列表的一维对象数组的方式打印出来。
- en: Ufunc behavior for overlapping inputs
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重叠输入的ufunc行为
- en: Operations where ufunc input and output operands have memory overlap produced
    undefined results in previous NumPy versions, due to data dependency issues. In
    NumPy 1.13.0, results from such operations are now defined to be the same as for
    equivalent operations where there is no memory overlap.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在以前的NumPy版本中，ufunc输入和输出操作数存在内存重叠时，由于数据依赖性问题，此类操作产生未定义的结果。在NumPy 1.13.0中，这类操作的结果现在被定义为与不存在内存重叠的操作的等效操作的结果相同。
- en: Operations affected now make temporary copies, as needed to eliminate data dependency.
    As detecting these cases is computationally expensive, a heuristic is used, which
    may in rare cases result to needless temporary copies. For operations where the
    data dependency is simple enough for the heuristic to analyze, temporary copies
    will not be made even if the arrays overlap, if it can be deduced copies are not
    necessary. As an example,``np.add(a, b, out=a)`` will not involve copies.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 受影响的操作现在将作临时复制，以消除数据依赖关系。由于检测这些情况在计算上是昂贵的，因此使用了一种启发式方法，这可能在极少数情况下导致不必要的临时复制。对于启发式分析能够分析的数据依赖性较简单的操作，即使数组重叠，也将不进行复制，如果能推断出不需要复制。例如，``np.add(a,
    b, out=a)``将不涉及复制。
- en: 'To illustrate a previously undefined operation:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 举例说明先前未定义的操作：
- en: '[PRE17]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In NumPy 1.13.0 the last line is guaranteed to be equivalent to:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy 1.13.0中，最后一行现在保证等同于：
- en: '[PRE18]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A similar operation with simple non-problematic data dependence is:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 具有简单且无问题的数据依赖关系的类似操作是：
- en: '[PRE19]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: It will continue to produce the same results as in previous NumPy versions,
    and will not involve unnecessary temporary copies.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 它将继续产生与之前NumPy版本相同的结果，并且不会涉及不必要的临时复制。
- en: 'The change applies also to in-place binary operations, for example:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 该变化也适用于原地二进制操作，例如：
- en: '[PRE20]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This statement is now guaranteed to be equivalent to `x[...] = x + x.T`, whereas
    in previous NumPy versions the results were undefined.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该语句保证等同于`x[...] = x + x.T`，而在以前的NumPy版本中，结果是未定义的。
- en: Partial support for 64-bit f2py extensions with MinGW
  id: totrans-407
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对MinGW的64位f2py扩展的部分支持
- en: Extensions that incorporate Fortran libraries can now be built using the free
    [MinGW](https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/)
    toolset, also under Python 3.5\. This works best for extensions that only do calculations
    and uses the runtime modestly (reading and writing from files, for instance).
    Note that this does not remove the need for Mingwpy; if you make extensive use
    of the runtime, you will most likely run into [issues](https://mingwpy.github.io/issues.html).
    Instead, it should be regarded as a band-aid until Mingwpy is fully functional.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 通过免费的[MinGW](https://sf.net/projects/mingw-w64/files/Toolchains%20targetting%20Win64/Personal%20Builds/mingw-builds/6.2.0/threads-win32/seh/)工具集，现在可以构建包含Fortran库的扩展，也支持Python
    3.5。这对于只进行计算并且适度使用运行时（例如读写文件）的扩展效果最佳。需要注意这并不意味着不再需要Mingwpy；如果你大量使用运行时，很可能会遇到[问题](https://mingwpy.github.io/issues.html)。相反，它应该被看作是一种临时措施，直到Mingwpy完全可用为止。
- en: Extensions can also be compiled using the MinGW toolset using the runtime library
    from the (moveable) WinPython 3.4 distribution, which can be useful for programs
    with a PySide1/Qt4 front-end.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 使用（可移动的）WinPython 3.4发行版的运行时库，也可以使用MinGW工具集编译扩展，这对于具有PySide1/Qt4前端的程序非常有用。
- en: Performance improvements for `packbits` and `unpackbits`
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`packbits`和`unpackbits`的性能改进'
- en: The functions `numpy.packbits` with boolean input and `numpy.unpackbits` have
    been optimized to be a significantly faster for contiguous data.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.packbits`和`numpy.unpackbits`函数已经优化，对于连续数据，性能显著提升。'
- en: Fix for PPC long double floating point information
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复了PPC长双浮点信息的问题
- en: In previous versions of NumPy, the `finfo` function returned invalid information
    about the [double double](https://en.wikipedia.org/wiki/Quadruple-precision_floating-point_format#Double-double_arithmetic)
    format of the `longdouble` float type on Power PC (PPC). The invalid values resulted
    from the failure of the NumPy algorithm to deal with the variable number of digits
    in the significand that are a feature of *PPC long doubles*. This release by-passes
    the failing algorithm by using heuristics to detect the presence of the PPC double
    double format. A side-effect of using these heuristics is that the `finfo` function
    is faster than previous releases.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的NumPy版本中，`finfo`函数返回了关于Power PC（PPC）上的`longdouble`浮点类型的*double double*格式的无效信息。无效值是由于NumPy算法未能处理*PPC长双浮点数*中变化的小数位数所导致的。此版本通过启发式算法来避开失败的算法，以侦测PPC
    double double格式。使用这些启发算法的副作用是，`finfo`函数比之前的版本更快。
- en: Better default repr for `ndarray` subclasses
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ndarray`子类的更好默认repr'
- en: Subclasses of ndarray with no `repr` specialization now correctly indent their
    data and type lines.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 没有`repr`特殊化的ndarray子类现在可以正确缩进它们的数据和类型行。
- en: More reliable comparisons of masked arrays
  id: totrans-416
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 掩码数组的比较更可靠了
- en: Comparisons of masked arrays were buggy for masked scalars and failed for structured
    arrays with dimension higher than one. Both problems are now solved. In the process,
    it was ensured that in getting the result for a structured array, masked fields
    are properly ignored, i.e., the result is equal if all fields that are non-masked
    in both are equal, thus making the behaviour identical to what one gets by comparing
    an unstructured masked array and then doing `.all()` over some axis.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 掩码数组的比较对于掩码标量存在错误，并且对于维度大于1的结构化数组存在失败。这两个问题现在都已解决。在这个过程中，确保在获得结构化数组的结果时，忽略掩码字段，即，如果两者中所有非掩码字段相等，则结果相等，使行为与比较无结构掩码数组后在某些轴上进行`.all()`相同。
- en: np.matrix with booleans elements can now be created using the string syntax
  id: totrans-418
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在可以使用字符串语法创建包含布尔元素的`np.matrix`
- en: '`np.matrix` failed whenever one attempts to use it with booleans, e.g., `np.matrix(''True'')`.
    Now, this works as expected.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，每当尝试将`np.matrix`与布尔值一起使用时，例如，`np.matrix('True')`，都会失败。现在，这可以按预期工作。
- en: More `linalg` operations now accept empty vectors and matrices
  id: totrans-420
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在，更多`linalg`操作可以接受空向量和矩阵
- en: 'All of the following functions in `np.linalg` now work when given input arrays
    with a 0 in the last two dimensions: `det`, `slogdet`, `pinv`, `eigvals`, `eigvalsh`,
    `eig`, `eigh`.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`np.linalg`中的以下函数，现在在最后两个维度中有0的输入数组时都可以工作：`det`、`slogdet`、`pinv`、`eigvals`、`eigvalsh`、`eig`、`eigh`。
- en: Bundled version of LAPACK is now 3.2.2
  id: totrans-422
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 绑定的LAPACK版本现在是3.2.2
- en: NumPy comes bundled with a minimal implementation of lapack for systems without
    a lapack library installed, under the name of `lapack_lite`. This has been upgraded
    from LAPACK 3.0.0 (June 30, 1999) to LAPACK 3.2.2 (June 30, 2010). See the [LAPACK
    changelogs](http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases)
    for details on the all the changes this entails.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy内置了一个最小实现的lapack，用于在没有安装lapack库的系统中使用，名为`lapack_lite`。它已从LAPACK 3.0.0（1999年6月30日）升级到LAPACK
    3.2.2（2010年6月30日）。有关这意味着的所有更改的详细信息，请参见[LAPACK更改日志](http://www.netlib.org/lapack/release_notes.html#_4_history_of_lapack_releases)。
- en: While no new features are exposed through `numpy`, this fixes some bugs regarding
    “workspace” sizes, and in some places may use faster algorithms.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`numpy`没有暴露任何新功能，但它修复了一些关于“工作空间”大小的错误，并且在某些地方可能使用更快的算法。
- en: '`reduce` of `np.hypot.reduce` and `np.logical_xor` allowed in more cases'
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.hypot.reduce`和`np.logical_xor`的`reduce`在更多情况下允许'
- en: This now works on empty arrays, returning 0, and can reduce over multiple axes.
    Previously, a `ValueError` was thrown in these cases.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在可以在空数组上进行，返回0，并且可以减少多个轴上。以前，在这些情况下会引发`ValueError`。
- en: Better `repr` of object arrays
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象数组的更好的`repr`
- en: Object arrays that contain themselves no longer cause a recursion error.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 不再导致递归错误包含自己的对象数组。
- en: Object arrays that contain `list` objects are now printed in a way that makes
    clear the difference between a 2d object array, and a 1d object array of lists.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 包含`list`对象的对象数组现在以一种清晰地区分二维对象数组和包含列表的一维对象数组的方式打印。
- en: Changes
  id: totrans-430
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更
- en: '`argsort` on masked arrays takes the same default arguments as `sort`'
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏蔽数组上的`argsort`采用相同的默认参数作为`sort`
- en: By default, `argsort` now places the masked values at the end of the sorted
    array, in the same way that `sort` already did. Additionally, the `end_with` argument
    is added to `argsort`, for consistency with `sort`. Note that this argument is
    not added at the end, so breaks any code that passed `fill_value` as a positional
    argument.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`argsort`现在将屏蔽值放在排序后的数组末尾，就像`sort`已经做的那样。此外，为了与`sort`保持一致，还添加了`end_with`参数到`argsort`。请注意，这个参数不是添加到末尾的，因此会破坏将`fill_value`作为位置参数传递的任何代码。
- en: '`average` now preserves subclasses'
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`average`现在保留子类'
- en: For ndarray subclasses, `numpy.average` will now return an instance of the subclass,
    matching the behavior of most other NumPy functions such as `mean`. As a consequence,
    also calls that returned a scalar may now return a subclass array scalar.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ndarray子类，`numpy.average`现在将返回一个子类的实例，与大多数其他NumPy函数（如`mean`）的行为相匹配。因此，现在可能返回一个子类数组标量的调用也可能返回标量。
- en: '`array == None` and `array != None` do element-wise comparison'
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`array == None`和`array != None`进行逐元素比较'
- en: Previously these operations returned scalars `False` and `True` respectively.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这些操作分别返回标量`False`和`True`。
- en: '`np.equal, np.not_equal` for object arrays ignores object identity'
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象数组的`np.equal，np.not_equal`忽略对象标识
- en: Previously, these functions always treated identical objects as equal. This
    had the effect of overriding comparison failures, comparison of objects that did
    not return booleans, such as np.arrays, and comparison of objects where the results
    differed from object identity, such as NaNs.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这些函数总是将相同的对象视为相等。这会导致覆盖比较失败、比较不返回布尔值的对象（如 np.arrays），以及比较结果不同于对象标识的对象，如 NaNs。
- en: Boolean indexing changes
  id: totrans-439
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔索引变更
- en: Boolean array-likes (such as lists of python bools) are always treated as boolean
    indexes.
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔数组（如 python 布尔值列表）始终被视为布尔索引。
- en: Boolean scalars (including python `True`) are legal boolean indexes and never
    treated as integers.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔标量（包括 python `True`）是合法的布尔索引，永远不会被视为整数。
- en: Boolean indexes must match the dimension of the axis that they index.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔索引必须匹配它们索引的轴的维度。
- en: Boolean indexes used on the lhs of an assignment must match the dimensions of
    the rhs.
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 赋值的左手边使用的布尔索引必须匹配右手边的维度。
- en: Boolean indexing into scalar arrays return a new 1-d array. This means that
    `array(1)[array(True)]` gives `array([1])` and not the original array.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对标量数组进行布尔索引会返回一个新的一维数组。这意味着`array(1)[array(True)]`会返回`array([1])`而不是原始数组。
- en: '`np.random.multivariate_normal` behavior with bad covariance matrix'
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用坏协方差矩阵时，`np.random.multivariate_normal`的行为
- en: 'It is now possible to adjust the behavior the function will have when dealing
    with the covariance matrix by using two new keyword arguments:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过使用两个新的关键字参数来调整处理协方差矩阵时的函数行为：
- en: '`tol` can be used to specify a tolerance to use when checking that the covariance
    matrix is positive semidefinite.'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以使用`tol`来指定在检查协方差矩阵是否为正定时要使用的容差。
- en: '`check_valid` can be used to configure what the function will do in the presence
    of a matrix that is not positive semidefinite. Valid options are `ignore`, `warn`
    and `raise`. The default value, `warn` keeps the the behavior used on previous
    releases.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_valid`可用于配置在存在非正定矩阵时函数将执行的操作。有效选项为`ignore`、`warn`和`raise`。默认值`warn`保持了上一个版本中使用的行为。'
- en: '`assert_array_less` compares `np.inf` and `-np.inf` now'
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`assert_array_less`现在比较`np.inf`和`-np.inf`'
- en: Previously, `np.testing.assert_array_less` ignored all infinite values. This
    is not the expected behavior both according to documentation and intuitively.
    Now, -inf < x < inf is considered `True` for any real number x and all other cases
    fail.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`np.testing.assert_array_less`忽略了所有无限值。这不符合文档和直觉上的预期行为。现在，-inf < x < inf对于任何实数
    x 都被认为是`True`，其他情况都失败。
- en: '`assert_array_` and masked arrays `assert_equal` hide less warnings'
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`assert_array_`和屏蔽数组`assert_equal`现在隐藏较少的警告'
- en: Some warnings that were previously hidden by the `assert_array_` functions are
    not hidden anymore. In most cases the warnings should be correct and, should they
    occur, will require changes to the tests using these functions. For the masked
    array `assert_equal` version, warnings may occur when comparing NaT. The function
    presently does not handle NaT or NaN specifically and it may be best to avoid
    it at this time should a warning show up due to this change.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 之前被`assert_array_`函数隐藏的一些警告现在不再隐藏。在大多数情况下，这些警告应该是正确的，如果出现，将需要更改使用这些函数的测试。对于屏蔽数组`assert_equal`版本，当比较
    NaT 时可能会出现警告。该函数目前不明确处理 NaT 或 NaN，如果由于此更改而出现警告，则最好在此时避免使用它。
- en: '`offset` attribute value in `memmap` objects'
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`memmap`对象中的`offset`属性值'
- en: The `offset` attribute in a `memmap` object is now set to the offset into the
    file. This is a behaviour change only for offsets greater than `mmap.ALLOCATIONGRANULARITY`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '`memmap`对象中的`offset`属性现在设置为文件偏移量。这对于大于`mmap.ALLOCATIONGRANULARITY`的偏移量只是行为上的更改。'
- en: '`np.real` and `np.imag` return scalars for scalar inputs'
  id: totrans-455
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于标量输入，`np.real`和`np.imag`返回标量
- en: Previously, `np.real` and `np.imag` used to return array objects when provided
    a scalar input, which was inconsistent with other functions like `np.angle` and
    `np.conj`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，当提供标量输入时，`np.real`和`np.imag`以前返回数组对象，这与其他函数如`np.angle`和`np.conj`不一致。
- en: The polynomial convenience classes cannot be passed to ufuncs
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多项式方便类不能传递给ufuncs
- en: The ABCPolyBase class, from which the convenience classes are derived, sets
    `__array_ufun__ = None` in order of opt out of ufuncs. If a polynomial convenience
    class instance is passed as an argument to a ufunc, a `TypeError` will now be
    raised.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ABCPolyBase类，方便类派生自该类，设置了`__array_ufun__ = None`，以便退出ufuncs。如果将多项式方便类实例作为ufunc的参数传递，现在将会引发`TypeError`。
- en: Output arguments to ufuncs can be tuples also for ufunc methods
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Ufunc的输出参数也可以是元组
- en: For calls to ufuncs, it was already possible, and recommended, to use an `out`
    argument with a tuple for ufuncs with multiple outputs. This has now been extended
    to output arguments in the `reduce`, `accumulate`, and `reduceat` methods. This
    is mostly for compatibility with `__array_ufunc`; there are no ufuncs yet that
    have more than one output.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ufunc的调用，已经可以使用一个具有多个输出的元组作为`out`参数，这现在已扩展到`reduce`、`accumulate`和`reduceat`方法的输出参数。这主要是为了与`__array_ufunc`兼容；目前还没有一个ufunc具有多个输出。
- en: '`argsort` on masked arrays takes the same default arguments as `sort`'
  id: totrans-461
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏蔽数组上的`argsort`采用与`sort`相同的默认参数
- en: By default, `argsort` now places the masked values at the end of the sorted
    array, in the same way that `sort` already did. Additionally, the `end_with` argument
    is added to `argsort`, for consistency with `sort`. Note that this argument is
    not added at the end, so breaks any code that passed `fill_value` as a positional
    argument.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`argsort`现在将屏蔽值放在已排序数组的末尾，与`sort`的行为一致。另外，为了与`sort`保持一致，`argsort`添加了`end_with`参数。请注意，此参数不在最后添加，因此会破坏任何将`fill_value`作为位置参数传递的代码。
- en: '`average` now preserves subclasses'
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`average`现在保留子类'
- en: For ndarray subclasses, `numpy.average` will now return an instance of the subclass,
    matching the behavior of most other NumPy functions such as `mean`. As a consequence,
    also calls that returned a scalar may now return a subclass array scalar.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ndarray 子类，`numpy.average` 现在会返回子类的实例，与大多数其他 NumPy 函数的行为相匹配，比如 `mean`。 因此，也可能出现调用返回子类数组标量的情况。
- en: '`array == None` and `array != None` do element-wise comparison'
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`array == None` 和 `array != None` 进行逐元素比较'
- en: Previously these operations returned scalars `False` and `True` respectively.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这些操作分别返回标量值 `False` 和 `True`。
- en: '`np.equal, np.not_equal` for object arrays ignores object identity'
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于对象数组，`np.equal, np.not_equal` 忽略了对象标识
- en: Previously, these functions always treated identical objects as equal. This
    had the effect of overriding comparison failures, comparison of objects that did
    not return booleans, such as np.arrays, and comparison of objects where the results
    differed from object identity, such as NaNs.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这些函数总是将相同的对象视为相等。 这会覆盖比较失败、不返回布尔值的对象的比较（如 np.arrays）以及结果与对象标识不同的对象的比较（如 NaNs）。
- en: Boolean indexing changes
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔索引的更改
- en: Boolean array-likes (such as lists of python bools) are always treated as boolean
    indexes.
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似布尔数组（例如 python 布尔列表）始终被视为布尔索引。
- en: Boolean scalars (including python `True`) are legal boolean indexes and never
    treated as integers.
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔标量（包括 python `True`）是合法的布尔索引，并且永远不被视为整数。
- en: Boolean indexes must match the dimension of the axis that they index.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔索引必须与它们索引的轴的维度匹配。
- en: Boolean indexes used on the lhs of an assignment must match the dimensions of
    the rhs.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在赋值的左手边使用的布尔索引必须与右手边的维度匹配。
- en: Boolean indexing into scalar arrays return a new 1-d array. This means that
    `array(1)[array(True)]` gives `array([1])` and not the original array.
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将标量数组进行布尔索引将返回一个新的一维数组。 这意味着 `array(1)[array(True)]` 会得到 `array([1])` 而不是原始数组。
- en: '`np.random.multivariate_normal` behavior with bad covariance matrix'
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用错误协方差矩阵时，`np.random.multivariate_normal` 的行为
- en: 'It is now possible to adjust the behavior the function will have when dealing
    with the covariance matrix by using two new keyword arguments:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过两个新的关键参数来调整处理协方差矩阵时函数的行为：
- en: '`tol` can be used to specify a tolerance to use when checking that the covariance
    matrix is positive semidefinite.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tol` 可用于指定在检查协方差矩阵是否为正定时使用的容差。'
- en: '`check_valid` can be used to configure what the function will do in the presence
    of a matrix that is not positive semidefinite. Valid options are `ignore`, `warn`
    and `raise`. The default value, `warn` keeps the the behavior used on previous
    releases.'
  id: totrans-478
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`check_valid` 可用于配置在存在非正定矩阵时函数将执行什么操作。 有效选项包括 `ignore`、`warn` 和 `raise`。 默认值
    `warn` 保持了之前版本的行为。'
- en: '`assert_array_less` compares `np.inf` and `-np.inf` now'
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`assert_array_less` 现在比较 `np.inf` 和 `-np.inf`'
- en: Previously, `np.testing.assert_array_less` ignored all infinite values. This
    is not the expected behavior both according to documentation and intuitively.
    Now, -inf < x < inf is considered `True` for any real number x and all other cases
    fail.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`np.testing.assert_array_less` 忽略所有无限值。 这不符合文件和直觉中的预期行为。 现在，-inf < x < inf
    被认为对于任何实数 x 都为 `True`，其他情况都失败。
- en: '`assert_array_` and masked arrays `assert_equal` hide less warnings'
  id: totrans-481
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`assert_array_` 和掩码数组 `assert_equal` 抑制了更少的警告'
- en: Some warnings that were previously hidden by the `assert_array_` functions are
    not hidden anymore. In most cases the warnings should be correct and, should they
    occur, will require changes to the tests using these functions. For the masked
    array `assert_equal` version, warnings may occur when comparing NaT. The function
    presently does not handle NaT or NaN specifically and it may be best to avoid
    it at this time should a warning show up due to this change.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 一些以前被 `assert_array_` 函数隐藏的警告现在不再隐藏。 在大多数情况下，这些警告应该是正确的，如果出现这些警告，则需要更改使用这些函数的测试。
    对于掩码数组 `assert_equal` 版本，在比较 NaT 时可能会产生警告。 目前该函数不特别处理 NaT 或 NaN，如果由于此更改而出现警告，最好在此时避免使用它。
- en: '`offset` attribute value in `memmap` objects'
  id: totrans-483
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`memmap` 对象中的 `offset` 属性值'
- en: The `offset` attribute in a `memmap` object is now set to the offset into the
    file. This is a behaviour change only for offsets greater than `mmap.ALLOCATIONGRANULARITY`.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`memmap` 对象中的 `offset` 属性现在设置为文件的偏移量。 这只是对大于 `mmap.ALLOCATIONGRANULARITY` 的偏移量进行的行为更改。'
- en: '`np.real` and `np.imag` return scalars for scalar inputs'
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`np.real` 和 `np.imag` 对于标量输入返回标量值'
- en: Previously, `np.real` and `np.imag` used to return array objects when provided
    a scalar input, which was inconsistent with other functions like `np.angle` and
    `np.conj`.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`np.real`和`np.imag`在提供标量输入时会返回数组对象，这与`np.angle`和`np.conj`等其他函数不一致。
- en: The polynomial convenience classes cannot be passed to ufuncs
  id: totrans-487
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无法将多项式便利类传递给ufuncs
- en: The ABCPolyBase class, from which the convenience classes are derived, sets
    `__array_ufun__ = None` in order of opt out of ufuncs. If a polynomial convenience
    class instance is passed as an argument to a ufunc, a `TypeError` will now be
    raised.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 从ABCBase类中派生的便利类设置`__array_ufunc__ = None`以退出ufuncs。如果将多项式便利类实例作为参数传递给ufunc，现在会引发`TypeError`。
- en: Output arguments to ufuncs can be tuples also for ufunc methods
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于ufunc方法，输出参数也可以是元组
- en: For calls to ufuncs, it was already possible, and recommended, to use an `out`
    argument with a tuple for ufuncs with multiple outputs. This has now been extended
    to output arguments in the `reduce`, `accumulate`, and `reduceat` methods. This
    is mostly for compatibility with `__array_ufunc`; there are no ufuncs yet that
    have more than one output.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对ufuncs的调用，已经可以使用带有元组的`out`参数来处理具有多个输出的ufuncs，这已经扩展到了`reduce`、`accumulate`和`reduceat`方法的输出参数。这主要是为了与`__array_ufunc__`兼容；目前还没有超过一个输出的ufuncs。
