- en: Integration (scipy.integrate)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 积分（scipy.integrate）
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/integrate.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/integrate.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/integrate.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/integrate.html)
- en: 'The [`scipy.integrate`](../reference/integrate.html#module-scipy.integrate
    "scipy.integrate") sub-package provides several integration techniques including
    an ordinary differential equation integrator. An overview of the module is provided
    by the help command:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 子包[`scipy.integrate`](../reference/integrate.html#module-scipy.integrate "scipy.integrate")
    提供了几种积分技术，包括普通微分方程积分器。您可以通过帮助命令了解模块的概述：
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: General integration ([`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"))
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用积分（[`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"))
- en: The function [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad") is provided to integrate a function of one variable between
    two points. The points can be \(\pm\infty\) (\(\pm\) `inf`) to indicate infinite
    limits. For example, suppose you wish to integrate a bessel function `jv(2.5,
    x)` along the interval \([0, 4.5].\)
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 函数[`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad") 提供了一种计算单变量函数在两点之间积分的方法。这些点可以是\(\pm\infty\)（\(\pm\) `inf`），表示无限限制。例如，假设您希望计算贝塞尔函数
    `jv(2.5, x)` 在区间 \([0, 4.5]\) 上的积分。
- en: \[I=\int_{0}^{4.5}J_{2.5}\left(x\right)\, dx.\]
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: \[I=\int_{0}^{4.5}J_{2.5}\left(x\right)\, dx.\]
- en: 'This could be computed using [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"):'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以使用 [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad") 计算：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first argument to quad is a “callable” Python object (i.e., a function,
    method, or class instance). Notice the use of a lambda- function in this case
    as the argument. The next two arguments are the limits of integration. The return
    value is a tuple, with the first element holding the estimated value of the integral
    and the second element holding an estimate of the absolute integration error.
    Notice, that in this case, the true value of this integral is
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: quad 的第一个参数是一个“可调用”的 Python 对象（即函数、方法或类实例）。请注意在此情况下使用 lambda- 函数作为参数。接下来的两个参数是积分的上下限。返回值是一个元组，第一个元素是积分估计值，第二个元素是绝对积分误差的估计值。请注意，在这种情况下，这个积分的真实值是
- en: \[I=\sqrt{\frac{2}{\pi}}\left(\frac{18}{27}\sqrt{2}\cos\left(4.5\right)-\frac{4}{27}\sqrt{2}\sin\left(4.5\right)+\sqrt{2\pi}\textrm{Si}\left(\frac{3}{\sqrt{\pi}}\right)\right),\]
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: \[I=\sqrt{\frac{2}{\pi}}\left(\frac{18}{27}\sqrt{2}\cos\left(4.5\right)-\frac{4}{27}\sqrt{2}\sin\left(4.5\right)+\sqrt{2\pi}\textrm{Si}\left(\frac{3}{\sqrt{\pi}}\right)\right),\]
- en: where
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: \[\textrm{Si}\left(x\right)=\int_{0}^{x}\sin\left(\frac{\pi}{2}t^{2}\right)\,
    dt.\]
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: \[\textrm{Si}\left(x\right)=\int_{0}^{x}\sin\left(\frac{\pi}{2}t^{2}\right)\,
    dt.\]
- en: is the Fresnel sine integral. Note that the numerically-computed integral is
    within \(1.04\times10^{-11}\) of the exact result — well below the reported error
    estimate.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 是 Fresnel 正弦积分。请注意，数值计算的积分结果比精确结果高出 \(1.04\times10^{-11}\) — 远低于报告的误差估计。
- en: 'If the function to integrate takes additional parameters, they can be provided
    in the *args* argument. Suppose that the following integral shall be calculated:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要积分的函数需要额外的参数，可以在 *args* 参数中提供。假设要计算以下积分：
- en: \[I(a,b)=\int_{0}^{1} ax^2+b \, dx.\]
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: \[I(a,b)=\int_{0}^{1} ax^2+b \, dx.\]
- en: 'This integral can be evaluated by using the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这个积分可以通过以下代码计算：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Infinite inputs are also allowed in [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad") by using \(\pm\) `inf` as one of the arguments. For example,
    suppose that a numerical value for the exponential integral:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad") 还允许使用 \(\pm\) `inf` 作为参数之一进行无限输入。例如，假设要计算指数积分的数值值：'
- en: \[E_{n}\left(x\right)=\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt.\]
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: \[E_{n}\left(x\right)=\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt.\]
- en: 'is desired (and the fact that this integral can be computed as `special.expn(n,x)`
    is forgotten). The functionality of the function [`special.expn`](../reference/generated/scipy.special.expn.html#scipy.special.expn
    "scipy.special.expn") can be replicated by defining a new function `vec_expint`
    based on the routine [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 是所需的（并且忘记了可以将这个积分计算为`special.expn(n,x)`的事实）。函数[`special.expn`](../reference/generated/scipy.special.expn.html#scipy.special.expn
    "scipy.special.expn")的功能可以通过基于[`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad")例程定义新函数`vec_expint`来复制：
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The function which is integrated can even use the quad argument (though the
    error bound may underestimate the error due to possible numerical error in the
    integrand from the use of [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad") ). The integral in this case is
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 被积函数甚至可以使用`quad`参数（尽管误差界限可能会由于使用[`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad")中的积分函数而低估误差）。在这种情况下，积分是
- en: \[I_{n}=\int_{0}^{\infty}\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt\, dx=\frac{1}{n}.\]
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: \[I_{n}=\int_{0}^{\infty}\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt\, dx=\frac{1}{n}.\]
- en: '[PRE9]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This last example shows that multiple integration can be handled using repeated
    calls to [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad").
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子显示，可以使用重复调用[`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad")来处理多重积分。
- en: Warning
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'Numerical integration algorithms sample the integrand at a finite number of
    points. Consequently, they cannot guarantee accurate results (or accuracy estimates)
    for arbitrary integrands and limits of integration. Consider the Gaussian integral,
    for example:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 数值积分算法在有限数量的点上采样被积函数。因此，它们不能保证对任意被积函数和积分限的准确结果（或准确性估计）。例如，考虑高斯积分：
- en: '[PRE12]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since the integrand is nearly zero except near the origin, we would expect
    large but finite limits of integration to yield the same result. However:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 由于被积函数除了在原点附近几乎为零，我们预期大但有限的积分限会得到相同的结果。然而：
- en: '[PRE13]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This happens because the adaptive quadrature routine implemented in [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"), while working as designed, does not notice the small,
    important part of the function within such a large, finite interval. For best
    results, consider using integration limits that tightly surround the important
    part of the integrand.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在[`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad")中实现的自适应积分例程虽然按设计工作，但没有注意到函数在如此大的有限区间内的小而重要部分。为了获得最佳结果，请考虑使用紧密环绕被积函数重要部分的积分限。
- en: '[PRE14]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Integrands with several important regions can be broken into pieces as necessary.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 必要时可以将具有几个重要区域的被积函数分成若干部分。
- en: General multiple integration ([`dblquad`](../reference/generated/scipy.integrate.dblquad.html#scipy.integrate.dblquad
    "scipy.integrate.dblquad"), [`tplquad`](../reference/generated/scipy.integrate.tplquad.html#scipy.integrate.tplquad
    "scipy.integrate.tplquad"), [`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad"))
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般的多重积分（[`dblquad`](../reference/generated/scipy.integrate.dblquad.html#scipy.integrate.dblquad
    "scipy.integrate.dblquad"), [`tplquad`](../reference/generated/scipy.integrate.tplquad.html#scipy.integrate.tplquad
    "scipy.integrate.tplquad"), [`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad"))
- en: The mechanics for double and triple integration have been wrapped up into the
    functions [`dblquad`](../reference/generated/scipy.integrate.dblquad.html#scipy.integrate.dblquad
    "scipy.integrate.dblquad") and [`tplquad`](../reference/generated/scipy.integrate.tplquad.html#scipy.integrate.tplquad
    "scipy.integrate.tplquad"). These functions take the function to integrate and
    four, or six arguments, respectively. The limits of all inner integrals need to
    be defined as functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 双重和三重积分的机制已经封装到[`dblquad`](../reference/generated/scipy.integrate.dblquad.html#scipy.integrate.dblquad
    "scipy.integrate.dblquad")和[`tplquad`](../reference/generated/scipy.integrate.tplquad.html#scipy.integrate.tplquad
    "scipy.integrate.tplquad")函数中。这些函数分别接受要积分的函数及四个或六个参数。所有内积分的限制必须定义为函数。
- en: 'An example of using double integration to compute several values of \(I_{n}\)
    is shown below:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了使用双重积分计算几个\(I_{n}\)值的示例：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: As example for non-constant limits consider the integral
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非常数限制的积分的一个例子
- en: \[I=\int_{y=0}^{1/2}\int_{x=0}^{1-2y} x y \, dx\, dy=\frac{1}{96}.\]
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: \[I=\int_{y=0}^{1/2}\int_{x=0}^{1-2y} x y \, dx\, dy=\frac{1}{96}.\]
- en: 'This integral can be evaluated using the expression below (Note the use of
    the non-constant lambda functions for the upper limit of the inner integral):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用下面的表达式计算这个积分（请注意使用非常数lambda函数作为内积分上限）：
- en: '[PRE17]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For n-fold integration, scipy provides the function [`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad"). The integration bounds are an iterable object: either
    a list of constant bounds, or a list of functions for the non-constant integration
    bounds. The order of integration (and therefore the bounds) is from the innermost
    integral to the outermost one.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于n重积分，scipy提供了函数[`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad")。积分边界是一个可迭代对象：要么是常数边界的列表，要么是非常数积分边界的函数列表。积分的顺序（因此也是边界）是从最内层的积分到最外层的。
- en: The integral from above
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述积分
- en: \[I_{n}=\int_{0}^{\infty}\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt\, dx=\frac{1}{n}\]
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: \[I_{n}=\int_{0}^{\infty}\int_{1}^{\infty}\frac{e^{-xt}}{t^{n}}\, dt\, dx=\frac{1}{n}\]
- en: can be calculated as
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 可以计算为
- en: '[PRE18]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the order of arguments for *f* must match the order of the integration
    bounds; i.e., the inner integral with respect to \(t\) is on the interval \([1,
    \infty]\) and the outer integral with respect to \(x\) is on the interval \([0,
    \infty]\).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*f*的参数顺序必须与积分边界的顺序匹配；即，对于\(t\)的内积分区间为\([1, \infty]\)，对于\(x\)的外积分区间为\([0, \infty]\)。
- en: Non-constant integration bounds can be treated in a similar manner; the example
    from above
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 非常数积分边界可以以类似的方式处理；如上例所示。
- en: \[I=\int_{y=0}^{1/2}\int_{x=0}^{1-2y} x y \, dx\, dy=\frac{1}{96}.\]
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: \[I=\int_{y=0}^{1/2}\int_{x=0}^{1-2y} x y \, dx\, dy=\frac{1}{96}.\]
- en: can be evaluated by means of
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过以下方式进行评估
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: which is the same result as before.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的结果相同。
- en: Gaussian quadrature
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高斯积分
- en: A few functions are also provided in order to perform simple Gaussian quadrature
    over a fixed interval. The first is [`fixed_quad`](../reference/generated/scipy.integrate.fixed_quad.html#scipy.integrate.fixed_quad
    "scipy.integrate.fixed_quad"), which performs fixed-order Gaussian quadrature.
    The second function is [`quadrature`](../reference/generated/scipy.integrate.quadrature.html#scipy.integrate.quadrature
    "scipy.integrate.quadrature"), which performs Gaussian quadrature of multiple
    orders until the difference in the integral estimate is beneath some tolerance
    supplied by the user. These functions both use the module `scipy.special.orthogonal`,
    which can calculate the roots and quadrature weights of a large variety of orthogonal
    polynomials (the polynomials themselves are available as special functions returning
    instances of the polynomial class — e.g., [`special.legendre`](../reference/generated/scipy.special.legendre.html#scipy.special.legendre
    "scipy.special.legendre")).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了一些函数，以便在固定区间上执行简单的高斯积分。第一个是[`fixed_quad`](../reference/generated/scipy.integrate.fixed_quad.html#scipy.integrate.fixed_quad
    "scipy.integrate.fixed_quad")，执行固定阶数的高斯积分。第二个函数是[`quadrature`](../reference/generated/scipy.integrate.quadrature.html#scipy.integrate.quadrature
    "scipy.integrate.quadrature")，执行多阶高斯积分，直到积分估计的差异低于用户提供的某个容差。这些函数都使用了模块`scipy.special.orthogonal`，该模块可以计算多种正交多项式的根和积分权重（这些多项式本身作为特殊函数返回多项式类的实例，例如，[`special.legendre`](../reference/generated/scipy.special.legendre.html#scipy.special.legendre
    "scipy.special.legendre")）。
- en: Romberg Integration
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 罗姆伯格积分法
- en: Romberg’s method [[WPR]](#wpr) is another method for numerically evaluating
    an integral. See the help function for [`romberg`](../reference/generated/scipy.integrate.romberg.html#scipy.integrate.romberg
    "scipy.integrate.romberg") for further details.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 罗姆伯格方法[[WPR]](#wpr)是另一种用于数值积分的方法。请参阅[`romberg`](../reference/generated/scipy.integrate.romberg.html#scipy.integrate.romberg
    "scipy.integrate.romberg")的帮助函数以获取更多细节。
- en: Integrating using Samples
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用样本进行积分
- en: If the samples are equally-spaced and the number of samples available is \(2^{k}+1\)
    for some integer \(k\), then Romberg [`romb`](../reference/generated/scipy.integrate.romb.html#scipy.integrate.romb
    "scipy.integrate.romb") integration can be used to obtain high-precision estimates
    of the integral using the available samples. Romberg integration uses the trapezoid
    rule at step-sizes related by a power of two and then performs Richardson extrapolation
    on these estimates to approximate the integral with a higher degree of accuracy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果样本等间距，并且可用样本数为 \(2^{k}+1\)（其中 \(k\) 是整数），那么可以使用Romberg [`romb`](../reference/generated/scipy.integrate.romb.html#scipy.integrate.romb
    "scipy.integrate.romb") 积分来获得高精度的积分估计。Romberg 积分使用梯形规则在与二的幂相关的步长上，并对这些估计进行理查逊外推，以更高精度地近似积分。
- en: In case of arbitrary spaced samples, the two functions [`trapezoid`](../reference/generated/scipy.integrate.trapezoid.html#scipy.integrate.trapezoid
    "scipy.integrate.trapezoid") and [`simpson`](../reference/generated/scipy.integrate.simpson.html#scipy.integrate.simpson
    "scipy.integrate.simpson") are available. They are using Newton-Coates formulas
    of order 1 and 2 respectively to perform integration. The trapezoidal rule approximates
    the function as a straight line between adjacent points, while Simpson’s rule
    approximates the function between three adjacent points as a parabola.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在任意间隔样本的情况下，有两个函数[`trapezoid`](../reference/generated/scipy.integrate.trapezoid.html#scipy.integrate.trapezoid
    "scipy.integrate.trapezoid")和[`simpson`](../reference/generated/scipy.integrate.simpson.html#scipy.integrate.simpson
    "scipy.integrate.simpson")可用。它们分别使用牛顿-科特斯一阶和二阶公式进行积分。梯形规则将函数近似为相邻点之间的直线，而辛普森规则将函数在三个相邻点之间近似为抛物线。
- en: For an odd number of samples that are equally spaced Simpson’s rule is exact
    if the function is a polynomial of order 3 or less. If the samples are not equally
    spaced, then the result is exact only if the function is a polynomial of order
    2 or less.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于样本数为奇数且等间距的情况，如果函数是三阶或更低阶的多项式，则辛普森规则是精确的。如果样本不是等间距的，则结果只有在函数是二阶或更低阶的多项式时才是精确的。
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This corresponds exactly to
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这恰好对应于
- en: \[\int_{1}^{4} x^2 \, dx = 21,\]
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: \[\int_{1}^{4} x^2 \, dx = 21,\]
- en: whereas integrating the second function
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 而积分第二个函数
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: does not correspond to
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 不对应于
- en: \[\int_{1}^{4} x^3 \, dx = 63.75\]
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: \[\int_{1}^{4} x^3 \, dx = 63.75\]
- en: because the order of the polynomial in f2 is larger than two.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 因为f2中的多项式阶数大于二阶。
- en: '## Faster integration using low-level callback functions'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用低级回调函数进行更快的积分'
- en: A user desiring reduced integration times may pass a C function pointer through
    [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") to [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"), [`dblquad`](../reference/generated/scipy.integrate.dblquad.html#scipy.integrate.dblquad
    "scipy.integrate.dblquad"), [`tplquad`](../reference/generated/scipy.integrate.tplquad.html#scipy.integrate.tplquad
    "scipy.integrate.tplquad") or [`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad") and it will be integrated and return a result in Python.
    The performance increase here arises from two factors. The primary improvement
    is faster function evaluation, which is provided by compilation of the function
    itself. Additionally we have a speedup provided by the removal of function calls
    between C and Python in [`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad"). This method may provide a speed improvements of ~2x for
    trivial functions such as sine but can produce a much more noticeable improvements
    (10x+) for more complex functions. This feature then, is geared towards a user
    with numerically intensive integrations willing to write a little C to reduce
    computation time significantly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户希望减少集成时间，可以通过[`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable")将C函数指针传递给[`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad")、[`dblquad`](../reference/generated/scipy.integrate.dblquad.html#scipy.integrate.dblquad
    "scipy.integrate.dblquad")、[`tplquad`](../reference/generated/scipy.integrate.tplquad.html#scipy.integrate.tplquad
    "scipy.integrate.tplquad")或[`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad")，它将在Python中进行集成并返回结果。这里的性能提升来自两个因素。主要改进是函数本身的编译提供的更快的函数评估。此外，在[`quad`](../reference/generated/scipy.integrate.quad.html#scipy.integrate.quad
    "scipy.integrate.quad")中，通过消除C和Python之间的函数调用，我们还提供了加速。对于像正弦这样的简单函数，这种方法可能提供大约2倍的速度改进，但对于更复杂的函数，可能会产生更明显的改进（10倍以上）。因此，此功能专为希望通过写一些C来显著减少计算时间的用户而设计。
- en: 'The approach can be used, for example, via [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.12)") in a few simple steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可以通过[`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(在Python v3.12中)")在几个简单的步骤中使用该方法：
- en: 1.) Write an integrand function in C with the function signature `double f(int
    n, double *x, void *user_data)`, where `x` is an array containing the point the
    function f is evaluated at, and `user_data` to arbitrary additional data you want
    to provide.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 1.) 在C中编写一个带有函数签名`double f(int n, double *x, void *user_data)`的积分函数，其中`x`是包含函数f评估点的数组，`user_data`是您想要提供的任意附加数据。
- en: '[PRE22]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '2.) Now compile this file to a shared/dynamic library (a quick search will
    help with this as it is OS-dependent). The user must link any math libraries,
    etc., used. On linux this looks like:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 2.) 现在将此文件编译为共享/动态库（快速搜索将帮助解决这个问题，因为它依赖于操作系统）。用户必须链接任何使用的数学库等。在Linux上，看起来像这样：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output library will be referred to as `testlib.so`, but it may have a different
    file extension. A library has now been created that can be loaded into Python
    with [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes "(in
    Python v3.12)").
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 输出库将被称为`testlib.so`，但它可能具有不同的文件扩展名。现在已经创建了一个库，可以使用[`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(在Python v3.12中)")加载到Python中。
- en: '3.) Load shared library into Python using [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.12)") and set `restypes` and `argtypes` - this allows SciPy to
    interpret the function correctly:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 3.) 使用[`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(在Python v3.12中)")将共享库加载到Python中，并设置`restypes`和`argtypes` - 这使得SciPy能够正确解释函数：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The last `void *user_data` in the function is optional and can be omitted (both
    in the C function and ctypes argtypes) if not needed. Note that the coordinates
    are passed in as an array of doubles rather than a separate argument.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 函数中最后的`void *user_data`是可选的，如果不需要，可以省略（在C函数和ctypes argtypes中都是如此）。注意，坐标被传递为双精度数组，而不是单独的参数。
- en: '4.) Now integrate the library function as normally, here using [`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad"):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 4.) 现在像往常一样集成库函数，这里使用[`nquad`](../reference/generated/scipy.integrate.nquad.html#scipy.integrate.nquad
    "scipy.integrate.nquad")：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The Python tuple is returned as expected in a reduced amount of time. All optional
    parameters can be used with this method including specifying singularities, infinite
    bounds, etc.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的Python元组在减少的时间内正常返回。此方法可以使用所有可选参数，包括指定奇点、无限界等。
- en: Ordinary differential equations ([`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp"))
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 普通微分方程 ([`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp"))
- en: 'Integrating a set of ordinary differential equations (ODEs) given initial conditions
    is another useful example. The function [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") is available in SciPy for integrating a first-order
    vector differential equation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对一组普通微分方程（ODEs）进行积分，并给出初始条件是另一个有用的例子。SciPy 中提供了函数 [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") 用于积分第一阶向量微分方程：
- en: \[\frac{d\mathbf{y}}{dt}=\mathbf{f}\left(\mathbf{y},t\right),\]
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{d\mathbf{y}}{dt}=\mathbf{f}\left(\mathbf{y},t\right),\]
- en: given initial conditions \(\mathbf{y}\left(0\right)=y_{0}\), where \(\mathbf{y}\)
    is a length \(N\) vector and \(\mathbf{f}\) is a mapping from \(\mathcal{R}^{N}\)
    to \(\mathcal{R}^{N}.\) A higher-order ordinary differential equation can always
    be reduced to a differential equation of this type by introducing intermediate
    derivatives into the \(\mathbf{y}\) vector.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 给定初始条件 \(\mathbf{y}\left(0\right)=y_{0}\)，其中 \(\mathbf{y}\) 是长度为 \(N\) 的向量，\(\mathbf{f}\)
    是从 \(\mathcal{R}^{N}\) 到 \(\mathcal{R}^{N}\) 的映射。通过将中间导数引入 \(\mathbf{y}\) 向量，任何高阶常微分方程总可以通过这种类型的微分方程来减少。
- en: 'For example, suppose it is desired to find the solution to the following second-order
    differential equation:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设要找到以下二阶微分方程的解：
- en: \[\frac{d^{2}w}{dz^{2}}-zw(z)=0\]
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: \[\frac{d^{2}w}{dz^{2}}-zw(z)=0\]
- en: with initial conditions \(w\left(0\right)=\frac{1}{\sqrt[3]{3^{2}}\Gamma\left(\frac{2}{3}\right)}\)
    and \(\left.\frac{dw}{dz}\right|_{z=0}=-\frac{1}{\sqrt[3]{3}\Gamma\left(\frac{1}{3}\right)}.\)
    It is known that the solution to this differential equation with these boundary
    conditions is the Airy function
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 初始条件为 \(w\left(0\right)=\frac{1}{\sqrt[3]{3^{2}}\Gamma\left(\frac{2}{3}\right)}\)
    和 \(\left.\frac{dw}{dz}\right|_{z=0}=-\frac{1}{\sqrt[3]{3}\Gamma\left(\frac{1}{3}\right)}.\)
    已知带有这些边界条件的解为艾里函数
- en: \[w=\textrm{Ai}\left(z\right),\]
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: \[w=\textrm{Ai}\left(z\right),\]
- en: which gives a means to check the integrator using [`special.airy`](../reference/generated/scipy.special.airy.html#scipy.special.airy
    "scipy.special.airy").
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了使用 [`special.airy`](../reference/generated/scipy.special.airy.html#scipy.special.airy
    "scipy.special.airy") 来检查积分器的方法。
- en: First, convert this ODE into standard form by setting \(\mathbf{y}=\left[\frac{dw}{dz},w\right]\)
    and \(t=z\). Thus, the differential equation becomes
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过设定 \(\mathbf{y}=\left[\frac{dw}{dz},w\right]\) 和 \(t=z\) 将这个ODE转换为标准形式。因此，微分方程变为
- en: \[\begin{split}\frac{d\mathbf{y}}{dt}=\left[\begin{array}{c} ty_{1}\\ y_{0}\end{array}\right]=\left[\begin{array}{cc}
    0 & t\\ 1 & 0\end{array}\right]\left[\begin{array}{c} y_{0}\\ y_{1}\end{array}\right]=\left[\begin{array}{cc}
    0 & t\\ 1 & 0\end{array}\right]\mathbf{y}.\end{split}\]
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\frac{d\mathbf{y}}{dt}=\left[\begin{array}{c} ty_{1}\\ y_{0}\end{array}\right]=\left[\begin{array}{cc}
    0 & t\\ 1 & 0\end{array}\right]\left[\begin{array}{c} y_{0}\\ y_{1}\end{array}\right]=\left[\begin{array}{cc}
    0 & t\\ 1 & 0\end{array}\right]\mathbf{y}.\end{split}\]
- en: In other words,
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，
- en: \[\mathbf{f}\left(\mathbf{y},t\right)=\mathbf{A}\left(t\right)\mathbf{y}.\]
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{f}\left(\mathbf{y},t\right)=\mathbf{A}\left(t\right)\mathbf{y}.\]
- en: 'As an interesting reminder, if \(\mathbf{A}\left(t\right)\) commutes with \(\int_{0}^{t}\mathbf{A}\left(\tau\right)\,
    d\tau\) under matrix multiplication, then this linear differential equation has
    an exact solution using the matrix exponential:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个有趣的提醒，如果 \(\mathbf{A}\left(t\right)\) 与 \(\int_{0}^{t}\mathbf{A}\left(\tau\right)\,
    d\tau\) 在矩阵乘法下交换，则此线性微分方程在使用矩阵指数的精确解时有解：
- en: \[\mathbf{y}\left(t\right)=\exp\left(\int_{0}^{t}\mathbf{A}\left(\tau\right)d\tau\right)\mathbf{y}\left(0\right),\]
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbf{y}\left(t\right)=\exp\left(\int_{0}^{t}\mathbf{A}\left(\tau\right)d\tau\right)\mathbf{y}\left(0\right),\]
- en: However, in this case, \(\mathbf{A}\left(t\right)\) and its integral do not
    commute.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但在这种情况下，\(\mathbf{A}\left(t\right)\) 及其积分不对易。
- en: This differential equation can be solved using the function [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp"). It requires the derivative, *fprime*, the time span
    *[t_start, t_end]* and the initial conditions vector, *y0*, as input arguments
    and returns an object whose *y* field is an array with consecutive solution values
    as columns. The initial conditions are therefore given in the first output column.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用函数[`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp")来解决这个微分方程。它需要导数*fprime*，时间跨度*[t_start, t_end]*和初始条件向量*y0*作为输入参数，并返回一个对象，其*y*字段是连续解值的数组，作为列。因此，初始条件给出在第一个输出列中。
- en: '[PRE26]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As it can be seen [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") determines its time steps automatically if not specified
    otherwise. To compare the solution of [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") with the *airy* function the time vector created
    by [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") is passed to the *airy* function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如可以看到的，如果未另有指定，[`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp")会自动确定其时间步长。为了比较[`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp")的解与*airy*函数，由[`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp")创建的时间向量被传递给*airy*函数。
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The solution of [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") with its standard parameters shows a big deviation
    to the airy function. To minimize this deviation, relative and absolute tolerances
    can be used.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 具有其标准参数的[`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp")的解显示出与airy函数的显著偏差。为了减小这种偏差，可以使用相对和绝对容差。
- en: '[PRE28]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: To specify user defined time points for the solution of [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp"), [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") offers two possibilities that can also be used complementarily.
    By passing the *t_eval* option to the function call [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") returns the solutions of these time points of *t_eval*
    in its output.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要为[`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp")的解指定用户定义的时间点，[`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp")提供了两种可能性，也可以互补使用。通过将*t_eval*选项传递给函数调用[`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp")返回在其输出中这些时间点的解。
- en: '[PRE29]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the jacobian matrix of function is known, it can be passed to the [`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp") to achieve better results. Please be aware however
    that the default integration method [`RK45`](../reference/generated/scipy.integrate.RK45.html#scipy.integrate.RK45
    "scipy.integrate.RK45") does not support jacobian matrices and thereby another
    integration method has to be chosen. One of the integration methods that support
    a jacobian matrix is the for example the [`Radau`](../reference/generated/scipy.integrate.Radau.html#scipy.integrate.Radau
    "scipy.integrate.Radau") method of following example.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数的雅可比矩阵已知，则可以将其传递给[`solve_ivp`](../reference/generated/scipy.integrate.solve_ivp.html#scipy.integrate.solve_ivp
    "scipy.integrate.solve_ivp")以获得更好的结果。但请注意，默认的积分方法[`RK45`](../reference/generated/scipy.integrate.RK45.html#scipy.integrate.RK45
    "scipy.integrate.RK45")不支持雅可比矩阵，因此必须选择另一种积分方法。支持雅可比矩阵的积分方法之一是例如以下示例中的[`Radau`](../reference/generated/scipy.integrate.Radau.html#scipy.integrate.Radau
    "scipy.integrate.Radau")方法。
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Solving a system with a banded Jacobian matrix
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 解决具有带状雅可比矩阵的系统
- en: '[`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") can be told that the Jacobian is *banded*. For a large
    system of differential equations that are known to be stiff, this can improve
    performance significantly.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint")可以告知雅可比矩阵为*banded*。对于已知是僵硬的大型微分方程系统，这可以显著提高性能。'
- en: As an example, we’ll solve the 1-D Gray-Scott partial differential equations
    using the method of lines [[MOL]](#mol). The Gray-Scott equations for the functions
    \(u(x, t)\) and \(v(x, t)\) on the interval \(x \in [0, L]\) are
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\begin{split} \frac{\partial u}{\partial t} = D_u \frac{\partial^2
    u}{\partial x^2} - uv^2 + f(1-u) \\ \frac{\partial v}{\partial t} = D_v \frac{\partial^2
    v}{\partial x^2} + uv^2 - (f + k)v \\ \end{split}\end{split}\]
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: where \(D_u\) and \(D_v\) are the diffusion coefficients of the components \(u\)
    and \(v\), respectively, and \(f\) and \(k\) are constants. (For more information
    about the system, see [http://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/](http://groups.csail.mit.edu/mac/projects/amorphous/GrayScott/))
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll assume Neumann (i.e., “no flux”) boundary conditions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{\partial u}{\partial x}(0,t) = 0, \quad \frac{\partial v}{\partial x}(0,t)
    = 0, \quad \frac{\partial u}{\partial x}(L,t) = 0, \quad \frac{\partial v}{\partial
    x}(L,t) = 0\]
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: To apply the method of lines, we discretize the \(x\) variable by defining the
    uniformly spaced grid of \(N\) points \(\left\{x_0, x_1, \ldots, x_{N-1}\right\}\),
    with \(x_0 = 0\) and \(x_{N-1} = L\). We define \(u_j(t) \equiv u(x_k, t)\) and
    \(v_j(t) \equiv v(x_k, t)\), and replace the \(x\) derivatives with finite differences.
    That is,
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{\partial^2 u}{\partial x^2}(x_j, t) \rightarrow \frac{u_{j-1}(t) - 2
    u_{j}(t) + u_{j+1}(t)}{(\Delta x)^2}\]
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'We then have a system of \(2N\) ordinary differential equations:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: (1)\[\begin{split} \begin{split} \frac{du_j}{dt} = \frac{D_u}{(\Delta x)^2}
    \left(u_{j-1} - 2 u_{j} + u_{j+1}\right) -u_jv_j^2 + f(1 - u_j) \\ \frac{dv_j}{dt}
    = \frac{D_v}{(\Delta x)^2} \left(v_{j-1} - 2 v_{j} + v_{j+1}\right) + u_jv_j^2
    - (f + k)v_j \end{split}\end{split}\]
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, the \((t)\) arguments have been dropped.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: To enforce the boundary conditions, we introduce “ghost” points \(x_{-1}\) and
    \(x_N\), and define \(u_{-1}(t) \equiv u_1(t)\), \(u_N(t) \equiv u_{N-2}(t)\);
    \(v_{-1}(t)\) and \(v_N(t)\) are defined analogously.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Then
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: (2)\[\begin{split} \begin{split} \frac{du_0}{dt} = \frac{D_u}{(\Delta x)^2}
    \left(2u_{1} - 2 u_{0}\right) -u_0v_0^2 + f(1 - u_0) \\ \frac{dv_0}{dt} = \frac{D_v}{(\Delta
    x)^2} \left(2v_{1} - 2 v_{0}\right) + u_0v_0^2 - (f + k)v_0 \end{split}\end{split}\]
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: and
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: (3)\[\begin{split} \begin{split} \frac{du_{N-1}}{dt} = \frac{D_u}{(\Delta x)^2}
    \left(2u_{N-2} - 2 u_{N-1}\right) -u_{N-1}v_{N-1}^2 + f(1 - u_{N-1}) \\ \frac{dv_{N-1}}{dt}
    = \frac{D_v}{(\Delta x)^2} \left(2v_{N-2} - 2 v_{N-1}\right) + u_{N-1}v_{N-1}^2
    - (f + k)v_{N-1} \end{split}\end{split}\]
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Our complete system of \(2N\) ordinary differential equations is [(1)](#equation-interior)
    for \(k = 1, 2, \ldots, N-2\), along with [(2)](#equation-boundary0) and [(3)](#equation-boundaryl).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: We can now starting implementing this system in code. We must combine \(\{u_k\}\)
    and \(\{v_k\}\) into a single vector of length \(2N\). The two obvious choices
    are \(\{u_0, u_1, \ldots, u_{N-1}, v_0, v_1, \ldots, v_{N-1}\}\) and \(\{u_0,
    v_0, u_1, v_1, \ldots, u_{N-1}, v_{N-1}\}\). Mathematically, it does not matter,
    but the choice affects how efficiently [`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") can solve the system. The reason is in how the order
    affects the pattern of the nonzero elements of the Jacobian matrix.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以开始在代码中实现这个系统。我们必须将 \(\{u_k\}\) 和 \(\{v_k\}\) 合并成长度为 \(2N\) 的单一向量。两个明显的选择是
    \(\{u_0, u_1, \ldots, u_{N-1}, v_0, v_1, \ldots, v_{N-1}\}\) 和 \(\{u_0, v_0, u_1,
    v_1, \ldots, u_{N-1}, v_{N-1}\}\)。数学上讲，选择没有影响，但是选择会影响[`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint)如何高效地解决系统。原因在于变量顺序如何影响雅可比矩阵非零元素的模式。
- en: When the variables are ordered as \(\{u_0, u_1, \ldots, u_{N-1}, v_0, v_1, \ldots,
    v_{N-1}\}\), the pattern of nonzero elements of the Jacobian matrix is
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当变量按 \(\{u_0, u_1, \ldots, u_{N-1}, v_0, v_1, \ldots, v_{N-1}\}\) 排序时，雅可比矩阵的非零元素模式是
- en: \[\begin{split}\begin{smallmatrix} * & * & 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0
    & 0 & 0 & 0 \\ * & * & * & 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & 0 \\ 0 & *
    & * & * & 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 \\ 0 & 0 & * & * & * & 0 & 0 &
    0 & 0 & 0 & * & 0 & 0 & 0 \\ 0 & 0 & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 & * & 0
    & 0 \\ 0 & 0 & 0 & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 & * & 0 \\ 0 & 0 & 0 & 0
    & 0 & * & * & 0 & 0 & 0 & 0 & 0 & 0 & * \\ * & 0 & 0 & 0 & 0 & 0 & 0 & * & * &
    0 & 0 & 0 & 0 & 0 \\ 0 & * & 0 & 0 & 0 & 0 & 0 & * & * & * & 0 & 0 & 0 & 0 \\
    0 & 0 & * & 0 & 0 & 0 & 0 & 0 & * & * & * & 0 & 0 & 0 \\ 0 & 0 & 0 & * & 0 & 0
    & 0 & 0 & 0 & * & * & * & 0 & 0 \\ 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & 0 & * &
    * & * & 0 \\ 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & 0 & * & * & * \\ 0 & 0 &
    0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & ) & * & * \\ \end{smallmatrix}\end{split}\]
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\begin{smallmatrix} * & * & 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0
    & 0 & 0 & 0 \\ * & * & * & 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & 0 \\ 0 & *
    & * & * & 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 \\ 0 & 0 & * & * & * & 0 & 0 &
    0 & 0 & 0 & * & 0 & 0 & 0 \\ 0 & 0 & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 & * & 0
    & 0 \\ 0 & 0 & 0 & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 & * & 0 \\ 0 & 0 & 0 & 0
    & 0 & * & * & 0 & 0 & 0 & 0 & 0 & 0 & * \\ * & 0 & 0 & 0 & 0 & 0 & 0 & * & * &
    0 & 0 & 0 & 0 & 0 \\ 0 & * & 0 & 0 & 0 & 0 & 0 & * & * & * & 0 & 0 & 0 & 0 \\
    0 & 0 & * & 0 & 0 & 0 & 0 & 0 & * & * & * & 0 & 0 & 0 \\ 0 & 0 & 0 & * & 0 & 0
    & 0 & 0 & 0 & * & * & * & 0 & 0 \\ 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & 0 & * &
    * & * & 0 \\ 0 & 0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & 0 & * & * & * \\ 0 & 0 &
    0 & 0 & 0 & 0 & * & 0 & 0 & 0 & 0 & * & * & * \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & *
    & * & 0 & 0 & 0 & 0 & 0 \\ \end{smallmatrix}\end{split}\]
- en: The Jacobian pattern with variables interleaved as \(\{u_0, v_0, u_1, v_1, \ldots,
    u_{N-1}, v_{N-1}\}\) is
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 使用变量交错排列的雅可比模式为 \(\{u_0, v_0, u_1, v_1, \ldots, u_{N-1}, v_{N-1}\}\) 是
- en: \[\begin{split}\begin{smallmatrix} * & * & * & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
    & 0 & 0 & 0 \\ * & * & 0 & * & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ * & 0
    & * & * & * & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & * & * & * & 0 & * & 0 &
    0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & * & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 & 0
    & 0 \\ 0 & 0 & 0 & * & * & * & 0 & * & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0
    & * & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & * & * & * & 0 &
    * & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & * & 0 & * & * & * & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & * & * & * & 0 & * & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0
    & 0 & 0 & * & 0 & * & * & * & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & * & * &
    * & 0 & * \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & * & 0 & * & * \\ 0 & 0 &
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & * & * & * \\ \end{smallmatrix}\end{split}\]
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split}\begin{smallmatrix} * & * & * & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0
    & 0 & 0 & 0 \\ * & * & 0 & * & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ * & 0
    & * & * & * & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & * & * & * & 0 & * & 0 &
    0 & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & * & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 & 0
    & 0 \\ 0 & 0 & 0 & * & * & * & 0 & * & 0 & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0
    & * & 0 & * & * & * & 0 & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & * & * & * & 0 &
    * & 0 & 0 & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & * & 0 & * & * & * & 0 & 0 & 0 \\
    0 & 0 & 0 & 0 & 0 & 0 & 0 & * & * & * & 0 & * & 0 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0
    & 0 & 0 & * & 0 & * & * & * & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & * & * &
    * & 0 & * \\ 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & * & 0 & * & * \\ 0 & 0 &
    0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & * & * & * \\ \end{smallmatrix}\end{split}\]
- en: In both cases, there are just five nontrivial diagonals, but when the variables
    are interleaved, the bandwidth is much smaller. That is, the main diagonal and
    the two diagonals immediately above and the two immediately below the main diagonal
    are the nonzero diagonals. This is important, because the inputs `mu` and `ml`
    of [`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") are the upper and lower bandwidths of the Jacobian matrix.
    When the variables are interleaved, `mu` and `ml` are 2\. When the variables are
    stacked with \(\{v_k\}\) following \(\{u_k\}\), the upper and lower bandwidths
    are \(N\).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，只有五条非平凡对角线，但当变量交错时，带宽要小得多。也就是说，主对角线和主对角线上下两侧的两条对角线是非零的。这很重要，因为[`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") 的输入 `mu` 和 `ml` 是雅可比矩阵的上下带宽。当变量交错时，`mu` 和 `ml` 都是 2。当变量以
    \(\{v_k\}\) 排列跟随 \(\{u_k\}\) 时，上下带宽是 \(N\)。
- en: With that decision made, we can write the function that implements the system
    of differential equations.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 决定好后，我们可以编写实现微分方程系统的函数。
- en: 'First, we define the functions for the source and reaction terms of the system:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义系统的源项和反应项的函数：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we define the function that computes the right-hand side of the system
    of differential equations:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们定义计算微分方程组右端的函数：
- en: '[PRE32]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We won’t implement a function to compute the Jacobian, but we will tell [`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") that the Jacobian matrix is banded. This allows the
    underlying solver (LSODA) to avoid computing values that it knows are zero. For
    a large system, this improves the performance significantly, as demonstrated in
    the following ipython session.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会实现一个计算雅可比矩阵的函数，但我们会告诉[`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") 雅可比矩阵是带状的。这使得底层求解器（LSODA）可以避免计算已知为零的值。对于大型系统，这显著提高了性能，正如以下
    ipython 会话中所示。
- en: 'First, we define the required inputs:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义所需的输入：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Time the computation without taking advantage of the banded structure of the
    Jacobian matrix:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 不利用雅可比矩阵的带状结构来计算时间：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now set `ml=2` and `mu=2`, so [`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") knows that the Jacobian matrix is banded:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置 `ml=2` 和 `mu=2`，这样[`odeint`](../reference/generated/scipy.integrate.odeint.html#scipy.integrate.odeint
    "scipy.integrate.odeint") 知道雅可比矩阵是带状的：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: That is quite a bit faster!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这样快了不少！
- en: 'Let’s ensure that they have computed the same result:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确保它们计算出了相同的结果：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: References
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[[WPR](#id1)]'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[[WPR](#id1)]'
- en: '[https://en.wikipedia.org/wiki/Romberg’s_method](https://en.wikipedia.org/wiki/Romberg''s_method)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Romberg’s_method](https://en.wikipedia.org/wiki/Romberg''s_method)'
- en: '[[MOL](#id2)]'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[[MOL](#id2)]'
- en: '[https://en.wikipedia.org/wiki/Method_of_lines](https://en.wikipedia.org/wiki/Method_of_lines)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/Method_of_lines](https://en.wikipedia.org/wiki/Method_of_lines)'
