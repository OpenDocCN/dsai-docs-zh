# 版本 0.21.0（2017 年 10 月 27 日）

> 原文：[`pandas.pydata.org/docs/whatsnew/v0.21.0.html`](https://pandas.pydata.org/docs/whatsnew/v0.21.0.html)

这是从 0.20.3 开始的一个重大更新，包括许多 API 更改、弃用、新功能、增强功能和性能改进，以及大量的错误修复。我们建议所有用户升级到这个版本。

亮点包括：

+   与 [Apache Parquet](https://parquet.apache.org/) 集成，包括一个新的顶级 `read_parquet()` 函数和 `DataFrame.to_parquet()` 方法，请见这里。

+   新的用户界面 `pandas.api.types.CategoricalDtype` 用于独立于数据指定分类变量，详情请见这里。

+   对于所有值为 NaN 的 Series/DataFrames，`sum` 和 `prod` 的行为现在是一致的，不再取决于是否安装了 [bottleneck](https://bottleneck.readthedocs.io)，而且空 Series 上的 `sum` 和 `prod` 现在返回 NaN 而不是 0，请参见这里。

+   pypy 的兼容性修复，请见这里。

+   对 `drop`、`reindex` 和 `rename` API 的添加，使它们更加一致，请见这里。

+   新方法 `DataFrame.infer_objects`（请见这里）和 `GroupBy.pipe`（请见这里）的添加。

+   使用标签列表进行索引，其中一个或多个标签丢失的情况已被弃用，并将在将来的版本中引发 KeyError，请见这里。

在更新之前，请查看 API 更改和弃用项。

v0.21.0 有什么新功能

+   新功能

    +   与 Apache Parquet 文件格式的集成

    +   方法 `infer_objects` 类型转换

    +   当尝试创建列时，警告改进

    +   方法 `drop` 现在也接受 index/columns 关键字

    +   方法 `rename`、`reindex` 现在也接受 axis 关键字

    +   用于指定分类变量的 `CategoricalDtype`

    +   `GroupBy` 对象现在具有 `pipe` 方法

    +   `Categorical.rename_categories` 现在接受类似字典的对象

    +   其他增强

+   向后不兼容的 API 更改

    +   依赖项的最低版本已经提高

    +   所有-NaN 或空 Series/DataFrames 的 sum/prod 现在一致为 NaN

    +   使用具有缺失标签的列表进行索引已弃用

    +   NA 命名更改

    +   Series/Index 的迭代现在���返回 Python 标量

    +   使用布尔索引进行索引

    +   `PeriodIndex` 重采样

    +   在 pd.eval 中进行项目赋值时改进错误处理

    +   Dtype 转换

    +   使用单个级别的 MultiIndex 构造函数

    +   Series 中的 UTC 本地化

    +   范围函数的一致性

    +   不再自动转换为 Matplotlib

    +   其他 API 更改

+   弃用

    +   Series.select 和 DataFrame.select

    +   Series.argmax 和 Series.argmin

+   删除之前版本的弃用/更改

+   性能改进

+   文档更改

+   错误修复

    +   转换

    +   索引

    +   IO

    +   绘图

    +   GroupBy/resample/rolling

    +   稀疏

    +   重塑

    +   数值

    +   分类

    +   PyPy

    +   其他

+   贡献者

## 新功能

### 与 Apache Parquet 文件格式的集成

与 [Apache Parquet](https://parquet.apache.org/) 的集成，包括一个新的顶级`read_parquet()` 和 `DataFrame.to_parquet()` 方法，请参见这里 ([GH 15838](https://github.com/pandas-dev/pandas/issues/15838), [GH 17438](https://github.com/pandas-dev/pandas/issues/17438))。

[Apache Parquet](https://parquet.apache.org/) 提供了一个跨语言的二进制文件格式，用于高效读写数据框。Parquet 被设计为忠实地序列化和反序列化`DataFrame` s，支持所有的 pandas dtypes，包括带有时区的扩展 dtypes，如带有时区的日期时间。

此功能取决于 [pyarrow](http://arrow.apache.org/docs/python/) 或 [fastparquet](https://fastparquet.readthedocs.io/en/latest/) 库。有关更多详细信息，请参阅 Parquet 上的 IO 文档。### 方法 `infer_objects` 类型转换

`DataFrame.infer_objects()`和`Series.infer_objects()`方法已添加以在对象列上执行 dtype 推断，取代了已弃用的`convert_objects`方法的部分功能。有关更多详细信息，请参阅此处的文档。([GH 11221](https://github.com/pandas-dev/pandas/issues/11221))

此方法仅对对象列执行软转换，将 Python 对象转换为本机类型，但不执行任何强制转换。例如：

```py
In [1]: df = pd.DataFrame({'A': [1, 2, 3],
 ...:                   'B': np.array([1, 2, 3], dtype='object'),
 ...:                   'C': ['1', '2', '3']})
 ...: 

In [2]: df.dtypes
Out[2]: 
A     int64
B    object
C    object
Length: 3, dtype: object

In [3]: df.infer_objects().dtypes
Out[3]: 
A     int64
B     int64
C    object
Length: 3, dtype: object 
```

请注意列`'C'`未被转换 - 只有标量数值类型将被转换为新类型。其他类型的转换应使用`to_numeric()`函数（或`to_datetime()`，`to_timedelta()`）来完成。

```py
In [4]: df = df.infer_objects()

In [5]: df['C'] = pd.to_numeric(df['C'], errors='coerce')

In [6]: df.dtypes
Out[6]: 
A    int64
B    int64
C    int64
Length: 3, dtype: object 
```  ### 尝试创建列时改进的警告

新用户经常对`DataFrame`实例上的列操作和属性访问之间的关系感到困惑（[GH 7175](https://github.com/pandas-dev/pandas/issues/7175)）。这种困惑的一个具体例子是尝试通过在`DataFrame`上设置属性来创建新列：

```py
In [1]: df = pd.DataFrame({'one': [1., 2., 3.]})
In [2]: df.two = [4, 5, 6] 
```

这不会引发任何明显的异常，但也不会创建新列：

```py
In [3]: df
Out[3]:
 one
0  1.0
1  2.0
2  3.0 
```

将类似列表的数据结构设置为新属性现在会引发一个关于潜在意外行为的`UserWarning`。请参阅属性访问。  ### 方法`drop`现在还接受索引/列关键字

`drop()`方法已经增加了`index`/`columns`关键字作为指定`axis`的替代方法。这类似于`reindex`的行为（[GH 12392](https://github.com/pandas-dev/pandas/issues/12392)）。

例如：

```py
In [7]: df = pd.DataFrame(np.arange(8).reshape(2, 4),
 ...:                  columns=['A', 'B', 'C', 'D'])
 ...: 

In [8]: df
Out[8]: 
 A  B  C  D
0  0  1  2  3
1  4  5  6  7

[2 rows x 4 columns]

In [9]: df.drop(['B', 'C'], axis=1)
Out[9]: 
 A  D
0  0  3
1  4  7

[2 rows x 2 columns]

# the following is now equivalent
In [10]: df.drop(columns=['B', 'C'])
Out[10]: 
 A  D
0  0  3
1  4  7

[2 rows x 2 columns] 
```  ### 方法`rename`，`reindex`现在也接受 axis 关键字

`DataFrame.rename()`和`DataFrame.reindex()`方法已经增加了`axis`关键字，用于指定要针对操作的轴（[GH 12392](https://github.com/pandas-dev/pandas/issues/12392)）。

这里是`rename`：

```py
In [11]: df = pd.DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})

In [12]: df.rename(str.lower, axis='columns')
Out[12]: 
 a  b
0  1  4
1  2  5
2  3  6

[3 rows x 2 columns]

In [13]: df.rename(id, axis='index')
Out[13]: 
 A  B
140682504175824  1  4
140682504175856  2  5
140682504175888  3  6

[3 rows x 2 columns] 
```

和`reindex`：

```py
In [14]: df.reindex(['A', 'B', 'C'], axis='columns')
Out[14]: 
 A  B   C
0  1  4 NaN
1  2  5 NaN
2  3  6 NaN

[3 rows x 3 columns]

In [15]: df.reindex([0, 1, 3], axis='index')
Out[15]: 
 A    B
0  1.0  4.0
1  2.0  5.0
3  NaN  NaN

[3 rows x 2 columns] 
```

“索引，列”风格仍然像以前一样工作。

```py
In [16]: df.rename(index=id, columns=str.lower)
Out[16]: 
 a  b
140682504175824  1  4
140682504175856  2  5
140682504175888  3  6

[3 rows x 2 columns]

In [17]: df.reindex(index=[0, 1, 3], columns=['A', 'B', 'C'])
Out[17]: 
 A    B   C
0  1.0  4.0 NaN
1  2.0  5.0 NaN
3  NaN  NaN NaN

[3 rows x 3 columns] 
```

我们*强烈*建议使用命名参数以避免在使用任何风格时产生混淆。  ### 用于指定分类的`CategoricalDtype`

`pandas.api.types.CategoricalDtype` 已添加到公共 API，并扩展以包括 `categories` 和 `ordered` 属性。`CategoricalDtype` 可用于指定数组的类别集和顺序，而与数据无关。例如，当将字符串数据转换为 `Categorical` 时，这可能很有用 ([GH 14711](https://github.com/pandas-dev/pandas/issues/14711), [GH 15078](https://github.com/pandas-dev/pandas/issues/15078), [GH 16015](https://github.com/pandas-dev/pandas/issues/16015), [GH 17643](https://github.com/pandas-dev/pandas/issues/17643)):

```py
In [18]: from pandas.api.types import CategoricalDtype

In [19]: s = pd.Series(['a', 'b', 'c', 'a'])  # strings

In [20]: dtype = CategoricalDtype(categories=['a', 'b', 'c', 'd'], ordered=True)

In [21]: s.astype(dtype)
Out[21]: 
0    a
1    b
2    c
3    a
Length: 4, dtype: category
Categories (4, object): ['a' < 'b' < 'c' < 'd'] 
```

一个值得特别提及的地方是在 `read_csv()` 中。以前，使用 `dtype={'col': 'category'}`，返回的值和类别总是字符串。

```py
In [22]: data = 'A,B\na,1\nb,2\nc,3'

In [23]: pd.read_csv(StringIO(data), dtype={'B': 'category'}).B.cat.categories
Out[23]: Index(['1', '2', '3'], dtype='object') 
```

注意“object” dtype。

有了所有数字、日期时间或时间增量的 `CategoricalDtype`，我们可以自动转换为正确的类型

```py
In [24]: dtype = {'B': CategoricalDtype([1, 2, 3])}

In [25]: pd.read_csv(StringIO(data), dtype=dtype).B.cat.categories
Out[25]: Index([1, 2, 3], dtype='int64') 
```

值已被正确解释为整数。

`Categorical`、`CategoricalIndex` 或具有分类类型的 `Series` 的 `.dtype` 属性现在将返回 `CategoricalDtype` 的实例。虽然 repr 已更改，但 `str(CategoricalDtype())` 仍然是字符串 `'category'`。我们在此提醒用户，检测分类数据的*首选*方法是使用 `pandas.api.types.is_categorical_dtype()`，而不是 `str(dtype) == 'category'`。

更多信息请参阅 CategoricalDtype 文档。  ### `GroupBy` 对象现在有一个 `pipe` 方法

`GroupBy` 对象现在有一个 `pipe` 方法，类似于 `DataFrame` 和 `Series` 上的方法，允许以清晰、易读的语法组合接受 `GroupBy` 的函数。([GH 17871](https://github.com/pandas-dev/pandas/issues/17871))

对于一个结合了 `.groupby` 和 `.pipe` 的具体示例，请想象一个包含了商店、产品、收入和销售数量列的 DataFrame。我们希望对每个商店和每种产品进行组内计算 *价格*（即收入/数量）。我们可以通过多步操作来完成这个操作，但用管道来表达会使代码更易读。

首先我们设置数据：

```py
In [26]: import numpy as np

In [27]: n = 1000

In [28]: df = pd.DataFrame({'Store': np.random.choice(['Store_1', 'Store_2'], n),
 ....:                   'Product': np.random.choice(['Product_1',
 ....:                                                'Product_2',
 ....:                                                'Product_3'
 ....:                                                ], n),
 ....:                   'Revenue': (np.random.random(n) * 50 + 10).round(2),
 ....:                   'Quantity': np.random.randint(1, 10, size=n)})
 ....: 

In [29]: df.head(2)
Out[29]: 
 Store    Product  Revenue  Quantity
0  Store_2  Product_2    32.09         7
1  Store_1  Product_3    14.20         1

[2 rows x 4 columns] 
```

现在，要找到每个商店/产品的价格，我们只需简单地执行：

```py
In [30]: (df.groupby(['Store', 'Product'])
 ....:   .pipe(lambda grp: grp.Revenue.sum() / grp.Quantity.sum())
 ....:   .unstack().round(2))
 ....: 
Out[30]: 
Product  Product_1  Product_2  Product_3
Store 
Store_1       6.73       6.72       7.14
Store_2       7.59       6.98       7.23

[2 rows x 3 columns] 
```

更多信息请参阅文档。  ### `Categorical.rename_categories` 接受类似字典的参数

`rename_categories()` 现在接受类似字典的参数作为 `new_categories`。先前的类别将在字典的键中查找并进行替换。缺失和额外键的行为与 `DataFrame.rename()` 中的行为相同。

```py
In [31]: c = pd.Categorical(['a', 'a', 'b'])

In [32]: c.rename_categories({"a": "eh", "b": "bee"})
Out[32]: 
['eh', 'eh', 'bee']
Categories (2, object): ['eh', 'bee'] 
```

警告

为了帮助升级 pandas，`rename_categories` 将 `Series` 视为类似列表的对象。通常，Series 被视为类似字典的对象（例如在 `.rename`、`.map` 中）。在 pandas 的未来版本中，`rename_categories` 将会改变其对待方式，将其视为类似字典的对象。请遵循警告信息的建议编写具有未来兼容性的代码。

```py
In [33]: c.rename_categories(pd.Series([0, 1], index=['a', 'c']))
FutureWarning: Treating Series 'new_categories' as a list-like and using the values.
In a future version, 'rename_categories' will treat Series like a dictionary.
For dict-like, use 'new_categories.to_dict()'
For list-like, use 'new_categories.values'.
Out[33]:
[0, 0, 1]
Categories (2, int64): [0, 1] 
```  ### 其他增强功能

#### 新增的函数或方法

+   `Resampler.nearest()` 添加了支持最近邻上采样的功能（[GH 17496](https://github.com/pandas-dev/pandas/issues/17496)）。

+   `Index` 添加了 `to_frame` 方法的支持（[GH 15230](https://github.com/pandas-dev/pandas/issues/15230)）。

#### 新增的关键字

+   添加了 `skipna` 参数到 `infer_dtype()` 以支持在存在缺失值时进行类型推断（[GH 17059](https://github.com/pandas-dev/pandas/issues/17059)）。

+   `Series.to_dict()` 和 `DataFrame.to_dict()` 现在支持一个 `into` 关键字，该关键字允许您指定要返回的 `collections.Mapping` 子类。默认为 `dict`，与向后兼容性一致。（[GH 16122](https://github.com/pandas-dev/pandas/issues/16122)）

+   `Series.set_axis()` 和 `DataFrame.set_axis()` 现在支持 `inplace` 参数。（[GH 14636](https://github.com/pandas-dev/pandas/issues/14636)）

+   `Series.to_pickle()` 和 `DataFrame.to_pickle()` 已经添加了 `protocol` 参数（[GH 16252](https://github.com/pandas-dev/pandas/issues/16252)）。默认情况下，此参数设置为 [HIGHEST_PROTOCOL](https://docs.python.org/3/library/pickle.html#data-stream-format)。

+   `read_feather()` 增加了 `nthreads` 参数，用于多线程操作 ([GH 16359](https://github.com/pandas-dev/pandas/issues/16359))

+   `DataFrame.clip()` 和 `Series.clip()` 现在增加了一个 `inplace` 参数。 ([GH 15388](https://github.com/pandas-dev/pandas/issues/15388))

+   `crosstab()` 增加了一个 `margins_name` 参数，用于定义当 `margins=True` 时包含总计的行/列的名称。 ([GH 15972](https://github.com/pandas-dev/pandas/issues/15972))

+   `read_json()` 现在接受一个 `chunksize` 参数，当 `lines=True` 时可以使用。如果传递了 `chunksize`，read_json 现在返回一个迭代器，每次迭代读取 `chunksize` 行。 ([GH 17048](https://github.com/pandas-dev/pandas/issues/17048))

+   `read_json()` 和 `to_json()` 现在接受一个 `compression` 参数，允许它们透明地处理压缩文件。 ([GH 17798](https://github.com/pandas-dev/pandas/issues/17798))

#### 各种增强

+   将 pandas 的导入时间提高了约 2.25 倍。 ([GH 16764](https://github.com/pandas-dev/pandas/issues/16764))

+   对大多数读取器（例如 `read_csv()`）和写入器（例如 `DataFrame.to_csv()`）添加了对 [PEP 519 – Adding a file system path protocol](https://www.python.org/dev/peps/pep-0519/) 的支持 ([GH 13823](https://github.com/pandas-dev/pandas/issues/13823)).

+   对 `pd.HDFStore`, `pd.ExcelFile`, 和 `pd.ExcelWriter` 添加了一个 `__fspath__` 方法，以正确处理文件系统路径协议 ([GH 13823](https://github.com/pandas-dev/pandas/issues/13823)).

+   `merge()` 的 `validate` 参数现在检查合并是一对一、一对多、多对一还是多对多。如果发现合并不是指定合并类型的示例，则会引发 `MergeError` 类型的异常。有关更多信息，请参见这里 ([GH 16270](https://github.com/pandas-dev/pandas/issues/16270))

+   对构建系统添加了对 [PEP 518](https://www.python.org/dev/peps/pep-0518/) (`pyproject.toml`) 的支持 ([GH 16745](https://github.com/pandas-dev/pandas/issues/16745))

+   `RangeIndex.append()` 现在在可能时返回一个`RangeIndex`对象 ([GH 16212](https://github.com/pandas-dev/pandas/issues/16212))

+   `Series.rename_axis()` 和 `DataFrame.rename_axis()` 在`inplace=True`时，现在会在原地重命名轴并返回`None`。 ([GH 15704](https://github.com/pandas-dev/pandas/issues/15704))

+   `api.types.infer_dtype()` 现在能够推断小数。 ([GH 15690](https://github.com/pandas-dev/pandas/issues/15690))

+   `DataFrame.select_dtypes()` 现在接受标量值用于包含/排除以及类似列表的值。 ([GH 16855](https://github.com/pandas-dev/pandas/issues/16855))

+   `date_range()` 现在除了‘AS’之外，还接受‘YS’作为年初的别名。 ([GH 9313](https://github.com/pandas-dev/pandas/issues/9313))

+   `date_range()` 现在除了‘A’之外，还接受‘Y’作为年末的别名。 ([GH 9313](https://github.com/pandas-dev/pandas/issues/9313))

+   `DataFrame.add_prefix()` 和 `DataFrame.add_suffix()` 现在接受包含‘%’字符的字符串。 ([GH 17151](https://github.com/pandas-dev/pandas/issues/17151))

+   读/写方法可以推断压缩（`read_csv()`、`read_table()`、`read_pickle()`和`to_pickle()`) 现在可以从类似路径的对象中推断，比如`pathlib.Path`。 ([GH 17206](https://github.com/pandas-dev/pandas/issues/17206))

+   `read_sas()` 现在能够识别更多 SAS7BDAT 文件中最常用的日期（时间）格式。 ([GH 15871](https://github.com/pandas-dev/pandas/issues/15871))

+   `DataFrame.items()` 和 `Series.items()` 现在在 Python 2 和 3 中都存在，并且在所有情况下都是惰性的。 ([GH 13918](https://github.com/pandas-dev/pandas/issues/13918), [GH 17213](https://github.com/pandas-dev/pandas/issues/17213))

+   `pandas.io.formats.style.Styler.where()` 已实现为 `pandas.io.formats.style.Styler.applymap()` 的方便用法。 ([GH 17474](https://github.com/pandas-dev/pandas/issues/17474))

+   已实现 `MultiIndex.is_monotonic_decreasing()`。先前在所有情况下返回 `False`。 ([GH 16554](https://github.com/pandas-dev/pandas/issues/16554))

+   `read_excel()` 如果未安装 `xlrd`，则提供更好的消息引发 `ImportError`。 ([GH 17613](https://github.com/pandas-dev/pandas/issues/17613))

+   `DataFrame.assign()` 将为 Python 3.6+ 用户保留 `**kwargs` 的原始顺序，而不是对列名进行排序。 ([GH 14207](https://github.com/pandas-dev/pandas/issues/14207))

+   `Series.reindex()`, `DataFrame.reindex()`, `Index.get_indexer()` 现在支持 `tolerance` 的类似列表参数。 ([GH 17367](https://github.com/pandas-dev/pandas/issues/17367))  ## 不兼容的 API 更改

### 依赖项已增加最低版本要求

我们已更新了对依赖项的最低支持版本 ([GH 15206](https://github.com/pandas-dev/pandas/issues/15206), [GH 15543](https://github.com/pandas-dev/pandas/issues/15543), [GH 15214](https://github.com/pandas-dev/pandas/issues/15214))。 如果已安装，我们现在要求：

> | Package | Minimum Version | Required |
> | --- | --- | --- |
> | Numpy | 1.9.0 | X |
> | Matplotlib | 1.4.3 |  |
> | Scipy | 0.14.0 |  |
> | Bottleneck | 1.0.0 |  |

此外，不再支持 Python 3.4 ([GH 15251](https://github.com/pandas-dev/pandas/issues/15251))。  ### 所有-NaN 或空 Series/DataFrames 的 Sum/prod 现在一致为 NaN

注

此处描述的更改已被部分撤销。请参阅 v0.22.0 Whatsnew 了解更多。

`sum` 和 `prod` 在所有-NaN Series/DataFrames 上的行为不再取决于是否已安装 [bottleneck](https://bottleneck.readthedocs.io)，并且空 Series 上 `sum` 和 `prod` 的返回值已更改 ([GH 9422](https://github.com/pandas-dev/pandas/issues/9422), [GH 15507](https://github.com/pandas-dev/pandas/issues/15507))。

对于空或全部为`NaN`的`Series`，或者`DataFrame`的列，调用`sum`或`prod`将导致`NaN`。请参阅文档。

```py
In [33]: s = pd.Series([np.nan]) 
```

先前没有安装`bottleneck`：

```py
In [2]: s.sum()
Out[2]: np.nan 
```

先前带有`bottleneck`：

```py
In [2]: s.sum()
Out[2]: 0.0 
```

新行为，不考虑`bottleneck`的安装情况：

```py
In [34]: s.sum()
Out[34]: 0.0 
```

请注意，这也改变了空`Series`的和。以前，这总是返回 0，无论是否安装了`bottleneck`：

```py
In [1]: pd.Series([]).sum()
Out[1]: 0 
```

但为了与全`NaN`情况保持一致，这也改为返回 0：

```py
In [2]: pd.Series([]).sum()
Out[2]: 0 
```  ### 使用带有缺失标签的列表进行索引已弃用

以前，使用带有缺失标签的列表进行选择总是会成功，对于缺失的标签返回`NaN`。现在这将显示一个`FutureWarning`。将来这将引发一个`KeyError`([GH 15747](https://github.com/pandas-dev/pandas/issues/15747))。当传递至少有 1 个缺失标签的标签列表时，此警告将在使用`.loc[]`或`[[]]`的`DataFrame`或`Series`上触发。

```py
In [35]: s = pd.Series([1, 2, 3])

In [36]: s
Out[36]: 
0    1
1    2
2    3
Length: 3, dtype: int64 
```

先前的行为

```py
In [4]: s.loc[[1, 2, 3]]
Out[4]:
1    2.0
2    3.0
3    NaN
dtype: float64 
```

当前行为

```py
In [4]: s.loc[[1, 2, 3]]
Passing list-likes to .loc or [] with any missing label will raise
KeyError in the future, you can use .reindex() as an alternative.

See the documentation here:
https://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike

Out[4]:
1    2.0
2    3.0
3    NaN
dtype: float64 
```

实现选择可能未找到的元素的惯用方法是通过`.reindex()`。

```py
In [37]: s.reindex([1, 2, 3])
Out[37]: 
1    2.0
2    3.0
3    NaN
Length: 3, dtype: float64 
```

选择所有找到的键不变。

```py
In [38]: s.loc[[1, 2]]
Out[38]: 
1    2
2    3
Length: 2, dtype: int64 
```  ### NA 命名更改

为了在 pandas API 中促进更一致性，我们添加了额外的顶级函数`isna()`和`notna()`，它们是`isnull()`和`notnull()`的别名。命名方案现在与`.dropna()`和`.fillna()`等方法更一致。此外，在定义`.isnull()`和`.notnull()`方法的所有情况下，这些方法都有额外的方法名为`.isna()`和`.notna()`，这些方法包括类`Categorical`、`Index`、`Series`和`DataFrame`。 ([GH 15001](https://github.com/pandas-dev/pandas/issues/15001))。

配置选项`pd.options.mode.use_inf_as_null`已弃用，新增了`pd.options.mode.use_inf_as_na`作为替代。  ### Series/Index 的迭代现在将返回 Python 标量

以前，对于 dtype 为`int`或`float`的`Series`使用某些迭代方法时，您将收到一个`numpy`标量，例如`np.int64`，而不是 Python `int`。问题([GH 10904](https://github.com/pandas-dev/pandas/issues/10904))已经为`Series.tolist()`和`list(Series)`更正了这一点。此更改使所有迭代方法保持一致，特别是对于`__iter__()`和`.map()`；请注意，这仅影响 int/float dtypes。([GH 13236](https://github.com/pandas-dev/pandas/issues/13236), [GH 13258](https://github.com/pandas-dev/pandas/issues/13258), [GH 14216](https://github.com/pandas-dev/pandas/issues/14216))。

```py
In [39]: s = pd.Series([1, 2, 3])

In [40]: s
Out[40]: 
0    1
1    2
2    3
Length: 3, dtype: int64 
```

以前：

```py
In [2]: type(list(s)[0])
Out[2]: numpy.int64 
```

新行为：

```py
In [41]: type(list(s)[0])
Out[41]: int 
```

此外，现在将正确地对`DataFrame.to_dict()` 的结果进行盒装。

```py
In [42]: d = {'a': [1], 'b': ['b']}

In [43]: df = pd.DataFrame(d) 
```

以前：

```py
In [8]: type(df.to_dict()['a'][0])
Out[8]: numpy.int64 
```

新行为：

```py
In [44]: type(df.to_dict()['a'][0])
Out[44]: int 
```  ### 使用布尔索引进行索引

以前，当将布尔`Index`传递给`.loc`时，如果`Series/DataFrame`的索引具有`boolean`标签，则会获得基于标签的选择，可能会复制结果标签，而不是布尔索引选择（其中`True`选择元素），这与布尔 numpy 数组的索引方式不一致。新行为是像布尔 numpy 数组索引器一样操作。([GH 17738](https://github.com/pandas-dev/pandas/issues/17738))

先前行为：

```py
In [45]: s = pd.Series([1, 2, 3], index=[False, True, False])

In [46]: s
Out[46]: 
False    1
True     2
False    3
Length: 3, dtype: int64 
```

```py
In [59]: s.loc[pd.Index([True, False, True])]
Out[59]:
True     2
False    1
False    3
True     2
dtype: int64 
```

当前行为

```py
In [47]: s.loc[pd.Index([True, False, True])]
Out[47]: 
False    1
False    3
Length: 2, dtype: int64 
```

此外，以前如果索引是非数字的（例如字符串），那么布尔索引将引发`KeyError`。现在将被视为布尔索引器。

先前行为：

```py
In [48]: s = pd.Series([1, 2, 3], index=['a', 'b', 'c'])

In [49]: s
Out[49]: 
a    1
b    2
c    3
Length: 3, dtype: int64 
```

```py
In [39]: s.loc[pd.Index([True, False, True])]
KeyError: "None of [Index([True, False, True], dtype='object')] are in the [index]" 
```

当前行为

```py
In [50]: s.loc[pd.Index([True, False, True])]
Out[50]: 
a    1
c    3
Length: 2, dtype: int64 
```  ### `PeriodIndex` 重新采样

在 pandas 的先前版本中，对由`PeriodIndex`索引的`Series`/`DataFrame`进行重新采样在某些情况下返回一个`DatetimeIndex` ([GH 12884](https://github.com/pandas-dev/pandas/issues/12884))。现在，对乘频率进行重新采样将返回一个`PeriodIndex` ([GH 15944](https://github.com/pandas-dev/pandas/issues/15944))。作为一个小的增强，现在可以处理`PeriodIndex`中的`NaT`值 ([GH 13224](https://github.com/pandas-dev/pandas/issues/13224))

先前行为：

```py
In [1]: pi = pd.period_range('2017-01', periods=12, freq='M')

In [2]: s = pd.Series(np.arange(12), index=pi)

In [3]: resampled = s.resample('2Q').mean()

In [4]: resampled
Out[4]:
2017-03-31     1.0
2017-09-30     5.5
2018-03-31    10.0
Freq: 2Q-DEC, dtype: float64

In [5]: resampled.index
Out[5]: DatetimeIndex(['2017-03-31', '2017-09-30', '2018-03-31'], dtype='datetime64[ns]', freq='2Q-DEC') 
```

新行为：

```py
In [1]: pi = pd.period_range('2017-01', periods=12, freq='M')

In [2]: s = pd.Series(np.arange(12), index=pi)

In [3]: resampled = s.resample('2Q').mean()

In [4]: resampled
Out[4]:
2017Q1    2.5
2017Q3    8.5
Freq: 2Q-DEC, dtype: float64

In [5]: resampled.index
Out[5]: PeriodIndex(['2017Q1', '2017Q3'], dtype='period[2Q-DEC]') 
```

上采样并调用`.ohlc()` 以前返回一个`Series`，基本上与调用`.asfreq()` 相同。现在，OHLC 上采样将返回一个具有列`open`、`high`、`low` 和`close`的 DataFrame ([GH 13083](https://github.com/pandas-dev/pandas/issues/13083))。这与下采样和`DatetimeIndex`的行为一致。

先前行为：

```py
In [1]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)

In [2]: s = pd.Series(np.arange(10), index=pi)

In [3]: s.resample('H').ohlc()
Out[3]:
2000-01-01 00:00    0.0
 ...
2000-01-10 23:00    NaN
Freq: H, Length: 240, dtype: float64

In [4]: s.resample('M').ohlc()
Out[4]:
 open  high  low  close
2000-01     0     9    0      9 
```

新行为：

```py
In [56]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)

In [57]: s = pd.Series(np.arange(10), index=pi)

In [58]: s.resample('H').ohlc()
Out[58]:
 open  high  low  close
2000-01-01 00:00   0.0   0.0  0.0    0.0
2000-01-01 01:00   NaN   NaN  NaN    NaN
2000-01-01 02:00   NaN   NaN  NaN    NaN
2000-01-01 03:00   NaN   NaN  NaN    NaN
2000-01-01 04:00   NaN   NaN  NaN    NaN
...                ...   ...  ...    ...
2000-01-10 19:00   NaN   NaN  NaN    NaN
2000-01-10 20:00   NaN   NaN  NaN    NaN
2000-01-10 21:00   NaN   NaN  NaN    NaN
2000-01-10 22:00   NaN   NaN  NaN    NaN
2000-01-10 23:00   NaN   NaN  NaN    NaN

[240 rows x 4 columns]

In [59]: s.resample('M').ohlc()
Out[59]:
 open  high  low  close
2000-01     0     9    0      9

[1 rows x 4 columns] 
```  ### 在 pd.eval 中改进了项目分配时的错误处理

`eval()` 现在会在项目分配出现故障或指定了原地操作但表达式中没有项目分配时引发`ValueError`（[GH 16732](https://github.com/pandas-dev/pandas/issues/16732)）

```py
In [51]: arr = np.array([1, 2, 3]) 
```

以前，如果尝试以下表达式，将会得到一个不太有用的错误消息：

```py
In [3]: pd.eval("a = 1 + 2", target=arr, inplace=True)
...
IndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`)
and integer or boolean arrays are valid indices 
```

这是说 numpy 数组不支持字符串项索引的一种很长的方式。通过这个改变，错误消息现在是这样的：

```py
In [3]: pd.eval("a = 1 + 2", target=arr, inplace=True)
...
ValueError: Cannot assign expression output to target 
```

以前还可以对表达式进行原地评估，即使没有项目分配：

```py
In [4]: pd.eval("1 + 2", target=arr, inplace=True)
Out[4]: 3 
```

然而，这种输入并没有太多意义，因为输出没有被分配给目标。现在，当传递这样的输入时，将引发`ValueError`：

```py
In [4]: pd.eval("1 + 2", target=arr, inplace=True)
...
ValueError: Cannot operate inplace if there is no assignment 
```  ### Dtype 转换

以前，使用`bool`赋值进行赋值、`.where()`和`.fillna()`会强制转换为相同的类型（例如 int / float），或者对于日期时间相关内容会引发错误。现在，这些操作将保留具有`object`数据类型的布尔值。([GH 16821](https://github.com/pandas-dev/pandas/issues/16821)).

```py
In [52]: s = pd.Series([1, 2, 3]) 
```

```py
In [5]: s[1] = True

In [6]: s
Out[6]:
0    1
1    1
2    3
dtype: int64 
```

新行为

```py
In [7]: s[1] = True

In [8]: s
Out[8]:
0       1
1    True
2       3
Length: 3, dtype: object 
```

以前，对非日期时间相关项进行赋值时，会强制转换为非日期时间相关项（[GH 14145](https://github.com/pandas-dev/pandas/issues/14145)）。

```py
In [53]: s = pd.Series([pd.Timestamp('2011-01-01'), pd.Timestamp('2012-01-01')]) 
```

```py
In [1]: s[1] = 1

In [2]: s
Out[2]:
0   2011-01-01 00:00:00.000000000
1   1970-01-01 00:00:00.000000001
dtype: datetime64[ns] 
```

现在强制转换为`object`数据类型。

```py
In [1]: s[1] = 1

In [2]: s
Out[2]:
0    2011-01-01 00:00:00
1                      1
dtype: object 
```

+   在`.where()`中与日期时间相关的不一致行为，会引发而不是强制转换为`object`（[GH 16402](https://github.com/pandas-dev/pandas/issues/16402)）

+   对带有`float64`数据类型的`np.ndarray`进行`int64`数据的赋值可能会保持`int64`数据类型 ([GH 14001](https://github.com/pandas-dev/pandas/issues/14001))  ### 具有单一级别的 MultiIndex 构造函数

`MultiIndex` 构造函数不再将具有全部长度为一级别的 MultiIndex 压缩为常规`Index`。这会影响到所有的`MultiIndex`构造函数。([GH 17178](https://github.com/pandas-dev/pandas/issues/17178))

先前的行为：

```py
In [2]: pd.MultiIndex.from_tuples([('a',), ('b',)])
Out[2]: Index(['a', 'b'], dtype='object') 
```

长度为 1 的级别不再特殊处理。它们的行为与长度为 2+ 的级别完全相同，因此所有的`MultiIndex`构造函数都将返回一个`MultiIndex`：

```py
In [54]: pd.MultiIndex.from_tuples([('a',), ('b',)])
Out[54]: 
MultiIndex([('a',),
 ('b',)],
 ) 
```  ### 使用 Series 进行 UTC 本地化

以前，当传递`utc=True`时，`to_datetime()`不会对日期时间`Series`数据进行本地化。现在，当传递`utc=True`时，`to_datetime()`将正确地对`datetime64[ns, UTC]`数据类型的`Series`进行本地化，以与列表样式和`Index`数据的处理方式保持一致。([GH 6415](https://github.com/pandas-dev/pandas/issues/6415)).

先前的行为

```py
In [55]: s = pd.Series(['20130101 00:00:00'] * 3) 
```

```py
In [12]: pd.to_datetime(s, utc=True)
Out[12]:
0   2013-01-01
1   2013-01-01
2   2013-01-01
dtype: datetime64[ns] 
```

新行为

```py
In [56]: pd.to_datetime(s, utc=True)
Out[56]: 
0   2013-01-01 00:00:00+00:00
1   2013-01-01 00:00:00+00:00
2   2013-01-01 00:00:00+00:00
Length: 3, dtype: datetime64[ns, UTC] 
```

此外，通过`read_sql_table()`和`read_sql_query()`解析的具有日期时间列的 DataFrame，如果原始 SQL 列是带时区的日期时间列，则也将被本地化为 UTC。### 范围函数的一致性

在以前的版本中，各种范围函数之间存在一些不一致性：`date_range()`、`bdate_range()`、`period_range()`、`timedelta_range()`和`interval_range()`。（[GH 17471](https://github.com/pandas-dev/pandas/issues/17471)）。

当`start`、`end`和`period`参数都指定时，出现不一致的行为之一可能导致模糊的范围。当传递了所有三个参数时，`interval_range`忽略了`period`参数，`period_range`忽略了`end`参数，而其他范围函数则引发了错误。为了促进范围函数之间的一致性，并避免可能的模糊范围，当传递了所有三个参数时，`interval_range`和`period_range`现在将引发错误。

之前的行为：

```py
 In [2]: pd.interval_range(start=0, end=4, periods=6)
 Out[2]:
 IntervalIndex([(0, 1], (1, 2], (2, 3]]
 closed='right',
 dtype='interval[int64]')

In [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')
Out[3]: PeriodIndex(['2017Q1', '2017Q2', '2017Q3', '2017Q4', '2018Q1', '2018Q2'], dtype='period[Q-DEC]', freq='Q-DEC') 
```

新行为：

```py
In [2]: pd.interval_range(start=0, end=4, periods=6)
---------------------------------------------------------------------------
ValueError: Of the three parameters: start, end, and periods, exactly two must be specified

In [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')
---------------------------------------------------------------------------
ValueError: Of the three parameters: start, end, and periods, exactly two must be specified 
```

此外，`interval_range`产生的区间中未包含端点参数`end`。然而，所有其他范围函数都在其输出中包含了`end`。为了促进范围函数之间的一致性，`interval_range`现在将`end`作为最后一个区间的右端点，除非以一种跳过`end`的方式指定了`freq`。

之前的行为：

```py
In [4]: pd.interval_range(start=0, end=4)
Out[4]:
IntervalIndex([(0, 1], (1, 2], (2, 3]]
 closed='right',
 dtype='interval[int64]') 
```

新行为：

```py
In [57]: pd.interval_range(start=0, end=4)
Out[57]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4]], dtype='interval[int64, right]') 
```  ### 没有自动 Matplotlib 转换器

当 pandas 被导入时，pandas 不再使用 matplotlib 注册我们的`date`、`time`、`datetime`、`datetime64`和`Period`转换器。Matplotlib 绘图方法（`plt.plot`、`ax.plot`等）将不会为`DatetimeIndex`或`PeriodIndex`值漂亮地格式化 x 轴。你必须显式注册这些方法：

pandas 内置的`Series.plot`和`DataFrame.plot`*将*在首次使用时注册这些转换器（[GH 17710](https://github.com/pandas-dev/pandas/issues/17710)）。

注意

这个改变在 pandas 0.21.1 中暂时被撤销了，更多详情请见这里。  ### 其他 API 改变

+   分类构造函数不再接受`categories`关键字的标量。 （[GH 16022](https://github.com/pandas-dev/pandas/issues/16022)）

+   在关闭的`HDFStore`上访问一个不存在的属性现在会引发一个`AttributeError`，而不是一个`ClosedFileError`（[GH 16301](https://github.com/pandas-dev/pandas/issues/16301)）

+   `read_csv()`现在会在`names`参数包含重复值时发出一个`UserWarning`（[GH 17095](https://github.com/pandas-dev/pandas/issues/17095))

+   `read_csv()` 现在默认将 `'null'` 和 `'n/a'` 字符串视为缺失值 ([GH 16471](https://github.com/pandas-dev/pandas/issues/16471), [GH 16078](https://github.com/pandas-dev/pandas/issues/16078))

+   `pandas.HDFStore` 的字符串表示现��更快且更简洁。要恢复以前的行为，请使用 `pandas.HDFStore.info()`。([GH 16503](https://github.com/pandas-dev/pandas/issues/16503)).

+   HDF 存储中的压缩默认值现在遵循 pytables 标准。默认值为无压缩，如果 `complib` 丢���且 `complevel` > 0，则使用 `zlib` ([GH 15943](https://github.com/pandas-dev/pandas/issues/15943))

+   `Index.get_indexer_non_unique()` 现在返回一个 ndarray 索引器而不是一个 `Index`；这与 `Index.get_indexer()` 保持一致 ([GH 16819](https://github.com/pandas-dev/pandas/issues/16819))

+   从 `pandas._testing` 中移除了 `@slow` 装饰器，这导致一些下游包的测试套件出现问题。改用 `@pytest.mark.slow`，它可以达到相同的效果 ([GH 16850](https://github.com/pandas-dev/pandas/issues/16850))

+   将 `MergeError` 的定义移动到 `pandas.errors` 模块中。

+   `Series.set_axis()` 和 `DataFrame.set_axis()` 的签名已从 `set_axis(axis, labels)` 更改为 `set_axis(labels, axis=0)`，以保持与其余 API 的一致性。旧的签名已被弃用，并将显示一个 `FutureWarning` ([GH 14636](https://github.com/pandas-dev/pandas/issues/14636))

+   `Series.argmin()` 和 `Series.argmax()` 现在在与 `object` dtypes 一起使用时会引发 `TypeError`，而不是 `ValueError` ([GH 13595](https://github.com/pandas-dev/pandas/issues/13595))

+   `Period` 现在是不可变的，当用户尝试为 `ordinal` 或 `freq` 属性分配新值时，将引发 `AttributeError` ([GH 17116](https://github.com/pandas-dev/pandas/issues/17116)).

+   当传递一个带有时区信息的 `origin=` kwarg 给 `to_datetime()` 时，现在会引发一个更具信息性的 `ValueError` 而不是 `TypeError` ([GH 16842](https://github.com/pandas-dev/pandas/issues/16842))

+   当格式包含 `%W` 或 `%U` 而没有包含星期几和日历年时，`to_datetime()` 现在会引发 `ValueError` ([GH 16774](https://github.com/pandas-dev/pandas/issues/16774))

+   在 `read_stata()` 中将非功能性的 `index` 重命名为 `index_col`，以改善 API 一致性（[GH 16342](https://github.com/pandas-dev/pandas/issues/16342)）

+   `DataFrame.drop()` 中的错误导致布尔标签 `False` 和 `True` 在从数值索引中删除索引时分别被视为标签 0 和 1。现在将引发 ValueError 错误（[GH 16877](https://github.com/pandas-dev/pandas/issues/16877)）

+   限制了 `DateOffset` 关键字参数。以前，`DateOffset` 子类允许任意关键字参数，这可能导致意外行为。现在，只有有效的参数将被接受。([GH 17176](https://github.com/pandas-dev/pandas/issues/17176))  ## 弃用

+   `DataFrame.from_csv()` 和 `Series.from_csv()` 已被弃用，推荐使用 `read_csv()`（[GH 4191](https://github.com/pandas-dev/pandas/issues/4191)）

+   `read_excel()` 已弃用 `sheetname`，推荐使用 `sheet_name` 以保持与 `.to_excel()` 的一致性（[GH 10559](https://github.com/pandas-dev/pandas/issues/10559)）

+   `read_excel()` 已弃用 `parse_cols`，推荐使用 `usecols` 以保持与 `read_csv()` 的一致性（[GH 4988](https://github.com/pandas-dev/pandas/issues/4988)）

+   `read_csv()` 已弃用 `tupleize_cols` 参数。列元组将始终转换为 `MultiIndex`（[GH 17060](https://github.com/pandas-dev/pandas/issues/17060)）

+   `DataFrame.to_csv()` 已弃用 `tupleize_cols` 参数。MultiIndex 列将始终以行的形式写入 CSV 文件（[GH 17060](https://github.com/pandas-dev/pandas/issues/17060)）

+   `.take()` 方法中已弃用 `convert` 参数，因为它没有被遵守（[GH 16948](https://github.com/pandas-dev/pandas/issues/16948)）

+   `pd.options.html.border` 已被弃用，推荐使用 `pd.options.display.html.border`（[GH 15793](https://github.com/pandas-dev/pandas/issues/15793)）

+   `SeriesGroupBy.nth()` 已弃用 `True`，推荐使用 `'all'` 作为其关键字参数 `dropna`（[GH 11038](https://github.com/pandas-dev/pandas/issues/11038)）

+   `DataFrame.as_blocks()` 已被弃用，因为这暴露了内部实现（[GH 17302](https://github.com/pandas-dev/pandas/issues/17302)）

+   `pd.TimeGrouper`已被弃用，推荐使用`pandas.Grouper`（[GH 16747](https://github.com/pandas-dev/pandas/issues/16747)）

+   `cdate_range`已被弃用，推荐使用`bdate_range()`，该方法增加了`weekmask`和`holidays`参数，用于构建自定义频率日期范围。更多详情请参阅文档（[GH 17596](https://github.com/pandas-dev/pandas/issues/17596)）

+   在`Series.astype()`中传递`categories`或`ordered`参数已被弃用，推荐传递 CategoricalDtype（[GH 17636](https://github.com/pandas-dev/pandas/issues/17636)）

+   `Series`、`DataFrame`、`Panel`、`SparseSeries`和`SparseDataFrame`上的`.get_value`和`.set_value`已被弃用，推荐使用`.iat[]`或`.at[]`访问器（[GH 15269](https://github.com/pandas-dev/pandas/issues/15269))

+   在`.to_excel(..., columns=)`中传递一个不存在的列已被弃用，并将在未来引发`KeyError`（[GH 17295](https://github.com/pandas-dev/pandas/issues/17295)）

+   在`Series.where()`、`Series.mask()`、`DataFrame.where()`、`DataFrame.mask()`中传递`raise_on_error`参数已被弃用，推荐使用`errors=`（[GH 14968](https://github.com/pandas-dev/pandas/issues/14968)）

+   使用`DataFrame.rename_axis()`和`Series.rename_axis()`来更改索引或列*标签*已被弃用，推荐使用`.rename`。`rename_axis`仍可用于更改索引或列的名称（[GH 17833](https://github.com/pandas-dev/pandas/issues/17833)）

+   `reindex_axis()`已被弃用，推荐使用`reindex()`。更多详情请参阅这里（[GH 17833](https://github.com/pandas-dev/pandas/issues/17833)）

### Series.select 和 DataFrame.select

`Series.select()`和`DataFrame.select()`方法已被弃用，推荐使用`df.loc[labels.map(crit)]`（[GH 12401](https://github.com/pandas-dev/pandas/issues/12401)）

```py
In [58]: df = pd.DataFrame({'A': [1, 2, 3]}, index=['foo', 'bar', 'baz']) 
```

```py
In [3]: df.select(lambda x: x in ['bar', 'baz'])
FutureWarning: select is deprecated and will be removed in a future release. You can use .loc[crit] as a replacement
Out[3]:
 A
bar  2
baz  3 
```

```py
In [59]: df.loc[df.index.map(lambda x: x in ['bar', 'baz'])]
Out[59]: 
 A
bar  2
baz  3

[2 rows x 1 columns] 
```  ### Series.argmax 和 Series.argmin

`Series.argmax()`和`Series.argmin()`的行为已被弃用，取而代之的是`Series.idxmax()`和`Series.idxmin()`，分别（[GH 16830](https://github.com/pandas-dev/pandas/issues/16830)）。

为了与 NumPy 数组兼容，`pd.Series`实现了`argmax`和`argmin`。自 pandas 0.13.0 以来，`argmax`已成为`pandas.Series.idxmax()`的别名，`argmin`已成为`pandas.Series.idxmin()`的别名。它们返回*标签*的最大值或最小值，而不是*位置*。

我们已弃用了`Series.argmax`和`Series.argmin`的当前行为。使用任何一个将发出`FutureWarning`。如果您想要最大值的标签，请使用`Series.idxmax()`。如果您想要最大值的位置，请使用`Series.values.argmax()`。最小值同理。在未来的版本中，`Series.argmax`和`Series.argmin`将返回最大值或最小值的位置。##移除之前版本的弃用/更改

+   `read_excel()`已放弃`has_index_names`参数（[GH 10967](https://github.com/pandas-dev/pandas/issues/10967)）。

+   `pd.options.display.height`配置已被放弃（[GH 3663](https://github.com/pandas-dev/pandas/issues/3663)）。

+   `pd.options.display.line_width`配置已被放弃（[GH 2881](https://github.com/pandas-dev/pandas/issues/2881)）。

+   `pd.options.display.mpl_style`配置已被放弃（[GH 12190](https://github.com/pandas-dev/pandas/issues/12190)）。

+   `Index`已放弃`.sym_diff()`方法，取而代之的是`.symmetric_difference()`（[GH 12591](https://github.com/pandas-dev/pandas/issues/12591)）。

+   `Categorical`已放弃`.order()`和`.sort()`方法，取而代之的是`.sort_values()`（[GH 12882](https://github.com/pandas-dev/pandas/issues/12882)）。

+   `eval()`和`DataFrame.eval()`已将`inplace`的默认值从`None`更改为`False`（[GH 11149](https://github.com/pandas-dev/pandas/issues/11149)）。

+   函数`get_offset_name`已被放弃，取而代之的是偏移量的`.freqstr`属性（[GH 11834](https://github.com/pandas-dev/pandas/issues/11834)）。

+   pandas 不再测试与使用 pandas < 0.11 创建的 hdf5 文件的兼容性（[GH 17404](https://github.com/pandas-dev/pandas/issues/17404))。  ## 性能改进

+   改进了实例化`SparseDataFrame`的性能（[GH 16773](https://github.com/pandas-dev/pandas/issues/16773))

+   `Series.dt`不再执行频率推断，在访问属性时速度大幅提升（[GH 17210](https://github.com/pandas-dev/pandas/issues/17210))

+   通过不实现值来改进`set_categories()`的性能（[GH 17508](https://github.com/pandas-dev/pandas/issues/17508))

+   `Timestamp.microsecond`在属性访问时不再重新计算（[GH 17331](https://github.com/pandas-dev/pandas/issues/17331))

+   改进了对已经是分类 dtype 的数据的`CategoricalIndex`的性能（[GH 17513](https://github.com/pandas-dev/pandas/issues/17513))

+   通过使用`RangeIndex`属性执行计算来改进`RangeIndex.min()`和`RangeIndex.max()`的性能（[GH 17607](https://github.com/pandas-dev/pandas/issues/17607))  ## 文档更改

+   几个`NaT`方法的文档字符串（例如`NaT.ctime()`）是不正确的（[GH 17327](https://github.com/pandas-dev/pandas/issues/17327))

+   文档已删除并清理了对版本 < v0.17 的引用（[GH 17442](https://github.com/pandas-dev/pandas/issues/17442), [GH 17442](https://github.com/pandas-dev/pandas/issues/17442), [GH 17404](https://github.com/pandas-dev/pandas/issues/17404) & [GH 17504](https://github.com/pandas-dev/pandas/issues/17504))  ## Bug 修复

### 转换

+   修复了使用`int`对日期时间数据进行赋值时可能错误地转换为日期时间数据的错误（[GH 14145](https://github.com/pandas-dev/pandas/issues/14145))

+   修复了使用`np.ndarray`和`float64` dtype 的`int64`数据进行赋值时可能保留`int64` dtype 的错误（[GH 14001](https://github.com/pandas-dev/pandas/issues/14001))

+   修复了`IntervalIndex.is_non_overlapping_monotonic`的返回类型，以便与类似���性/方法保持一致为 Python `bool`。之前返回的是`numpy.bool_`。（[GH 17237](https://github.com/pandas-dev/pandas/issues/17237))

+   当间隔两端闭合且在一个点重叠时，修复了`IntervalIndex.is_non_overlapping_monotonic`的错误（[GH 16560](https://github.com/pandas-dev/pandas/issues/16560))

+   在`inplace=True`且`value`为字典时，修复了`Series.fillna()`返回帧的错误（[GH 16156](https://github.com/pandas-dev/pandas/issues/16156))

+   在本地化到时区时，`Timestamp.weekday_name`返回基于 UTC 的星期几名称存在错误（[GH 17354](https://github.com/pandas-dev/pandas/issues/17354)）

+   在处理夏令时变化时，`Timestamp.replace`存在错误（[GH 15683](https://github.com/pandas-dev/pandas/issues/15683)）

+   在构建和计算`Timedelta`时存在错误，不会传播`Overflow`异常（[GH 17367](https://github.com/pandas-dev/pandas/issues/17367)）

+   当传递扩展类型类（`DatetimeTZDtype`，`CategoricalDtype`）而不是实例时，`astype()`转换为对象 dtype 时存在错误。现在当传递类时会引发`TypeError`（[GH 17780](https://github.com/pandas-dev/pandas/issues/17780)）

+   在`errors='coerce'`时，修复了`to_numeric()`中元素不始终被强制转换为数值的错误（[GH 17007](https://github.com/pandas-dev/pandas/issues/17007), [GH 17125](https://github.com/pandas-dev/pandas/issues/17125)）

+   在 Windows 上，修复了`DataFrame`和`Series`构造函数中将`range`对象转换为`int32`而不是`int64`的错误（[GH 16804](https://github.com/pandas-dev/pandas/issues/16804)）

### 索引

+   当使用空切片调用时（例如`df.iloc[:]`），`.iloc`和`.loc`索引器返回原始对象的浅拷贝。以前它们返回原始对象。（[GH 13873](https://github.com/pandas-dev/pandas/issues/13873)）

+   当在未排序的`MultiIndex`上调用时，`loc`索引器现在只有在非排序级别上使用正确的切片时才会引发`UnsortedIndexError`（[GH 16734](https://github.com/pandas-dev/pandas/issues/16734)）。

+   修复了 0.20.3 版本中使用字符串对`TimedeltaIndex`进行索引时的回归错误（[GH 16896](https://github.com/pandas-dev/pandas/issues/16896)）

+   修复了`TimedeltaIndex.get_loc()`对`np.timedelta64`输入的处理（[GH 16909](https://github.com/pandas-dev/pandas/issues/16909)）

+   在`ascending`参数是一个列表但未指定所有级别或级别顺序不同的情况下，修复了`MultiIndex.sort_index()`的排序问题（[GH 16934](https://github.com/pandas-dev/pandas/issues/16934)）

+   修复了使用`np.inf`进行索引时引发`OverflowError`的错误（[GH 16957](https://github.com/pandas-dev/pandas/issues/16957)）

+   在重新索引时，修复了对空`CategoricalIndex`的错误（[GH 16770](https://github.com/pandas-dev/pandas/issues/16770)）

+   修复了`DataFrame.loc`在使用对齐和带时区的`DatetimeIndex`时的问题（[GH 16889](https://github.com/pandas-dev/pandas/issues/16889)）

+   当使用较旧版本的 numpy 将索引或系列传递给`.iloc`时，避免了`IndexError`（[GH 17193](https://github.com/pandas-dev/pandas/issues/17193)）

+   允许在 Python 2 中的多级列中使用 Unicode 空字符串作为占位符（[GH 17099](https://github.com/pandas-dev/pandas/issues/17099)）

+   Bug in `.iloc` 当在`MultiIndex`上使用就地加法或赋值和整数索引器时，导致从错误的索引读取和写入（[GH 17148](https://github.com/pandas-dev/pandas/issues/17148)）

+   Bug in `.isin()` 中检查空`Series`对象成员资格时引发错误（[GH 16991](https://github.com/pandas-dev/pandas/issues/16991)）

+   Bug in `CategoricalIndex` 重新索引中指定包含重复项的索引未被尊重（[GH 17323](https://github.com/pandas-dev/pandas/issues/17323)）

+   Bug in `RangeIndex` 与负步长的交集中出现的问题（[GH 17296](https://github.com/pandas-dev/pandas/issues/17296)）

+   Bug in `IntervalIndex` 在对非重叠单调递减索引的包含右端点执行标量查找时失败（[GH 16417](https://github.com/pandas-dev/pandas/issues/16417)，[GH 17271](https://github.com/pandas-dev/pandas/issues/17271)）

+   Bug in `DataFrame.first_valid_index()` 和 `DataFrame.last_valid_index()` 当没有有效条目时（[GH 17400](https://github.com/pandas-dev/pandas/issues/17400)）

+   Bug in `Series.rename()` 被调用时，使用可调用对象时，错误地改变了`Series`的名称，而不是`Index`的名称。（[GH 17407](https://github.com/pandas-dev/pandas/issues/17407)）

+   Bug in `String.str_get()` 当使用负索引时，引发`IndexError`而不是插入 NaNs。（[GH 17704](https://github.com/pandas-dev/pandas/issues/17704)）

### IO

+   Bug in `read_hdf()` 从`fixed`格式 HDFStore 读取时，读取带时区的索引时出现问题（[GH 17618](https://github.com/pandas-dev/pandas/issues/17618)）

+   Bug in `read_csv()` 中存在的问题，列未被彻底去重复（[GH 17060](https://github.com/pandas-dev/pandas/issues/17060)）

+   Bug in `read_csv()` 中指定的列名未被彻底去重复（[GH 17095](https://github.com/pandas-dev/pandas/issues/17095)）

+   Bug in `read_csv()` 中存在的问题，头部参数的非整数值生成了一个无用/无关的错误信息（[GH 16338](https://github.com/pandas-dev/pandas/issues/16338)）

+   `read_csv()` 中的错误，异常处理中的内存管理问题，在特定条件下，会导致解释器崩溃（[GH 14696](https://github.com/pandas-dev/pandas/issues/14696)，[GH 16798](https://github.com/pandas-dev/pandas/issues/16798)）

+   `read_csv()` 中的错误，当使用 `low_memory=False` 时，大小至少为 2GB 的至少一列的 CSV 会不正确地引发 `MemoryError`（[GH 16798](https://github.com/pandas-dev/pandas/issues/16798)）

+   `read_csv()` 中的错误，当使用单元素列表 `header` 调用时，将返回所有 NaN 值的 DataFrame（[GH 7757](https://github.com/pandas-dev/pandas/issues/7757)）

+   `DataFrame.to_csv()` 中的错误，默认为 Python 3 中的 'ascii' 编码，而不是 'utf-8'（[GH 17097](https://github.com/pandas-dev/pandas/issues/17097)）

+   `read_stata()` 存在的错误，当使用迭代器时无法读取值标签（[GH 16923](https://github.com/pandas-dev/pandas/issues/16923)）

+   `read_stata()` 中的错误，索引未设置（[GH 16342](https://github.com/pandas-dev/pandas/issues/16342)）

+   `read_html()` 中的错误，当在多个线程中运行时，导入检查失败（[GH 16928](https://github.com/pandas-dev/pandas/issues/16928)）

+   `read_csv()` 中的错误，自动分隔符检测导致遇到坏行时引发 `TypeError` 而不是正确的错误消息（[GH 13374](https://github.com/pandas-dev/pandas/issues/13374)）

+   `DataFrame.to_html()` 中的错误，当 `notebook=True` 时，具有命名索引或非 MultiIndex 索引的 DataFrame 的列或行标签具有不希望的水平或垂直对齐（[GH 16792](https://github.com/pandas-dev/pandas/issues/16792)）

+   `DataFrame.to_html()` 中的错误，`justify` 参数没有验证（[GH 17527](https://github.com/pandas-dev/pandas/issues/17527)）

+   `HDFStore.select()` 中的错误，读取包含 VLArray 的连续混合数据表时出现问题（[GH 17021](https://github.com/pandas-dev/pandas/issues/17021)）

+   在 `to_json()` 中，多种条件（包括具有不可打印符号的对象，具有深度递归的对象，标签过长等）导致 segfaults 而不是引发适当的异常。([GH 14256](https://github.com/pandas-dev/pandas/issues/14256))

### 绘图

+   绘图方法中使用 `secondary_y` 和 `fontsize` 设置次要轴字体大小时出现的错误（[GH 12565](https://github.com/pandas-dev/pandas/issues/12565)）

+   在绘制 `timedelta` 和 `datetime` 数据类型的图时出现的错误，位于 y 轴上。([GH 16953](https://github.com/pandas-dev/pandas/issues/16953))

+   现在，在计算 xlims 时，线图不再假设 x 数据是单调的，即使 x 数据未排序，它们现在也会显示整个线。([GH 11310](https://github.com/pandas-dev/pandas/issues/11310), [GH 11471](https://github.com/pandas-dev/pandas/issues/11471))

+   在 matplotlib 2.0.0 及以上版本中，线图的 x 轴限制的计算由 matplotlib 完成，因此应用了其新的默认设置。([GH 15495](https://github.com/pandas-dev/pandas/issues/15495))

+   在 `Series.plot.bar` 或 `DataFrame.plot.bar` 中，`y` 参数不遵循用户传递的 `color` 参数。([GH 16822](https://github.com/pandas-dev/pandas/issues/16822))

+   在使用随机颜色时，导致 `plotting.parallel_coordinates` 重置随机种子的错误。([GH 17525](https://github.com/pandas-dev/pandas/issues/17525))

### GroupBy/resample/rolling

+   在 `DataFrame.resample(...).size()` 中，一个空的 `DataFrame` 没有返回一个 `Series`。([GH 14962](https://github.com/pandas-dev/pandas/issues/14962))

+   在 `infer_freq()` 中，导致工作日之间存在 2 天间隔的索引错误地被推断为工作日频率。([GH 16624](https://github.com/pandas-dev/pandas/issues/16624))

+   在 `.rolling(...).quantile()` 中错误地使用了与 `Series.quantile()` 和 `DataFrame.quantile()` 不同的默认设置（[GH 9413](https://github.com/pandas-dev/pandas/issues/9413), [GH 16211](https://github.com/pandas-dev/pandas/issues/16211)）

+   在 `groupby.transform()` 中，布尔类型被强制转换为浮点型。([GH 16875](https://github.com/pandas-dev/pandas/issues/16875))

+   在 `Series.resample(...).apply()` 中，一个空的 `Series` 修改了源索引并且没有返回一个 `Series` 的名称。([GH 14313](https://github.com/pandas-dev/pandas/issues/14313))

+   在具有 `DatetimeIndex` 的 `DataFrame` 上使用 `.rolling(...).apply(...)` 时，`window` 是一个时间增量可转换的情况下，以及 `min_periods >= 1` 时出现的错误（[GH 15305](https://github.com/pandas-dev/pandas/issues/15305)）

+   在 `DataFrame.groupby` 中，当键的数量等于分组轴上的元素数量时，索引和列键没有被正确识别。([GH 16859](https://github.com/pandas-dev/pandas/issues/16859))

+   `groupby.nunique()` 中的 Bug，与 `TimeGrouper` 结合使用时无法正确处理 `NaT`（[GH 17575](https://github.com/pandas-dev/pandas/issues/17575)）

+   `DataFrame.groupby` 中的 Bug，在从 `MultiIndex` 进行单层选择时意外地进行排序（[GH 17537](https://github.com/pandas-dev/pandas/issues/17537)）

+   `DataFrame.groupby` 中的 Bug，在使用 `Grouper` 对象覆盖模糊列名时会引发虚假警告（[GH 17383](https://github.com/pandas-dev/pandas/issues/17383)）

+   `TimeGrouper` 中的 Bug，在作为列表和标量传递时存在差异（[GH 17530](https://github.com/pandas-dev/pandas/issues/17530)）

### Sparse

+   `SparseSeries` 中的 Bug，当传入字典作为数据时会引发 `AttributeError`（[GH 16905](https://github.com/pandas-dev/pandas/issues/16905)）

+   `SparseDataFrame.fillna()` 中的 Bug，在从 SciPy 稀疏矩阵实例化的框架中未填充所有 NaNs（[GH 16112](https://github.com/pandas-dev/pandas/issues/16112)）

+   `SparseSeries.unstack()` 和 `SparseDataFrame.stack()` 中的 Bug（[GH 16614](https://github.com/pandas-dev/pandas/issues/16614), [GH 15045](https://github.com/pandas-dev/pandas/issues/15045)）

+   `make_sparse()` 中的 Bug，在数组 `dtype` 为 `object` 时，将两个数字/布尔数据（具有相同位）视为相同（[GH 17574](https://github.com/pandas-dev/pandas/issues/17574)）

+   `SparseArray.all()` 和 `SparseArray.any()` 现在已实现以处理 `SparseArray`，这些功能以前被使用但未实现（[GH 17570](https://github.com/pandas-dev/pandas/issues/17570)）

### 重塑

+   使用非唯一的 `PeriodIndex` 进行连接/合并会引发 `TypeError`（[GH 16871](https://github.com/pandas-dev/pandas/issues/16871)）

+   在 `crosstab()` 中存在 Bug，其中非对齐的整数系列被转换为浮点数（[GH 17005](https://github.com/pandas-dev/pandas/issues/17005)）

+   与日期时间类别数据类型合并存在 Bug，错误地引发了 `TypeError`（[GH 16900](https://github.com/pandas-dev/pandas/issues/16900)）

+   在大型对象系列和大型比较数组上使用 `isin()` 时存在 Bug（[GH 16012](https://github.com/pandas-dev/pandas/issues/16012)）

+   从 0.20 中的回归修复，`Series.aggregate()` 和 `DataFrame.aggregate()` 再次允许将字典作为返回值（[GH 16741](https://github.com/pandas-dev/pandas/issues/16741)）

+   修复了整数类型输入的结果的 dtype，来自 `pivot_table()` 在调用时使用 `margins=True` 时（[GH 17013](https://github.com/pandas-dev/pandas/issues/17013)）

+   在 `crosstab()` 中出现的 Bug，当传入两个具有相同名称的 `Series` 时引发 `KeyError` ([GH 13279](https://github.com/pandas-dev/pandas/issues/13279))

+   `Series.argmin()`，`Series.argmax()`，以及它们在 `DataFrame` 和 groupby 对象上的对应函数，在包含无穷值的浮点数据上能够正常工作 ([GH 13595](https://github.com/pandas-dev/pandas/issues/13595)).

+   在 `unique()` 中出现的 Bug，检查字符串元组时引发 `TypeError` ([GH 17108](https://github.com/pandas-dev/pandas/issues/17108))

+   在 `concat()` 中出现的 Bug，如果结果索引包含不可比较的元素，则其顺序是不可预测的 ([GH 17344](https://github.com/pandas-dev/pandas/issues/17344))

+   修复了在具有 `datetime64` dtype 的 `Series` 上按多个列排序时出现的回归问题，其中包含 `NaT` 值 ([GH 16836](https://github.com/pandas-dev/pandas/issues/16836))

+   在 `pivot_table()` 中出现的 Bug，当 `dropna` 为 `False` 时，结果的列未保留 `columns` 的分类 dtype ([GH 17842](https://github.com/pandas-dev/pandas/issues/17842))

+   在 `DataFrame.drop_duplicates` 中出现的 Bug，当具有非唯一列名时引发 `ValueError` ([GH 17836](https://github.com/pandas-dev/pandas/issues/17836))

+   在 `unstack()` 中出现的 Bug，在一个级别列表上调用时，会丢弃 `fillna` 参数 ([GH 13971](https://github.com/pandas-dev/pandas/issues/13971))

+   `range` 对象与其他类似列表在与 `DataFrame` 对齐时出现的 Bug，导致操作按行而不是按列执行 ([GH 17901](https://github.com/pandas-dev/pandas/issues/17901))

### 数字

+   调用 `.clip()` 时，当 `axis=1` 并且 `threshold` 传入一个类似列表时出现的 Bug；之前会引发 `ValueError` ([GH 15390](https://github.com/pandas-dev/pandas/issues/15390))

+   `Series.clip()` 和 `DataFrame.clip()` 现在将上限和下限参数的 NA 值视为 `None`，而不是引发 `ValueError` ([GH 17276](https://github.com/pandas-dev/pandas/issues/17276))

### 分类

+   在 `Series.isin()` 中出现的 Bug，当与一个分类一起调用时 ([GH 16639](https://github.com/pandas-dev/pandas/issues/16639))

+   当空值和类别造成分类构造函数中的 bug 时，`.categories`会是一个空的`Float64Index`，而不是一个空的具有对象 dtype 的`Index`（[GH 17248](https://github.com/pandas-dev/pandas/issues/17248)）

+   与 Series.cat 中的分类操作 bug，未保留原始 Series 的名称（[GH 17509](https://github.com/pandas-dev/pandas/issues/17509)）

+   `DataFrame.merge()`中的 bug，对于布尔/整数数据类型的分类列失败（[GH 17187](https://github.com/pandas-dev/pandas/issues/17187)）

+   当指定的`categories`是分类类型时，在构建`Categorical`/`CategoricalDtype`时存在 bug，导致错误（[GH 17884](https://github.com/pandas-dev/pandas/issues/17884)）。

### PyPy

+   在`read_csv()`和`usecols=[<unsorted ints>]`以及`read_json()`中与 PyPy 的兼容性（[GH 17351](https://github.com/pandas-dev/pandas/issues/17351)）

+   在必要时将测试拆分为 CPython 和 PyPy 的情况，这凸显了使用`float('nan')`、`np.nan`和`NAT`进行索引匹配的脆弱性（[GH 17351](https://github.com/pandas-dev/pandas/issues/17351)）

+   修复了支持 PyPy 的`DataFrame.memory_usage()`。 PyPy 上的对象没有固定大小，因此使用近似值（[GH 17228](https://github.com/pandas-dev/pandas/issues/17228)）

### 其他

+   一些 inplace 操作符没有被正确包装并在调用时产生了副本的 bug（[GH 12962](https://github.com/pandas-dev/pandas/issues/12962)）

+   `eval()`中的 bug，`inplace`参数被错误处理（[GH 16732](https://github.com/pandas-dev/pandas/issues/16732)）  ## 贡献者

共有 206 人为此版本做出了贡献。 带有“+”符号的人是第一次贡献代码。

+   3553x +

+   Aaron Barber

+   Adam Gleave +

+   Adam Smith +

+   AdamShamlian +

+   Adrian Liaw +

+   Alan Velasco +

+   Alan Yee +

+   Alex B +

+   Alex Lubbock +

+   Alex Marchenko +

+   Alex Rychyk +

+   Amol K +

+   Andreas Winkler

+   Andrew +

+   Andrew 亮

+   André Jonasson +

+   Becky Sweger

+   Berkay +

+   Bob Haffner +

+   Bran Yang

+   Brian Tu +

+   Brock Mendel +

+   Carol Willing +

+   Carter Green +

+   Chankey Pathak +

+   Chris

+   Chris Billington

+   Chris Filo Gorgolewski +

+   Chris Kerr

+   Chris M +

+   Chris Mazzullo +

+   Christian Prinoth

+   Christian Stade-Schuldt

+   Christoph Moehl +

+   DSM

+   Daniel Chen +

+   Daniel Grady

+   Daniel Himmelstein

+   Dave Willmer

+   David Cook

+   David Gwynne

+   David Read +

+   Dillon Niederhut +

+   Douglas Rudd

+   Eric Stein +

+   Eric Wieser +

+   Erik Fredriksen

+   Florian Wilhelm +

+   Floris Kint +

+   禁忌甜甜圈

+   Gabe F +

+   Giftlin +

+   Giftlin Rajaiah +

+   Giulio Pepe +

+   Guilherme Beltramini

+   Guillem Borrell +

+   Hanmin Qin +

+   Hendrik Makait +

+   Hugues Valois

+   Hussain Tamboli +

+   Iva Miholic +

+   Jan Novotný +

+   Jan Rudolph

+   Jean Helie +

+   Jean-Baptiste Schiratti +

+   Jean-Mathieu Deschenes

+   Jeff Knupp +

+   Jeff Reback

+   Jeff Tratner

+   JennaVergeynst

+   JimStearns206

+   Joel Nothman

+   John W. O’Brien

+   Jon Crall +

+   Jon Mease

+   Jonathan J. Helmus +

+   Joris Van den Bossche

+   JosephWagner

+   Juarez Bochi

+   Julian Kuhlmann +

+   Karel De Brabandere

+   Kassandra Keeton +

+   Keiron Pizzey +

+   Keith Webber

+   Kernc

+   Kevin Sheppard

+   Kirk Hansen +

+   Licht Takeuchi +

+   Lucas Kushner +

+   Mahdi Ben Jelloul +

+   Makarov Andrey +

+   Malgorzata Turzanska +

+   Marc Garcia +

+   Margaret Sy +

+   MarsGuy +

+   Matt Bark +

+   Matthew Roeschke

+   Matti Picus

+   Mehmet Ali “Mali” Akmanalp

+   Michael Gasvoda +

+   Michael Penkov +

+   Milo +

+   Morgan Stuart +

+   Morgan243 +

+   Nathan Ford +

+   Nick Eubank

+   Nick Garvey +

+   Oleg Shteynbuk +

+   P-Tillmann +

+   Pankaj Pandey

+   Patrick Luo

+   Patrick O’Melveny

+   Paul Reidy +

+   Paula +

+   Peter Quackenbush

+   Peter Yanovich +

+   Phillip Cloud

+   Pierre Haessig

+   Pietro Battiston

+   Pradyumna Reddy Chinthala

+   Prasanjit Prakash

+   RobinFiveWords

+   Ryan Hendrickson

+   Sam Foo

+   Sangwoong Yoon +

+   Simon Gibbons +

+   SimonBaron

+   Steven Cutting +

+   Sudeep +

+   Sylvia +

+   T N +

+   Telt

+   Thomas A Caswell

+   Tim Swast +

+   Tom Augspurger

+   Tong SHEN

+   Tuan +

+   Utkarsh Upadhyay +

+   Vincent La +

+   Vivek +

+   WANG Aiyong

+   WBare

+   Wes McKinney

+   XF +

+   Yi Liu +

+   Yosuke Nakabayashi +

+   aaron315 +

+   abarber4gh +

+   aernlund +

+   agustín méndez +

+   andymaheshw +

+   ante328 +

+   aviolov +

+   bpraggastis

+   cbertinato +

+   cclauss +

+   chernrick

+   chris-b1

+   dkamm +

+   dwkenefick

+   economy

+   faic +

+   fding253 +

+   gfyoung

+   guygoldberg +

+   hhuuggoo +

+   huashuai +

+   ian

+   iulia +

+   jaredsnyder

+   jbrockmendel +

+   jdeschenes

+   jebob +

+   jschendel +

+   keitakurita

+   kernc +

+   kiwirob +

+   kjford

+   linebp

+   lloydkirk

+   louispotok +

+   majiang +

+   manikbhandari +

+   margotphoenix +

+   matthiashuschle +

+   mattip

+   mjlove12 +

+   nmartensen +

+   pandas-docs-bot +

+   parchd-1 +

+   philipphanemann +

+   rdk1024 +

+   reidy-p +

+   ri938

+   ruiann +

+   rvernica +

+   s-weigand +

+   scotthavard92 +

+   skwbc +

+   step4me +

+   tobycheese +

+   topper-123 +

+   tsdlovell

+   ysau +

+   zzgao +  ## 新功能

### 与 Apache Parquet 文件格式的集成

与[Apache Parquet](https://parquet.apache.org/)的集成，包括一个新的顶级`read_parquet()`和`DataFrame.to_parquet()`方法，参见此处（[GH 15838](https://github.com/pandas-dev/pandas/issues/15838)，[GH 17438](https://github.com/pandas-dev/pandas/issues/17438)）。

[Apache Parquet](https://parquet.apache.org/)提供了一种跨语言的二进制文件格式，用于高效地读取和写入数据帧。Parquet 旨在忠实地序列化和反序列化`DataFrame`，支持所有 pandas 的数据类型，包括带时区的日期时间等扩展数据类型。

此功能取决于[pyarrow](http://arrow.apache.org/docs/python/)或[fastparquet](https://fastparquet.readthedocs.io/en/latest/)库。有关更多详细信息，请参阅关于 Parquet 的 IO 文档（原文已失效）。### 方法`infer_objects`类型转换

`DataFrame.infer_objects()`和`Series.infer_objects()`方法已添加以执行对象列的 dtype 推断，替换了已弃用的`convert_objects`方法的部分功能。有关更多详细信息，请参阅此处的文档（原文已失效）（[GH 11221](https://github.com/pandas-dev/pandas/issues/11221)）。

此方法仅对对象列执行软转换，将 Python 对象转换为本机类型，但不执行任何强制转换。例如：

```py
In [1]: df = pd.DataFrame({'A': [1, 2, 3],
 ...:                   'B': np.array([1, 2, 3], dtype='object'),
 ...:                   'C': ['1', '2', '3']})
 ...: 

In [2]: df.dtypes
Out[2]: 
A     int64
B    object
C    object
Length: 3, dtype: object

In [3]: df.infer_objects().dtypes
Out[3]: 
A     int64
B     int64
C    object
Length: 3, dtype: object 
```

请注意，列`'C'`未转换 - 只有标量数值类型将被转换为新类型。其他类型的转换应使用`to_numeric()`函数（或`to_datetime()`，`to_timedelta()`）完成。

```py
In [4]: df = df.infer_objects()

In [5]: df['C'] = pd.to_numeric(df['C'], errors='coerce')

In [6]: df.dtypes
Out[6]: 
A    int64
B    int64
C    int64
Length: 3, dtype: object 
```### 当尝试创建列时改进了警告。

新用户经常困惑于`DataFrame`实例上的列操作与属性访问之间的关系（[GH 7175](https://github.com/pandas-dev/pandas/issues/7175)）。这种困惑的一个具体实例是尝试通过在`DataFrame`上设置属性来创建新列：

```py
In [1]: df = pd.DataFrame({'one': [1., 2., 3.]})
In [2]: df.two = [4, 5, 6] 
```

这不会引发任何明显的异常，但也不会创建新列：

```py
In [3]: df
Out[3]:
 one
0  1.0
1  2.0
2  3.0 
```

将类似列表的数据结构设置为新属性现在会引发`UserWarning`，提示可能出现意外行为。请参阅属性访问。### 方法`drop`现在还接受索引/列关键字。

`drop()`方法增加了`index`/`columns`关键字，作为指定`axis`的替代方案。这类似于`reindex`的行为（[GH 12392](https://github.com/pandas-dev/pandas/issues/12392)）。

例如：

```py
In [7]: df = pd.DataFrame(np.arange(8).reshape(2, 4),
 ...:                  columns=['A', 'B', 'C', 'D'])
 ...: 

In [8]: df
Out[8]: 
 A  B  C  D
0  0  1  2  3
1  4  5  6  7

[2 rows x 4 columns]

In [9]: df.drop(['B', 'C'], axis=1)
Out[9]: 
 A  D
0  0  3
1  4  7

[2 rows x 2 columns]

# the following is now equivalent
In [10]: df.drop(columns=['B', 'C'])
Out[10]: 
 A  D
0  0  3
1  4  7

[2 rows x 2 columns] 
```### 方法`rename`，`reindex`现在还接受轴关键字。

`DataFrame.rename()` 和 `DataFrame.reindex()` 方法现已添加 `axis` 关键字，用于指定要使用操作的轴（[GH 12392](https://github.com/pandas-dev/pandas/issues/12392)）。

这是 `rename`：

```py
In [11]: df = pd.DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})

In [12]: df.rename(str.lower, axis='columns')
Out[12]: 
 a  b
0  1  4
1  2  5
2  3  6

[3 rows x 2 columns]

In [13]: df.rename(id, axis='index')
Out[13]: 
 A  B
140682504175824  1  4
140682504175856  2  5
140682504175888  3  6

[3 rows x 2 columns] 
```

并且 `reindex`：

```py
In [14]: df.reindex(['A', 'B', 'C'], axis='columns')
Out[14]: 
 A  B   C
0  1  4 NaN
1  2  5 NaN
2  3  6 NaN

[3 rows x 3 columns]

In [15]: df.reindex([0, 1, 3], axis='index')
Out[15]: 
 A    B
0  1.0  4.0
1  2.0  5.0
3  NaN  NaN

[3 rows x 2 columns] 
```

“index, columns” 样式仍然像以前一样工作。

```py
In [16]: df.rename(index=id, columns=str.lower)
Out[16]: 
 a  b
140682504175824  1  4
140682504175856  2  5
140682504175888  3  6

[3 rows x 2 columns]

In [17]: df.reindex(index=[0, 1, 3], columns=['A', 'B', 'C'])
Out[17]: 
 A    B   C
0  1.0  4.0 NaN
1  2.0  5.0 NaN
3  NaN  NaN NaN

[3 rows x 3 columns] 
```

我们*强烈*鼓励使用命名参数，以避免在使用任何一种样式时产生混淆。### 用于指定分类的 `CategoricalDtype`

`pandas.api.types.CategoricalDtype` 已添加到公共 API 并扩展以包括 `categories` 和 `ordered` 属性。`CategoricalDtype` 可用于指定数组的类别集和顺序性，与数据独立。例如，将字符串数据转换为 `Categorical` 时可以很有用（[GH 14711](https://github.com/pandas-dev/pandas/issues/14711)，[GH 15078](https://github.com/pandas-dev/pandas/issues/15078)，[GH 16015](https://github.com/pandas-dev/pandas/issues/16015)，[GH 17643](https://github.com/pandas-dev/pandas/issues/17643)）：

```py
In [18]: from pandas.api.types import CategoricalDtype

In [19]: s = pd.Series(['a', 'b', 'c', 'a'])  # strings

In [20]: dtype = CategoricalDtype(categories=['a', 'b', 'c', 'd'], ordered=True)

In [21]: s.astype(dtype)
Out[21]: 
0    a
1    b
2    c
3    a
Length: 4, dtype: category
Categories (4, object): ['a' < 'b' < 'c' < 'd'] 
```

一个值得特别提及的地方在 `read_csv()` 中。以前，使用 `dtype={'col': 'category'}`，返回的值和类别总是字符串。

```py
In [22]: data = 'A,B\na,1\nb,2\nc,3'

In [23]: pd.read_csv(StringIO(data), dtype={'B': 'category'}).B.cat.categories
Out[23]: Index(['1', '2', '3'], dtype='object') 
```

注意“object” dtype。

有了所有数字、日期时间或时间增量的 `CategoricalDtype`，我们可以自动转换为正确的类型。

```py
In [24]: dtype = {'B': CategoricalDtype([1, 2, 3])}

In [25]: pd.read_csv(StringIO(data), dtype=dtype).B.cat.categories
Out[25]: Index([1, 2, 3], dtype='int64') 
```

值已正确解释为整数。

`Categorical`、`CategoricalIndex` 或具有分类类型的 `Series` 的 `.dtype` 属性现在将返回 `CategoricalDtype` 的实例。虽然 repr 已经改变，`str(CategoricalDtype())` 仍然是字符串 `'category'`。我们将在此提醒用户，检测分类数据的*首选*方式是使用`pandas.api.types.is_categorical_dtype()`，而不是 `str(dtype) == 'category'`。

更多信息请参阅 CategoricalDtype 文档。### `GroupBy` 对象现在具有 `pipe` 方法

`GroupBy` 对象现在具有 `pipe` 方法，类似于 `DataFrame` 和 `Series` 上的方法，允许以清晰、可读的语法组合接受 `GroupBy` 的函数。([GH 17871](https://github.com/pandas-dev/pandas/issues/17871))

对于一个将 `.groupby` 和 `.pipe` 结合起来的具体示例，请想象一个具有店铺、产品、收入和销售数量列的 DataFrame。我们想要对每个店铺和每个产品进行分组计算*价格*（即收入/数量）。我们可以通过多步操作来实现这个目标，但是使用管道来表达会使代码更易读。

首先我们设置数据：

```py
In [26]: import numpy as np

In [27]: n = 1000

In [28]: df = pd.DataFrame({'Store': np.random.choice(['Store_1', 'Store_2'], n),
 ....:                   'Product': np.random.choice(['Product_1',
 ....:                                                'Product_2',
 ....:                                                'Product_3'
 ....:                                                ], n),
 ....:                   'Revenue': (np.random.random(n) * 50 + 10).round(2),
 ....:                   'Quantity': np.random.randint(1, 10, size=n)})
 ....: 

In [29]: df.head(2)
Out[29]: 
 Store    Product  Revenue  Quantity
0  Store_2  Product_2    32.09         7
1  Store_1  Product_3    14.20         1

[2 rows x 4 columns] 
```

现在，要找到每个商店/产品的价格，我们可以简单地执行：

```py
In [30]: (df.groupby(['Store', 'Product'])
 ....:   .pipe(lambda grp: grp.Revenue.sum() / grp.Quantity.sum())
 ....:   .unstack().round(2))
 ....: 
Out[30]: 
Product  Product_1  Product_2  Product_3
Store 
Store_1       6.73       6.72       7.14
Store_2       7.59       6.98       7.23

[2 rows x 3 columns] 
```

查看更多内容，请参阅文档。### `Categorical.rename_categories` 接受类似字典的对象

`rename_categories()` 现在接受类似字典的参数作为 `new_categories`。先前的类别将在字典的键中查找并进行替换。与 `DataFrame.rename()` 中的缺失和额外键的行为相同。

```py
In [31]: c = pd.Categorical(['a', 'a', 'b'])

In [32]: c.rename_categories({"a": "eh", "b": "bee"})
Out[32]: 
['eh', 'eh', 'bee']
Categories (2, object): ['eh', 'bee'] 
```

警告

为了帮助升级 pandas，`rename_categories` 将 `Series` 视为类似列表的对象。通常，Series 被视为类似字典的对象（例如在 `.rename`、`.map` 中）。在未来的 pandas 版本中，`rename_categories` 将会更改为将其视为类似字典的对象。请遵循警告消息中的建议编写具有未来兼容性的代码。

```py
In [33]: c.rename_categories(pd.Series([0, 1], index=['a', 'c']))
FutureWarning: Treating Series 'new_categories' as a list-like and using the values.
In a future version, 'rename_categories' will treat Series like a dictionary.
For dict-like, use 'new_categories.to_dict()'
For list-like, use 'new_categories.values'.
Out[33]:
[0, 0, 1]
Categories (2, int64): [0, 1] 
```  ### 其他增强功能

#### 新函数或方法

+   `Resampler.nearest()` 被添加以支持最近邻上采样（[GH 17496](https://github.com/pandas-dev/pandas/issues/17496)）。

+   `Index` 现在支持 `to_frame` 方法（[GH 15230](https://github.com/pandas-dev/pandas/issues/15230)）。

#### 新关键字

+   在 `infer_dtype()` 中添加了一个 `skipna` 参数，以支持在存在缺失值时进行类型推断（[GH 17059](https://github.com/pandas-dev/pandas/issues/17059)）。

+   `Series.to_dict()` 和 `DataFrame.to_dict()` 现在支持 `into` 关键字，允许您指定要返回的 `collections.Mapping` 子类。默认为 `dict`，向后兼容。([GH 16122](https://github.com/pandas-dev/pandas/issues/16122))

+   `Series.set_axis()` 和 `DataFrame.set_axis()` 现在支持 `inplace` 参数。([GH 14636](https://github.com/pandas-dev/pandas/issues/14636))

+   `Series.to_pickle()` 和 `DataFrame.to_pickle()` 增加了一个 `protocol` 参数 ([GH 16252](https://github.com/pandas-dev/pandas/issues/16252))。默认情况下，该参数设置为[HIGHEST_PROTOCOL](https://docs.python.org/3/library/pickle.html#data-stream-format)

+   `read_feather()` 增加了 `nthreads` 参数，用于多线程操作 ([GH 16359](https://github.com/pandas-dev/pandas/issues/16359))

+   `DataFrame.clip()` 和 `Series.clip()` 增加了一个 `inplace` 参数。([GH 15388](https://github.com/pandas-dev/pandas/issues/15388))

+   `crosstab()` 增加了一个 `margins_name` 参数，用于定义当 `margins=True` 时包含总计的行/列的名称。([GH 15972](https://github.com/pandas-dev/pandas/issues/15972))

+   `read_json()` 现在接受一个 `chunksize` 参数，当 `lines=True` 时可用。如果传递了 `chunksize`，read_json 现在将返回一个迭代器，每次迭代读取 `chunksize` 行。([GH 17048](https://github.com/pandas-dev/pandas/issues/17048))

+   `read_json()` 和 `to_json()` 现在接受一个 `compression` 参数，允许它们透明地处理压缩文件。 ([GH 17798](https://github.com/pandas-dev/pandas/issues/17798))

#### 各种增强

+   提高了 pandas 的导入时间约 2.25 倍。([GH 16764](https://github.com/pandas-dev/pandas/issues/16764))

+   对大多数读取器（例如 `read_csv()`）和写入器（例如 `DataFrame.to_csv()`）添加了对[PEP 519 – 添加文件系统路径协议](https://www.python.org/dev/peps/pep-0519/)的支持。 ([GH 13823](https://github.com/pandas-dev/pandas/issues/13823)).

+   向 `pd.HDFStore`、`pd.ExcelFile` 和 `pd.ExcelWriter` 添加了一个 `__fspath__` 方法，以正确处理文件系统路径协议 ([GH 13823](https://github.com/pandas-dev/pandas/issues/13823)).

+   `merge()` 的 `validate` 参数现在检查合并是一对一、一对多、多对一还是多对多。如果发现合并不符合指定的合并类型，将引发 `MergeError` 类型的异常。更多信息，请参见这里 ([GH 16270](https://github.com/pandas-dev/pandas/issues/16270))

+   增加对[PEP 518](https://www.python.org/dev/peps/pep-0518/) (`pyproject.toml`)的构建系统支持 ([GH 16745](https://github.com/pandas-dev/pandas/issues/16745))

+   `RangeIndex.append()` 现在在可能的情况下返回一个 `RangeIndex` 对象 ([GH 16212](https://github.com/pandas-dev/pandas/issues/16212))

+   `Series.rename_axis()` 和 `DataFrame.rename_axis()` 在 `inplace=True` 的情况下，重命名轴时返回 `None`。([GH 15704](https://github.com/pandas-dev/pandas/issues/15704))

+   `api.types.infer_dtype()` 现在推断小数。([GH 15690](https://github.com/pandas-dev/pandas/issues/15690))

+   `DataFrame.select_dtypes()` 现在接受标量值作为包含/排除，以及类似列表的值。([GH 16855](https://github.com/pandas-dev/pandas/issues/16855))

+   `date_range()` 现在接受‘YS’作为年初的别名，与‘AS’一起。([GH 9313](https://github.com/pandas-dev/pandas/issues/9313))

+   `date_range()` 现在接受‘Y’作为年末的别名，与‘A’一起。([GH 9313](https://github.com/pandas-dev/pandas/issues/9313))

+   `DataFrame.add_prefix()` 和 `DataFrame.add_suffix()` 现在接受包含‘%’字符的字符串。([GH 17151](https://github.com/pandas-dev/pandas/issues/17151))

+   从路径样式对象（例如 `pathlib.Path`）推断压缩的读/写方法（`read_csv()`, `read_table()`, `read_pickle()` 和 `to_pickle()`）现在可以推断压缩。([GH 17206](https://github.com/pandas-dev/pandas/issues/17206))

+   `read_sas()` 现在可以识别 SAS7BDAT 文件中最常用的日期（时间）格式的更多内容。([GH 15871](https://github.com/pandas-dev/pandas/issues/15871))

+   `DataFrame.items()` 和 `Series.items()` 现在在 Python 2 和 3 中都存在，并且在所有情况下都是惰性的。([GH 13918](https://github.com/pandas-dev/pandas/issues/13918), [GH 17213](https://github.com/pandas-dev/pandas/issues/17213))

+   `pandas.io.formats.style.Styler.where()` 已实现为 `pandas.io.formats.style.Styler.applymap()` 的一种便利。([GH 17474](https://github.com/pandas-dev/pandas/issues/17474))

+   `MultiIndex.is_monotonic_decreasing()` 已实现。先前在所有情况下返回 `False`。([GH 16554](https://github.com/pandas-dev/pandas/issues/16554))

+   `read_excel()` 如果未安装 `xlrd`，将引发 `ImportError` 并显示更好的消息。([GH 17613](https://github.com/pandas-dev/pandas/issues/17613))

+   `DataFrame.assign()` 将保留 Python 3.6+ 用户的 `**kwargs` 的原始顺序，而不是对列名进行排序。([GH 14207](https://github.com/pandas-dev/pandas/issues/14207))

+   `Series.reindex()`, `DataFrame.reindex()`, `Index.get_indexer()` 现在支持 `tolerance` 的类似列表的参数。([GH 17367](https://github.com/pandas-dev/pandas/issues/17367))  ### 与 Apache Parquet 文件格式的集成

与[Apache Parquet](https://parquet.apache.org/)集成，包括一个新的顶级`read_parquet()`和`DataFrame.to_parquet()`方法，见这里（[GH 15838](https://github.com/pandas-dev/pandas/issues/15838)，[GH 17438](https://github.com/pandas-dev/pandas/issues/17438))。

[Apache Parquet](https://parquet.apache.org/)提供了一个跨语言的二进制文件格式，用于高效读写数据框。Parquet 旨在忠实地序列化和反序列化`DataFrame`，支持所有 pandas dtypes，包括带时区的 datetime 等扩展 dtypes。

此功能取决于[pyarrow](http://arrow.apache.org/docs/python/)或[fastparquet](https://fastparquet.readthedocs.io/en/latest/)库。有关更多详情，请参阅 Parquet 上的 IO 文档。

### 方法`infer_objects`类型转换

已添加`DataFrame.infer_objects()`和`Series.infer_objects()`方法，在对象列上执行 dtype 推断，取代了已弃用的`convert_objects`方法的部分功能。有关更多详情，请参阅这里的文档（[GH 11221](https://github.com/pandas-dev/pandas/issues/11221)）。

此方法仅对对象列执行软转换，将 Python 对象转换为本机类型，而不进行任何强制转换。例如：

```py
In [1]: df = pd.DataFrame({'A': [1, 2, 3],
 ...:                   'B': np.array([1, 2, 3], dtype='object'),
 ...:                   'C': ['1', '2', '3']})
 ...: 

In [2]: df.dtypes
Out[2]: 
A     int64
B    object
C    object
Length: 3, dtype: object

In [3]: df.infer_objects().dtypes
Out[3]: 
A     int64
B     int64
C    object
Length: 3, dtype: object 
```

请注意，列`'C'`未被转换 - 只有标量数值类型将被转换为新类型。其他类型的转换应使用`to_numeric()`函数（或`to_datetime()`、`to_timedelta()`）来完成。

```py
In [4]: df = df.infer_objects()

In [5]: df['C'] = pd.to_numeric(df['C'], errors='coerce')

In [6]: df.dtypes
Out[6]: 
A    int64
B    int64
C    int64
Length: 3, dtype: object 
```

### 尝试创建列时改进的警告

新用户经常对`DataFrame`实例上的列操作和属性访问之间的关系感到困惑（[GH 7175](https://github.com/pandas-dev/pandas/issues/7175)）。此混淆的一个具体实例是尝试通过设置`DataFrame`上的属性来创建新列：

```py
In [1]: df = pd.DataFrame({'one': [1., 2., 3.]})
In [2]: df.two = [4, 5, 6] 
```

这不会引发任何明显的异常，但也不会创建新列：

```py
In [3]: df
Out[3]:
 one
0  1.0
1  2.0
2  3.0 
```

将类似于列表的数据结构设置为新属性现在会引发一个`UserWarning`，指出可能会出现意外行为。请参阅 Attribute Access。

### 方法 `drop` 现在也接受 index/columns 关键字

`drop()` 方法现在可以使用 `index`/`columns` 关键字作为指定 `axis` 的替代方法。这类似于 `reindex` 的行为（[GH 12392](https://github.com/pandas-dev/pandas/issues/12392)）。

例如：

```py
In [7]: df = pd.DataFrame(np.arange(8).reshape(2, 4),
 ...:                  columns=['A', 'B', 'C', 'D'])
 ...: 

In [8]: df
Out[8]: 
 A  B  C  D
0  0  1  2  3
1  4  5  6  7

[2 rows x 4 columns]

In [9]: df.drop(['B', 'C'], axis=1)
Out[9]: 
 A  D
0  0  3
1  4  7

[2 rows x 2 columns]

# the following is now equivalent
In [10]: df.drop(columns=['B', 'C'])
Out[10]: 
 A  D
0  0  3
1  4  7

[2 rows x 2 columns] 
```

### 方法 `rename`、`reindex` 现在也接受 axis 关键字

`DataFrame.rename()` 和 `DataFrame.reindex()` 方法现在增加了 `axis` 关键字来指定操作的轴（[GH 12392](https://github.com/pandas-dev/pandas/issues/12392)）。

这是 `rename`：

```py
In [11]: df = pd.DataFrame({"A": [1, 2, 3], "B": [4, 5, 6]})

In [12]: df.rename(str.lower, axis='columns')
Out[12]: 
 a  b
0  1  4
1  2  5
2  3  6

[3 rows x 2 columns]

In [13]: df.rename(id, axis='index')
Out[13]: 
 A  B
140682504175824  1  4
140682504175856  2  5
140682504175888  3  6

[3 rows x 2 columns] 
```

还有 `reindex`：

```py
In [14]: df.reindex(['A', 'B', 'C'], axis='columns')
Out[14]: 
 A  B   C
0  1  4 NaN
1  2  5 NaN
2  3  6 NaN

[3 rows x 3 columns]

In [15]: df.reindex([0, 1, 3], axis='index')
Out[15]: 
 A    B
0  1.0  4.0
1  2.0  5.0
3  NaN  NaN

[3 rows x 2 columns] 
```

“index, columns” 风格的方式仍然像以前一样有效。

```py
In [16]: df.rename(index=id, columns=str.lower)
Out[16]: 
 a  b
140682504175824  1  4
140682504175856  2  5
140682504175888  3  6

[3 rows x 2 columns]

In [17]: df.reindex(index=[0, 1, 3], columns=['A', 'B', 'C'])
Out[17]: 
 A    B   C
0  1.0  4.0 NaN
1  2.0  5.0 NaN
3  NaN  NaN NaN

[3 rows x 3 columns] 
```

我们*强烈*建议使用命名参数以避免在使用任一风格时产生混淆。

### 用于指定分类的 `CategoricalDtype`

`pandas.api.types.CategoricalDtype` 已添加到公共 API，并扩展以包括 `categories` 和 `ordered` 属性。`CategoricalDtype` 可以用于指定数组的类别集和排序，独立于数据。例如，在将字符串数据转换为 `Categorical` 时这可能会很有用（[GH 14711](https://github.com/pandas-dev/pandas/issues/14711)，[GH 15078](https://github.com/pandas-dev/pandas/issues/15078)，[GH 16015](https://github.com/pandas-dev/pandas/issues/16015)，[GH 17643](https://github.com/pandas-dev/pandas/issues/17643)）：

```py
In [18]: from pandas.api.types import CategoricalDtype

In [19]: s = pd.Series(['a', 'b', 'c', 'a'])  # strings

In [20]: dtype = CategoricalDtype(categories=['a', 'b', 'c', 'd'], ordered=True)

In [21]: s.astype(dtype)
Out[21]: 
0    a
1    b
2    c
3    a
Length: 4, dtype: category
Categories (4, object): ['a' < 'b' < 'c' < 'd'] 
```

有一个特别需要提及的地方是在 `read_csv()` 中。以前，使用 `dtype={'col': 'category'}`，返回的值和类别总是字符串。

```py
In [22]: data = 'A,B\na,1\nb,2\nc,3'

In [23]: pd.read_csv(StringIO(data), dtype={'B': 'category'}).B.cat.categories
Out[23]: Index(['1', '2', '3'], dtype='object') 
```

注意“object” dtype。

有了包含所有数字、日期时间或时间差的 `CategoricalDtype`，我们可以自动转换为正确的类型

```py
In [24]: dtype = {'B': CategoricalDtype([1, 2, 3])}

In [25]: pd.read_csv(StringIO(data), dtype=dtype).B.cat.categories
Out[25]: Index([1, 2, 3], dtype='int64') 
```

值已经被正确解释为整数。

`Categorical`、`CategoricalIndex` 或具有分类类型的 `Series` 的 `.dtype` 属性现在将返回 `CategoricalDtype` 的实例。虽然 repr 已更改，但 `str(CategoricalDtype())` 仍然是字符串 `'category'`。我们在此提醒用户，检测分类数据的*首选*方式是使用 `pandas.api.types.is_categorical_dtype()`，而不是 `str(dtype) == 'category'`。

更多信息请参阅 CategoricalDtype 文档。

### `GroupBy` 对象现在具有 `pipe` 方法

现在 `GroupBy` 对象也具有 `pipe` 方法，类似于 `DataFrame` 和 `Series` 上的方法，可以以清晰、可读的语法组合接受 `GroupBy` 的函数。([GH 17871](https://github.com/pandas-dev/pandas/issues/17871))

一个结合了 `.groupby` 和 `.pipe` 的具体例子是，想象有一个包含了店铺、产品、收入和销售数量列的 DataFrame。我们想要对每个店铺和每个产品进行组内价格计算（即收入/数量）。我们可以通过多步操作来实现这一点，但是用管道的方式表达可以使代码更具可读性。

首先我们设置了数据：

```py
In [26]: import numpy as np

In [27]: n = 1000

In [28]: df = pd.DataFrame({'Store': np.random.choice(['Store_1', 'Store_2'], n),
 ....:                   'Product': np.random.choice(['Product_1',
 ....:                                                'Product_2',
 ....:                                                'Product_3'
 ....:                                                ], n),
 ....:                   'Revenue': (np.random.random(n) * 50 + 10).round(2),
 ....:                   'Quantity': np.random.randint(1, 10, size=n)})
 ....: 

In [29]: df.head(2)
Out[29]: 
 Store    Product  Revenue  Quantity
0  Store_2  Product_2    32.09         7
1  Store_1  Product_3    14.20         1

[2 rows x 4 columns] 
```

现在，要找到每个店铺/产品的价格，我们可以简单地执行：

```py
In [30]: (df.groupby(['Store', 'Product'])
 ....:   .pipe(lambda grp: grp.Revenue.sum() / grp.Quantity.sum())
 ....:   .unstack().round(2))
 ....: 
Out[30]: 
Product  Product_1  Product_2  Product_3
Store 
Store_1       6.73       6.72       7.14
Store_2       7.59       6.98       7.23

[2 rows x 3 columns] 
```

有关更多信息，请参阅文档。

### `Categorical.rename_categories` 接受类似于字典的参数

`rename_categories()` 现在接受类似于字典的参数作为 `new_categories`。之前的类别将在字典的键中查找并进行替换。与 `DataFrame.rename()` 中的行为相同，缺失和额外的键的行为也相同。

```py
In [31]: c = pd.Categorical(['a', 'a', 'b'])

In [32]: c.rename_categories({"a": "eh", "b": "bee"})
Out[32]: 
['eh', 'eh', 'bee']
Categories (2, object): ['eh', 'bee'] 
```

警告

为了帮助升级 pandas，`rename_categories` 现在将 `Series` 视为类似于列表的对象。通常，Series 被认为类似于字典（例如，在 `.rename`，`.map` 中）。在 pandas 的将来版本中，`rename_categories` 将更改为将其视为类似于字典的对象。请遵循警告消息中的建议编写具有未来兼容性的代码。

```py
In [33]: c.rename_categories(pd.Series([0, 1], index=['a', 'c']))
FutureWarning: Treating Series 'new_categories' as a list-like and using the values.
In a future version, 'rename_categories' will treat Series like a dictionary.
For dict-like, use 'new_categories.to_dict()'
For list-like, use 'new_categories.values'.
Out[33]:
[0, 0, 1]
Categories (2, int64): [0, 1] 
```

### 其他增强

#### 新增的函数或方法

+   `Resampler.nearest()` 现在支持最近邻上采样（[GH 17496](https://github.com/pandas-dev/pandas/issues/17496)）。

+   `Index` 已添加了对 `to_frame` 方法的支持（[GH 15230](https://github.com/pandas-dev/pandas/issues/15230)）。

#### 新增的关键字

+   在 `infer_dtype()` 中添加了一个 `skipna` 参数，以支持在存在缺失值时进行类型推断（[GH 17059](https://github.com/pandas-dev/pandas/issues/17059)）。

+   `Series.to_dict()` 和 `DataFrame.to_dict()` 现在支持 `into` 关键字，允许您指定要返回的 `collections.Mapping` 子类。默认为 `dict`，向后兼容。([GH 16122](https://github.com/pandas-dev/pandas/issues/16122))

+   `Series.set_axis()`和`DataFrame.set_axis()`现在支持`inplace`参数（[GH 14636](https://github.com/pandas-dev/pandas/issues/14636)）。

+   `Series.to_pickle()`和`DataFrame.to_pickle()`现在增加了一个`protocol`参数（[GH 16252](https://github.com/pandas-dev/pandas/issues/16252)）。默认情况下，此参数设置为[HIGHEST_PROTOCOL](https://docs.python.org/3/library/pickle.html#data-stream-format)。

+   `read_feather()`增加了`nthreads`参数用于多线程操作（[GH 16359](https://github.com/pandas-dev/pandas/issues/16359)）。

+   `DataFrame.clip()`和`Series.clip()`现在增加了一个`inplace`参数（[GH 15388](https://github.com/pandas-dev/pandas/issues/15388)）。

+   `crosstab()`现在增加了一个`margins_name`参数，用于在`margins=True`时定义包含总计的行/列的名称（[GH 15972](https://github.com/pandas-dev/pandas/issues/15972)）。

+   `read_json()`现在接受一个`chunksize`参数，当`lines=True`时可以使用。如果传递了`chunksize`，read_json 现在返回一个迭代器，每次迭代读取`chunksize`行。（[GH 17048](https://github.com/pandas-dev/pandas/issues/17048)）。

+   `read_json()`和`to_json()`现在接受一个`compression`参数，允许它们透明地处理压缩文件（[GH 17798](https://github.com/pandas-dev/pandas/issues/17798)）。

#### 各种增强功能。

+   将 pandas 的导入时间提高了约 2.25 倍（[GH 16764](https://github.com/pandas-dev/pandas/issues/16764)）。

+   支持[PEP 519 – 添加文件系统路径协议](https://www.python.org/dev/peps/pep-0519/)的大多数读取器（例如`read_csv()``](../reference/api/pandas.DataFrame.to_csv.html#pandas.DataFrame.to_csv "pandas.DataFrame.to_csv"））（[GH 13823](https://github.com/pandas-dev/pandas/issues/13823)）。

+   添加了 `pd.HDFStore`，`pd.ExcelFile` 和 `pd.ExcelWriter` 的 `__fspath__` 方法，以便与文件系统路径协议正常工作 ([GH 13823](https://github.com/pandas-dev/pandas/issues/13823)).

+   `merge()` 的 `validate` 参数现在检查合并是一对一、一对多、多对一还是多对多。如果发现合并不是指定的合并类型的示例，则会引发 `MergeError` 类型的异常。详情请参阅这里 ([GH 16270](https://github.com/pandas-dev/pandas/issues/16270))

+   为[PEP 518](https://www.python.org/dev/peps/pep-0518/) (`pyproject.toml`)添加了构建系统的支持 ([GH 16745](https://github.com/pandas-dev/pandas/issues/16745))

+   `RangeIndex.append()` 现在在可能时返回 `RangeIndex` 对象 ([GH 16212](https://github.com/pandas-dev/pandas/issues/16212))

+   `Series.rename_axis()` 和 `DataFrame.rename_axis()` 使用 `inplace=True` 时，现在在原地重命名轴时返回 `None`。 ([GH 15704](https://github.com/pandas-dev/pandas/issues/15704))

+   `api.types.infer_dtype()` 现在推断十进制。 ([GH 15690](https://github.com/pandas-dev/pandas/issues/15690))

+   `DataFrame.select_dtypes()` 现在接受标量值作为 include/exclude，也可以是类似列表的对象。 ([GH 16855](https://github.com/pandas-dev/pandas/issues/16855))

+   `date_range()` 现在除了‘AS’之外还接受‘YS’作为年初的别名。 ([GH 9313](https://github.com/pandas-dev/pandas/issues/9313))

+   `date_range()` 现在除了‘A’之外还接受‘Y’作为年末的别名。 ([GH 9313](https://github.com/pandas-dev/pandas/issues/9313))

+   `DataFrame.add_prefix()` 和 `DataFrame.add_suffix()` 现在接受包含‘%’字符的字符串。 ([GH 17151](https://github.com/pandas-dev/pandas/issues/17151))

+   可以从路径类对象（如`pathlib.Path`）推断压缩的读/写方法(`read_csv()`, `read_table()`, `read_pickle()`, 和 `to_pickle()`)。([GH 17206](https://github.com/pandas-dev/pandas/issues/17206))

+   `read_sas()`现在可以识别 SAS7BDAT 文件中最常用的日期（时间）格式。([GH 15871](https://github.com/pandas-dev/pandas/issues/15871))

+   `DataFrame.items()`和`Series.items()`现在在 Python 2 和 3 中都存在，并且在所有情况下都是惰性的。([GH 13918](https://github.com/pandas-dev/pandas/issues/13918), [GH 17213](https://github.com/pandas-dev/pandas/issues/17213))

+   `pandas.io.formats.style.Styler.where()`已实现为`pandas.io.formats.style.Styler.applymap()`的便利方法。([GH 17474](https://github.com/pandas-dev/pandas/issues/17474))

+   `MultiIndex.is_monotonic_decreasing()`已实现。以前在所有情况下返回`False`。([GH 16554](https://github.com/pandas-dev/pandas/issues/16554))

+   如果未安装`xlrd`，`read_excel()`将引发`ImportError`并提供更好的消息。([GH 17613](https://github.com/pandas-dev/pandas/issues/17613))

+   `DataFrame.assign()`将保留`**kwargs`的原始顺序，而不是对列名进行排序，适用于 Python 3.6+用户。([GH 14207](https://github.com/pandas-dev/pandas/issues/14207))

+   `Series.reindex()`, `DataFrame.reindex()`, `Index.get_indexer()`现在支持`tolerance`的类似列表参数。([GH 17367](https://github.com/pandas-dev/pandas/issues/17367))

#### 新函数或方法

+   `Resampler.nearest()`被添加以支持最近邻上采样。([GH 17496](https://github.com/pandas-dev/pandas/issues/17496))

+   `Index` 现在支持 `to_frame` 方法 ([GH 15230](https://github.com/pandas-dev/pandas/issues/15230)).

#### 新的关键字

+   在 `infer_dtype()` 中添加了一个 `skipna` 参数，以支持在存在缺失值时进行类型推断 ([GH 17059](https://github.com/pandas-dev/pandas/issues/17059)).

+   `Series.to_dict()` 和 `DataFrame.to_dict()` 现在支持一个 `into` 关键字，允许您指定要返回的 `collections.Mapping` 子类。默认为 `dict`，与向后兼容。([GH 16122](https://github.com/pandas-dev/pandas/issues/16122))

+   `Series.set_axis()` 和 `DataFrame.set_axis()` 现在支持 `inplace` 参数。([GH 14636](https://github.com/pandas-dev/pandas/issues/14636))

+   `Series.to_pickle()` 和 `DataFrame.to_pickle()` 增加了一个 `protocol` 参数 ([GH 16252](https://github.com/pandas-dev/pandas/issues/16252))。默认情况下，此参数设置为 [HIGHEST_PROTOCOL](https://docs.python.org/3/library/pickle.html#data-stream-format)

+   `read_feather()` 现在增加了 `nthreads` 参数以支持多线程操作 ([GH 16359](https://github.com/pandas-dev/pandas/issues/16359))

+   `DataFrame.clip()` 和 `Series.clip()` 增加了一个 `inplace` 参数。([GH 15388](https://github.com/pandas-dev/pandas/issues/15388))

+   `crosstab()` 增加了一个 `margins_name` 参数，用于在 `margins=True` 时定义包含总计的行/列的名称。([GH 15972](https://github.com/pandas-dev/pandas/issues/15972))

+   `read_json()` 现在在 `lines=True` 时接受一个 `chunksize` 参数。如果传入 `chunksize`，read_json 现在会返回一个迭代器，每次迭代读入 `chunksize` 行。([GH 17048](https://github.com/pandas-dev/pandas/issues/17048))

+   `read_json()` 和 `to_json()` 现在接受一个 `compression` 参数，使它们能够透明地处理压缩文件。 ([GH 17798](https://github.com/pandas-dev/pandas/issues/17798))

#### 各种增强功能

+   提高了 pandas 的导入时间约 2.25 倍。 ([GH 16764](https://github.com/pandas-dev/pandas/issues/16764))

+   在大多数读取器（例如 `read_csv()`）和写入器（例如 `DataFrame.to_csv()`）上添加了对 [PEP 519 – 添加文件系统路径协议](https://www.python.org/dev/peps/pep-0519/) 的支持 ([GH 13823](https://github.com/pandas-dev/pandas/issues/13823)).

+   向 `pd.HDFStore`、`pd.ExcelFile` 和 `pd.ExcelWriter` 添加了一个 `__fspath__` 方法，以便与文件系统路径协议正常工作 ([GH 13823](https://github.com/pandas-dev/pandas/issues/13823)).

+   `merge()` 的 `validate` 参数现在检查合并是一对一、一对多、多对一还是多对多。 如果发现合并不是指定合并类型的示例，将引发 `MergeError` 类型的异常。 更多信息请参见此处 ([GH 16270](https://github.com/pandas-dev/pandas/issues/16270))

+   对构建系统添加了对 [PEP 518](https://www.python.org/dev/peps/pep-0518/) (`pyproject.toml`) 的支持 ([GH 16745](https://github.com/pandas-dev/pandas/issues/16745))

+   `RangeIndex.append()` 现在在可能的情况下返回一个 `RangeIndex` 对象 ([GH 16212](https://github.com/pandas-dev/pandas/issues/16212))

+   `Series.rename_axis()` 和 `DataFrame.rename_axis()` 在 `inplace=True` 时，将轴重命名为 `None`。 ([GH 15704](https://github.com/pandas-dev/pandas/issues/15704))

+   `api.types.infer_dtype()` 现在推断小数。 ([GH 15690](https://github.com/pandas-dev/pandas/issues/15690))

+   `DataFrame.select_dtypes()` 现在接受标量值作为包含/排除以及类似列表的参数。 ([GH 16855](https://github.com/pandas-dev/pandas/issues/16855))

+   `date_range()` 现在除了‘AS’之外还接受‘YS’作为年初的别名。([GH 9313](https://github.com/pandas-dev/pandas/issues/9313))

+   `date_range()` 现在除了‘A’之外还接受‘Y’作为年末的别名。([GH 9313](https://github.com/pandas-dev/pandas/issues/9313))

+   `DataFrame.add_prefix()` 和 `DataFrame.add_suffix()` 现在接受包含‘%’字符的字符串。([GH 17151](https://github.com/pandas-dev/pandas/issues/17151))

+   从推断压缩的读/写方法（`read_csv()`, `read_table()`, `read_pickle()`, 和 `to_pickle()`）现在可以从类似 `pathlib.Path` 的路径对象中推断。([GH 17206](https://github.com/pandas-dev/pandas/issues/17206))

+   `read_sas()` 现在可以识别更多在 SAS7BDAT 文件中最常用的日期（时间）格式。([GH 15871](https://github.com/pandas-dev/pandas/issues/15871))

+   `DataFrame.items()` 和 `Series.items()` 现在在 Python 2 和 3 中都存在，并且在所有情况下都是惰性的。([GH 13918](https://github.com/pandas-dev/pandas/issues/13918), [GH 17213](https://github.com/pandas-dev/pandas/issues/17213))

+   `pandas.io.formats.style.Styler.where()` 已经实现，作为 `pandas.io.formats.style.Styler.applymap()` 的便利。([GH 17474](https://github.com/pandas-dev/pandas/issues/17474))

+   `MultiIndex.is_monotonic_decreasing()` 已经实现。以前在所有情况下返回 `False`。([GH 16554](https://github.com/pandas-dev/pandas/issues/16554))

+   `read_excel()` 如果未安装 `xlrd`，将引发 `ImportError` 并提供更好的消息。([GH 17613](https://github.com/pandas-dev/pandas/issues/17613))

+   `DataFrame.assign()` 将为 Python 3.6+ 用户保留 `**kwargs` 的原始顺序，而不是对列名进行排序。([GH 14207](https://github.com/pandas-dev/pandas/issues/14207))

+   `Series.reindex()`, `DataFrame.reindex()`, `Index.get_indexer()` 现在支持`tolerance`的类似列表参数。 ([GH 17367](https://github.com/pandas-dev/pandas/issues/17367))

## 不向后兼容的 API 更改

### 依赖关系已增加最低版本

我们已经更新了我们所支持的依赖项的最低版本（[GH 15206](https://github.com/pandas-dev/pandas/issues/15206), [GH 15543](https://github.com/pandas-dev/pandas/issues/15543), [GH 15214](https://github.com/pandas-dev/pandas/issues/15214)）。如果已安装，我们现在需要：

> | Package | Minimum Version | Required |
> | --- | --- | --- |
> | Numpy | 1.9.0 | X |
> | Matplotlib | 1.4.3 |  |
> | Scipy | 0.14.0 |  |
> | Bottleneck | 1.0.0 |  |

另外，支持已放弃 Python 3.4 ([GH 15251](https://github.com/pandas-dev/pandas/issues/15251))。  ### 所有-NaN 或空系列/数据框的和/乘积现在一致为 NaN

注意

此处描述的更改已部分回滚。有关更多信息，请参见 v0.22.0 Whatsnew 。

在所有 NaN 的 Series/DataFrames 上`sum`和`prod`的行为不再取决于是否安装了 [bottleneck](https://bottleneck.readthedocs.io)，并且空 Series 的`sum`和`prod`的返回值已更改 ([GH 9422](https://github.com/pandas-dev/pandas/issues/9422), [GH 15507](https://github.com/pandas-dev/pandas/issues/15507))。

在空或所有 `NaN` 的 `Series`，或 `DataFrame` 的列上调用 `sum` 或 `prod` 将导致 `NaN`。请参阅 文档。

```py
In [33]: s = pd.Series([np.nan]) 
```

以前未安装 `bottleneck` 时：

```py
In [2]: s.sum()
Out[2]: np.nan 
```

以前使用`bottleneck`时：

```py
In [2]: s.sum()
Out[2]: 0.0 
```

新行为，不考虑瓶颈安装：

```py
In [34]: s.sum()
Out[34]: 0.0 
```

请注意，这也更改了空 `Series` 的总和。以前，无论是否安装了 `bottleneck`，这总是返回 0：

```py
In [1]: pd.Series([]).sum()
Out[1]: 0 
```

但是为了与全 NaN 情况保持一致，这也被更改为返回 0：

```py
In [2]: pd.Series([]).sum()
Out[2]: 0 
```  ### 使用带有缺失标签的列表进行索引已被弃用

以前，选择使用标签列表，其中一个或多个标签丢失，将总是成功，并返回 `NaN` 以表示缺失标签。现在将显示一个 `FutureWarning`。将来这将引发一个 `KeyError` ([GH 15747](https://github.com/pandas-dev/pandas/issues/15747))。当传递至少有一个缺失标签的标签列表时，此警告将在使用 `.loc[]` 或 `[[]]` 选择 `DataFrame` 或 `Series` 时触发。

```py
In [35]: s = pd.Series([1, 2, 3])

In [36]: s
Out[36]: 
0    1
1    2
2    3
Length: 3, dtype: int64 
```

先前的行为

```py
In [4]: s.loc[[1, 2, 3]]
Out[4]:
1    2.0
2    3.0
3    NaN
dtype: float64 
```

当前行为

```py
In [4]: s.loc[[1, 2, 3]]
Passing list-likes to .loc or [] with any missing label will raise
KeyError in the future, you can use .reindex() as an alternative.

See the documentation here:
https://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike

Out[4]:
1    2.0
2    3.0
3    NaN
dtype: float64 
```

实现选择可能不存在的元素的惯用方法是通过 `.reindex()`

```py
In [37]: s.reindex([1, 2, 3])
Out[37]: 
1    2.0
2    3.0
3    NaN
Length: 3, dtype: float64 
```

选择所有找到的键的行为未更改。

```py
In [38]: s.loc[[1, 2]]
Out[38]: 
1    2
2    3
Length: 2, dtype: int64 
```  ### NA 命名更改

为了在 pandas API 中促进更一致性，我们添加了额外的顶层函数`isna()`和`notna()`，它们是`isnull()`和`notnull()`的别名。命名方案现在更符合`.dropna()`和`.fillna()`等方法。此外，在定义了`.isnull()`和`.notnull()`方法的所有情况下，这些方法还有名为`.isna()`和`.notna()`的附加方法，这些方法适用于类别`Categorical`、`Index`、`Series`和`DataFrame`。([GH 15001](https://github.com/pandas-dev/pandas/issues/15001))。

配置选项`pd.options.mode.use_inf_as_null`已被弃用，添加了`pd.options.mode.use_inf_as_na`作为替代。### Series/Index 的迭代现在将返回 Python 标量

以前，当对具有`int`或`float`类型的`Series`使用某些迭代方法时，您将收到一个`numpy`标量，例如`np.int64`，而不是 Python 的`int`。问题（[GH 10904](https://github.com/pandas-dev/pandas/issues/10904)）已为`Series.tolist()`和`list(Series)`进行了更正。此更改使所有迭代方法保持一致，特别是对于`__iter__()`和`.map()`；请注意，这仅影响 int/float 类型。([GH 13236](https://github.com/pandas-dev/pandas/issues/13236), [GH 13258](https://github.com/pandas-dev/pandas/issues/13258), [GH 14216](https://github.com/pandas-dev/pandas/issues/14216))。

```py
In [39]: s = pd.Series([1, 2, 3])

In [40]: s
Out[40]: 
0    1
1    2
2    3
Length: 3, dtype: int64 
```

以前：

```py
In [2]: type(list(s)[0])
Out[2]: numpy.int64 
```

新行为：

```py
In [41]: type(list(s)[0])
Out[41]: int 
```

此外，现在这将正确地对`DataFrame.to_dict()`的迭代结果进行封装。

```py
In [42]: d = {'a': [1], 'b': ['b']}

In [43]: df = pd.DataFrame(d) 
```

以前：

```py
In [8]: type(df.to_dict()['a'][0])
Out[8]: numpy.int64 
```

新行为：

```py
In [44]: type(df.to_dict()['a'][0])
Out[44]: int 
```  ### 使用布尔索引进行索引

以前，当将布尔`Index`传递给`.loc`时，如果`Series/DataFrame`的索引具有`boolean`标签，则会获得基于标签的选择，可能会重复结果标签，而不是布尔索引选择（其中`True`选择元素），这与布尔 numpy 数组索引的方式不一致。新行为是像布尔 numpy 数组索引器一样操作。([GH 17738](https://github.com/pandas-dev/pandas/issues/17738))

先前行为：

```py
In [45]: s = pd.Series([1, 2, 3], index=[False, True, False])

In [46]: s
Out[46]: 
False    1
True     2
False    3
Length: 3, dtype: int64 
```

```py
In [59]: s.loc[pd.Index([True, False, True])]
Out[59]:
True     2
False    1
False    3
True     2
dtype: int64 
```

当前行为

```py
In [47]: s.loc[pd.Index([True, False, True])]
Out[47]: 
False    1
False    3
Length: 2, dtype: int64 
```

此外，以前如果您有一个非数字索引（例如字符串），那么布尔索引将引发`KeyError`。现在将被视为布尔索引器。

先前行为：

```py
In [48]: s = pd.Series([1, 2, 3], index=['a', 'b', 'c'])

In [49]: s
Out[49]: 
a    1
b    2
c    3
Length: 3, dtype: int64 
```

```py
In [39]: s.loc[pd.Index([True, False, True])]
KeyError: "None of [Index([True, False, True], dtype='object')] are in the [index]" 
```

当前行为

```py
In [50]: s.loc[pd.Index([True, False, True])]
Out[50]: 
a    1
c    3
Length: 2, dtype: int64 
```  ### `PeriodIndex` 重新采样

在 pandas 的先前版本中，对由 `PeriodIndex` 索引的 `Series`/`DataFrame` 进行重新采样，在某些情况下会返回 `DatetimeIndex` ([GH 12884](https://github.com/pandas-dev/pandas/issues/12884))。现在，对倍频率进行重新采样将返回 `PeriodIndex` ([GH 15944](https://github.com/pandas-dev/pandas/issues/15944))。作为一个小的增强，对 `PeriodIndex` 进行重新采样现在可以处理 `NaT` 值 ([GH 13224](https://github.com/pandas-dev/pandas/issues/13224))。

先前的行为：

```py
In [1]: pi = pd.period_range('2017-01', periods=12, freq='M')

In [2]: s = pd.Series(np.arange(12), index=pi)

In [3]: resampled = s.resample('2Q').mean()

In [4]: resampled
Out[4]:
2017-03-31     1.0
2017-09-30     5.5
2018-03-31    10.0
Freq: 2Q-DEC, dtype: float64

In [5]: resampled.index
Out[5]: DatetimeIndex(['2017-03-31', '2017-09-30', '2018-03-31'], dtype='datetime64[ns]', freq='2Q-DEC') 
```

新行为：

```py
In [1]: pi = pd.period_range('2017-01', periods=12, freq='M')

In [2]: s = pd.Series(np.arange(12), index=pi)

In [3]: resampled = s.resample('2Q').mean()

In [4]: resampled
Out[4]:
2017Q1    2.5
2017Q3    8.5
Freq: 2Q-DEC, dtype: float64

In [5]: resampled.index
Out[5]: PeriodIndex(['2017Q1', '2017Q3'], dtype='period[2Q-DEC]') 
```

上采样并调用 `.ohlc()` 先前返回一个 `Series`，基本上与调用 `.asfreq()` 相同。OHLC 上采样现在返回一个带有列 `open`、`high`、`low` 和 `close` 的 DataFrame ([GH 13083](https://github.com/pandas-dev/pandas/issues/13083))。这与下采样和 `DatetimeIndex` 的行为一致。

先前的行为：

```py
In [1]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)

In [2]: s = pd.Series(np.arange(10), index=pi)

In [3]: s.resample('H').ohlc()
Out[3]:
2000-01-01 00:00    0.0
 ...
2000-01-10 23:00    NaN
Freq: H, Length: 240, dtype: float64

In [4]: s.resample('M').ohlc()
Out[4]:
 open  high  low  close
2000-01     0     9    0      9 
```

新行为：

```py
In [56]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)

In [57]: s = pd.Series(np.arange(10), index=pi)

In [58]: s.resample('H').ohlc()
Out[58]:
 open  high  low  close
2000-01-01 00:00   0.0   0.0  0.0    0.0
2000-01-01 01:00   NaN   NaN  NaN    NaN
2000-01-01 02:00   NaN   NaN  NaN    NaN
2000-01-01 03:00   NaN   NaN  NaN    NaN
2000-01-01 04:00   NaN   NaN  NaN    NaN
...                ...   ...  ...    ...
2000-01-10 19:00   NaN   NaN  NaN    NaN
2000-01-10 20:00   NaN   NaN  NaN    NaN
2000-01-10 21:00   NaN   NaN  NaN    NaN
2000-01-10 22:00   NaN   NaN  NaN    NaN
2000-01-10 23:00   NaN   NaN  NaN    NaN

[240 rows x 4 columns]

In [59]: s.resample('M').ohlc()
Out[59]:
 open  high  low  close
2000-01     0     9    0      9

[1 rows x 4 columns] 
```  ### 在 pd.eval 中的项赋值改进的错误处理

`eval()` 当项赋值失败或指定了原地操作但在表达式中没有项赋值时，现在会引发 `ValueError` ([GH 16732](https://github.com/pandas-dev/pandas/issues/16732))

```py
In [51]: arr = np.array([1, 2, 3]) 
```

先前，如果尝试以下表达式，将会得到一个不太有用的错误消息：

```py
In [3]: pd.eval("a = 1 + 2", target=arr, inplace=True)
...
IndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`)
and integer or boolean arrays are valid indices 
```

这是说 numpy 数组不支持字符串项索引的一种非常长的方式。随着这个变化，错误消息现在是这样的：

```py
In [3]: pd.eval("a = 1 + 2", target=arr, inplace=True)
...
ValueError: Cannot assign expression output to target 
```

还可以在没有项赋值的情况下进行表达式的原地求值：

```py
In [4]: pd.eval("1 + 2", target=arr, inplace=True)
Out[4]: 3 
```

然而，这个输入并没有太多意义，因为输出没有被分配给目标。现在，当传入这样的输入时，将会引发 `ValueError`：

```py
In [4]: pd.eval("1 + 2", target=arr, inplace=True)
...
ValueError: Cannot operate inplace if there is no assignment 
```  ### Dtype 转换

先前的赋值、`.where()` 和 `.fillna()` 与 `bool` 赋值一起使用，会强制转换为相同类型（例如 int / float），或者对于日期时间型会引发错误。现在，这些将保留具有 `object` dtype 的 bools。([GH 16821](https://github.com/pandas-dev/pandas/issues/16821))。

```py
In [52]: s = pd.Series([1, 2, 3]) 
```

```py
In [5]: s[1] = True

In [6]: s
Out[6]:
0    1
1    1
2    3
dtype: int64 
```

新行为

```py
In [7]: s[1] = True

In [8]: s
Out[8]:
0       1
1    True
2       3
Length: 3, dtype: object 
```

先前，对于具有非日期时间型的 datetimelike 的赋值会强制转换被赋值的非日期时间型项 ([GH 14145](https://github.com/pandas-dev/pandas/issues/14145))。

```py
In [53]: s = pd.Series([pd.Timestamp('2011-01-01'), pd.Timestamp('2012-01-01')]) 
```

```py
In [1]: s[1] = 1

In [2]: s
Out[2]:
0   2011-01-01 00:00:00.000000000
1   1970-01-01 00:00:00.000000001
dtype: datetime64[ns] 
```

这些现在强制转换为 `object` dtype。

```py
In [1]: s[1] = 1

In [2]: s
Out[2]:
0    2011-01-01 00:00:00
1                      1
dtype: object 
```

+   在 `.where()` 中使用 datetimelikes 的不一致行为，会引发而不是强制转换为 `object` ([GH 16402](https://github.com/pandas-dev/pandas/issues/16402))

+   在使用 `np.ndarray` 的 `float64` dtype 的 `int64` 数据进行赋值时可能会保持 `int64` dtype 的错误（[GH 14001](https://github.com/pandas-dev/pandas/issues/14001))  ### 具有单个级别的 MultiIndex 构造函数

`MultiIndex` 构造函数不再将所有长度为一的级别的 MultiIndex 压缩为常规的 `Index`。这影响所有 `MultiIndex` 构造函数。([GH 17178](https://github.com/pandas-dev/pandas/issues/17178))

先前的行为：

```py
In [2]: pd.MultiIndex.from_tuples([('a',), ('b',)])
Out[2]: Index(['a', 'b'], dtype='object') 
```

长度为 1 的级别不再特殊处理。它们的行为与长度为 2+ 的级别完全相同，因此 `MultiIndex` 构造函数始终返回 `MultiIndex`：

```py
In [54]: pd.MultiIndex.from_tuples([('a',), ('b',)])
Out[54]: 
MultiIndex([('a',),
 ('b',)],
 ) 
```  ### Series 的 UTC 本地化

以前，当传递 `utc=True` 时，`to_datetime()` 不会本地化日期时间 `Series` 数据。现在，`to_datetime()` 将正确地本地化具有 `datetime64[ns, UTC]` dtype 的 `Series`，以使其与列表样式和 `Index` 数据的处理方式保持一致。 ([GH 6415](https://github.com/pandas-dev/pandas/issues/6415)).

先前的行为

```py
In [55]: s = pd.Series(['20130101 00:00:00'] * 3) 
```

```py
In [12]: pd.to_datetime(s, utc=True)
Out[12]:
0   2013-01-01
1   2013-01-01
2   2013-01-01
dtype: datetime64[ns] 
```

新行为

```py
In [56]: pd.to_datetime(s, utc=True)
Out[56]: 
0   2013-01-01 00:00:00+00:00
1   2013-01-01 00:00:00+00:00
2   2013-01-01 00:00:00+00:00
Length: 3, dtype: datetime64[ns, UTC] 
```

此外，通过 `read_sql_table()` 和 `read_sql_query()` 解析的具有日期时间列的 DataFrame 将仅在原始 SQL 列是时区感知日期时间列时本地化为 UTC。  ### 范围函数的一致性

在以前的版本中，各种范围函数之间存在一些不一致性：`date_range()`, `bdate_range()`, `period_range()`, `timedelta_range()`, 和 `interval_range()`. ([GH 17471](https://github.com/pandas-dev/pandas/issues/17471)).

其中不一致的行为之一是当同时指定 `start`、`end` 和 `period` 参数时，可能导致模糊的范围。当传递了所有三个参数时，`interval_range` 忽略 `period` 参数，`period_range` 忽略 `end` 参数，而其他范围函数则引发异常。为了促进范围函数之间的一致性，并避免潜在的模糊范围，当传递所有三个参数时，`interval_range` 和 `period_range` 现在会引发异常。

先前的行为：

```py
 In [2]: pd.interval_range(start=0, end=4, periods=6)
 Out[2]:
 IntervalIndex([(0, 1], (1, 2], (2, 3]]
 closed='right',
 dtype='interval[int64]')

In [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')
Out[3]: PeriodIndex(['2017Q1', '2017Q2', '2017Q3', '2017Q4', '2018Q1', '2018Q2'], dtype='period[Q-DEC]', freq='Q-DEC') 
```

新行为：

```py
In [2]: pd.interval_range(start=0, end=4, periods=6)
---------------------------------------------------------------------------
ValueError: Of the three parameters: start, end, and periods, exactly two must be specified

In [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')
---------------------------------------------------------------------------
ValueError: Of the three parameters: start, end, and periods, exactly two must be specified 
```

此外，`interval_range` 生成的区间不包括终点参数 `end`。然而，所有其他范围函数都将 `end` 包含在其输出中。为了促进范围函数之间的一致性，`interval_range` 现在将 `end` 包括在最后一个区间的右端点，除非以跳过 `end` 的方式指定了 `freq`。

先前的行为：

```py
In [4]: pd.interval_range(start=0, end=4)
Out[4]:
IntervalIndex([(0, 1], (1, 2], (2, 3]]
 closed='right',
 dtype='interval[int64]') 
```

新行为：

```py
In [57]: pd.interval_range(start=0, end=4)
Out[57]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4]], dtype='interval[int64, right]') 
```  ### 没有自动的 Matplotlib 转换器

当导入 pandas 时，pandas 不再向 matplotlib 注册我们的`date`、`time`、`datetime`、`datetime64`和`Period`转换器。Matplotlib 绘图方法（`plt.plot`、`ax.plot`等）将不会为`DatetimeIndex`或`PeriodIndex`值格式化 x 轴。您必须显式注册这些方法：

pandas 内置的`Series.plot`和`DataFrame.plot` *将*在首次使用时注册这些转换器（[GH 17710](https://github.com/pandas-dev/pandas/issues/17710)）。

注意

这一变更在 pandas 0.21.1 中暂时被撤销，更多详情请参见这里。### 其他 API 变更

+   Categorical 构造函数不再接受`categories`关键字的标量。([GH 16022](https://github.com/pandas-dev/pandas/issues/16022))

+   现在在关闭的`HDFStore`上访问不存在的属性将引发`AttributeError`而不是`ClosedFileError` ([GH 16301](https://github.com/pandas-dev/pandas/issues/16301))

+   `read_csv()`现在会在`names`参数包含重复值时发出`UserWarning`（[GH 17095](https://github.com/pandas-dev/pandas/issues/17095)）

+   `read_csv()`现在默认将`'null'`和`'n/a'`字符串视为缺失值 ([GH 16471](https://github.com/pandas-dev/pandas/issues/16471), [GH 16078](https://github.com/pandas-dev/pandas/issues/16078))

+   `pandas.HDFStore`的字符串表示现在更快且更简洁。要恢复以前的行为，请使用`pandas.HDFStore.info()`。([GH 16503](https://github.com/pandas-dev/pandas/issues/16503))

+   HDF 存储中的压缩默认值现在遵循 pytables 标准。默认值为无压缩，如果`complib`缺失且`complevel` > 0，则使用`zlib` ([GH 15943](https://github.com/pandas-dev/pandas/issues/15943))

+   `Index.get_indexer_non_unique()`现在返回一个 ndarray 索引器而��是`Index`；这与`Index.get_indexer()`保持一致 ([GH 16819](https://github.com/pandas-dev/pandas/issues/16819))

+   从`pandas._testing`中删除了`@slow`装饰器，这导致一些下游软件包的测试套件出现问题。改用`@pytest.mark.slow`，它可以实现相同的效果（[GH 16850](https://github.com/pandas-dev/pandas/issues/16850)）

+   将`MergeError`的定义移至`pandas.errors`模块。

+   `Series.set_axis()`和`DataFrame.set_axis()`的签名已从`set_axis(axis, labels)`更改为`set_axis(labels, axis=0)`，以保持与 API 的一致性。旧的签名已被弃用，并将显示`FutureWarning` ([GH 14636](https://github.com/pandas-dev/pandas/issues/14636))

+   当使用`object` dtypes 时，`Series.argmin()`和`Series.argmax()`现在将引发`TypeError`，而不是`ValueError`（[GH 13595](https://github.com/pandas-dev/pandas/issues/13595)）

+   `Period`现在是不可变的，当用户尝试为`ordinal`或`freq`属性分配新值时，将引发`AttributeError`（[GH 17116](https://github.com/pandas-dev/pandas/issues/17116)）。

+   当传递了一个带有时区信息的`origin=`关键字参数给`to_datetime()`时，现在会引发一个更具信息性的`ValueError`而不是`TypeError`（[GH 16842](https://github.com/pandas-dev/pandas/issues/16842)）

+   当格式包含`%W`或`%U`而没有包括星期几和日历年时，`to_datetime()`现在会引发一个`ValueError`（[GH 16774](https://github.com/pandas-dev/pandas/issues/16774)）

+   在`read_stata()`中将非功能性的`index`重命名为`index_col`，以改善 API 一致性（[GH 16342](https://github.com/pandas-dev/pandas/issues/16342)）

+   在`DataFrame.drop()`中存在一个错误，导致布尔标签`False`和`True`在从数值索引中删除索引时分别被视为标签 0 和 1。现在将引发一个 ValueError（[GH 16877](https://github.com/pandas-dev/pandas/issues/16877)）

+   限制了`DateOffset`关键字参数。以前，`DateOffset`子类允许任意关键字参数，这可能导致意外行为。现在，只有有效的参数将被接受。([GH 17176](https://github.com/pandas-dev/pandas/issues/17176))。### 依赖项已增加最低版本

我们已更新了我们的依赖项的最低支持版本（[GH 15206](https://github.com/pandas-dev/pandas/issues/15206)，[GH 15543](https://github.com/pandas-dev/pandas/issues/15543)，[GH 15214](https://github.com/pandas-dev/pandas/issues/15214)）。如果已安装，我们现在要求：

> | Package | Minimum Version | Required |
> | --- | --- | --- |
> | Numpy | 1.9.0 | X |
> | Matplotlib | 1.4.3 |  |
> | Scipy | 0.14.0 |  |
> | Bottleneck | 1.0.0 |  |

另外，不再支持 Python 3.4（[GH 15251](https://github.com/pandas-dev/pandas/issues/15251)）。

### 所有-NaN 或空 Series/DataFrames 的 sum/prod 现在一致为 NaN

注意

此处描述的更改已经部分回滚。更多信息请参阅 v0.22.0 Whatsnew。

`sum`和`prod`在所有 NaN Series/DataFrames 上的行为不再取决于是否安装了[bottleneck](https://bottleneck.readthedocs.io)，并且空 Series 上`sum`和`prod`的返回值已更改([GH 9422](https://github.com/pandas-dev/pandas/issues/9422)，[GH 15507](https://github.com/pandas-dev/pandas/issues/15507))。

在空的或全部为`NaN`的`Series`或`DataFrame`上调用`sum`或`prod`将导致`NaN`。参见文档。

```py
In [33]: s = pd.Series([np.nan]) 
```

先前未安装`bottleneck`：

```py
In [2]: s.sum()
Out[2]: np.nan 
```

先前使用`bottleneck`：

```py
In [2]: s.sum()
Out[2]: 0.0 
```

新行为，不考虑 bottleneck 的安装：

```py
In [34]: s.sum()
Out[34]: 0.0 
```

请注意，这也更改了空`Series`的总和。先前，无论是否安装了`bottleneck`，这总是返回 0：

```py
In [1]: pd.Series([]).sum()
Out[1]: 0 
```

但是为了与所有 NaN 情况保持一致，这也被更改为返回 0：

```py
In [2]: pd.Series([]).sum()
Out[2]: 0 
```

### 使用缺失标签的列表进行索引已被弃用

先前，在选择缺少一个或多个标签的标签列表时，总是成功的，对于缺失的标签返回`NaN`。这现在将显示一个`FutureWarning`。未来将在使用`.loc[]`或`[[]]`时触发此警告，当传递至少有 1 个缺失标签的标签列表时，将在`DataFrame`或`Series`上引发`KeyError` ([GH 15747](https://github.com/pandas-dev/pandas/issues/15747))。

```py
In [35]: s = pd.Series([1, 2, 3])

In [36]: s
Out[36]: 
0    1
1    2
2    3
Length: 3, dtype: int64 
```

先前的行为

```py
In [4]: s.loc[[1, 2, 3]]
Out[4]:
1    2.0
2    3.0
3    NaN
dtype: float64 
```

当前行为

```py
In [4]: s.loc[[1, 2, 3]]
Passing list-likes to .loc or [] with any missing label will raise
KeyError in the future, you can use .reindex() as an alternative.

See the documentation here:
https://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike

Out[4]:
1    2.0
2    3.0
3    NaN
dtype: float64 
```

实现选择可能未找到的元素的惯用方法是通过`.reindex()`。

```py
In [37]: s.reindex([1, 2, 3])
Out[37]: 
1    2.0
2    3.0
3    NaN
Length: 3, dtype: float64 
```

使用所有找到的键的选择未更改。

```py
In [38]: s.loc[[1, 2]]
Out[38]: 
1    2
2    3
Length: 2, dtype: int64 
```

### NA 命名更改

为了在 pandas API 中提升更多一致性，我们添加了额外的顶级函数`isna()`和`notna()`，它们是`isnull()`和`notnull()`的别名。现在的命名方案与`.dropna()`和`.fillna()`等方法更一致。此外，在定义了`.isnull()`和`.notnull()`方法的所有情况下，这些方法都有额外的名为`.isna()`和`.notna()`的方法，这些方法包括类`Categorical`、`Index`、`Series`和`DataFrame`。([GH 15001](https://github.com/pandas-dev/pandas/issues/15001))。

配置选项`pd.options.mode.use_inf_as_null`已被弃用，添加了`pd.options.mode.use_inf_as_na`作为替代。

### 现在 Series/Index 的迭代将返回 Python 标量

以前，当对 dtype 为`int`或`float`的`Series`使用某些迭代方法时，会收到一个`numpy`标量，例如`np.int64`，而不是 Python 的`int`。问题 ([GH 10904](https://github.com/pandas-dev/pandas/issues/10904)) 为`Series.tolist()`和`list(Series)`进行了修正。此更改使所有迭代方法一致，特别是对于`__iter__()`和`.map()`；请注意，这仅影响 int/float dtype。 ([GH 13236](https://github.com/pandas-dev/pandas/issues/13236), [GH 13258](https://github.com/pandas-dev/pandas/issues/13258), [GH 14216](https://github.com/pandas-dev/pandas/issues/14216))。

```py
In [39]: s = pd.Series([1, 2, 3])

In [40]: s
Out[40]: 
0    1
1    2
2    3
Length: 3, dtype: int64 
```

以前：

```py
In [2]: type(list(s)[0])
Out[2]: numpy.int64 
```

新行为：

```py
In [41]: type(list(s)[0])
Out[41]: int 
```

此外，这现在还将正确地对`DataFrame.to_dict()`的迭代结果进行包装。

```py
In [42]: d = {'a': [1], 'b': ['b']}

In [43]: df = pd.DataFrame(d) 
```

以前：

```py
In [8]: type(df.to_dict()['a'][0])
Out[8]: numpy.int64 
```

新行为：

```py
In [44]: type(df.to_dict()['a'][0])
Out[44]: int 
```

### 使用布尔索引进行索引

以前当将布尔值`Index`传递给`.loc`时，如果`Series/DataFrame`的索引具有`boolean`标签，则会获得基于标签的选择，而不是布尔索引选择（其中`True`选择元素），这与布尔 numpy 数组索引的方式不一致。新行为是像布尔 numpy 数组索引器一样运行。 ([GH 17738](https://github.com/pandas-dev/pandas/issues/17738))

先前的行为：

```py
In [45]: s = pd.Series([1, 2, 3], index=[False, True, False])

In [46]: s
Out[46]: 
False    1
True     2
False    3
Length: 3, dtype: int64 
```

```py
In [59]: s.loc[pd.Index([True, False, True])]
Out[59]:
True     2
False    1
False    3
True     2
dtype: int64 
```

当前行为

```py
In [47]: s.loc[pd.Index([True, False, True])]
Out[47]: 
False    1
False    3
Length: 2, dtype: int64 
```

此外，以前如果你有一个非数字的索引（例如字符串），那么布尔索引会引发一个`KeyError`。现在将把它视为布尔索引。

以前行为：

```py
In [48]: s = pd.Series([1, 2, 3], index=['a', 'b', 'c'])

In [49]: s
Out[49]: 
a    1
b    2
c    3
Length: 3, dtype: int64 
```

```py
In [39]: s.loc[pd.Index([True, False, True])]
KeyError: "None of [Index([True, False, True], dtype='object')] are in the [index]" 
```

当前行为

```py
In [50]: s.loc[pd.Index([True, False, True])]
Out[50]: 
a    1
c    3
Length: 2, dtype: int64 
```

### `PeriodIndex` 重新采样

在 pandas 的早期版本中，对由`PeriodIndex`索引的`Series`/`DataFrame`进行重新采样，在某些情况下返回一个`DatetimeIndex` ([GH 12884](https://github.com/pandas-dev/pandas/issues/12884))。现在重新采样为倍频率将返回一个`PeriodIndex` ([GH 15944](https://github.com/pandas-dev/pandas/issues/15944))。作为一个小的增强，现在重新采样`PeriodIndex`可以处理`NaT`值 ([GH 13224](https://github.com/pandas-dev/pandas/issues/13224))

先前的行为：

```py
In [1]: pi = pd.period_range('2017-01', periods=12, freq='M')

In [2]: s = pd.Series(np.arange(12), index=pi)

In [3]: resampled = s.resample('2Q').mean()

In [4]: resampled
Out[4]:
2017-03-31     1.0
2017-09-30     5.5
2018-03-31    10.0
Freq: 2Q-DEC, dtype: float64

In [5]: resampled.index
Out[5]: DatetimeIndex(['2017-03-31', '2017-09-30', '2018-03-31'], dtype='datetime64[ns]', freq='2Q-DEC') 
```

新行为：

```py
In [1]: pi = pd.period_range('2017-01', periods=12, freq='M')

In [2]: s = pd.Series(np.arange(12), index=pi)

In [3]: resampled = s.resample('2Q').mean()

In [4]: resampled
Out[4]:
2017Q1    2.5
2017Q3    8.5
Freq: 2Q-DEC, dtype: float64

In [5]: resampled.index
Out[5]: PeriodIndex(['2017Q1', '2017Q3'], dtype='period[2Q-DEC]') 
```

上采样并调用`.ohlc()`之前返回一个`Series`，基本上与调用`.asfreq()`相同。OHLC 上采样现在返回一个具有列`open`、`high`、`low`和`close`的 DataFrame ([GH 13083](https://github.com/pandas-dev/pandas/issues/13083))。这与下采样和`DatetimeIndex`的行为一致。

以前行为：

```py
In [1]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)

In [2]: s = pd.Series(np.arange(10), index=pi)

In [3]: s.resample('H').ohlc()
Out[3]:
2000-01-01 00:00    0.0
 ...
2000-01-10 23:00    NaN
Freq: H, Length: 240, dtype: float64

In [4]: s.resample('M').ohlc()
Out[4]:
 open  high  low  close
2000-01     0     9    0      9 
```

新行为：

```py
In [56]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)

In [57]: s = pd.Series(np.arange(10), index=pi)

In [58]: s.resample('H').ohlc()
Out[58]:
 open  high  low  close
2000-01-01 00:00   0.0   0.0  0.0    0.0
2000-01-01 01:00   NaN   NaN  NaN    NaN
2000-01-01 02:00   NaN   NaN  NaN    NaN
2000-01-01 03:00   NaN   NaN  NaN    NaN
2000-01-01 04:00   NaN   NaN  NaN    NaN
...                ...   ...  ...    ...
2000-01-10 19:00   NaN   NaN  NaN    NaN
2000-01-10 20:00   NaN   NaN  NaN    NaN
2000-01-10 21:00   NaN   NaN  NaN    NaN
2000-01-10 22:00   NaN   NaN  NaN    NaN
2000-01-10 23:00   NaN   NaN  NaN    NaN

[240 rows x 4 columns]

In [59]: s.resample('M').ohlc()
Out[59]:
 open  high  low  close
2000-01     0     9    0      9

[1 rows x 4 columns] 
```

### 在 pd.eval 中改进的错误处理

`eval()` 现在将在项分配失效或指定了原地操作但表达式中没有项分配时引发`ValueError` ([GH 16732](https://github.com/pandas-dev/pandas/issues/16732))

```py
In [51]: arr = np.array([1, 2, 3]) 
```

以前，如果尝试以下表达式，则会收到一个不是很有用的错误消息：

```py
In [3]: pd.eval("a = 1 + 2", target=arr, inplace=True)
...
IndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`)
and integer or boolean arrays are valid indices 
```

这是说 numpy 数组不支持字符串项索引的一种很长的方式。随着这个改变，错误消息现在是这样的：

```py
In [3]: pd.eval("a = 1 + 2", target=arr, inplace=True)
...
ValueError: Cannot assign expression output to target 
```

即使没有项目赋值，也曾经可以对表达式进行原地评估：

```py
In [4]: pd.eval("1 + 2", target=arr, inplace=True)
Out[4]: 3 
```

然而，这个输入并没有太多意义，因为输出没有被分配给目标。现在，当传入这样的输入时，将会引发`ValueError`：

```py
In [4]: pd.eval("1 + 2", target=arr, inplace=True)
...
ValueError: Cannot operate inplace if there is no assignment 
```

### Dtype 转换

先前的分配、`.where()`和`.fillna()`与`bool`赋值，会强制转换为相同的类型（例如 int / float），或对于 datetimelikes 会引发错误。这些现在将保留具有`object` dtypes 的布尔值。 ([GH 16821](https://github.com/pandas-dev/pandas/issues/16821)).

```py
In [52]: s = pd.Series([1, 2, 3]) 
```

```py
In [5]: s[1] = True

In [6]: s
Out[6]:
0    1
1    1
2    3
dtype: int64 
```

新行为

```py
In [7]: s[1] = True

In [8]: s
Out[8]:
0       1
1    True
2       3
Length: 3, dtype: object 
```

以前，对具有非 datetimelike 的 datetimelike 进行赋值会强制转换为正在分配的非 datetimelike 项 ([GH 14145](https://github.com/pandas-dev/pandas/issues/14145)).

```py
In [53]: s = pd.Series([pd.Timestamp('2011-01-01'), pd.Timestamp('2012-01-01')]) 
```

```py
In [1]: s[1] = 1

In [2]: s
Out[2]:
0   2011-01-01 00:00:00.000000000
1   1970-01-01 00:00:00.000000001
dtype: datetime64[ns] 
```

这些现在会强制转换为`object` dtype。

```py
In [1]: s[1] = 1

In [2]: s
Out[2]:
0    2011-01-01 00:00:00
1                      1
dtype: object 
```

+   `.where()`中的 datetimelike 存在不一致的行为，会引发而不是强制转换为`object` ([GH 16402](https://github.com/pandas-dev/pandas/issues/16402))

+   对`float64` dtype 的`np.ndarray`进行`int64`数据的赋值可能会保持`int64` dtype ([GH 14001](https://github.com/pandas-dev/pandas/issues/14001))

### 单级别的 MultiIndex 构造函数

`MultiIndex` 构造函数不再将具有所有长度为一级别的 MultiIndex 压缩为常规`Index`。这会影响到所有`MultiIndex` 构造函数。 ([GH 17178](https://github.com/pandas-dev/pandas/issues/17178))

先前的行为:

```py
In [2]: pd.MultiIndex.from_tuples([('a',), ('b',)])
Out[2]: Index(['a', 'b'], dtype='object') 
```

长度为 1 的级别不再被特殊处理。它们的行为与长度为 2+ 级别的行为完全相同，因此所有`MultiIndex` 构造函数都将返回`MultiIndex`:

```py
In [54]: pd.MultiIndex.from_tuples([('a',), ('b',)])
Out[54]: 
MultiIndex([('a',),
 ('b',)],
 ) 
```

### Series 的 UTC 本地化

以前，当传递`utc=True`时，`to_datetime()`不会对 datetime `Series` 数据进行本地化。现在，当`to_datetime()`](../reference/api/pandas.to_datetime.html#pandas.to_datetime "pandas.to_datetime")将正确地对 `datetime64[ns, UTC]` dtype 的`Series` 进行本地化，以与处理类似列表和`Index`数据的方式保持一致。 ([GH 6415](https://github.com/pandas-dev/pandas/issues/6415)).

先前的行为

```py
In [55]: s = pd.Series(['20130101 00:00:00'] * 3) 
```

```py
In [12]: pd.to_datetime(s, utc=True)
Out[12]:
0   2013-01-01
1   2013-01-01
2   2013-01-01
dtype: datetime64[ns] 
```

新行为

```py
In [56]: pd.to_datetime(s, utc=True)
Out[56]: 
0   2013-01-01 00:00:00+00:00
1   2013-01-01 00:00:00+00:00
2   2013-01-01 00:00:00+00:00
Length: 3, dtype: datetime64[ns, UTC] 
```

此外，由`read_sql_table()`和`read_sql_query()`解析的具有 datetime 列的 DataFrame，如果原始 SQL 列是时区感知的 datetime 列，则也将被本地化为 UTC。

### 范围函数的一致性

在之前的版本中，各种范围函数之间存在一些不一致性：`date_range()`、`bdate_range()`、`period_range()`、`timedelta_range()`和`interval_range()`。 ([GH 17471](https://github.com/pandas-dev/pandas/issues/17471))。

当`start`、`end`和`period`参数都指定时，出现了不一致的行为，可能导致范围模糊不清。当传递了所有三个参数时，`interval_range`忽略了`period`参数，`period_range`忽略了`end`参数，而其他范围函数则会引发错误。为了促进范围函数之间的一致性，并避免潜在的模糊范围，当传递了所有三个参数时，`interval_range`和`period_range`现在将引发错误。

以前的行为：

```py
 In [2]: pd.interval_range(start=0, end=4, periods=6)
 Out[2]:
 IntervalIndex([(0, 1], (1, 2], (2, 3]]
 closed='right',
 dtype='interval[int64]')

In [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')
Out[3]: PeriodIndex(['2017Q1', '2017Q2', '2017Q3', '2017Q4', '2018Q1', '2018Q2'], dtype='period[Q-DEC]', freq='Q-DEC') 
```

新行为：

```py
In [2]: pd.interval_range(start=0, end=4, periods=6)
---------------------------------------------------------------------------
ValueError: Of the three parameters: start, end, and periods, exactly two must be specified

In [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')
---------------------------------------------------------------------------
ValueError: Of the three parameters: start, end, and periods, exactly two must be specified 
```

另外，`interval_range`产生的间隔中未包括端点参数`end`。然而，所有其他范围函数都包括`end`在它们的输出中。为了促进范围函数之间的一致性，`interval_range`现在将`end`包括在最后一个间隔的右端点中，除非以一种跳过`end`的方式指定了`freq`。

以前的行为：

```py
In [4]: pd.interval_range(start=0, end=4)
Out[4]:
IntervalIndex([(0, 1], (1, 2], (2, 3]]
 closed='right',
 dtype='interval[int64]') 
```

新行为：

```py
In [57]: pd.interval_range(start=0, end=4)
Out[57]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4]], dtype='interval[int64, right]') 
```

### 没有自动的 Matplotlib 转换器

当 pandas 被导入时，pandas 不再注册我们的`date`、`time`、`datetime`、`datetime64`和`Period`转换器到 matplotlib。Matplotlib 绘图方法（`plt.plot`、`ax.plot`等）不会对`DatetimeIndex`或`PeriodIndex`值的 x 轴进行漂亮的格式化。您必须显式注册这些方法：

pandas 内置的`Series.plot`和`DataFrame.plot`在首次使用时*会*注册这些转换器 ([GH 17710](https://github.com/pandas-dev/pandas/issues/17710))。

注：

这个改变在 pandas 0.21.1 中暂时被撤销，更多详情请参见这里。

### 其他 API 变更

+   Categorical 构造函数不再接受`categories`关键字的标量。 ([GH 16022](https://github.com/pandas-dev/pandas/issues/16022))

+   在关闭的`HDFStore`上访问不存在的属性将引发`AttributeError`，而不是`ClosedFileError` ([GH 16301](https://github.com/pandas-dev/pandas/issues/16301))

+   `read_csv()`现在如果`names`参数包含重复项，会发出`UserWarning` ([GH 17095](https://github.com/pandas-dev/pandas/issues/17095))

+   `read_csv()`现在默认将`'null'`和`'n/a'`字符串视为缺失值 ([GH 16471](https://github.com/pandas-dev/pandas/issues/16471), [GH 16078](https://github.com/pandas-dev/pandas/issues/16078))

+   `pandas.HDFStore`的字符串表示现在更快且更简洁。要保留以前的行为，请使用`pandas.HDFStore.info()`。([GH 16503](https://github.com/pandas-dev/pandas/issues/16503)).

+   HDF 存储中的压缩默认值现在遵循 pytables 标准。默认情况下不压缩，如果`complib`缺失且`complevel` > 0，则使用`zlib` ([GH 15943](https://github.com/pandas-dev/pandas/issues/15943))

+   `Index.get_indexer_non_unique()`现在返回一个 ndarray 索引器，而不是一个`Index`；这与`Index.get_indexer()`保持一致 ([GH 16819](https://github.com/pandas-dev/pandas/issues/16819))

+   从`pandas._testing`中删除了`@slow`装饰器，这导致一些下游软件包的测试套件出现问题。改用`@pytest.mark.slow`，它可以实现相同的功能 ([GH 16850](https://github.com/pandas-dev/pandas/issues/16850))

+   将`MergeError`的定义移动到`pandas.errors`模块中。

+   `Series.set_axis()`和`DataFrame.set_axis()`的签名已从`set_axis(axis, labels)`更改为`set_axis(labels, axis=0)`，以保持与 API 的一致性。旧的签名已被弃用，并将显示`FutureWarning` ([GH 14636](https://github.com/pandas-dev/pandas/issues/14636))

+   `Series.argmin()`和`Series.argmax()`现在在与`object` dtypes 一起使用时会引发`TypeError`，而不是`ValueError` ([GH 13595](https://github.com/pandas-dev/pandas/issues/13595))

+   `Period`现在是不可变的，当用户尝试为`ordinal`或`freq`属性分配新值时，将引发`AttributeError` ([GH 17116](https://github.com/pandas-dev/pandas/issues/17116)).

+   `to_datetime()`在传递了 tz-aware `origin=` kwarg 时，现在会引发更具信息性的`ValueError`而不是`TypeError` ([GH 16842](https://github.com/pandas-dev/pandas/issues/16842))

+   `to_datetime()`现在在格式中包含`%W`或`%U`但没有包含星期几和日历年时会引发`ValueError` ([GH 16774](https://github.com/pandas-dev/pandas/issues/16774))

+   在 `read_stata()` 中将非功能性的 `index` 重命名为 `index_col`，以提高 API 的一致性（[GH 16342](https://github.com/pandas-dev/pandas/issues/16342)）。

+   在 `DataFrame.drop()` 中的错误导致布尔标签 `False` 和 `True` 被视为分别从数字索引中删除索引 0 和 1。现在将引发 ValueError 错误（[GH 16877](https://github.com/pandas-dev/pandas/issues/16877)）。

+   限制了 DateOffset 关键字参数。以前，`DateOffset` 子类允许任意关键字参数，这可能导致意外行为。现在，只有有效的参数将被接受（[GH 17176](https://github.com/pandas-dev/pandas/issues/17176)）。

## 弃用

+   `DataFrame.from_csv()` 和 `Series.from_csv()` 已经弃用，改为使用 `read_csv()`（[GH 4191](https://github.com/pandas-dev/pandas/issues/4191)）。

+   `read_excel()` 已经弃用了 `sheetname`，改为使用 `sheet_name` 以保持与 `.to_excel()` 的一致性（[GH 10559](https://github.com/pandas-dev/pandas/issues/10559)）。

+   `read_excel()` 已经弃用了 `parse_cols`，改为使用 `usecols` 以保持与 `read_csv()` 的一致性（[GH 4988](https://github.com/pandas-dev/pandas/issues/4988)）。

+   `read_csv()` 已经弃用了 `tupleize_cols` 参数。列元组将始终转换为 `MultiIndex`（[GH 17060](https://github.com/pandas-dev/pandas/issues/17060)）。

+   `DataFrame.to_csv()` 已经弃用了 `tupleize_cols` 参数。MultiIndex 列将始终以行的形式写入 CSV 文件中（[GH 17060](https://github.com/pandas-dev/pandas/issues/17060)）。

+   `.take()` 方法中的 `convert` 参数已被弃用，因为它没有被遵守（[GH 16948](https://github.com/pandas-dev/pandas/issues/16948)）。

+   `pd.options.html.border` 已经弃用，改为使用 `pd.options.display.html.border`（[GH 15793](https://github.com/pandas-dev/pandas/issues/15793)）。

+   `SeriesGroupBy.nth()` 已经弃用 `True`，而是使用了 `dropna` 的关键字参数 ``'all'``（[GH 11038](https://github.com/pandas-dev/pandas/issues/11038)）。

+   `DataFrame.as_blocks()` 已经弃用，因为这暴露了内部实现（[GH 17302](https://github.com/pandas-dev/pandas/issues/17302)）。

+   `pd.TimeGrouper` 已被弃用，建议使用 `pandas.Grouper` ([GH 16747](https://github.com/pandas-dev/pandas/issues/16747))

+   `cdate_range` 已被弃用，建议使用 `bdate_range()`，它已获得 `weekmask` 和 `holidays` 参数，用于构建自定义频率日期范围。详细信息请参见文档 ([GH 17596](https://github.com/pandas-dev/pandas/issues/17596))

+   在 `Series.astype()` 中传递 `categories` 或 `ordered` kwargs 已被弃用，建议传递 CategoricalDtype ([GH 17636](https://github.com/pandas-dev/pandas/issues/17636))

+   `Series`、`DataFrame`、`Panel`、`SparseSeries` 和 `SparseDataFrame` 上的 `.get_value` 和 `.set_value` 已被弃用，建议使用 `.iat[]` 或 `.at[]` 访问器 ([GH 15269](https://github.com/pandas-dev/pandas/issues/15269))

+   在 `.to_excel(..., columns=)` 中传递一个不存在的列已被弃用，并将在未来引发 `KeyError` ([GH 17295](https://github.com/pandas-dev/pandas/issues/17295))

+   `raise_on_error` 参数已被弃用，建议使用 `errors=`，适用于 `Series.where()`、`Series.mask()`、`DataFrame.where()` 和 `DataFrame.mask()` ([GH 14968](https://github.com/pandas-dev/pandas/issues/14968))

+   现在已弃用使用 `DataFrame.rename_axis()` 和 `Series.rename_axis()` 修改索引或列 *标签*，建议使用 `.rename`。`rename_axis` 仍可用于修改索引或列的名称 ([GH 17833](https://github.com/pandas-dev/pandas/issues/17833)).

+   `reindex_axis()` 已被弃用，建议使用 `reindex()`。详见此处 ([GH 17833](https://github.com/pandas-dev/pandas/issues/17833)).

### Series.select 和 DataFrame.select

`Series.select()` 和 `DataFrame.select()` 方法已被弃用，建议使用 `df.loc[labels.map(crit)]` ([GH 12401](https://github.com/pandas-dev/pandas/issues/12401))

```py
In [58]: df = pd.DataFrame({'A': [1, 2, 3]}, index=['foo', 'bar', 'baz']) 
```

```py
In [3]: df.select(lambda x: x in ['bar', 'baz'])
FutureWarning: select is deprecated and will be removed in a future release. You can use .loc[crit] as a replacement
Out[3]:
 A
bar  2
baz  3 
```

```py
In [59]: df.loc[df.index.map(lambda x: x in ['bar', 'baz'])]
Out[59]: 
 A
bar  2
baz  3

[2 rows x 1 columns] 
```  ### Series.argmax 和 Series.argmin

`Series.argmax()` 和 `Series.argmin()` 的行为已弃用，推荐使用 `Series.idxmax()` 和 `Series.idxmin()` ([GH 16830](https://github.com/pandas-dev/pandas/issues/16830))。

为了与 NumPy 数组兼容，`pd.Series` 实现了 `argmax` 和 `argmin`。自 pandas 0.13.0 起，`argmax` 成为 `pandas.Series.idxmax()` 的别名，`argmin` 成为 `pandas.Series.idxmin()` 的别名。它们返回的是*标签*，而不是*位置*。

我们已弃用了 `Series.argmax` 和 `Series.argmin` 的当前行为。使用其中任何一个将会发出 `FutureWarning`。如果你想要最大值的标签，请使用 `Series.idxmax()`。如果你想要最大值的位置，请使用 `Series.values.argmax()`。最小值同理。在未来的发布中，`Series.argmax` 和 `Series.argmin` 将返回最大值或最小值的位置。### Series.select 和 DataFrame.select

`Series.select()` 和 `DataFrame.select()` 方法已弃用，推荐使用 `df.loc[labels.map(crit)]` ([GH 12401](https://github.com/pandas-dev/pandas/issues/12401))

```py
In [58]: df = pd.DataFrame({'A': [1, 2, 3]}, index=['foo', 'bar', 'baz']) 
```

```py
In [3]: df.select(lambda x: x in ['bar', 'baz'])
FutureWarning: select is deprecated and will be removed in a future release. You can use .loc[crit] as a replacement
Out[3]:
 A
bar  2
baz  3 
```

```py
In [59]: df.loc[df.index.map(lambda x: x in ['bar', 'baz'])]
Out[59]: 
 A
bar  2
baz  3

[2 rows x 1 columns] 
```

### Series.argmax 和 Series.argmin

`Series.argmax()` 和 `Series.argmin()` 的行为已弃用，推荐使用 `Series.idxmax()` 和 `Series.idxmin()` ([GH 16830](https://github.com/pandas-dev/pandas/issues/16830))。

为了与 NumPy 数组兼容，`pd.Series` 实现了 `argmax` 和 `argmin`。自 pandas 0.13.0 起，`argmax` 成为 `pandas.Series.idxmax()` 的别名，`argmin` 成为 `pandas.Series.idxmin()` 的别名。它们返回的是*标签*，而不是*位置*。

我们已经废弃了 `Series.argmax` 和 `Series.argmin` 的当前行为。使用任何一个将会发出 `FutureWarning`。如果你想要最大值的标签，请使用 `Series.idxmax()`。如果你想要最大值的位置，请使用 `Series.values.argmax()`。最小值同理。在将来的版本中，`Series.argmax` 和 `Series.argmin` 将返回最大值或最小值的位置。

## 移除之前版本的废弃/更改

+   `read_excel()` 放弃了 `has_index_names` 参数 ([GH 10967](https://github.com/pandas-dev/pandas/issues/10967))

+   `pd.options.display.height` 配置已经被移除 ([GH 3663](https://github.com/pandas-dev/pandas/issues/3663))

+   `pd.options.display.line_width` 配置已经被移除 ([GH 2881](https://github.com/pandas-dev/pandas/issues/2881))

+   `pd.options.display.mpl_style` 配置已经被移除 ([GH 12190](https://github.com/pandas-dev/pandas/issues/12190))

+   `Index` 已经放弃了 `.sym_diff()` 方法，转而使用 `.symmetric_difference()` ([GH 12591](https://github.com/pandas-dev/pandas/issues/12591))

+   `Categorical` 放弃了 `.order()` 和 `.sort()` 方法，转而使用 `.sort_values()` ([GH 12882](https://github.com/pandas-dev/pandas/issues/12882))

+   `eval()` 和 `DataFrame.eval()` 将 `inplace` 的默认值从 `None` 更改为 `False` ([GH 11149](https://github.com/pandas-dev/pandas/issues/11149))

+   函数 `get_offset_name` 已被放弃，转而使用偏移量的 `.freqstr` 属性 ([GH 11834](https://github.com/pandas-dev/pandas/issues/11834))

+   pandas 不再测试与 pandas < 0.11 创建的 hdf5 文件兼容性 ([GH 17404](https://github.com/pandas-dev/pandas/issues/17404)).

## 性能改进

+   实例化 `SparseDataFrame` 的性能得到了提升 ([GH 16773](https://github.com/pandas-dev/pandas/issues/16773))

+   `Series.dt` 不再进行频率推断，访问属性时速度大幅提升 ([GH 17210](https://github.com/pandas-dev/pandas/issues/17210))

+   通过不实例化值来提升 `set_categories()` 的性能 ([GH 17508](https://github.com/pandas-dev/pandas/issues/17508))

+   `Timestamp.microsecond` 不再在属性访问时重新计算 ([GH 17331](https://github.com/pandas-dev/pandas/issues/17331))

+   改进了对已经是分类数据类型的数据的`CategoricalIndex`的性能（[GH 17513](https://github.com/pandas-dev/pandas/issues/17513)）

+   通过使用`RangeIndex`属性执行计算，改进了`RangeIndex.min()`和`RangeIndex.max()`的性能（[GH 17607](https://github.com/pandas-dev/pandas/issues/17607)）

## 文档更改

+   几个`NaT`方法的文档字符串（例如`NaT.ctime()`）是不正确的（[GH 17327](https://github.com/pandas-dev/pandas/issues/17327)）

+   文档已删除并清理了对版本小于 v0.17 的引用（[GH 17442](https://github.com/pandas-dev/pandas/issues/17442)，[GH 17442](https://github.com/pandas-dev/pandas/issues/17442)，[GH 17404](https://github.com/pandas-dev/pandas/issues/17404) & [GH 17504](https://github.com/pandas-dev/pandas/issues/17504))

## Bug 修复

### 转换

+   当对类似于日期时间的数据进行整数赋值时可能会错误地转换为日期时间类型（[GH 14145](https://github.com/pandas-dev/pandas/issues/14145)）

+   当使用`float64`数据类型的`np.ndarray`对`int64`数据进行赋值时可能会保留`int64`数据类型（[GH 14001](https://github.com/pandas-dev/pandas/issues/14001)）

+   将`IntervalIndex.is_non_overlapping_monotonic`的返回类型更改为 Python 的`bool`，以保持与类似属性/方法的一致性。之前返回的是`numpy.bool_`（[GH 17237](https://github.com/pandas-dev/pandas/issues/17237)）

+   当区间两端都闭合且在某一点重叠时，`IntervalIndex.is_non_overlapping_monotonic`存在 bug（[GH 16560](https://github.com/pandas-dev/pandas/issues/16560)）

+   当`inplace=True`且`value`为字典时，修复了`Series.fillna()`在返回帧时的 bug（[GH 16156](https://github.com/pandas-dev/pandas/issues/16156)）

+   当本地化到时区时，`Timestamp.weekday_name`存在 bug，返回基于 UTC 的星期几名称（[GH 17354](https://github.com/pandas-dev/pandas/issues/17354)）

+   在替换`tzinfo`时`Timestamp.replace`存在 bug，特别是在夏令时变化时（[GH 15683](https://github.com/pandas-dev/pandas/issues/15683)）

+   修复了`Timedelta`构造和算术中不会传播`Overflow`异常的 bug（[GH 17367](https://github.com/pandas-dev/pandas/issues/17367)）

+   当传递扩展类型类（`DatetimeTZDtype`，`CategoricalDtype`）而不是实例时，修复了`astype()`转换为对象数据类型的 bug。现在当传递类时会引发`TypeError`（[GH 17780](https://github.com/pandas-dev/pandas/issues/17780)）

+   `to_numeric()` 中的 Bug，在使用 `errors='coerce'` 时，元素并非始终被强制转换为数值类型 ([GH 17007](https://github.com/pandas-dev/pandas/issues/17007), [GH 17125](https://github.com/pandas-dev/pandas/issues/17125))

+   在 `DataFrame` 和 `Series` 构造函数中，将 `range` 对象转换为 `int32` dtype 而不是 `int64` 在 Windows 上 ([GH 16804](https://github.com/pandas-dev/pandas/issues/16804))

### 索引

+   当使用空切片调用时（例如 `df.iloc[:]`），`.iloc` 和 `.loc` 索引器将返回原始对象的浅拷贝。之前它们返回的是原始对象。([GH 13873](https://github.com/pandas-dev/pandas/issues/13873)).

+   当在未排序的 `MultiIndex` 上调用时，`loc` 索引器现在只会在非排序级别上使用适当的切片时引发 `UnsortedIndexError` ([GH 16734](https://github.com/pandas-dev/pandas/issues/16734)).

+   在 0.20.3 中，使用字符串进行 `TimedeltaIndex` 索引时，修复了回归问题 ([GH 16896](https://github.com/pandas-dev/pandas/issues/16896)).

+   修复了 `TimedeltaIndex.get_loc()` 对 `np.timedelta64` 输入的处理问题 ([GH 16909](https://github.com/pandas-dev/pandas/issues/16909)).

+   修复了在 `MultiIndex.sort_index()` 中，当 `ascending` 参数为列表，但未指定所有级别，或者级别顺序不同时的排序问题 ([GH 16934](https://github.com/pandas-dev/pandas/issues/16934)).

+   修复了使用 `np.inf` 进行索引时引发 `OverflowError` 的 bug ([GH 16957](https://github.com/pandas-dev/pandas/issues/16957))

+   在空的 `CategoricalIndex` 上重新索引的 bug ([GH 16770](https://github.com/pandas-dev/pandas/issues/16770))

+   修复了使用对齐和具有时区感知的 `DatetimeIndex` 进行设置的 `DataFrame.loc` ([GH 16889](https://github.com/pandas-dev/pandas/issues/16889))

+   当向 `.iloc` 传递 Index 或 Series 时，避免了旧版本 numpy 中的 `IndexError` ([GH 17193](https://github.com/pandas-dev/pandas/issues/17193))

+   允许在 Python 2 中，多级列中使用 Unicode 空字符串作为占位符 ([GH 17099](https://github.com/pandas-dev/pandas/issues/17099))

+   在 `.iloc` 与 `MultiIndex` 结合使用时，进行就地加法或赋值，并使用整数索引器时，会导致从错误的索引中读取和写入 ([GH 17148](https://github.com/pandas-dev/pandas/issues/17148))。

+   `.isin()` 中的 bug，当检查空 `Series` 对象中的成员资格时，引发错误 ([GH 16991](https://github.com/pandas-dev/pandas/issues/16991))

+   在 `CategoricalIndex` 重新索引中的 bug，在指定包含重复的索引时未被尊重 ([GH 17323](https://github.com/pandas-dev/pandas/issues/17323))

+   与负步长的 `RangeIndex` 的交集中的 bug ([GH 17296](https://github.com/pandas-dev/pandas/issues/17296))

+   `IntervalIndex` 中存在的 bug，在执行标量查找时，对于非重叠的单调递减索引的包含右端点会失败 ([GH 16417](https://github.com/pandas-dev/pandas/issues/16417), [GH 17271](https://github.com/pandas-dev/pandas/issues/17271))

+   `DataFrame.first_valid_index()` 和 `DataFrame.last_valid_index()` 存在的 bug，当不存在有效条目时 ([GH 17400](https://github.com/pandas-dev/pandas/issues/17400))

+   `Series.rename()` 中存在的 bug，在使用可调用对象调用时，会错误地改变 `Series` 的名称，而不是 `Index` 的名称。 ([GH 17407](https://github.com/pandas-dev/pandas/issues/17407))

+   `String.str_get()` 中存在的 bug，在使用负索引时，会引发 `IndexError`，而不是插入 NaNs。 ([GH 17704](https://github.com/pandas-dev/pandas/issues/17704))

### IO

+   `read_hdf()` 在从 `fixed` 格式 HDFStore 读取时，存在 bug，读取时区感知索引时出现问题 ([GH 17618](https://github.com/pandas-dev/pandas/issues/17618))

+   `read_csv()` 存在的 bug，列没有彻底去重 ([GH 17060](https://github.com/pandas-dev/pandas/issues/17060))

+   `read_csv()` 中存在的 bug，指定的列名没有彻底去重 ([GH 17095](https://github.com/pandas-dev/pandas/issues/17095))

+   `read_csv()` 中存在的 bug，对于头部参数的非整数值会生成一个无用/无关的错误消息 ([GH 16338](https://github.com/pandas-dev/pandas/issues/16338))

+   `read_csv()` 中存在的 bug，在异常处理中存在内存管理问题，特定条件下会导致解释器发生段错误 ([GH 14696](https://github.com/pandas-dev/pandas/issues/14696), [GH 16798](https://github.com/pandas-dev/pandas/issues/16798)).

+   `read_csv()` 中存在的 bug，使用 `low_memory=False` 调用时，如果 CSV 中至少有一列的大小超过 2GB，会错误地引发 `MemoryError` ([GH 16798](https://github.com/pandas-dev/pandas/issues/16798)).

+   `read_csv()` 中存在的 bug，使用单元素列表 `header` 调用时会返回所有 NaN 值的 `DataFrame` ([GH 7757](https://github.com/pandas-dev/pandas/issues/7757))

+   在 Python 3 中，默认为‘ascii’编码，而不是‘utf-8’的`DataFrame.to_csv()`中存在错误 ([GH 17097](https://github.com/pandas-dev/pandas/issues/17097))

+   在使用迭代器时，`read_stata()`中无法读取值标签 ([GH 16923](https://github.com/pandas-dev/pandas/issues/16923))

+   在`read_stata()`中未设置索引 ([GH 16342](https://github.com/pandas-dev/pandas/issues/16342))

+   在多线程运行时，`read_html()`中的导入检查失败 ([GH 16928](https://github.com/pandas-dev/pandas/issues/16928))

+   在自动分隔符检测引发`TypeError`而不是正确的错误消息时，在`read_csv()`中存在错误 ([GH 13374](https://github.com/pandas-dev/pandas/issues/13374))

+   在`DataFrame.to_html()`中，当`notebook=True`时，具有命名索引或非多重索引索引的 DataFrame 对于列或行标签的水平或垂直对齐不符合预期 ([GH 16792](https://github.com/pandas-dev/pandas/issues/16792))

+   在`DataFrame.to_html()`中存在错误，没有验证`justify`参数 ([GH 17527](https://github.com/pandas-dev/pandas/issues/17527))

+   在读取包含 VLArray 的连续混合数据表时，`HDFStore.select()`中存在错误 ([GH 17021](https://github.com/pandas-dev/pandas/issues/17021))

+   在`to_json()`中存在错误，其中几种条件（包括具有不可打印符号的对象、具有深度递归的对象、过长的标签等）导致段错误而不是引发适当的异常 ([GH 14256](https://github.com/pandas-dev/pandas/issues/14256))

### 绘图

+   使用`secondary_y`和`fontsize`的绘图方法中存在错误，未设置次要轴字体大小 ([GH 12565](https://github.com/pandas-dev/pandas/issues/12565))

+   当在 y 轴上绘制`timedelta`和`datetime`类型时出现错误 ([GH 16953](https://github.com/pandas-dev/pandas/issues/16953))

+   在计算 xlims 时，线图不再假定 x 数据单调递增，它们现在会显示整个线条，即使 x 数据未排序。 ([GH 11310](https://github.com/pandas-dev/pandas/issues/11310), [GH 11471](https://github.com/pandas-dev/pandas/issues/11471))

+   在 matplotlib 2.0.0 及以上版本中，对于线图的 x 轴限制的计算由 matplotlib 处理，以便应用其新的默认设置。（[GH 15495](https://github.com/pandas-dev/pandas/issues/15495)）

+   在 `Series.plot.bar` 或 `DataFrame.plot.bar` 中，`y` 参数不遵循用户传递的 `color` 的 Bug（[GH 16822](https://github.com/pandas-dev/pandas/issues/16822)）

+   当使用随机颜色时，`plotting.parallel_coordinates` 导致重置随机种子的 Bug（[GH 17525](https://github.com/pandas-dev/pandas/issues/17525)）

### GroupBy/resample/rolling

+   在 `DataFrame.resample(...).size()` 中存在 Bug，其中空 `DataFrame` 没有返回 `Series`（[GH 14962](https://github.com/pandas-dev/pandas/issues/14962)）

+   `infer_freq()` 中的 Bug 导致在工作周内具有 2 天间隔的索引被错误地推断为工作日（[GH 16624](https://github.com/pandas-dev/pandas/issues/16624)）

+   在 `.rolling(...).quantile()` 中，使用的默认值与 `Series.quantile()` 和 `DataFrame.quantile()` 不同（[GH 9413](https://github.com/pandas-dev/pandas/issues/9413), [GH 16211](https://github.com/pandas-dev/pandas/issues/16211)）

+   `groupby.transform()` 中存在的 Bug 会将布尔类型的数据强制转换为浮点数（[GH 16875](https://github.com/pandas-dev/pandas/issues/16875)）

+   在 `Series.resample(...).apply()` 中存在 Bug，其中空 `Series` 修改了源索引并且没有返回 `Series` 的名称（[GH 14313](https://github.com/pandas-dev/pandas/issues/14313)）

+   在具有 `DatetimeIndex`、时间间隔可转换的 `window` 和 `min_periods >= 1` 的 `DataFrame` 上使用 `.rolling(...).apply(...)` 存在 Bug（[GH 15305](https://github.com/pandas-dev/pandas/issues/15305)）

+   在 `DataFrame.groupby` 中，当键的数量等于分组轴上的元素数量时，无法正确识别索引和列键（[GH 16859](https://github.com/pandas-dev/pandas/issues/16859)）

+   `TimeGrouper` 中的 `groupby.nunique()` 存在 Bug，无法正确处理 `NaT`（[GH 17575](https://github.com/pandas-dev/pandas/issues/17575)）

+   在 `DataFrame.groupby` 中，从 `MultiIndex` 进行单级选择时，会意外地进行排序（[GH 17537](https://github.com/pandas-dev/pandas/issues/17537)）

+   在 `DataFrame.groupby` 中，当使用 `Grouper` 对象来覆盖模糊的列名时，会引发虚假警告的 Bug（[GH 17383](https://github.com/pandas-dev/pandas/issues/17383)）

+   `TimeGrouper` 中的 Bug 在作为列表和标量传递时会有所不同（[GH 17530](https://github.com/pandas-dev/pandas/issues/17530)）

### Sparse

+   当将字典传递给 `SparseSeries` 时，会引发 `AttributeError` 的 Bug（[GH 16905](https://github.com/pandas-dev/pandas/issues/16905)）

+   在`SparseDataFrame.fillna()`中存在错误，当框架是从 SciPy 稀疏矩阵实例化时，未填充所有 NaN 值（[GH 16112](https://github.com/pandas-dev/pandas/issues/16112)）。

+   在`SparseSeries.unstack()`和`SparseDataFrame.stack()`中存在错误（[GH 16614](https://github.com/pandas-dev/pandas/issues/16614)，[GH 15045](https://github.com/pandas-dev/pandas/issues/15045)）。

+   在`make_sparse()`中存在错误，当数组`dtype`为`object`时，处理两个具有相同位的数字/布尔数据时被视为相同（[GH 17574](https://github.com/pandas-dev/pandas/issues/17574)）。

+   `SparseArray.all()`和`SparseArray.any()`现在已实现以处理`SparseArray`，这些函数以前被使用但未实现（[GH 17570](https://github.com/pandas-dev/pandas/issues/17570)）。

### 重塑

+   使用非唯一`PeriodIndex`进行连接/合并引发了`TypeError`（[GH 16871](https://github.com/pandas-dev/pandas/issues/16871)）。

+   在`crosstab()`中存在错误，当整数的非对齐系列被转换为浮点数时（[GH 17005](https://github.com/pandas-dev/pandas/issues/17005)）。

+   在与分类数据类型和 datetimelikes 合并时，存在错误，错误地引发了`TypeError`（[GH 16900](https://github.com/pandas-dev/pandas/issues/16900)）。

+   当在大型对象系列和大型比较数组上使用`isin()`时存在错误（[GH 16012](https://github.com/pandas-dev/pandas/issues/16012)）。

+   从 0.20 版本开始的回归修复，`Series.aggregate()`和`DataFrame.aggregate()`再次允许字典作为返回值（[GH 16741](https://github.com/pandas-dev/pandas/issues/16741)）。

+   修复了输入具有整数 dtype 的结果的 dtype，在使用`margins=True`调用时从`pivot_table()`返回了正确的值（[GH 17013](https://github.com/pandas-dev/pandas/issues/17013)）。

+   在`crosstab()`中存在错误，当传递具有相同名称的两个`Series`时引发了`KeyError`（[GH 13279](https://github.com/pandas-dev/pandas/issues/13279)）。

+   `Series.argmin()`，`Series.argmax()`，以及它们在`DataFrame`和 groupby 对象上的对应功能，对包含无穷值的浮点数据的处理已经正确（[GH 13595](https://github.com/pandas-dev/pandas/issues/13595)）。

+   在`unique()`中存在错误，检查字符串元组时引发了`TypeError`（[GH 17108](https://github.com/pandas-dev/pandas/issues/17108)）。

+   在`concat()`中存在的错误，如果包含不可比较元素，则结果索引的顺序是不可预测的（[GH 17344](https://github.com/pandas-dev/pandas/issues/17344)）

+   修复了在`datetime64` dtype `Series`上按多列排序时出现的回归问题，其中包含`NaT`值（[GH 16836](https://github.com/pandas-dev/pandas/issues/16836)）

+   在`pivot_table()`中存在的错误，当`dropna`为`False`时，结果的列未保留`columns`的分类数据类型（[GH 17842](https://github.com/pandas-dev/pandas/issues/17842)）

+   在`DataFrame.drop_duplicates`中存在的错误，当使用非唯一列名进行删除时会引发`ValueError`错误（[GH 17836](https://github.com/pandas-dev/pandas/issues/17836)）

+   在`unstack()`中存在的错误，当在一组级别上调用时，会丢弃`fillna`参数（[GH 13971](https://github.com/pandas-dev/pandas/issues/13971)）

+   在`DataFrame`中对`range`对象和其他类似列表进行对齐时出现的错误，导致操作是按行而不是按列执行（[GH 17901](https://github.com/pandas-dev/pandas/issues/17901)）

### 数值

+   使用`.clip()`时，当`axis=1`且`threshold`为类似列表时出现的错误；之前会引发`ValueError`错误（[GH 15390](https://github.com/pandas-dev/pandas/issues/15390)）

+   `Series.clip()`和`DataFrame.clip()`现在将上限和下限参数的 NA 值视为`None`，而不是引发`ValueError`错误（[GH 17276](https://github.com/pandas-dev/pandas/issues/17276)）

### 分类数据类型

+   在调用带有分类的`Series.isin()`时出现的错误（[GH 16639](https://github.com/pandas-dev/pandas/issues/16639)）

+   在分类构造函数中存在的错误，当空值和类别导致`.categories`为一个空的`Float64Index`而不是一个空的对象 dtype 为`Index`时（[GH 17248](https://github.com/pandas-dev/pandas/issues/17248)）

+   在使用 Series.cat 进行分类操作时，未保留原始 Series 的名称的错误（[GH 17509](https://github.com/pandas-dev/pandas/issues/17509)）

+   在使用`DataFrame.merge()`时，对具有布尔/整数数据类型的分类列进行合并时出现的错误（[GH 17187](https://github.com/pandas-dev/pandas/issues/17187)）

+   在构建`Categorical`/`CategoricalDtype`时，当指定的`categories`为分类类型时出现的错误（[GH 17884](https://github.com/pandas-dev/pandas/issues/17884)）

### PyPy

+   在 `read_csv()` 中与 PyPy 的兼容性，使用 `usecols=[<unsorted ints>]` 和 `read_json()` ([GH 17351](https://github.com/pandas-dev/pandas/issues/17351))

+   在需要时将测试拆分为 CPython 和 PyPy 用例，突出了与 `float('nan')`，`np.nan` 和 `NAT` 的索引匹配的脆弱性 ([GH 17351](https://github.com/pandas-dev/pandas/issues/17351))

+   修复 `DataFrame.memory_usage()` 以支持 PyPy。PyPy 上的对象没有固定大小，因此使用了近似值 ([GH 17228](https://github.com/pandas-dev/pandas/issues/17228))

### 其他

+   一些 inplace 运算符未被包装并在调用时生成副本的 Bug ([GH 12962](https://github.com/pandas-dev/pandas/issues/12962))

+   `eval()` 中 `inplace` 参数的处理错误的 Bug ([GH 16732](https://github.com/pandas-dev/pandas/issues/16732))

### 转换

+   在使用 `int` 进行赋值时可能会错误地转换为 datetime-like 的 Bug ([GH 14145](https://github.com/pandas-dev/pandas/issues/14145))

+   在使用 `np.ndarray` 和 `float64` dtype 的 `int64` 数据进行赋值时可能会保持 `int64` dtype 的 Bug ([GH 14001](https://github.com/pandas-dev/pandas/issues/14001))

+   修复 `IntervalIndex.is_non_overlapping_monotonic` 的返回类型为 Python `bool` 以保持与类似属性/方法的一致性。之前返回了 `numpy.bool_`。 ([GH 17237](https://github.com/pandas-dev/pandas/issues/17237))

+   当区间两端都关闭并在某一点重叠时 `IntervalIndex.is_non_overlapping_monotonic` 存在 Bug ([GH 16560](https://github.com/pandas-dev/pandas/issues/16560))

+   `Series.fillna()` 的 Bug 在 `inplace=True` 且 `value` 为字典时返回数据框 ([GH 16156](https://github.com/pandas-dev/pandas/issues/16156))

+   `Timestamp.weekday_name` 返回基于 UTC 的工作日名称的 Bug 当本地化为时区时 ([GH 17354](https://github.com/pandas-dev/pandas/issues/17354))

+   `Timestamp.replace` 在替换 `tzinfo` 时围绕 DST 变更时存在 Bug ([GH 15683](https://github.com/pandas-dev/pandas/issues/15683))

+   `Timedelta` 构造和算术中不会传播 `Overflow` 异常的 Bug ([GH 17367](https://github.com/pandas-dev/pandas/issues/17367))

+   在传递扩展类型类（`DatetimeTZDtype`，`CategoricalDtype`）而不是实例时，`astype()` 转换为对象 dtype 的 Bug。现在当传递类时会引发 `TypeError` ([GH 17780](https://github.com/pandas-dev/pandas/issues/17780)).

+   在`to_numeric()`中的 bug 修复，当`errors='coerce'`时，元素不总是被强制转换为数值（[GH 17007](https://github.com/pandas-dev/pandas/issues/17007)，[GH 17125](https://github.com/pandas-dev/pandas/issues/17125)）。

+   在 Windows 上，`DataFrame`和`Series`构造函数中的`range`对象现在会转换为`int32` dtype，而不是`int64`（[GH 16804](https://github.com/pandas-dev/pandas/issues/16804)）。

### 索引

+   当使用空切片（例如`df.iloc[:]`）调用时，`.iloc`和`.loc`索引器返回原始对象的浅层副本。之前它们返回原始对象（[GH 13873](https://github.com/pandas-dev/pandas/issues/13873)）。

+   当在未排序的`MultiIndex`上调用时，`loc`索引器现在仅在对非排序级别使用正确切片时才会引发`UnsortedIndexError`（[GH 16734](https://github.com/pandas-dev/pandas/issues/16734)）。

+   修复了在 0.20.3 版本中，使用字符串索引`TimedeltaIndex`时引发的回归问题（[GH 16896](https://github.com/pandas-dev/pandas/issues/16896)）。

+   修复了`TimedeltaIndex.get_loc()`对`np.timedelta64`输入的处理问题（[GH 16909](https://github.com/pandas-dev/pandas/issues/16909)）。

+   修复了在`ascending`参数为列表但未指定全部级别或顺序不同的情况下，`MultiIndex.sort_index()`排序的顺序问题（[GH 16934](https://github.com/pandas-dev/pandas/issues/16934)）。

+   修复了使用`np.inf`进行索引时引发`OverflowError`的 bug（[GH 16957](https://github.com/pandas-dev/pandas/issues/16957)）。

+   在空`CategoricalIndex`上重新索引时修复了 bug（[GH 16770](https://github.com/pandas-dev/pandas/issues/16770)）。

+   修复了在设置对齐和 tz-aware `DatetimeIndex`时的`DataFrame.loc`问题（[GH 16889](https://github.com/pandas-dev/pandas/issues/16889)）。

+   当使用较旧的 numpy 将 Index 或 Series 传递给`.iloc`时，避免了`IndexError`（[GH 17193](https://github.com/pandas-dev/pandas/issues/17193)）。

+   允许 Python 2 中多级列中使用 Unicode 空字符串作为占位符（[GH 17099](https://github.com/pandas-dev/pandas/issues/17099)）。

+   在`MultiIndex`上使用就地加法或赋值和 int 索引器时引起错误的 bug 修复，导致从错误的索引器读取和写入（[GH 17148](https://github.com/pandas-dev/pandas/issues/17148)）。

+   在`isin()`中的 bug 修复，其中检查空`Series`对象的成员资格引发错误（[GH 16991](https://github.com/pandas-dev/pandas/issues/16991)）。

+   在重新索引`CategoricalIndex`时修复了指定包含重复项的索引未被尊重的问题（[GH 17323](https://github.com/pandas-dev/pandas/issues/17323)）。

+   `RangeIndex`与负步长的交集中的 bug 修复（[GH 17296](https://github.com/pandas-dev/pandas/issues/17296)）。

+   `IntervalIndex` 中的错误，在非重叠单调递减索引的右端点中执行标量查找会失败。([GH 16417](https://github.com/pandas-dev/pandas/issues/16417), [GH 17271](https://github.com/pandas-dev/pandas/issues/17271))

+   `DataFrame.first_valid_index()` 和 `DataFrame.last_valid_index()` 中的错误，当没有有效条目时。([GH 17400](https://github.com/pandas-dev/pandas/issues/17400))

+   `Series.rename()` 中的错误，当调用一个可调用对象时，错误地更改了 `Series` 的名称，而不是 `Index` 的名称。([GH 17407](https://github.com/pandas-dev/pandas/issues/17407))

+   `String.str_get()` 中的错误导致在使用负索引时引发 `IndexError` 而不是插入 NaN。([GH 17704](https://github.com/pandas-dev/pandas/issues/17704))

### IO

+   `read_hdf()` 中的错误，在从 `fixed` 格式的 HDFStore 中读取时，读取一个时区感知的索引。([GH 17618](https://github.com/pandas-dev/pandas/issues/17618))

+   `read_csv()` 中的错误，列没有彻底去重。([GH 17060](https://github.com/pandas-dev/pandas/issues/17060))

+   `read_csv()` 中的错误，指定的列名没有彻底去重。([GH 17095](https://github.com/pandas-dev/pandas/issues/17095))

+   `read_csv()` 中的错误，对于头参数的非整数值会生成一个无关的错误消息。([GH 16338](https://github.com/pandas-dev/pandas/issues/16338))

+   `read_csv()` 中的错误，当内存管理问题在某些条件下引发异常处理时，解释器会段错误。([GH 14696](https://github.com/pandas-dev/pandas/issues/14696), [GH 16798](https://github.com/pandas-dev/pandas/issues/16798)).

+   `read_csv()` 中的错误，当以 `low_memory=False` 调用时，至少一个列大小 > 2GB 的 CSV 会错误地引发 `MemoryError`。([GH 16798](https://github.com/pandas-dev/pandas/issues/16798)).

+   `read_csv()` 中的错误，当使用单元素列表 `header` 调用时，会返回所有 NaN 值的 `DataFrame`。([GH 7757](https://github.com/pandas-dev/pandas/issues/7757))

+   `DataFrame.to_csv()` 中的一个 Bug，在 Python 3 中默认使用 'ascii' 编码，而不是 'utf-8'（[GH 17097](https://github.com/pandas-dev/pandas/issues/17097)）

+   `read_stata()` 中的一个 Bug，使用迭代器时无法读取值标签（[GH 16923](https://github.com/pandas-dev/pandas/issues/16923)）

+   `read_stata()` 中的一个 Bug，未设置索引（[GH 16342](https://github.com/pandas-dev/pandas/issues/16342)）

+   `read_html()` 中的一个 Bug，在多线程运行时导入检查失败（[GH 16928](https://github.com/pandas-dev/pandas/issues/16928)）

+   `read_csv()` 中的一个 Bug，自动检测分隔符导致在遇到错误行时抛出 `TypeError` 而不是正确的错误消息（[GH 13374](https://github.com/pandas-dev/pandas/issues/13374)）

+   `DataFrame.to_html()` 中的一个 Bug，当 `notebook=True` 时，具有命名索引或非 MultiIndex 索引的 DataFrame 的列或行标签具有不希望的水平或垂直对齐（[GH 16792](https://github.com/pandas-dev/pandas/issues/16792)）

+   `DataFrame.to_html()` 存在一个 Bug，即 `justify` 参数没有验证（[GH 17527](https://github.com/pandas-dev/pandas/issues/17527)）

+   在读取包含 VLArray 的连续混合数据表时，`HDFStore.select()` 中存在一个 Bug（[GH 17021](https://github.com/pandas-dev/pandas/issues/17021)）

+   `to_json()` 中的一个 Bug，包括具有不可打印符号的对象、具有深度递归的对象、标签过长等多种条件导致的段错误，而不是引发适当的异常（[GH 14256](https://github.com/pandas-dev/pandas/issues/14256)）

### 绘图

+   使用 `secondary_y` 和 `fontsize` 的绘图方法中存在一个 Bug，未设置次要轴的字体大小（[GH 12565](https://github.com/pandas-dev/pandas/issues/12565)）

+   在 y 轴绘制 `timedelta` 和 `datetime` 数据类型时存在一个 Bug（[GH 16953](https://github.com/pandas-dev/pandas/issues/16953)）

+   线图在计算 xlims 时不再假设 x 数据单调递增，现在即使是未排序的 x 数据也会显示整条线。([GH 11310](https://github.com/pandas-dev/pandas/issues/11310), [GH 11471](https://github.com/pandas-dev/pandas/issues/11471))

+   使用 matplotlib 2.0.0 及以上版本，线图的 x 范围计算由 matplotlib 处理，以便应用其新的默认设置。([GH 15495](https://github.com/pandas-dev/pandas/issues/15495))

+   `Series.plot.bar` 或 `DataFrame.plot.bar` 中的 bug，`y` 不尊重用户传递的 `color` ([GH 16822](https://github.com/pandas-dev/pandas/issues/16822))

+   使用随机颜色时，`plotting.parallel_coordinates` 中的 bug 会重置随机种子 ([GH 17525](https://github.com/pandas-dev/pandas/issues/17525))

### GroupBy/resample/rolling

+   `DataFrame.resample(...).size()` 中的 bug，一个空的 `DataFrame` 没有返回一个 `Series` ([GH 14962](https://github.com/pandas-dev/pandas/issues/14962))

+   `infer_freq()` 中的 bug 导致工作日之间间隔为 2 天的索引被错误地推断为工作日频率 ([GH 16624](https://github.com/pandas-dev/pandas/issues/16624))

+   `.rolling(...).quantile()` 中的 bug 不正确地使用了与 `Series.quantile()` 和 `DataFrame.quantile()` 不同的默认值 ([GH 9413](https://github.com/pandas-dev/pandas/issues/9413), [GH 16211](https://github.com/pandas-dev/pandas/issues/16211))

+   `groupby.transform()` 中的 bug，会将布尔值的 dtype 强制转换为浮点数 ([GH 16875](https://github.com/pandas-dev/pandas/issues/16875))

+   `Series.resample(...).apply()` 中的 bug，其中一个空的 `Series` 修改了源索引并且没有返回一个 `Series` 的名称 ([GH 14313](https://github.com/pandas-dev/pandas/issues/14313))

+   在具有 `DatetimeIndex`、`window` 为 timedelta 可转换且 `min_periods >= 1` 的 `DataFrame` 上使用 `.rolling(...).apply(...)` 中的 bug ([GH 15305](https://github.com/pandas-dev/pandas/issues/15305))

+   `DataFrame.groupby` 中的 bug，当键的数量等于 groupby 轴上的元素数量时，索引和列键没有被正确识别 ([GH 16859](https://github.com/pandas-dev/pandas/issues/16859))

+   `groupby.nunique()` 中的 bug，使用 `TimeGrouper` 无法正确处理 `NaT` ([GH 17575](https://github.com/pandas-dev/pandas/issues/17575))

+   `DataFrame.groupby` 中的 bug，当从 `MultiIndex` 中选择单个级别时，意外地进行排序 ([GH 17537](https://github.com/pandas-dev/pandas/issues/17537))

+   `DataFrame.groupby` 中的 bug，在使用 `Grouper` 对象覆盖模糊的列名时会引发不明确的警告 ([GH 17383](https://github.com/pandas-dev/pandas/issues/17383))

+   `TimeGrouper` 中的 bug 在作为列表和标量传递时会有所不同 ([GH 17530](https://github.com/pandas-dev/pandas/issues/17530))

### Sparse

+   在将字典作为数据传入时，`SparseSeries` 中的 bug 会引发 `AttributeError` ([GH 16905](https://github.com/pandas-dev/pandas/issues/16905))

+   在从 SciPy 稀疏矩阵实例化的情况下，`SparseDataFrame.fillna()`未填充所有 NaN 值的错误（[GH 16112](https://github.com/pandas-dev/pandas/issues/16112)）

+   在`SparseSeries.unstack()`和`SparseDataFrame.stack()`中的错误（[GH 16614](https://github.com/pandas-dev/pandas/issues/16614)，[GH 15045](https://github.com/pandas-dev/pandas/issues/15045)）

+   在`make_sparse()`中的错误处理两个具有相同位的数值/布尔数据，当数组`dtype`为`object`时被视为相同的错误（[GH 17574](https://github.com/pandas-dev/pandas/issues/17574)）

+   `SparseArray.all()`和`SparseArray.any()`现在已实现以处理`SparseArray`，这些方法以前被使用但未实现（[GH 17570](https://github.com/pandas-dev/pandas/issues/17570)）

### 重塑

+   使用非唯一`PeriodIndex`进行连接/合并引发`TypeError`的错误��[GH 16871](https://github.com/pandas-dev/pandas/issues/16871)）

+   在`crosstab()`中的错误，非对齐的整数序列被转换为浮点数的错误（[GH 17005](https://github.com/pandas-dev/pandas/issues/17005)）

+   在与类别数据类型和日期时间数据类型合并时出现错误引发`TypeError`的错误（[GH 16900](https://github.com/pandas-dev/pandas/issues/16900)）

+   在大型对象序列和大型比较数组上使用`isin()`时出现的错误（[GH 16012](https://github.com/pandas-dev/pandas/issues/16012)）

+   从 0.20 版本中修复的问题，`Series.aggregate()`和`DataFrame.aggregate()`再次允许字典作为返回值（[GH 16741](https://github.com/pandas-dev/pandas/issues/16741)）

+   修复了在使用`pivot_table()`时，当调用`margins=True`时，结果的数据类型为整数数据类型输入的问题（[GH 17013](https://github.com/pandas-dev/pandas/issues/17013))

+   在`crosstab()`中的错误，传递两个具有相同名称的`Series`引发`KeyError`的错误（[GH 13279](https://github.com/pandas-dev/pandas/issues/13279)）

+   `Series.argmin()`，`Series.argmax()`以及它们在`DataFrame`和 groupby 对象上的对应项在包含无限值的浮点数据上能够正确工作（[GH 13595](https://github.com/pandas-dev/pandas/issues/13595)）

+   在`unique()`中，检查字符串元组引发`TypeError`的错误（[GH 17108](https://github.com/pandas-dev/pandas/issues/17108)）

+   `concat()`中的一个错误，如果包含不可比较元素，则结果索引的顺序是不可预测的（[GH 17344](https://github.com/pandas-dev/pandas/issues/17344)）

+   修复了在`datetime64` dtype `Series`上按多列排序时出现的回归问题，其中包含`NaT`值（[GH 16836](https://github.com/pandas-dev/pandas/issues/16836)）

+   `pivot_table()`中的一个错误，当`dropna`为`False`时，结果的列未保留`columns`的分类 dtype（[GH 17842](https://github.com/pandas-dev/pandas/issues/17842)）

+   在`DataFrame.drop_duplicates`中的一个错误，当使用非唯一列名进行删除时会引发`ValueError`（[GH 17836](https://github.com/pandas-dev/pandas/issues/17836)）

+   在`unstack()`中的一个错误，当在级别列表上调用时，会丢弃`fillna`参数（[GH 13971](https://github.com/pandas-dev/pandas/issues/13971)）

+   在`range`对象和其他类似列表与`DataFrame`对齐时的一个错误，导致操作是按行而不是按列执行（[GH 17901](https://github.com/pandas-dev/pandas/issues/17901)）

### 数值

+   在`.clip()`中，当`axis=1`且传递了类似列表的`threshold`时的一个错误；之前会引发`ValueError`（[GH 15390](https://github.com/pandas-dev/pandas/issues/15390)）

+   `Series.clip()`和`DataFrame.clip()`现在将上限和下限参数的 NA 值视为`None`而不是引发`ValueError`（[GH 17276](https://github.com/pandas-dev/pandas/issues/17276)）

### 分类

+   在使用分类调用`Series.isin()`时的一个错误（[GH 16639](https://github.com/pandas-dev/pandas/issues/16639)）

+   分类构造函数中的一个错误，当空值和类别导致`.categories`是一个空的`Float64Index`而不是一个带有对象 dtype 的空`Index`（[GH 17248](https://github.com/pandas-dev/pandas/issues/17248)）

+   在分类操作中，Series.cat 未保留原始 Series 名称的一个错误（[GH 17509](https://github.com/pandas-dev/pandas/issues/17509)）

+   在`DataFrame.merge()`中的一个错误，对于布尔/整数数据类型的分类列会失败（[GH 17187](https://github.com/pandas-dev/pandas/issues/17187)）

+   在指定的`categories`是分类类型时构造`Categorical`/`CategoricalDtype`的一个错误（[GH 17884](https://github.com/pandas-dev/pandas/issues/17884)）

### PyPy

+   与 PyPy 在 `read_csv()` 中的兼容性，使用 `usecols=[<unsorted ints>]` 和 `read_json()` ([GH 17351](https://github.com/pandas-dev/pandas/issues/17351))

+   将拆分测试案例为 CPython 和 PyPy 的情况，其中需要强调使用 `float('nan')`、`np.nan` 和 `NAT` 进行索引匹配的脆弱性 ([GH 17351](https://github.com/pandas-dev/pandas/issues/17351))

+   修复 `DataFrame.memory_usage()` 以支持 PyPy。PyPy 上的对象没有固定大小，因此使用近似值代替 ([GH 17228](https://github.com/pandas-dev/pandas/issues/17228))

### 其他

+   一种 bug，一些原地操作符在调用时未被包装并生成了副本 ([GH 12962](https://github.com/pandas-dev/pandas/issues/12962))

+   `eval()` 中的一个 bug，`inplace` 参数被错误处理 ([GH 16732](https://github.com/pandas-dev/pandas/issues/16732))

## 贡献者

本版本共有 206 人贡献了补丁。带有“+”符号的人是第一次贡献补丁的。

+   3553x +

+   Aaron Barber

+   Adam Gleave +

+   Adam Smith +

+   AdamShamlian +

+   Adrian Liaw +

+   Alan Velasco +

+   Alan Yee +

+   Alex B +

+   Alex Lubbock +

+   Alex Marchenko +

+   Alex Rychyk +

+   Amol K +

+   Andreas Winkler

+   Andrew +

+   Andrew 亮

+   André Jonasson +

+   Becky Sweger

+   Berkay +

+   Bob Haffner +

+   Bran Yang

+   Brian Tu +

+   Brock Mendel +

+   Carol Willing +

+   Carter Green +

+   Chankey Pathak +

+   Chris

+   Chris Billington

+   Chris Filo Gorgolewski +

+   Chris Kerr

+   Chris M +

+   Chris Mazzullo +

+   Christian Prinoth

+   Christian Stade-Schuldt

+   Christoph Moehl +

+   DSM

+   Daniel Chen +

+   Daniel Grady

+   Daniel Himmelstein

+   Dave Willmer

+   David Cook

+   David Gwynne

+   David Read +

+   Dillon Niederhut +

+   Douglas Rudd

+   Eric Stein +

+   Eric Wieser +

+   Erik Fredriksen

+   Florian Wilhelm +

+   Floris Kint +

+   Forbidden Donut

+   Gabe F +

+   Giftlin +

+   Giftlin Rajaiah +

+   Giulio Pepe +

+   Guilherme Beltramini

+   Guillem Borrell +

+   Hanmin Qin +

+   Hendrik Makait +

+   Hugues Valois

+   Hussain Tamboli +

+   Iva Miholic +

+   Jan Novotný +

+   Jan Rudolph

+   Jean Helie +

+   Jean-Baptiste Schiratti +

+   Jean-Mathieu Deschenes

+   Jeff Knupp +

+   Jeff Reback

+   Jeff Tratner

+   JennaVergeynst

+   JimStearns206

+   Joel Nothman

+   John W. O’Brien

+   Jon Crall +

+   Jon Mease

+   Jonathan J. Helmus +

+   Joris Van den Bossche

+   JosephWagner

+   Juarez Bochi

+   Julian Kuhlmann +

+   Karel De Brabandere

+   Kassandra Keeton +

+   Keiron Pizzey +

+   Keith Webber

+   Kernc

+   Kevin Sheppard

+   Kirk Hansen +

+   Licht Takeuchi +

+   Lucas Kushner +

+   Mahdi Ben Jelloul +

+   Makarov Andrey +

+   Malgorzata Turzanska +

+   Marc Garcia +

+   Margaret Sy +

+   MarsGuy +

+   Matt Bark +

+   Matthew Roeschke

+   Matti Picus

+   Mehmet Ali “Mali” Akmanalp

+   Michael Gasvoda +

+   Michael Penkov +

+   Milo +

+   Morgan Stuart +

+   Morgan243 +

+   Nathan Ford +

+   Nick Eubank

+   Nick Garvey +

+   Oleg Shteynbuk +

+   P-Tillmann +

+   Pankaj Pandey

+   Patrick Luo

+   Patrick O’Melveny

+   Paul Reidy +

+   Paula +

+   Peter Quackenbush

+   Peter Yanovich +

+   Phillip Cloud

+   Pierre Haessig

+   Pietro Battiston

+   Pradyumna Reddy Chinthala

+   Prasanjit Prakash

+   RobinFiveWords

+   Ryan Hendrickson

+   Sam Foo

+   Sangwoong Yoon +

+   Simon Gibbons +

+   SimonBaron

+   Steven Cutting +

+   Sudeep +

+   Sylvia +

+   T N +

+   Telt

+   Thomas A Caswell

+   Tim Swast +

+   Tom Augspurger

+   Tong SHEN

+   Tuan +

+   Utkarsh Upadhyay +

+   Vincent La +

+   Vivek +

+   WANG Aiyong

+   WBare

+   Wes McKinney

+   XF +

+   Yi Liu +

+   Yosuke Nakabayashi +

+   aaron315 +

+   abarber4gh +

+   aernlund +

+   agustín méndez +

+   andymaheshw +

+   ante328 +

+   aviolov +

+   bpraggastis

+   cbertinato +

+   cclauss +

+   chernrick

+   chris-b1

+   dkamm +

+   dwkenefick

+   economy

+   faic +

+   fding253 +

+   gfyoung

+   guygoldberg +

+   hhuuggoo +

+   huashuai +

+   ian

+   iulia +

+   jaredsnyder

+   jbrockmendel +

+   jdeschenes

+   jebob +

+   jschendel +

+   keitakurita

+   kernc +

+   kiwirob +

+   kjford

+   linebp

+   lloydkirk

+   louispotok +

+   majiang +

+   manikbhandari +

+   margotphoenix +

+   matthiashuschle +

+   mattip

+   mjlove12 +

+   nmartensen +

+   pandas-docs-bot +

+   parchd-1 +

+   philipphanemann +

+   rdk1024 +

+   reidy-p +

+   ri938

+   ruiann +

+   rvernica +

+   s-weigand +

+   scotthavard92 +

+   skwbc +

+   step4me +

+   tobycheese +

+   topper-123 +

+   tsdlovell

+   ysau +

+   zzgao +
