["```py\n>>> from sympy import symbols, Matrix\n>>> from sympy.physics.mechanics import *\n>>> q1 = dynamicsymbols('q1')                     # Angle of pendulum\n>>> u1 = dynamicsymbols('u1')                     # Angular velocity\n>>> q1d = dynamicsymbols('q1', 1)\n>>> L, m, t, g = symbols('L, m, t, g')\n\n>>> # Compose world frame\n>>> N = ReferenceFrame('N')\n>>> pN = Point('N*')\n>>> pN.set_vel(N, 0)\n\n>>> # A.x is along the pendulum\n>>> A = N.orientnew('A', 'axis', [q1, N.z])\n>>> A.set_ang_vel(N, u1*N.z)\n\n>>> # Locate point P relative to the origin N*\n>>> P = pN.locatenew('P', L*A.x)\n>>> vel_P = P.v2pt_theory(pN, N, A)\n>>> pP = Particle('pP', P, m)\n\n>>> # Create Kinematic Differential Equations\n>>> kde = Matrix([q1d - u1])\n\n>>> # Input the force resultant at P\n>>> R = m*g*N.x\n\n>>> # Solve for eom with kanes method\n>>> KM = KanesMethod(N, q_ind=[q1], u_ind=[u1], kd_eqs=kde)\n>>> fr, frstar = KM.kanes_equations([pP], [(P, R)]) \n```", "```py\n>>> linearizer = KM.to_linearizer() \n```", "```py\n>>> M, A, B = linearizer.linearize()\n>>> M\nMatrix([\n[1,       0],\n[0, -L**2*m]])\n>>> A\nMatrix([\n[                 0, 1],\n[L*g*m*cos(q1(t)), 0]])\n>>> B\nMatrix(0, 0, []) \n```", "```py\n>>> A, B = linearizer.linearize(A_and_B=True)\n>>> A\nMatrix([\n[                0, 1],\n[-g*cos(q1(t))/L, 0]])\n>>> B\nMatrix(0, 0, []) \n```", "```py\n>>> op_point = {q1: 0, u1: 0}\n>>> A_op, B_op = linearizer.linearize(A_and_B=True, op_point=op_point)\n>>> A_op\nMatrix([\n[     0, 1],\n[-g/L, 0]]) \n```", "```py\n>>> assert msubs(A, op_point) == A_op \n```", "```py\n>>> A, B, inp_vec = KM.linearize(A_and_B=True, op_point=op_point, new_method=True)\n>>> A\nMatrix([\n[     0, 1],\n[-g/L, 0]]) \n```", "```py\n>>> inp_vec\nMatrix(0, 0, []) \n```", "```py\n>>> # Redefine A and P in terms of q1d, not u1\n>>> A = N.orientnew('A', 'axis', [q1, N.z])\n>>> A.set_ang_vel(N, q1d*N.z)\n>>> P = pN.locatenew('P', L*A.x)\n>>> vel_P = P.v2pt_theory(pN, N, A)\n>>> pP = Particle('pP', P, m)\n\n>>> # Solve for eom with Lagrange's method\n>>> Lag = Lagrangian(N, pP)\n>>> LM = LagrangesMethod(Lag, [q1], forcelist=[(P, R)], frame=N)\n>>> lag_eqs = LM.form_lagranges_equations() \n```", "```py\n>>> linearizer = LM.to_linearizer(q_ind=[q1], qd_ind=[q1d]) \n```", "```py\n>>> A, B = linearizer.linearize(A_and_B=True, op_point=op_point)\n>>> A\nMatrix([\n[     0, 1],\n[-g/L, 0]]) \n```", "```py\n>>> A, B, inp_vec = LM.linearize(q_ind=[q1], qd_ind=[q1d], A_and_B=True, op_point=op_point)\n>>> A\nMatrix([\n[     0, 1],\n[-g/L, 0]]) \n```", "```py\n>>> M, A, B = linearizer.linearize()\n>>> M_op = msubs(M, op_point)\n>>> A_op = msubs(A, op_point)\n>>> perm_mat = linearizer.perm_mat\n>>> A_lin = perm_mat.T * M_op.LUsolve(A_op)\n>>> A_lin\nMatrix([\n[     0, 1],\n[-g/L, 0]]) \n```", "```py\n>>> from sympy import sin, tan\n>>> expr = sin(q1)/tan(q1)\n>>> op_point = {q1: 0}\n>>> expr.subs(op_point)\nnan \n```", "```py\n>>> expr.simplify().subs(op_point)\n1 \n```", "```py\n>>> msubs(expr, op_point, smart=True)\n1 \n```"]