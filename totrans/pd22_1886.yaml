- en: Extending pandas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/development/extending.html](https://pandas.pydata.org/docs/development/extending.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: While pandas provides a rich set of methods, containers, and data types, your
    needs may not be fully satisfied. pandas offers a few options for extending pandas.
  prefs: []
  type: TYPE_NORMAL
- en: '## Registering custom accessors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries can use the decorators [`pandas.api.extensions.register_dataframe_accessor()`](../reference/api/pandas.api.extensions.register_dataframe_accessor.html#pandas.api.extensions.register_dataframe_accessor
    "pandas.api.extensions.register_dataframe_accessor"), [`pandas.api.extensions.register_series_accessor()`](../reference/api/pandas.api.extensions.register_series_accessor.html#pandas.api.extensions.register_series_accessor
    "pandas.api.extensions.register_series_accessor"), and [`pandas.api.extensions.register_index_accessor()`](../reference/api/pandas.api.extensions.register_index_accessor.html#pandas.api.extensions.register_index_accessor
    "pandas.api.extensions.register_index_accessor"), to add additional “namespaces”
    to pandas objects. All of these follow a similar convention: you decorate a class,
    providing the name of attribute to add. The class’s `__init__` method gets the
    object being decorated. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now users can access your methods using the `geo` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This can be a convenient way to extend pandas objects without subclassing them.
    If you write a custom accessor, make a pull request adding it to our [ecosystem](https://pandas.pydata.org/community/ecosystem.html)
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'We highly recommend validating the data in your accessor’s `__init__`. In our
    `GeoAccessor`, we validate that the data contains the expected columns, raising
    an `AttributeError` when the validation fails. For a `Series` accessor, you should
    validate the `dtype` if the accessor applies only to certain dtypes.  ## Extension
    types'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") and [`pandas.api.extensions.ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") APIs were experimental prior to pandas
    1.5\. Starting with version 1.5, future changes will follow the [pandas deprecation
    policy](policies.html#policies-version).
  prefs: []
  type: TYPE_NORMAL
- en: pandas defines an interface for implementing data types and arrays that *extend*
    NumPy’s type system. pandas itself uses the extension system for some types that
    aren’t built into NumPy (categorical, period, interval, datetime with timezone).
  prefs: []
  type: TYPE_NORMAL
- en: Libraries can define a custom array and data type. When pandas encounters these
    objects, they will be handled properly (i.e. not converted to an ndarray of objects).
    Many methods like [`pandas.isna()`](../reference/api/pandas.isna.html#pandas.isna
    "pandas.isna") will dispatch to the extension type’s implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re building a library that implements the interface, please publicize
    it on [the ecosystem page](https://pandas.pydata.org/community/ecosystem.html).
  prefs: []
  type: TYPE_NORMAL
- en: The interface consists of two classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") is similar to a `numpy.dtype` object.
    It describes the data type. Implementers are responsible for a few unique items
    like the name.
  prefs: []
  type: TYPE_NORMAL
- en: One particularly important item is the `type` property. This should be the class
    that is the scalar type for your data. For example, if you were writing an extension
    array for IP Address data, this might be `ipaddress.IPv4Address`.
  prefs: []
  type: TYPE_NORMAL
- en: See the [extension dtype source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/base.py)
    for interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") can be registered to pandas to allow creation
    via a string dtype name. This allows one to instantiate `Series` and `.astype()`
    with a registered string name, for example `''category''` is a registered string
    accessor for the `CategoricalDtype`.'
  prefs: []
  type: TYPE_NORMAL
- en: See the [extension dtype dtypes](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/dtypes.py)
    for more on how to register dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class provides all the array-like functionality. ExtensionArrays are limited
    to 1 dimension. An ExtensionArray is linked to an ExtensionDtype via the `dtype`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: pandas makes no restrictions on how an extension array is created via its `__new__`
    or `__init__`, and puts no restrictions on how you store your data. We do require
    that your array be convertible to a NumPy array, even if this is relatively expensive
    (as it is for `Categorical`).
  prefs: []
  type: TYPE_NORMAL
- en: They may be backed by none, one, or many NumPy arrays. For example, [`pandas.Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") is an extension array backed by two arrays, one for codes
    and one for categories. An array of IPv6 addresses may be backed by a NumPy structured
    array with two fields, one for the lower 64 bits and one for the upper 64 bits.
    Or they may be backed by some other storage type, like Python lists.
  prefs: []
  type: TYPE_NORMAL
- en: See the [extension array source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/arrays/base.py)
    for the interface definition. The docstrings and comments contain guidance for
    properly implementing the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '### [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") operator support'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, there are no operators defined for the class [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). There are two approaches for providing
    operator support for your ExtensionArray:'
  prefs: []
  type: TYPE_NORMAL
- en: Define each of the operators on your `ExtensionArray` subclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use an operator implementation from pandas that depends on operators that are
    already defined on the underlying elements (scalars) of the ExtensionArray.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the approach, you may want to set `__array_priority__` if you
    want your implementation to be called when involved in binary operations with
    NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: For the first approach, you define selected operators, e.g., `__add__`, `__le__`,
    etc. that you want your `ExtensionArray` subclass to support.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach assumes that the underlying elements (i.e., scalar type)
    of the `ExtensionArray` have the individual operators already defined. In other
    words, if your `ExtensionArray` named `MyExtensionArray` is implemented so that
    each element is an instance of the class `MyExtensionElement`, then if the operators
    are defined for `MyExtensionElement`, the second approach will automatically define
    the operators for `MyExtensionArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mixin class, `ExtensionScalarOpsMixin` supports this second approach. If
    developing an `ExtensionArray` subclass, for example `MyExtensionArray`, can simply
    include `ExtensionScalarOpsMixin` as a parent class of `MyExtensionArray`, and
    then call the methods `_add_arithmetic_ops()` and/or `_add_comparison_ops()` to
    hook the operators into your `MyExtensionArray` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since `pandas` automatically calls the underlying operator on each element one-by-one,
    this might not be as performant as implementing your own version of the associated
    operators directly on the `ExtensionArray`.
  prefs: []
  type: TYPE_NORMAL
- en: For arithmetic operations, this implementation will try to reconstruct a new
    `ExtensionArray` with the result of the element-wise operation. Whether or not
    that succeeds depends on whether the operation returns a result that’s valid for
    the `ExtensionArray`. If an `ExtensionArray` cannot be reconstructed, an ndarray
    containing the scalars returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: For ease of implementation and consistency with operations between pandas and
    NumPy ndarrays, we recommend *not* handling Series and Indexes in your binary
    ops. Instead, you should detect these cases and return `NotImplemented`. When
    pandas encounters an operation like `op(Series, ExtensionArray)`, pandas will
  prefs: []
  type: TYPE_NORMAL
- en: unbox the array from the `Series` (`Series.array`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: call `result = op(values, ExtensionArray)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 're-box the result in a `Series`  ### NumPy universal functions'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    implements `__array_ufunc__`. As part of the implementation, pandas unboxes the
    `ExtensionArray` from the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), applies the ufunc, and re-boxes it if necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: If applicable, we highly recommend that you implement `__array_ufunc__` in your
    extension array to avoid coercion to an ndarray. See [the NumPy documentation](https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of your implementation, we require that you defer to pandas when a
    pandas container ([`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")) is detected in `inputs`. If any of those is present, you should
    return `NotImplemented`. pandas will take care of unboxing the array from the
    container and re-calling the ufunc with the unwrapped input.  ### Testing extension
    arrays'
  prefs: []
  type: TYPE_NORMAL
- en: We provide a test suite for ensuring that your extension arrays satisfy the
    expected behavior. To use the test suite, you must provide several pytest fixtures
    and inherit from the base test class. The required fixtures are found in [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/conftest.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a test, subclass it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'See [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/base/__init__.py)
    for a list of all the tests available.  ### Compatibility with Apache Arrow'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `ExtensionArray` can support conversion to / from `pyarrow` arrays (and
    thus support for example serialization to the Parquet file format) by implementing
    two methods: `ExtensionArray.__arrow_array__` and `ExtensionDtype.__from_arrow__`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExtensionArray.__arrow_array__` ensures that `pyarrow` knowns how to convert
    the specific extension array into a `pyarrow.Array` (also when included as a column
    in a pandas DataFrame):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExtensionDtype.__from_arrow__` method then controls the conversion back
    from pyarrow to a pandas ExtensionArray. This method receives a pyarrow `Array`
    or `ChunkedArray` as only argument and is expected to return the appropriate pandas
    `ExtensionArray` for this dtype and the passed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See more in the [Arrow documentation](https://arrow.apache.org/docs/python/extending_types.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Those methods have been implemented for the nullable integer and string extension
    dtypes included in pandas, and ensure roundtrip to pyarrow and the Parquet file
    format.  ## Subclassing pandas data structures'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: There are some easier alternatives before considering subclassing `pandas` data
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Extensible method chains with [pipe](../user_guide/basics.html#basics-pipe)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *composition*. See [here](https://en.wikipedia.org/wiki/Composition_over_inheritance).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending by [registering an accessor](#extending-register-accessors)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending by [extension type](#extending-extension-types)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This section describes how to subclass `pandas` data structures to meet more
    specific needs. There are two points that need attention:'
  prefs: []
  type: TYPE_NORMAL
- en: Override constructor properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define original properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find a nice example in [geopandas](https://github.com/geopandas/geopandas)
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Override constructor properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each data structure has several *constructor properties* for returning a new
    data structure as the result of an operation. By overriding these properties,
    you can retain subclasses through `pandas` data manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 3 possible constructor properties to be defined on a subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrame/Series._constructor`: Used when a manipulation result has the same
    dimension as the original.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataFrame._constructor_sliced`: Used when a `DataFrame` (sub-)class manipulation
    result should be a `Series` (sub-)class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Series._constructor_expanddim`: Used when a `Series` (sub-)class manipulation
    result should be a `DataFrame` (sub-)class, e.g. `Series.to_frame()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below example shows how to define `SubclassedSeries` and `SubclassedDataFrame`
    overriding constructor properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Define original properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To let original data structures have additional properties, you should let
    `pandas` know what properties are added. `pandas` maps unknown properties to data
    names overriding `__getattribute__`. Defining original properties can be done
    in one of 2 ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Define `_internal_names` and `_internal_names_set` for temporary properties
    which WILL NOT be passed to manipulation results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define `_metadata` for normal properties which will be passed to manipulation
    results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Below is an example to define two original properties, “internal_cache” as a
    temporary property and “added_property” as a normal property
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]  ## Plotting backends'
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas can be extended with third-party plotting backends. The main idea is
    letting users select a plotting backend different than the provided one based
    on Matplotlib. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be more or less equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The backend module can then use other visualization tools (Bokeh, Altair,…)
    to generate the plots.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries implementing the plotting backend should use [entry points](https://setuptools.pypa.io/en/latest/userguide/entry_point.html)
    to make their backend discoverable to pandas. The key is `"pandas_plotting_backends"`.
    For example, pandas registers the default “matplotlib” backend as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'More information on how to implement a third-party plotting backend can be
    found at [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/plotting/__init__.py#L1).  ##
    Arithmetic with 3rd party types'
  prefs: []
  type: TYPE_NORMAL
- en: In order to control how arithmetic works between a custom type and a pandas
    type, implement `__pandas_priority__`. Similar to numpy’s `__array_priority__`
    semantics, arithmetic methods on [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") objects will delegate to `other`, if it has an attribute `__pandas_priority__`
    with a higher value.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, pandas objects try to operate with other objects, even if they
    are not types known to pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, if `[10, 20]` was a custom type that can be understood
    as a list, pandas objects will still operate with it in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it is useful to delegate to the other type the operation. For
    example, consider I implement a custom list object, and I want the result of adding
    my custom list with a pandas [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") to be an instance of my list and not a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") as seen in the previous example. This is now possible by defining
    the `__pandas_priority__` attribute of my custom list, and setting it to a higher
    value, than the priority of the pandas objects I want to operate with.
  prefs: []
  type: TYPE_NORMAL
- en: The `__pandas_priority__` of [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") are `4000`, `3000`, and `2000` respectively. The base `ExtensionArray.__pandas_priority__`
    is `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]  ## Registering custom accessors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Libraries can use the decorators [`pandas.api.extensions.register_dataframe_accessor()`](../reference/api/pandas.api.extensions.register_dataframe_accessor.html#pandas.api.extensions.register_dataframe_accessor
    "pandas.api.extensions.register_dataframe_accessor"), [`pandas.api.extensions.register_series_accessor()`](../reference/api/pandas.api.extensions.register_series_accessor.html#pandas.api.extensions.register_series_accessor
    "pandas.api.extensions.register_series_accessor"), and [`pandas.api.extensions.register_index_accessor()`](../reference/api/pandas.api.extensions.register_index_accessor.html#pandas.api.extensions.register_index_accessor
    "pandas.api.extensions.register_index_accessor"), to add additional “namespaces”
    to pandas objects. All of these follow a similar convention: you decorate a class,
    providing the name of attribute to add. The class’s `__init__` method gets the
    object being decorated. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now users can access your methods using the `geo` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This can be a convenient way to extend pandas objects without subclassing them.
    If you write a custom accessor, make a pull request adding it to our [ecosystem](https://pandas.pydata.org/community/ecosystem.html)
    page.
  prefs: []
  type: TYPE_NORMAL
- en: We highly recommend validating the data in your accessor’s `__init__`. In our
    `GeoAccessor`, we validate that the data contains the expected columns, raising
    an `AttributeError` when the validation fails. For a `Series` accessor, you should
    validate the `dtype` if the accessor applies only to certain dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '## Extension types'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") and [`pandas.api.extensions.ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") APIs were experimental prior to pandas
    1.5\. Starting with version 1.5, future changes will follow the [pandas deprecation
    policy](policies.html#policies-version).
  prefs: []
  type: TYPE_NORMAL
- en: pandas defines an interface for implementing data types and arrays that *extend*
    NumPy’s type system. pandas itself uses the extension system for some types that
    aren’t built into NumPy (categorical, period, interval, datetime with timezone).
  prefs: []
  type: TYPE_NORMAL
- en: Libraries can define a custom array and data type. When pandas encounters these
    objects, they will be handled properly (i.e. not converted to an ndarray of objects).
    Many methods like [`pandas.isna()`](../reference/api/pandas.isna.html#pandas.isna
    "pandas.isna") will dispatch to the extension type’s implementation.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re building a library that implements the interface, please publicize
    it on [the ecosystem page](https://pandas.pydata.org/community/ecosystem.html).
  prefs: []
  type: TYPE_NORMAL
- en: The interface consists of two classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") is similar to a `numpy.dtype` object.
    It describes the data type. Implementers are responsible for a few unique items
    like the name.
  prefs: []
  type: TYPE_NORMAL
- en: One particularly important item is the `type` property. This should be the class
    that is the scalar type for your data. For example, if you were writing an extension
    array for IP Address data, this might be `ipaddress.IPv4Address`.
  prefs: []
  type: TYPE_NORMAL
- en: See the [extension dtype source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/base.py)
    for interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") can be registered to pandas to allow creation
    via a string dtype name. This allows one to instantiate `Series` and `.astype()`
    with a registered string name, for example `''category''` is a registered string
    accessor for the `CategoricalDtype`.'
  prefs: []
  type: TYPE_NORMAL
- en: See the [extension dtype dtypes](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/dtypes.py)
    for more on how to register dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class provides all the array-like functionality. ExtensionArrays are limited
    to 1 dimension. An ExtensionArray is linked to an ExtensionDtype via the `dtype`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: pandas makes no restrictions on how an extension array is created via its `__new__`
    or `__init__`, and puts no restrictions on how you store your data. We do require
    that your array be convertible to a NumPy array, even if this is relatively expensive
    (as it is for `Categorical`).
  prefs: []
  type: TYPE_NORMAL
- en: They may be backed by none, one, or many NumPy arrays. For example, [`pandas.Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") is an extension array backed by two arrays, one for codes
    and one for categories. An array of IPv6 addresses may be backed by a NumPy structured
    array with two fields, one for the lower 64 bits and one for the upper 64 bits.
    Or they may be backed by some other storage type, like Python lists.
  prefs: []
  type: TYPE_NORMAL
- en: See the [extension array source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/arrays/base.py)
    for the interface definition. The docstrings and comments contain guidance for
    properly implementing the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '### [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") operator support'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, there are no operators defined for the class [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). There are two approaches for providing
    operator support for your ExtensionArray:'
  prefs: []
  type: TYPE_NORMAL
- en: Define each of the operators on your `ExtensionArray` subclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use an operator implementation from pandas that depends on operators that are
    already defined on the underlying elements (scalars) of the ExtensionArray.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the approach, you may want to set `__array_priority__` if you
    want your implementation to be called when involved in binary operations with
    NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: For the first approach, you define selected operators, e.g., `__add__`, `__le__`,
    etc. that you want your `ExtensionArray` subclass to support.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach assumes that the underlying elements (i.e., scalar type)
    of the `ExtensionArray` have the individual operators already defined. In other
    words, if your `ExtensionArray` named `MyExtensionArray` is implemented so that
    each element is an instance of the class `MyExtensionElement`, then if the operators
    are defined for `MyExtensionElement`, the second approach will automatically define
    the operators for `MyExtensionArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mixin class, `ExtensionScalarOpsMixin` supports this second approach. If
    developing an `ExtensionArray` subclass, for example `MyExtensionArray`, can simply
    include `ExtensionScalarOpsMixin` as a parent class of `MyExtensionArray`, and
    then call the methods `_add_arithmetic_ops()` and/or `_add_comparison_ops()` to
    hook the operators into your `MyExtensionArray` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since `pandas` automatically calls the underlying operator on each element one-by-one,
    this might not be as performant as implementing your own version of the associated
    operators directly on the `ExtensionArray`.
  prefs: []
  type: TYPE_NORMAL
- en: For arithmetic operations, this implementation will try to reconstruct a new
    `ExtensionArray` with the result of the element-wise operation. Whether or not
    that succeeds depends on whether the operation returns a result that’s valid for
    the `ExtensionArray`. If an `ExtensionArray` cannot be reconstructed, an ndarray
    containing the scalars returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: For ease of implementation and consistency with operations between pandas and
    NumPy ndarrays, we recommend *not* handling Series and Indexes in your binary
    ops. Instead, you should detect these cases and return `NotImplemented`. When
    pandas encounters an operation like `op(Series, ExtensionArray)`, pandas will
  prefs: []
  type: TYPE_NORMAL
- en: unbox the array from the `Series` (`Series.array`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: call `result = op(values, ExtensionArray)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 're-box the result in a `Series`  ### NumPy universal functions'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    implements `__array_ufunc__`. As part of the implementation, pandas unboxes the
    `ExtensionArray` from the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), applies the ufunc, and re-boxes it if necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: If applicable, we highly recommend that you implement `__array_ufunc__` in your
    extension array to avoid coercion to an ndarray. See [the NumPy documentation](https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of your implementation, we require that you defer to pandas when a
    pandas container ([`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")) is detected in `inputs`. If any of those is present, you should
    return `NotImplemented`. pandas will take care of unboxing the array from the
    container and re-calling the ufunc with the unwrapped input.  ### Testing extension
    arrays'
  prefs: []
  type: TYPE_NORMAL
- en: We provide a test suite for ensuring that your extension arrays satisfy the
    expected behavior. To use the test suite, you must provide several pytest fixtures
    and inherit from the base test class. The required fixtures are found in [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/conftest.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a test, subclass it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'See [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/base/__init__.py)
    for a list of all the tests available.  ### Compatibility with Apache Arrow'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `ExtensionArray` can support conversion to / from `pyarrow` arrays (and
    thus support for example serialization to the Parquet file format) by implementing
    two methods: `ExtensionArray.__arrow_array__` and `ExtensionDtype.__from_arrow__`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExtensionArray.__arrow_array__` ensures that `pyarrow` knowns how to convert
    the specific extension array into a `pyarrow.Array` (also when included as a column
    in a pandas DataFrame):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExtensionDtype.__from_arrow__` method then controls the conversion back
    from pyarrow to a pandas ExtensionArray. This method receives a pyarrow `Array`
    or `ChunkedArray` as only argument and is expected to return the appropriate pandas
    `ExtensionArray` for this dtype and the passed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: See more in the [Arrow documentation](https://arrow.apache.org/docs/python/extending_types.html).
  prefs: []
  type: TYPE_NORMAL
- en: Those methods have been implemented for the nullable integer and string extension
    dtypes included in pandas, and ensure roundtrip to pyarrow and the Parquet file
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A [`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") is similar to a `numpy.dtype` object.
    It describes the data type. Implementers are responsible for a few unique items
    like the name.
  prefs: []
  type: TYPE_NORMAL
- en: One particularly important item is the `type` property. This should be the class
    that is the scalar type for your data. For example, if you were writing an extension
    array for IP Address data, this might be `ipaddress.IPv4Address`.
  prefs: []
  type: TYPE_NORMAL
- en: See the [extension dtype source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/base.py)
    for interface definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[`pandas.api.extensions.ExtensionDtype`](../reference/api/pandas.api.extensions.ExtensionDtype.html#pandas.api.extensions.ExtensionDtype
    "pandas.api.extensions.ExtensionDtype") can be registered to pandas to allow creation
    via a string dtype name. This allows one to instantiate `Series` and `.astype()`
    with a registered string name, for example `''category''` is a registered string
    accessor for the `CategoricalDtype`.'
  prefs: []
  type: TYPE_NORMAL
- en: See the [extension dtype dtypes](https://github.com/pandas-dev/pandas/blob/main/pandas/core/dtypes/dtypes.py)
    for more on how to register dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This class provides all the array-like functionality. ExtensionArrays are limited
    to 1 dimension. An ExtensionArray is linked to an ExtensionDtype via the `dtype`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: pandas makes no restrictions on how an extension array is created via its `__new__`
    or `__init__`, and puts no restrictions on how you store your data. We do require
    that your array be convertible to a NumPy array, even if this is relatively expensive
    (as it is for `Categorical`).
  prefs: []
  type: TYPE_NORMAL
- en: They may be backed by none, one, or many NumPy arrays. For example, [`pandas.Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") is an extension array backed by two arrays, one for codes
    and one for categories. An array of IPv6 addresses may be backed by a NumPy structured
    array with two fields, one for the lower 64 bits and one for the upper 64 bits.
    Or they may be backed by some other storage type, like Python lists.
  prefs: []
  type: TYPE_NORMAL
- en: See the [extension array source](https://github.com/pandas-dev/pandas/blob/main/pandas/core/arrays/base.py)
    for the interface definition. The docstrings and comments contain guidance for
    properly implementing the interface.
  prefs: []
  type: TYPE_NORMAL
- en: '### [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") operator support'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, there are no operators defined for the class [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). There are two approaches for providing
    operator support for your ExtensionArray:'
  prefs: []
  type: TYPE_NORMAL
- en: Define each of the operators on your `ExtensionArray` subclass.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use an operator implementation from pandas that depends on operators that are
    already defined on the underlying elements (scalars) of the ExtensionArray.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the approach, you may want to set `__array_priority__` if you
    want your implementation to be called when involved in binary operations with
    NumPy arrays.
  prefs: []
  type: TYPE_NORMAL
- en: For the first approach, you define selected operators, e.g., `__add__`, `__le__`,
    etc. that you want your `ExtensionArray` subclass to support.
  prefs: []
  type: TYPE_NORMAL
- en: The second approach assumes that the underlying elements (i.e., scalar type)
    of the `ExtensionArray` have the individual operators already defined. In other
    words, if your `ExtensionArray` named `MyExtensionArray` is implemented so that
    each element is an instance of the class `MyExtensionElement`, then if the operators
    are defined for `MyExtensionElement`, the second approach will automatically define
    the operators for `MyExtensionArray`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A mixin class, `ExtensionScalarOpsMixin` supports this second approach. If
    developing an `ExtensionArray` subclass, for example `MyExtensionArray`, can simply
    include `ExtensionScalarOpsMixin` as a parent class of `MyExtensionArray`, and
    then call the methods `_add_arithmetic_ops()` and/or `_add_comparison_ops()` to
    hook the operators into your `MyExtensionArray` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Since `pandas` automatically calls the underlying operator on each element one-by-one,
    this might not be as performant as implementing your own version of the associated
    operators directly on the `ExtensionArray`.
  prefs: []
  type: TYPE_NORMAL
- en: For arithmetic operations, this implementation will try to reconstruct a new
    `ExtensionArray` with the result of the element-wise operation. Whether or not
    that succeeds depends on whether the operation returns a result that’s valid for
    the `ExtensionArray`. If an `ExtensionArray` cannot be reconstructed, an ndarray
    containing the scalars returned instead.
  prefs: []
  type: TYPE_NORMAL
- en: For ease of implementation and consistency with operations between pandas and
    NumPy ndarrays, we recommend *not* handling Series and Indexes in your binary
    ops. Instead, you should detect these cases and return `NotImplemented`. When
    pandas encounters an operation like `op(Series, ExtensionArray)`, pandas will
  prefs: []
  type: TYPE_NORMAL
- en: unbox the array from the `Series` (`Series.array`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: call `result = op(values, ExtensionArray)`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: re-box the result in a `Series`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '### NumPy universal functions'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    implements `__array_ufunc__`. As part of the implementation, pandas unboxes the
    `ExtensionArray` from the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), applies the ufunc, and re-boxes it if necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: If applicable, we highly recommend that you implement `__array_ufunc__` in your
    extension array to avoid coercion to an ndarray. See [the NumPy documentation](https://numpy.org/doc/stable/reference/generated/numpy.lib.mixins.NDArrayOperatorsMixin.html)
    for an example.
  prefs: []
  type: TYPE_NORMAL
- en: As part of your implementation, we require that you defer to pandas when a pandas
    container ([`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series"),
    [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame"),
    [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")) is
    detected in `inputs`. If any of those is present, you should return `NotImplemented`.
    pandas will take care of unboxing the array from the container and re-calling
    the ufunc with the unwrapped input.
  prefs: []
  type: TYPE_NORMAL
- en: '### Testing extension arrays'
  prefs: []
  type: TYPE_NORMAL
- en: We provide a test suite for ensuring that your extension arrays satisfy the
    expected behavior. To use the test suite, you must provide several pytest fixtures
    and inherit from the base test class. The required fixtures are found in [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/conftest.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a test, subclass it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: See [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/tests/extension/base/__init__.py)
    for a list of all the tests available.
  prefs: []
  type: TYPE_NORMAL
- en: '### Compatibility with Apache Arrow'
  prefs: []
  type: TYPE_NORMAL
- en: 'An `ExtensionArray` can support conversion to / from `pyarrow` arrays (and
    thus support for example serialization to the Parquet file format) by implementing
    two methods: `ExtensionArray.__arrow_array__` and `ExtensionDtype.__from_arrow__`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ExtensionArray.__arrow_array__` ensures that `pyarrow` knowns how to convert
    the specific extension array into a `pyarrow.Array` (also when included as a column
    in a pandas DataFrame):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ExtensionDtype.__from_arrow__` method then controls the conversion back
    from pyarrow to a pandas ExtensionArray. This method receives a pyarrow `Array`
    or `ChunkedArray` as only argument and is expected to return the appropriate pandas
    `ExtensionArray` for this dtype and the passed values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See more in the [Arrow documentation](https://arrow.apache.org/docs/python/extending_types.html).
  prefs: []
  type: TYPE_NORMAL
- en: Those methods have been implemented for the nullable integer and string extension
    dtypes included in pandas, and ensure roundtrip to pyarrow and the Parquet file
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '## Subclassing pandas data structures'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: There are some easier alternatives before considering subclassing `pandas` data
    structures.
  prefs: []
  type: TYPE_NORMAL
- en: Extensible method chains with [pipe](../user_guide/basics.html#basics-pipe)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use *composition*. See [here](https://en.wikipedia.org/wiki/Composition_over_inheritance).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending by [registering an accessor](#extending-register-accessors)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extending by [extension type](#extending-extension-types)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This section describes how to subclass `pandas` data structures to meet more
    specific needs. There are two points that need attention:'
  prefs: []
  type: TYPE_NORMAL
- en: Override constructor properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define original properties
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can find a nice example in [geopandas](https://github.com/geopandas/geopandas)
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Override constructor properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each data structure has several *constructor properties* for returning a new
    data structure as the result of an operation. By overriding these properties,
    you can retain subclasses through `pandas` data manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 3 possible constructor properties to be defined on a subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrame/Series._constructor`: Used when a manipulation result has the same
    dimension as the original.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataFrame._constructor_sliced`: Used when a `DataFrame` (sub-)class manipulation
    result should be a `Series` (sub-)class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Series._constructor_expanddim`: Used when a `Series` (sub-)class manipulation
    result should be a `DataFrame` (sub-)class, e.g. `Series.to_frame()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below example shows how to define `SubclassedSeries` and `SubclassedDataFrame`
    overriding constructor properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Define original properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To let original data structures have additional properties, you should let
    `pandas` know what properties are added. `pandas` maps unknown properties to data
    names overriding `__getattribute__`. Defining original properties can be done
    in one of 2 ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Define `_internal_names` and `_internal_names_set` for temporary properties
    which WILL NOT be passed to manipulation results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define `_metadata` for normal properties which will be passed to manipulation
    results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Below is an example to define two original properties, “internal_cache” as a
    temporary property and “added_property” as a normal property
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Override constructor properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each data structure has several *constructor properties* for returning a new
    data structure as the result of an operation. By overriding these properties,
    you can retain subclasses through `pandas` data manipulations.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are 3 possible constructor properties to be defined on a subclass:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrame/Series._constructor`: Used when a manipulation result has the same
    dimension as the original.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DataFrame._constructor_sliced`: Used when a `DataFrame` (sub-)class manipulation
    result should be a `Series` (sub-)class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Series._constructor_expanddim`: Used when a `Series` (sub-)class manipulation
    result should be a `DataFrame` (sub-)class, e.g. `Series.to_frame()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Below example shows how to define `SubclassedSeries` and `SubclassedDataFrame`
    overriding constructor properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Define original properties
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To let original data structures have additional properties, you should let
    `pandas` know what properties are added. `pandas` maps unknown properties to data
    names overriding `__getattribute__`. Defining original properties can be done
    in one of 2 ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Define `_internal_names` and `_internal_names_set` for temporary properties
    which WILL NOT be passed to manipulation results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define `_metadata` for normal properties which will be passed to manipulation
    results.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Below is an example to define two original properties, “internal_cache” as a
    temporary property and “added_property” as a normal property
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '## Plotting backends'
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas can be extended with third-party plotting backends. The main idea is
    letting users select a plotting backend different than the provided one based
    on Matplotlib. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be more or less equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The backend module can then use other visualization tools (Bokeh, Altair,…)
    to generate the plots.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries implementing the plotting backend should use [entry points](https://setuptools.pypa.io/en/latest/userguide/entry_point.html)
    to make their backend discoverable to pandas. The key is `"pandas_plotting_backends"`.
    For example, pandas registers the default “matplotlib” backend as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: More information on how to implement a third-party plotting backend can be found
    at [pandas-dev/pandas](https://github.com/pandas-dev/pandas/blob/main/pandas/plotting/__init__.py#L1).
  prefs: []
  type: TYPE_NORMAL
- en: '## Arithmetic with 3rd party types'
  prefs: []
  type: TYPE_NORMAL
- en: In order to control how arithmetic works between a custom type and a pandas
    type, implement `__pandas_priority__`. Similar to numpy’s `__array_priority__`
    semantics, arithmetic methods on [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") objects will delegate to `other`, if it has an attribute `__pandas_priority__`
    with a higher value.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, pandas objects try to operate with other objects, even if they
    are not types known to pandas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the example above, if `[10, 20]` was a custom type that can be understood
    as a list, pandas objects will still operate with it in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, it is useful to delegate to the other type the operation. For
    example, consider I implement a custom list object, and I want the result of adding
    my custom list with a pandas [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") to be an instance of my list and not a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") as seen in the previous example. This is now possible by defining
    the `__pandas_priority__` attribute of my custom list, and setting it to a higher
    value, than the priority of the pandas objects I want to operate with.
  prefs: []
  type: TYPE_NORMAL
- en: The `__pandas_priority__` of [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"), [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), and [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") are `4000`, `3000`, and `2000` respectively. The base `ExtensionArray.__pandas_priority__`
    is `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
