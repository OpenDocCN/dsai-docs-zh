- en: Gotchas and Pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/explanation/gotchas.html](https://docs.sympy.org/latest/explanation/gotchas.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Introduction'
  prefs: []
  type: TYPE_NORMAL
- en: SymPy runs under the [Python Programming Language](https://www.python.org/),
    so there are some things that may behave differently than they do in other, independent
    computer algebra systems like Maple or Mathematica. These are some of the gotchas
    and pitfalls that you may encounter when using SymPy. See also the [introductory
    tutorial](../tutorials/intro-tutorial/index.html#intro-tutorial), the remainder
    of the SymPy Docs, and the [official Python Tutorial](https://docs.python.org/3/tutorial/).
  prefs: []
  type: TYPE_NORMAL
- en: If you are already familiar with C or Java, you might also want to look at this
    [4 minute Python tutorial](https://nerdparadise.com/programming/python4minutes/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignore `#doctest: +SKIP` in the examples. That has to do with internal testing
    of the examples.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Equals Signs (=)'
  prefs: []
  type: TYPE_NORMAL
- en: Single Equals Sign
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The equals sign (`=`) is the assignment operator, not equality. If you want
    to do \(x = y\), use `Eq(x, y)` for equality. Alternatively, all expressions are
    assumed to equal zero, so you can just subtract one side and use `x - y`.
  prefs: []
  type: TYPE_NORMAL
- en: The proper use of the equals sign is to assign expressions to variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Double Equals Signs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Double equals signs (`==`) are used to test equality. However, this tests expressions
    exactly, not symbolically. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you want to test for symbolic equality, one way is to subtract one expression
    from the other and run it through functions like [`expand()`](../modules/core.html#sympy.core.function.expand
    "sympy.core.function.expand"), [`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify"), and [`trigsimp()`](../modules/simplify/simplify.html#sympy.simplify.trigsimp.trigsimp
    "sympy.simplify.trigsimp.trigsimp") and see if the equation reduces to 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: See also [Structural Equality](glossary.html#term-Structural-Equality) in the
    [Glossary](glossary.html).
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables Assignment does not Create a Relation Between Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you use `=` to do assignment, remember that in Python, as in most programming
    languages, the variable does not change if you change the value you assigned to
    it. The equations you are typing use the values present at the time of creation
    to “fill in” values, just like regular Python definitions. They are not altered
    by changes made afterwards. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Changing quantity `a` does not change `b`; you are not working with a set of
    simultaneous equations. It might be helpful to remember that the string that gets
    printed when you print a variable referring to a SymPy object is the string that
    was given to it when it was created; that string does not have to be the same
    as the variable that you assign it to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you need variables that have dependence on each other, you can define functions.
    Use the `def` operator. Indent the body of the function. See the Python docs for
    more information on defining functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you define a circular relationship, you will get a `RuntimeError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: See also [immutable](glossary.html#term-Immutable) in the [Glossary](glossary.html).
  prefs: []
  type: TYPE_NORMAL
- en: '### Symbols'
  prefs: []
  type: TYPE_NORMAL
- en: 'Symbols are variables, and like all other variables, they need to be assigned
    before you can use them. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you use **isympy**, it runs the following commands for you, giving you some
    default Symbols and Functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can also import common symbol names from [`sympy.abc`](../modules/abc.html#module-sympy.abc
    "sympy.abc").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you want control over the assumptions of the variables, use [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol") and [`symbols()`](../modules/core.html#sympy.core.symbol.symbols
    "sympy.core.symbol.symbols"). See [Keyword Arguments](#keyword-arguments) below.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, it is recommended that you not use [`I`](../modules/core.html#sympy.core.numbers.ImaginaryUnit
    "sympy.core.numbers.ImaginaryUnit"), [`E`](../modules/stats.html#sympy.stats.E
    "sympy.stats.E"), [`S`](../modules/physics/quantum/gate.html#sympy.physics.quantum.gate.S
    "sympy.physics.quantum.gate.S"), [`N`](../modules/core.html#sympy.core.evalf.N
    "sympy.core.evalf.N"), `C`, [`O`](../modules/series/series.html#sympy.series.order.Order
    "sympy.series.order.Order"), or [`Q`](../modules/assumptions/ask.html#sympy.assumptions.ask.AssumptionKeys
    "sympy.assumptions.ask.AssumptionKeys") for variable or symbol names, as those
    are used for the imaginary unit (\(i\)), the base of the natural logarithm (\(e\)),
    the [`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")
    function (see [Symbolic Expressions](#symbolic-expressions) below), numeric evaluation
    ([`N()`](../modules/core.html#sympy.core.evalf.N "sympy.core.evalf.N") is equivalent
    to [evalf()](../modules/evalf.html#evalf-label) ), the [big O](https://en.wikipedia.org/wiki/Big_O_notation)
    order symbol (as in \(O(n\log{n})\)), and the assumptions object that holds a
    list of supported ask keys (such as `Q.real`), respectively. You can use the mnemonic
    `OSINEQ` to remember what Symbols are defined by default in SymPy. Or better yet,
    always use lowercase letters for Symbol names. Python will not prevent you from
    overriding default SymPy names or functions, so be careful.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a full list of all default names in SymPy do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you have [IPython](https://ipython.org/) installed and use **isympy**, you
    can also press the TAB key to get a list of all built-in names and to autocomplete.
    Also, see [this page](https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks)
    for a trick for getting tab completion in the regular Python console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'See also the [Defining Symbols](best-practices.html#best-practices-defining-symbols)
    section of the [Best Practices](best-practices.html) page.  ### Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function like `f(x)` can be created by defining the Function and the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you assign `f(x)` to a Python variable \(f\) you will lose your ability
    to copy and paste that function or to create a function with a different argument:
    `Function(''f'')` is callable, but `Function(''f'')(x)` is not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]  ## Symbolic Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: '### Python numbers vs. SymPy Numbers'
  prefs: []
  type: TYPE_NORMAL
- en: SymPy uses its own classes for integers, rational numbers, and floating point
    numbers instead of the default Python `int` and `float` types because it allows
    for more control. But you have to be careful. If you type an expression that just
    has numbers in it, it will default to a Python expression. Use the [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") function, or just [`S`](../modules/physics/quantum/gate.html#sympy.physics.quantum.gate.S
    "sympy.physics.quantum.gate.S"), to ensure that something is a SymPy expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you include numbers in a SymPy expression, they will be sympified automatically,
    but there is one gotcha you should be aware of. If you do `<number>/<number>`
    inside of a SymPy expression, Python will evaluate the two numbers before SymPy
    has a chance to get to them. The solution is to [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") one of the numbers, or use [`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'With a power of `1/2` you can also use `sqrt` shorthand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If the two integers are not directly separated by a division sign then you
    don’t have to worry about this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A common mistake is copying an expression that is printed and reusing it. If
    the expression has a [`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational") (i.e., `<number>/<number>`) in it, you will not
    get the same result, obtaining the Python result for the division rather than
    a SymPy Rational.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The other solution is to put quotes around the expression and run it through
    S() (i.e., sympify it):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Also, if you do not use **isympy**, you could use `from __future__ import division`
    to prevent the `/` sign from performing [integer division](https://en.wikipedia.org/wiki/Integer_division).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'But be careful: you will now receive floats where you might have desired a
    Rational:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '[`Rational`](../modules/core.html#sympy.core.numbers.Rational "sympy.core.numbers.Rational")
    only works for number/number and is only meant for rational numbers. If you want
    a fraction with symbols or expressions in it, just use `/`. If you do number/expression
    or expression/number, then the number will automatically be converted into a SymPy
    Number. You only need to be careful with number/number.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating Expressions with Floats and Rationals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SymPy keeps track of the precision of `Float` objects. The default precision
    is 15 digits. When an expression involving a `Float` is evaluated, the result
    will be expressed to 15 digits of precision but those digits (depending on the
    numbers involved with the calculation) may not all be significant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first issue to keep in mind is how the `Float` is created: it is created
    with a value and a precision. The precision indicates how precise of a value to
    use when that `Float` (or an expression it appears in) is evaluated.'
  prefs: []
  type: TYPE_NORMAL
- en: The values can be given as strings, integers, floats, or rationals.
  prefs: []
  type: TYPE_NORMAL
- en: strings and integers are interpreted as exact
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: to have the precision match the number of digits, the null string can be used
    for the precision
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'Next, notice that each of those values looks correct to 3 digits. But if we
    try to evaluate them to 20 digits, a difference will become apparent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The 0.25 (with precision of 3) represents a number that has a non-repeating
    binary decimal; 1/7 is repeating in binary and decimal – it cannot be represented
    accurately too far past those first 3 digits (the correct decimal is a repeating
    142857):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is important to realize that although a Float is being displayed in decimal
    at arbitrary precision, it is actually stored in binary. Once the Float is created,
    its binary information is set at the given precision. The accuracy of that value
    cannot be subsequently changed; so 1/7, at a precision of 3 digits, can be padded
    with binary zeros, but these will not make it a more accurate value of 1/7.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If inexact, low-precision numbers are involved in a calculation with higher
    precision values, the evalf engine will increase the precision of the low precision
    values and inexact results will be obtained. This is feature of calculations with
    limited precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Although the `evalf` engine tried to maintain 10 digits of precision (since
    that was the highest precision represented) the 3-digit precision used limits
    the accuracy to about 4 digits – not all the digits you see are significant. evalf
    doesn’t try to keep track of the number of significant digits.
  prefs: []
  type: TYPE_NORMAL
- en: 'That very simple expression involving the addition of two numbers with different
    precisions will hopefully be instructive in helping you understand why more complicated
    expressions (like trig expressions that may not be simplified) will not evaluate
    to an exact zero even though, with the right simplification, they should be zero.
    Consider this unsimplified trig identity, multiplied by a big number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When the \(\cos\) and \(\sin\) terms were evaluated to 15 digits of precision
    and multiplied by the big number, they gave a large number that was only precise
    to 15 digits (approximately) and when the 20 digit big number was subtracted the
    result was not zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three things that will help you obtain more precise numerical values
    for expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '1) Pass the desired substitutions with the call to evaluate. By doing the subs
    first, the `Float` values cannot be updated as necessary. By passing the desired
    substitutions with the call to evalf the ability to re-evaluate as necessary is
    gained and the results are impressively better:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2) Use Rationals, not Floats. During the evaluation process, the Rational can
    be computed to an arbitrary precision while the Float, once created – at a default
    of 15 digits – cannot. Compare the value of `-1.4e+3` above with the nearly zero
    value obtained when replacing x with a Rational representing 1/10 – before the
    call to evaluate:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '3) Try to simplify the expression. In this case, SymPy will recognize the trig
    identity and simplify it to zero so you don’t even have to evaluate it numerically:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '### Immutability of Expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Expressions in SymPy are immutable, and cannot be modified by an in-place operation.
    This means that a function will always return an object, and the original expression
    will not be modified. The following example snippet demonstrates how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows that the [`subs()`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs") function has replaced variable `x` with variable
    `a`, and variable `y` with variable `b`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The [`subs()`](../modules/core.html#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")
    function does not modify the original expression `expr`. Rather, a modified copy
    of the expression is returned. This returned object is stored in the variable
    `expr_modified`. Note that unlike C/C++ and other high-level languages, Python
    does not require you to declare a variable before it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Mathematical Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SymPy uses the same default operators as Python. Most of these, like `*/+-`,
    are standard. Aside from integer division discussed in [Python numbers vs. SymPy
    Numbers](#python-vs-sympy-numbers) above, you should also be aware that implied
    multiplication is not allowed. You need to use `*` whenever you wish to multiply
    something. Also, to raise something to a power, use `**`, not `^` as many computer
    algebra systems use. Parentheses `()` change operator precedence as you would
    normally expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In **isympy**, with the **ipython** shell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Inverse Trig Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SymPy uses different names for some functions than most computer algebra systems.
    In particular, the inverse trig functions use the python names of [`asin`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.asin
    "sympy.functions.elementary.trigonometric.asin"), [`acos`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.acos
    "sympy.functions.elementary.trigonometric.acos") and so on instead of the usual
    `arcsin` and `arccos`. Use the methods described in [Symbols](#symbols) above
    to see the names of all SymPy functions.
  prefs: []
  type: TYPE_NORMAL
- en: Sqrt is not a Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is no `sqrt` function in the same way that there is an exponential function
    (`exp`). `sqrt(x)` is used to represent `Pow(x, S(1)/2)` so if you want to know
    if an expression has any square roots in it, `expr.has(sqrt)` will not work. You
    must look for `Pow` with an exponent of one half (or negative one half if it is
    in a denominator, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you are interested in any power of the `sqrt` then the following pattern
    would be appropriate
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Special Symbols
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The symbols `[]`, `{}`, `=`, and `()` have special meanings in Python, and thus
    in SymPy. See the Python docs linked to above for additional information.
  prefs: []
  type: TYPE_NORMAL
- en: '### Lists'
  prefs: []
  type: TYPE_NORMAL
- en: Square brackets `[]` denote a list. A list is a container that holds any number
    of different objects. A list can contain anything, including items of different
    types. Lists are mutable, which means that you can change the elements of a list
    after it has been created. You access the items of a list also using square brackets,
    placing them after the list or list variable. Items are numbered using the space
    before the item.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: List indexes begin at 0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: See the Python docs for more information on lists and the square bracket notation
    for accessing elements of a list.
  prefs: []
  type: TYPE_NORMAL
- en: Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Curly brackets `{}` denote a dictionary, or a dict for short. A dictionary
    is an unordered list of non-duplicate keys and values. The syntax is `{key: value}`.
    You can access values of keys using square bracket notation.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: See the Python docs for more information on dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: Tuples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Parentheses `()`, aside from changing operator precedence and their use in function
    calls, (like `cos(x)`), are also used for tuples. A `tuple` is identical to a
    [list](#lists), except that it is not mutable. That means that you cannot change
    their values after they have been created. In general, you will not need tuples
    in SymPy, but sometimes it can be more convenient to type parentheses instead
    of square brackets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Single element tuples, unlike lists, must have a comma in them:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Without the comma, a single expression without a comma is not a tuple:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'integrate takes a sequence as the second argument if you want to integrate
    with limits (and a tuple or list will work):'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: See the Python docs for more information on tuples.
  prefs: []
  type: TYPE_NORMAL
- en: '### Keyword Arguments'
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the usage described [above](#equals-signs), equals signs (`=`) are
    also used to give named arguments to functions. Any function that has `key=value`
    in its parameters list (see below on how to find this out), then `key` is set
    to `value` by default. You can change the value of the key by supplying your own
    value using the equals sign in the function call. Also, functions that have `**`
    followed by a name in the parameters list (usually `**kwargs` or `**assumptions`)
    allow you to add any number of `key=value` pairs that you want, and they will
    all be evaluated according to the function.
  prefs: []
  type: TYPE_NORMAL
- en: '`sqrt(x**2)` doesn’t auto simplify to x because x is assumed to be complex
    by default, and, for example, `sqrt((-1)**2) == sqrt(1) == 1 != -1`:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Giving assumptions to Symbols is an example of using the keyword argument:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The square root will now simplify since it knows that `x >= 0`:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'powsimp has a default argument of `combine=''all''`:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Setting combine to the default value is the same as not setting it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The non-default options are `'exp'`, which combines exponents…
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …and ‘base’, which combines bases.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: See the Python docs for more information on function parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Getting help from within SymPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: help()
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Although all docs are available at [docs.sympy.org](https://docs.sympy.org/)
    or on the [SymPy Wiki](https://wiki.sympy.org/), you can also get info on functions
    from within the Python interpreter that runs SymPy. The easiest way to do this
    is to do `help(function)`, or `function?` if you are using **ipython**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'These will give you the function parameters and docstring for [`powsimp()`](../modules/simplify/simplify.html#sympy.simplify.powsimp.powsimp
    "sympy.simplify.powsimp.powsimp"). The output will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Reduce expression by combining powers with similar bases and exponents.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If `deep` is `True` then powsimp() will also simplify arguments of functions.
    By default `deep` is set to `False`.
  prefs: []
  type: TYPE_NORMAL
- en: If `force` is `True` then bases will be combined without checking for assumptions,
    e.g. sqrt(x)*sqrt(y) -> sqrt(x*y) which is not true if x and y are both negative.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make powsimp() only combine bases or only combine exponents by changing
    combine=’base’ or combine=’exp’. By default, combine=’all’, which does both. combine=’base’
    will only combine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: and combine=’exp’ will only combine
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: combine=’exp’ will strictly only combine exponents in the way that used to be
    automatic. Also use deep=True if you need the old behavior.
  prefs: []
  type: TYPE_NORMAL
- en: When combine=’all’, ‘exp’ is evaluated first. Consider the first example below
    for when there could be an ambiguity relating to this. This is done so things
    like the second example can be completely combined. If you want ‘base’ combined
    first, do something like powsimp(powsimp(expr, combine=’base’), combine=’exp’).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Radicals with Mul bases will be combined if combine=’exp’
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Two radicals are automatically joined through Mul:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'But if an integer power of that radical has been autoexpanded then Mul does
    not join the resulting factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
