- en: Writing Custom Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/guides/custom-functions.html](https://docs.sympy.org/latest/guides/custom-functions.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This guide will describe how to create custom function classes in SymPy. Custom
    user defined functions use the same mechanisms as the [functions](../modules/functions/index.html#functions)
    that are included with SymPy such as the common [elementary functions](../modules/functions/elementary.html#elementary-functions)
    like [`exp()`](../modules/functions/elementary.html#sympy.functions.elementary.exponential.exp
    "sympy.functions.elementary.exponential.exp") or [`sin()`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.sin
    "sympy.functions.elementary.trigonometric.sin"), [special functions](../modules/functions/special.html#special-functions)
    like [`gamma()`](../modules/functions/special.html#sympy.functions.special.gamma_functions.gamma
    "sympy.functions.special.gamma_functions.gamma") or [`Si()`](../modules/functions/special.html#sympy.functions.special.error_functions.Si
    "sympy.functions.special.error_functions.Si"), and [combinatorial functions](../modules/functions/combinatorial.html#combinatorial-functions)
    and [number theory functions](../modules/ntheory.html#ntheory-module) like [`factorial()`](../modules/functions/combinatorial.html#sympy.functions.combinatorial.factorials.factorial
    "sympy.functions.combinatorial.factorials.factorial") or [`primepi()`](../modules/ntheory.html#sympy.ntheory.generate.primepi
    "sympy.ntheory.generate.primepi"). Consequently, this guide serves both as a guide
    to end users who want to define their own custom functions and to SymPy developers
    wishing to extend the functions included with SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: This guide describes how to define complex valued functions, that is functions
    that map a subset of \(\mathbb{C}^n\) to \(\mathbb{C}\). Functions that accept
    or return other kinds of objects than complex numbers should subclass another
    class, such as [`Boolean`](../modules/logic.html#sympy.logic.boolalg.Boolean "sympy.logic.boolalg.Boolean"),
    [`MatrixExpr`](../modules/matrices/expressions.html#sympy.matrices.expressions.MatrixExpr
    "sympy.matrices.expressions.MatrixExpr"), [`Expr`](../modules/core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"), or [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic"). Some of what is written here will apply to general
    [`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")
    or [`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    subclasses, but much of it only applies to [`Function`](../modules/core.html#sympy.core.function.Function
    "sympy.core.function.Function") subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Easy Cases: Fully Symbolic or Fully Evaluated'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before digging into the more advanced functionality for custom functions, we
    should mention two common cases, the case where the function is fully symbolic,
    and the case where the function is fully evaluated. Both of these cases have much
    simpler alternatives than the full mechanisms described in this guide.
  prefs: []
  type: TYPE_NORMAL
- en: '### The Fully Symbolic Case'
  prefs: []
  type: TYPE_NORMAL
- en: If your function `f` has no mathematical properties you want to define on it,
    and should never evaluate on any arguments, you can create an undefined function
    using `Function('f')`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is useful, for instance, when solving [ODEs](../modules/solvers/ode.html#ode-docs).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is also useful if you only wish to create a symbol that depends on another
    symbol for the purposes of differentiation. By default, SymPy assumes all symbols
    are independent of one another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: To make a symbol that depends on another symbol, you can use a function that
    explicitly depends on that symbol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you want your function to have additional behavior, for example, to have
    a custom derivative, or to evaluate on certain arguments, you should create a
    custom `Function` subclass as [described below](#custom-functions-function-subclass).
    However, undefined functions do support one additional feature, which is that
    assumptions can be defined on them, using the same syntax as used by symbols.
    This defines the assumptions of the output of the function, not the input (that
    is, it defines the function’s range, not its domain).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a function’s assumptions depend on its input in some way, you should
    create a custom `Function` subclass and define assumptions handlers as [described
    below](#custom-functions-assumptions).  ### The Fully Evaluated Case'
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of the spectrum are functions that always evaluate to something
    no matter what their inputs are. These functions are never left in an unevaluated,
    symbolic form like `f(x)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, you should use a normal Python function using the `def` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you find yourself defining an [`eval()`](#custom-functions-eval) method on
    a `Function` subclass where you always return a value and never return `None`,
    you should consider just using a normal Python function instead, as there is no
    benefit to using a symbolic `Function` subclass in that case (see the [Best Practices
    for eval()](#custom-functions-eval-best-practices) section below)
  prefs: []
  type: TYPE_NORMAL
- en: Note that in many cases, functions like these can be represented directly using
    SymPy classes. For example, the above function can be represented symbolically
    using [`Piecewise`](../modules/functions/elementary.html#sympy.functions.elementary.piecewise.Piecewise
    "sympy.functions.elementary.piecewise.Piecewise"). The `Piecewise` expression
    can be evaluated for specific values of `x` using [`subs()`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Fully symbolic representations like `Piecewise` have the advantage that they
    accurately represent symbolic values. For example, in the above Python `def` definition
    of `f`, `f(x)` implicitly assumes that `x` is nonzero. The `Piecewise` version
    handles this case correctly and won’t evaluate to the \(x \neq 0\) case unless
    `x` is known to not be zero.
  prefs: []
  type: TYPE_NORMAL
- en: Another option, if you want a function that not only evaluates, but always evaluates
    to a numerical value, is to use [`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify"). This will convert a SymPy expression into
    a function that can be evaluated using NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Ultimately, the correct tool for the job depends on what you are doing and
    what exact behavior you want.  ## Creating a Custom Function'
  prefs: []
  type: TYPE_NORMAL
- en: The first step to creating a custom function is to subclass [`Function`](../modules/core.html#sympy.core.function.Function
    "sympy.core.function.Function"). The name of the subclass will be the name of
    the function. Different methods should then be defined on this subclass, depending
    on what functionality you want to provide.
  prefs: []
  type: TYPE_NORMAL
- en: As a motivating example for this document, let’s create a custom function class
    representing the [versine function](https://en.wikipedia.org/wiki/Versine). Versine
    is a trigonometric function which was used historically alongside some of the
    more familiar trigonometric functions like sine and cosine. It is rarely used
    today. Versine can be defined by the identity
  prefs: []
  type: TYPE_NORMAL
- en: \[\operatorname{versin}(x) = 1 - \cos(x).\]
  prefs: []
  type: TYPE_NORMAL
- en: SymPy does not already include versine because it is used so rarely in modern
    mathematics and because it is so easily defined in terms of the more familiar
    cosine.
  prefs: []
  type: TYPE_NORMAL
- en: Let us start by subclassing `Function`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: At this point, `versin` has no behaviors defined on it. It is very similar to
    the [undefined functions](#custom-functions-fully-symbolic) we discussed above.
    Note that `versin` is a class, and `versin(x)` is an instance of this class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the methods described below are optional. They can be included if you want
    to define the given behavior, but if they are omitted, SymPy will default to leaving
    things unevaluated. For example, if you do not define [differentiation](#custom-functions-differentiation),
    [`diff()`](../modules/core.html#sympy.core.function.diff "sympy.core.function.diff")
    will just return an unevaluated [`Derivative`](../modules/core.html#sympy.core.function.Derivative
    "sympy.core.function.Derivative").
  prefs: []
  type: TYPE_NORMAL
- en: '### Defining Automatic Evaluation with `eval()`'
  prefs: []
  type: TYPE_NORMAL
- en: The first and most common thing we might want to define on our custom function
    is automatic evaluation, that is, the cases where it will return an actual value
    instead of just remaining unevaluated as-is.
  prefs: []
  type: TYPE_NORMAL
- en: This is done by defining the class method `eval()`. `eval()` should take the
    arguments of the function and return either a value or `None`. If it returns `None`,
    the function will remain unevaluated in that case. This also serves to define
    the signature of the function (by default, without an `eval()` method, a `Function`
    subclass will accept any number of arguments).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our function `versin`, we might recall that \(\cos(n\pi) = (-1)^n\) for
    integer \(n\), so \(\operatorname{versin}(n\pi) = 1 - (-1)^n.\) We can make `versin`
    automatically evaluate to this value when passed an integer multiple of `pi`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here we make use of the fact that if a Python function does not explicitly return
    a value, it automatically returns `None`. So in the cases where the `if isinstance(n,
    Integer)` statement is not triggered, `eval()` returns `None` and `versin` remains
    unevaluated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Function` subclasses should not redefine `__new__` or `__init__`. If you want
    to implement behavior that isn’t possible with `eval()`, it might make more sense
    to subclass [`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    rather than `Function`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`eval()` can take any number of arguments, including an arbitrary number with
    `*args` and optional keyword arguments. The `.args` of the function will always
    be the arguments that were passed in by the user. For example'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Finally, note that automatic evaluation on floating-point inputs happens automatically
    once [`evalf()` is defined](#custom-functions-evalf), so you do not need to handle
    it explicitly in `eval()`.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Best Practices for `eval()`'
  prefs: []
  type: TYPE_NORMAL
- en: Certain antipatterns are common when defining `eval()` methods and should be
    avoided.
  prefs: []
  type: TYPE_NORMAL
- en: '**Don’t just return an expression.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the above example, we might have been tempted to write
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, this would make it so that `versin(x)` would *always* return `1 - cos(x)`,
    regardless of what `x` is. If all you want is a quick shorthand to `1 - cos(x)`,
    that is fine, but would be much simpler and more explicit to just [use a Python
    function as described above](#custom-functions-fully-evaluated). If we defined
    `versin` like this, it would never actually be represented as `versin(x)`, and
    none of the other behavior we define below would matter, because the other behaviors
    we are going to define on the `versin` class only apply when the returned object
    is actually a `versin` instance. So for example, `versin(x).diff(x)` would actually
    just be `(1 - cos(x)).diff(x)`, instead of calling [the `fdiff()` method we define
    below](#custom-functions-differentiation).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Key Point
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**The purpose of `eval()` is not to define what the function *is*, mathematically,
    but rather to specify on what inputs it should automatically evaluate.** The mathematical
    definition of a function is determined through the specification of various mathematical
    properties with the methods outlined below, like [numerical evaluation](#custom-functions-evalf),
    [differentiation](#custom-functions-differentiation), and so on.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you find yourself doing this, you should think about what you actually want
    to achieve. If you just want a shorthand function for an expression, it will be
    simpler to just [define a Python function](#custom-functions-fully-evaluated).
    If you really do want a symbolic function, think about when you want it to evaluate
    to something else and when you want it to stay unevaluated. One option is to make
    your function unevaluated in `eval()` and define a [`doit()` method](#custom-functions-doit)
    to evaluate it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Avoid too much automatic evaluation.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is recommended to minimize what is evaluated automatically by `eval()`. It
    is typically better to put more advanced simplifications in [other methods](#custom-functions-rewriting-and-simplification),
    like [`doit()`](#custom-functions-doit). Remember that whatever you define for
    automatic evaluation will *always* evaluate.[[1]](#evaluate-footnote) As in the
    previous point, if you evaluate every value, there is little point to even having
    a symbolic function in the first place. For example, we might be tempted to evaluate
    some trig identities on `versin` in `eval()`, but then these identities would
    always evaluate, and it wouldn’t be possible to represent one half of the identity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One should also avoid doing anything in `eval()` that is slow to compute. SymPy
    generally assumes that it is cheap to create expressions, and if this is not true,
    it can lead to performance issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, it is recommended to avoid performing automatic evaluation in `eval()`
    based on assumptions. Instead, `eval()` should typically only evaluate explicit
    numerical special values and return `None` for everything else. You might have
    noticed in [the example above](#custom-functions-versin-eval-example) that we
    used `isinstance(n, Integer)` instead of checking `n.is_integer` using the assumptions
    system. We could have done that instead, which would make `versin(n*pi)` evaluate
    even if `n = Symbol('n', integer=True)`. But this is a case where we might not
    always want evaluation to happen, and if `n` is a more complicated expression,
    `n.is_integer` might be more expensive to compute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s consider an example. Using the identity \(\cos(x + y) = \cos(x)\cos(y)
    - \sin(x)\sin(y)\), we can derive the identity
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: \[\operatorname{versin}(x + y) = \operatorname{versin}(x)\operatorname{versin}(y)
    - \operatorname{versin}(x) - \operatorname{versin}(y) - \sin(x)\sin(y) + 1.\]
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Suppose we decided to automatically expand this in `eval()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method recursively splits `Add` terms into two parts and applies the above
    identity.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But now it’s impossible to represent `versin(x + y)` without it expanding.
    This will affect other methods too. For example, suppose we define [differentiation
    (see below)](#custom-functions-differentiation):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We would expect `versin(x + y).diff(x)` to return `sin(x + y)`, and indeed,
    if we hadn’t expanded this identity in `eval()`, [it would](#custom-functions-differentiation-examples).
    But with this version, `versin(x + y)` gets automatically expanded before `diff()`
    gets called, instead we get a more complicated expression:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And things are even worse than that. Let’s try an `Add` with three terms:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can see that things are getting out of control quite quickly. In fact, `versin(Add(*symbols('x:100')))`
    (`versin()` on an `Add` with 100 terms) takes over a second to evaluate, and that’s
    just to *create* the expression, without even doing anything with it yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identities like this are better left out of `eval` and implemented in other
    methods instead (in the case of this identity, [`expand_trig()`](#custom-functions-expand)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**When restricting the input domain: allow `None` input assumptions.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our example function \(\operatorname{versin}(x)\) is a function from \(\mathbb{C}\)
    to \(\mathbb{C}\), so it can accept any input. But suppose we had a function that
    only made sense with certain inputs. As a second example, let’s define a function
    `divides` as
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '\[\begin{split}\operatorname{divides}(m, n) = \begin{cases} 1 & \text{for}\:
    m \mid n \\ 0 & \text{for}\: m\not\mid n \end{cases}.\end{split}\]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That is, `divides(m, n)` will be `1` if `m` divides `n` and `0` otherwise. `divides`
    clearly only makes sense if `m` and `n` are integers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We might be tempted to define the `eval()` method for `divides` like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The problem here is that by using `if not m.is_integer`, we are requiring `m.is_integer`
    to be `True`. If it is `None`, it will fail (see the [guide on booleans and three-valued
    logic](booleans.html#booleans-guide) for details on what it means for an assumption
    to be `None`). This is problematic for two reasons. Firstly, it forces the user
    to define assumptions on any input variable. If the user omits them, it will fail:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Instead they have to write
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This may seem like an acceptable restriction, but there is a bigger problem.
    Sometimes, SymPy’s assumptions system cannot deduce an assumption, even though
    it is mathematically true. In this case, it will give `None` (`None` means both
    “undefined” and “cannot compute” in SymPy’s assumptions). For example
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here the expression `(m**2 + m)/2` is always an integer, but SymPy’s assumptions
    system is not able to deduce this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: SymPy’s assumptions system is always improving, but there will always be cases
    like this that it cannot deduce, due to the fundamental computational complexity
    of the problem, and the fact that the general problem is [often](https://en.wikipedia.org/wiki/Hilbert%27s_tenth_problem)
    [undecidable](https://en.wikipedia.org/wiki/Richardson%27s_theorem).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Consequently, one should always test *negated* assumptions for input variables,
    that is, fail if the assumption is `False` but allow the assumption to be `None`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This still disallows non-integer inputs as desired:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'But it does not fail in cases where the assumption is `None`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This rule of allowing `None` assumptions only applies to instances where an
    exception would be raised, such as type checking an input domain. In cases where
    simplifications or other operations are done, one should treat a `None` assumption
    as meaning “can be either `True` or `False`” and not perform an operation that
    might not be mathematically valid.  ### Assumptions'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The next thing you might want to define are the assumptions on our function.
    The assumptions system allows defining what mathematical properties your function
    has given its inputs, for example, “\(f(x)\) is *positive* when \(x\) is *real*.”
  prefs: []
  type: TYPE_NORMAL
- en: The [guide on the assumptions system](assumptions.html#assumptions-guide) goes
    into the assumptions system in great detail. It is recommended to read through
    that guide first to understand what the different assumptions mean and how the
    assumptions system works.
  prefs: []
  type: TYPE_NORMAL
- en: The simplest case is a function that always has a given assumption regardless
    of its input. In this case, you can define `is_*assumption*` directly on the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our [example `divides` function](#custom-functions-divides-definition)
    is always an integer, because its value is always either 0 or 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In general, however, the assumptions of a function depend on the assumptions
    of its inputs. In this case, you should define an `_eval_*assumption*` method.
  prefs: []
  type: TYPE_NORMAL
- en: For our [\(\operatorname{versin}(x)\) example](#custom-functions-versine-definition),
    the function is always in \([0, 2]\) when \(x\) is real, and it is 0 exactly when
    \(x\) is an even multiple of \(\pi\). So `versin(x)` should be *nonnegative* whenever
    `x` is *real* and *positive* whenever `x` is *real* and not an *even* multiple
    of π. Remember that by default, a function’s domain is all of \(\mathbb{C}\),
    and indeed `versin(x)` makes perfect sense with non-real `x`.
  prefs: []
  type: TYPE_NORMAL
- en: To see if `x` is an even multiple of `pi`, we can use [`as_independent()`](../modules/core.html#sympy.core.expr.Expr.as_independent
    "sympy.core.expr.Expr.as_independent") to match `x` structurally as `coeff*pi`.
    Pulling apart subexpressions structurally like this in assumptions handlers is
    preferable to using something like `(x/pi).is_even`, because that will create
    a new expression `x/pi`. The creation of a new expression is much slower. Furthermore,
    whenever an expression is created, the constructors that are called when creating
    the expression will often themselves cause assumptions to be queried. If you are
    not careful, this can lead to infinite recursion. So a good general rule for assumptions
    handlers is, **never create a new expression in an assumptions handler**. Always
    pull apart the args of the function using structural methods like `as_independent`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that \(\operatorname{versin}(x)\) can be nonnegative for nonreal \(x\),
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: So for the `_eval_is_nonnegative` handler, we want to return `True` if `x.is_real`
    is `True` but `None` if `x.is_real` is either `False` or `None`. It is left as
    an exercise to the reader to handle the cases for nonreal `x` that make `versin(x)`
    nonnegative, using similar logic from the `_eval_is_positive` handler.
  prefs: []
  type: TYPE_NORMAL
- en: In the assumptions handler methods, as in all methods, we can access the arguments
    of the function using `self.args`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `fuzzy_` functions in the more complicated `_eval_is_positive()`
    handler, and the careful handling of the `if`/`elif`. It is important when working
    with assumptions to always be careful about [handling three-valued logic correctly](booleans.html#booleans-guide).
    This ensures that the method returns the correct answer when `x.is_real` or `coeff.is_even`
    are `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Never define `is_*assumption*` as a `@property` method. Doing so will break
    the automatic deduction of other assumptions. `is_*assumption*` should only ever
    be defined as a class variable equal to `True` or `False`. If the assumption depends
    on the `.args` of the function somehow, define the `_eval_*assumption*` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, it is not necessary to define `_eval_is_real()` because it
    is deduced automatically from the other assumptions, since `nonnegative -> real`.
    In general, you should avoid defining assumptions that the assumptions system
    can deduce automatically given its [known facts](assumptions.html#assumptions-guide-predicates).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The assumptions system is often able to deduce more than you might think. For
    example, from the above, it can deduce that `versin(2*n*pi)` is zero when `n`
    is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: It’s always worth checking if the assumptions system can deduce something automatically
    before manually coding it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a word of warning: be very careful about correctness when coding assumptions.
    Make sure to use the exact [definitions](assumptions.html#assumptions-guide-predicates)
    of the various assumptions, and always check that you’re handling `None` cases
    correctly with the fuzzy three-valued logic functions. Incorrect or inconsistent
    assumptions can lead to subtle bugs. It’s recommended to use unit tests to check
    all the various cases whenever your function has a nontrivial assumption handler.
    All functions defined in SymPy itself are required to be extensively tested.  ###
    Numerical Evaluation with `evalf()`'
  prefs: []
  type: TYPE_NORMAL
- en: Here we show how to define how a function should numerically evaluate to a floating
    point [`Float`](../modules/core.html#sympy.core.numbers.Float "sympy.core.numbers.Float")
    value, for instance, via `evalf()`. Implementing numerical evaluation enables
    several behaviors in SymPy. For example, once `evalf()` is defined, you can plot
    your function, and things like inequalities can evaluate to explicit values.
  prefs: []
  type: TYPE_NORMAL
- en: If your function has the same name as a function in [mpmath](https://mpmath.org/doc/current/),
    which is the case for most functions included with SymPy, numerical evaluation
    will happen automatically and you do not need to do anything.
  prefs: []
  type: TYPE_NORMAL
- en: If this is not the case, numerical evaluation can be specified by defining the
    method `_eval_evalf(self, prec)`, where `prec` is the binary precision of the
    input. The method should return the expression evaluated to the given precision,
    or `None` if this is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `prec` argument to `_eval_evalf()` is the *binary* precision, that is, the
    number of bits in the floating-point representation. This differs from the first
    argument to the `evalf()` method, which is the *decimal* precision, or `dps`.
    For example, the default binary precision of `Float` is 53, corresponding to a
    decimal precision of 15\. Therefore, if your `_eval_evalf()` method recursively
    calls evalf on another expression, it should call `expr._eval_evalf(prec)` rather
    than `expr.evalf(prec)`, as the latter will incorrectly use `prec` as the decimal
    precision.
  prefs: []
  type: TYPE_NORMAL
- en: We can define numerical evaluation for [our example \(\operatorname{versin}(x)\)
    function](#custom-functions-versine-definition) by recursively evaluating \(2\sin^2\left(\frac{x}{2}\right)\),
    which is a more numerically stable way of writing \(1 - \cos(x)\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Once `_eval_evalf()` is defined, this enables the automatic evaluation of floating-point
    inputs. It is not required to implement this manually in [`eval()`](#custom-functions-eval).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that `evalf()` may be passed any expression, not just one that can be evaluated
    numerically. In this case, it is expected that the numerical parts of an expression
    will be evaluated. A general pattern to follow is to recursively call `_eval_evalf(prec)`
    on the arguments of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever possible, it’s best to reuse the evalf functionality defined in existing
    SymPy functions. However, in some cases it will be necessary to use mpmath directly.  ###
    Rewriting and Simplification'
  prefs: []
  type: TYPE_NORMAL
- en: Various simplification functions and methods allow specifying their behavior
    on custom subclasses. Not every function in SymPy has such hooks. See the documentation
    of each individual function for details.
  prefs: []
  type: TYPE_NORMAL
- en: '#### `rewrite()`'
  prefs: []
  type: TYPE_NORMAL
- en: The [`rewrite()`](../modules/core.html#sympy.core.basic.Basic.rewrite "sympy.core.basic.Basic.rewrite")
    method allows rewriting an expression in terms of a specific function or rule.
    For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: To implement rewriting, define a method `_eval_rewrite(self, rule, args, **hints)`,
    where
  prefs: []
  type: TYPE_NORMAL
- en: '`rule` is the *rule* passed to the `rewrite()` method. Typically `rule` will
    be the class of the object to be rewritten to, although for more complex rewrites,
    it can be anything. Each object that defines `_eval_rewrite()` defines what rule(s)
    it supports. Many SymPy functions rewrite to common classes, like `expr.rewrite(Add)`,
    to perform simplifications or other computations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`args` are the arguments of the function to be used for rewriting. This should
    be used instead of `self.args` because any recursive expressions in the args will
    be rewritten in `args` (assuming the caller used `rewrite(deep=True)`, which is
    the default).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`**hints` are additional keyword arguments which may be used to specify the
    behavior of the rewrite. Unknown hints should be ignored as they may be passed
    to other `_eval_rewrite()` methods. If you recursively call rewrite, you should
    pass the `**hints` through.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method should return a rewritten expression, using `args` as the arguments
    to the function, or `None` if the expression should be unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our [`versin` example](#custom-functions-versine-definition), an obvious
    rewrite we can implement is rewriting `versin(x)` as `1 - cos(x)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we’ve defined this, [`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") is now able to simplify some expressions containing
    `versin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]  #### `doit()`'
  prefs: []
  type: TYPE_NORMAL
- en: The [`doit()`](../modules/core.html#sympy.core.basic.Basic.doit "sympy.core.basic.Basic.doit")
    method is used to evaluate “unevaluated” functions. To define `doit()` implement
    `doit(self, deep=True, **hints)`. If `deep=True`, `doit()` should recursively
    call `doit()` on the arguments. `**hints` will be any other keyword arguments
    passed to the user, which should be passed to any recursive calls to `doit()`.
    You can use `hints` to allow the user to specify specific behavior for `doit()`.
  prefs: []
  type: TYPE_NORMAL
- en: The typical usage of `doit()` in custom `Function` subclasses is to perform
    more advanced evaluation which is not performed in [`eval()`](#custom-functions-eval).
  prefs: []
  type: TYPE_NORMAL
- en: For example, for our [`divides` example](#custom-functions-divides-definition),
    there are several instances that could be simplified using some identities. For
    example, we defined `eval()` to evaluate on explicit integers, but we might also
    want to evaluate examples like `divides(k, k*n)` where the divisibility is symbolically
    true. One of the [best practices for `eval()`](#custom-functions-eval-best-practices)
    is to avoid too much automatic evaluation. Automatically evaluating in this case
    might be considered too much, as it would make use of the assumptions system,
    which could be expensive. Furthermore, we might want to be able to represent `divides(k,
    k*n)` without it always evaluating.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to implement these more advanced evaluations in `doit()`. That
    way, we can explicitly perform them by calling `expr.doit()`, but they won’t happen
    by default. An example `doit()` for `divides` that performs this simplification
    (along with the [above definition of `eval()`](#custom-functions-divides-eval))
    might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If `doit()` returns a Python `int` literal, convert it to an `Integer` so that
    the returned object is a SymPy type.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: (Note that this uses the [convention](https://en.wikipedia.org/wiki/Divisor#Definition)
    that \(k \mid 0\) for all \(k\) so that we do not need to check if `m` or `n`
    are nonzero. If we used a different convention we would need to check if `m.is_zero`
    and `n.is_zero` before performing the simplification.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Another common way to implement `doit()` is for it to always return another
    expression. This effectively treats the function as an “unevaluated” form of another
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let’s define a function for [fused multiply-add](https://en.wikipedia.org/w/index.php?title=Fused_multiply_add):
    \(\operatorname{FMA}(x, y, z) = xy + z\). It may be useful to express this function
    as a distinct function, e.g., for the purposes of code generation, but it would
    also be useful in some contexts to “evaluate” `FMA(x, y, z)` to `x*y + z` so that
    it can properly simplify with other expressions.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Most custom functions will not want to define `doit()` in this way. However,
    this can provide a happy medium between having a function that always evaluates
    and a function that never evaluates, producing a function that doesn’t evaluate
    by default but can be evaluated on demand (see the [discussion above](#custom-functions-eval-best-practices)).  ####
    `expand()`'
  prefs: []
  type: TYPE_NORMAL
- en: The [`expand()`](../modules/core.html#sympy.core.function.expand "sympy.core.function.expand")
    function “expands” an expression in various ways. It is actually a wrapper around
    several sub-expansion hints. Each function corresponds to a hint to the `expand()`
    function/method. A specific expand *hint* can be defined in a custom function
    by defining `_eval_expand_*hint*(self, **hints)`. See the documentation of [`expand()`](../modules/core.html#sympy.core.function.expand
    "sympy.core.function.expand") for details on which hints are defined and the documentation
    for each specific `expand_*hint*()` function (e.g., [`expand_trig()`](../modules/core.html#sympy.core.function.expand_trig
    "sympy.core.function.expand_trig")) for details on what each hint is designed
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: The `**hints` keyword arguments are additional hints that may be passed to the
    expand function to specify additional behavior (these are separate from the predefined
    *hints* described in the previous paragraph). Unknown hints should be ignored
    as they may apply to other functions’ custom `expand()` methods. A common hint
    to define is `force`, where `force=True` would force an expansion that might not
    be mathematically valid for all the given input assumptions. For example, `expand_log(log(x*y),
    force=True)` produces `log(x) + log(y)` even though this identity is not true
    for all complex `x` and `y` (typically `force=False` is the default).
  prefs: []
  type: TYPE_NORMAL
- en: Note that `expand()` automatically takes care of recursively expanding expressions
    using its own `deep` flag, so `_eval_expand_*` methods should not recursively
    call expand on the arguments of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our [`versin` example](#custom-functions-versine-definition), we can define
    rudimentary `trig` expansion by defining an `_eval_expand_trig` method, which
    recursively calls `expand_trig()` on `1 - cos(x)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'A more sophisticated implementation might attempt to rewrite the result of
    `expand_trig(1 - cos(x))` back into `versin` functions. This is left as an exercise
    for the reader.  ### Differentiation'
  prefs: []
  type: TYPE_NORMAL
- en: To define differentiation via [`diff()`](../modules/core.html#sympy.core.function.diff
    "sympy.core.function.diff"), define a method `fdiff(self, argindex)`. `fdiff()`
    should return the derivative of the function, without considering the chain rule,
    with respect to the `argindex`-th variable. `argindex` is indexed starting at
    `1`.
  prefs: []
  type: TYPE_NORMAL
- en: That is, `f(x1, ..., xi, ..., xn).fdiff(i)` should return \(\frac{d}{d x_i}
    f(x_1, \ldots, x_i, \ldots, x_n)\), where \(x_k\) are independent of one another.
    `diff()` will automatically apply the chain rule using the result of `fdiff()`.
    User code should use `diff()` and not call `fdiff()` directly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`Function` subclasses should define differentiation using `fdiff()`. Subclasses
    of [`Expr`](../modules/core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    that aren’t `Function` subclasses will need to define `_eval_derivative()` instead.
    It is not recommended to redefine `_eval_derivative()` on a `Function` subclass.'
  prefs: []
  type: TYPE_NORMAL
- en: For our [\(\operatorname{versin}\) example function](#custom-functions-versine-definition),
    the derivative is \(\sin(x)\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As an example of a function that has multiple arguments, consider the [fused
    multiply-add (FMA) example](#custom-functions-fma-definition) defined above (\(\operatorname{FMA}(x,
    y, z) = xy + z\)).
  prefs: []
  type: TYPE_NORMAL
- en: We have
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{d}{dx} \operatorname{FMA}(x, y, z) = y,\]\[\frac{d}{dy} \operatorname{FMA}(x,
    y, z) = x,\]\[\frac{d}{dz} \operatorname{FMA}(x, y, z) = 1.\]
  prefs: []
  type: TYPE_NORMAL
- en: 'So the `fdiff()` method for `FMA` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: To leave a derivative unevaluated, raise `sympy.core.function.ArgumentIndexError(self,
    argindex)`. This is the default behavior if `fdiff()` is not defined. Here is
    an example function \(f(x, y)\) that is linear in the first argument and has an
    unevaluated derivative on the second argument.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Printing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can define how a function prints itself with the varions [printers](../modules/printing.html#module-printing)
    such as the [`string printer`](../modules/printing.html#sympy.printing.str.StrPrinter
    "sympy.printing.str.StrPrinter"), [`pretty printers`](../modules/printing.html#sympy.printing.pretty.pretty.PrettyPrinter
    "sympy.printing.pretty.pretty.PrettyPrinter"), and [`LaTeX printer`](../modules/printing.html#sympy.printing.latex.LatexPrinter
    "sympy.printing.latex.LatexPrinter"), as well as code printers for various languages
    like [`C`](../modules/printing.html#sympy.printing.c.C99CodePrinter "sympy.printing.c.C99CodePrinter")
    and [`Fortran`](../modules/printing.html#sympy.printing.fortran.FCodePrinter "sympy.printing.fortran.FCodePrinter").
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you will not need to define any printing methods. The default
    behavior is to print functions using their name. However, in some cases we may
    want to define special printing for a function.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for our [divides example above](#custom-functions-divides-definition),
    we may want the LaTeX printer to print a more mathematical expression. Let’s make
    the LaTeX printer represent `divides(m, n)` as `\left [ m \middle | n \right ]`,
    which looks like \(\left [ m \middle | n \right ]\) (here \([P]\) is the [Iverson
    bracket](https://en.wikipedia.org/wiki/Iverson_bracket), which is \(1\) if \(P\)
    is true and \(0\) if \(P\) is false).
  prefs: []
  type: TYPE_NORMAL
- en: There are two primary ways to define printing for SymPy objects. One is to define
    a printer on the printer class. Most classes that are part of the SymPy library
    should use this method, by defining the printers on the respective classes in
    `sympy.printing`. For user code, this may be preferable if you are defining a
    custom printer, or if you have many custom functions that you want to define printing
    for. See [Example of Custom Printer](../modules/printing.html#printer-example)
    for an example of how to define a printer in this way.
  prefs: []
  type: TYPE_NORMAL
- en: The other way is to define the printing as a method on the function class. To
    do this, first look up the `printmethod` attribute on the printer you want to
    define the printing for. This is the name of the method you should define for
    that printer. For the LaTeX printer, [`LatexPrinter.printmethod`](../modules/printing.html#sympy.printing.latex.LatexPrinter.printmethod
    "sympy.printing.latex.LatexPrinter.printmethod") is `'_latex'`. The print method
    always takes one argument, `printer`. `printer._print` should be used to recursively
    print any other expressions, including the arguments of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'So to define our `divides` LaTeX printer, we will define the function `_latex(self,
    printer)` on the class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: See [Example of Custom Printing Method](../modules/printing.html#printer-method-example)
    for more details on how to define printer methods and some pitfalls to avoid.
    Most importantly, you should always use `printer._print()` to recursively print
    the arguments of the function inside of a custom printer.
  prefs: []
  type: TYPE_NORMAL
- en: Other Methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Several other methods can be defined on custom functions to specify various
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: '`inverse()`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `inverse(self, argindex=1)` method can be defined to specify the inverse
    of the function. This is used by [`solve()`](../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") and [`solveset()`](../modules/solvers/solveset.html#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset"). The `argindex` argument is the argument of
    the function, starting at 1 (similar to the same argument name for the [`fdiff()`
    method](#custom-functions-differentiation)).
  prefs: []
  type: TYPE_NORMAL
- en: '`inverse()` should return a function (not an expression) for the inverse. If
    the inverse is a larger expression than a single function, it can return a `lambda`
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: '`inverse()` should only be defined for functions that are one-to-one. In other
    words, `f(x).inverse()` is the [left inverse](https://en.wikipedia.org/wiki/Inverse_function#Left_and_right_inverses)
    of `f(x)`. Defining `inverse()` on a function that is not one-to-one may result
    in `solve()` not giving all possible solutions to an expression containing the
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our [example versine function](#custom-functions-versine-definition) is not
    one-to-one (because cosine is not), but its inverse \(\operatorname{arcversin}\)
    is. We may define it as follows (using the same naming convention as other inverse
    trig functions in SymPy):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes `solve()` work on `aversin(x)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '`as_real_imag()`'
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The method [`as_real_imag()`](../modules/core.html#sympy.core.expr.Expr.as_real_imag
    "sympy.core.expr.Expr.as_real_imag") method defines how to split a function into
    its real and imaginary parts. It is used by various SymPy functions that operate
    on the real and imaginary parts of an expression separately.
  prefs: []
  type: TYPE_NORMAL
- en: '`as_real_imag(self, deep=True, **hints)` should return a 2-tuple containing
    the real part and imaginary part of the function. That is `expr.as_real_imag()`
    returns `(re(expr), im(expr))`, where `expr == re(expr) + im(expr)*I`, and `re(expr)`
    and `im(expr)` are real.'
  prefs: []
  type: TYPE_NORMAL
- en: If `deep=True`, it should recursively call `as_real_imag(deep=True, **hints)`
    on its arguments. As with [`doit()`](#custom-functions-doit) and [the `_eval_expand_*()`
    methods](#custom-functions-expand), `**hints` may be any hints to allow the user
    to specify the behavior of the method. Unknown hints should be ignored and passed
    through on any recursive calls in case they are meant for other `as_real_imag()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: For our [`versin` example](#custom-functions-versine-definition), we can recursively
    use the `as_real_imag()` that is already defined for `1 - cos(x)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Defining `as_real_imag()` also automatically makes [`expand_complex()`](../modules/core.html#sympy.core.function.expand_complex
    "sympy.core.function.expand_complex") work.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Miscellaneous `_eval_*` methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'There are many other functions in SymPy whose behavior can be defined on custom
    functions via a custom `_eval_*` method, analogous to the ones described above.
    See the documentation of the specific function for details on how to define each
    method.  ## Complete Examples'
  prefs: []
  type: TYPE_NORMAL
- en: Here are complete examples for the example functions defined in this guide.
    See the above sections for details on each method.
  prefs: []
  type: TYPE_NORMAL
- en: '### Versine'
  prefs: []
  type: TYPE_NORMAL
- en: The versine (versed sine) function is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[\operatorname{versin}(x) = 1 - \cos(x).\]
  prefs: []
  type: TYPE_NORMAL
- en: Versine is an example of a simple function defined for all complex numbers.
    The mathematical definition is simple, which makes it straightforward to define
    all the above methods on it (in most cases we can just reuse the existing SymPy
    logic defined on `1 - cos(x)`).
  prefs: []
  type: TYPE_NORMAL
- en: Definition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Evaluation:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Assumptions:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '**Simplification:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '**Differentiation:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '**Solving:**'
  prefs: []
  type: TYPE_NORMAL
- en: (a more general version of `aversin` would have all the above methods defined
    as well)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]  ### divides'
  prefs: []
  type: TYPE_NORMAL
- en: divides is a function defined by
  prefs: []
  type: TYPE_NORMAL
- en: '\[\begin{split}\operatorname{divides}(m, n) = \begin{cases} 1 & \text{for}\:
    m \mid n \\ 0 & \text{for}\: m\not\mid n \end{cases},\end{split}\]'
  prefs: []
  type: TYPE_NORMAL
- en: that is, `divides(m, n)` is 1 if `m` divides `n` and `0` if `m` does not divide
    `m`. It is only defined for integer `m` and `n`. For the sake of simplicity, we
    use the convention that \(m \mid 0\) for all integer \(m\).
  prefs: []
  type: TYPE_NORMAL
- en: '`divides` is an example of a function that is only defined for certain input
    values (integers). `divides` also gives an example of defining a custom printer
    (`_latex()`).'
  prefs: []
  type: TYPE_NORMAL
- en: Definition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Evaluation**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '**Printing:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]  ### Fused Multiply-Add (FMA)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Fused Multiply-Add (FMA)](https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation#Fused_multiply%E2%80%93add)
    is a multiplication followed by an addition:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\operatorname{FMA}(x, y, z) = xy + z.\]
  prefs: []
  type: TYPE_NORMAL
- en: It is often implemented in hardware as a single floating-point operation that
    has better rounding and performance than the equivalent combination of multiplication
    and addition operations.
  prefs: []
  type: TYPE_NORMAL
- en: FMA is an example of a custom function that is defined as an unevaluated “shorthand”
    to another function. This is because the [`doit()`](#custom-functions-doit) method
    is defined to return `x*y + z`, meaning the `FMA` function can easily be evaluated
    to the expression is represents, but the [`eval()`](#custom-functions-eval) method
    does *not* return anything (except when `x`, `y`, and `z` are all explicit numeric
    values), meaning that it stays unevaluated by default.
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this with the [versine](#custom-functions-versine-full-example) example,
    which treats `versin` as a first-class function in its own regard. Even though
    `versin(x)` can be expressed in terms of other functions (`1 - cos(x)`) it does
    not evaluate on general symbolic inputs in `versin.eval()`, and `versin.doit()`
    is not defined at all.
  prefs: []
  type: TYPE_NORMAL
- en: '`FMA` also represents an example of a continuous function defined on multiple
    variables, which demonstrates how `argindex` works in the [`fdiff`](#custom-functions-differentiation)
    example.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, `FMA` shows an example of defining some code printers for `C` and `C++`
    (using the method names from [`C99CodePrinter.printmethod`](../modules/printing.html#sympy.printing.c.C99CodePrinter.printmethod
    "sympy.printing.c.C99CodePrinter.printmethod") and [`CXX11CodePrinter.printmethod`](../modules/printing.html#sympy.printing.cxx.CXX11CodePrinter.printmethod
    "sympy.printing.cxx.CXX11CodePrinter.printmethod")), since that is a typical use-case
    for this function.
  prefs: []
  type: TYPE_NORMAL
- en: The mathematical definition of FMA is very simple and it would be easy to define
    every method on it, but only a handful are shown here. The [versine](#custom-functions-versine-full-example)
    and [divides](#custom-functions-divides-full-example) examples show how to define
    the other important methods discussed in this guide.
  prefs: []
  type: TYPE_NORMAL
- en: Note that if you want to actually use fused-multiply add for code generation,
    there is already a version in SymPy `sympy.codegen.cfunctions.fma()` which is
    supported by the existing code printers. The version here is only designed to
    serve as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Definition
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '**Evaluation:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '**Differentiation**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '**Code Printers**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Additional Tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy includes dozens of functions. These can serve as useful examples for how
    to write a custom function, especially if the function is similar to one that
    is already implemented. Remember that everything in this guide applies equally
    well to functions that are included with SymPy and user-defined functions. Indeed,
    this guide is designed to serve as both a developer guide for contributors to
    SymPy and a guide for end-users of SymPy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have many custom functions that share common logic, you can use a common
    base class to contain this shared logic. For an example of this, see the [source
    code for the trigonometric functions in SymPy](https://github.com/sympy/sympy/blob/master/sympy/functions/elementary/trigonometric.py),
    which use `TrigonometricFunction`, `InverseTrigonometricFunction`, and `ReciprocalTrigonometricFunction`
    base classes with some shared logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with any code, it is a good idea to write extensive tests for your function.
    The [SymPy test suite](https://github.com/sympy/sympy/tree/master/sympy/functions/elementary/tests)
    is a good resource for examples of how to write tests for such functions. All
    code included in SymPy itself is required to be tested. Functions included in
    SymPy should also always contain a docstring with references, a mathematical definition,
    and doctest examples.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
