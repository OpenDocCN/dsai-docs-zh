["```py\n# Previously ignored the byte-order (affect if non-native)\nnp.add(3, 5, dtype=\">i32\")\n\n# The biggest impact is for timedelta or datetimes:\narr = np.arange(10, dtype=\"m8[s]\")\n# The examples always ignored the time unit \"ns\":\nnp.add(arr, arr, dtype=\"m8[ns]\")\nnp.maximum.reduce(arr, dtype=\"m8[ns]\")\n\n# The following previously did use \"ns\" (as opposed to `arr.dtype`)\nnp.add(3, 5, dtype=\"m8[ns]\")  # Now return generic time units\nnp.maximum(arr, arr, dtype=\"m8[ns]\")  # Now returns \"s\" (from `arr`) \n```", "```py\nsignature=(None, None, \"float64\") \n```", "```py\nsignature=(\"float64\", \"float64\", \"float64\") \n```", "```py\n[mypy]\nplugins  =  numpy.typing.mypy_plugin \n```", "```py\n[mypy]\nplugins  =  numpy.typing.mypy_plugin \n```", "```py\n>>> import numpy as np\n>>> import numpy.typing as npt\n\n>>> print(npt.NDArray)\nnumpy.ndarray[typing.Any, numpy.dtype[~ScalarType]]\n\n>>> print(npt.NDArray[np.float64])\nnumpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]\n\n>>> NDArrayInt = npt.NDArray[np.int_]\n>>> a: NDArrayInt = np.arange(10)\n\n>>> def func(a: npt.ArrayLike) -> npt.NDArray[Any]:\n...     return np.array(a) \n```", "```py\n>>> phase_deg = np.mod(np.linspace(0,720,19), 360) - 180\n>>> phase_deg\narray([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n -180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n -180.])\n\n>>> unwrap(phase_deg, period=360)\narray([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n 180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,\n 540.]) \n```", "```py\n# Previously ignored the byte-order (affect if non-native)\nnp.add(3, 5, dtype=\">i32\")\n\n# The biggest impact is for timedelta or datetimes:\narr = np.arange(10, dtype=\"m8[s]\")\n# The examples always ignored the time unit \"ns\":\nnp.add(arr, arr, dtype=\"m8[ns]\")\nnp.maximum.reduce(arr, dtype=\"m8[ns]\")\n\n# The following previously did use \"ns\" (as opposed to `arr.dtype`)\nnp.add(3, 5, dtype=\"m8[ns]\")  # Now return generic time units\nnp.maximum(arr, arr, dtype=\"m8[ns]\")  # Now returns \"s\" (from `arr`) \n```", "```py\nsignature=(None, None, \"float64\") \n```", "```py\nsignature=(\"float64\", \"float64\", \"float64\") \n```", "```py\n# Previously ignored the byte-order (affect if non-native)\nnp.add(3, 5, dtype=\">i32\")\n\n# The biggest impact is for timedelta or datetimes:\narr = np.arange(10, dtype=\"m8[s]\")\n# The examples always ignored the time unit \"ns\":\nnp.add(arr, arr, dtype=\"m8[ns]\")\nnp.maximum.reduce(arr, dtype=\"m8[ns]\")\n\n# The following previously did use \"ns\" (as opposed to `arr.dtype`)\nnp.add(3, 5, dtype=\"m8[ns]\")  # Now return generic time units\nnp.maximum(arr, arr, dtype=\"m8[ns]\")  # Now returns \"s\" (from `arr`) \n```", "```py\nsignature=(None, None, \"float64\") \n```", "```py\nsignature=(\"float64\", \"float64\", \"float64\") \n```", "```py\n[mypy]\nplugins  =  numpy.typing.mypy_plugin \n```", "```py\n[mypy]\nplugins  =  numpy.typing.mypy_plugin \n```", "```py\n>>> import numpy as np\n>>> import numpy.typing as npt\n\n>>> print(npt.NDArray)\nnumpy.ndarray[typing.Any, numpy.dtype[~ScalarType]]\n\n>>> print(npt.NDArray[np.float64])\nnumpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]\n\n>>> NDArrayInt = npt.NDArray[np.int_]\n>>> a: NDArrayInt = np.arange(10)\n\n>>> def func(a: npt.ArrayLike) -> npt.NDArray[Any]:\n...     return np.array(a) \n```", "```py\n[mypy]\nplugins  =  numpy.typing.mypy_plugin \n```", "```py\n[mypy]\nplugins  =  numpy.typing.mypy_plugin \n```", "```py\n>>> import numpy as np\n>>> import numpy.typing as npt\n\n>>> print(npt.NDArray)\nnumpy.ndarray[typing.Any, numpy.dtype[~ScalarType]]\n\n>>> print(npt.NDArray[np.float64])\nnumpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]\n\n>>> NDArrayInt = npt.NDArray[np.int_]\n>>> a: NDArrayInt = np.arange(10)\n\n>>> def func(a: npt.ArrayLike) -> npt.NDArray[Any]:\n...     return np.array(a) \n```", "```py\n>>> import numpy as np\n>>> import numpy.typing as npt\n\n>>> print(npt.NDArray)\nnumpy.ndarray[typing.Any, numpy.dtype[~ScalarType]]\n\n>>> print(npt.NDArray[np.float64])\nnumpy.ndarray[typing.Any, numpy.dtype[numpy.float64]]\n\n>>> NDArrayInt = npt.NDArray[np.int_]\n>>> a: NDArrayInt = np.arange(10)\n\n>>> def func(a: npt.ArrayLike) -> npt.NDArray[Any]:\n...     return np.array(a) \n```", "```py\n>>> phase_deg = np.mod(np.linspace(0,720,19), 360) - 180\n>>> phase_deg\narray([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n -180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n -180.])\n\n>>> unwrap(phase_deg, period=360)\narray([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n 180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,\n 540.]) \n```", "```py\n>>> phase_deg = np.mod(np.linspace(0,720,19), 360) - 180\n>>> phase_deg\narray([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n -180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n -180.])\n\n>>> unwrap(phase_deg, period=360)\narray([-180., -140., -100.,  -60.,  -20.,   20.,   60.,  100.,  140.,\n 180.,  220.,  260.,  300.,  340.,  380.,  420.,  460.,  500.,\n 540.]) \n```"]