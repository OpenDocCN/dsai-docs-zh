- en: NumPy 1.17.0 Release Notes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: NumPy 1.17.0 发布说明
- en: 原文：[https://numpy.org/doc/1.26/release/1.17.0-notes.html](https://numpy.org/doc/1.26/release/1.17.0-notes.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[https://numpy.org/doc/1.26/release/1.17.0-notes.html](https://numpy.org/doc/1.26/release/1.17.0-notes.html)'
- en: This NumPy release contains a number of new features that should substantially
    improve its performance and usefulness, see Highlights below for a summary. The
    Python versions supported are 3.5-3.7, note that Python 2.7 has been dropped.
    Python 3.8b2 should work with the released source packages, but there are no future
    guarantees.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这个NumPy版本包含了一些新特性，应该会显著提高其性能和实用性，请参见下面的亮点摘要。支持的Python版本为3.5-3.7，注意Python 2.7已经被移除。Python
    3.8b2应该可以与发布的源码包一起工作，但没有未来的保证。
- en: Downstream developers should use Cython >= 0.29.11 for Python 3.8 support and
    OpenBLAS >= 3.7 (not currently out) to avoid problems on the Skylake architecture.
    The NumPy wheels on PyPI are built from the OpenBLAS development branch in order
    to avoid those problems.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下游开发人员应该使用Cython >= 0.29.11来支持Python 3.8，以及OpenBLAS >= 3.7（目前还未发布）以避免在Skylake架构上出现问题。PyPI上的NumPy
    wheels是从OpenBLAS开发分支构建的，以避免这些问题。
- en: Highlights
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亮点
- en: A new extensible [`random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module along with four selectable *random number generators* and
    improved seeding designed for use in parallel processes has been added. The currently
    available bit generators are *MT19937*, *PCG64*, *Philox*, and *SFC64*. See below
    under New Features.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个新的可扩展的[`random`](../reference/random/index.html#module-numpy.random "numpy.random")模块，以及四个可选的*随机数生成器*和改进的种子设计，用于并行进程。当前的可用位生成器有*MT19937*，*PCG64*，*Philox*和*SFC64*。请参见下面的新特性。
- en: NumPy’s [`FFT`](../reference/routines.fft.html#module-numpy.fft "numpy.fft")
    implementation was changed from fftpack to pocketfft, resulting in faster, more
    accurate transforms and better handling of datasets of prime length. See below
    under Improvements.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NumPy的[`FFT`](../reference/routines.fft.html#module-numpy.fft "numpy.fft")实现从fftpack更改为pocketfft，导致更快，更准确的变换，并更好地处理素数长度的数据集。请参见下面的改进部分。
- en: New radix sort and timsort sorting methods. It is currently not possible to
    choose which will be used. They are hardwired to the datatype and used when either
    `stable` or `mergesort` is passed as the method. See below under Improvements.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的基数排序和timsort排序方法。目前不可能选择将使用哪一种。它们被硬编码到数据类型中，并且当`stable`或`mergesort`被传递为方法时使用。请参见下面的改进部分。
- en: Overriding numpy functions is now possible by default, see `__array_function__`
    below.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在默认情况下可以覆盖numpy函数，参见下面的`__array_function__`。
- en: New functions
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新函数
- en: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate") is now also a function decorator'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate")现在也是一个函数修饰器。'
- en: Deprecations
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 废弃功能
- en: '[`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") functions warn when passed `float` in place of `int`'
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当传递`int`的位置上的`float`时，[`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial")函数会发出警告。
- en: Previously functions in this module would accept `float` values provided they
    were integral (`1.0`, `2.0`, etc). For consistency with the rest of numpy, doing
    so is now deprecated, and in future will raise a `TypeError`.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这个模块中的函数会接受`float`值，只要它们是整数（`1.0`，`2.0`等）。为了与numpy的其余部分保持一致，此举现在已被弃用，并且在未来将引发`TypeError`。
- en: Similarly, passing a float like `0.5` in place of an integer will now raise
    a `TypeError` instead of the previous `ValueError`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在整数位置传递`0.5`这样的浮点数现在会引发`TypeError`而不是以前的`ValueError`。
- en: Deprecate [`numpy.distutils.exec_command`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") and `temp_file_name`
  id: totrans-15
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 废弃[`numpy.distutils.exec_command`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command")和`temp_file_name`
- en: The internal use of these functions has been refactored and there are better
    alternatives. Replace `exec_command` with [`subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen
    "(in Python v3.11)") and [`temp_file_name`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") with [`tempfile.mkstemp`](https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp
    "(in Python v3.11)").
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的内部使用已经进行了重构，并有更好的替代方案。用[`subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen
    "(in Python v3.11)")替换`exec_command`，用[`tempfile.mkstemp`](https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp
    "(in Python v3.11)")替换[`temp_file_name`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command")。
- en: Writeable flag of C-API wrapped arrays
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C-API包装数组的可写标志
- en: When an array is created from the C-API to wrap a pointer to data, the only
    indication we have of the read-write nature of the data is the `writeable` flag
    set during creation. It is dangerous to force the flag to writeable. In the future
    it will not be possible to switch the writeable flag to `True` from python. This
    deprecation should not affect many users since arrays created in such a manner
    are very rare in practice and only available through the NumPy C-API.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当从C-API创建数组以包装数据指针时，我们唯一可以得知数据读写性质的方式是在创建期间设置`writeable`标志。强制将标志设置为可写是危险的。在将来，将不再可能从python将`writeable`标志切换为`True`。此废弃不应影响许多用户，因为以这种方式创建的数组在实践中非常罕见，且仅通过NumPy
    C-API可用。
- en: '[`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero "numpy.nonzero")
    should no longer be called on 0d arrays'
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不应再对0维数组调用[`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero")
- en: The behavior of [`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero") on 0d arrays was surprising, making uses of it almost always
    incorrect. If the old behavior was intended, it can be preserved without a warning
    by using `nonzero(atleast_1d(arr))` instead of `nonzero(arr)`. In a future release,
    it is most likely this will raise a `ValueError`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在0维数组上调用[`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero")的行为令人惊讶，几乎总是不正确的。如果旧的行为是有意的，则可以通过`nonzero(atleast_1d(arr))`来保留，而不是`nonzero(arr)`，在将来的版本中，这很可能会引发`ValueError`。
- en: Writing to the result of [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") will warn
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入[`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays")的结果将会发出警告
- en: Commonly [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") returns a writeable array with internal overlap, making
    it unsafe to write to. A future version will set the `writeable` flag to `False`,
    and require users to manually set it to `True` if they are sure that is what they
    want to do. Now writing to it will emit a deprecation warning with instructions
    to set the `writeable` flag `True`. Note that if one were to inspect the flag
    before setting it, one would find it would already be `True`. Explicitly setting
    it, though, as one will need to do in future versions, clears an internal flag
    that is used to produce the deprecation warning. To help alleviate confusion,
    an additional *FutureWarning* will be emitted when accessing the `writeable` flag
    state to clarify the contradiction.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通常的[`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays")返回一个可写的数组，内部存在重叠，这样写入是不安全的。在将来的版本中，`writeable`标志将被设置为`False`，并要求用户手动将其设置为`True`，如果他们确定这样做是他们想要的。现在写入会发出一个废弃警告，并附有设置`writeable`标志`True`的说明。请注意，如果在设置之前检查标志，将发现它已经为`True`
    。然而，明确地设置它，正如在将来的版本中所需要的，会清除用于产生废弃警告的内部标志。为了帮助缓解混淆，当访问`writeable`标志状态时，会发出额外的*FutureWarning*来澄清矛盾。
- en: Note that for the C-side buffer protocol such an array will return a readonly
    buffer immediately unless a writable buffer is requested. If a writeable buffer
    is requested a warning will be given. When using cython, the `const` qualifier
    should be used with such arrays to avoid the warning (e.g. `cdef const double[::1]
    view`).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于C端的缓冲协议，这样的数组将立即返回一个只读缓冲区，除非请求一个可写的缓冲区。如果请求可写的缓冲区将会发出警告。在使用cython时，应该在此类数组上使用`const`修饰符以避免警告（例如`cdef
    const double[::1] view`）。
- en: Future Changes
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来的变化
- en: Shape-1 fields in dtypes won’t be collapsed to scalars in a future version
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在将来的版本中，dtype中的shape-1字段将不会被压缩为标量。
- en: Currently, a field specified as `[(name, dtype, 1)]` or `"1type"` is interpreted
    as a scalar field (i.e., the same as `[(name, dtype)]` or `[(name, dtype, ()]`).
    This now raises a FutureWarning; in a future version, it will be interpreted as
    a shape-(1,) field, i.e. the same as `[(name, dtype, (1,))]` or `"(1,)type"` (consistently
    with `[(name, dtype, n)]` / `"ntype"` with `n>1`, which is already equivalent
    to `[(name, dtype, (n,)]` / `"(n,)type"`).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，指定为 `[(name, dtype, 1)]` 或 `"1type"` 的字段被解释为标量字段（即与 `[(name, dtype)]` 或 `[(name,
    dtype, ()]` 相同）。现在将引发 FutureWarning；在将来的版本中，它将被解释为形状为 (1,) 的字段，即与 `[(name, dtype,
    (1,))]` 或 `"(1,)type"` 相同（与已经等效为 `[(name, dtype, n)]` / `"ntype"` 且 `n>1` 的情况一致，它已经等效为
    `[(name, dtype, (n,)]` / `"(n,)type"`）。
- en: Compatibility notes
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兼容性注意事项
- en: '`float16` subnormal rounding'
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`float16` 下溢舍入'
- en: Casting from a different floating point precision to `float16` used incorrect
    rounding in some edge cases. This means in rare cases, subnormal results will
    now be rounded up instead of down, changing the last bit (ULP) of the result.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同的浮点精度转换到 `float16` 在某些边缘情况下使用了不正确的四舍五入。这意味着在罕见情况下，下溢结果现在会四舍进一而不是舍去，改变了结果的最后一位（ULP）。
- en: Signed zero when using divmod
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 divmod 时的有符号零
- en: 'Starting in version *1.12.0*, numpy incorrectly returned a negatively signed
    zero when using the `divmod` and `floor_divide` functions when the result was
    zero. For example:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 *1.12.0* 开始，当使用 `divmod` 和 `floor_divide` 函数得到结果为零时，numpy 返回一个负符号零。
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With this release, the result is correctly returned as a positively signed
    zero:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此版本，结果现在正确地作为正符号零返回：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`MaskedArray.mask` now returns a view of the mask, not the mask itself'
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`MaskedArray.mask` 现在返回掩码的一个视图，而不是掩码本身。'
- en: Returning the mask itself was unsafe, as it could be reshaped in place which
    would violate expectations of the masked array code. The behavior of [`mask`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") is now consistent with [`data`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data"), which also returns a view.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 返回掩码本身是不安全的，因为它可能被直接重塑，从而违反掩码数组代码的期望。现在 [`mask`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") 的行为与 [`data`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data") 一致，也返回一个视图。
- en: The underlying mask can still be accessed with `._mask` if it is needed. Tests
    that contain `assert x.mask is not y.mask` or similar will need to be updated.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，可以仍然访问底层掩码 `._mask`。包含 `assert x.mask is not y.mask` 或类似内容的测试将需要更新。
- en: Do not lookup `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer")
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在 [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer") 中查找 `__buffer__` 属性。
- en: Looking up `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer") was undocumented and non-functional. This code was removed.
    If needed, use `frombuffer(memoryview(obj), ...)` instead.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查找 `__buffer__` 属性在 [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer") 中是未记录且无效的。该代码已被移除。如果需要，使用 `frombuffer(memoryview(obj), ...)`
    代替。
- en: '`out` is buffered for memory overlaps in [`take`](../reference/generated/numpy.take.html#numpy.take
    "numpy.take"), [`choose`](../reference/generated/numpy.choose.html#numpy.choose
    "numpy.choose"), [`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put")'
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 [`take`](../reference/generated/numpy.take.html#numpy.take "numpy.take")、[`choose`](../reference/generated/numpy.choose.html#numpy.choose
    "numpy.choose")、[`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put")
    中，`out` 在内存重叠时会被缓冲。
- en: If the out argument to these functions is provided and has memory overlap with
    the other arguments, it is now buffered to avoid order-dependent behavior.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些函数的输出参数提供并且与其他参数有内存重叠，则现在将对其进行缓冲以避免依赖顺序的行为。
- en: Unpickling while loading requires explicit opt-in
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载时进行解托的拆包需要明确选择
- en: The functions [`load`](../reference/generated/numpy.load.html#numpy.load "numpy.load"),
    and `lib.format.read_array` take an `allow_pickle` keyword which now defaults
    to `False` in response to [CVE-2019-6446](https://nvd.nist.gov/vuln/detail/CVE-2019-6446).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 [`load`](../reference/generated/numpy.load.html#numpy.load "numpy.load")
    和 `lib.format.read_array` 现在包含一个 `allow_pickle` 关键字，默认为 `False`，以应对 [CVE-2019-6446](https://nvd.nist.gov/vuln/detail/CVE-2019-6446)。
- en: Potential changes to the random stream in old random module
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旧随机模块中随机流的潜在更改
- en: Due to bugs in the application of `log` to random floating point numbers, the
    stream may change when sampling from [`beta`](../reference/random/generated/numpy.random.RandomState.beta.html#numpy.random.RandomState.beta
    "numpy.random.RandomState.beta"), [`binomial`](../reference/random/generated/numpy.random.RandomState.binomial.html#numpy.random.RandomState.binomial
    "numpy.random.RandomState.binomial"), [`laplace`](../reference/random/generated/numpy.random.RandomState.laplace.html#numpy.random.RandomState.laplace
    "numpy.random.RandomState.laplace"), [`logistic`](../reference/random/generated/numpy.random.RandomState.logistic.html#numpy.random.RandomState.logistic
    "numpy.random.RandomState.logistic"), [`logseries`](../reference/random/generated/numpy.random.RandomState.logseries.html#numpy.random.RandomState.logseries
    "numpy.random.RandomState.logseries") or [`multinomial`](../reference/random/generated/numpy.random.RandomState.multinomial.html#numpy.random.RandomState.multinomial
    "numpy.random.RandomState.multinomial") if a `0` is generated in the underlying
    [`MT19937`](../reference/random/bit_generators/mt19937.html#numpy.random.MT19937
    "numpy.random.MT19937") random stream. There is a `1` in \(10^{53}\) chance of
    this occurring, so the probability that the stream changes for any given seed
    is extremely small. If a `0` is encountered in the underlying generator, then
    the incorrect value produced (either [`numpy.inf`](../reference/constants.html#numpy.inf
    "numpy.inf") or [`numpy.nan`](../reference/constants.html#numpy.nan "numpy.nan"))
    is now dropped.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将`log`应用于随机浮点数时存在错误，当从[`beta`](../reference/random/generated/numpy.random.RandomState.beta.html#numpy.random.RandomState.beta
    "numpy.random.RandomState.beta"), [`binomial`](../reference/random/generated/numpy.random.RandomState.binomial.html#numpy.random.RandomState.binomial
    "numpy.random.RandomState.binomial"), [`laplace`](../reference/random/generated/numpy.random.RandomState.laplace.html#numpy.random.RandomState.laplace
    "numpy.random.RandomState.laplace"), [`logistic`](../reference/random/generated/numpy.random.RandomState.logistic.html#numpy.random.RandomState.logistic
    "numpy.random.RandomState.logistic"), [`logseries`](../reference/random/generated/numpy.random.RandomState.logseries.html#numpy.random.RandomState.logseries
    "numpy.random.RandomState.logseries") 或 [`multinomial`](../reference/random/generated/numpy.random.RandomState.multinomial.html#numpy.random.RandomState.multinomial
    "numpy.random.RandomState.multinomial") 进行抽样时，如果在底层的[`MT19937`](../reference/random/bit_generators/mt19937.html#numpy.random.MT19937
    "numpy.random.MT19937")随机流中生成`0`，则流可能会更改。这种情况发生的概率是$10^{53}$分之1，因此对于任何给定的种子，流发生改变的概率极小。如果在底层生成器中遇到`0`，那么现在会放弃生成的不正确值（要么是[`numpy.inf`](../reference/constants.html#numpy.inf
    "numpy.inf")，要么是[`numpy.nan`](../reference/constants.html#numpy.nan "numpy.nan")）。
- en: '[`i0`](../reference/generated/numpy.i0.html#numpy.i0 "numpy.i0") now always
    returns a result with the same shape as the input'
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`i0`](../reference/generated/numpy.i0.html#numpy.i0 "numpy.i0") 现在始终返回与输入相同形状的结果'
- en: Previously, the output was squeezed, such that, e.g., input with just a single
    element would lead to an array scalar being returned, and inputs with shapes such
    as `(10, 1)` would yield results that would not broadcast against the input.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，输出会被挤压，因此，例如，只有一个元素的输入将导致返回一个数组标量，并且具有形状如`(10, 1)`的输入会产生无法广播到输入的结果。
- en: 'Note that we generally recommend the SciPy implementation over the numpy one:
    it is a proper ufunc written in C, and more than an order of magnitude faster.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通常建议使用SciPy实现而不是numpy实现：它是用C编写的适当`ufunc`，速度比numpy快一个数量级以上。
- en: '[`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast "numpy.can_cast")
    no longer assumes all unsafe casting is allowed'
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast "numpy.can_cast")
    不再假设所有不安全的转换都被允许'
- en: Previously, [`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast
    "numpy.can_cast") returned *True* for almost all inputs for `casting='unsafe'`,
    even for cases where casting was not possible, such as from a structured dtype
    to a regular one. This has been fixed, making it more consistent with actual casting
    using, e.g., the [`.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype") method.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 先前，[`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast "numpy.can_cast")
    对于`casting='unsafe'`的几乎所有输入都返回*True*，即使在不可能转换的情况下，例如从结构化`dtype`到常规`dtype`。已修复此问题，使其与实际转换更一致，例如使用[`.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype")方法。
- en: '`ndarray.flags.writeable` can be switched to true slightly more often'
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ndarray.flags.writeable` 现在会更频繁地切换到true。'
- en: In rare cases, it was not possible to switch an array from not writeable to
    writeable, although a base array is writeable. This can happen if an intermediate
    [`ndarray.base`](../reference/generated/numpy.ndarray.base.html#numpy.ndarray.base
    "numpy.ndarray.base") object is writeable. Previously, only the deepest base object
    was considered for this decision. However, in rare cases this object does not
    have the necessary information. In that case switching to writeable was never
    allowed. This has now been fixed.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在极少情况下，虽然基本数组是可写的，但是不可能将数组从不可写切换为可写。如果一个中间 [`ndarray.base`](../reference/generated/numpy.ndarray.base.html#numpy.ndarray.base
    "numpy.ndarray.base") 对象是可写的，可能会发生这种情况。先前，仅考虑了最深的基本对象来做出这个决定。但是，在极少情况下，这个对象没有必要的信息。在这种情况下，切换为可写是永远不允许的。现在已经修复了这个问题。
- en: C API changes
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C API 变更
- en: dimension or stride input arguments are now passed by `npy_intp const*`
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维度或步幅输入参数现在通过`npy_intp const*`传递
- en: 'Previously these function arguments were declared as the more strict `npy_intp*`,
    which prevented the caller passing constant data. This change is backwards compatible,
    but now allows code like:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 先前，这些函数参数被声明为更严格的 `npy_intp*`，这阻止了调用者传递常量数据。这个改变是向后兼容的，但是现在允许像下面这样的代码：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: New Features
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新特性
- en: New extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module with selectable random number generators
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的可扩展 [`numpy.random`](../reference/random/index.html#module-numpy.random "numpy.random")
    模块，可选择随机数生成器
- en: A new extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module along with four selectable random number generators and
    improved seeding designed for use in parallel processes has been added. The currently
    available *Bit Generators* are *MT19937*, *PCG64*, *Philox*, and *SFC64*. `PCG64`
    is the new default while `MT19937` is retained for backwards compatibility. Note
    that the legacy random module is unchanged and is now frozen, your current results
    will not change. More information is available in the [API change description](../reference/random/new-or-different.html#new-or-different)
    and in the [`top-level view`](../reference/random/index.html#module-numpy.random
    "numpy.random") documentation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 新的可扩展 [`numpy.random`](../reference/random/index.html#module-numpy.random "numpy.random")
    模块与四个可选的随机数生成器以及用于并行进程的改进种子设定已经添加。目前可用的*Bit Generators*是*MT19937*、*PCG64*、*Philox*和*SFC64*。`PCG64`是新的默认值，而`MT19937`保留了向后兼容性。请注意，传统的random模块未更改，并且现在已被冻结，您当前的结果不会改变。更多信息，请参阅[API变更描述](../reference/random/new-or-different.html#new-or-different)和[`顶级视图`](../reference/random/index.html#module-numpy.random
    "numpy.random")文档。
- en: libFLAME
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: libFLAME
- en: Support for building NumPy with the libFLAME linear algebra package as the LAPACK,
    implementation, see [libFLAME](https://www.cs.utexas.edu/~flame/web/libFLAME.html)
    for details.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 支持构建使用libFLAME线性代数包作为LAPACK实现的NumPy，详情请见 [libFLAME](https://www.cs.utexas.edu/~flame/web/libFLAME.html)。
- en: User-defined BLAS detection order
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户自定义的BLAS检测顺序
- en: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    now uses an environment variable, comma-separated and case insensitive, to determine
    the detection order for BLAS libraries. By default `NPY_BLAS_ORDER=mkl,blis,openblas,atlas,accelerate,blas`.
    However, to force the use of OpenBLAS simply do:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    现在使用一个环境变量，不区分大小写和逗号分隔，来确定BLAS库的检测顺序。默认情况下为 `NPY_BLAS_ORDER=mkl,blis,openblas,atlas,accelerate,blas`。然而，要强制使用OpenBlas只需执行：'
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 强制使用OpenBLAS。这对于安装了MKL但希望尝试不同实现的用户可能是有帮助的。
- en: User-defined LAPACK detection order
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户自定义LAPACK检测顺序
- en: '`numpy.distutils` now uses an environment variable, comma-separated and case
    insensitive, to determine the detection order for LAPACK libraries. By default
    `NPY_LAPACK_ORDER=mkl,openblas,flame,atlas,accelerate,lapack`. However, to force
    the use of OpenBLAS simply do:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.distutils` 现在使用一个环境变量，不区分大小写和逗号分隔，来确定LAPACK库的检测顺序。默认情况下为 `NPY_LAPACK_ORDER=mkl,openblas,flame,atlas,accelerate,lapack`。但是，要强制使用OpenBLAS只需执行：'
- en: '[PRE4]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 强制使用OpenBLAS。这对于安装了MKL但希望尝试不同实现的用户可能是有帮助的。
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce") and related functions now accept a `where` mask'
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce") 及相关函数现在接受 `where` 掩码'
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce"), [`sum`](../reference/generated/numpy.sum.html#numpy.sum
    "numpy.sum"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min"), [`max`](../reference/generated/numpy.max.html#numpy.max
    "numpy.max") all now accept a `where` keyword argument, which can be used to tell
    which elements to include in the reduction. For reductions that do not have an
    identity, it is necessary to also pass in an initial value (e.g., `initial=np.inf`
    for [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min")). For
    instance, the equivalent of [`nansum`](../reference/generated/numpy.nansum.html#numpy.nansum
    "numpy.nansum") would be `np.sum(a, where=~np.isnan(a))`.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce")，[`sum`](../reference/generated/numpy.sum.html#numpy.sum
    "numpy.sum")，[`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod")，[`min`](../reference/generated/numpy.min.html#numpy.min
    "numpy.min")，[`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max")
    现在都接受一个 `where` 关键字参数，这可以用于告诉缩减中应包含哪些元素。 对于没有单位元的缩减，还需要传入一个初始值（例如，对于 [`min`](../reference/generated/numpy.min.html#numpy.min
    "numpy.min") 使用`initial=np.inf`）。 例如，[`nansum`](../reference/generated/numpy.nansum.html#numpy.nansum
    "numpy.nansum") 的等价物将是 `np.sum(a, where=~np.isnan(a))`。'
- en: Timsort and radix sort have replaced mergesort for stable sorting
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Timsort和radix sort已代替mergesort进行稳定排序
- en: Both radix sort and timsort have been implemented and are now used in place
    of mergesort. Due to the need to maintain backward compatibility, the sorting
    `kind` options `"stable"` and `"mergesort"` have been made aliases of each other
    with the actual sort implementation depending on the array type. Radix sort is
    used for small integer types of 16 bits or less and timsort for the remaining
    types. Timsort features improved performance on data containing already or nearly
    sorted data and performs like mergesort on random data and requires \(O(n/2)\)
    working space. Details of the timsort algorithm can be found at [CPython listsort.txt](https://github.com/python/cpython/blob/3.7/Objects/listsort.txt).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: radix sort和timsort都已经被实现，并现在用来代替mergesort。 由于需要保持向后兼容性，排序`kind`选项 `"stable"`
    和 `"mergesort"` 已被制作成对方的别名，实际排序实现取决于数组类型。 对于小于16位的小整数类型使用radix sort，而剩下的类型使用timsort。
    Timsort在包含已经或几乎排序好的数据时具有改善的性能，并且在随机数据上像mergesort一样执行，并且需要\(O(n/2)\)的工作空间。 Timsort算法的详细信息可以在
    [CPython listsort.txt](https://github.com/python/cpython/blob/3.7/Objects/listsort.txt)
    找到。
- en: '[`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits "numpy.packbits")
    and [`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") accept an `order` keyword'
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits "numpy.packbits")和[`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") 接受`order`关键字'
- en: The `order` keyword defaults to `big`, and will order the **bits** accordingly.
    For `'order=big'` 3 will become `[0, 0, 0, 0, 0, 0, 1, 1]`, and `[1, 1, 0, 0,
    0, 0, 0, 0]` for `order=little`
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`order`关键字默认为`big`，并且将相应地排序**bits**。 对于 `''order=big''`，3将变成`[0, 0, 0, 0, 0,
    0, 1, 1]`，对于`order=little` 为`[1, 1, 0, 0, 0, 0, 0, 0]`'
- en: '[`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") now accepts a `count` parameter'
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits")现在接受`count`参数'
- en: '`count` allows subsetting the number of bits that will be unpacked up-front,
    rather than reshaping and subsetting later, making the [`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits
    "numpy.packbits") operation invertible, and the unpacking less wasteful. Counts
    larger than the number of available bits add zero padding. Negative counts trim
    bits off the end instead of counting from the beginning. None counts implement
    the existing behavior of unpacking everything.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`count`允许对将要预处理的比特数进行子集化，而不是稍后进行重塑和子集化，使得[`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits
    "numpy.packbits")操作可逆，而拆包则不那么浪费。 大于可用比特数的计数添加零填充。 负计数则从末尾截取比特，而不是从开头计数。 无计数实现了拆包所有内容的现有行为。'
- en: '[`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd") and [`linalg.pinv`](../reference/generated/numpy.linalg.pinv.html#numpy.linalg.pinv
    "numpy.linalg.pinv") can be faster on hermitian inputs'
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd")和[`linalg.pinv`](../reference/generated/numpy.linalg.pinv.html#numpy.linalg.pinv
    "numpy.linalg.pinv") 在hermitian输入上可以更快'
- en: These functions now accept a `hermitian` argument, matching the one added to
    [`linalg.matrix_rank`](../reference/generated/numpy.linalg.matrix_rank.html#numpy.linalg.matrix_rank
    "numpy.linalg.matrix_rank") in 1.14.0.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数现在接受一个`hermitian`参数，和1.14.0版本中添加到[`linalg.matrix_rank`](../reference/generated/numpy.linalg.matrix_rank.html#numpy.linalg.matrix_rank
    "numpy.linalg.matrix_rank")的参数相匹配。
- en: divmod operation is now supported for two `timedelta64` operands
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: divmod运算现在支持两个`timedelta64`操作数
- en: The divmod operator now handles two `timedelta64` operands, with type signature
    `mm->qm`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: divmod运算现在支持两个`timedelta64`操作数，其类型签名为`mm->qm`。
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile")
    now takes an `offset` argument'
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile")现在接受一个`offset`参数'
- en: This function now takes an `offset` keyword argument for binary files, which
    specifics the offset (in bytes) from the file’s current position. Defaults to
    `0`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数现在接受一个用于二进制文件的`offset`关键字参数，指定了从文件当前位置的偏移量（以字节为单位）。默认为`0`。
- en: New mode “empty” for [`pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`pad`](../reference/generated/numpy.pad.html#numpy.pad "numpy.pad")的新模式“empty”'
- en: This mode pads an array to a desired shape without initializing the new entries.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式可使数组填充到所需形状，而不初始化新条目。
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like") and related functions now accept a `shape` argument'
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like")和相关函数现在接受一个`shape`参数'
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`full_like`](../reference/generated/numpy.full_like.html#numpy.full_like
    "numpy.full_like"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like") and [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like") now accept a `shape` keyword argument, which can be used to
    create a new array as the prototype, overriding its shape as well. This is particularly
    useful when combined with the `__array_function__` protocol, allowing the creation
    of new arbitrary-shape arrays from NumPy-like libraries when such an array is
    used as the prototype.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like")、[`full_like`](../reference/generated/numpy.full_like.html#numpy.full_like
    "numpy.full_like")、[`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like")和[`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like")现在接受一个`shape`关键字参数，可用于创建一个新的数组作为原型，同时覆盖其形状。在与`__array_function__`协议结合使用时非常有用，允许从类似
    NumPy 的库创建新的任意形状数组，当这样的数组用作原型时。'
- en: Floating point scalars implement `as_integer_ratio` to match the builtin float
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点标量实现`as_integer_ratio`以匹配内置的浮点数
- en: This returns a (numerator, denominator) pair, which can be used to construct
    a [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)").
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这返回一个(分子，分母)对，可用于构造一个[`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)")。
- en: Structured `dtype` objects can be indexed with multiple fields names
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构化`dtype`对象可以用多个字段名称进行索引
- en: '`arr.dtype[[''a'', ''b'']]` now returns a dtype that is equivalent to `arr[[''a'',
    ''b'']].dtype`, for consistency with `arr.dtype[''a''] == arr[''a''].dtype`.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`arr.dtype[[''a'', ''b'']]`现在返回一个等价于`arr[[''a'', ''b'']].dtype`的dtype，以保持与`arr.dtype[''a'']
    == arr[''a''].dtype`的一致性。'
- en: Like the dtype of structured arrays indexed with a list of fields, this dtype
    has the same `itemsize` as the original, but only keeps a subset of the fields.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用字段列表索引的结构化数组的dtype一样，这个dtype与原始的`itemsize`相同，但只保留字段的子集。
- en: This means that `arr[['a', 'b']]` and `arr.view(arr.dtype[['a', 'b']])` are
    equivalent.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着`arr[['a', 'b']]`和`arr.view(arr.dtype[['a', 'b']])`是等价的。
- en: '`.npy` files support unicode field names'
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`.npy`文件支持unicode字段名称'
- en: A new format version of 3.0 has been introduced, which enables structured types
    with non-latin1 field names. This is used automatically when needed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 引入了一个新的3.0格式版本，允许具有非拉丁1字段名称的结构化类型。需要时将自动使用此功能。
- en: Improvements
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进
- en: Array comparison assertions include maximum differences
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组比较断言包括最大差异
- en: Error messages from array comparison tests such as [`testing.assert_allclose`](../reference/generated/numpy.testing.assert_allclose.html#numpy.testing.assert_allclose
    "numpy.testing.assert_allclose") now include “max absolute difference” and “max
    relative difference,” in addition to the previous “mismatch” percentage. This
    information makes it easier to update absolute and relative error tolerances.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如[`testing.assert_allclose`](../reference/generated/numpy.testing.assert_allclose.html#numpy.testing.assert_allclose
    "numpy.testing.assert_allclose")的数组比较测试的错误消息现在包括“最大绝对差异”和“最大相对差异”，而不仅仅是以前的“不匹配”百分比。这些信息使更新绝对误差和相对误差容忍度更容易。
- en: Replacement of the fftpack based [`fft`](../reference/routines.fft.html#module-numpy.fft
    "numpy.fft") module by the pocketfft library
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过pocketfft库替换基于fftpack的[`fft`](../reference/routines.fft.html#module-numpy.fft
    "numpy.fft")模块
- en: Both implementations have the same ancestor (Fortran77 FFTPACK by Paul N. Swarztrauber),
    but pocketfft contains additional modifications which improve both accuracy and
    performance in some circumstances. For FFT lengths containing large prime factors,
    pocketfft uses Bluestein’s algorithm, which maintains \(O(N log N)\) run time
    complexity instead of deteriorating towards \(O(N*N)\) for prime lengths. Also,
    accuracy for real valued FFTs with near prime lengths has improved and is on par
    with complex valued FFTs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 两种实现都有相同的祖先（Paul N. Swarztrauber的Fortran77 FFTPACK），但是pocketfft包含额外的修改，这些修改改善了某些情况下的准确性和性能。对于包含大素数因子的FFT长度，pocketfft使用Bluestein算法，该算法保持了\(O(N
    log N)\)的运行时间复杂度，而不是素数长度变差为\(O(N*N)\)。另外，对于接近素数长度的实值FFT的准确性得到改善，与复值FFT的准确性相当。
- en: Further improvements to `ctypes` support in [`numpy.ctypeslib`](../reference/routines.ctypeslib.html#module-numpy.ctypeslib
    "numpy.ctypeslib")
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`numpy.ctypeslib`](../reference/routines.ctypeslib.html#module-numpy.ctypeslib
    "numpy.ctypeslib")中`ctypes`支持的进一步改进'
- en: A new [`numpy.ctypeslib.as_ctypes_type`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes_type
    "numpy.ctypeslib.as_ctypes_type") function has been added, which can be used to
    converts a [`dtype`](../reference/generated/numpy.dtype.html#numpy.dtype "numpy.dtype")
    into a best-guess [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.11)") type. Thanks to this new function, [`numpy.ctypeslib.as_ctypes`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes
    "numpy.ctypeslib.as_ctypes") now supports a much wider range of array types, including
    structures, booleans, and integers of non-native endianness.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新的[`numpy.ctypeslib.as_ctypes_type`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes_type
    "numpy.ctypeslib.as_ctypes_type")函数，该函数可以将[`dtype`](../reference/generated/numpy.dtype.html#numpy.dtype
    "numpy.dtype")转换为最佳猜测的[`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(在Python v3.11中)")类型。由于这个新函数，[`numpy.ctypeslib.as_ctypes`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes
    "numpy.ctypeslib.as_ctypes")现在支持更广泛的数组类型，包括结构体、布尔值和非本机字节顺序的整数。
- en: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate") is now also a function decorator'
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate")现在也是一个函数装饰器'
- en: 'Currently, if you have a function like:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，如果你有一个像这样的函数：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'and you want to wrap the whole thing in [`errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate"), you have to rewrite it like so:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将整个东西包装在[`errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate")中，你必须像这样重写它：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'but with this change, you can do:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 但是有了这个改变，你可以这样做：
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: thereby saving a level of indentation
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从而节省一级缩进
- en: '[`numpy.exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp")
    and [`numpy.log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    speed up for float32 implementation'
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`numpy.exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp")和[`numpy.log`](../reference/generated/numpy.log.html#numpy.log
    "numpy.log")的float32实现加速'
- en: float32 implementation of [`exp`](../reference/generated/numpy.exp.html#numpy.exp
    "numpy.exp") and [`log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    now benefit from AVX2/AVX512 instruction set which are detected during runtime.
    [`exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp") has a max
    ulp error of 2.52 and [`log`](../reference/generated/numpy.log.html#numpy.log
    "numpy.log") has a max ulp error or 3.83.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[`exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp")和[`log`](../reference/generated/numpy.log.html#numpy.log
    "numpy.log")的float32实现现在受益于AVX2/AVX512指令集，这些指令集在运行时被检测到。[`exp`](../reference/generated/numpy.exp.html#numpy.exp
    "numpy.exp")的最大ulp误差为2.52，[`log`](../reference/generated/numpy.log.html#numpy.log
    "numpy.log")的最大ulp误差为3.83。'
- en: Improve performance of [`numpy.pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改进[`numpy.pad`](../reference/generated/numpy.pad.html#numpy.pad "numpy.pad")的性能
- en: The performance of the function has been improved for most cases by filling
    in a preallocated array with the desired padded shape instead of using concatenation.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，该函数的性能已经得到改善，通过使用预分配的数组填充所需的填充形状，而不是使用串联。
- en: '[`numpy.interp`](../reference/generated/numpy.interp.html#numpy.interp "numpy.interp")
    handles infinities more robustly'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`numpy.interp`](../reference/generated/numpy.interp.html#numpy.interp "numpy.interp")
    更稳健地处理无穷大'
- en: In some cases where [`interp`](../reference/generated/numpy.interp.html#numpy.interp
    "numpy.interp") would previously return [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"), it now returns an appropriate infinity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些情况下，[`interp`](../reference/generated/numpy.interp.html#numpy.interp "numpy.interp")
    以前会返回 [`nan`](../reference/constants.html#numpy.nan "numpy.nan")，现在会返回适当的无穷大。
- en: Pathlib support for [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile"), *tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump")
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile")
    的 `tofile` 和 *ndarray.dump* 对 *Pathlib* 的支持'
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile"),
    *ndarray.ndarray.tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump") now support the [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path
    "(in Python v3.11)") type for the `file`/`fid` parameter.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile")、*ndarray.ndarray.tofile*
    和 [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump") 现在支持 `pathlib.Path` 类型用于 `file`/`fid` 参数。'
- en: Specialized [`isnan`](../reference/generated/numpy.isnan.html#numpy.isnan "numpy.isnan"),
    [`isinf`](../reference/generated/numpy.isinf.html#numpy.isinf "numpy.isinf"),
    and [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    ufuncs for bool and int types
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 专门的 [`isnan`](../reference/generated/numpy.isnan.html#numpy.isnan "numpy.isnan")、[`isinf`](../reference/generated/numpy.isinf.html#numpy.isinf
    "numpy.isinf") 和 [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite
    "numpy.isfinite") ufuncs 适用于 bool 和 int 类型
- en: The boolean and integer types are incapable of storing [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan") and [`inf`](../reference/constants.html#numpy.inf "numpy.inf") values,
    which allows us to provide specialized ufuncs that are up to 250x faster than
    the previous approach.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔和整数类型无法存储 [`nan`](../reference/constants.html#numpy.nan "numpy.nan") 和 [`inf`](../reference/constants.html#numpy.inf
    "numpy.inf") 值，这使我们能够提供比以前方法快250倍的专门的 ufuncs。
- en: '[`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    supports `datetime64` and `timedelta64` types'
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    支持 `datetime64` 和 `timedelta64` 类型'
- en: Previously, [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite
    "numpy.isfinite") used to raise a *TypeError* on being used on these two types.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，当在这两种类型上使用[`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite
    "numpy.isfinite")时，会引发 *TypeError*
- en: New keywords added to [`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num")
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num") 添加了新关键字'
- en: '[`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num") now accepts keywords `nan`, `posinf` and `neginf` allowing
    the user to define the value to replace the `nan`, positive and negative `np.inf`
    values respectively.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num") 现在接受关键字 `nan`、`posinf` 和 `neginf`，允许用户定义替换 `nan`、正 `np.inf`
    值和负 `np.inf` 值的值。'
- en: MemoryErrors caused by allocated overly large arrays are more descriptive
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 由于分配过大的数组可能导致内存错误，这些错误更具描述性
- en: Often the cause of a MemoryError is incorrect broadcasting, which results in
    a very large and incorrect shape. The message of the error now includes this shape
    to help diagnose the cause of failure.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 内存错误的原因经常是不正确的广播，导致非常庞大和错误的形状。错误消息现在包含此形状，以帮助诊断故障的原因。
- en: '[`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor"),
    [`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil "numpy.ceil"), and
    [`trunc`](../reference/generated/numpy.trunc.html#numpy.trunc "numpy.trunc") now
    respect builtin magic methods'
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor")、[`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil
    "numpy.ceil") 和 [`trunc`](../reference/generated/numpy.trunc.html#numpy.trunc
    "numpy.trunc") 现在尊重内置魔术方法'
- en: These ufuncs now call the `__floor__`, `__ceil__`, and `__trunc__` methods when
    called on object arrays, making them compatible with [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") and [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)") objects.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当在单元素数组上调用这些ufunc时，现在会调用`__floor__`、`__ceil__`和`__trunc__`方法，使其与[`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(在 Python v3.11)")和[`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(在 Python v3.11)")对象兼容。
- en: '[`quantile`](../reference/generated/numpy.quantile.html#numpy.quantile "numpy.quantile")
    now works on *fraction.Fraction* and [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") objects'
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`quantile`](../reference/generated/numpy.quantile.html#numpy.quantile "numpy.quantile")现在适用于*Fraction.Fraction*和[`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(在 Python v3.11)")对象'
- en: In general, this handles object arrays more gracefully, and avoids floating-
    point operations if exact arithmetic types are used.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这种方法更优雅地处理对象数组，并且在使用精确算术类型时避免了浮点运算。
- en: Support of object arrays in [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul")
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元素数组在[`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul "numpy.matmul")中的支持
- en: 'It is now possible to use [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul") (or the `@` operator) with object arrays. For instance, it is
    now possible to do:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用[`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul "numpy.matmul")（或`@`运算符）与单元素数组一起使用。例如，现在可以这样做：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Changes
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变更
- en: '[`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median")
    and [`percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile") family of functions no longer warn about `nan`'
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median")和[`percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile")系列函数不再警告`nan`值'
- en: '[`numpy.median`](../reference/generated/numpy.median.html#numpy.median "numpy.median"),
    [`numpy.percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile"), and [`numpy.quantile`](../reference/generated/numpy.quantile.html#numpy.quantile
    "numpy.quantile") used to emit a `RuntimeWarning` when encountering an [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"). Since they return the `nan` value, the warning is redundant and
    has been removed.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '[`numpy.median`](../reference/generated/numpy.median.html#numpy.median "numpy.median")、[`numpy.percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile")和[`numpy.quantile`](../reference/generated/numpy.quantile.html#numpy.quantile
    "numpy.quantile")在遇到[`nan`](../reference/constants.html#numpy.nan "numpy.nan")时曾发出`RuntimeWarning`。由于它们返回`nan`值，警告是多余的，因此已经移除。'
- en: '`timedelta64 % 0` behavior adjusted to return `NaT`'
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整`timedelta64 % 0`的行为以返回`NaT`
- en: The modulus operation with two `np.timedelta64` operands now returns `NaT` in
    the case of division by zero, rather than returning zero
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个`np.timedelta64`操作数之间的模运算在除以零时返回`NaT`，而不是返回零
- en: NumPy functions now always support overrides with `__array_function__`
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy函数现在始终支持使用`__array_function__`进行覆盖
- en: NumPy now always checks the `__array_function__` method to implement overrides
    of NumPy functions on non-NumPy arrays, as described in [NEP 18](http://www.numpy.org/neps/nep-0018-array-function-protocol.html).
    The feature was available for testing with NumPy 1.16 if appropriate environment
    variables are set, but is now always enabled.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy现在始终检查`__array_function__`方法，以实现对非NumPy数组的NumPy函数覆盖，如[NEP 18](http://www.numpy.org/neps/nep-0018-array-function-protocol.html)中所述。如果设置了适当的环境变量，此功能在NumPy
    1.16中可以进行测试，但现在始终启用。
- en: '`lib.recfunctions.structured_to_unstructured` does not squeeze single-field
    views'
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`lib.recfunctions.structured_to_unstructured`不会压缩单字段视图'
- en: Previously `structured_to_unstructured(arr[['a']])` would produce a squeezed
    result inconsistent with `structured_to_unstructured(arr[['a', b']])`. This was
    accidental. The old behavior can be retained with `structured_to_unstructured(arr[['a']]).squeeze(axis=-1)`
    or far more simply, `arr['a']`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`structured_to_unstructured(arr[['a']])`会产生一个与`structured_to_unstructured(arr[['a',
    b']])`不一致的压缩结果。这是偶然发生的。旧行为可以通过`structured_to_unstructured(arr[['a']]).squeeze(axis=-1)`或更简单的`arr['a']`来保留。
- en: '[`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip") now
    uses a ufunc under the hood'
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip")现在在内部使用ufunc'
- en: This means that registering clip functions for custom dtypes in C via `descr->f->fastclip`
    is deprecated - they should use the ufunc registration mechanism instead, attaching
    to the `np.core.umath.clip` ufunc.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: It also means that `clip` accepts `where` and `casting` arguments, and can be
    override with `__array_ufunc__`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'A consequence of this change is that some behaviors of the old `clip` have
    been deprecated:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Passing `nan` to mean “do not clip” as one or both bounds. This didn’t work
    in all cases anyway, and can be better handled by passing infinities of the appropriate
    sign.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using “unsafe” casting by default when an `out` argument is passed. Using `casting="unsafe"`
    explicitly will silence this warning.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are some corner cases with behavior changes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Padding `max < min` has changed to be more consistent across dtypes, but should
    not be relied upon.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar `min` and `max` take part in promotion rules like they do in all other
    ufuncs.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__array_interface__` offset now works as documented'
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interface may use an `offset` value that was mistakenly ignored.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Pickle protocol in [`savez`](../reference/generated/numpy.savez.html#numpy.savez
    "numpy.savez") set to 3 for `force zip64` flag
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`savez`](../reference/generated/numpy.savez.html#numpy.savez "numpy.savez")
    was not using the `force_zip64` flag, which limited the size of the archive to
    2GB. But using the flag requires us to use pickle protocol 3 to write `object`
    arrays. The protocol used was bumped to 3, meaning the archive will be unreadable
    by Python2.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Structured arrays indexed with non-existent fields raise `KeyError` not `ValueError`
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr[''bad_field'']` on a structured type raises `KeyError`, for consistency
    with `dict[''bad_field'']`.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Highlights
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A new extensible [`random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module along with four selectable *random number generators* and
    improved seeding designed for use in parallel processes has been added. The currently
    available bit generators are *MT19937*, *PCG64*, *Philox*, and *SFC64*. See below
    under New Features.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NumPy’s [`FFT`](../reference/routines.fft.html#module-numpy.fft "numpy.fft")
    implementation was changed from fftpack to pocketfft, resulting in faster, more
    accurate transforms and better handling of datasets of prime length. See below
    under Improvements.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New radix sort and timsort sorting methods. It is currently not possible to
    choose which will be used. They are hardwired to the datatype and used when either
    `stable` or `mergesort` is passed as the method. See below under Improvements.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding numpy functions is now possible by default, see `__array_function__`
    below.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New functions
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate") is now also a function decorator'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecations
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") functions warn when passed `float` in place of `int`'
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously functions in this module would accept `float` values provided they
    were integral (`1.0`, `2.0`, etc). For consistency with the rest of numpy, doing
    so is now deprecated, and in future will raise a `TypeError`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 之前该模块中的函数可以接受`float`值，只要它们是整数(`1.0`, `2.0`,等)。为了与 numpy 的其余部分保持一致，现在这样做已经被弃用，并且在将来会引发`TypeError`。
- en: Similarly, passing a float like `0.5` in place of an integer will now raise
    a `TypeError` instead of the previous `ValueError`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，现在在整数位置传递像`0.5`这样的浮点数将引发`TypeError`，而不是之前的`ValueError`。
- en: Deprecate [`numpy.distutils.exec_command`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") and `temp_file_name`
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弃用[`numpy.distutils.exec_command`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") 和 `temp_file_name`
- en: The internal use of these functions has been refactored and there are better
    alternatives. Replace `exec_command` with [`subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen
    "(in Python v3.11)") and [`temp_file_name`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") with [`tempfile.mkstemp`](https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp
    "(in Python v3.11)").
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的内部使用已被重构，有更好的替代方案。用[`subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen
    "(在 Python v3.11)")替换`exec_command`，用[`tempfile.mkstemp`](https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp
    "(在 Python v3.11)")替换`temp_file_name`
- en: Writeable flag of C-API wrapped arrays
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C-API包装数组的可写标志
- en: When an array is created from the C-API to wrap a pointer to data, the only
    indication we have of the read-write nature of the data is the `writeable` flag
    set during creation. It is dangerous to force the flag to writeable. In the future
    it will not be possible to switch the writeable flag to `True` from python. This
    deprecation should not affect many users since arrays created in such a manner
    are very rare in practice and only available through the NumPy C-API.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 C-API 创建数组以包装数据指针时，我们唯一能够知道数据的读写性质的指标是在创建过程中设置的`writeable`标志。强制该标志变为可写是很危险的。将来将不可能从
    python 将标志切换为`True`。这种弃用不应影响很多用户，因为以这种方式创建的数组在实践中非常少见，而且仅通过 NumPy C-API 可用。
- en: '[`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero "numpy.nonzero")
    should no longer be called on 0d arrays'
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不应该在0维数组上再调用[`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero")。
- en: The behavior of [`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero") on 0d arrays was surprising, making uses of it almost always
    incorrect. If the old behavior was intended, it can be preserved without a warning
    by using `nonzero(atleast_1d(arr))` instead of `nonzero(arr)`. In a future release,
    it is most likely this will raise a `ValueError`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero "numpy.nonzero")对于0维数组的行为令人惊讶，几乎总是不正确的。如果打算保留旧的行为，可以通过使用`nonzero(atleast_1d(arr))`代替`nonzero(arr)`来保留它而不会发出警告。在将来的版本中，很可能会引发`ValueError`。'
- en: Writing to the result of [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") will warn
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入[`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays")的结果会发出警告
- en: Commonly [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") returns a writeable array with internal overlap, making
    it unsafe to write to. A future version will set the `writeable` flag to `False`,
    and require users to manually set it to `True` if they are sure that is what they
    want to do. Now writing to it will emit a deprecation warning with instructions
    to set the `writeable` flag `True`. Note that if one were to inspect the flag
    before setting it, one would find it would already be `True`. Explicitly setting
    it, though, as one will need to do in future versions, clears an internal flag
    that is used to produce the deprecation warning. To help alleviate confusion,
    an additional *FutureWarning* will be emitted when accessing the `writeable` flag
    state to clarify the contradiction.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，[`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") 返回一个带有内部重叠的可写数组，对其进行写操作是不安全的。将来的版本将将 `writeable` 标志设置为
    `False`，并要求用户手动将其设置为 `True`，如果他们确定这样做是他们想要的。现在对其进行写操作将发出弃用警告，并提供设置 `writeable`
    标志为 `True` 的说明。请注意，如果在设置它之前检查标志，您会发现它已经是 `True`。然而，在未来版本中，将明确设置它会清除一个用于产生弃用警告的内部标志。为帮助减轻混乱，当访问
    `writeable` 标志状态时将发出额外的 *FutureWarning*，以澄清矛盾。
- en: Note that for the C-side buffer protocol such an array will return a readonly
    buffer immediately unless a writable buffer is requested. If a writeable buffer
    is requested a warning will be given. When using cython, the `const` qualifier
    should be used with such arrays to avoid the warning (e.g. `cdef const double[::1]
    view`).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于C端缓冲区协议，此类数组将立即返回只读缓冲区，除非请求可写缓冲区。如果请求可写缓冲区，将发出警告。在使用Cython时，应该对这种数组使用
    `const` 修饰符以避免警告（例如 `cdef const double[::1] view`）。
- en: '[`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") functions warn when passed `float` in place of `int`'
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") 中的函数在传递 `float` 时会发出警告，期望传递 `int`'
- en: Previously functions in this module would accept `float` values provided they
    were integral (`1.0`, `2.0`, etc). For consistency with the rest of numpy, doing
    so is now deprecated, and in future will raise a `TypeError`.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，此模块中的函数会接受浮点值，只要它们是整数（`1.0`, `2.0` 等）。为了与NumPy的其余部分保持一致，现在已弃用此做法，并且在将来会引发
    `TypeError`。
- en: Similarly, passing a float like `0.5` in place of an integer will now raise
    a `TypeError` instead of the previous `ValueError`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在整数位置传递一个浮点数，现在将引发 `TypeError` 而不是以前的 `ValueError`。
- en: Deprecate [`numpy.distutils.exec_command`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") and `temp_file_name`
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 废弃 [`numpy.distutils.exec_command`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") 和 `temp_file_name`
- en: The internal use of these functions has been refactored and there are better
    alternatives. Replace `exec_command` with [`subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen
    "(in Python v3.11)") and [`temp_file_name`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command") with [`tempfile.mkstemp`](https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp
    "(in Python v3.11)").
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的内部使用已经重构，有更好的替代方案。用 [`subprocess.Popen`](https://docs.python.org/3/library/subprocess.html#subprocess.Popen
    "(in Python v3.11)") 替换 `exec_command`，用 [`tempfile.mkstemp`](https://docs.python.org/3/library/tempfile.html#tempfile.mkstemp
    "(in Python v3.11)") 替换 [`temp_file_name`](../reference/generated/numpy.distutils.exec_command.html#module-numpy.distutils.exec_command
    "numpy.distutils.exec_command")。
- en: Writeable flag of C-API wrapped arrays
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: C-API包装数组的可写标志
- en: When an array is created from the C-API to wrap a pointer to data, the only
    indication we have of the read-write nature of the data is the `writeable` flag
    set during creation. It is dangerous to force the flag to writeable. In the future
    it will not be possible to switch the writeable flag to `True` from python. This
    deprecation should not affect many users since arrays created in such a manner
    are very rare in practice and only available through the NumPy C-API.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当从C-API创建数组以包装数据指针时，我们唯一知道数据可读写性的指示是在创建过程中设置的 `writeable` 标志。强制将标志设置为可写是危险的。将来将不再能够从Python将
    `writeable` 标志切换为 `True`。此弃用不会影响许多用户，因为以这种方式创建的数组在实践中非常罕见，并且仅通过NumPy C-API可用。
- en: '[`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero "numpy.nonzero")
    should no longer be called on 0d arrays'
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不应再在 0d 数组上调用 [`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero")
- en: The behavior of [`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero") on 0d arrays was surprising, making uses of it almost always
    incorrect. If the old behavior was intended, it can be preserved without a warning
    by using `nonzero(atleast_1d(arr))` instead of `nonzero(arr)`. In a future release,
    it is most likely this will raise a `ValueError`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0d 数组上使用 [`numpy.nonzero`](../reference/generated/numpy.nonzero.html#numpy.nonzero
    "numpy.nonzero") 的行为令人意外，使其几乎总是不正确的。 如果旧行为是有意的，则可以通过使用 `nonzero(atleast_1d(arr))`
    而不是 `nonzero(arr)` 来保留它，而不会引发警告。 在将来的版本中，这很可能会引发 `ValueError`。
- en: Writing to the result of [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") will warn
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对[`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") 的结果进行写操作将会有警告
- en: Commonly [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") returns a writeable array with internal overlap, making
    it unsafe to write to. A future version will set the `writeable` flag to `False`,
    and require users to manually set it to `True` if they are sure that is what they
    want to do. Now writing to it will emit a deprecation warning with instructions
    to set the `writeable` flag `True`. Note that if one were to inspect the flag
    before setting it, one would find it would already be `True`. Explicitly setting
    it, though, as one will need to do in future versions, clears an internal flag
    that is used to produce the deprecation warning. To help alleviate confusion,
    an additional *FutureWarning* will be emitted when accessing the `writeable` flag
    state to clarify the contradiction.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，[`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") 返回一个具有内部重叠的可写数组，使得对其进行写操作是不安全的。 未来版本将会将 `writeable`
    标志设置为 `False`，并要求用户手动将其设置为 `True`，如果他们确信这是他们想要做的。现在对其进行写操作将会发出弃用警告，并提供设置` writeable`
    标志 `True` 的说明。 请注意，如果在设置标志之前检查标志，将会发现它已经是 `True`。 显式设置它，如在将来的版本中将需要做的那样，会清除用于生成弃用警告的内部标志。
    为了帮助减轻困惑，当访问 `writeable` 标志状态时将发出另一个 *FutureWarning* 以澄清矛盾。
- en: Note that for the C-side buffer protocol such an array will return a readonly
    buffer immediately unless a writable buffer is requested. If a writeable buffer
    is requested a warning will be given. When using cython, the `const` qualifier
    should be used with such arrays to avoid the warning (e.g. `cdef const double[::1]
    view`).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于 C 侧的缓冲协议，这样的数组将立即返回只读缓冲区，除非请求可写缓冲区。 如果请求可写缓冲区，将发出警告。在使用 Cython 时，应使用
    `const` 修饰符来避免此类数组产生警告（例如 `cdef const double[::1] view`）。
- en: Future Changes
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 未来变更
- en: Shape-1 fields in dtypes won’t be collapsed to scalars in a future version
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将来版本中，dtype 中的形状为1的字段不会被合并为标量
- en: Currently, a field specified as `[(name, dtype, 1)]` or `"1type"` is interpreted
    as a scalar field (i.e., the same as `[(name, dtype)]` or `[(name, dtype, ()]`).
    This now raises a FutureWarning; in a future version, it will be interpreted as
    a shape-(1,) field, i.e. the same as `[(name, dtype, (1,))]` or `"(1,)type"` (consistently
    with `[(name, dtype, n)]` / `"ntype"` with `n>1`, which is already equivalent
    to `[(name, dtype, (n,)]` / `"(n,)type"`).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，将字段指定为 `[(name, dtype, 1)]` 或 `"1type"` 将被解释为标量字段（即与 `[(name, dtype)]` 或
    `[(name, dtype, ()]` 相同）。 现在会引发警告。 在将来的版本中，它将被解释为形状为（1，）的字段，即与 `[(name, dtype,
    (1,))]` 或 `"(1,)type"` 相同（与 `[(name, dtype, n)]` / `"ntype"`，其中 `n>1` 已经等同于 `[(name,
    dtype, (n,)]` / `"(n,)type"`））。
- en: Shape-1 fields in dtypes won’t be collapsed to scalars in a future version
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将来版本中，dtype 中的形状为1的字段��会被合并为标量
- en: Currently, a field specified as `[(name, dtype, 1)]` or `"1type"` is interpreted
    as a scalar field (i.e., the same as `[(name, dtype)]` or `[(name, dtype, ()]`).
    This now raises a FutureWarning; in a future version, it will be interpreted as
    a shape-(1,) field, i.e. the same as `[(name, dtype, (1,))]` or `"(1,)type"` (consistently
    with `[(name, dtype, n)]` / `"ntype"` with `n>1`, which is already equivalent
    to `[(name, dtype, (n,)]` / `"(n,)type"`).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，将字段指定为 `[(name, dtype, 1)]` 或 `"1type"` 将被解释为标量字段（即与 `[(name, dtype)]` 或
    `[(name, dtype, ()]` 相同）。 现在将发出 FutureWarning；在将来版本中，它将被解释为形状为（1，）的字段，即与 `[(name,
    dtype, (1,))]` 或 `"(1,)type"` 相同（与 `[(name, dtype, n)]` / `"ntype"`，其中 `n>1` 已经等同于
    `[(name, dtype, (n,)]` / `"(n,)type"`））。
- en: Compatibility notes
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 兼容性注意事项
- en: '`float16` subnormal rounding'
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`float16` 浮点数舍入'
- en: Casting from a different floating point precision to `float16` used incorrect
    rounding in some edge cases. This means in rare cases, subnormal results will
    now be rounded up instead of down, changing the last bit (ULP) of the result.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同的浮点精度转换为`float16`在一些极端情况下使用不正确的舍入。这意味着在罕见情况下，次正规结果现在会向上舍入而不是向下舍入，改变了结果的最后一位（ULP）。
- en: Signed zero when using divmod
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用divmod时返回带符号的零
- en: 'Starting in version *1.12.0*, numpy incorrectly returned a negatively signed
    zero when using the `divmod` and `floor_divide` functions when the result was
    zero. For example:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从*1.12.0*版本开始，当使用`divmod`和`floor_divide`函数得到结果为零时，numpy在返回负号零时会出现错误。例如：
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With this release, the result is correctly returned as a positively signed
    zero:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此版本发布，结果现在正确地返回为正号的零：
- en: '[PRE10]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`MaskedArray.mask` now returns a view of the mask, not the mask itself'
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`MaskedArray.mask`现在返回掩码的视图，而不是掩码本身'
- en: Returning the mask itself was unsafe, as it could be reshaped in place which
    would violate expectations of the masked array code. The behavior of [`mask`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") is now consistent with [`data`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data"), which also returns a view.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 返回掩码本身是不安全的，因为它可能会被就地重塑，这会违反掩码数组代码的期望。[`mask`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask")的行为现在与[`data`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data")一致，也会返回一个视图。
- en: The underlying mask can still be accessed with `._mask` if it is needed. Tests
    that contain `assert x.mask is not y.mask` or similar will need to be updated.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要访问底层掩码，可以用`._mask`来获取。包含`assert x.mask is not y.mask`或类似语句的测试将需要更新。
- en: Do not lookup `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer")
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在[`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer")中查找`__buffer__`属性
- en: Looking up `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer") was undocumented and non-functional. This code was removed.
    If needed, use `frombuffer(memoryview(obj), ...)` instead.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer")中查找`__buffer__`属性是未记录和无效的。已删除此代码。如果需要，可以使用`frombuffer(memoryview(obj),
    ...)`代替。
- en: '`out` is buffered for memory overlaps in [`take`](../reference/generated/numpy.take.html#numpy.take
    "numpy.take"), [`choose`](../reference/generated/numpy.choose.html#numpy.choose
    "numpy.choose"), [`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put")'
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`out`在内存重叠中被缓冲，适用于[`take`](../reference/generated/numpy.take.html#numpy.take
    "numpy.take")、[`choose`](../reference/generated/numpy.choose.html#numpy.choose
    "numpy.choose")、[`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put")'
- en: If the out argument to these functions is provided and has memory overlap with
    the other arguments, it is now buffered to avoid order-dependent behavior.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些函数的`out`参数被提供并且与其他参数存在内存重叠，现在它将被缓冲以避免依赖于顺序的行为。
- en: Unpickling while loading requires explicit opt-in
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在加载时进行反序列化需要显式的选择
- en: The functions [`load`](../reference/generated/numpy.load.html#numpy.load "numpy.load"),
    and `lib.format.read_array` take an `allow_pickle` keyword which now defaults
    to `False` in response to [CVE-2019-6446](https://nvd.nist.gov/vuln/detail/CVE-2019-6446).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 函数[`load`](../reference/generated/numpy.load.html#numpy.load "numpy.load")和`lib.format.read_array`现在默认采用`False`作为`allow_pickle`关键字的响应，以应对[CVE-2019-6446](https://nvd.nist.gov/vuln/detail/CVE-2019-6446)。
- en: Potential changes to the random stream in old random module
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在旧的随机模块中随机流的潜在改变
- en: Due to bugs in the application of `log` to random floating point numbers, the
    stream may change when sampling from [`beta`](../reference/random/generated/numpy.random.RandomState.beta.html#numpy.random.RandomState.beta
    "numpy.random.RandomState.beta"), [`binomial`](../reference/random/generated/numpy.random.RandomState.binomial.html#numpy.random.RandomState.binomial
    "numpy.random.RandomState.binomial"), [`laplace`](../reference/random/generated/numpy.random.RandomState.laplace.html#numpy.random.RandomState.laplace
    "numpy.random.RandomState.laplace"), [`logistic`](../reference/random/generated/numpy.random.RandomState.logistic.html#numpy.random.RandomState.logistic
    "numpy.random.RandomState.logistic"), [`logseries`](../reference/random/generated/numpy.random.RandomState.logseries.html#numpy.random.RandomState.logseries
    "numpy.random.RandomState.logseries") or [`multinomial`](../reference/random/generated/numpy.random.RandomState.multinomial.html#numpy.random.RandomState.multinomial
    "numpy.random.RandomState.multinomial") if a `0` is generated in the underlying
    [`MT19937`](../reference/random/bit_generators/mt19937.html#numpy.random.MT19937
    "numpy.random.MT19937") random stream. There is a `1` in \(10^{53}\) chance of
    this occurring, so the probability that the stream changes for any given seed
    is extremely small. If a `0` is encountered in the underlying generator, then
    the incorrect value produced (either [`numpy.inf`](../reference/constants.html#numpy.inf
    "numpy.inf") or [`numpy.nan`](../reference/constants.html#numpy.nan "numpy.nan"))
    is now dropped.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[`i0`](../reference/generated/numpy.i0.html#numpy.i0 "numpy.i0") now always
    returns a result with the same shape as the input'
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, the output was squeezed, such that, e.g., input with just a single
    element would lead to an array scalar being returned, and inputs with shapes such
    as `(10, 1)` would yield results that would not broadcast against the input.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we generally recommend the SciPy implementation over the numpy one:
    it is a proper ufunc written in C, and more than an order of magnitude faster.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast "numpy.can_cast")
    no longer assumes all unsafe casting is allowed'
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, [`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast
    "numpy.can_cast") returned *True* for almost all inputs for `casting='unsafe'`,
    even for cases where casting was not possible, such as from a structured dtype
    to a regular one. This has been fixed, making it more consistent with actual casting
    using, e.g., the [`.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype") method.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '`ndarray.flags.writeable` can be switched to true slightly more often'
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In rare cases, it was not possible to switch an array from not writeable to
    writeable, although a base array is writeable. This can happen if an intermediate
    [`ndarray.base`](../reference/generated/numpy.ndarray.base.html#numpy.ndarray.base
    "numpy.ndarray.base") object is writeable. Previously, only the deepest base object
    was considered for this decision. However, in rare cases this object does not
    have the necessary information. In that case switching to writeable was never
    allowed. This has now been fixed.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，将数组从不可写入切换为可写入可能是不可能的，尽管基本数组是可写入的。如果一个中间[`ndarray.base`](../reference/generated/numpy.ndarray.base.html#numpy.ndarray.base
    "numpy.ndarray.base") 对象是可写入的，这种情况就会发生。以前，只有最深的基对象被考虑用于这个决定。然而，在罕见的情况下，这个对象没有必要的信息。在这种情况下，从不允许切换到可写入。这个问题现在已经修复。
- en: '`float16` subnormal rounding'
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`float16`次正规舍入'
- en: Casting from a different floating point precision to `float16` used incorrect
    rounding in some edge cases. This means in rare cases, subnormal results will
    now be rounded up instead of down, changing the last bit (ULP) of the result.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同的浮点精度转换为`float16`在某些边缘情况下使用了不正确的舍入。这意味着在罕见的情况下，次正规结果现在将向上舍入，而不是向下舍入，改变了结果的最后一位（ULP）。
- en: Signed zero when using divmod
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用divmod时的有符号零
- en: 'Starting in version *1.12.0*, numpy incorrectly returned a negatively signed
    zero when using the `divmod` and `floor_divide` functions when the result was
    zero. For example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从`1.12.0`版本开始，当使用`divmod`和`floor_divide`函数时，numpy在结果为零时错误地返回了一个带负号的零。例如：
- en: '[PRE11]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'With this release, the result is correctly returned as a positively signed
    zero:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个版本，结果现在正确地被返回为一个明显的有符号零：
- en: '[PRE12]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`MaskedArray.mask` now returns a view of the mask, not the mask itself'
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`MaskedArray.mask`现在返回掩码的视图，而不是掩码本身'
- en: Returning the mask itself was unsafe, as it could be reshaped in place which
    would violate expectations of the masked array code. The behavior of [`mask`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask") is now consistent with [`data`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data"), which also returns a view.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 返回掩码本身是不安全的，因为它可能被就地重塑，这将违反掩码数组代码的预期。[`mask`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.mask
    "numpy.ma.MaskedArray.mask")的行为现在与[`data`](../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray.data
    "numpy.ma.MaskedArray.data")一致，后者也返回一个视图。
- en: The underlying mask can still be accessed with `._mask` if it is needed. Tests
    that contain `assert x.mask is not y.mask` or similar will need to be updated.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，仍然可以通过`._mask`访问底层掩码。包含`assert x.mask is not y.mask`或类似语句的测试将需要更新。
- en: Do not lookup `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer")
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要在[`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer")中查找`__buffer__`属性
- en: Looking up `__buffer__` attribute in [`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer") was undocumented and non-functional. This code was removed.
    If needed, use `frombuffer(memoryview(obj), ...)` instead.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`numpy.frombuffer`](../reference/generated/numpy.frombuffer.html#numpy.frombuffer
    "numpy.frombuffer")中查找`__buffer__`属性是未记录且无效的。这段代码已被删除。如果需要，可以使用`frombuffer(memoryview(obj),
    ...)`代替。
- en: '`out` is buffered for memory overlaps in [`take`](../reference/generated/numpy.take.html#numpy.take
    "numpy.take"), [`choose`](../reference/generated/numpy.choose.html#numpy.choose
    "numpy.choose"), [`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put")'
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在[`take`](../reference/generated/numpy.take.html#numpy.take "numpy.take")、[`choose`](../reference/generated/numpy.choose.html#numpy.choose
    "numpy.choose")和[`put`](../reference/generated/numpy.put.html#numpy.put "numpy.put")中，用于处理内存重叠的`out`现在是缓冲的
- en: If the out argument to these functions is provided and has memory overlap with
    the other arguments, it is now buffered to avoid order-dependent behavior.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些函数的`out`参数已经提供并且与其他参数有内存重叠，现在将对其进行缓冲以避免依赖于顺序的行为。
- en: Unpickling while loading requires explicit opt-in
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在加载时解封装需要明确选择
- en: The functions [`load`](../reference/generated/numpy.load.html#numpy.load "numpy.load"),
    and `lib.format.read_array` take an `allow_pickle` keyword which now defaults
    to `False` in response to [CVE-2019-6446](https://nvd.nist.gov/vuln/detail/CVE-2019-6446).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 函数[`load`](../reference/generated/numpy.load.html#numpy.load "numpy.load")和`lib.format.read_array`现在默认带有一个`allow_pickle`关键字，以响应[CVE-2019-6446](https://nvd.nist.gov/vuln/detail/CVE-2019-6446)。
- en: Potential changes to the random stream in old random module
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 旧随机模块中对随机流的潜在变更
- en: Due to bugs in the application of `log` to random floating point numbers, the
    stream may change when sampling from [`beta`](../reference/random/generated/numpy.random.RandomState.beta.html#numpy.random.RandomState.beta
    "numpy.random.RandomState.beta"), [`binomial`](../reference/random/generated/numpy.random.RandomState.binomial.html#numpy.random.RandomState.binomial
    "numpy.random.RandomState.binomial"), [`laplace`](../reference/random/generated/numpy.random.RandomState.laplace.html#numpy.random.RandomState.laplace
    "numpy.random.RandomState.laplace"), [`logistic`](../reference/random/generated/numpy.random.RandomState.logistic.html#numpy.random.RandomState.logistic
    "numpy.random.RandomState.logistic"), [`logseries`](../reference/random/generated/numpy.random.RandomState.logseries.html#numpy.random.RandomState.logseries
    "numpy.random.RandomState.logseries") or [`multinomial`](../reference/random/generated/numpy.random.RandomState.multinomial.html#numpy.random.RandomState.multinomial
    "numpy.random.RandomState.multinomial") if a `0` is generated in the underlying
    [`MT19937`](../reference/random/bit_generators/mt19937.html#numpy.random.MT19937
    "numpy.random.MT19937") random stream. There is a `1` in \(10^{53}\) chance of
    this occurring, so the probability that the stream changes for any given seed
    is extremely small. If a `0` is encountered in the underlying generator, then
    the incorrect value produced (either [`numpy.inf`](../reference/constants.html#numpy.inf
    "numpy.inf") or [`numpy.nan`](../reference/constants.html#numpy.nan "numpy.nan"))
    is now dropped.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将`log`应用于随机浮点数的错误，当从 [`beta`](../reference/random/generated/numpy.random.RandomState.beta.html#numpy.random.RandomState.beta
    "numpy.random.RandomState.beta")、[`binomial`](../reference/random/generated/numpy.random.RandomState.binomial.html#numpy.random.RandomState.binomial
    "numpy.random.RandomState.binomial")、[`laplace`](../reference/random/generated/numpy.random.RandomState.laplace.html#numpy.random.RandomState.laplace
    "numpy.random.RandomState.laplace")、[`logistic`](../reference/random/generated/numpy.random.RandomState.logistic.html#numpy.random.RandomState.logistic
    "numpy.random.RandomState.logistic")、[`logseries`](../reference/random/generated/numpy.random.RandomState.logseries.html#numpy.random.RandomState.logseries
    "numpy.random.RandomState.logseries") 或 [`multinomial`](../reference/random/generated/numpy.random.RandomState.multinomial.html#numpy.random.RandomState.multinomial
    "numpy.random.RandomState.multinomial") 中的任一生成随机数流时生成了`0`时，流可能会发生变化。发生这种情况的概率是
    \(10^{53}\) 中的 `1`，因此对于任何给定的种子，流变化的概率都极小。如果在底层生成器中遇到`0`，那么现在将删除生成的错误值（[`numpy.inf`](../reference/constants.html#numpy.inf
    "numpy.inf") 或 [`numpy.nan`](../reference/constants.html#numpy.nan "numpy.nan")）。
- en: '[`i0`](../reference/generated/numpy.i0.html#numpy.i0 "numpy.i0") now always
    returns a result with the same shape as the input'
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`i0`](../reference/generated/numpy.i0.html#numpy.i0 "numpy.i0") 现在总是返回与输入相同形状的结果。'
- en: Previously, the output was squeezed, such that, e.g., input with just a single
    element would lead to an array scalar being returned, and inputs with shapes such
    as `(10, 1)` would yield results that would not broadcast against the input.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，输出会被挤压，例如，只有一个元素的输入会导致返回一个数组标量，并且形状为 `(10, 1)` 的输入将产生不能对输入进行广播的结果。
- en: 'Note that we generally recommend the SciPy implementation over the numpy one:
    it is a proper ufunc written in C, and more than an order of magnitude faster.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们通常建议使用 SciPy 的实现而不是 numpy 的实现：它是用 C 编写的合适的 ufunc，速度比 numpy 快一个数量级以上。
- en: '[`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast "numpy.can_cast")
    no longer assumes all unsafe casting is allowed'
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast "numpy.can_cast")
    不再假设所有不安全的转换都是允许的。'
- en: Previously, [`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast
    "numpy.can_cast") returned *True* for almost all inputs for `casting='unsafe'`,
    even for cases where casting was not possible, such as from a structured dtype
    to a regular one. This has been fixed, making it more consistent with actual casting
    using, e.g., the [`.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype") method.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，[`can_cast`](../reference/generated/numpy.can_cast.html#numpy.can_cast "numpy.can_cast")
    对于`casting='unsafe'`几乎对所有输入都返回*True*，即使对于不能进行转换的情况（例如，从结构化的 dtype 到常规的 dtype）。已经修复了这个问题，使其更符合实际的转换，例如使用
    [`.astype`](../reference/generated/numpy.ndarray.astype.html#numpy.ndarray.astype
    "numpy.ndarray.astype") 方法。
- en: '`ndarray.flags.writeable` can be switched to true slightly more often'
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ndarray.flags.writeable` 稍微更频繁地可以切换为 true。'
- en: In rare cases, it was not possible to switch an array from not writeable to
    writeable, although a base array is writeable. This can happen if an intermediate
    [`ndarray.base`](../reference/generated/numpy.ndarray.base.html#numpy.ndarray.base
    "numpy.ndarray.base") object is writeable. Previously, only the deepest base object
    was considered for this decision. However, in rare cases this object does not
    have the necessary information. In that case switching to writeable was never
    allowed. This has now been fixed.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在罕见的情况下，可能无法将数组从不可写切换为可写，尽管基础数组是可写的。如果中间的 [`ndarray.base`](../reference/generated/numpy.ndarray.base.html#numpy.ndarray.base
    "numpy.ndarray.base") 对象是可写的，就会发生这种情况。以前，只有最深的基本对象被考虑在内做出这个决定。但是，在罕见的情况下，这个对象没有必要的信息。在这种情况下，切换为可写是永远不被允许的。现在这个问题已经解决了。
- en: C API changes
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C API 变更
- en: dimension or stride input arguments are now passed by `npy_intp const*`
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维度或步幅输入参数现在由 `npy_intp const*` 传递
- en: 'Previously these function arguments were declared as the more strict `npy_intp*`,
    which prevented the caller passing constant data. This change is backwards compatible,
    but now allows code like:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以前这些函数参数被声明为更严格的 `npy_intp*`，这阻止了调用者传递常量数据。这个更改向后兼容，但现在允许如下代码：
- en: '[PRE13]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: dimension or stride input arguments are now passed by `npy_intp const*`
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维度或步幅输入参数现在由 `npy_intp const*` 传递
- en: 'Previously these function arguments were declared as the more strict `npy_intp*`,
    which prevented the caller passing constant data. This change is backwards compatible,
    but now allows code like:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 以前这些函数参数被声明为更严格的 `npy_intp*`，这阻止了调用者传递常量数据。这个更改向后兼容，但现在允许如下代码：
- en: '[PRE14]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: New Features
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新特性
- en: New extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module with selectable random number generators
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 具有可选随机数生成器的新的可扩展的 [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") 模块
- en: A new extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module along with four selectable random number generators and
    improved seeding designed for use in parallel processes has been added. The currently
    available *Bit Generators* are *MT19937*, *PCG64*, *Philox*, and *SFC64*. `PCG64`
    is the new default while `MT19937` is retained for backwards compatibility. Note
    that the legacy random module is unchanged and is now frozen, your current results
    will not change. More information is available in the [API change description](../reference/random/new-or-different.html#new-or-different)
    and in the [`top-level view`](../reference/random/index.html#module-numpy.random
    "numpy.random") documentation.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 新的可扩展的 [`numpy.random`](../reference/random/index.html#module-numpy.random "numpy.random")
    模块与四种可选的随机数生成器和改进的种子设计用于并行进程中的使用已经添加。当前可用的 *Bit Generators* 有 *MT19937*, *PCG64*,
    *Philox*, 和 *SFC64*。`PCG64` 是新的默认值，而 `MT19937` 被保留以保持向后兼容性。请注意，旧版随机模块保持不变，并且现在被冻结，您当前的结果不会改变。更多信息请参见[API变更说明](../reference/random/new-or-different.html#new-or-different)和[`顶层视图`](../reference/random/index.html#module-numpy.random
    "numpy.random")文档。
- en: libFLAME
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: libFLAME
- en: Support for building NumPy with the libFLAME linear algebra package as the LAPACK,
    implementation, see [libFLAME](https://www.cs.utexas.edu/~flame/web/libFLAME.html)
    for details.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 支持使用 libFLAME 线性代数包作为 LAPACK 实现来构建 NumPy，详情请参见 [libFLAME](https://www.cs.utexas.edu/~flame/web/libFLAME.html)。
- en: User-defined BLAS detection order
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的 BLAS 检测顺序
- en: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    now uses an environment variable, comma-separated and case insensitive, to determine
    the detection order for BLAS libraries. By default `NPY_BLAS_ORDER=mkl,blis,openblas,atlas,accelerate,blas`.
    However, to force the use of OpenBLAS simply do:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")现在使用环境变量来确定
    BLAS 库的检测顺序，环境变量是大小写不敏感的，采用逗号分隔。默认情况下 `NPY_BLAS_ORDER=mkl,blis,openblas,atlas,accelerate,blas`。然而，要强制使用
    OpenBLAS 只需执行:'
- en: '[PRE15]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 强制使用 OpenBLAS。这对于那些已经安装了 MKL 但希望尝试不同实现的用户可能有帮助。
- en: User-defined LAPACK detection order
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的 LAPACK 检测顺序
- en: '`numpy.distutils` now uses an environment variable, comma-separated and case
    insensitive, to determine the detection order for LAPACK libraries. By default
    `NPY_LAPACK_ORDER=mkl,openblas,flame,atlas,accelerate,lapack`. However, to force
    the use of OpenBLAS simply do:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.distutils`现在使用环境变量来确定 LAPACK 库检测顺序，环境变量是大小写不敏感的，采用逗号分隔。默认情况下 `NPY_LAPACK_ORDER=mkl,openblas,flame,atlas,accelerate,lapack`。然而，要强制使用
    OpenBLAS 只需执行:'
- en: '[PRE16]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce") and related functions now accept a `where` mask'
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce"), [`sum`](../reference/generated/numpy.sum.html#numpy.sum
    "numpy.sum"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min"), [`max`](../reference/generated/numpy.max.html#numpy.max
    "numpy.max") all now accept a `where` keyword argument, which can be used to tell
    which elements to include in the reduction. For reductions that do not have an
    identity, it is necessary to also pass in an initial value (e.g., `initial=np.inf`
    for [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min")). For
    instance, the equivalent of [`nansum`](../reference/generated/numpy.nansum.html#numpy.nansum
    "numpy.nansum") would be `np.sum(a, where=~np.isnan(a))`.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Timsort and radix sort have replaced mergesort for stable sorting
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both radix sort and timsort have been implemented and are now used in place
    of mergesort. Due to the need to maintain backward compatibility, the sorting
    `kind` options `"stable"` and `"mergesort"` have been made aliases of each other
    with the actual sort implementation depending on the array type. Radix sort is
    used for small integer types of 16 bits or less and timsort for the remaining
    types. Timsort features improved performance on data containing already or nearly
    sorted data and performs like mergesort on random data and requires \(O(n/2)\)
    working space. Details of the timsort algorithm can be found at [CPython listsort.txt](https://github.com/python/cpython/blob/3.7/Objects/listsort.txt).
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits "numpy.packbits")
    and [`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") accept an `order` keyword'
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `order` keyword defaults to `big`, and will order the **bits** accordingly.
    For `'order=big'` 3 will become `[0, 0, 0, 0, 0, 0, 1, 1]`, and `[1, 1, 0, 0,
    0, 0, 0, 0]` for `order=little`
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '[`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") now accepts a `count` parameter'
  id: totrans-272
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`count` allows subsetting the number of bits that will be unpacked up-front,
    rather than reshaping and subsetting later, making the [`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits
    "numpy.packbits") operation invertible, and the unpacking less wasteful. Counts
    larger than the number of available bits add zero padding. Negative counts trim
    bits off the end instead of counting from the beginning. None counts implement
    the existing behavior of unpacking everything.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd") and [`linalg.pinv`](../reference/generated/numpy.linalg.pinv.html#numpy.linalg.pinv
    "numpy.linalg.pinv") can be faster on hermitian inputs'
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These functions now accept a `hermitian` argument, matching the one added to
    [`linalg.matrix_rank`](../reference/generated/numpy.linalg.matrix_rank.html#numpy.linalg.matrix_rank
    "numpy.linalg.matrix_rank") in 1.14.0.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: divmod operation is now supported for two `timedelta64` operands
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The divmod operator now handles two `timedelta64` operands, with type signature
    `mm->qm`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile")
    now takes an `offset` argument'
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function now takes an `offset` keyword argument for binary files, which
    specifics the offset (in bytes) from the file’s current position. Defaults to
    `0`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: New mode “empty” for [`pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This mode pads an array to a desired shape without initializing the new entries.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like") and related functions now accept a `shape` argument'
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`full_like`](../reference/generated/numpy.full_like.html#numpy.full_like
    "numpy.full_like"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like") and [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like") now accept a `shape` keyword argument, which can be used to
    create a new array as the prototype, overriding its shape as well. This is particularly
    useful when combined with the `__array_function__` protocol, allowing the creation
    of new arbitrary-shape arrays from NumPy-like libraries when such an array is
    used as the prototype.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Floating point scalars implement `as_integer_ratio` to match the builtin float
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This returns a (numerator, denominator) pair, which can be used to construct
    a [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)").
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Structured `dtype` objects can be indexed with multiple fields names
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr.dtype[[''a'', ''b'']]` now returns a dtype that is equivalent to `arr[[''a'',
    ''b'']].dtype`, for consistency with `arr.dtype[''a''] == arr[''a''].dtype`.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Like the dtype of structured arrays indexed with a list of fields, this dtype
    has the same `itemsize` as the original, but only keeps a subset of the fields.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: This means that `arr[['a', 'b']]` and `arr.view(arr.dtype[['a', 'b']])` are
    equivalent.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '`.npy` files support unicode field names'
  id: totrans-290
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new format version of 3.0 has been introduced, which enables structured types
    with non-latin1 field names. This is used automatically when needed.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: New extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module with selectable random number generators
  id: totrans-292
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new extensible [`numpy.random`](../reference/random/index.html#module-numpy.random
    "numpy.random") module along with four selectable random number generators and
    improved seeding designed for use in parallel processes has been added. The currently
    available *Bit Generators* are *MT19937*, *PCG64*, *Philox*, and *SFC64*. `PCG64`
    is the new default while `MT19937` is retained for backwards compatibility. Note
    that the legacy random module is unchanged and is now frozen, your current results
    will not change. More information is available in the [API change description](../reference/random/new-or-different.html#new-or-different)
    and in the [`top-level view`](../reference/random/index.html#module-numpy.random
    "numpy.random") documentation.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 新的可扩展 [`numpy.random`](../reference/random/index.html#module-numpy.random "numpy.random")
    模块和四个可选的随机数生成器以及为并行进程设计的改进种子设置已添加。目前可用的 *Bit Generators* 包括 *MT19937*、*PCG64*、*Philox*
    和 *SFC64*。`PCG64` 是新的默认值，而 `MT19937` 保留作为向后兼容。请注意，传统的 random 模块保持不变且已冻结，所以您的当前结果不会改变。更多信息请参阅
    [API 更改描述](../reference/random/new-or-different.html#new-or-different) 和 [`顶层视图`](../reference/random/index.html#module-numpy.random
    "numpy.random") 文档。
- en: libFLAME
  id: totrans-294
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: libFLAME
- en: Support for building NumPy with the libFLAME linear algebra package as the LAPACK,
    implementation, see [libFLAME](https://www.cs.utexas.edu/~flame/web/libFLAME.html)
    for details.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 libFLAME 线性代数包作为 LAPACK 实现构建 NumPy 的支持，请参阅 [libFLAME](https://www.cs.utexas.edu/~flame/web/libFLAME.html)
    了解详情。
- en: User-defined BLAS detection order
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的 BLAS 检测顺序
- en: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    now uses an environment variable, comma-separated and case insensitive, to determine
    the detection order for BLAS libraries. By default `NPY_BLAS_ORDER=mkl,blis,openblas,atlas,accelerate,blas`.
    However, to force the use of OpenBLAS simply do:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    现在使用一个环境变量，大小写不敏感，逗号分隔，来确定 BLAS 库的检测顺序。默认情况下为 `NPY_BLAS_ORDER=mkl,blis,openblas,atlas,accelerate,blas`。如果要强制使用
    OpenBLAS，只需执行：'
- en: '[PRE17]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这会强制使用 OpenBLAS。对于已安装 MKL 但希望尝试不同实现的用户，这可能会有所帮助。
- en: User-defined LAPACK detection order
  id: totrans-300
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户定义的 LAPACK 检测顺序
- en: '`numpy.distutils` now uses an environment variable, comma-separated and case
    insensitive, to determine the detection order for LAPACK libraries. By default
    `NPY_LAPACK_ORDER=mkl,openblas,flame,atlas,accelerate,lapack`. However, to force
    the use of OpenBLAS simply do:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`numpy.distutils` 现在使用一个环境变量，大小写不敏感，逗号分隔，来确定 LAPACK 库的检测顺序。默认情况下为 `NPY_LAPACK_ORDER=mkl,openblas,flame,atlas,accelerate,lapack`。如果要强制使用
    OpenBLAS，只需执行：'
- en: '[PRE18]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: which forces the use of OpenBLAS. This may be helpful for users which have a
    MKL installation but wishes to try out different implementations.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 这会强制使用 OpenBLAS。对于已安装 MKL 但希望尝试不同实现的用户，这可能会有所帮助。
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce") and related functions now accept a `where` mask'
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce") 和相关函数现在接受一个 `where` 掩码'
- en: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce"), [`sum`](../reference/generated/numpy.sum.html#numpy.sum
    "numpy.sum"), [`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod"),
    [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min"), [`max`](../reference/generated/numpy.max.html#numpy.max
    "numpy.max") all now accept a `where` keyword argument, which can be used to tell
    which elements to include in the reduction. For reductions that do not have an
    identity, it is necessary to also pass in an initial value (e.g., `initial=np.inf`
    for [`min`](../reference/generated/numpy.min.html#numpy.min "numpy.min")). For
    instance, the equivalent of [`nansum`](../reference/generated/numpy.nansum.html#numpy.nansum
    "numpy.nansum") would be `np.sum(a, where=~np.isnan(a))`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ufunc.reduce`](../reference/generated/numpy.ufunc.reduce.html#numpy.ufunc.reduce
    "numpy.ufunc.reduce")、[`sum`](../reference/generated/numpy.sum.html#numpy.sum
    "numpy.sum")、[`prod`](../reference/generated/numpy.prod.html#numpy.prod "numpy.prod")、[`min`](../reference/generated/numpy.min.html#numpy.min
    "numpy.min")、[`max`](../reference/generated/numpy.max.html#numpy.max "numpy.max")
    现在都接受一个 `where` 关键字参数，该参数可用于指定在规约中包含哪些元素。对于没有标识的规约，还需要传递一个初始值（例如对于 [`min`](../reference/generated/numpy.min.html#numpy.min
    "numpy.min")，使用 `initial=np.inf`）。例如，[`nansum`](../reference/generated/numpy.nansum.html#numpy.nansum
    "numpy.nansum") 的等效形式是 `np.sum(a, where=~np.isnan(a))`。'
- en: Timsort and radix sort have replaced mergesort for stable sorting
  id: totrans-306
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Timsort 和基数排序已替代归并排序用于稳定排序。
- en: Both radix sort and timsort have been implemented and are now used in place
    of mergesort. Due to the need to maintain backward compatibility, the sorting
    `kind` options `"stable"` and `"mergesort"` have been made aliases of each other
    with the actual sort implementation depending on the array type. Radix sort is
    used for small integer types of 16 bits or less and timsort for the remaining
    types. Timsort features improved performance on data containing already or nearly
    sorted data and performs like mergesort on random data and requires \(O(n/2)\)
    working space. Details of the timsort algorithm can be found at [CPython listsort.txt](https://github.com/python/cpython/blob/3.7/Objects/listsort.txt).
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits "numpy.packbits")
    and [`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") accept an `order` keyword'
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `order` keyword defaults to `big`, and will order the **bits** accordingly.
    For `'order=big'` 3 will become `[0, 0, 0, 0, 0, 0, 1, 1]`, and `[1, 1, 0, 0,
    0, 0, 0, 0]` for `order=little`
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[`unpackbits`](../reference/generated/numpy.unpackbits.html#numpy.unpackbits
    "numpy.unpackbits") now accepts a `count` parameter'
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`count` allows subsetting the number of bits that will be unpacked up-front,
    rather than reshaping and subsetting later, making the [`packbits`](../reference/generated/numpy.packbits.html#numpy.packbits
    "numpy.packbits") operation invertible, and the unpacking less wasteful. Counts
    larger than the number of available bits add zero padding. Negative counts trim
    bits off the end instead of counting from the beginning. None counts implement
    the existing behavior of unpacking everything.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[`linalg.svd`](../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd
    "numpy.linalg.svd") and [`linalg.pinv`](../reference/generated/numpy.linalg.pinv.html#numpy.linalg.pinv
    "numpy.linalg.pinv") can be faster on hermitian inputs'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These functions now accept a `hermitian` argument, matching the one added to
    [`linalg.matrix_rank`](../reference/generated/numpy.linalg.matrix_rank.html#numpy.linalg.matrix_rank
    "numpy.linalg.matrix_rank") in 1.14.0.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: divmod operation is now supported for two `timedelta64` operands
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The divmod operator now handles two `timedelta64` operands, with type signature
    `mm->qm`.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile")
    now takes an `offset` argument'
  id: totrans-316
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This function now takes an `offset` keyword argument for binary files, which
    specifics the offset (in bytes) from the file’s current position. Defaults to
    `0`.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: New mode “empty” for [`pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This mode pads an array to a desired shape without initializing the new entries.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like") and related functions now accept a `shape` argument'
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`empty_like`](../reference/generated/numpy.empty_like.html#numpy.empty_like
    "numpy.empty_like"), [`full_like`](../reference/generated/numpy.full_like.html#numpy.full_like
    "numpy.full_like"), [`ones_like`](../reference/generated/numpy.ones_like.html#numpy.ones_like
    "numpy.ones_like") and [`zeros_like`](../reference/generated/numpy.zeros_like.html#numpy.zeros_like
    "numpy.zeros_like") now accept a `shape` keyword argument, which can be used to
    create a new array as the prototype, overriding its shape as well. This is particularly
    useful when combined with the `__array_function__` protocol, allowing the creation
    of new arbitrary-shape arrays from NumPy-like libraries when such an array is
    used as the prototype.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Floating point scalars implement `as_integer_ratio` to match the builtin float
  id: totrans-322
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This returns a (numerator, denominator) pair, which can be used to construct
    a [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)").
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Structured `dtype` objects can be indexed with multiple fields names
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr.dtype[[''a'', ''b'']]` now returns a dtype that is equivalent to `arr[[''a'',
    ''b'']].dtype`, for consistency with `arr.dtype[''a''] == arr[''a''].dtype`.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Like the dtype of structured arrays indexed with a list of fields, this dtype
    has the same `itemsize` as the original, but only keeps a subset of the fields.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: This means that `arr[['a', 'b']]` and `arr.view(arr.dtype[['a', 'b']])` are
    equivalent.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '`.npy` files support unicode field names'
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new format version of 3.0 has been introduced, which enables structured types
    with non-latin1 field names. This is used automatically when needed.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Array comparison assertions include maximum differences
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Error messages from array comparison tests such as [`testing.assert_allclose`](../reference/generated/numpy.testing.assert_allclose.html#numpy.testing.assert_allclose
    "numpy.testing.assert_allclose") now include “max absolute difference” and “max
    relative difference,” in addition to the previous “mismatch” percentage. This
    information makes it easier to update absolute and relative error tolerances.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: Replacement of the fftpack based [`fft`](../reference/routines.fft.html#module-numpy.fft
    "numpy.fft") module by the pocketfft library
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both implementations have the same ancestor (Fortran77 FFTPACK by Paul N. Swarztrauber),
    but pocketfft contains additional modifications which improve both accuracy and
    performance in some circumstances. For FFT lengths containing large prime factors,
    pocketfft uses Bluestein’s algorithm, which maintains \(O(N log N)\) run time
    complexity instead of deteriorating towards \(O(N*N)\) for prime lengths. Also,
    accuracy for real valued FFTs with near prime lengths has improved and is on par
    with complex valued FFTs.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Further improvements to `ctypes` support in [`numpy.ctypeslib`](../reference/routines.ctypeslib.html#module-numpy.ctypeslib
    "numpy.ctypeslib")
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new [`numpy.ctypeslib.as_ctypes_type`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes_type
    "numpy.ctypeslib.as_ctypes_type") function has been added, which can be used to
    converts a [`dtype`](../reference/generated/numpy.dtype.html#numpy.dtype "numpy.dtype")
    into a best-guess [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.11)") type. Thanks to this new function, [`numpy.ctypeslib.as_ctypes`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes
    "numpy.ctypeslib.as_ctypes") now supports a much wider range of array types, including
    structures, booleans, and integers of non-native endianness.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate") is now also a function decorator'
  id: totrans-337
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, if you have a function like:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'and you want to wrap the whole thing in [`errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate"), you have to rewrite it like so:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'but with this change, you can do:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: thereby saving a level of indentation
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp")
    and [`numpy.log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    speed up for float32 implementation'
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: float32 implementation of [`exp`](../reference/generated/numpy.exp.html#numpy.exp
    "numpy.exp") and [`log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    now benefit from AVX2/AVX512 instruction set which are detected during runtime.
    [`exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp") has a max
    ulp error of 2.52 and [`log`](../reference/generated/numpy.log.html#numpy.log
    "numpy.log") has a max ulp error or 3.83.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Improve performance of [`numpy.pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The performance of the function has been improved for most cases by filling
    in a preallocated array with the desired padded shape instead of using concatenation.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.interp`](../reference/generated/numpy.interp.html#numpy.interp "numpy.interp")
    handles infinities more robustly'
  id: totrans-349
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases where [`interp`](../reference/generated/numpy.interp.html#numpy.interp
    "numpy.interp") would previously return [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"), it now returns an appropriate infinity.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Pathlib support for [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile"), *tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump")
  id: totrans-351
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile"),
    *ndarray.ndarray.tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump") now support the [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path
    "(in Python v3.11)") type for the `file`/`fid` parameter.'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: Specialized [`isnan`](../reference/generated/numpy.isnan.html#numpy.isnan "numpy.isnan"),
    [`isinf`](../reference/generated/numpy.isinf.html#numpy.isinf "numpy.isinf"),
    and [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    ufuncs for bool and int types
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The boolean and integer types are incapable of storing [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan") and [`inf`](../reference/constants.html#numpy.inf "numpy.inf") values,
    which allows us to provide specialized ufuncs that are up to 250x faster than
    the previous approach.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    supports `datetime64` and `timedelta64` types'
  id: totrans-355
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite
    "numpy.isfinite") used to raise a *TypeError* on being used on these two types.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: New keywords added to [`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num")
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num") now accepts keywords `nan`, `posinf` and `neginf` allowing
    the user to define the value to replace the `nan`, positive and negative `np.inf`
    values respectively.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: MemoryErrors caused by allocated overly large arrays are more descriptive
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often the cause of a MemoryError is incorrect broadcasting, which results in
    a very large and incorrect shape. The message of the error now includes this shape
    to help diagnose the cause of failure.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor"),
    [`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil "numpy.ceil"), and
    [`trunc`](../reference/generated/numpy.trunc.html#numpy.trunc "numpy.trunc") now
    respect builtin magic methods'
  id: totrans-361
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These ufuncs now call the `__floor__`, `__ceil__`, and `__trunc__` methods when
    called on object arrays, making them compatible with [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") and [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)") objects.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[`quantile`](../reference/generated/numpy.quantile.html#numpy.quantile "numpy.quantile")
    now works on *fraction.Fraction* and [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") objects'
  id: totrans-363
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, this handles object arrays more gracefully, and avoids floating-
    point operations if exact arithmetic types are used.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Support of object arrays in [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul")
  id: totrans-365
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is now possible to use [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul") (or the `@` operator) with object arrays. For instance, it is
    now possible to do:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Array comparison assertions include maximum differences
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Error messages from array comparison tests such as [`testing.assert_allclose`](../reference/generated/numpy.testing.assert_allclose.html#numpy.testing.assert_allclose
    "numpy.testing.assert_allclose") now include “max absolute difference” and “max
    relative difference,” in addition to the previous “mismatch” percentage. This
    information makes it easier to update absolute and relative error tolerances.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Replacement of the fftpack based [`fft`](../reference/routines.fft.html#module-numpy.fft
    "numpy.fft") module by the pocketfft library
  id: totrans-370
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both implementations have the same ancestor (Fortran77 FFTPACK by Paul N. Swarztrauber),
    but pocketfft contains additional modifications which improve both accuracy and
    performance in some circumstances. For FFT lengths containing large prime factors,
    pocketfft uses Bluestein’s algorithm, which maintains \(O(N log N)\) run time
    complexity instead of deteriorating towards \(O(N*N)\) for prime lengths. Also,
    accuracy for real valued FFTs with near prime lengths has improved and is on par
    with complex valued FFTs.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Further improvements to `ctypes` support in [`numpy.ctypeslib`](../reference/routines.ctypeslib.html#module-numpy.ctypeslib
    "numpy.ctypeslib")
  id: totrans-372
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A new [`numpy.ctypeslib.as_ctypes_type`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes_type
    "numpy.ctypeslib.as_ctypes_type") function has been added, which can be used to
    converts a [`dtype`](../reference/generated/numpy.dtype.html#numpy.dtype "numpy.dtype")
    into a best-guess [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.11)") type. Thanks to this new function, [`numpy.ctypeslib.as_ctypes`](../reference/routines.ctypeslib.html#numpy.ctypeslib.as_ctypes
    "numpy.ctypeslib.as_ctypes") now supports a much wider range of array types, including
    structures, booleans, and integers of non-native endianness.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate") is now also a function decorator'
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, if you have a function like:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'and you want to wrap the whole thing in [`errstate`](../reference/generated/numpy.errstate.html#numpy.errstate
    "numpy.errstate"), you have to rewrite it like so:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'but with this change, you can do:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: thereby saving a level of indentation
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp")
    and [`numpy.log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    speed up for float32 implementation'
  id: totrans-382
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: float32 implementation of [`exp`](../reference/generated/numpy.exp.html#numpy.exp
    "numpy.exp") and [`log`](../reference/generated/numpy.log.html#numpy.log "numpy.log")
    now benefit from AVX2/AVX512 instruction set which are detected during runtime.
    [`exp`](../reference/generated/numpy.exp.html#numpy.exp "numpy.exp") has a max
    ulp error of 2.52 and [`log`](../reference/generated/numpy.log.html#numpy.log
    "numpy.log") has a max ulp error or 3.83.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Improve performance of [`numpy.pad`](../reference/generated/numpy.pad.html#numpy.pad
    "numpy.pad")
  id: totrans-384
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The performance of the function has been improved for most cases by filling
    in a preallocated array with the desired padded shape instead of using concatenation.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.interp`](../reference/generated/numpy.interp.html#numpy.interp "numpy.interp")
    handles infinities more robustly'
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In some cases where [`interp`](../reference/generated/numpy.interp.html#numpy.interp
    "numpy.interp") would previously return [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"), it now returns an appropriate infinity.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Pathlib support for [`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile
    "numpy.fromfile"), *tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump")
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`fromfile`](../reference/generated/numpy.fromfile.html#numpy.fromfile "numpy.fromfile"),
    *ndarray.ndarray.tofile* and [`ndarray.dump`](../reference/generated/numpy.ndarray.dump.html#numpy.ndarray.dump
    "numpy.ndarray.dump") now support the [`pathlib.Path`](https://docs.python.org/3/library/pathlib.html#pathlib.Path
    "(in Python v3.11)") type for the `file`/`fid` parameter.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Specialized [`isnan`](../reference/generated/numpy.isnan.html#numpy.isnan "numpy.isnan"),
    [`isinf`](../reference/generated/numpy.isinf.html#numpy.isinf "numpy.isinf"),
    and [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    ufuncs for bool and int types
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The boolean and integer types are incapable of storing [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan") and [`inf`](../reference/constants.html#numpy.inf "numpy.inf") values,
    which allows us to provide specialized ufuncs that are up to 250x faster than
    the previous approach.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite "numpy.isfinite")
    supports `datetime64` and `timedelta64` types'
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, [`isfinite`](../reference/generated/numpy.isfinite.html#numpy.isfinite
    "numpy.isfinite") used to raise a *TypeError* on being used on these two types.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: New keywords added to [`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num")
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`nan_to_num`](../reference/generated/numpy.nan_to_num.html#numpy.nan_to_num
    "numpy.nan_to_num") now accepts keywords `nan`, `posinf` and `neginf` allowing
    the user to define the value to replace the `nan`, positive and negative `np.inf`
    values respectively.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: MemoryErrors caused by allocated overly large arrays are more descriptive
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Often the cause of a MemoryError is incorrect broadcasting, which results in
    a very large and incorrect shape. The message of the error now includes this shape
    to help diagnose the cause of failure.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[`floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor"),
    [`ceil`](../reference/generated/numpy.ceil.html#numpy.ceil "numpy.ceil"), and
    [`trunc`](../reference/generated/numpy.trunc.html#numpy.trunc "numpy.trunc") now
    respect builtin magic methods'
  id: totrans-398
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These ufuncs now call the `__floor__`, `__ceil__`, and `__trunc__` methods when
    called on object arrays, making them compatible with [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") and [`fractions.Fraction`](https://docs.python.org/3/library/fractions.html#fractions.Fraction
    "(in Python v3.11)") objects.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '[`quantile`](../reference/generated/numpy.quantile.html#numpy.quantile "numpy.quantile")
    now works on *fraction.Fraction* and [`decimal.Decimal`](https://docs.python.org/3/library/decimal.html#decimal.Decimal
    "(in Python v3.11)") objects'
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, this handles object arrays more gracefully, and avoids floating-
    point operations if exact arithmetic types are used.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: Support of object arrays in [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul")
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is now possible to use [`matmul`](../reference/generated/numpy.matmul.html#numpy.matmul
    "numpy.matmul") (or the `@` operator) with object arrays. For instance, it is
    now possible to do:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Changes
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median")
    and [`percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile") family of functions no longer warn about `nan`'
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`numpy.median`](../reference/generated/numpy.median.html#numpy.median "numpy.median"),
    [`numpy.percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile"), and [`numpy.quantile`](../reference/generated/numpy.quantile.html#numpy.quantile
    "numpy.quantile") used to emit a `RuntimeWarning` when encountering an [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"). Since they return the `nan` value, the warning is redundant and
    has been removed.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '`timedelta64 % 0` behavior adjusted to return `NaT`'
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The modulus operation with two `np.timedelta64` operands now returns `NaT` in
    the case of division by zero, rather than returning zero
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: NumPy functions now always support overrides with `__array_function__`
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy now always checks the `__array_function__` method to implement overrides
    of NumPy functions on non-NumPy arrays, as described in [NEP 18](http://www.numpy.org/neps/nep-0018-array-function-protocol.html).
    The feature was available for testing with NumPy 1.16 if appropriate environment
    variables are set, but is now always enabled.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '`lib.recfunctions.structured_to_unstructured` does not squeeze single-field
    views'
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `structured_to_unstructured(arr[['a']])` would produce a squeezed
    result inconsistent with `structured_to_unstructured(arr[['a', b']])`. This was
    accidental. The old behavior can be retained with `structured_to_unstructured(arr[['a']]).squeeze(axis=-1)`
    or far more simply, `arr['a']`.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip") now
    uses a ufunc under the hood'
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that registering clip functions for custom dtypes in C via `descr->f->fastclip`
    is deprecated - they should use the ufunc registration mechanism instead, attaching
    to the `np.core.umath.clip` ufunc.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: It also means that `clip` accepts `where` and `casting` arguments, and can be
    override with `__array_ufunc__`.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: 'A consequence of this change is that some behaviors of the old `clip` have
    been deprecated:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: Passing `nan` to mean “do not clip” as one or both bounds. This didn’t work
    in all cases anyway, and can be better handled by passing infinities of the appropriate
    sign.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using “unsafe” casting by default when an `out` argument is passed. Using `casting="unsafe"`
    explicitly will silence this warning.
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are some corner cases with behavior changes:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Padding `max < min` has changed to be more consistent across dtypes, but should
    not be relied upon.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar `min` and `max` take part in promotion rules like they do in all other
    ufuncs.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__array_interface__` offset now works as documented'
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interface may use an `offset` value that was mistakenly ignored.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Pickle protocol in [`savez`](../reference/generated/numpy.savez.html#numpy.savez
    "numpy.savez") set to 3 for `force zip64` flag
  id: totrans-425
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`savez`](../reference/generated/numpy.savez.html#numpy.savez "numpy.savez")
    was not using the `force_zip64` flag, which limited the size of the archive to
    2GB. But using the flag requires us to use pickle protocol 3 to write `object`
    arrays. The protocol used was bumped to 3, meaning the archive will be unreadable
    by Python2.'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: Structured arrays indexed with non-existent fields raise `KeyError` not `ValueError`
  id: totrans-427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr[''bad_field'']` on a structured type raises `KeyError`, for consistency
    with `dict[''bad_field'']`.'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: '[`median`](../reference/generated/numpy.median.html#numpy.median "numpy.median")
    and [`percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile") family of functions no longer warn about `nan`'
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`numpy.median`](../reference/generated/numpy.median.html#numpy.median "numpy.median"),
    [`numpy.percentile`](../reference/generated/numpy.percentile.html#numpy.percentile
    "numpy.percentile"), and [`numpy.quantile`](../reference/generated/numpy.quantile.html#numpy.quantile
    "numpy.quantile") used to emit a `RuntimeWarning` when encountering an [`nan`](../reference/constants.html#numpy.nan
    "numpy.nan"). Since they return the `nan` value, the warning is redundant and
    has been removed.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '`timedelta64 % 0` behavior adjusted to return `NaT`'
  id: totrans-431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The modulus operation with two `np.timedelta64` operands now returns `NaT` in
    the case of division by zero, rather than returning zero
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: NumPy functions now always support overrides with `__array_function__`
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy now always checks the `__array_function__` method to implement overrides
    of NumPy functions on non-NumPy arrays, as described in [NEP 18](http://www.numpy.org/neps/nep-0018-array-function-protocol.html).
    The feature was available for testing with NumPy 1.16 if appropriate environment
    variables are set, but is now always enabled.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: '`lib.recfunctions.structured_to_unstructured` does not squeeze single-field
    views'
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously `structured_to_unstructured(arr[['a']])` would produce a squeezed
    result inconsistent with `structured_to_unstructured(arr[['a', b']])`. This was
    accidental. The old behavior can be retained with `structured_to_unstructured(arr[['a']]).squeeze(axis=-1)`
    or far more simply, `arr['a']`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[`clip`](../reference/generated/numpy.clip.html#numpy.clip "numpy.clip") now
    uses a ufunc under the hood'
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This means that registering clip functions for custom dtypes in C via `descr->f->fastclip`
    is deprecated - they should use the ufunc registration mechanism instead, attaching
    to the `np.core.umath.clip` ufunc.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: It also means that `clip` accepts `where` and `casting` arguments, and can be
    override with `__array_ufunc__`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: 'A consequence of this change is that some behaviors of the old `clip` have
    been deprecated:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Passing `nan` to mean “do not clip” as one or both bounds. This didn’t work
    in all cases anyway, and can be better handled by passing infinities of the appropriate
    sign.
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using “unsafe” casting by default when an `out` argument is passed. Using `casting="unsafe"`
    explicitly will silence this warning.
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, there are some corner cases with behavior changes:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: Padding `max < min` has changed to be more consistent across dtypes, but should
    not be relied upon.
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalar `min` and `max` take part in promotion rules like they do in all other
    ufuncs.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__array_interface__` offset now works as documented'
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The interface may use an `offset` value that was mistakenly ignored.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: Pickle protocol in [`savez`](../reference/generated/numpy.savez.html#numpy.savez
    "numpy.savez") set to 3 for `force zip64` flag
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`savez`](../reference/generated/numpy.savez.html#numpy.savez "numpy.savez")
    was not using the `force_zip64` flag, which limited the size of the archive to
    2GB. But using the flag requires us to use pickle protocol 3 to write `object`
    arrays. The protocol used was bumped to 3, meaning the archive will be unreadable
    by Python2.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: Structured arrays indexed with non-existent fields raise `KeyError` not `ValueError`
  id: totrans-450
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`arr[''bad_field'']` on a structured type raises `KeyError`, for consistency
    with `dict[''bad_field'']`.'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
