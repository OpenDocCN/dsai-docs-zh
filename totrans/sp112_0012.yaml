- en: Compressed Sparse Graph Routines (scipy.sparse.csgraph)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/csgraph.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/csgraph.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Example: Word Ladders'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A [Word Ladder](https://en.wikipedia.org/wiki/Word_ladder) is a word game invented
    by Lewis Carroll, in which players find paths between words by switching one letter
    at a time. For example, one can link “ape” and “man” in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: \[{\rm ape \to apt \to ait \to bit \to big \to bag \to mag \to man}\]
  prefs: []
  type: TYPE_NORMAL
- en: Note that each step involves changing just one letter of the word. This is just
    one possible path from “ape” to “man”, but is it the shortest possible path? If
    we desire to find the shortest word-ladder path between two given words, the sparse
    graph submodule can help.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need a list of valid words. Many operating systems have such a list
    built in. For example, on linux, a word list can often be found at one of the
    following locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Another easy source for words are the Scrabble word lists available at various
    sites around the internet (search with your favorite search engine). We’ll first
    create this list. The system word lists consist of a file with one word per line.
    The following should be modified to use the particular word list you have available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to look at words of length 3, so let’s select just those words of the
    correct length. We’ll also eliminate words which start with upper-case (proper
    nouns) or contain non-alphanumeric characters, like apostrophes and hyphens. Finally,
    we’ll make sure everything is lower-case for comparison later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we have a list of 586 valid three-letter words (the exact number may change
    depending on the particular list used). Each of these words will become a node
    in our graph, and we will create edges connecting the nodes associated with each
    pair of words which differs by only one letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are efficient ways to do this, and inefficient ways to do this. To do
    this as efficiently as possible, we’re going to use some sophisticated numpy array
    manipulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have an array where each entry is three unicode characters long. We’d like
    to find all pairs where exactly one character is different. We’ll start by converting
    each word to a 3-D vector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’ll use the [Hamming distance](https://en.wikipedia.org/wiki/Hamming_distance)
    between each point to determine which pairs of words are connected. The Hamming
    distance measures the fraction of entries between two vectors which differ: any
    two words with a Hamming distance equal to \(1/N\), where \(N\) is the number
    of letters, are connected in the word ladder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'When comparing the distances, we don’t use an equality because this can be
    unstable for floating point values. The inequality produces the desired result,
    as long as no two entries of the word list are identical. Now, that our graph
    is set up, we’ll use a shortest path search to find the path between any two words
    in the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to check that these match, because if the words are not in the list,
    that will not be the case. Now, all we need is to find the shortest path between
    these two indices in the graph. We’ll use [Dijkstra’s algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm),
    because it allows us to find the path for just one node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So we see that the shortest path between “ape” and “man” contains only five
    steps. We can use the predecessors returned by the algorithm to reconstruct this
    path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is three fewer links than our initial example: the path from “ape” to
    “man” is only five steps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using other tools in the module, we can answer other questions. For example,
    are there three-letter words which are not linked in a word ladder? This is a
    question of connected components in the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this particular sample of three-letter words, there are 15 connected components:
    that is, 15 distinct sets of words with no paths between the sets. How many words
    are there in each of these sets? We can learn this from the list of components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one large connected set and 14 smaller ones. Let’s look at the words
    in the smaller ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These are all the three-letter words which do not connect to others via a word
    ladder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might also be curious about which words are maximally separated. Which two
    words take the most links to connect? We can determine this by computing the matrix
    of all shortest paths. Note that, by convention, the distance between two non-connected
    points is reported to be infinity, so we’ll need to remove these before finding
    the maximum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'So, there is at least one pair of words which takes 13 steps to get from one
    to the other! Let’s determine which these are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that there are two pairs of words which are maximally separated from
    each other: ‘imp’ and ‘ump’ on the one hand, and ‘ohm’ and ‘ohs’ on the other.
    We can find the connecting list in the same way as above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This gives us the path we desired to see.
  prefs: []
  type: TYPE_NORMAL
- en: Word ladders are just one potential application of scipy’s fast graph algorithms
    for sparse matrices. Graph theory makes appearances in many areas of mathematics,
    data analysis, and machine learning. The sparse graph tools are flexible enough
    to handle many of these situations.
  prefs: []
  type: TYPE_NORMAL
