- en: Indexing and selecting data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 索引和选择数据
- en: 原文：[https://pandas.pydata.org/docs/user_guide/indexing.html](https://pandas.pydata.org/docs/user_guide/indexing.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://pandas.pydata.org/docs/user_guide/indexing.html](https://pandas.pydata.org/docs/user_guide/indexing.html)
- en: 'The axis labeling information in pandas objects serves many purposes:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 对象中的轴标签信息具有多种用途：
- en: Identifies data (i.e. provides *metadata*) using known indicators, important
    for analysis, visualization, and interactive console display.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用已知指标标识数据（即提供 *元数据*），对于分析、可视化和交互式控制台显示非常重要。
- en: Enables automatic and explicit data alignment.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启用自动和明确的数据对齐。
- en: Allows intuitive getting and setting of subsets of the data set.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许直观地获取和设置数据集的子集。
- en: 'In this section, we will focus on the final point: namely, how to slice, dice,
    and generally get and set subsets of pandas objects. The primary focus will be
    on Series and DataFrame as they have received more development attention in this
    area.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将重点放在最后一点上：即如何切片、切块和通常获取和设置 pandas 对象的子集。���要关注将放在 Series 和 DataFrame
    上，因为它们在这个领域接受了更多的开发关注。
- en: Note
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Python and NumPy indexing operators `[]` and attribute operator `.` provide
    quick and easy access to pandas data structures across a wide range of use cases.
    This makes interactive work intuitive, as there’s little new to learn if you already
    know how to deal with Python dictionaries and NumPy arrays. However, since the
    type of the data to be accessed isn’t known in advance, directly using standard
    operators has some optimization limits. For production code, we recommended that
    you take advantage of the optimized pandas data access methods exposed in this
    chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Python 和 NumPy 索引运算符 `[]` 和属性运算符 `.` 提供了对 pandas 数据结构的快速简便访问，适用于各种用例。这使得交互式工作变得直观，因为如果你已经知道如何处理
    Python 字典和 NumPy 数组，那么学习成本很低。然而，由于要访问的数据类型事先未知，直接使用标准运算符存在一些优化限制。对于生产代码，我们建议您利用本章节中提供的优化的
    pandas 数据访问方法。
- en: Warning
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Whether a copy or a reference is returned for a setting operation, may depend
    on the context. This is sometimes called `chained assignment` and should be avoided.
    See [Returning a View versus Copy](#indexing-view-versus-copy).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设置操作，返回的是副本还是引用，可能取决于上下文。有时这被称为 `chained assignment`，应该避免。请参阅[返回视图与副本](#indexing-view-versus-copy)。
- en: See the [MultiIndex / Advanced Indexing](advanced.html#advanced) for `MultiIndex`
    and more advanced indexing documentation.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在[MultiIndex / 高级索引](advanced.html#advanced)中查看 `MultiIndex` 和更高级的索引文档。
- en: See the [cookbook](cookbook.html#cookbook-selection) for some advanced strategies.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在[食谱](cookbook.html#cookbook-selection)中查看一些高级策略。
- en: '## Different choices for indexing'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '## 不同的索引选择'
- en: Object selection has had a number of user-requested additions in order to support
    more explicit location based indexing. pandas now supports three types of multi-axis
    indexing.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持更明确的基于位置的索引，对象选择已经增加了一些用户请求的内容。pandas 现在支持三种类型的多轴索引。
- en: '`.loc` is primarily label based, but may also be used with a boolean array.
    `.loc` will raise `KeyError` when the items are not found. Allowed inputs are:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.loc` 主要基于标签，但也可以与布尔数组一起使用。当未找到项目时，`.loc` 会引发 `KeyError`。允许的输入包括：'
- en: A single label, e.g. `5` or `'a'` (Note that `5` is interpreted as a *label*
    of the index. This use is **not** an integer position along the index.).
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个标签，例如 `5` 或 `'a'`（请注意，`5` 被解释为索引的 *标签*。这种用法**不是**索引上的整数位置。）。
- en: ''
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A list or array of labels `['a', 'b', 'c']`.
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标签列表或数组 `['a', 'b', 'c']`。
- en: ''
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A slice object with labels `'a':'f'` (Note that contrary to usual Python slices,
    **both** the start and the stop are included, when present in the index! See [Slicing
    with labels](#indexing-slicing-with-labels) and [Endpoints are inclusive](advanced.html#advanced-endpoints-are-inclusive).)
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有标签 `'a':'f'` 的切片对象（请注意，与通常的 Python 切片相反，**开始和停止都包括在内**，当存在于索引中时！请参阅[使用标签切片](#indexing-slicing-with-labels)和[端点是包含的](advanced.html#advanced-endpoints-are-inclusive)。）
- en: ''
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A boolean array (any `NA` values will be treated as `False`).
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔数组（任何 `NA` 值将被视为 `False`）。
- en: ''
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A `callable` function with one argument (the calling Series or DataFrame) and
    that returns valid output for indexing (one of the above).
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有一个参数（调用的 Series 或 DataFrame）的 `callable` 函数，并返回用于索引的有效输出（上述之一）。
- en: ''
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A tuple of row (and column) indices whose elements are one of the above inputs.
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含上述输入之一的行（和列）索引的元组。
- en: See more at [Selection by Label](#indexing-label).
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在[按标签选择](#indexing-label)中查看更多信息。
- en: '`.iloc` is primarily integer position based (from `0` to `length-1` of the
    axis), but may also be used with a boolean array. `.iloc` will raise `IndexError`
    if a requested indexer is out-of-bounds, except *slice* indexers which allow out-of-bounds
    indexing. (this conforms with Python/NumPy *slice* semantics). Allowed inputs
    are:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.iloc`主要基于整数位置（从轴的`0`到`length-1`），但也可以与布尔数组一起使用。如果请求的索引器超出范围，`.iloc`将引发`IndexError`，除了*切片*索引器允许超出范围索引（这符合Python/NumPy的*切片*语义）。允许的输入为：'
- en: An integer e.g. `5`.
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数，例如`5`。
- en: ''
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A list or array of integers `[4, 3, 0]`.
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数列表或数组`[4, 3, 0]`。
- en: ''
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A slice object with ints `1:7`.
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含整数`1:7`的切片对象。
- en: ''
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A boolean array (any `NA` values will be treated as `False`).
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔数组（任何`NA`值将被视为`False`）。
- en: ''
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A `callable` function with one argument (the calling Series or DataFrame) and
    that returns valid output for indexing (one of the above).
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有一个参数（调用的Series或DataFrame）的`callable`函数，并返回用于索引的有效输出（上述之一）。
- en: ''
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A tuple of row (and column) indices whose elements are one of the above inputs.
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含行（和列）索引的元组，其元素是上述输入之一。
- en: See more at [Selection by Position](#indexing-integer), [Advanced Indexing](advanced.html#advanced)
    and [Advanced Hierarchical](advanced.html#advanced-advanced-hierarchical).
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看更多内容请参考[按位置选择](#indexing-integer)，[高级索引](advanced.html#advanced)和[高级分层](advanced.html#advanced-advanced-hierarchical)。
- en: '`.loc`, `.iloc`, and also `[]` indexing can accept a `callable` as indexer.
    See more at [Selection By Callable](#indexing-callable).'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.loc`、`.iloc`，以及`[]`索引可以接受`callable`作为索引器。查看更多内容请参考[按callable选择](#indexing-callable)。'
- en: Note
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Destructuring tuple keys into row (and column) indexes occurs *before* callables
    are applied, so you cannot return a tuple from a callable to index both rows and
    columns.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将元组键解构为行（和列）索引发生在调用可调用函数之前，因此您不能从可调用函数返回元组以同时索引���和列。
- en: Getting values from an object with multi-axes selection uses the following notation
    (using `.loc` as an example, but the following applies to `.iloc` as well). Any
    of the axes accessors may be the null slice `:`. Axes left out of the specification
    are assumed to be `:`, e.g. `p.loc['a']` is equivalent to `p.loc['a', :]`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从具有多轴选择的对象获取值使用以下表示法（以`.loc`为例，但以下内容也适用于`.iloc`）。任何轴访问器都可以是空切片`:`。规范中省略的轴被假定为`:`，例如`p.loc['a']`等同于`p.loc['a',
    :]`。
- en: '| Object Type | Indexers |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 对象类型 | 索引器 |'
- en: '| --- | --- |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Series | `s.loc[indexer]` |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| Series | `s.loc[indexer]` |'
- en: '| DataFrame | `df.loc[row_indexer,column_indexer]` |  ## Basics'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '| DataFrame | `df.loc[row_indexer,column_indexer]` |  ## 基础知识'
- en: 'As mentioned when introducing the data structures in the [last section](basics.html#basics),
    the primary function of indexing with `[]` (a.k.a. `__getitem__` for those familiar
    with implementing class behavior in Python) is selecting out lower-dimensional
    slices. The following table shows return type values when indexing pandas objects
    with `[]`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[上一节](basics.html#basics)介绍数据结构时提到的，使用`[]`进行索引（在Python中实现类行为的熟悉者称之为`__getitem__`）的主要功能是选择出低维度切片。下表显示了使用`[]`对pandas对象进行索引时的返回类型值：
- en: '| Object Type | Selection | Return Value Type |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 对象类型 | 选择 | 返回值类型 |'
- en: '| --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Series | `series[label]` | scalar value |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Series | `series[label]` | 标量值 |'
- en: '| DataFrame | `frame[colname]` | `Series` corresponding to colname |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| DataFrame | `frame[colname]` | 与colname对应的`Series` |'
- en: 'Here we construct a simple time series data set to use for illustrating the
    indexing functionality:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们构建一个简单的时间序列数据集，用于说明索引功能：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: None of the indexing functionality is time series specific unless specifically
    stated.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 除非特别说明，否则索引功能都不是特定于时间序列的。
- en: 'Thus, as per above, we have the most basic indexing using `[]`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据上述，我们可以使用`[]`进行最基本的索引：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can pass a list of columns to `[]` to select columns in that order. If
    a column is not contained in the DataFrame, an exception will be raised. Multiple
    columns can also be set in this manner:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以传递一个列列表给`[]`以按顺序选择列。如果DataFrame中不包含某列，将引发异常。也可以以这种方式设置多个列：
- en: '[PRE2]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You may find this useful for applying a transform (in-place) to a subset of
    the columns.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会发现这对于对一部分列应用变换（就地）很有用。
- en: Warning
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: pandas aligns all AXES when setting `Series` and `DataFrame` from `.loc`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`.loc`设置`Series`和`DataFrame`时，pandas会对齐所有轴。
- en: This will **not** modify `df` because the column alignment is before value assignment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会修改`df`，因为列对齐是在赋值之前进行的。
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The correct way to swap column values is by using raw values:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 交换列值的正确方式是使用原始值：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, pandas does not align AXES when setting `Series` and `DataFrame` from
    `.iloc` because `.iloc` operates by position.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用`.iloc`设置`Series`和`DataFrame`时，pandas不会对轴进行对齐，因为`.iloc`是按位置操作的。
- en: This will modify `df` because the column alignment is not done before value
    assignment.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将修改`df`，因为在值分配之前未执行列对齐。
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Attribute access
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性访问
- en: 'You may access an index on a `Series` or column on a `DataFrame` directly as
    an attribute:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接访问`Series`上的索引或`DataFrame`上的列作为属性：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Warning
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: You can use this access only if the index element is a valid Python identifier,
    e.g. `s.1` is not allowed. See [here for an explanation of valid identifiers](https://docs.python.org/3/reference/lexical_analysis.html#identifiers).
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当索引元素是有效的Python标识符时，才能使用此访问，例如`s.1`是不允许的。请参阅[此处以获取有效标识符的解释](https://docs.python.org/3/reference/lexical_analysis.html#identifiers)。
- en: The attribute will not be available if it conflicts with an existing method
    name, e.g. `s.min` is not allowed, but `s['min']` is possible.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性与现有方法名称冲突，则该属性将不可用，例如`s.min`是不允许的，但`s['min']`是可能的。
- en: 'Similarly, the attribute will not be available if it conflicts with any of
    the following list: `index`, `major_axis`, `minor_axis`, `items`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似地，如果属性与以下列表中的任何一个冲突，则该属性将不可用：`index`，`major_axis`，`minor_axis`，`items`。
- en: In any of these cases, standard indexing will still work, e.g. `s['1']`, `s['min']`,
    and `s['index']` will access the corresponding element or column.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何这些情况下，标准索引仍然有效，例如`s['1']`，`s['min']`和`s['index']`将访问相应的元素或列。
- en: If you are using the IPython environment, you may also use tab-completion to
    see these accessible attributes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在IPython环境中使用，还可以使用制表符补全来查看这些可访问的属性。
- en: 'You can also assign a `dict` to a row of a `DataFrame`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将`dict`分配给`DataFrame`的一行：
- en: '[PRE9]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can use attribute access to modify an existing element of a Series or column
    of a DataFrame, but be careful; if you try to use attribute access to create a
    new column, it creates a new attribute rather than a new column and will this
    raise a `UserWarning`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用属性访问来修改Series的现有元素或DataFrame的列，但要小心；如果尝试使用属性访问创建新列，则会创建一个新属性而不是新列，并且会引发`UserWarning`：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Slicing ranges
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片范围
- en: The most robust and consistent way of slicing ranges along arbitrary axes is
    described in the [Selection by Position](#indexing-integer) section detailing
    the `.iloc` method. For now, we explain the semantics of slicing using the `[]`
    operator.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着任意轴切片范围的最稳健和一致的方法在[按位置选择](#indexing-integer)部分详细描述了`.iloc`方法。现在，我们解释使用`[]`运算符进行切片的语义。
- en: 'With Series, the syntax works exactly as with an ndarray, returning a slice
    of the values and the corresponding labels:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Series，语法与ndarray完全相同，返回值的切片和相应的标签：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note that setting works as well:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，设置也有效：
- en: '[PRE12]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With DataFrame, slicing inside of `[]` **slices the rows**. This is provided
    largely as a convenience since it is such a common operation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DataFrame，在`[]`内部切片**切片行**。这在很大程度上是为了方便，因为这是一个常见的操作。
- en: '[PRE13]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '## Selection by label'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '## 按标签选择'
- en: Warning
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Whether a copy or a reference is returned for a setting operation, may depend
    on the context. This is sometimes called `chained assignment` and should be avoided.
    See [Returning a View versus Copy](#indexing-view-versus-copy).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置操作中，返回的是副本还是引用，可能取决于上下文。有时这被称为`链式赋值`，应该避免。请参阅[返回视图与副本](#indexing-view-versus-copy)。
- en: Warning
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '`.loc` is strict when you present slicers that are not compatible (or convertible)
    with the index type. For example using integers in a `DatetimeIndex`. These will
    raise a `TypeError`.'
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您提供与索引类型不兼容（或可转换）的切片器时，`.loc`是严格的。例如，在`DatetimeIndex`中使用整数。这将引发`TypeError`。
- en: ''
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE14]'
- en: String likes in slicing *can* be convertible to the type of the index and lead
    to natural slicing.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串切片中的*可以*转换为索引类型，并导致自然切片。
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: pandas provides a suite of methods in order to have **purely label based indexing**.
    This is a strict inclusion based protocol. Every label asked for must be in the
    index, or a `KeyError` will be raised. When slicing, both the start bound **AND**
    the stop bound are *included*, if present in the index. Integers are valid labels,
    but they refer to the label **and not the position**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: pandas提供了一套方法，以实现**纯标签索引**。这是一个严格的包含协议。每个要求的标签必须在索引中，否则将引发`KeyError`。在切片时，如果存在于索引中，则起始边界**和**停止边界都*包括*。整数是有效的标签，但它们指的是标签**而不是位置**。
- en: 'The `.loc` attribute is the primary access method. The following are valid
    inputs:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`.loc`属性是主要的访问方法。以下是有效的输入：'
- en: A single label, e.g. `5` or `'a'` (Note that `5` is interpreted as a *label*
    of the index. This use is **not** an integer position along the index.).
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单个标签，例如`5`或`'a'`（请注意，`5`被解释为索引的*标签*。这种用法**不是**索引上的整数位置。）。
- en: A list or array of labels `['a', 'b', 'c']`.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标签列表或数组`['a', 'b', 'c']`。
- en: A slice object with labels `'a':'f'` (Note that contrary to usual Python slices,
    **both** the start and the stop are included, when present in the index! See [Slicing
    with labels](#indexing-slicing-with-labels).
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有标签`'a':'f'`的切片对象（请注意，与通常的Python切片相反，**当索引中存在时**，起始和停止都包括在内！请参见[使用标签切片](#indexing-slicing-with-labels)）。
- en: A boolean array.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔数组。
- en: A `callable`, see [Selection By Callable](#indexing-callable).
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`callable`，请参见[通过callable选择](#indexing-callable)。
- en: '[PRE16]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that setting works as well:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，设置也可以：
- en: '[PRE17]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'With a DataFrame:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DataFrame：
- en: '[PRE18]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Accessing via label slices:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签切片访问：
- en: '[PRE19]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'For getting a cross section using a label (equivalent to `df.xs(''a'')`):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签获取交叉部分（等同于`df.xs('a')`）：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For getting values with a boolean array:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 通过布尔数组获取值：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'NA values in a boolean array propagate as `False`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数组中的NA值传播为`False`：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For getting a value explicitly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 明确获取一个值：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '### Slicing with labels'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用标签切片'
- en: 'When using `.loc` with slices, if both the start and the stop labels are present
    in the index, then elements *located* between the two (including them) are returned:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片与`.loc`一起使��时，如果起始和停止标签都存在于索引中，则返回两者之间（包括它们）的元素：
- en: '[PRE24]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If at least one of the two is absent, but the index is sorted, and can be compared
    against start and stop labels, then slicing will still work as expected, by selecting
    labels which *rank* between the two:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两者中至少有一个缺失，但索引已排序，并且可以与起始和停止标签进行比较，则切片仍将按预期工作，通过选择介于两者之间的标签：
- en: '[PRE25]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: However, if at least one of the two is absent *and* the index is not sorted,
    an error will be raised (since doing otherwise would be computationally expensive,
    as well as potentially ambiguous for mixed type indexes). For instance, in the
    above example, `s.loc[1:6]` would raise `KeyError`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果两者中至少有一个缺失*且*索引未排序，则会引发错误（因为否则会在计算上昂贵，以及对于混合类型索引可能会产生歧义）。例如，在上面的示例中，`s.loc[1:6]`会引发`KeyError`。
- en: For the rationale behind this behavior, see [Endpoints are inclusive](advanced.html#advanced-endpoints-are-inclusive).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此行为背后的原理，请参见[端点是包容的](advanced.html#advanced-endpoints-are-inclusive)。
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Also, if the index has duplicate labels *and* either the start or the stop label
    is duplicated, an error will be raised. For instance, in the above example, `s.loc[2:5]`
    would raise a `KeyError`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果索引具有重复标签*且*起始或停止标签重复，则会引发错误。例如，在上面的示例中，`s.loc[2:5]`会引发`KeyError`。
- en: 'For more information about duplicate labels, see [Duplicate Labels](duplicates.html#duplicates).  ##
    Selection by position'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有关重复标签的更多信息，请参见[重复标签](duplicates.html#duplicates)。## 通过位置选择
- en: Warning
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Whether a copy or a reference is returned for a setting operation, may depend
    on the context. This is sometimes called `chained assignment` and should be avoided.
    See [Returning a View versus Copy](#indexing-view-versus-copy).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于设置操作返回的是副本还是引用，可能取决于上下文。有时这被称为`chained assignment`，应该避免。请参见[返回视图与副本](#indexing-view-versus-copy)。
- en: pandas provides a suite of methods in order to get **purely integer based indexing**.
    The semantics follow closely Python and NumPy slicing. These are `0-based` indexing.
    When slicing, the start bound is *included*, while the upper bound is *excluded*.
    Trying to use a non-integer, even a **valid** label will raise an `IndexError`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: pandas提供了一套方法，以便获得**纯整数索引**。语义紧随Python和NumPy的切片。这些是`0-based`索引。在切片时，起始边界是*包含*的，而上限是*排除*的。尝试使用非整数，即使是**有效**标签也会引发`IndexError`。
- en: 'The `.iloc` attribute is the primary access method. The following are valid
    inputs:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`.iloc`属性是主要访问方法。以下是有效的输入：'
- en: An integer e.g. `5`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数，例如`5`。
- en: A list or array of integers `[4, 3, 0]`.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个整数列表或数组`[4, 3, 0]`。
- en: A slice object with ints `1:7`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有整数`1:7`的切片对象。
- en: A boolean array.
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔数组。
- en: A `callable`, see [Selection By Callable](#indexing-callable).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个`callable`，请参见[通过callable选择](#indexing-callable)。
- en: A tuple of row (and column) indexes, whose elements are one of the above types.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含上述类型之一的行（和列）索引的元组。
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Note that setting works as well:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，设置也可以：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'With a DataFrame:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DataFrame：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Select via integer slicing:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通过整数切片选择：
- en: '[PRE30]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Select via integer list:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 通过整数列表选择：
- en: '[PRE31]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'For getting a cross section using an integer position (equiv to `df.xs(1)`):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 通过整数位置获取交叉部分（等同于`df.xs(1)`）：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Out of range slice indexes are handled gracefully just as in Python/NumPy.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 超出范围的切片索引会像在Python/NumPy中一样得到很好的处理。
- en: '[PRE36]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that using slices that go out of bounds can result in an empty axis (e.g.
    an empty DataFrame being returned).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，使用超出边界的切片可能导致一个空轴（例如返回一个空的DataFrame）。
- en: '[PRE37]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A single indexer that is out of bounds will raise an `IndexError`. A list of
    indexers where any element is out of bounds will raise an `IndexError`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个超出边界的单个索引器将引发`IndexError`。任何元素超出边界的索引器列表将引发`IndexError`。
- en: '[PRE38]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]  ## Selection by callable'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE39]  ## 通过可调用进行选择'
- en: '`.loc`, `.iloc`, and also `[]` indexing can accept a `callable` as indexer.
    The `callable` must be a function with one argument (the calling Series or DataFrame)
    that returns valid output for indexing.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`.loc`、`.iloc`，还有`[]`索引可以接受`callable`作为索引器。`callable`必须是一个带有一个参数（调用的Series或DataFrame）的函数，返回用于索引的有效输出。'
- en: Note
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For `.iloc` indexing, returning a tuple from the callable is not supported,
    since tuple destructuring for row and column indexes occurs *before* applying
    callables.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`.iloc`索引，不支持从可调用函数返回元组，因为在应用可调用函数之前会发生行和列索引的元组解构。
- en: '[PRE40]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: You can use callable indexing in `Series`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`Series`中使用可调用的索引。
- en: '[PRE41]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Using these methods / indexers, you can chain data selection operations without
    using a temporary variable.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些方法/索引器，你可以在不使用临时变量的情况下链接数据选择操作。
- en: '[PRE42]  ## Combining positional and label-based indexing'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE42]  ## 结合位置和基于标签的索引'
- en: 'If you wish to get the 0th and the 2nd elements from the index in the ‘A’ column,
    you can do:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望从‘A’列的索引中获取第0和第2个元素，可以这样做：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This can also be expressed using `.iloc`, by explicitly getting locations on
    the indexers, and using *positional* indexing to select things.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以使用`.iloc`来表示，通过在索引器上明确获取位置，并使用*位置*索引来选择内容。
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'For getting *multiple* indexers, using `.get_indexer`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取*多个*索引器，可以使用`.get_indexer`：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Reindexing
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新索引
- en: The idiomatic way to achieve selecting potentially not-found elements is via
    `.reindex()`. See also the section on [reindexing](basics.html#basics-reindexing).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 实现选择可能未找到元素的惯用方法是通过`.reindex()`。另请参阅关于[重新索引](basics.html#basics-reindexing)的部分。
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Alternatively, if you want to select only *valid* keys, the following is idiomatic
    and efficient; it is guaranteed to preserve the dtype of the selection.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你只想选择*有效*的键，下面是惯用且高效的方法；它保证保留所选内容的dtype。
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Having a duplicated index will raise for a `.reindex()`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有重复索引将为`.reindex()`引发错误：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Generally, you can intersect the desired labels with the current axis, and then
    reindex.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你可以将所需的标签与当前轴相交，然后重新索引。
- en: '[PRE49]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: However, this would *still* raise if your resulting index is duplicated.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你的结果索引重复，这仍然会引发错误。
- en: '[PRE50]  ## Selecting random samples'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE50]  ## 选择随机样本'
- en: A random selection of rows or columns from a Series or DataFrame with the [`sample()`](../reference/api/pandas.DataFrame.sample.html#pandas.DataFrame.sample
    "pandas.DataFrame.sample") method. The method will sample rows by default, and
    accepts a specific number of rows/columns to return, or a fraction of rows.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从Series或DataFrame中随机选择行或列的方法是使用[`sample()`](../reference/api/pandas.DataFrame.sample.html#pandas.DataFrame.sample
    "pandas.DataFrame.sample")方法。该方法默认会抽样行，并接受要返回的特定行/列数，或行的比例。
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'By default, `sample` will return each row at most once, but one can also sample
    with replacement using the `replace` option:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sample`将最多返回每行一次，但也可以使用`replace`选项进行替换抽样：
- en: '[PRE52]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'By default, each row has an equal probability of being selected, but if you
    want rows to have different probabilities, you can pass the `sample` function
    sampling weights as `weights`. These weights can be a list, a NumPy array, or
    a Series, but they must be of the same length as the object you are sampling.
    Missing values will be treated as a weight of zero, and inf values are not allowed.
    If weights do not sum to 1, they will be re-normalized by dividing all weights
    by the sum of the weights. For example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每行被选择的概率相等，但如果你希望行具有不同的概率，可以将`sample`函数的抽样权重作为`weights`传递。这些权重可以是列表、NumPy数组或Series，但它们必须与你要抽样的对象的长度相同。缺失值将被视为权重为零，不允许inf值。如果权重不总和为1，它们将通过将所有权重除以权重总和来重新规范化。例如：
- en: '[PRE53]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: When applied to a DataFrame, you can use a column of the DataFrame as sampling
    weights (provided you are sampling rows and not columns) by simply passing the
    name of the column as a string.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用于DataFrame时，你可以通过简单地将列的名称作为字符串传递来使用DataFrame的列作为抽样权重（前提是你正在抽样行而不是列）。
- en: '[PRE54]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '`sample` also allows users to sample columns instead of rows using the `axis`
    argument.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`sample`还允许用户使用`axis`参数而不是行来对列进行抽样。'
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Finally, one can also set a seed for `sample`’s random number generator using
    the `random_state` argument, which will accept either an integer (as a seed) or
    a NumPy RandomState object.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您还可以使用`random_state`参数为`sample`的随机数生成器设置种子，该参数将接受整数（作为种子）或NumPy RandomState对象。
- en: '[PRE56]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Setting with enlargement
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置扩大
- en: The `.loc/[]` operations can perform enlargement when setting a non-existent
    key for that axis.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在为该轴设置不存在的键时，`.loc/[]`操作可以执行扩大。
- en: In the `Series` case this is effectively an appending operation.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Series`情况下，这实际上是一个追加操作。
- en: '[PRE57]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: A `DataFrame` can be enlarged on either axis via `.loc`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`.loc`，可以在任一轴上扩大`DataFrame`。
- en: '[PRE58]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This is like an `append` operation on the `DataFrame`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这类似于在`DataFrame`上进行`append`操作。
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '## Fast scalar value getting and setting'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '## 快速标量值获取和设置'
- en: Since indexing with `[]` must handle a lot of cases (single-label access, slicing,
    boolean indexing, etc.), it has a bit of overhead in order to figure out what
    you’re asking for. If you only want to access a scalar value, the fastest way
    is to use the `at` and `iat` methods, which are implemented on all of the data
    structures.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用`[]`进行索引必须处理许多情况（单标签访问、切片、布尔索引等），因此为了弄清楚您要求的内容，需要一些额外的开销。如果您只想访问标量值，最快的方法是使用在所有数据结构上实现的`at`和`iat`方法。
- en: Similarly to `loc`, `at` provides **label** based scalar lookups, while, `iat`
    provides **integer** based lookups analogously to `iloc`
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 与`loc`类似，`at`提供基于**标签**的标量查找，而`iat`类似于`iloc`提供基于**整数**的查找
- en: '[PRE60]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: You can also set using these same indexers.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用这些相同的索引器进行设置。
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`at` may enlarge the object in-place as above if the indexer is missing.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果索引器缺失，`at`可能会就地扩大对象。
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Boolean indexing
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔索引
- en: 'Another common operation is the use of boolean vectors to filter the data.
    The operators are: `|` for `or`, `&` for `and`, and `~` for `not`. These **must**
    be grouped by using parentheses, since by default Python will evaluate an expression
    such as `df[''A''] > 2 & df[''B''] < 3` as `df[''A''] > (2 & df[''B'']) < 3`,
    while the desired evaluation order is `(df[''A''] > 2) & (df[''B''] < 3)`.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见操作是使用布尔向量过滤数据。运算符有：`|`表示`或`，`&`表示`与`，`~`表示`非`。这些**必须**使用括号分组，因为默认情况下，Python会将表达式如`df['A']
    > 2 & df['B'] < 3`评估为`df['A'] > (2 & df['B']) < 3`，而期望的评估顺序是`(df['A'] > 2) & (df['B']
    < 3)`。
- en: 'Using a boolean vector to index a Series works exactly as in a NumPy ndarray:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔向量索引Series的方式与NumPy ndarray完全相同：
- en: '[PRE63]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You may select rows from a DataFrame using a boolean vector the same length
    as the DataFrame’s index (for example, something derived from one of the columns
    of the DataFrame):'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用与DataFrame索引长度相同的布尔向量（例如，从DataFrame的列之一派生的内容）选择DataFrame的行：
- en: '[PRE64]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'List comprehensions and the `map` method of Series can also be used to produce
    more complex criteria:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 列表推导和Series的`map`方法也可用于生成更复杂的条件：
- en: '[PRE65]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: With the choice methods [Selection by Label](#indexing-label), [Selection by
    Position](#indexing-integer), and [Advanced Indexing](advanced.html#advanced)
    you may select along more than one axis using boolean vectors combined with other
    indexing expressions.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用选择方法[按标签选择](#indexing-label)、[按位置选择](#indexing-integer)和[高级索引](advanced.html#advanced)，您可以使用布尔向量结合其他索引表达式沿多个轴选择。
- en: '[PRE66]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Warning
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '`iloc` supports two kinds of boolean indexing. If the indexer is a boolean
    `Series`, an error will be raised. For instance, in the following example, `df.iloc[s.values,
    1]` is ok. The boolean indexer is an array. But `df.iloc[s, 1]` would raise `ValueError`.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '`iloc`支持两种布尔索引。如果索引器是布尔`Series`，则会引发错误。例如，在以下示例中，`df.iloc[s.values, 1]`是可以的。布尔索引器是一个数组。但`df.iloc[s,
    1]`会引发`ValueError`。'
- en: '[PRE67]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '## Indexing with isin'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用isin进行索引'
- en: 'Consider the [`isin()`](../reference/api/pandas.Series.isin.html#pandas.Series.isin
    "pandas.Series.isin") method of `Series`, which returns a boolean vector that
    is true wherever the `Series` elements exist in the passed list. This allows you
    to select rows where one or more columns have values you want:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑`Series`的[`isin()`](../reference/api/pandas.Series.isin.html#pandas.Series.isin
    "pandas.Series.isin")方法，它返回一个布尔向量，其中`Series`元素存在于传递的列表中的位置为真。这使您可以选择具有您想要的值的一个或多个列的行：
- en: '[PRE68]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'The same method is available for `Index` objects and is useful for the cases
    when you don’t know which of the sought labels are in fact present:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index`对象也可使用相同方法，并且在您不知道所寻标签中哪些实际存在时非常有用：'
- en: '[PRE69]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'In addition to that, `MultiIndex` allows selecting a separate level to use
    in the membership check:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，`MultiIndex` 允许选择一个单独的级别用于成员检查：
- en: '[PRE70]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: DataFrame also has an [`isin()`](../reference/api/pandas.DataFrame.isin.html#pandas.DataFrame.isin
    "pandas.DataFrame.isin") method. When calling `isin`, pass a set of values as
    either an array or dict. If values is an array, `isin` returns a DataFrame of
    booleans that is the same shape as the original DataFrame, with True wherever
    the element is in the sequence of values.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame 还有一个 [`isin()`](../reference/api/pandas.DataFrame.isin.html#pandas.DataFrame.isin
    "pandas.DataFrame.isin") 方法。在调用 `isin` 时，将一组值作为数组或字典传递。如果值是一个数组，`isin` 返回一个与原始
    DataFrame 形状相同的布尔值 DataFrame，其中元素在值序列中的位置为 True。
- en: '[PRE71]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Oftentimes you’ll want to match certain values with certain columns. Just make
    values a `dict` where the key is the column, and the value is a list of items
    you want to check for.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 通常你会想要将某些值与某些列匹配。只需将值设为一个 `dict`，其中键是列，值是你想要检查的项目列表。
- en: '[PRE72]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To return the DataFrame of booleans where the values are *not* in the original
    DataFrame, use the `~` operator:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回值不在原始 DataFrame 中的布尔值 DataFrame，请使用 `~` 运算符：
- en: '[PRE73]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Combine DataFrame’s `isin` with the `any()` and `all()` methods to quickly
    select subsets of your data that meet a given criteria. To select a row where
    each column meets its own criterion:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 将 DataFrame 的 `isin` 与 `any()` 和 `all()` 方法结合使用，快速选择满足给定条件的数据子集。要选择每列都满足自己条件的行：
- en: '[PRE74]  ## The [`where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where") Method and Masking'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE74]  ## [`where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where") 方法和掩码'
- en: Selecting values from a Series with a boolean vector generally returns a subset
    of the data. To guarantee that selection output has the same shape as the original
    data, you can use the `where` method in `Series` and `DataFrame`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用布尔向量从 Series 中选择值通常会返回数据的子集。为了确保选择输出具有与原始数据相同的形状，可以在 `Series` 和 `DataFrame`
    中使用 `where` 方法。
- en: 'To return only the selected rows:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 仅返回选定的行：
- en: '[PRE75]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'To return a Series of the same shape as the original:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回与原始形状相同的 Series：
- en: '[PRE76]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Selecting values from a DataFrame with a boolean criterion now also preserves
    input data shape. `where` is used under the hood as the implementation. The code
    below is equivalent to `df.where(df < 0)`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用布尔条件从 DataFrame 中选择值也会保留输入数据形状。`where` 在幕后作为实现使用。下面的代码等同于 `df.where(df <
    0)`。
- en: '[PRE77]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In addition, `where` takes an optional `other` argument for replacement of values
    where the condition is False, in the returned copy.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`where` 接受一个可选的 `other` 参数，用于在返回的副本中替换条件为 False 的值。
- en: '[PRE78]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'You may wish to set values based on some boolean criteria. This can be done
    intuitively like so:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能希望根据一些布尔条件设置值。这可以直观地这样做：
- en: '[PRE79]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '`where` returns a modified copy of the data.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`where` 返回数据的修改副本。'
- en: Note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The signature for [`DataFrame.where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where") differs from [`numpy.where()`](https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where
    "(in NumPy v1.26)"). Roughly `df1.where(m, df2)` is equivalent to `np.where(m,
    df1, df2)`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DataFrame.where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where") 的签名与 [`numpy.where()`](https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where
    "(在 NumPy v1.26 中)") 不同。大致上 `df1.where(m, df2)` 等同于 `np.where(m, df1, df2)`。'
- en: '[PRE80]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '**Alignment**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**对齐**'
- en: Furthermore, `where` aligns the input boolean condition (ndarray or DataFrame),
    such that partial selection with setting is possible. This is analogous to partial
    setting via `.loc` (but on the contents rather than the axis labels).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`where` 对齐输入的布尔条件（ndarray 或 DataFrame），使得可以进行部分选择设置。这类似于通过 `.loc` 进行部分设置（但是在内容而不是轴标签上）。
- en: '[PRE81]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Where can also accept `axis` and `level` parameters to align the input when
    performing the `where`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`where` 还可以接受 `axis` 和 `level` 参数，以在执行 `where` 时对齐输入。'
- en: '[PRE82]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This is equivalent to (but faster than) the following.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于（但比以下更快）。
- en: '[PRE83]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '`where` can accept a callable as condition and `other` arguments. The function
    must be with one argument (the calling Series or DataFrame) and that returns valid
    output as condition and `other` argument.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`where` 可以接受一个可调用的条件和 `other` 参数。该函数必须带有一个参数（调用的 Series 或 DataFrame），并返回有效的输出作为条件和
    `other` 参数。'
- en: '[PRE84]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Mask
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 掩码
- en: '[`mask()`](../reference/api/pandas.DataFrame.mask.html#pandas.DataFrame.mask
    "pandas.DataFrame.mask") is the inverse boolean operation of `where`.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mask()`](../reference/api/pandas.DataFrame.mask.html#pandas.DataFrame.mask
    "pandas.DataFrame.mask") 是 `where` 的反布尔操作。'
- en: '[PRE85]  ## Setting with enlargement conditionally using `numpy()`'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE85]  ## 使用`numpy()` 条件性扩展设置'
- en: An alternative to [`where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where") is to use [`numpy.where()`](https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where
    "(in NumPy v1.26)"). Combined with setting a new column, you can use it to enlarge
    a DataFrame where the values are determined conditionally.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 一个替代[`where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where")的方法是使用[`numpy.where()`](https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where
    "(在 NumPy v1.26 中)")。结合设置一个新列，您可以使用它来根据条件扩展DataFrame。
- en: 'Consider you have two choices to choose from in the following DataFrame. And
    you want to set a new column color to ‘green’ when the second column has ‘Z’.
    You can do the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您在以下DataFrame中有两个选择。当第二列为‘Z’时，您希望将新列颜色设置为‘green’。您可以执行以下操作：
- en: '[PRE86]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If you have multiple conditions, you can use [`numpy.select()`](https://numpy.org/doc/stable/reference/generated/numpy.select.html#numpy.select
    "(in NumPy v1.26)") to achieve that. Say corresponding to three conditions there
    are three choice of colors, with a fourth color as a fallback, you can do the
    following.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个条件，您可以使用[`numpy.select()`](https://numpy.org/doc/stable/reference/generated/numpy.select.html#numpy.select
    "(在 NumPy v1.26 中)") 来实现。假设对应于三个条件有三种颜色选择，第四种颜色作为备用，您可以执行以下操作。
- en: '[PRE87]  ## The [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Method'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE87]  ## [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") 方法'
- en: '[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    objects have a [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") method that allows selection using an expression.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    对象具有允许使用表达式进行选择的[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") 方法。'
- en: 'You can get the value of the frame where column `b` has values between the
    values of columns `a` and `c`. For example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以获取列`b`的值在列`a`和`c`的值之间的帧的值。例如：
- en: '[PRE88]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Do the same thing but fall back on a named index if there is no column with
    the name `a`.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 做同样的事情，但如果没有名为`a`的列，则回退到命名索引。
- en: '[PRE89]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'If instead you don’t want to or cannot name your index, you can use the name
    `index` in your query expression:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想或不能命名您的索引，您可以在查询表达式中使用名称`index`：
- en: '[PRE90]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If the name of your index overlaps with a column name, the column name is given
    precedence. For example,
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的索引名称与列名重叠，则列名优先。例如，
- en: '[PRE91]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'You can still use the index in a query expression by using the special identifier
    ‘index’:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 您仍然可以通过使用特殊标识符‘index’在查询表达式中使用索引：
- en: '[PRE92]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: If for some reason you have a column named `index`, then you can refer to the
    index as `ilevel_0` as well, but at this point you should consider renaming your
    columns to something less ambiguous.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因您有一个名为`index`的列，那么您也可以将索引称为`ilevel_0`，但在这一点上，您应该考虑将列重命名为不那么模糊的名称。
- en: '[`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex "pandas.MultiIndex")
    [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Syntax'
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex "pandas.MultiIndex")
    [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") 语法'
- en: 'You can also use the levels of a `DataFrame` with a [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex") as if they were columns in the frame:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以像使用列一样使用具有[`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex")的`DataFrame`的级别：
- en: '[PRE93]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'If the levels of the `MultiIndex` are unnamed, you can refer to them using
    special names:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`MultiIndex`的级别未命名，您可以使用特殊名称引用它们：
- en: '[PRE94]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The convention is `ilevel_0`, which means “index level 0” for the 0th level
    of the `index`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 约定是`ilevel_0`，表示“索引级别0”对于`index`的第0级。
- en: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Use Cases'
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") 使用案例'
- en: A use case for [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") is when you have a collection of [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") objects that have a subset of column names (or index levels/names)
    in common. You can pass the same query to both frames *without* having to specify
    which frame you’re interested in querying
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query")的一个用例是当你有一组[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame")对象，它们具有一些共同的列名（或索引级别/名称）。您可以将相同的查询传递给两个框架，*而不需要*指定您要查询的框架。
- en: '[PRE95]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Python versus pandas Syntax Comparison'
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Python与pandas语法比较'
- en: 'Full numpy-like syntax:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的类似numpy的语法：
- en: '[PRE96]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Slightly nicer by removing the parentheses (comparison operators bind tighter
    than `&` and `|`):'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过去除括号（比较运算符比`&`和`|`绑定更紧）稍微更好：
- en: '[PRE97]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Use English instead of symbols:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 使用英语而不是符号：
- en: '[PRE98]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Pretty close to how you might write it on paper:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 与您可能在纸上写的方式非常接近：
- en: '[PRE99]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: The `in` and `not in` operators
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`in`和`not in`运算符'
- en: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") also supports special use of Python’s `in` and `not
    in` comparison operators, providing a succinct syntax for calling the `isin` method
    of a `Series` or `DataFrame`.'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query")还支持Python的`in`和`not in`比较运算符的特殊用法，提供了一种简洁的语法来调用`Series`或`DataFrame`的`isin`方法。'
- en: '[PRE100]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'You can combine this with other expressions for very succinct queries:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将其与其他表达式结合使用，以获得非常简洁的查询：
- en: '[PRE101]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that `in` and `not in` are evaluated in Python, since `numexpr` has no
    equivalent of this operation. However, **only the** `in`/`not in` **expression
    itself** is evaluated in vanilla Python. For example, in the expression
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`in`和`not in`在Python中进行评估，因为`numexpr`没有此操作的等效操作。但是，**只有**`in`/`not in` **表达式本身**在普通Python中评估。例如，在表达式中
- en: '[PRE102]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '`(b + c + d)` is evaluated by `numexpr` and *then* the `in` operation is evaluated
    in plain Python. In general, any operations that can be evaluated using `numexpr`
    will be.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '`(b + c + d)`由`numexpr`计算，*然后*在普通Python中评估`in`操作。一般来说，任何可以使用`numexpr`计算的操作都将被计算。'
- en: Special use of the `==` operator with `list` objects
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与`list`对象一起使用`==`运算符的特殊用法
- en: Comparing a `list` of values to a column using `==`/`!=` works similarly to
    `in`/`not in`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`==`/`!=`将值列表与列进行比较与使用`in`/`not in`类似。
- en: '[PRE103]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Boolean operators
  id: totrans-333
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布尔运算符
- en: You can negate boolean expressions with the word `not` or the `~` operator.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`not`单词或`~`运算符否定布尔表达式。
- en: '[PRE104]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Of course, expressions can be arbitrarily complex too:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，表达式也可以任意复杂：
- en: '[PRE105]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Performance of [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query")
  id: totrans-338
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query")的性能'
- en: '`DataFrame.query()` using `numexpr` is slightly faster than Python for large
    frames.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`numexpr`的`DataFrame.query()`比Python对于大型框架稍微快一些。
- en: '![../_images/query-perf.png](../Images/5c9dcf2ea447b26d588f19d23146ea2a.png)'
  id: totrans-340
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/query-perf.png](../Images/5c9dcf2ea447b26d588f19d23146ea2a.png)'
- en: You will only see the performance benefits of using the `numexpr` engine with
    `DataFrame.query()` if your frame has more than approximately 100,000 rows.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当您的框架具有大约100,000行以上时，使用`numexpr`引擎与`DataFrame.query()`才会看到性能优势。
- en: This plot was created using a `DataFrame` with 3 columns each containing floating
    point values generated using `numpy.random.randn()`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此图是使用包含使用`numpy.random.randn()`生成的浮点值的3列的`DataFrame`创建的。
- en: '[PRE106]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Duplicate data
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重复数据
- en: 'If you want to identify and remove duplicate rows in a DataFrame, there are
    two methods that will help: `duplicated` and `drop_duplicates`. Each takes as
    an argument the columns to use to identify duplicated rows.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要识别和删除DataFrame中的重复行，有两种方法可以帮助：`duplicated`和`drop_duplicates`。每个方法都以要用于识别重复行的列作为参数。
- en: '`duplicated` returns a boolean vector whose length is the number of rows, and
    which indicates whether a row is duplicated.'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`duplicated`返回一个布尔向量，其长度为行数，指示行是否重复。'
- en: '`drop_duplicates` removes duplicate rows.'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop_duplicates`删除重复行。'
- en: By default, the first observed row of a duplicate set is considered unique,
    but each method has a `keep` parameter to specify targets to be kept.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，重复集的第一个观察行被视为唯一，但每种方法都有一个`keep`参数来指定要保留的目标。
- en: '`keep=''first''` (default): mark / drop duplicates except for the first occurrence.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keep=''first''`（默认）：标记/删除除第一次出现之外的重复项。'
- en: '`keep=''last''`: mark / drop duplicates except for the last occurrence.'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keep=''last''`：标记/删除除最后一次出现之外的重复项。'
- en: '`keep=False`: mark / drop all duplicates.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`keep=False`：标记/删除所有重复项。'
- en: '[PRE107]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Also, you can pass a list of columns to identify duplications.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以传递一个列的列表来识别重复项。
- en: '[PRE108]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: To drop duplicates by index value, use `Index.duplicated` then perform slicing.
    The same set of options are available for the `keep` parameter.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过索引值删除重复项，请使用`Index.duplicated`然后执行切片。`keep`参数也有相同的选项。
- en: '[PRE109]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '## Dictionary-like [`get()`](../reference/api/pandas.DataFrame.get.html#pandas.DataFrame.get
    "pandas.DataFrame.get") method'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '## 类似字典的 [`get()`](../reference/api/pandas.DataFrame.get.html#pandas.DataFrame.get
    "pandas.DataFrame.get") 方法'
- en: Each of Series or DataFrame have a `get` method which can return a default value.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Series 或 DataFrame 都有一个`get`方法，可以返回一个默认值。
- en: '[PRE110]  ## Looking up values by index/column labels'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE110]  ## 通过索引/列标签查找值'
- en: 'Sometimes you want to extract a set of values given a sequence of row labels
    and column labels, this can be achieved by `pandas.factorize` and NumPy indexing.
    For instance:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你想提取一组值，给定一系列行标签和列标签，这可以通过`pandas.factorize`和NumPy索引实现。例如：
- en: '[PRE111]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Formerly this could be achieved with the dedicated `DataFrame.lookup` method
    which was deprecated in version 1.2.0 and removed in version 2.0.0.  ## Index
    objects'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '以前可以使用专用的`DataFrame.lookup`方法来实现这一点，该方法在1.2.0版本中已弃用，并在2.0.0版本中移除。  ## 索引对象'
- en: The pandas [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")
    class and its subclasses can be viewed as implementing an *ordered multiset*.
    Duplicates are allowed.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index") 类及其子类可以被视为实现了*有序多重集*。允许重复。'
- en: '[`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index") also
    provides the infrastructure necessary for lookups, data alignment, and reindexing.
    The easiest way to create an [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") directly is to pass a `list` or other sequence to [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index"):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index") 还提供了查找、数据对齐和重新索引所需的基础设施。直接创建一个[`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")的最简单方法是将一个`list`或其他序列传递给[`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")：'
- en: '[PRE112]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'or using numbers:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 或使用数字：
- en: '[PRE113]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'If no dtype is given, `Index` tries to infer the dtype from the data. It is
    also possible to give an explicit dtype when instantiating an [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index"):'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有给出dtype，`Index`会尝试从数据中推断dtype。也可以在实例化[`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index")时给出显式dtype：
- en: '[PRE114]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'You can also pass a `name` to be stored in the index:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以传递一个`name`来存储在索引中：
- en: '[PRE115]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'The name, if set, will be shown in the console display:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设置了名称，将显示在控制台显示中：
- en: '[PRE116]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '### Setting metadata'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '### 设置元数据'
- en: Indexes are “mostly immutable”, but it is possible to set and change their `name`
    attribute. You can use the `rename`, `set_names` to set these attributes directly,
    and they default to returning a copy.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 索引“大部分是不可变的”，但是可以设置和更改它们的`name`属性。你可以使用`rename`、`set_names`直接设置这些属性，默认返回一个副本。
- en: See [Advanced Indexing](advanced.html#advanced) for usage of MultiIndexes.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 有关多重索引的用法，请参见[高级索引](advanced.html#advanced)。
- en: '[PRE117]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '`set_names`, `set_levels`, and `set_codes` also take an optional `level` argument'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_names`、`set_levels`和`set_codes`还接受一个可选的`level`参数'
- en: '[PRE118]  ### Set operations on Index objects'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE118]  ### 索引对象上的集合操作'
- en: The two main operations are `union` and `intersection`. Difference is provided
    via the `.difference()` method.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 两个主要操作是`union`和`intersection`。差异通过`.difference()`方法提供。
- en: '[PRE119]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Also available is the `symmetric_difference` operation, which returns elements
    that appear in either `idx1` or `idx2`, but not in both. This is equivalent to
    the Index created by `idx1.difference(idx2).union(idx2.difference(idx1))`, with
    duplicates dropped.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了`symmetric_difference`操作，返回出现在`idx1`或`idx2`中的元素，但不在两者中都出现的元素。这等同于通过`idx1.difference(idx2).union(idx2.difference(idx1))`创建的索引，重复项被删除。
- en: '[PRE120]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The resulting index from a set operation will be sorted in ascending order.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 从集合操作得到的索引将按升序排序。
- en: When performing [`Index.union()`](../reference/api/pandas.Index.union.html#pandas.Index.union
    "pandas.Index.union") between indexes with different dtypes, the indexes must
    be cast to a common dtype. Typically, though not always, this is object dtype.
    The exception is when performing a union between integer and float data. In this
    case, the integer values are converted to float
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同dtype的索引之间执行[`Index.union()`](../reference/api/pandas.Index.union.html#pandas.Index.union
    "pandas.Index.union")时，索引必须转换为公共dtype。通常，尽管不总是如此，这是对象dtype。唯一的例外是在整数和浮点数据之间执行联合时。在这种情况下，整数值将转换为浮点数
- en: '[PRE121]  ### Missing values'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE121]  ### 缺失值'
- en: Important
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: Even though `Index` can hold missing values (`NaN`), it should be avoided if
    you do not want any unexpected results. For example, some operations exclude missing
    values implicitly.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 即使`Index`可以包含缺失值（`NaN`），如果不希望出现任何意外结果，应该避免使用它。例如，一些操作隐含地排除缺失值。
- en: '`Index.fillna` fills missing values with specified scalar value.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`Index.fillna`使用指定的标量值填充缺失值。'
- en: '[PRE122]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: Set / reset index
  id: totrans-392
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置/重置索引
- en: Occasionally you will load or create a data set into a DataFrame and want to
    add an index after you’ve already done so. There are a couple of different ways.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您会将数据集加载或创建到DataFrame中，并希望在已经这样做之后添加索引。有几种不同的方法。
- en: '### Set an index'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '### 设置索引'
- en: 'DataFrame has a [`set_index()`](../reference/api/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index
    "pandas.DataFrame.set_index") method which takes a column name (for a regular
    `Index`) or a list of column names (for a `MultiIndex`). To create a new, re-indexed
    DataFrame:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: DataFrame有一个[`set_index()`](../reference/api/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index
    "pandas.DataFrame.set_index")方法，它接受一个列名（对于常规`Index`）或一个列名列表（对于`MultiIndex`）。要创建一个新的重新索引的DataFrame：
- en: '[PRE123]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The `append` keyword option allow you to keep the existing index and append
    the given columns to a MultiIndex:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`append`关键字选项允许您保留现有索引并将给定列附加到MultiIndex：'
- en: '[PRE124]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Other options in `set_index` allow you not drop the index columns.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`set_index`中的其他选项允许您不删除索引列。'
- en: '[PRE125]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Reset the index
  id: totrans-401
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重置索引
- en: As a convenience, there is a new function on DataFrame called [`reset_index()`](../reference/api/pandas.DataFrame.reset_index.html#pandas.DataFrame.reset_index
    "pandas.DataFrame.reset_index") which transfers the index values into the DataFrame’s
    columns and sets a simple integer index. This is the inverse operation of [`set_index()`](../reference/api/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index
    "pandas.DataFrame.set_index").
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一种便利，DataFrame上有一个名为[`reset_index()`](../reference/api/pandas.DataFrame.reset_index.html#pandas.DataFrame.reset_index
    "pandas.DataFrame.reset_index")的新函数，它将索引值转移到DataFrame的列中，并设置一个简单的整数索引。这是[`set_index()`](../reference/api/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index
    "pandas.DataFrame.set_index")的逆操作。
- en: '[PRE126]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: The output is more similar to a SQL table or a record array. The names for the
    columns derived from the index are the ones stored in the `names` attribute.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 输出更类似于SQL表或记录数组。从索引派生的列的名称存储在`names`属性中。
- en: 'You can use the `level` keyword to remove only a portion of the index:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`level`关键字仅删除索引的一部分：
- en: '[PRE127]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '`reset_index` takes an optional parameter `drop` which if true simply discards
    the index, instead of putting index values in the DataFrame’s columns.'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`reset_index`接受一个可选参数`drop`，如果为true，则简单丢弃索引，而不是将索引值放入DataFrame的列中。'
- en: Adding an ad hoc index
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加临时索引
- en: 'You can assign a custom index to the `index` attribute:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以为`index`属性分配自定义索引：
- en: '[PRE128]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '## Returning a view versus a copy'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '## 返回视图与副本'
- en: Warning
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '[Copy-on-Write](copy_on_write.html#copy-on-write) will become the new default
    in pandas 3.0\. This means than chained indexing will never work. As a consequence,
    the `SettingWithCopyWarning` won’t be necessary anymore. See [this section](copy_on_write.html#copy-on-write-chained-assignment)
    for more context. We recommend turning Copy-on-Write on to leverage the improvements
    with'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[Copy-on-Write](copy_on_write.html#copy-on-write)将成为pandas 3.0的新默认设置。这意味着链式索引永远不会起作用。因此，`SettingWithCopyWarning`将不再必要。有关更多上下文，请参见[此部分](copy_on_write.html#copy-on-write-chained-assignment)。我们建议打开Copy-on-Write以利用改进'
- en: '`` pd.options.mode.copy_on_write = True ``'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`` pd.options.mode.copy_on_write = True ``'
- en: even before pandas 3.0 is available.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在 pandas 3.0 可用之前。
- en: When setting values in a pandas object, care must be taken to avoid what is
    called `chained indexing`. Here is an example.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置pandas对象的值时，必须小心避免所谓的`chained indexing`。这里是一个例子。
- en: '[PRE129]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Compare these two access methods:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 比较这两种访问方法：
- en: '[PRE130]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: These both yield the same results, so which should you use? It is instructive
    to understand the order of operations on these and why method 2 (`.loc`) is much
    preferred over method 1 (chained `[]`).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '`dfmi[''one'']` selects the first level of the columns and returns a DataFrame
    that is singly-indexed. Then another Python operation `dfmi_with_one[''second'']`
    selects the series indexed by `''second''`. This is indicated by the variable
    `dfmi_with_one` because pandas sees these operations as separate events. e.g.
    separate calls to `__getitem__`, so it has to treat them as linear operations,
    they happen one after another.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this to `df.loc[:,('one','second')]` which passes a nested tuple of
    `(slice(None),('one','second'))` to a single call to `__getitem__`. This allows
    pandas to deal with this as a single entity. Furthermore this order of operations
    *can* be significantly faster, and allows one to index *both* axes if so desired.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: Why does assignment fail when using chained indexing?
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[Copy-on-Write](copy_on_write.html#copy-on-write) will become the new default
    in pandas 3.0\. This means than chained indexing will never work. As a consequence,
    the `SettingWithCopyWarning` won’t be necessary anymore. See [this section](copy_on_write.html#copy-on-write-chained-assignment)
    for more context. We recommend turning Copy-on-Write on to leverage the improvements
    with'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '`` pd.options.mode.copy_on_write = True ``'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: even before pandas 3.0 is available.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
- en: The problem in the previous section is just a performance issue. What’s up with
    the `SettingWithCopy` warning? We don’t **usually** throw warnings around when
    you do something that might cost a few extra milliseconds!
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: 'But it turns out that assigning to the product of chained indexing has inherently
    unpredictable results. To see this, think about how the Python interpreter executes
    this code:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'But this code is handled differently:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: See that `__getitem__` in there? Outside of simple cases, it’s very hard to
    predict whether it will return a view or a copy (it depends on the memory layout
    of the array, about which pandas makes no guarantees), and therefore whether the
    `__setitem__` will modify `dfmi` or a temporary object that gets thrown out immediately
    afterward. **That’s** what `SettingWithCopy` is warning you about!
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering whether we should be concerned about the `loc` property
    in the first example. But `dfmi.loc` is guaranteed to be `dfmi` itself with modified
    indexing behavior, so `dfmi.loc.__getitem__` / `dfmi.loc.__setitem__` operate
    on `dfmi` directly. Of course, `dfmi.loc.__getitem__(idx)` may be a view or a
    copy of `dfmi`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes a `SettingWithCopy` warning will arise at times when there’s no obvious
    chained indexing going on. **These** are the bugs that `SettingWithCopy` is designed
    to catch! pandas is probably trying to warn you that you’ve done this:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Yikes!
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: '### Evaluation order matters'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
- en: '[Copy-on-Write](copy_on_write.html#copy-on-write) will become the new default
    in pandas 3.0\. This means than chained indexing will never work. As a consequence,
    the `SettingWithCopyWarning` won’t be necessary anymore. See [this section](copy_on_write.html#copy-on-write-chained-assignment)
    for more context. We recommend turning Copy-on-Write on to leverage the improvements
    with'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
- en: '`` pd.options.mode.copy_on_write = True ``'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
- en: even before pandas 3.0 is available.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
- en: When you use chained indexing, the order and type of the indexing operation
    partially determine whether the result is a slice into the original object, or
    a copy of the slice.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
- en: pandas has the `SettingWithCopyWarning` because assigning to a copy of a slice
    is frequently not intentional, but a mistake caused by chained indexing returning
    a copy where a slice was expected.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like pandas to be more or less trusting about assignment to a
    chained indexing expression, you can set the [option](options.html#options) `mode.chained_assignment`
    to one of these values:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: '`''warn''`, the default, means a `SettingWithCopyWarning` is printed.'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''raise''` means pandas will raise a `SettingWithCopyError` you have to deal
    with.'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None` will suppress the warnings entirely.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: This however is operating on a copy and will not work.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: A chained assignment can also crop up in setting in a mixed dtype frame.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
- en: These setting rules apply to all of `.loc/.iloc`.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the recommended access method using `.loc` for multiple items
    (using `mask`) and a single item using a fixed index:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The following *can* work at times, but it is not guaranteed to, and therefore
    should be avoided:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Last, the subsequent example will **not** work at all, and so should be avoided:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Warning
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: 'The chained assignment warnings / exceptions are aiming to inform the user
    of a possibly invalid assignment. There may be false positives; situations where
    a chained assignment is inadvertently reported.  ## Different choices for indexing'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: Object selection has had a number of user-requested additions in order to support
    more explicit location based indexing. pandas now supports three types of multi-axis
    indexing.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '`.loc` is primarily label based, but may also be used with a boolean array.
    `.loc` will raise `KeyError` when the items are not found. Allowed inputs are:'
  id: totrans-466
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single label, e.g. `5` or `'a'` (Note that `5` is interpreted as a *label*
    of the index. This use is **not** an integer position along the index.).
  id: totrans-467
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-468
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-469
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A list or array of labels `['a', 'b', 'c']`.
  id: totrans-470
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-471
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-472
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A slice object with labels `'a':'f'` (Note that contrary to usual Python slices,
    **both** the start and the stop are included, when present in the index! See [Slicing
    with labels](#indexing-slicing-with-labels) and [Endpoints are inclusive](advanced.html#advanced-endpoints-are-inclusive).)
  id: totrans-473
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-474
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-475
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A boolean array (any `NA` values will be treated as `False`).
  id: totrans-476
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-477
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-478
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A `callable` function with one argument (the calling Series or DataFrame) and
    that returns valid output for indexing (one of the above).
  id: totrans-479
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-480
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-481
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A tuple of row (and column) indices whose elements are one of the above inputs.
  id: totrans-482
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: See more at [Selection by Label](#indexing-label).
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.iloc` is primarily integer position based (from `0` to `length-1` of the
    axis), but may also be used with a boolean array. `.iloc` will raise `IndexError`
    if a requested indexer is out-of-bounds, except *slice* indexers which allow out-of-bounds
    indexing. (this conforms with Python/NumPy *slice* semantics). Allowed inputs
    are:'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An integer e.g. `5`.
  id: totrans-485
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-486
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-487
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A list or array of integers `[4, 3, 0]`.
  id: totrans-488
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-489
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-490
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A slice object with ints `1:7`.
  id: totrans-491
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-492
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-493
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A boolean array (any `NA` values will be treated as `False`).
  id: totrans-494
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-495
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-496
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A `callable` function with one argument (the calling Series or DataFrame) and
    that returns valid output for indexing (one of the above).
  id: totrans-497
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-498
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-499
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A tuple of row (and column) indices whose elements are one of the above inputs.
  id: totrans-500
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: See more at [Selection by Position](#indexing-integer), [Advanced Indexing](advanced.html#advanced)
    and [Advanced Hierarchical](advanced.html#advanced-advanced-hierarchical).
  id: totrans-501
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.loc`, `.iloc`, and also `[]` indexing can accept a `callable` as indexer.
    See more at [Selection By Callable](#indexing-callable).'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-503
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Destructuring tuple keys into row (and column) indexes occurs *before* callables
    are applied, so you cannot return a tuple from a callable to index both rows and
    columns.
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Getting values from an object with multi-axes selection uses the following notation
    (using `.loc` as an example, but the following applies to `.iloc` as well). Any
    of the axes accessors may be the null slice `:`. Axes left out of the specification
    are assumed to be `:`, e.g. `p.loc['a']` is equivalent to `p.loc['a', :]`.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Type | Indexers |'
  id: totrans-506
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
- en: '| Series | `s.loc[indexer]` |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
- en: '| DataFrame | `df.loc[row_indexer,column_indexer]` |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
- en: '## Basics'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned when introducing the data structures in the [last section](basics.html#basics),
    the primary function of indexing with `[]` (a.k.a. `__getitem__` for those familiar
    with implementing class behavior in Python) is selecting out lower-dimensional
    slices. The following table shows return type values when indexing pandas objects
    with `[]`:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Type | Selection | Return Value Type |'
  id: totrans-512
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-513
  prefs: []
  type: TYPE_TB
- en: '| Series | `series[label]` | scalar value |'
  id: totrans-514
  prefs: []
  type: TYPE_TB
- en: '| DataFrame | `frame[colname]` | `Series` corresponding to colname |'
  id: totrans-515
  prefs: []
  type: TYPE_TB
- en: 'Here we construct a simple time series data set to use for illustrating the
    indexing functionality:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Note
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: None of the indexing functionality is time series specific unless specifically
    stated.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, as per above, we have the most basic indexing using `[]`:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'You can pass a list of columns to `[]` to select columns in that order. If
    a column is not contained in the DataFrame, an exception will be raised. Multiple
    columns can also be set in this manner:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: You may find this useful for applying a transform (in-place) to a subset of
    the columns.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: pandas aligns all AXES when setting `Series` and `DataFrame` from `.loc`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: This will **not** modify `df` because the column alignment is before value assignment.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这不会修改`df`，因为在赋值之前列对齐。
- en: '[PRE143]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The correct way to swap column values is by using raw values:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 交换列值的正确方法是使用原始值：
- en: '[PRE144]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: However, pandas does not align AXES when setting `Series` and `DataFrame` from
    `.iloc` because `.iloc` operates by position.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当使用`.iloc`从`Series`和`DataFrame`设置时，pandas不会对齐轴，因为`.iloc`是按位置操作的。
- en: This will modify `df` because the column alignment is not done before value
    assignment.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 这将修改`df`，因为在赋值之前列对齐。
- en: '[PRE145]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Attribute access
  id: totrans-534
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性访问
- en: 'You may access an index on a `Series` or column on a `DataFrame` directly as
    an attribute:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接将`Series`上的索引或`DataFrame`上的列作为属性访问：
- en: '[PRE146]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Warning
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: You can use this access only if the index element is a valid Python identifier,
    e.g. `s.1` is not allowed. See [here for an explanation of valid identifiers](https://docs.python.org/3/reference/lexical_analysis.html#identifiers).
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有当索引元素是有效的Python标识符时，才能使用此访问，例如，`s.1`是不允许的。请参阅[此处以了解有效标识符的解释](https://docs.python.org/3/reference/lexical_analysis.html#identifiers)。
- en: The attribute will not be available if it conflicts with an existing method
    name, e.g. `s.min` is not allowed, but `s['min']` is possible.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果属性与现有方法名冲突，则该属性将不可用，例如，`s.min`是不允许的，但`s['min']`是可能的。
- en: 'Similarly, the attribute will not be available if it conflicts with any of
    the following list: `index`, `major_axis`, `minor_axis`, `items`.'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，如果属性与以下列表中的任何内容冲突，则该属性将不可用：`index`、`major_axis`、`minor_axis`、`items`。
- en: In any of these cases, standard indexing will still work, e.g. `s['1']`, `s['min']`,
    and `s['index']` will access the corresponding element or column.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在任何这些情况下，标准索引仍将起作用，例如，`s['1']`、`s['min']`和`s['index']`将访问相应的元素或列。
- en: If you are using the IPython environment, you may also use tab-completion to
    see these accessible attributes.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用IPython环境，还可以使用制表符补全来查看这些可访问的属性。
- en: 'You can also assign a `dict` to a row of a `DataFrame`:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将`dict`分配给`DataFrame`的一行：
- en: '[PRE149]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'You can use attribute access to modify an existing element of a Series or column
    of a DataFrame, but be careful; if you try to use attribute access to create a
    new column, it creates a new attribute rather than a new column and will this
    raise a `UserWarning`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用属性访问来修改Series或DataFrame的现有元素，但要小心；如果尝试使用属性访问来创建新列，则会创建新属性而不是新列，并将引发`UserWarning`：
- en: '[PRE150]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Slicing ranges
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片范围
- en: The most robust and consistent way of slicing ranges along arbitrary axes is
    described in the [Selection by Position](#indexing-integer) section detailing
    the `.iloc` method. For now, we explain the semantics of slicing using the `[]`
    operator.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着任意轴切片范围的最稳健和一致的方法在[按位置选择](#indexing-integer)部分详细描述了`.iloc`方法。现在，我们解释使用`[]`运算符的切片语义。
- en: 'With Series, the syntax works exactly as with an ndarray, returning a slice
    of the values and the corresponding labels:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Series，语法与ndarray完全相同，返回值的切片和相应的标签：
- en: '[PRE151]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Note that setting works as well:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，设置也有效：
- en: '[PRE152]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: With DataFrame, slicing inside of `[]` **slices the rows**. This is provided
    largely as a convenience since it is such a common operation.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 对于DataFrame，在`[]`内部切片**切片行**。这主要是为了方便，因为这是一个常见操作。
- en: '[PRE153]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '## Selection by label'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '## 按标签选择'
- en: Warning
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Whether a copy or a reference is returned for a setting operation, may depend
    on the context. This is sometimes called `chained assignment` and should be avoided.
    See [Returning a View versus Copy](#indexing-view-versus-copy).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置操作中返回副本还是引用可能取决于上下文。有时这被称为`chained assignment`，应该避免。请参阅[返回视图与副本](#indexing-view-versus-copy)。
- en: Warning
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '`.loc` is strict when you present slicers that are not compatible (or convertible)
    with the index type. For example using integers in a `DatetimeIndex`. These will
    raise a `TypeError`.'
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当您提供与索引类型不兼容（或可转换）的切片器时，`.loc`是严格的。例如，在`DatetimeIndex`中使用整数。这将引发`TypeError`。
- en: ''
  id: totrans-562
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE154]'
- en: String likes in slicing *can* be convertible to the type of the index and lead
    to natural slicing.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 切片中的字符串*可以*转换为索引类型，并导致自然切片。
- en: '[PRE155]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: pandas provides a suite of methods in order to have **purely label based indexing**.
    This is a strict inclusion based protocol. Every label asked for must be in the
    index, or a `KeyError` will be raised. When slicing, both the start bound **AND**
    the stop bound are *included*, if present in the index. Integers are valid labels,
    but they refer to the label **and not the position**.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: pandas提供了一套方法，以实现**纯粹基于标签的索引**。这是一种严格的包含协议。每个请求的标签必须在索引中，否则将引发`KeyError`。在切片时，如果存在于索引中，则起始边界**和**停止边界都将*包括*。整数是有效标签，但它们指的是标签**而不是位置**。
- en: 'The `.loc` attribute is the primary access method. The following are valid
    inputs:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`.loc`属性是主要访问方法。以下是有效输入：'
- en: A single label, e.g. `5` or `'a'` (Note that `5` is interpreted as a *label*
    of the index. This use is **not** an integer position along the index.).
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单个标签，例如`5`或`'a'`（请注意，`5`被解释为索引的*标签*。此用法**不**是索引上的整数位置）。
- en: A list or array of labels `['a', 'b', 'c']`.
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标签列表或数组`['a', 'b', 'c']`。
- en: A slice object with labels `'a':'f'` (Note that contrary to usual Python slices,
    **both** the start and the stop are included, when present in the index! See [Slicing
    with labels](#indexing-slicing-with-labels).
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有标签`'a':'f'`的切片对象（请注意，与通常的Python切片相反，**当**存在于索引中时，起始和停止都包括在内！请参见[使用标签切片](#indexing-slicing-with-labels)）。
- en: A boolean array.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔数组。
- en: A `callable`, see [Selection By Callable](#indexing-callable).
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`callable`，参见[通过可调用进行选择](#indexing-callable)。'
- en: '[PRE156]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Note that setting works as well:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，设置也有效：
- en: '[PRE157]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'With a DataFrame:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DataFrame：
- en: '[PRE158]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Accessing via label slices:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签切片访问：
- en: '[PRE159]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'For getting a cross section using a label (equivalent to `df.xs(''a'')`):'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 通过标签获取交叉部分（相当于`df.xs('a')`）：
- en: '[PRE160]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'For getting values with a boolean array:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 通过布尔数组获取值：
- en: '[PRE161]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'NA values in a boolean array propagate as `False`:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔数组中的NA值会传播为`False`：
- en: '[PRE162]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'For getting a value explicitly:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 明确获取一个值：
- en: '[PRE163]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '### Slicing with labels'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用标签切片'
- en: 'When using `.loc` with slices, if both the start and the stop labels are present
    in the index, then elements *located* between the two (including them) are returned:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片时，如果索引中同时存在起始和停止标签，则返回介于两者之间（包括它们）的元素：
- en: '[PRE164]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'If at least one of the two is absent, but the index is sorted, and can be compared
    against start and stop labels, then slicing will still work as expected, by selecting
    labels which *rank* between the two:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两者中至少有一个缺失，但索引已排序，并且可以与起始和停止标签进行比较，则切片仍将按预期工作，通过选择介于两者之间的标签：
- en: '[PRE165]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: However, if at least one of the two is absent *and* the index is not sorted,
    an error will be raised (since doing otherwise would be computationally expensive,
    as well as potentially ambiguous for mixed type indexes). For instance, in the
    above example, `s.loc[1:6]` would raise `KeyError`.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果两者中至少有一个缺失*且*索引未排序，则会引发错误（因为否则会在计算上昂贵，以及对于混合类型索引可能会产生歧义）。例如，在上面的示例中，`s.loc[1:6]`将引发`KeyError`。
- en: For the rationale behind this behavior, see [Endpoints are inclusive](advanced.html#advanced-endpoints-are-inclusive).
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此行为背后的原理，请参见[端点是包容的](advanced.html#advanced-endpoints-are-inclusive)。
- en: '[PRE166]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Also, if the index has duplicate labels *and* either the start or the stop label
    is duplicated, an error will be raised. For instance, in the above example, `s.loc[2:5]`
    would raise a `KeyError`.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果索引具有重复标签*且*起始或停止标签重复，则会引发错误。例如，在上面的示例中，`s.loc[2:5]`将引发`KeyError`。
- en: 'For more information about duplicate labels, see [Duplicate Labels](duplicates.html#duplicates).  ###
    Slicing with labels'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 有关重复标签的更多信息，请参见[重复标签](duplicates.html#duplicates)。### 使用标签切片
- en: 'When using `.loc` with slices, if both the start and the stop labels are present
    in the index, then elements *located* between the two (including them) are returned:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 使用切片时，如果索引中同时存在起始和停止标签，则返回介于两者之间（包括它们）的元素：
- en: '[PRE167]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'If at least one of the two is absent, but the index is sorted, and can be compared
    against start and stop labels, then slicing will still work as expected, by selecting
    labels which *rank* between the two:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两者中至少有一个缺失，但索引已排序，并且可以与起始和停止标签进行比较，则切片仍将按预期工作，通过选择介于两者之间的标签：
- en: '[PRE168]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: However, if at least one of the two is absent *and* the index is not sorted,
    an error will be raised (since doing otherwise would be computationally expensive,
    as well as potentially ambiguous for mixed type indexes). For instance, in the
    above example, `s.loc[1:6]` would raise `KeyError`.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: For the rationale behind this behavior, see [Endpoints are inclusive](advanced.html#advanced-endpoints-are-inclusive).
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: Also, if the index has duplicate labels *and* either the start or the stop label
    is duplicated, an error will be raised. For instance, in the above example, `s.loc[2:5]`
    would raise a `KeyError`.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
- en: For more information about duplicate labels, see [Duplicate Labels](duplicates.html#duplicates).
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
- en: '## Selection by position'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: Whether a copy or a reference is returned for a setting operation, may depend
    on the context. This is sometimes called `chained assignment` and should be avoided.
    See [Returning a View versus Copy](#indexing-view-versus-copy).
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
- en: pandas provides a suite of methods in order to get **purely integer based indexing**.
    The semantics follow closely Python and NumPy slicing. These are `0-based` indexing.
    When slicing, the start bound is *included*, while the upper bound is *excluded*.
    Trying to use a non-integer, even a **valid** label will raise an `IndexError`.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.iloc` attribute is the primary access method. The following are valid
    inputs:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
- en: An integer e.g. `5`.
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list or array of integers `[4, 3, 0]`.
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A slice object with ints `1:7`.
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A boolean array.
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `callable`, see [Selection By Callable](#indexing-callable).
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A tuple of row (and column) indexes, whose elements are one of the above types.
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Note that setting works as well:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'With a DataFrame:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Select via integer slicing:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'Select via integer list:'
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'For getting a cross section using an integer position (equiv to `df.xs(1)`):'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Out of range slice indexes are handled gracefully just as in Python/NumPy.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Note that using slices that go out of bounds can result in an empty axis (e.g.
    an empty DataFrame being returned).
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  id: totrans-635
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: A single indexer that is out of bounds will raise an `IndexError`. A list of
    indexers where any element is out of bounds will raise an `IndexError`.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '## Selection by callable'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
- en: '`.loc`, `.iloc`, and also `[]` indexing can accept a `callable` as indexer.
    The `callable` must be a function with one argument (the calling Series or DataFrame)
    that returns valid output for indexing.'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
- en: For `.iloc` indexing, returning a tuple from the callable is not supported,
    since tuple destructuring for row and column indexes occurs *before* applying
    callables.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: You can use callable indexing in `Series`.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Using these methods / indexers, you can chain data selection operations without
    using a temporary variable.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '## Combining positional and label-based indexing'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to get the 0th and the 2nd elements from the index in the ‘A’ column,
    you can do:'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: This can also be expressed using `.iloc`, by explicitly getting locations on
    the indexers, and using *positional* indexing to select things.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'For getting *multiple* indexers, using `.get_indexer`:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Reindexing
  id: totrans-655
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idiomatic way to achieve selecting potentially not-found elements is via
    `.reindex()`. See also the section on [reindexing](basics.html#basics-reindexing).
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Alternatively, if you want to select only *valid* keys, the following is idiomatic
    and efficient; it is guaranteed to preserve the dtype of the selection.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'Having a duplicated index will raise for a `.reindex()`:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-661
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: Generally, you can intersect the desired labels with the current axis, and then
    reindex.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: However, this would *still* raise if your resulting index is duplicated.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Reindexing
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The idiomatic way to achieve selecting potentially not-found elements is via
    `.reindex()`. See also the section on [reindexing](basics.html#basics-reindexing).
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Alternatively, if you want to select only *valid* keys, the following is idiomatic
    and efficient; it is guaranteed to preserve the dtype of the selection.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Having a duplicated index will raise for a `.reindex()`:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Generally, you can intersect the desired labels with the current axis, and then
    reindex.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: However, this would *still* raise if your resulting index is duplicated.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '## Selecting random samples'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
- en: A random selection of rows or columns from a Series or DataFrame with the [`sample()`](../reference/api/pandas.DataFrame.sample.html#pandas.DataFrame.sample
    "pandas.DataFrame.sample") method. The method will sample rows by default, and
    accepts a specific number of rows/columns to return, or a fraction of rows.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'By default, `sample` will return each row at most once, but one can also sample
    with replacement using the `replace` option:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'By default, each row has an equal probability of being selected, but if you
    want rows to have different probabilities, you can pass the `sample` function
    sampling weights as `weights`. These weights can be a list, a NumPy array, or
    a Series, but they must be of the same length as the object you are sampling.
    Missing values will be treated as a weight of zero, and inf values are not allowed.
    If weights do not sum to 1, they will be re-normalized by dividing all weights
    by the sum of the weights. For example:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: When applied to a DataFrame, you can use a column of the DataFrame as sampling
    weights (provided you are sampling rows and not columns) by simply passing the
    name of the column as a string.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '`sample` also allows users to sample columns instead of rows using the `axis`
    argument.'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: Finally, one can also set a seed for `sample`’s random number generator using
    the `random_state` argument, which will accept either an integer (as a seed) or
    a NumPy RandomState object.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Setting with enlargement
  id: totrans-690
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `.loc/[]` operations can perform enlargement when setting a non-existent
    key for that axis.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: In the `Series` case this is effectively an appending operation.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: A `DataFrame` can be enlarged on either axis via `.loc`.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: This is like an `append` operation on the `DataFrame`.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '## Fast scalar value getting and setting'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
- en: Since indexing with `[]` must handle a lot of cases (single-label access, slicing,
    boolean indexing, etc.), it has a bit of overhead in order to figure out what
    you’re asking for. If you only want to access a scalar value, the fastest way
    is to use the `at` and `iat` methods, which are implemented on all of the data
    structures.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to `loc`, `at` provides **label** based scalar lookups, while, `iat`
    provides **integer** based lookups analogously to `iloc`
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: You can also set using these same indexers.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '`at` may enlarge the object in-place as above if the indexer is missing.'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: Boolean indexing
  id: totrans-706
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another common operation is the use of boolean vectors to filter the data.
    The operators are: `|` for `or`, `&` for `and`, and `~` for `not`. These **must**
    be grouped by using parentheses, since by default Python will evaluate an expression
    such as `df[''A''] > 2 & df[''B''] < 3` as `df[''A''] > (2 & df[''B'']) < 3`,
    while the desired evaluation order is `(df[''A''] > 2) & (df[''B''] < 3)`.'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a boolean vector to index a Series works exactly as in a NumPy ndarray:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'You may select rows from a DataFrame using a boolean vector the same length
    as the DataFrame’s index (for example, something derived from one of the columns
    of the DataFrame):'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: 'List comprehensions and the `map` method of Series can also be used to produce
    more complex criteria:'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-713
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: With the choice methods [Selection by Label](#indexing-label), [Selection by
    Position](#indexing-integer), and [Advanced Indexing](advanced.html#advanced)
    you may select along more than one axis using boolean vectors combined with other
    indexing expressions.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: Warning
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
- en: '`iloc` supports two kinds of boolean indexing. If the indexer is a boolean
    `Series`, an error will be raised. For instance, in the following example, `df.iloc[s.values,
    1]` is ok. The boolean indexer is an array. But `df.iloc[s, 1]` would raise `ValueError`.'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '## Indexing with isin'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the [`isin()`](../reference/api/pandas.Series.isin.html#pandas.Series.isin
    "pandas.Series.isin") method of `Series`, which returns a boolean vector that
    is true wherever the `Series` elements exist in the passed list. This allows you
    to select rows where one or more columns have values you want:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'The same method is available for `Index` objects and is useful for the cases
    when you don’t know which of the sought labels are in fact present:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'In addition to that, `MultiIndex` allows selecting a separate level to use
    in the membership check:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: DataFrame also has an [`isin()`](../reference/api/pandas.DataFrame.isin.html#pandas.DataFrame.isin
    "pandas.DataFrame.isin") method. When calling `isin`, pass a set of values as
    either an array or dict. If values is an array, `isin` returns a DataFrame of
    booleans that is the same shape as the original DataFrame, with True wherever
    the element is in the sequence of values.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: Oftentimes you’ll want to match certain values with certain columns. Just make
    values a `dict` where the key is the column, and the value is a list of items
    you want to check for.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'To return the DataFrame of booleans where the values are *not* in the original
    DataFrame, use the `~` operator:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'Combine DataFrame’s `isin` with the `any()` and `all()` methods to quickly
    select subsets of your data that meet a given criteria. To select a row where
    each column meets its own criterion:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '## The [`where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where") Method and Masking'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: Selecting values from a Series with a boolean vector generally returns a subset
    of the data. To guarantee that selection output has the same shape as the original
    data, you can use the `where` method in `Series` and `DataFrame`.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
- en: 'To return only the selected rows:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: 'To return a Series of the same shape as the original:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: Selecting values from a DataFrame with a boolean criterion now also preserves
    input data shape. `where` is used under the hood as the implementation. The code
    below is equivalent to `df.where(df < 0)`.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: In addition, `where` takes an optional `other` argument for replacement of values
    where the condition is False, in the returned copy.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'You may wish to set values based on some boolean criteria. This can be done
    intuitively like so:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-745
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '`where` returns a modified copy of the data.'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: The signature for [`DataFrame.where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where") differs from [`numpy.where()`](https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where
    "(in NumPy v1.26)"). Roughly `df1.where(m, df2)` is equivalent to `np.where(m,
    df1, df2)`.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '**Alignment**'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, `where` aligns the input boolean condition (ndarray or DataFrame),
    such that partial selection with setting is possible. This is analogous to partial
    setting via `.loc` (but on the contents rather than the axis labels).
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: Where can also accept `axis` and `level` parameters to align the input when
    performing the `where`.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: This is equivalent to (but faster than) the following.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '`where` can accept a callable as condition and `other` arguments. The function
    must be with one argument (the calling Series or DataFrame) and that returns valid
    output as condition and `other` argument.'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: Mask
  id: totrans-759
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`mask()`](../reference/api/pandas.DataFrame.mask.html#pandas.DataFrame.mask
    "pandas.DataFrame.mask") is the inverse boolean operation of `where`.'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: Mask
  id: totrans-762
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`mask()`](../reference/api/pandas.DataFrame.mask.html#pandas.DataFrame.mask
    "pandas.DataFrame.mask") is the inverse boolean operation of `where`.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-764
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '## Setting with enlargement conditionally using `numpy()`'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to [`where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where") is to use [`numpy.where()`](https://numpy.org/doc/stable/reference/generated/numpy.where.html#numpy.where
    "(in NumPy v1.26)"). Combined with setting a new column, you can use it to enlarge
    a DataFrame where the values are determined conditionally.
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider you have two choices to choose from in the following DataFrame. And
    you want to set a new column color to ‘green’ when the second column has ‘Z’.
    You can do the following:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: If you have multiple conditions, you can use [`numpy.select()`](https://numpy.org/doc/stable/reference/generated/numpy.select.html#numpy.select
    "(in NumPy v1.26)") to achieve that. Say corresponding to three conditions there
    are three choice of colors, with a fourth color as a fallback, you can do the
    following.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '## The [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Method'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    objects have a [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") method that allows selection using an expression.'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: 'You can get the value of the frame where column `b` has values between the
    values of columns `a` and `c`. For example:'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: Do the same thing but fall back on a named index if there is no column with
    the name `a`.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'If instead you don’t want to or cannot name your index, you can use the name
    `index` in your query expression:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-778
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: Note
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: If the name of your index overlaps with a column name, the column name is given
    precedence. For example,
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-781
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'You can still use the index in a query expression by using the special identifier
    ‘index’:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: If for some reason you have a column named `index`, then you can refer to the
    index as `ilevel_0` as well, but at this point you should consider renaming your
    columns to something less ambiguous.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
- en: '[`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex "pandas.MultiIndex")
    [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Syntax'
  id: totrans-785
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use the levels of a `DataFrame` with a [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex") as if they were columns in the frame:'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-787
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'If the levels of the `MultiIndex` are unnamed, you can refer to them using
    special names:'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-789
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: The convention is `ilevel_0`, which means “index level 0” for the 0th level
    of the `index`.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
- en: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Use Cases'
  id: totrans-791
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A use case for [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") is when you have a collection of [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") objects that have a subset of column names (or index levels/names)
    in common. You can pass the same query to both frames *without* having to specify
    which frame you’re interested in querying
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Python versus pandas Syntax Comparison'
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Full numpy-like syntax:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'Slightly nicer by removing the parentheses (comparison operators bind tighter
    than `&` and `|`):'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: 'Use English instead of symbols:'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-800
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'Pretty close to how you might write it on paper:'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-802
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: The `in` and `not in` operators
  id: totrans-803
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") also supports special use of Python’s `in` and `not
    in` comparison operators, providing a succinct syntax for calling the `isin` method
    of a `Series` or `DataFrame`.'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'You can combine this with other expressions for very succinct queries:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Note
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: Note that `in` and `not in` are evaluated in Python, since `numexpr` has no
    equivalent of this operation. However, **only the** `in`/`not in` **expression
    itself** is evaluated in vanilla Python. For example, in the expression
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '`(b + c + d)` is evaluated by `numexpr` and *then* the `in` operation is evaluated
    in plain Python. In general, any operations that can be evaluated using `numexpr`
    will be.'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
- en: Special use of the `==` operator with `list` objects
  id: totrans-812
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparing a `list` of values to a column using `==`/`!=` works similarly to
    `in`/`not in`.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-814
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: Boolean operators
  id: totrans-815
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can negate boolean expressions with the word `not` or the `~` operator.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'Of course, expressions can be arbitrarily complex too:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: Performance of [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query")
  id: totrans-820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`DataFrame.query()` using `numexpr` is slightly faster than Python for large
    frames.'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/query-perf.png](../Images/5c9dcf2ea447b26d588f19d23146ea2a.png)'
  id: totrans-822
  prefs: []
  type: TYPE_IMG
- en: You will only see the performance benefits of using the `numexpr` engine with
    `DataFrame.query()` if your frame has more than approximately 100,000 rows.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: This plot was created using a `DataFrame` with 3 columns each containing floating
    point values generated using `numpy.random.randn()`.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex "pandas.MultiIndex")
    [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Syntax'
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can also use the levels of a `DataFrame` with a [`MultiIndex`](../reference/api/pandas.MultiIndex.html#pandas.MultiIndex
    "pandas.MultiIndex") as if they were columns in the frame:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'If the levels of the `MultiIndex` are unnamed, you can refer to them using
    special names:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: The convention is `ilevel_0`, which means “index level 0” for the 0th level
    of the `index`.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
- en: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Use Cases'
  id: totrans-832
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A use case for [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") is when you have a collection of [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") objects that have a subset of column names (or index levels/names)
    in common. You can pass the same query to both frames *without* having to specify
    which frame you’re interested in querying
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") Python versus pandas Syntax Comparison'
  id: totrans-835
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Full numpy-like syntax:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Slightly nicer by removing the parentheses (comparison operators bind tighter
    than `&` and `|`):'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: 'Use English instead of symbols:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'Pretty close to how you might write it on paper:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: The `in` and `not in` operators
  id: totrans-844
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query") also supports special use of Python’s `in` and `not
    in` comparison operators, providing a succinct syntax for calling the `isin` method
    of a `Series` or `DataFrame`.'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'You can combine this with other expressions for very succinct queries:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Note
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: Note that `in` and `not in` are evaluated in Python, since `numexpr` has no
    equivalent of this operation. However, **only the** `in`/`not in` **expression
    itself** is evaluated in vanilla Python. For example, in the expression
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '`(b + c + d)` is evaluated by `numexpr` and *then* the `in` operation is evaluated
    in plain Python. In general, any operations that can be evaluated using `numexpr`
    will be.'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
- en: Special use of the `==` operator with `list` objects
  id: totrans-853
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparing a `list` of values to a column using `==`/`!=` works similarly to
    `in`/`not in`.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-855
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Boolean operators
  id: totrans-856
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can negate boolean expressions with the word `not` or the `~` operator.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: 'Of course, expressions can be arbitrarily complex too:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: Performance of [`query()`](../reference/api/pandas.DataFrame.query.html#pandas.DataFrame.query
    "pandas.DataFrame.query")
  id: totrans-861
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`DataFrame.query()` using `numexpr` is slightly faster than Python for large
    frames.'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
- en: '![../_images/query-perf.png](../Images/5c9dcf2ea447b26d588f19d23146ea2a.png)'
  id: totrans-863
  prefs: []
  type: TYPE_IMG
- en: You will only see the performance benefits of using the `numexpr` engine with
    `DataFrame.query()` if your frame has more than approximately 100,000 rows.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
- en: This plot was created using a `DataFrame` with 3 columns each containing floating
    point values generated using `numpy.random.randn()`.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: Duplicate data
  id: totrans-867
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to identify and remove duplicate rows in a DataFrame, there are
    two methods that will help: `duplicated` and `drop_duplicates`. Each takes as
    an argument the columns to use to identify duplicated rows.'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
- en: '`duplicated` returns a boolean vector whose length is the number of rows, and
    which indicates whether a row is duplicated.'
  id: totrans-869
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drop_duplicates` removes duplicate rows.'
  id: totrans-870
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, the first observed row of a duplicate set is considered unique,
    but each method has a `keep` parameter to specify targets to be kept.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: '`keep=''first''` (default): mark / drop duplicates except for the first occurrence.'
  id: totrans-872
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keep=''last''`: mark / drop duplicates except for the last occurrence.'
  id: totrans-873
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`keep=False`: mark / drop all duplicates.'
  id: totrans-874
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: Also, you can pass a list of columns to identify duplications.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: To drop duplicates by index value, use `Index.duplicated` then perform slicing.
    The same set of options are available for the `keep` parameter.
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '## Dictionary-like [`get()`](../reference/api/pandas.DataFrame.get.html#pandas.DataFrame.get
    "pandas.DataFrame.get") method'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: Each of Series or DataFrame have a `get` method which can return a default value.
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '## Looking up values by index/column labels'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you want to extract a set of values given a sequence of row labels
    and column labels, this can be achieved by `pandas.factorize` and NumPy indexing.
    For instance:'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-885
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: Formerly this could be achieved with the dedicated `DataFrame.lookup` method
    which was deprecated in version 1.2.0 and removed in version 2.0.0.
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
- en: '## Index objects'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: The pandas [`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index")
    class and its subclasses can be viewed as implementing an *ordered multiset*.
    Duplicates are allowed.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
- en: '[`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index") also
    provides the infrastructure necessary for lookups, data alignment, and reindexing.
    The easiest way to create an [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") directly is to pass a `list` or other sequence to [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index"):'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'or using numbers:'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-892
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'If no dtype is given, `Index` tries to infer the dtype from the data. It is
    also possible to give an explicit dtype when instantiating an [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index"):'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'You can also pass a `name` to be stored in the index:'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: 'The name, if set, will be shown in the console display:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '### Setting metadata'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: Indexes are “mostly immutable”, but it is possible to set and change their `name`
    attribute. You can use the `rename`, `set_names` to set these attributes directly,
    and they default to returning a copy.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: See [Advanced Indexing](advanced.html#advanced) for usage of MultiIndexes.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-902
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '`set_names`, `set_levels`, and `set_codes` also take an optional `level` argument'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]  ### Set operations on Index objects'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: The two main operations are `union` and `intersection`. Difference is provided
    via the `.difference()` method.
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: Also available is the `symmetric_difference` operation, which returns elements
    that appear in either `idx1` or `idx2`, but not in both. This is equivalent to
    the Index created by `idx1.difference(idx2).union(idx2.difference(idx1))`, with
    duplicates dropped.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Note
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: The resulting index from a set operation will be sorted in ascending order.
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
- en: When performing [`Index.union()`](../reference/api/pandas.Index.union.html#pandas.Index.union
    "pandas.Index.union") between indexes with different dtypes, the indexes must
    be cast to a common dtype. Typically, though not always, this is object dtype.
    The exception is when performing a union between integer and float data. In this
    case, the integer values are converted to float
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]  ### Missing values'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
- en: Important
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: Even though `Index` can hold missing values (`NaN`), it should be avoided if
    you do not want any unexpected results. For example, some operations exclude missing
    values implicitly.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
- en: '`Index.fillna` fills missing values with specified scalar value.'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]  ### Setting metadata'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
- en: Indexes are “mostly immutable”, but it is possible to set and change their `name`
    attribute. You can use the `rename`, `set_names` to set these attributes directly,
    and they default to returning a copy.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: See [Advanced Indexing](advanced.html#advanced) for usage of MultiIndexes.
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '`set_names`, `set_levels`, and `set_codes` also take an optional `level` argument'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '### Set operations on Index objects'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: The two main operations are `union` and `intersection`. Difference is provided
    via the `.difference()` method.
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: Also available is the `symmetric_difference` operation, which returns elements
    that appear in either `idx1` or `idx2`, but not in both. This is equivalent to
    the Index created by `idx1.difference(idx2).union(idx2.difference(idx1))`, with
    duplicates dropped.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: Note
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
- en: The resulting index from a set operation will be sorted in ascending order.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: When performing [`Index.union()`](../reference/api/pandas.Index.union.html#pandas.Index.union
    "pandas.Index.union") between indexes with different dtypes, the indexes must
    be cast to a common dtype. Typically, though not always, this is object dtype.
    The exception is when performing a union between integer and float data. In this
    case, the integer values are converted to float
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '### Missing values'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
- en: Important
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: Even though `Index` can hold missing values (`NaN`), it should be avoided if
    you do not want any unexpected results. For example, some operations exclude missing
    values implicitly.
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
- en: '`Index.fillna` fills missing values with specified scalar value.'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: Set / reset index
  id: totrans-936
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Occasionally you will load or create a data set into a DataFrame and want to
    add an index after you’ve already done so. There are a couple of different ways.
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
- en: '### Set an index'
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
- en: 'DataFrame has a [`set_index()`](../reference/api/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index
    "pandas.DataFrame.set_index") method which takes a column name (for a regular
    `Index`) or a list of column names (for a `MultiIndex`). To create a new, re-indexed
    DataFrame:'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'The `append` keyword option allow you to keep the existing index and append
    the given columns to a MultiIndex:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: Other options in `set_index` allow you not drop the index columns.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-944
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: Reset the index
  id: totrans-945
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a convenience, there is a new function on DataFrame called [`reset_index()`](../reference/api/pandas.DataFrame.reset_index.html#pandas.DataFrame.reset_index
    "pandas.DataFrame.reset_index") which transfers the index values into the DataFrame’s
    columns and sets a simple integer index. This is the inverse operation of [`set_index()`](../reference/api/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index
    "pandas.DataFrame.set_index").
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: The output is more similar to a SQL table or a record array. The names for the
    columns derived from the index are the ones stored in the `names` attribute.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `level` keyword to remove only a portion of the index:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '`reset_index` takes an optional parameter `drop` which if true simply discards
    the index, instead of putting index values in the DataFrame’s columns.'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
- en: Adding an ad hoc index
  id: totrans-952
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can assign a custom index to the `index` attribute:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '### Set an index'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
- en: 'DataFrame has a [`set_index()`](../reference/api/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index
    "pandas.DataFrame.set_index") method which takes a column name (for a regular
    `Index`) or a list of column names (for a `MultiIndex`). To create a new, re-indexed
    DataFrame:'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  id: totrans-957
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'The `append` keyword option allow you to keep the existing index and append
    the given columns to a MultiIndex:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: Other options in `set_index` allow you not drop the index columns.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  id: totrans-961
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: Reset the index
  id: totrans-962
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a convenience, there is a new function on DataFrame called [`reset_index()`](../reference/api/pandas.DataFrame.reset_index.html#pandas.DataFrame.reset_index
    "pandas.DataFrame.reset_index") which transfers the index values into the DataFrame’s
    columns and sets a simple integer index. This is the inverse operation of [`set_index()`](../reference/api/pandas.DataFrame.set_index.html#pandas.DataFrame.set_index
    "pandas.DataFrame.set_index").
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  id: totrans-964
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: The output is more similar to a SQL table or a record array. The names for the
    columns derived from the index are the ones stored in the `names` attribute.
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `level` keyword to remove only a portion of the index:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: '`reset_index` takes an optional parameter `drop` which if true simply discards
    the index, instead of putting index values in the DataFrame’s columns.'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
- en: Adding an ad hoc index
  id: totrans-969
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can assign a custom index to the `index` attribute:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: '## Returning a view versus a copy'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
- en: '[Copy-on-Write](copy_on_write.html#copy-on-write) will become the new default
    in pandas 3.0\. This means than chained indexing will never work. As a consequence,
    the `SettingWithCopyWarning` won’t be necessary anymore. See [this section](copy_on_write.html#copy-on-write-chained-assignment)
    for more context. We recommend turning Copy-on-Write on to leverage the improvements
    with'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '`` pd.options.mode.copy_on_write = True ``'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
- en: even before pandas 3.0 is available.
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: When setting values in a pandas object, care must be taken to avoid what is
    called `chained indexing`. Here is an example.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'Compare these two access methods:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: '[PRE306]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: These both yield the same results, so which should you use? It is instructive
    to understand the order of operations on these and why method 2 (`.loc`) is much
    preferred over method 1 (chained `[]`).
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: '`dfmi[''one'']` selects the first level of the columns and returns a DataFrame
    that is singly-indexed. Then another Python operation `dfmi_with_one[''second'']`
    selects the series indexed by `''second''`. This is indicated by the variable
    `dfmi_with_one` because pandas sees these operations as separate events. e.g.
    separate calls to `__getitem__`, so it has to treat them as linear operations,
    they happen one after another.'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
- en: Contrast this to `df.loc[:,('one','second')]` which passes a nested tuple of
    `(slice(None),('one','second'))` to a single call to `__getitem__`. This allows
    pandas to deal with this as a single entity. Furthermore this order of operations
    *can* be significantly faster, and allows one to index *both* axes if so desired.
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
- en: Why does assignment fail when using chained indexing?
  id: totrans-985
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: '[Copy-on-Write](copy_on_write.html#copy-on-write) will become the new default
    in pandas 3.0\. This means than chained indexing will never work. As a consequence,
    the `SettingWithCopyWarning` won’t be necessary anymore. See [this section](copy_on_write.html#copy-on-write-chained-assignment)
    for more context. We recommend turning Copy-on-Write on to leverage the improvements
    with'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
- en: '`` pd.options.mode.copy_on_write = True ``'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: even before pandas 3.0 is available.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: The problem in the previous section is just a performance issue. What’s up with
    the `SettingWithCopy` warning? We don’t **usually** throw warnings around when
    you do something that might cost a few extra milliseconds!
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
- en: 'But it turns out that assigning to the product of chained indexing has inherently
    unpredictable results. To see this, think about how the Python interpreter executes
    this code:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'But this code is handled differently:'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  id: totrans-994
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: See that `__getitem__` in there? Outside of simple cases, it’s very hard to
    predict whether it will return a view or a copy (it depends on the memory layout
    of the array, about which pandas makes no guarantees), and therefore whether the
    `__setitem__` will modify `dfmi` or a temporary object that gets thrown out immediately
    afterward. **That’s** what `SettingWithCopy` is warning you about!
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering whether we should be concerned about the `loc` property
    in the first example. But `dfmi.loc` is guaranteed to be `dfmi` itself with modified
    indexing behavior, so `dfmi.loc.__getitem__` / `dfmi.loc.__setitem__` operate
    on `dfmi` directly. Of course, `dfmi.loc.__getitem__(idx)` may be a view or a
    copy of `dfmi`.
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes a `SettingWithCopy` warning will arise at times when there’s no obvious
    chained indexing going on. **These** are the bugs that `SettingWithCopy` is designed
    to catch! pandas is probably trying to warn you that you’ve done this:'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  id: totrans-999
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Yikes!
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: '### Evaluation order matters'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: '[Copy-on-Write](copy_on_write.html#copy-on-write) will become the new default
    in pandas 3.0\. This means than chained indexing will never work. As a consequence,
    the `SettingWithCopyWarning` won’t be necessary anymore. See [this section](copy_on_write.html#copy-on-write-chained-assignment)
    for more context. We recommend turning Copy-on-Write on to leverage the improvements
    with'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '`` pd.options.mode.copy_on_write = True ``'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
- en: even before pandas 3.0 is available.
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
- en: When you use chained indexing, the order and type of the indexing operation
    partially determine whether the result is a slice into the original object, or
    a copy of the slice.
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
- en: pandas has the `SettingWithCopyWarning` because assigning to a copy of a slice
    is frequently not intentional, but a mistake caused by chained indexing returning
    a copy where a slice was expected.
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like pandas to be more or less trusting about assignment to a
    chained indexing expression, you can set the [option](options.html#options) `mode.chained_assignment`
    to one of these values:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
- en: '`''warn''`, the default, means a `SettingWithCopyWarning` is printed.'
  id: totrans-1009
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''raise''` means pandas will raise a `SettingWithCopyError` you have to deal
    with.'
  id: totrans-1010
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None` will suppress the warnings entirely.'
  id: totrans-1011
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE310]'
  id: totrans-1012
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: This however is operating on a copy and will not work.
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: A chained assignment can also crop up in setting in a mixed dtype frame.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: These setting rules apply to all of `.loc/.iloc`.
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the recommended access method using `.loc` for multiple items
    (using `mask`) and a single item using a fixed index:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'The following *can* work at times, but it is not guaranteed to, and therefore
    should be avoided:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'Last, the subsequent example will **not** work at all, and so should be avoided:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: Warning
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
- en: The chained assignment warnings / exceptions are aiming to inform the user of
    a possibly invalid assignment. There may be false positives; situations where
    a chained assignment is inadvertently reported.
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
- en: Why does assignment fail when using chained indexing?
  id: totrans-1026
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Warning
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
- en: '[Copy-on-Write](copy_on_write.html#copy-on-write) will become the new default
    in pandas 3.0\. This means than chained indexing will never work. As a consequence,
    the `SettingWithCopyWarning` won’t be necessary anymore. See [this section](copy_on_write.html#copy-on-write-chained-assignment)
    for more context. We recommend turning Copy-on-Write on to leverage the improvements
    with'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '`` pd.options.mode.copy_on_write = True ``'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
- en: even before pandas 3.0 is available.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: The problem in the previous section is just a performance issue. What’s up with
    the `SettingWithCopy` warning? We don’t **usually** throw warnings around when
    you do something that might cost a few extra milliseconds!
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: 'But it turns out that assigning to the product of chained indexing has inherently
    unpredictable results. To see this, think about how the Python interpreter executes
    this code:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'But this code is handled differently:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: See that `__getitem__` in there? Outside of simple cases, it’s very hard to
    predict whether it will return a view or a copy (it depends on the memory layout
    of the array, about which pandas makes no guarantees), and therefore whether the
    `__setitem__` will modify `dfmi` or a temporary object that gets thrown out immediately
    afterward. **That’s** what `SettingWithCopy` is warning you about!
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering whether we should be concerned about the `loc` property
    in the first example. But `dfmi.loc` is guaranteed to be `dfmi` itself with modified
    indexing behavior, so `dfmi.loc.__getitem__` / `dfmi.loc.__setitem__` operate
    on `dfmi` directly. Of course, `dfmi.loc.__getitem__(idx)` may be a view or a
    copy of `dfmi`.
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes a `SettingWithCopy` warning will arise at times when there’s no obvious
    chained indexing going on. **These** are the bugs that `SettingWithCopy` is designed
    to catch! pandas is probably trying to warn you that you’ve done this:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: Yikes!
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '### Evaluation order matters'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: '[Copy-on-Write](copy_on_write.html#copy-on-write) will become the new default
    in pandas 3.0\. This means than chained indexing will never work. As a consequence,
    the `SettingWithCopyWarning` won’t be necessary anymore. See [this section](copy_on_write.html#copy-on-write-chained-assignment)
    for more context. We recommend turning Copy-on-Write on to leverage the improvements
    with'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
- en: '`` pd.options.mode.copy_on_write = True ``'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: even before pandas 3.0 is available.
  id: totrans-1046
  prefs: []
  type: TYPE_NORMAL
- en: When you use chained indexing, the order and type of the indexing operation
    partially determine whether the result is a slice into the original object, or
    a copy of the slice.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: pandas has the `SettingWithCopyWarning` because assigning to a copy of a slice
    is frequently not intentional, but a mistake caused by chained indexing returning
    a copy where a slice was expected.
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like pandas to be more or less trusting about assignment to a
    chained indexing expression, you can set the [option](options.html#options) `mode.chained_assignment`
    to one of these values:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
- en: '`''warn''`, the default, means a `SettingWithCopyWarning` is printed.'
  id: totrans-1050
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''raise''` means pandas will raise a `SettingWithCopyError` you have to deal
    with.'
  id: totrans-1051
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`None` will suppress the warnings entirely.'
  id: totrans-1052
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE318]'
  id: totrans-1053
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: This however is operating on a copy and will not work.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: A chained assignment can also crop up in setting in a mixed dtype frame.
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: These setting rules apply to all of `.loc/.iloc`.
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the recommended access method using `.loc` for multiple items
    (using `mask`) and a single item using a fixed index:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'The following *can* work at times, but it is not guaranteed to, and therefore
    should be avoided:'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  id: totrans-1062
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'Last, the subsequent example will **not** work at all, and so should be avoided:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: Warning
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
- en: The chained assignment warnings / exceptions are aiming to inform the user of
    a possibly invalid assignment. There may be false positives; situations where
    a chained assignment is inadvertently reported.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
