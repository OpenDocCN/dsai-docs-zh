- en: Comparison with SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_sql.html](https://pandas.pydata.org/docs/getting_started/comparison/comparison_with_sql.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since many potential pandas users have some familiarity with [SQL](https://en.wikipedia.org/wiki/SQL),
    this page is meant to provide some examples of how various SQL operations would
    be performed using pandas.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re new to pandas, you might want to first read through [10 Minutes to
    pandas](../../user_guide/10min.html#min) to familiarize yourself with the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'As is customary, we import pandas and NumPy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Most of the examples will utilize the `tips` dataset found within pandas tests.
    We’ll read the data into a DataFrame called `tips` and assume we have a database
    table of the same name and structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Copies vs. in place operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most pandas operations return copies of the `Series`/`DataFrame`. To make the
    changes “stick”, you’ll need to either assign to a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'or overwrite the original one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see an `inplace=True` or `copy=False` keyword argument available for
    some methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There is an active discussion about deprecating and removing `inplace` and `copy`
    for most methods (e.g. `dropna`) except for a very small subset of methods (including
    `replace`). Both keywords won’t be necessary anymore in the context of Copy-on-Write.
    The proposal can be found [here](https://github.com/pandas-dev/pandas/pull/51466).
  prefs: []
  type: TYPE_NORMAL
- en: SELECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In SQL, selection is done using a comma-separated list of columns you’d like
    to select (or a `*` to select all columns):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'With pandas, column selection is done by passing a list of column names to
    your DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Calling the DataFrame without the list of column names would display all columns
    (akin to SQL’s `*`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, you can add a calculated column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With pandas, you can use the [`DataFrame.assign()`](../../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") method of a DataFrame to append a new column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: WHERE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filtering in SQL is done via a WHERE clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: DataFrames can be filtered in multiple ways; the most intuitive of which is
    using [boolean indexing](../../user_guide/indexing.html#indexing-boolean).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The above statement is simply passing a `Series` of `True`/`False` objects to
    the DataFrame, returning all rows with `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Just like SQL’s `OR` and `AND`, multiple conditions can be passed to a DataFrame
    using `|` (`OR`) and `&` (`AND`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Tips of more than $5 at Dinner meals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Tips by parties of at least 5 diners OR bill total was more than $45:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: NULL checking is done using the [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna") and [`isna()`](../../reference/api/pandas.Series.isna.html#pandas.Series.isna
    "pandas.Series.isna") methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume we have a table of the same structure as our DataFrame above. We can
    see only the records where `col2` IS NULL with the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Getting items where `col1` IS NOT NULL can be done with [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: GROUP BY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In pandas, SQL’s `GROUP BY` operations are performed using the similarly named
    [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method. [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") typically refers to a process where we’d like to split
    a dataset into groups, apply some function (typically aggregation) , and then
    combine the groups together.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common SQL operation would be getting the count of records in each group
    throughout a dataset. For instance, a query getting us the number of tips left
    by sex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The pandas equivalent would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the pandas code we used [`DataFrameGroupBy.size()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size
    "pandas.core.groupby.DataFrameGroupBy.size") and not [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count"). This is because [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") applies the function to each column,
    returning the number of `NOT NULL` records within each.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could have applied the [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") method to an individual column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Multiple functions can also be applied at once. For instance, say we’d like
    to see how tip amount differs by day of the week - [`DataFrameGroupBy.agg()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html#pandas.core.groupby.DataFrameGroupBy.agg
    "pandas.core.groupby.DataFrameGroupBy.agg") allows you to pass a dictionary to
    your grouped DataFrame, indicating which functions to apply to specific columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Grouping by more than one column is done by passing a list of columns to the
    [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '## JOIN'
  prefs: []
  type: TYPE_NORMAL
- en: '`JOIN`s can be performed with [`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join") or [`merge()`](../../reference/api/pandas.merge.html#pandas.merge
    "pandas.merge"). By default, [`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join") will join the DataFrames on their indices. Each method
    has parameters allowing you to specify the type of join to perform (`LEFT`, `RIGHT`,
    `INNER`, `FULL`) or the columns to join on (column names or indices).'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: If both key columns contain rows where the key is a null value, those rows will
    be matched against each other. This is different from usual SQL join behaviour
    and can lead to unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Assume we have two database tables of the same name and structure as our DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s go over the various types of `JOIN`s.
  prefs: []
  type: TYPE_NORMAL
- en: INNER JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[`merge()`](../../reference/api/pandas.merge.html#pandas.merge "pandas.merge")
    also offers parameters for cases when you’d like to join one DataFrame’s column
    with another DataFrame’s index.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: LEFT OUTER JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Show all records from `df1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: RIGHT JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Show all records from `df2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: FULL JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pandas also allows for `FULL JOIN`s, which display both sides of the dataset,
    whether or not the joined columns find a match. As of writing, `FULL JOIN`s are
    not supported in all RDBMS (MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: Show all records from both tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: UNION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UNION ALL` can be performed using [`concat()`](../../reference/api/pandas.concat.html#pandas.concat
    "pandas.concat").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: SQL’s `UNION` is similar to `UNION ALL`, however `UNION` will remove duplicate
    rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In pandas, you can use [`concat()`](../../reference/api/pandas.concat.html#pandas.concat
    "pandas.concat") in conjunction with [`drop_duplicates()`](../../reference/api/pandas.DataFrame.drop_duplicates.html#pandas.DataFrame.drop_duplicates
    "pandas.DataFrame.drop_duplicates").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: LIMIT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: pandas equivalents for some SQL analytic and aggregate functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Top n rows with offset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Top n rows per group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: the same using `rank(method='first')` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Let’s find tips with (rank < 3) per gender group for (tips < 2). Notice that
    when using `rank(method='min')` function `rnk_min` remains the same for the same
    `tip` (as Oracle’s `RANK()` function)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: UPDATE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: DELETE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas we select the rows that should remain instead of deleting them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Copies vs. in place operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most pandas operations return copies of the `Series`/`DataFrame`. To make the
    changes “stick”, you’ll need to either assign to a new variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: 'or overwrite the original one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You will see an `inplace=True` or `copy=False` keyword argument available for
    some methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: There is an active discussion about deprecating and removing `inplace` and `copy`
    for most methods (e.g. `dropna`) except for a very small subset of methods (including
    `replace`). Both keywords won’t be necessary anymore in the context of Copy-on-Write.
    The proposal can be found [here](https://github.com/pandas-dev/pandas/pull/51466).
  prefs: []
  type: TYPE_NORMAL
- en: SELECT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In SQL, selection is done using a comma-separated list of columns you’d like
    to select (or a `*` to select all columns):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'With pandas, column selection is done by passing a list of column names to
    your DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Calling the DataFrame without the list of column names would display all columns
    (akin to SQL’s `*`).
  prefs: []
  type: TYPE_NORMAL
- en: 'In SQL, you can add a calculated column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'With pandas, you can use the [`DataFrame.assign()`](../../reference/api/pandas.DataFrame.assign.html#pandas.DataFrame.assign
    "pandas.DataFrame.assign") method of a DataFrame to append a new column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: WHERE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Filtering in SQL is done via a WHERE clause.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: DataFrames can be filtered in multiple ways; the most intuitive of which is
    using [boolean indexing](../../user_guide/indexing.html#indexing-boolean).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The above statement is simply passing a `Series` of `True`/`False` objects to
    the DataFrame, returning all rows with `True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Just like SQL’s `OR` and `AND`, multiple conditions can be passed to a DataFrame
    using `|` (`OR`) and `&` (`AND`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Tips of more than $5 at Dinner meals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Tips by parties of at least 5 diners OR bill total was more than $45:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: NULL checking is done using the [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna") and [`isna()`](../../reference/api/pandas.Series.isna.html#pandas.Series.isna
    "pandas.Series.isna") methods.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Assume we have a table of the same structure as our DataFrame above. We can
    see only the records where `col2` IS NULL with the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Getting items where `col1` IS NOT NULL can be done with [`notna()`](../../reference/api/pandas.Series.notna.html#pandas.Series.notna
    "pandas.Series.notna").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: GROUP BY
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In pandas, SQL’s `GROUP BY` operations are performed using the similarly named
    [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method. [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") typically refers to a process where we’d like to split
    a dataset into groups, apply some function (typically aggregation) , and then
    combine the groups together.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common SQL operation would be getting the count of records in each group
    throughout a dataset. For instance, a query getting us the number of tips left
    by sex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The pandas equivalent would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Notice that in the pandas code we used [`DataFrameGroupBy.size()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.size.html#pandas.core.groupby.DataFrameGroupBy.size
    "pandas.core.groupby.DataFrameGroupBy.size") and not [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count"). This is because [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") applies the function to each column,
    returning the number of `NOT NULL` records within each.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we could have applied the [`DataFrameGroupBy.count()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.count.html#pandas.core.groupby.DataFrameGroupBy.count
    "pandas.core.groupby.DataFrameGroupBy.count") method to an individual column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Multiple functions can also be applied at once. For instance, say we’d like
    to see how tip amount differs by day of the week - [`DataFrameGroupBy.agg()`](../../reference/api/pandas.core.groupby.DataFrameGroupBy.agg.html#pandas.core.groupby.DataFrameGroupBy.agg
    "pandas.core.groupby.DataFrameGroupBy.agg") allows you to pass a dictionary to
    your grouped DataFrame, indicating which functions to apply to specific columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Grouping by more than one column is done by passing a list of columns to the
    [`groupby()`](../../reference/api/pandas.DataFrame.groupby.html#pandas.DataFrame.groupby
    "pandas.DataFrame.groupby") method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '## JOIN'
  prefs: []
  type: TYPE_NORMAL
- en: '`JOIN`s can be performed with [`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join") or [`merge()`](../../reference/api/pandas.merge.html#pandas.merge
    "pandas.merge"). By default, [`join()`](../../reference/api/pandas.DataFrame.join.html#pandas.DataFrame.join
    "pandas.DataFrame.join") will join the DataFrames on their indices. Each method
    has parameters allowing you to specify the type of join to perform (`LEFT`, `RIGHT`,
    `INNER`, `FULL`) or the columns to join on (column names or indices).'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: If both key columns contain rows where the key is a null value, those rows will
    be matched against each other. This is different from usual SQL join behaviour
    and can lead to unexpected results.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Assume we have two database tables of the same name and structure as our DataFrames.
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s go over the various types of `JOIN`s.
  prefs: []
  type: TYPE_NORMAL
- en: INNER JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[`merge()`](../../reference/api/pandas.merge.html#pandas.merge "pandas.merge")
    also offers parameters for cases when you’d like to join one DataFrame’s column
    with another DataFrame’s index.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: LEFT OUTER JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Show all records from `df1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: RIGHT JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Show all records from `df2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: FULL JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pandas also allows for `FULL JOIN`s, which display both sides of the dataset,
    whether or not the joined columns find a match. As of writing, `FULL JOIN`s are
    not supported in all RDBMS (MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: Show all records from both tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: INNER JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[`merge()`](../../reference/api/pandas.merge.html#pandas.merge "pandas.merge")
    also offers parameters for cases when you’d like to join one DataFrame’s column
    with another DataFrame’s index.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: LEFT OUTER JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Show all records from `df1`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: RIGHT JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Show all records from `df2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: FULL JOIN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: pandas also allows for `FULL JOIN`s, which display both sides of the dataset,
    whether or not the joined columns find a match. As of writing, `FULL JOIN`s are
    not supported in all RDBMS (MySQL).
  prefs: []
  type: TYPE_NORMAL
- en: Show all records from both tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: UNION
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UNION ALL` can be performed using [`concat()`](../../reference/api/pandas.concat.html#pandas.concat
    "pandas.concat").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: SQL’s `UNION` is similar to `UNION ALL`, however `UNION` will remove duplicate
    rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: In pandas, you can use [`concat()`](../../reference/api/pandas.concat.html#pandas.concat
    "pandas.concat") in conjunction with [`drop_duplicates()`](../../reference/api/pandas.DataFrame.drop_duplicates.html#pandas.DataFrame.drop_duplicates
    "pandas.DataFrame.drop_duplicates").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: LIMIT
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: pandas equivalents for some SQL analytic and aggregate functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Top n rows with offset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Top n rows per group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: the same using `rank(method='first')` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Let’s find tips with (rank < 3) per gender group for (tips < 2). Notice that
    when using `rank(method='min')` function `rnk_min` remains the same for the same
    `tip` (as Oracle’s `RANK()` function)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Top n rows with offset
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Top n rows per group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: the same using `rank(method='first')` function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Let’s find tips with (rank < 3) per gender group for (tips < 2). Notice that
    when using `rank(method='min')` function `rnk_min` remains the same for the same
    `tip` (as Oracle’s `RANK()` function)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: UPDATE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: DELETE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'In pandas we select the rows that should remain instead of deleting them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
