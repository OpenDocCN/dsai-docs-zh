["```py\ndef add(num1, num2):\n  \"\"\"\n Add up two integer numbers.\n\n This function simply wraps the ``+`` operator, and does not\n do anything interesting, except for illustrating what\n the docstring of a very simple function looks like.\n\n Parameters\n ----------\n num1 : int\n First number to add.\n num2 : int\n Second number to add.\n\n Returns\n -------\n int\n The sum of ``num1`` and ``num2``.\n\n See Also\n --------\n subtract : Subtract one integer from another.\n\n Examples\n --------\n >>> add(2, 2)\n 4\n >>> add(25, 0)\n 25\n >>> add(10, -10)\n 0\n \"\"\"\n    return num1 + num2 \n```", "```py\ndef add_values(arr):\n  \"\"\"\n Add the values in ``arr``.\n\n This is equivalent to Python ``sum`` of :meth:`pandas.Series.sum`.\n\n Some sections are omitted here for simplicity.\n \"\"\"\n    return sum(arr) \n```", "```py\ndef func():\n\n  \"\"\"Some function.\n\n With several mistakes in the docstring.\n\n It has a blank like after the signature ``def func():``.\n\n The text 'Some function' should go in the line after the\n opening quotes of the docstring, not in the same line.\n\n There is a blank line between the docstring and the first line\n of code ``foo = 1``.\n\n The closing quotes should be in the next line, not in this one.\"\"\"\n\n    foo = 1\n    bar = 2\n    return foo + bar \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Cast Series type.\n\n This section will provide further details.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Casts Series type.\n\n Verb in third-person of the present simple, should be infinitive.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Method to cast Series type.\n\n Does not start with verb.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Cast Series type\n\n Missing dot at the end.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Cast Series type from its current type to the new type defined in\n the parameter dtype.\n\n Summary is too verbose and doesn't fit in a single line.\n \"\"\"\n    pass \n```", "```py\ndef unstack():\n  \"\"\"\n Pivot a row index to columns.\n\n When using a MultiIndex, a level can be pivoted so each value in\n the index becomes a column. This is especially useful when a subindex\n is repeated for the main index, and data is easier to visualize as a\n pivot table.\n\n The index level will be automatically removed from the index when added\n as columns.\n \"\"\"\n    pass \n```", "```py\nclass Series:\n    def plot(self, kind, color='blue', **kwargs):\n  \"\"\"\n Generate a plot.\n\n Render the data in the Series as a matplotlib plot of the\n specified kind.\n\n Parameters\n ----------\n kind : str\n Kind of matplotlib plot.\n color : str, default 'blue'\n Color name or rgb code.\n **kwargs\n These parameters will be passed to the matplotlib plotting\n function.\n \"\"\"\n        pass \n```", "```py\nclass Series:\n    def plot(self, kind, **kwargs):\n  \"\"\"\n Generate a plot.\n\n Render the data in the Series as a matplotlib plot of the\n specified kind.\n\n Note the blank line between the parameters title and the first\n parameter. Also, note that after the name of the parameter ``kind``\n and before the colon, a space is missing.\n\n Also, note that the parameter descriptions do not start with a\n capital letter, and do not finish with a dot.\n\n Finally, the ``**kwargs`` parameter is missing.\n\n Parameters\n ----------\n\n kind: str\n kind of matplotlib plot\n \"\"\"\n        pass \n```", "```py\ndef sample():\n  \"\"\"\n Generate and return a random number.\n\n The value is sampled from a continuous uniform distribution between\n 0 and 1.\n\n Returns\n -------\n float\n Random number generated.\n \"\"\"\n    return np.random.random() \n```", "```py\nimport string\n\ndef random_letters():\n  \"\"\"\n Generate and return a sequence of random letters.\n\n The length of the returned string is also random, and is also\n returned.\n\n Returns\n -------\n length : int\n Length of the returned string.\n letters : str\n String of random letters.\n \"\"\"\n    length = np.random.randint(1, 10)\n    letters = ''.join(np.random.choice(string.ascii_lowercase)\n                      for i in range(length))\n    return length, letters \n```", "```py\ndef sample_values():\n  \"\"\"\n Generate an infinite sequence of random numbers.\n\n The values are sampled from a continuous uniform distribution between\n 0 and 1.\n\n Yields\n ------\n float\n Random number generated.\n \"\"\"\n    while True:\n        yield np.random.random() \n```", "```py\nclass Series:\n    def head(self):\n  \"\"\"\n Return the first 5 elements of the Series.\n\n This function is mainly useful to preview the values of the\n Series without displaying the whole of it.\n\n Returns\n -------\n Series\n Subset of the original series with the 5 first values.\n\n See Also\n --------\n Series.tail : Return the last 5 elements of the Series.\n Series.iloc : Return a slice of the elements in the Series,\n which can also be used to return the first or last n.\n \"\"\"\n        return self.iloc[:5] \n```", "```py\nclass Series:\n\n    def head(self, n=5):\n  \"\"\"\n Return the first elements of the Series.\n\n This function is mainly useful to preview the values of the\n Series without displaying all of it.\n\n Parameters\n ----------\n n : int\n Number of values to return.\n\n Return\n ------\n pandas.Series\n Subset of the original series with the n first values.\n\n See Also\n --------\n tail : Return the last n elements of the Series.\n\n Examples\n --------\n >>> ser = pd.Series(['Ant', 'Bear', 'Cow', 'Dog', 'Falcon',\n ...                'Lion', 'Monkey', 'Rabbit', 'Zebra'])\n >>> ser.head()\n 0   Ant\n 1   Bear\n 2   Cow\n 3   Dog\n 4   Falcon\n dtype: object\n\n With the ``n`` parameter, we can change the number of returned rows:\n\n >>> ser.head(n=3)\n 0   Ant\n 1   Bear\n 2   Cow\n dtype: object\n \"\"\"\n        return self.iloc[:n] \n```", "```py\nimport numpy as np\nimport pandas as pd \n```", "```py\nclass Series:\n\n    def mean(self):\n  \"\"\"\n Compute the mean of the input.\n\n Examples\n --------\n >>> ser = pd.Series([1, 2, 3])\n >>> ser.mean()\n 2\n \"\"\"\n        pass\n\n    def fillna(self, value):\n  \"\"\"\n Replace missing values by ``value``.\n\n Examples\n --------\n >>> ser = pd.Series([1, np.nan, 3])\n >>> ser.fillna(0)\n [1, 0, 3]\n \"\"\"\n        pass\n\n    def groupby_mean(self):\n  \"\"\"\n Group by index and return mean.\n\n Examples\n --------\n >>> ser = pd.Series([380., 370., 24., 26],\n ...               name='max_speed',\n ...               index=['falcon', 'falcon', 'parrot', 'parrot'])\n >>> ser.groupby_mean()\n index\n falcon    375.0\n parrot     25.0\n Name: max_speed, dtype: float64\n \"\"\"\n        pass\n\n    def contains(self, pattern, case_sensitive=True, na=numpy.nan):\n  \"\"\"\n Return whether each value contains ``pattern``.\n\n In this case, we are illustrating how to use sections, even\n if the example is simple enough and does not require them.\n\n Examples\n --------\n >>> ser = pd.Series('Antelope', 'Lion', 'Zebra', np.nan)\n >>> ser.contains(pattern='a')\n 0    False\n 1    False\n 2     True\n 3      NaN\n dtype: bool\n\n **Case sensitivity**\n\n With ``case_sensitive`` set to ``False`` we can match ``a`` with both\n ``a`` and ``A``:\n\n >>> s.contains(pattern='a', case_sensitive=False)\n 0     True\n 1    False\n 2     True\n 3      NaN\n dtype: bool\n\n **Missing values**\n\n We can fill missing values in the output using the ``na`` parameter:\n\n >>> ser.contains(pattern='a', na=False)\n 0    False\n 1    False\n 2     True\n 3    False\n dtype: bool\n \"\"\"\n        pass \n```", "```py\ndef method(foo=None, bar=None):\n  \"\"\"\n A sample DataFrame method.\n\n Do not import NumPy and pandas.\n\n Try to use meaningful data, when it makes the example easier\n to understand.\n\n Try to avoid positional arguments like in ``df.method(1)``. They\n can be all right if previously defined with a meaningful name,\n like in ``present_value(interest_rate)``, but avoid them otherwise.\n\n When presenting the behavior with different parameters, do not place\n all the calls one next to the other. Instead, add a short sentence\n explaining what the example shows.\n\n Examples\n --------\n >>> import numpy as np\n >>> import pandas as pd\n >>> df = pd.DataFrame(np.random.randn(3, 3),\n ...                   columns=('a', 'b', 'c'))\n >>> df.method(1)\n 21\n >>> df.method(bar=14)\n 123\n \"\"\"\n    pass \n```", "```py\n    >>> np.random.seed(42)\n    >>> df = pd.DataFrame({'normal': np.random.normal(100, 5, 20)}) \n    ```", "```py\n    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], index=['a', 'b', 'c'],\n    ...                   columns=['A', 'B']) \n    ```", "```py\n    >>> pd.to_datetime([\"712-01-01\"])\n    Traceback (most recent call last):\n    OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 712-01-01 00:00:00 \n    ```", "```py\n    >>> s.plot()\n    <matplotlib.axes._subplots.AxesSubplot at 0x7efd0c0b0690> \n    ```", "```py\n    >>> s.plot()  \n    <matplotlib.axes._subplots.AxesSubplot at ...> \n    ```", "```py\nclass Series:\n    def plot(self):\n  \"\"\"\n Generate a plot with the ``Series`` data.\n\n Examples\n --------\n\n .. plot::\n :context: close-figs\n\n >>> ser = pd.Series([1, 2, 3])\n >>> ser.plot()\n \"\"\"\n        pass \n```", "```py\nclass Parent:\n    @doc(klass=\"Parent\")\n    def my_function(self):\n  \"\"\"Apply my function to {klass}.\"\"\"\n        ...\n\nclass ChildA(Parent):\n    @doc(Parent.my_function, klass=\"ChildA\")\n    def my_function(self):\n        ...\n\nclass ChildB(Parent):\n    @doc(Parent.my_function, klass=\"ChildB\")\n    def my_function(self):\n        ... \n```", "```py\n>>> print(Parent.my_function.__doc__)\nApply my function to Parent.\n>>> print(ChildA.my_function.__doc__)\nApply my function to ChildA.\n>>> print(ChildB.my_function.__doc__)\nApply my function to ChildB. \n```", "```py\n@doc(template, **_shared_doc_kwargs)\ndef my_function(self):\n    ... \n```", "```py\ndef add(num1, num2):\n  \"\"\"\n Add up two integer numbers.\n\n This function simply wraps the ``+`` operator, and does not\n do anything interesting, except for illustrating what\n the docstring of a very simple function looks like.\n\n Parameters\n ----------\n num1 : int\n First number to add.\n num2 : int\n Second number to add.\n\n Returns\n -------\n int\n The sum of ``num1`` and ``num2``.\n\n See Also\n --------\n subtract : Subtract one integer from another.\n\n Examples\n --------\n >>> add(2, 2)\n 4\n >>> add(25, 0)\n 25\n >>> add(10, -10)\n 0\n \"\"\"\n    return num1 + num2 \n```", "```py\ndef add_values(arr):\n  \"\"\"\n Add the values in ``arr``.\n\n This is equivalent to Python ``sum`` of :meth:`pandas.Series.sum`.\n\n Some sections are omitted here for simplicity.\n \"\"\"\n    return sum(arr) \n```", "```py\ndef func():\n\n  \"\"\"Some function.\n\n With several mistakes in the docstring.\n\n It has a blank like after the signature ``def func():``.\n\n The text 'Some function' should go in the line after the\n opening quotes of the docstring, not in the same line.\n\n There is a blank line between the docstring and the first line\n of code ``foo = 1``.\n\n The closing quotes should be in the next line, not in this one.\"\"\"\n\n    foo = 1\n    bar = 2\n    return foo + bar \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Cast Series type.\n\n This section will provide further details.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Casts Series type.\n\n Verb in third-person of the present simple, should be infinitive.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Method to cast Series type.\n\n Does not start with verb.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Cast Series type\n\n Missing dot at the end.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Cast Series type from its current type to the new type defined in\n the parameter dtype.\n\n Summary is too verbose and doesn't fit in a single line.\n \"\"\"\n    pass \n```", "```py\ndef unstack():\n  \"\"\"\n Pivot a row index to columns.\n\n When using a MultiIndex, a level can be pivoted so each value in\n the index becomes a column. This is especially useful when a subindex\n is repeated for the main index, and data is easier to visualize as a\n pivot table.\n\n The index level will be automatically removed from the index when added\n as columns.\n \"\"\"\n    pass \n```", "```py\nclass Series:\n    def plot(self, kind, color='blue', **kwargs):\n  \"\"\"\n Generate a plot.\n\n Render the data in the Series as a matplotlib plot of the\n specified kind.\n\n Parameters\n ----------\n kind : str\n Kind of matplotlib plot.\n color : str, default 'blue'\n Color name or rgb code.\n **kwargs\n These parameters will be passed to the matplotlib plotting\n function.\n \"\"\"\n        pass \n```", "```py\nclass Series:\n    def plot(self, kind, **kwargs):\n  \"\"\"\n Generate a plot.\n\n Render the data in the Series as a matplotlib plot of the\n specified kind.\n\n Note the blank line between the parameters title and the first\n parameter. Also, note that after the name of the parameter ``kind``\n and before the colon, a space is missing.\n\n Also, note that the parameter descriptions do not start with a\n capital letter, and do not finish with a dot.\n\n Finally, the ``**kwargs`` parameter is missing.\n\n Parameters\n ----------\n\n kind: str\n kind of matplotlib plot\n \"\"\"\n        pass \n```", "```py\ndef sample():\n  \"\"\"\n Generate and return a random number.\n\n The value is sampled from a continuous uniform distribution between\n 0 and 1.\n\n Returns\n -------\n float\n Random number generated.\n \"\"\"\n    return np.random.random() \n```", "```py\nimport string\n\ndef random_letters():\n  \"\"\"\n Generate and return a sequence of random letters.\n\n The length of the returned string is also random, and is also\n returned.\n\n Returns\n -------\n length : int\n Length of the returned string.\n letters : str\n String of random letters.\n \"\"\"\n    length = np.random.randint(1, 10)\n    letters = ''.join(np.random.choice(string.ascii_lowercase)\n                      for i in range(length))\n    return length, letters \n```", "```py\ndef sample_values():\n  \"\"\"\n Generate an infinite sequence of random numbers.\n\n The values are sampled from a continuous uniform distribution between\n 0 and 1.\n\n Yields\n ------\n float\n Random number generated.\n \"\"\"\n    while True:\n        yield np.random.random() \n```", "```py\nclass Series:\n    def head(self):\n  \"\"\"\n Return the first 5 elements of the Series.\n\n This function is mainly useful to preview the values of the\n Series without displaying the whole of it.\n\n Returns\n -------\n Series\n Subset of the original series with the 5 first values.\n\n See Also\n --------\n Series.tail : Return the last 5 elements of the Series.\n Series.iloc : Return a slice of the elements in the Series,\n which can also be used to return the first or last n.\n \"\"\"\n        return self.iloc[:5] \n```", "```py\nclass Series:\n\n    def head(self, n=5):\n  \"\"\"\n Return the first elements of the Series.\n\n This function is mainly useful to preview the values of the\n Series without displaying all of it.\n\n Parameters\n ----------\n n : int\n Number of values to return.\n\n Return\n ------\n pandas.Series\n Subset of the original series with the n first values.\n\n See Also\n --------\n tail : Return the last n elements of the Series.\n\n Examples\n --------\n >>> ser = pd.Series(['Ant', 'Bear', 'Cow', 'Dog', 'Falcon',\n ...                'Lion', 'Monkey', 'Rabbit', 'Zebra'])\n >>> ser.head()\n 0   Ant\n 1   Bear\n 2   Cow\n 3   Dog\n 4   Falcon\n dtype: object\n\n With the ``n`` parameter, we can change the number of returned rows:\n\n >>> ser.head(n=3)\n 0   Ant\n 1   Bear\n 2   Cow\n dtype: object\n \"\"\"\n        return self.iloc[:n] \n```", "```py\nimport numpy as np\nimport pandas as pd \n```", "```py\nclass Series:\n\n    def mean(self):\n  \"\"\"\n Compute the mean of the input.\n\n Examples\n --------\n >>> ser = pd.Series([1, 2, 3])\n >>> ser.mean()\n 2\n \"\"\"\n        pass\n\n    def fillna(self, value):\n  \"\"\"\n Replace missing values by ``value``.\n\n Examples\n --------\n >>> ser = pd.Series([1, np.nan, 3])\n >>> ser.fillna(0)\n [1, 0, 3]\n \"\"\"\n        pass\n\n    def groupby_mean(self):\n  \"\"\"\n Group by index and return mean.\n\n Examples\n --------\n >>> ser = pd.Series([380., 370., 24., 26],\n ...               name='max_speed',\n ...               index=['falcon', 'falcon', 'parrot', 'parrot'])\n >>> ser.groupby_mean()\n index\n falcon    375.0\n parrot     25.0\n Name: max_speed, dtype: float64\n \"\"\"\n        pass\n\n    def contains(self, pattern, case_sensitive=True, na=numpy.nan):\n  \"\"\"\n Return whether each value contains ``pattern``.\n\n In this case, we are illustrating how to use sections, even\n if the example is simple enough and does not require them.\n\n Examples\n --------\n >>> ser = pd.Series('Antelope', 'Lion', 'Zebra', np.nan)\n >>> ser.contains(pattern='a')\n 0    False\n 1    False\n 2     True\n 3      NaN\n dtype: bool\n\n **Case sensitivity**\n\n With ``case_sensitive`` set to ``False`` we can match ``a`` with both\n ``a`` and ``A``:\n\n >>> s.contains(pattern='a', case_sensitive=False)\n 0     True\n 1    False\n 2     True\n 3      NaN\n dtype: bool\n\n **Missing values**\n\n We can fill missing values in the output using the ``na`` parameter:\n\n >>> ser.contains(pattern='a', na=False)\n 0    False\n 1    False\n 2     True\n 3    False\n dtype: bool\n \"\"\"\n        pass \n```", "```py\ndef method(foo=None, bar=None):\n  \"\"\"\n A sample DataFrame method.\n\n Do not import NumPy and pandas.\n\n Try to use meaningful data, when it makes the example easier\n to understand.\n\n Try to avoid positional arguments like in ``df.method(1)``. They\n can be all right if previously defined with a meaningful name,\n like in ``present_value(interest_rate)``, but avoid them otherwise.\n\n When presenting the behavior with different parameters, do not place\n all the calls one next to the other. Instead, add a short sentence\n explaining what the example shows.\n\n Examples\n --------\n >>> import numpy as np\n >>> import pandas as pd\n >>> df = pd.DataFrame(np.random.randn(3, 3),\n ...                   columns=('a', 'b', 'c'))\n >>> df.method(1)\n 21\n >>> df.method(bar=14)\n 123\n \"\"\"\n    pass \n```", "```py\n    >>> np.random.seed(42)\n    >>> df = pd.DataFrame({'normal': np.random.normal(100, 5, 20)}) \n    ```", "```py\n    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], index=['a', 'b', 'c'],\n    ...                   columns=['A', 'B']) \n    ```", "```py\n    >>> pd.to_datetime([\"712-01-01\"])\n    Traceback (most recent call last):\n    OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 712-01-01 00:00:00 \n    ```", "```py\n    >>> s.plot()\n    <matplotlib.axes._subplots.AxesSubplot at 0x7efd0c0b0690> \n    ```", "```py\n    >>> s.plot()  \n    <matplotlib.axes._subplots.AxesSubplot at ...> \n    ```", "```py\nclass Series:\n    def plot(self):\n  \"\"\"\n Generate a plot with the ``Series`` data.\n\n Examples\n --------\n\n .. plot::\n :context: close-figs\n\n >>> ser = pd.Series([1, 2, 3])\n >>> ser.plot()\n \"\"\"\n        pass \n```", "```py\ndef add_values(arr):\n  \"\"\"\n Add the values in ``arr``.\n\n This is equivalent to Python ``sum`` of :meth:`pandas.Series.sum`.\n\n Some sections are omitted here for simplicity.\n \"\"\"\n    return sum(arr) \n```", "```py\ndef func():\n\n  \"\"\"Some function.\n\n With several mistakes in the docstring.\n\n It has a blank like after the signature ``def func():``.\n\n The text 'Some function' should go in the line after the\n opening quotes of the docstring, not in the same line.\n\n There is a blank line between the docstring and the first line\n of code ``foo = 1``.\n\n The closing quotes should be in the next line, not in this one.\"\"\"\n\n    foo = 1\n    bar = 2\n    return foo + bar \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Cast Series type.\n\n This section will provide further details.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Casts Series type.\n\n Verb in third-person of the present simple, should be infinitive.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Method to cast Series type.\n\n Does not start with verb.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Cast Series type\n\n Missing dot at the end.\n \"\"\"\n    pass \n```", "```py\ndef astype(dtype):\n  \"\"\"\n Cast Series type from its current type to the new type defined in\n the parameter dtype.\n\n Summary is too verbose and doesn't fit in a single line.\n \"\"\"\n    pass \n```", "```py\ndef unstack():\n  \"\"\"\n Pivot a row index to columns.\n\n When using a MultiIndex, a level can be pivoted so each value in\n the index becomes a column. This is especially useful when a subindex\n is repeated for the main index, and data is easier to visualize as a\n pivot table.\n\n The index level will be automatically removed from the index when added\n as columns.\n \"\"\"\n    pass \n```", "```py\nclass Series:\n    def plot(self, kind, color='blue', **kwargs):\n  \"\"\"\n Generate a plot.\n\n Render the data in the Series as a matplotlib plot of the\n specified kind.\n\n Parameters\n ----------\n kind : str\n Kind of matplotlib plot.\n color : str, default 'blue'\n Color name or rgb code.\n **kwargs\n These parameters will be passed to the matplotlib plotting\n function.\n \"\"\"\n        pass \n```", "```py\nclass Series:\n    def plot(self, kind, **kwargs):\n  \"\"\"\n Generate a plot.\n\n Render the data in the Series as a matplotlib plot of the\n specified kind.\n\n Note the blank line between the parameters title and the first\n parameter. Also, note that after the name of the parameter ``kind``\n and before the colon, a space is missing.\n\n Also, note that the parameter descriptions do not start with a\n capital letter, and do not finish with a dot.\n\n Finally, the ``**kwargs`` parameter is missing.\n\n Parameters\n ----------\n\n kind: str\n kind of matplotlib plot\n \"\"\"\n        pass \n```", "```py\ndef sample():\n  \"\"\"\n Generate and return a random number.\n\n The value is sampled from a continuous uniform distribution between\n 0 and 1.\n\n Returns\n -------\n float\n Random number generated.\n \"\"\"\n    return np.random.random() \n```", "```py\nimport string\n\ndef random_letters():\n  \"\"\"\n Generate and return a sequence of random letters.\n\n The length of the returned string is also random, and is also\n returned.\n\n Returns\n -------\n length : int\n Length of the returned string.\n letters : str\n String of random letters.\n \"\"\"\n    length = np.random.randint(1, 10)\n    letters = ''.join(np.random.choice(string.ascii_lowercase)\n                      for i in range(length))\n    return length, letters \n```", "```py\ndef sample_values():\n  \"\"\"\n Generate an infinite sequence of random numbers.\n\n The values are sampled from a continuous uniform distribution between\n 0 and 1.\n\n Yields\n ------\n float\n Random number generated.\n \"\"\"\n    while True:\n        yield np.random.random() \n```", "```py\nclass Series:\n    def head(self):\n  \"\"\"\n Return the first 5 elements of the Series.\n\n This function is mainly useful to preview the values of the\n Series without displaying the whole of it.\n\n Returns\n -------\n Series\n Subset of the original series with the 5 first values.\n\n See Also\n --------\n Series.tail : Return the last 5 elements of the Series.\n Series.iloc : Return a slice of the elements in the Series,\n which can also be used to return the first or last n.\n \"\"\"\n        return self.iloc[:5] \n```", "```py\nclass Series:\n\n    def head(self, n=5):\n  \"\"\"\n Return the first elements of the Series.\n\n This function is mainly useful to preview the values of the\n Series without displaying all of it.\n\n Parameters\n ----------\n n : int\n Number of values to return.\n\n Return\n ------\n pandas.Series\n Subset of the original series with the n first values.\n\n See Also\n --------\n tail : Return the last n elements of the Series.\n\n Examples\n --------\n >>> ser = pd.Series(['Ant', 'Bear', 'Cow', 'Dog', 'Falcon',\n ...                'Lion', 'Monkey', 'Rabbit', 'Zebra'])\n >>> ser.head()\n 0   Ant\n 1   Bear\n 2   Cow\n 3   Dog\n 4   Falcon\n dtype: object\n\n With the ``n`` parameter, we can change the number of returned rows:\n\n >>> ser.head(n=3)\n 0   Ant\n 1   Bear\n 2   Cow\n dtype: object\n \"\"\"\n        return self.iloc[:n] \n```", "```py\nimport numpy as np\nimport pandas as pd \n```", "```py\nclass Series:\n\n    def mean(self):\n  \"\"\"\n Compute the mean of the input.\n\n Examples\n --------\n >>> ser = pd.Series([1, 2, 3])\n >>> ser.mean()\n 2\n \"\"\"\n        pass\n\n    def fillna(self, value):\n  \"\"\"\n Replace missing values by ``value``.\n\n Examples\n --------\n >>> ser = pd.Series([1, np.nan, 3])\n >>> ser.fillna(0)\n [1, 0, 3]\n \"\"\"\n        pass\n\n    def groupby_mean(self):\n  \"\"\"\n Group by index and return mean.\n\n Examples\n --------\n >>> ser = pd.Series([380., 370., 24., 26],\n ...               name='max_speed',\n ...               index=['falcon', 'falcon', 'parrot', 'parrot'])\n >>> ser.groupby_mean()\n index\n falcon    375.0\n parrot     25.0\n Name: max_speed, dtype: float64\n \"\"\"\n        pass\n\n    def contains(self, pattern, case_sensitive=True, na=numpy.nan):\n  \"\"\"\n Return whether each value contains ``pattern``.\n\n In this case, we are illustrating how to use sections, even\n if the example is simple enough and does not require them.\n\n Examples\n --------\n >>> ser = pd.Series('Antelope', 'Lion', 'Zebra', np.nan)\n >>> ser.contains(pattern='a')\n 0    False\n 1    False\n 2     True\n 3      NaN\n dtype: bool\n\n **Case sensitivity**\n\n With ``case_sensitive`` set to ``False`` we can match ``a`` with both\n ``a`` and ``A``:\n\n >>> s.contains(pattern='a', case_sensitive=False)\n 0     True\n 1    False\n 2     True\n 3      NaN\n dtype: bool\n\n **Missing values**\n\n We can fill missing values in the output using the ``na`` parameter:\n\n >>> ser.contains(pattern='a', na=False)\n 0    False\n 1    False\n 2     True\n 3    False\n dtype: bool\n \"\"\"\n        pass \n```", "```py\ndef method(foo=None, bar=None):\n  \"\"\"\n A sample DataFrame method.\n\n Do not import NumPy and pandas.\n\n Try to use meaningful data, when it makes the example easier\n to understand.\n\n Try to avoid positional arguments like in ``df.method(1)``. They\n can be all right if previously defined with a meaningful name,\n like in ``present_value(interest_rate)``, but avoid them otherwise.\n\n When presenting the behavior with different parameters, do not place\n all the calls one next to the other. Instead, add a short sentence\n explaining what the example shows.\n\n Examples\n --------\n >>> import numpy as np\n >>> import pandas as pd\n >>> df = pd.DataFrame(np.random.randn(3, 3),\n ...                   columns=('a', 'b', 'c'))\n >>> df.method(1)\n 21\n >>> df.method(bar=14)\n 123\n \"\"\"\n    pass \n```", "```py\n    >>> np.random.seed(42)\n    >>> df = pd.DataFrame({'normal': np.random.normal(100, 5, 20)}) \n    ```", "```py\n    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], index=['a', 'b', 'c'],\n    ...                   columns=['A', 'B']) \n    ```", "```py\n    >>> pd.to_datetime([\"712-01-01\"])\n    Traceback (most recent call last):\n    OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 712-01-01 00:00:00 \n    ```", "```py\n    >>> s.plot()\n    <matplotlib.axes._subplots.AxesSubplot at 0x7efd0c0b0690> \n    ```", "```py\n    >>> s.plot()  \n    <matplotlib.axes._subplots.AxesSubplot at ...> \n    ```", "```py\nclass Series:\n    def plot(self):\n  \"\"\"\n Generate a plot with the ``Series`` data.\n\n Examples\n --------\n\n .. plot::\n :context: close-figs\n\n >>> ser = pd.Series([1, 2, 3])\n >>> ser.plot()\n \"\"\"\n        pass \n```", "```py\nimport numpy as np\nimport pandas as pd \n```", "```py\nclass Series:\n\n    def mean(self):\n  \"\"\"\n Compute the mean of the input.\n\n Examples\n --------\n >>> ser = pd.Series([1, 2, 3])\n >>> ser.mean()\n 2\n \"\"\"\n        pass\n\n    def fillna(self, value):\n  \"\"\"\n Replace missing values by ``value``.\n\n Examples\n --------\n >>> ser = pd.Series([1, np.nan, 3])\n >>> ser.fillna(0)\n [1, 0, 3]\n \"\"\"\n        pass\n\n    def groupby_mean(self):\n  \"\"\"\n Group by index and return mean.\n\n Examples\n --------\n >>> ser = pd.Series([380., 370., 24., 26],\n ...               name='max_speed',\n ...               index=['falcon', 'falcon', 'parrot', 'parrot'])\n >>> ser.groupby_mean()\n index\n falcon    375.0\n parrot     25.0\n Name: max_speed, dtype: float64\n \"\"\"\n        pass\n\n    def contains(self, pattern, case_sensitive=True, na=numpy.nan):\n  \"\"\"\n Return whether each value contains ``pattern``.\n\n In this case, we are illustrating how to use sections, even\n if the example is simple enough and does not require them.\n\n Examples\n --------\n >>> ser = pd.Series('Antelope', 'Lion', 'Zebra', np.nan)\n >>> ser.contains(pattern='a')\n 0    False\n 1    False\n 2     True\n 3      NaN\n dtype: bool\n\n **Case sensitivity**\n\n With ``case_sensitive`` set to ``False`` we can match ``a`` with both\n ``a`` and ``A``:\n\n >>> s.contains(pattern='a', case_sensitive=False)\n 0     True\n 1    False\n 2     True\n 3      NaN\n dtype: bool\n\n **Missing values**\n\n We can fill missing values in the output using the ``na`` parameter:\n\n >>> ser.contains(pattern='a', na=False)\n 0    False\n 1    False\n 2     True\n 3    False\n dtype: bool\n \"\"\"\n        pass \n```", "```py\ndef method(foo=None, bar=None):\n  \"\"\"\n A sample DataFrame method.\n\n Do not import NumPy and pandas.\n\n Try to use meaningful data, when it makes the example easier\n to understand.\n\n Try to avoid positional arguments like in ``df.method(1)``. They\n can be all right if previously defined with a meaningful name,\n like in ``present_value(interest_rate)``, but avoid them otherwise.\n\n When presenting the behavior with different parameters, do not place\n all the calls one next to the other. Instead, add a short sentence\n explaining what the example shows.\n\n Examples\n --------\n >>> import numpy as np\n >>> import pandas as pd\n >>> df = pd.DataFrame(np.random.randn(3, 3),\n ...                   columns=('a', 'b', 'c'))\n >>> df.method(1)\n 21\n >>> df.method(bar=14)\n 123\n \"\"\"\n    pass \n```", "```py\n    >>> np.random.seed(42)\n    >>> df = pd.DataFrame({'normal': np.random.normal(100, 5, 20)}) \n    ```", "```py\n    >>> df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], index=['a', 'b', 'c'],\n    ...                   columns=['A', 'B']) \n    ```", "```py\n    >>> pd.to_datetime([\"712-01-01\"])\n    Traceback (most recent call last):\n    OutOfBoundsDatetime: Out of bounds nanosecond timestamp: 712-01-01 00:00:00 \n    ```", "```py\n    >>> s.plot()\n    <matplotlib.axes._subplots.AxesSubplot at 0x7efd0c0b0690> \n    ```", "```py\n    >>> s.plot()  \n    <matplotlib.axes._subplots.AxesSubplot at ...> \n    ```", "```py\nclass Series:\n    def plot(self):\n  \"\"\"\n Generate a plot with the ``Series`` data.\n\n Examples\n --------\n\n .. plot::\n :context: close-figs\n\n >>> ser = pd.Series([1, 2, 3])\n >>> ser.plot()\n \"\"\"\n        pass \n```", "```py\nclass Parent:\n    @doc(klass=\"Parent\")\n    def my_function(self):\n  \"\"\"Apply my function to {klass}.\"\"\"\n        ...\n\nclass ChildA(Parent):\n    @doc(Parent.my_function, klass=\"ChildA\")\n    def my_function(self):\n        ...\n\nclass ChildB(Parent):\n    @doc(Parent.my_function, klass=\"ChildB\")\n    def my_function(self):\n        ... \n```", "```py\n>>> print(Parent.my_function.__doc__)\nApply my function to Parent.\n>>> print(ChildA.my_function.__doc__)\nApply my function to ChildA.\n>>> print(ChildB.my_function.__doc__)\nApply my function to ChildB. \n```", "```py\n@doc(template, **_shared_doc_kwargs)\ndef my_function(self):\n    ... \n```"]