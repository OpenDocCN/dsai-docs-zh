- en: Time series / date functionality
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/user_guide/timeseries.html](https://pandas.pydata.org/docs/user_guide/timeseries.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: pandas contains extensive capabilities and features for working with time series
    data for all domains. Using the NumPy `datetime64` and `timedelta64` dtypes, pandas
    has consolidated a large number of features from other Python libraries like `scikits.timeseries`
    as well as created a tremendous amount of new functionality for manipulating time
    series data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, pandas supports:'
  prefs: []
  type: TYPE_NORMAL
- en: Parsing time series information from various sources and formats
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Generate sequences of fixed-frequency dates and time spans
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Manipulating and converting date times with timezone information
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Resampling or converting a time series to a particular frequency
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Performing date and time arithmetic with absolute or relative time increments
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: pandas provides a relatively compact and self-contained set of tools for performing
    the above tasks and more.
  prefs: []
  type: TYPE_NORMAL
- en: '## Overview'
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas captures 4 general time related concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Date times: A specific date and time with timezone support. Similar to `datetime.datetime`
    from the standard library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Time deltas: An absolute time duration. Similar to `datetime.timedelta` from
    the standard library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Time spans: A span of time defined by a point in time and its associated frequency.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Date offsets: A relative time duration that respects calendar arithmetic. Similar
    to `dateutil.relativedelta.relativedelta` from the `dateutil` package.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Concept | Scalar Class | Array Class | pandas Data Type | Primary Creation
    Method |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Date times | `Timestamp` | `DatetimeIndex` | `datetime64[ns]` or `datetime64[ns,
    tz]` | `to_datetime` or `date_range` |'
  prefs: []
  type: TYPE_TB
- en: '| Time deltas | `Timedelta` | `TimedeltaIndex` | `timedelta64[ns]` | `to_timedelta`
    or `timedelta_range` |'
  prefs: []
  type: TYPE_TB
- en: '| Time spans | `Period` | `PeriodIndex` | `period[freq]` | `Period` or `period_range`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Date offsets | `DateOffset` | `None` | `None` | `DateOffset` |'
  prefs: []
  type: TYPE_TB
- en: For time series data, it’s conventional to represent the time component in the
    index of a [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    or [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    so manipulations can be performed with respect to the time element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: However, [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    and [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    can directly also support the time component as data itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    and [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    have extended data type support and functionality for `datetime`, `timedelta`
    and `Period` data when passed into those constructors. `DateOffset` data however
    will be stored as `object` data.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, pandas represents null date times, time deltas, and time spans as `NaT`
    which is useful for representing missing or null date like values and behaves
    similar as `np.nan` does for float data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]  ## Timestamps vs. time spans'
  prefs: []
  type: TYPE_NORMAL
- en: Timestamped data is the most basic type of time series data that associates
    values with points in time. For pandas objects it means using the points in time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: However, in many cases it is more natural to associate things like change variables
    with a time span instead. The span represented by `Period` can be specified explicitly,
    or inferred from datetime string format.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp "pandas.Timestamp")
    and [`Period`](../reference/api/pandas.Period.html#pandas.Period "pandas.Period")
    can serve as an index. Lists of `Timestamp` and `Period` are automatically coerced
    to [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") and [`PeriodIndex`](../reference/api/pandas.PeriodIndex.html#pandas.PeriodIndex
    "pandas.PeriodIndex") respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'pandas allows you to capture both representations and convert between them.
    Under the hood, pandas represents timestamps using instances of `Timestamp` and
    sequences of timestamps using instances of `DatetimeIndex`. For regular time spans,
    pandas uses `Period` objects for scalar values and `PeriodIndex` for sequences
    of spans. Better support for irregular intervals with arbitrary start and end
    points are forth-coming in future releases.  ## Converting to timestamps'
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    or list-like object of date-like objects e.g. strings, epochs, or a mixture, you
    can use the `to_datetime` function. When passed a `Series`, this returns a `Series`
    (with the same index), while a list-like is converted to a `DatetimeIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use dates which start with the day first (i.e. European style), you
    can pass the `dayfirst` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: You see in the above example that `dayfirst` isn’t strict. If a date can’t be
    parsed with the day being first it will be parsed as if `dayfirst` were `False`
    and a warning will also be raised.
  prefs: []
  type: TYPE_NORMAL
- en: If you pass a single string to `to_datetime`, it returns a single `Timestamp`.
    `Timestamp` can also accept string input, but it doesn’t accept string parsing
    options like `dayfirst` or `format`, so use `to_datetime` if these are required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `DatetimeIndex` constructor directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The string ‘infer’ can be passed in order to set the frequency of the index
    as the inferred frequency upon creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '### Providing a format argument'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the required datetime string, a `format` argument can be passed
    to ensure specific parsing. This could also potentially speed up the conversion
    considerably.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For more information on the choices available when specifying the `format` option,
    see the Python [datetime documentation](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior).
  prefs: []
  type: TYPE_NORMAL
- en: Assembling datetime from multiple DataFrame columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also pass a `DataFrame` of integer or string columns to assemble into
    a `Series` of `Timestamps`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can pass only the columns that you need to assemble.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.to_datetime` looks for standard designations of the datetime component
    in the column names, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'required: `year`, `month`, `day`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional: `hour`, `minute`, `second`, `millisecond`, `microsecond`, `nanosecond`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default behavior, `errors=''raise''`, is to raise when unparsable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass `errors=''coerce''` to convert unparsable data to `NaT` (not a time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '### Epoch timestamps'
  prefs: []
  type: TYPE_NORMAL
- en: pandas supports converting integer or float epoch times to `Timestamp` and `DatetimeIndex`.
    The default unit is nanoseconds, since that is how `Timestamp` objects are stored
    internally. However, epochs are often stored in another `unit` which can be specified.
    These are computed from the starting point specified by the `origin` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `unit` parameter does not use the same strings as the `format` parameter
    that was discussed [above](#timeseries-converting-format)). The available units
    are listed on the documentation for [`pandas.to_datetime()`](../reference/api/pandas.to_datetime.html#pandas.to_datetime
    "pandas.to_datetime").
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructing a [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") or [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") with an epoch timestamp with the `tz` argument specified
    will raise a ValueError. If you have epochs in wall time in another timezone,
    you can read the epochs as timezone-naive timestamps and then localize to the
    appropriate timezone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Epoch times will be rounded to the nearest nanosecond.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Conversion of float epoch times can lead to inaccurate and unexpected results.
    [Python floats](https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues
    "(in Python v3.12)") have about 15 digits precision in decimal. Rounding during
    conversion from float to high precision `Timestamp` is unavoidable. The only way
    to achieve exact precision is to use a fixed-width types (e.g. an int64).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the origin parameter](#timeseries-origin)  ### From timestamps to epoch'
  prefs: []
  type: TYPE_NORMAL
- en: 'To invert the operation from above, namely, to convert from a `Timestamp` to
    a ‘unix’ epoch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We subtract the epoch (midnight at January 1, 1970 UTC) and then floor divide
    by the “unit” (1 second).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]  ### Using the `origin` parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `origin` parameter, one can specify an alternative starting point
    for creation of a `DatetimeIndex`. For example, to use 1960-01-01 as the starting
    date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The default is set at `origin='unix'`, which defaults to `1970-01-01 00:00:00`.
    Commonly called ‘unix epoch’ or POSIX time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]  ## Generating ranges of timestamps'
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate an index with timestamps, you can use either the `DatetimeIndex`
    or `Index` constructor and pass in a list of datetime objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice this becomes very cumbersome because we often need a very long
    index with a large number of timestamps. If we need timestamps on a regular frequency,
    we can use the [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range") and [`bdate_range()`](../reference/api/pandas.bdate_range.html#pandas.bdate_range
    "pandas.bdate_range") functions to create a `DatetimeIndex`. The default frequency
    for `date_range` is a **calendar day** while the default for `bdate_range` is
    a **business day**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Convenience functions like `date_range` and `bdate_range` can utilize a variety
    of [frequency aliases](#timeseries-offset-aliases):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`date_range` and `bdate_range` make it easy to generate a range of dates using
    various combinations of parameters like `start`, `end`, `periods`, and `freq`.
    The start and end dates are strictly inclusive, so dates outside of those specified
    will not be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying `start`, `end`, and `periods` will generate a range of evenly spaced
    dates from `start` to `end` inclusively, with `periods` number of elements in
    the resulting `DatetimeIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '### Custom frequency ranges'
  prefs: []
  type: TYPE_NORMAL
- en: '`bdate_range` can also generate a range of custom frequency dates by using
    the `weekmask` and `holidays` parameters. These parameters will only be used if
    a custom frequency string is passed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Custom business days](#timeseries-custombusinessdays)  ## Timestamp limitations'
  prefs: []
  type: TYPE_NORMAL
- en: 'The limits of timestamp representation depend on the chosen resolution. For
    nanosecond resolution, the time span that can be represented using a 64-bit integer
    is limited to approximately 584 years:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: When choosing second-resolution, the available range grows to `+/- 2.9e11 years`.
    Different resolutions can be converted to each other through `as_unit`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Representing out-of-bounds spans](#timeseries-oob)  ## Indexing'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the main uses for `DatetimeIndex` is as an index for pandas objects.
    The `DatetimeIndex` class contains many time series related optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: A large range of dates for various offsets are pre-computed and cached under
    the hood in order to make generating subsequent date ranges very fast (just have
    to grab a slice).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast shifting using the `shift` method on pandas objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unioning of overlapping `DatetimeIndex` objects with the same frequency is very
    fast (important for fast data alignment).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick access to date fields via properties such as `year`, `month`, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularization functions like `snap` and very fast `asof` logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatetimeIndex` objects have all the basic functionality of regular `Index`
    objects, and a smorgasbord of advanced time series specific methods for easy frequency
    processing.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Reindexing methods](basics.html#basics-reindexing)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While pandas does not force you to have a sorted date index, some of these methods
    may have unexpected or incorrect behavior if the dates are unsorted.
  prefs: []
  type: TYPE_NORMAL
- en: '`DatetimeIndex` can be used like a regular index and offers all of its intelligent
    functionality like selection, slicing, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '### Partial string indexing'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dates and strings that parse to timestamps can be passed as indexing parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide convenience for accessing longer time series, you can also pass
    in the year or year and month as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of slicing will work on a `DataFrame` with a `DatetimeIndex` as well.
    Since the partial string selection is a form of label slicing, the endpoints **will
    be** included. This would include matching times on an included date:'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Indexing `DataFrame` rows with a *single* string with getitem (e.g. `frame[dtstring]`)
    is deprecated starting with pandas 1.2.0 (given the ambiguity whether it is indexing
    the rows or selecting a column) and will be removed in a future version. The equivalent
    with `.loc` (e.g. `frame.loc[dtstring]`) is still supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This starts on the very first time in the month, and includes the last date
    and time for the month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This specifies a stop time **that includes all of the times on the last day**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This specifies an **exact** stop time (and is not the same as the above):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We are stopping on the included end-point as it is part of the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`DatetimeIndex` partial string indexing also works on a `DataFrame` with a
    `MultiIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Slicing with string indexing also honors UTC offset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]  ### Slice vs. exact match'
  prefs: []
  type: TYPE_NORMAL
- en: The same string used as an indexing parameter can be treated either as a slice
    or as an exact match depending on the resolution of the index. If the string is
    less accurate than the index, it will be treated as a slice, otherwise as an exact
    match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a `Series` object with a minute resolution index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: A timestamp string less accurate than a minute gives a `Series` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: A timestamp string with minute resolution (or more accurate), gives a scalar
    instead, i.e. it is not casted to a slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If index resolution is second, then the minute-accurate timestamp gives a `Series`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If the timestamp string is treated as a slice, it can be used to index `DataFrame`
    with `.loc[]` as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the string is treated as an exact match, the selection in `DataFrame`’s
    `[]` will be column-wise and not row-wise, see [Indexing Basics](indexing.html#indexing-basics).
    For example `dft_minute[''2011-12-31 23:59'']` will raise `KeyError` as `''2012-12-31
    23:59''` has the same resolution as the index and there is no column with such
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: To *always* have unambiguous selection, whether the row is treated as a slice
    or a single selection, use `.loc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note also that `DatetimeIndex` resolution cannot be less precise than day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Exact indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in previous section, indexing a `DatetimeIndex` with a partial
    string depends on the “accuracy” of the period, in other words how specific the
    interval is in relation to the resolution of the index. In contrast, indexing
    with `Timestamp` or `datetime` objects is exact, because the objects have exact
    meaning. These also follow the semantics of *including both endpoints*.
  prefs: []
  type: TYPE_NORMAL
- en: These `Timestamp` and `datetime` objects have exact `hours, minutes,` and `seconds`,
    even though they were not explicitly specified (they are `0`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: With no defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Truncating & fancy indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A [`truncate()`](../reference/api/pandas.DataFrame.truncate.html#pandas.DataFrame.truncate
    "pandas.DataFrame.truncate") convenience function is provided that is similar
    to slicing. Note that `truncate` assumes a 0 value for any unspecified date component
    in a `DatetimeIndex` in contrast to slicing which returns any partially matching
    dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Even complicated fancy indexing that breaks the `DatetimeIndex` frequency regularity
    will result in a `DatetimeIndex`, although frequency is lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]  ## Time/date components'
  prefs: []
  type: TYPE_NORMAL
- en: There are several time/date properties that one can access from `Timestamp`
    or a collection of timestamps like a `DatetimeIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| year | The year of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| month | The month of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| day | The days of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| hour | The hour of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| minute | The minutes of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| second | The seconds of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| microsecond | The microseconds of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| nanosecond | The nanoseconds of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| date | Returns datetime.date (does not contain timezone information) |'
  prefs: []
  type: TYPE_TB
- en: '| time | Returns datetime.time (does not contain timezone information) |'
  prefs: []
  type: TYPE_TB
- en: '| timetz | Returns datetime.time as local time with timezone information |'
  prefs: []
  type: TYPE_TB
- en: '| dayofyear | The ordinal day of year |'
  prefs: []
  type: TYPE_TB
- en: '| day_of_year | The ordinal day of year |'
  prefs: []
  type: TYPE_TB
- en: '| weekofyear | The week ordinal of the year |'
  prefs: []
  type: TYPE_TB
- en: '| week | The week ordinal of the year |'
  prefs: []
  type: TYPE_TB
- en: '| dayofweek | The number of the day of the week with Monday=0, Sunday=6 |'
  prefs: []
  type: TYPE_TB
- en: '| day_of_week | The number of the day of the week with Monday=0, Sunday=6 |'
  prefs: []
  type: TYPE_TB
- en: '| weekday | The number of the day of the week with Monday=0, Sunday=6 |'
  prefs: []
  type: TYPE_TB
- en: '| quarter | Quarter of the date: Jan-Mar = 1, Apr-Jun = 2, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| days_in_month | The number of days in the month of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| is_month_start | Logical indicating if first day of month (defined by frequency)
    |'
  prefs: []
  type: TYPE_TB
- en: '| is_month_end | Logical indicating if last day of month (defined by frequency)
    |'
  prefs: []
  type: TYPE_TB
- en: '| is_quarter_start | Logical indicating if first day of quarter (defined by
    frequency) |'
  prefs: []
  type: TYPE_TB
- en: '| is_quarter_end | Logical indicating if last day of quarter (defined by frequency)
    |'
  prefs: []
  type: TYPE_TB
- en: '| is_year_start | Logical indicating if first day of year (defined by frequency)
    |'
  prefs: []
  type: TYPE_TB
- en: '| is_year_end | Logical indicating if last day of year (defined by frequency)
    |'
  prefs: []
  type: TYPE_TB
- en: '| is_leap_year | Logical indicating if the date belongs to a leap year |'
  prefs: []
  type: TYPE_TB
- en: Furthermore, if you have a `Series` with datetimelike values, then you can access
    these properties via the `.dt` accessor, as detailed in the section on [.dt accessors](basics.html#basics-dt-accessors).
  prefs: []
  type: TYPE_NORMAL
- en: 'You may obtain the year, week and day components of the ISO year from the ISO
    8601 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]  ## DateOffset objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, frequency strings (e.g. `''D''`) were used to specify
    a frequency that defined:'
  prefs: []
  type: TYPE_NORMAL
- en: how the date times in [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") were spaced when using [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the frequency of a [`Period`](../reference/api/pandas.Period.html#pandas.Period
    "pandas.Period") or [`PeriodIndex`](../reference/api/pandas.PeriodIndex.html#pandas.PeriodIndex
    "pandas.PeriodIndex")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These frequency strings map to a `DateOffset` object and its subclasses. A `DateOffset`
    is similar to a [`Timedelta`](../reference/api/pandas.Timedelta.html#pandas.Timedelta
    "pandas.Timedelta") that represents a duration of time but follows specific calendar
    duration rules. For example, a [`Timedelta`](../reference/api/pandas.Timedelta.html#pandas.Timedelta
    "pandas.Timedelta") day will always increment `datetimes` by 24 hours, while a
    `DateOffset` day will increment `datetimes` to the same time the next day whether
    a day represents 23, 24 or 25 hours due to daylight savings time. However, all
    `DateOffset` subclasses that are an hour or smaller (`Hour`, `Minute`, `Second`,
    `Milli`, `Micro`, `Nano`) behave like [`Timedelta`](../reference/api/pandas.Timedelta.html#pandas.Timedelta
    "pandas.Timedelta") and respect absolute time.
  prefs: []
  type: TYPE_NORMAL
- en: The basic `DateOffset` acts similar to `dateutil.relativedelta` ([relativedelta
    documentation](https://dateutil.readthedocs.io/en/stable/relativedelta.html))
    that shifts a date time by the corresponding calendar duration specified. The
    arithmetic operator (`+`) can be used to perform the shift.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Most `DateOffsets` have associated frequencies strings, or offset aliases,
    that can be passed into `freq` keyword arguments. The available date offsets and
    associated frequency strings can be found below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Date Offset | Frequency String | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`DateOffset`](../reference/api/pandas.tseries.offsets.DateOffset.html#pandas.tseries.offsets.DateOffset
    "pandas.tseries.offsets.DateOffset") | None | Generic offset class, defaults to
    absolute 24 hours |'
  prefs: []
  type: TYPE_TB
- en: '| [`BDay`](../reference/api/pandas.tseries.offsets.BDay.html#pandas.tseries.offsets.BDay
    "pandas.tseries.offsets.BDay") or [`BusinessDay`](../reference/api/pandas.tseries.offsets.BusinessDay.html#pandas.tseries.offsets.BusinessDay
    "pandas.tseries.offsets.BusinessDay") | `''B''` | business day (weekday) |'
  prefs: []
  type: TYPE_TB
- en: '| [`CDay`](../reference/api/pandas.tseries.offsets.CDay.html#pandas.tseries.offsets.CDay
    "pandas.tseries.offsets.CDay") or [`CustomBusinessDay`](../reference/api/pandas.tseries.offsets.CustomBusinessDay.html#pandas.tseries.offsets.CustomBusinessDay
    "pandas.tseries.offsets.CustomBusinessDay") | `''C''` | custom business day |'
  prefs: []
  type: TYPE_TB
- en: '| [`Week`](../reference/api/pandas.tseries.offsets.Week.html#pandas.tseries.offsets.Week
    "pandas.tseries.offsets.Week") | `''W''` | one week, optionally anchored on a
    day of the week |'
  prefs: []
  type: TYPE_TB
- en: '| [`WeekOfMonth`](../reference/api/pandas.tseries.offsets.WeekOfMonth.html#pandas.tseries.offsets.WeekOfMonth
    "pandas.tseries.offsets.WeekOfMonth") | `''WOM''` | the x-th day of the y-th week
    of each month |'
  prefs: []
  type: TYPE_TB
- en: '| [`LastWeekOfMonth`](../reference/api/pandas.tseries.offsets.LastWeekOfMonth.html#pandas.tseries.offsets.LastWeekOfMonth
    "pandas.tseries.offsets.LastWeekOfMonth") | `''LWOM''` | the x-th day of the last
    week of each month |'
  prefs: []
  type: TYPE_TB
- en: '| [`MonthEnd`](../reference/api/pandas.tseries.offsets.MonthEnd.html#pandas.tseries.offsets.MonthEnd
    "pandas.tseries.offsets.MonthEnd") | `''ME''` | calendar month end |'
  prefs: []
  type: TYPE_TB
- en: '| [`MonthBegin`](../reference/api/pandas.tseries.offsets.MonthBegin.html#pandas.tseries.offsets.MonthBegin
    "pandas.tseries.offsets.MonthBegin") | `''MS''` | calendar month begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`BMonthEnd`](../reference/api/pandas.tseries.offsets.BMonthEnd.html#pandas.tseries.offsets.BMonthEnd
    "pandas.tseries.offsets.BMonthEnd") or [`BusinessMonthEnd`](../reference/api/pandas.tseries.offsets.BusinessMonthEnd.html#pandas.tseries.offsets.BusinessMonthEnd
    "pandas.tseries.offsets.BusinessMonthEnd") | `''BME''` | business month end |'
  prefs: []
  type: TYPE_TB
- en: '| [`BMonthBegin`](../reference/api/pandas.tseries.offsets.BMonthBegin.html#pandas.tseries.offsets.BMonthBegin
    "pandas.tseries.offsets.BMonthBegin") or [`BusinessMonthBegin`](../reference/api/pandas.tseries.offsets.BusinessMonthBegin.html#pandas.tseries.offsets.BusinessMonthBegin
    "pandas.tseries.offsets.BusinessMonthBegin") | `''BMS''` | business month begin
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`CBMonthEnd`](../reference/api/pandas.tseries.offsets.CBMonthEnd.html#pandas.tseries.offsets.CBMonthEnd
    "pandas.tseries.offsets.CBMonthEnd") or [`CustomBusinessMonthEnd`](../reference/api/pandas.tseries.offsets.CustomBusinessMonthEnd.html#pandas.tseries.offsets.CustomBusinessMonthEnd
    "pandas.tseries.offsets.CustomBusinessMonthEnd") | `''CBME''` | custom business
    month end |'
  prefs: []
  type: TYPE_TB
- en: '| [`CBMonthBegin`](../reference/api/pandas.tseries.offsets.CBMonthBegin.html#pandas.tseries.offsets.CBMonthBegin
    "pandas.tseries.offsets.CBMonthBegin") or [`CustomBusinessMonthBegin`](../reference/api/pandas.tseries.offsets.CustomBusinessMonthBegin.html#pandas.tseries.offsets.CustomBusinessMonthBegin
    "pandas.tseries.offsets.CustomBusinessMonthBegin") | `''CBMS''` | custom business
    month begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`SemiMonthEnd`](../reference/api/pandas.tseries.offsets.SemiMonthEnd.html#pandas.tseries.offsets.SemiMonthEnd
    "pandas.tseries.offsets.SemiMonthEnd") | `''SME''` | 15th (or other day_of_month)
    and calendar month end |'
  prefs: []
  type: TYPE_TB
- en: '| [`SemiMonthBegin`](../reference/api/pandas.tseries.offsets.SemiMonthBegin.html#pandas.tseries.offsets.SemiMonthBegin
    "pandas.tseries.offsets.SemiMonthBegin") | `''SMS''` | 15th (or other day_of_month)
    and calendar month begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`QuarterEnd`](../reference/api/pandas.tseries.offsets.QuarterEnd.html#pandas.tseries.offsets.QuarterEnd
    "pandas.tseries.offsets.QuarterEnd") | `''QE''` | calendar quarter end |'
  prefs: []
  type: TYPE_TB
- en: '| [`QuarterBegin`](../reference/api/pandas.tseries.offsets.QuarterBegin.html#pandas.tseries.offsets.QuarterBegin
    "pandas.tseries.offsets.QuarterBegin") | `''QS''` | calendar quarter begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`BQuarterEnd`](../reference/api/pandas.tseries.offsets.BQuarterEnd.html#pandas.tseries.offsets.BQuarterEnd
    "pandas.tseries.offsets.BQuarterEnd") | `''BQE` | business quarter end |'
  prefs: []
  type: TYPE_TB
- en: '| [`BQuarterBegin`](../reference/api/pandas.tseries.offsets.BQuarterBegin.html#pandas.tseries.offsets.BQuarterBegin
    "pandas.tseries.offsets.BQuarterBegin") | `''BQS''` | business quarter begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`FY5253Quarter`](../reference/api/pandas.tseries.offsets.FY5253Quarter.html#pandas.tseries.offsets.FY5253Quarter
    "pandas.tseries.offsets.FY5253Quarter") | `''REQ''` | retail (aka 52-53 week)
    quarter |'
  prefs: []
  type: TYPE_TB
- en: '| [`YearEnd`](../reference/api/pandas.tseries.offsets.YearEnd.html#pandas.tseries.offsets.YearEnd
    "pandas.tseries.offsets.YearEnd") | `''YE''` | calendar year end |'
  prefs: []
  type: TYPE_TB
- en: '| [`YearBegin`](../reference/api/pandas.tseries.offsets.YearBegin.html#pandas.tseries.offsets.YearBegin
    "pandas.tseries.offsets.YearBegin") | `''YS''` or `''BYS''` | calendar year begin
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`BYearEnd`](../reference/api/pandas.tseries.offsets.BYearEnd.html#pandas.tseries.offsets.BYearEnd
    "pandas.tseries.offsets.BYearEnd") | `''BYE''` | business year end |'
  prefs: []
  type: TYPE_TB
- en: '| [`BYearBegin`](../reference/api/pandas.tseries.offsets.BYearBegin.html#pandas.tseries.offsets.BYearBegin
    "pandas.tseries.offsets.BYearBegin") | `''BYS''` | business year begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`FY5253`](../reference/api/pandas.tseries.offsets.FY5253.html#pandas.tseries.offsets.FY5253
    "pandas.tseries.offsets.FY5253") | `''RE''` | retail (aka 52-53 week) year |'
  prefs: []
  type: TYPE_TB
- en: '| [`Easter`](../reference/api/pandas.tseries.offsets.Easter.html#pandas.tseries.offsets.Easter
    "pandas.tseries.offsets.Easter") | None | Easter holiday |'
  prefs: []
  type: TYPE_TB
- en: '| [`BusinessHour`](../reference/api/pandas.tseries.offsets.BusinessHour.html#pandas.tseries.offsets.BusinessHour
    "pandas.tseries.offsets.BusinessHour") | `''bh''` | business hour |'
  prefs: []
  type: TYPE_TB
- en: '| [`CustomBusinessHour`](../reference/api/pandas.tseries.offsets.CustomBusinessHour.html#pandas.tseries.offsets.CustomBusinessHour
    "pandas.tseries.offsets.CustomBusinessHour") | `''cbh''` | custom business hour
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Day`](../reference/api/pandas.tseries.offsets.Day.html#pandas.tseries.offsets.Day
    "pandas.tseries.offsets.Day") | `''D''` | one absolute day |'
  prefs: []
  type: TYPE_TB
- en: '| [`Hour`](../reference/api/pandas.tseries.offsets.Hour.html#pandas.tseries.offsets.Hour
    "pandas.tseries.offsets.Hour") | `''h''` | one hour |'
  prefs: []
  type: TYPE_TB
- en: '| [`Minute`](../reference/api/pandas.tseries.offsets.Minute.html#pandas.tseries.offsets.Minute
    "pandas.tseries.offsets.Minute") | `''min''` | one minute |'
  prefs: []
  type: TYPE_TB
- en: '| [`Second`](../reference/api/pandas.tseries.offsets.Second.html#pandas.tseries.offsets.Second
    "pandas.tseries.offsets.Second") | `''s''` | one second |'
  prefs: []
  type: TYPE_TB
- en: '| [`Milli`](../reference/api/pandas.tseries.offsets.Milli.html#pandas.tseries.offsets.Milli
    "pandas.tseries.offsets.Milli") | `''ms''` | one millisecond |'
  prefs: []
  type: TYPE_TB
- en: '| [`Micro`](../reference/api/pandas.tseries.offsets.Micro.html#pandas.tseries.offsets.Micro
    "pandas.tseries.offsets.Micro") | `''us''` | one microsecond |'
  prefs: []
  type: TYPE_TB
- en: '| [`Nano`](../reference/api/pandas.tseries.offsets.Nano.html#pandas.tseries.offsets.Nano
    "pandas.tseries.offsets.Nano") | `''ns''` | one nanosecond |'
  prefs: []
  type: TYPE_TB
- en: '`DateOffsets` additionally have `rollforward()` and `rollback()` methods for
    moving a date forward or backward respectively to a valid offset date relative
    to the offset. For example, business offsets will roll dates that land on the
    weekends (Saturday and Sunday) forward to Monday since business offsets operate
    on the weekdays.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: These operations preserve time (hour, minute, etc) information by default. To
    reset time to midnight, use `normalize()` before or after applying the operation
    (depending on whether you want the time information included in the operation).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Parametric offsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the offsets can be “parameterized” when created to result in different
    behaviors. For example, the `Week` offset for generating weekly data accepts a
    `weekday` parameter which results in the generated dates always lying on a particular
    day of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `normalize` option will be effective for addition and subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example is parameterizing `YearEnd` with the specific ending month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '### Using offsets with `Series` / `DatetimeIndex`'
  prefs: []
  type: TYPE_NORMAL
- en: Offsets can be used with either a `Series` or `DatetimeIndex` to apply the offset
    to each element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: If the offset class maps directly to a `Timedelta` (`Day`, `Hour`, `Minute`,
    `Second`, `Micro`, `Milli`, `Nano`) it can be used exactly like a `Timedelta`
    - see the [Timedelta section](timedeltas.html#timedeltas-operations) for more
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Note that some offsets (such as `BQuarterEnd`) do not have a vectorized implementation.
    They can still be used but may calculate significantly slower and will show a
    `PerformanceWarning`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]  ### Custom business days'
  prefs: []
  type: TYPE_NORMAL
- en: The `CDay` or `CustomBusinessDay` class provides a parametric `BusinessDay`
    class which can be used to create customized business day calendars which account
    for local holidays and local weekend conventions.
  prefs: []
  type: TYPE_NORMAL
- en: As an interesting example, let’s look at Egypt where a Friday-Saturday weekend
    is observed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s map to the weekday names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Holiday calendars can be used to provide the list of holidays. See the [holiday
    calendar](#timeseries-holiday) section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Monthly offsets that respect a certain holiday calendar can be defined in the
    usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The frequency string ‘C’ is used to indicate that a CustomBusinessDay DateOffset
    is used, it is important to note that since CustomBusinessDay is a parameterised
    type, instances of CustomBusinessDay may differ and this is not detectable from
    the ‘C’ frequency string. The user therefore needs to ensure that the ‘C’ frequency
    string is used consistently within the user’s application.  ### Business hour'
  prefs: []
  type: TYPE_NORMAL
- en: The `BusinessHour` class provides a business hour representation on `BusinessDay`,
    allowing to use specific start and end times.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `BusinessHour` uses 9:00 - 17:00 as business hours. Adding `BusinessHour`
    will increment `Timestamp` by hourly frequency. If target `Timestamp` is out of
    business hours, move to the next business hour then increment it. If the result
    exceeds the business hours end, the remaining hours are added to the next business
    day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: You can also specify `start` and `end` time by keywords. The argument must be
    a `str` with an `hour:minute` representation or a `datetime.time` instance. Specifying
    seconds, microseconds and nanoseconds as business hour results in `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Passing `start` time later than `end` represents midnight business hour. In
    this case, business hour exceeds midnight and overlap to the next day. Valid business
    hours are distinguished by whether it started from valid `BusinessDay`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Applying `BusinessHour.rollforward` and `rollback` to out of business hours
    results in the next business hour start or previous day’s end. Different from
    other offsets, `BusinessHour.rollforward` may output different results from `apply`
    by definition.
  prefs: []
  type: TYPE_NORMAL
- en: This is because one day’s business hour end is equal to next day’s business
    hour start. For example, under the default business hours (9:00 - 17:00), there
    is no gap (0 minutes) between `2014-08-01 17:00` and `2014-08-04 09:00`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`BusinessHour` regards Saturday and Sunday as holidays. To use arbitrary holidays,
    you can use `CustomBusinessHour` offset, as explained in the following subsection.  ###
    Custom business hour'
  prefs: []
  type: TYPE_NORMAL
- en: The `CustomBusinessHour` is a mixture of `BusinessHour` and `CustomBusinessDay`
    which allows you to specify arbitrary holidays. `CustomBusinessHour` works as
    the same as `BusinessHour` except that it skips specified custom holidays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: You can use keyword arguments supported by either `BusinessHour` and `CustomBusinessDay`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]  ### Offset aliases'
  prefs: []
  type: TYPE_NORMAL
- en: A number of string aliases are given to useful common time series frequencies.
    We will refer to these aliases as *offset aliases*.
  prefs: []
  type: TYPE_NORMAL
- en: '| Alias | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| B | business day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| C | custom business day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| D | calendar day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| W | weekly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| ME | month end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| SME | semi-month end frequency (15th and end of month) |'
  prefs: []
  type: TYPE_TB
- en: '| BME | business month end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| CBME | custom business month end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| MS | month start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| SMS | semi-month start frequency (1st and 15th) |'
  prefs: []
  type: TYPE_TB
- en: '| BMS | business month start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| CBMS | custom business month start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| QE | quarter end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BQE | business quarter end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| QS | quarter start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BQS | business quarter start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| YE | year end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BYE | business year end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| YS | year start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BYS | business year start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| h | hourly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| bh | business hour frequency |'
  prefs: []
  type: TYPE_TB
- en: '| cbh | custom business hour frequency |'
  prefs: []
  type: TYPE_TB
- en: '| min | minutely frequency |'
  prefs: []
  type: TYPE_TB
- en: '| s | secondly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| ms | milliseconds |'
  prefs: []
  type: TYPE_TB
- en: '| us | microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| ns | nanoseconds |'
  prefs: []
  type: TYPE_TB
- en: 'Deprecated since version 2.2.0: Aliases `H`, `BH`, `CBH`, `T`, `S`, `L`, `U`,
    and `N` are deprecated in favour of the aliases `h`, `bh`, `cbh`, `min`, `s`,
    `ms`, `us`, and `ns`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using the offset aliases above, it should be noted that functions such
    as [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range"), [`bdate_range()`](../reference/api/pandas.bdate_range.html#pandas.bdate_range
    "pandas.bdate_range"), will only return timestamps that are in the interval defined
    by `start_date` and `end_date`. If the `start_date` does not correspond to the
    frequency, the returned timestamps will start at the next valid timestamp, same
    for `end_date`, the returned timestamps will stop at the previous valid timestamp.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, for the offset `MS`, if the `start_date` is not the first of the
    month, the returned timestamps will start with the first day of the next month.
    If `end_date` is not the first day of a month, the last returned timestamp will
    be the first day of the corresponding month.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the above example [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range") and [`bdate_range()`](../reference/api/pandas.bdate_range.html#pandas.bdate_range
    "pandas.bdate_range") will only return the valid timestamps between the `start_date`
    and `end_date`. If these are not valid timestamps for the given frequency it will
    roll to the next value for `start_date` (respectively previous for the `end_date`)  ###
    Period aliases'
  prefs: []
  type: TYPE_NORMAL
- en: A number of string aliases are given to useful common time series frequencies.
    We will refer to these aliases as *period aliases*.
  prefs: []
  type: TYPE_NORMAL
- en: '| Alias | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| B | business day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| D | calendar day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| W | weekly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| M | monthly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| Q | quarterly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| Y | yearly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| h | hourly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| min | minutely frequency |'
  prefs: []
  type: TYPE_TB
- en: '| s | secondly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| ms | milliseconds |'
  prefs: []
  type: TYPE_TB
- en: '| us | microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| ns | nanoseconds |'
  prefs: []
  type: TYPE_TB
- en: 'Deprecated since version 2.2.0: Aliases `A`, `H`, `T`, `S`, `L`, `U`, and `N`
    are deprecated in favour of the aliases `Y`, `h`, `min`, `s`, `ms`, `us`, and
    `ns`.'
  prefs: []
  type: TYPE_NORMAL
- en: Combining aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have seen previously, the alias and the offset instance are fungible
    in most functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine together day and intraday offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Anchored offsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For some frequencies you can specify an anchoring suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Alias | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| W-SUN | weekly frequency (Sundays). Same as ‘W’ |'
  prefs: []
  type: TYPE_TB
- en: '| W-MON | weekly frequency (Mondays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-TUE | weekly frequency (Tuesdays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-WED | weekly frequency (Wednesdays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-THU | weekly frequency (Thursdays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-FRI | weekly frequency (Fridays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-SAT | weekly frequency (Saturdays) |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-DEC | quarterly frequency, year ends in December. Same as ‘QE’
    |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-JAN | quarterly frequency, year ends in January |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-FEB | quarterly frequency, year ends in February |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-MAR | quarterly frequency, year ends in March |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-APR | quarterly frequency, year ends in April |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-MAY | quarterly frequency, year ends in May |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-JUN | quarterly frequency, year ends in June |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-JUL | quarterly frequency, year ends in July |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-AUG | quarterly frequency, year ends in August |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-SEP | quarterly frequency, year ends in September |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-OCT | quarterly frequency, year ends in October |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-NOV | quarterly frequency, year ends in November |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-DEC | annual frequency, anchored end of December. Same as ‘YE’
    |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-JAN | annual frequency, anchored end of January |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-FEB | annual frequency, anchored end of February |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-MAR | annual frequency, anchored end of March |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-APR | annual frequency, anchored end of April |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-MAY | annual frequency, anchored end of May |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-JUN | annual frequency, anchored end of June |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-JUL | annual frequency, anchored end of July |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-AUG | annual frequency, anchored end of August |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-SEP | annual frequency, anchored end of September |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-OCT | annual frequency, anchored end of October |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-NOV | annual frequency, anchored end of November |'
  prefs: []
  type: TYPE_TB
- en: These can be used as arguments to `date_range`, `bdate_range`, constructors
    for `DatetimeIndex`, as well as various other timeseries-related functions in
    pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Anchored offset semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those offsets that are anchored to the start or end of specific frequency
    (`MonthEnd`, `MonthBegin`, `WeekEnd`, etc), the following rules apply to rolling
    forward and backwards.
  prefs: []
  type: TYPE_NORMAL
- en: When `n` is not 0, if the given date is not on an anchor point, it snapped to
    the next(previous) anchor point, and moved `|n|-1` additional steps forwards or
    backwards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: If the given date *is* on an anchor point, it is moved `|n|` points forwards
    or backwards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: For the case when `n=0`, the date is not moved if on an anchor point, otherwise
    it is rolled forward to the next anchor point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '### Holidays / holiday calendars'
  prefs: []
  type: TYPE_NORMAL
- en: Holidays and calendars provide a simple way to define holiday rules to be used
    with `CustomBusinessDay` or in other analysis that requires a predefined set of
    holidays. The `AbstractHolidayCalendar` class provides all the necessary methods
    to return a list of holidays and only `rules` need to be defined in a specific
    holiday calendar class. Furthermore, the `start_date` and `end_date` class attributes
    determine over what date range holidays are generated. These should be overwritten
    on the `AbstractHolidayCalendar` class to have the range apply to all calendar
    subclasses. `USFederalHolidayCalendar` is the only calendar that exists and primarily
    serves as an example for developing other calendars.
  prefs: []
  type: TYPE_NORMAL
- en: 'For holidays that occur on fixed dates (e.g., US Memorial Day or July 4th)
    an observance rule determines when that holiday is observed if it falls on a weekend
    or some other non-observed day. Defined observance rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Rule | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| nearest_workday | move Saturday to Friday and Sunday to Monday |'
  prefs: []
  type: TYPE_TB
- en: '| sunday_to_monday | move Sunday to following Monday |'
  prefs: []
  type: TYPE_TB
- en: '| next_monday_or_tuesday | move Saturday to Monday and Sunday/Monday to Tuesday
    |'
  prefs: []
  type: TYPE_TB
- en: '| previous_friday | move Saturday and Sunday to previous Friday” |'
  prefs: []
  type: TYPE_TB
- en: '| next_monday | move Saturday and Sunday to following Monday |'
  prefs: []
  type: TYPE_TB
- en: 'An example of how holidays and holiday calendars are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '**weekday=MO(2)** is same as **2 * Week(weekday=2)**'
  prefs: []
  type: TYPE_NORMAL
- en: Using this calendar, creating an index or doing offset arithmetic skips weekends
    and holidays (i.e., Memorial Day/July 4th). For example, the below defines a custom
    business day offset using the `ExampleCalendar`. Like any other offset, it can
    be used to create a `DatetimeIndex` or added to `datetime` or `Timestamp` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Ranges are defined by the `start_date` and `end_date` class attributes of `AbstractHolidayCalendar`.
    The defaults are shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: These dates can be overwritten by setting the attributes as datetime/Timestamp/string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Every calendar class is accessible by name using the `get_calendar` function
    which returns a holiday class instance. Any imported calendar class will automatically
    be available by this function. Also, `HolidayCalendarFactory` provides an easy
    interface to create calendars that are combinations of calendars or calendars
    with additional rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]  ## Time Series-related instance methods'
  prefs: []
  type: TYPE_NORMAL
- en: Shifting / lagging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One may want to *shift* or *lag* the values in a time series back and forward
    in time. The method for this is [`shift()`](../reference/api/pandas.Series.shift.html#pandas.Series.shift
    "pandas.Series.shift"), which is available on all of the pandas objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: The `shift` method accepts an `freq` argument which can accept a `DateOffset`
    class or other `timedelta`-like object or also an [offset alias](#timeseries-offset-aliases).
  prefs: []
  type: TYPE_NORMAL
- en: 'When `freq` is specified, `shift` method changes all the dates in the index
    rather than changing the alignment of the data and the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Note that with when `freq` is specified, the leading entry is no longer NaN
    because the data is not being realigned.
  prefs: []
  type: TYPE_NORMAL
- en: Frequency conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary function for changing frequencies is the [`asfreq()`](../reference/api/pandas.Series.asfreq.html#pandas.Series.asfreq
    "pandas.Series.asfreq") method. For a `DatetimeIndex`, this is basically just
    a thin, but convenient wrapper around [`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") which generates a `date_range` and calls `reindex`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '`asfreq` provides a further convenience so you can specify an interpolation
    method for any gaps that may appear after the frequency conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Filling forward / backward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Related to `asfreq` and `reindex` is [`fillna()`](../reference/api/pandas.Series.fillna.html#pandas.Series.fillna
    "pandas.Series.fillna"), which is documented in the [missing data section](missing_data.html#missing-data-fillna).
  prefs: []
  type: TYPE_NORMAL
- en: Converting to Python datetimes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`DatetimeIndex` can be converted to an array of Python native [`datetime.datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime
    "(in Python v3.12)") objects using the `to_pydatetime` method.  ## Resampling'
  prefs: []
  type: TYPE_NORMAL
- en: pandas has a simple, powerful, and efficient functionality for performing resampling
    operations during frequency conversion (e.g., converting secondly data into 5-minutely
    data). This is extremely common in, but not limited to, financial applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[`resample()`](../reference/api/pandas.Series.resample.html#pandas.Series.resample
    "pandas.Series.resample") is a time-based groupby, followed by a reduction method
    on each of its groups. See some [cookbook examples](cookbook.html#cookbook-resample)
    for some advanced strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: The `resample()` method can be used directly from `DataFrameGroupBy` objects,
    see the [groupby docs](groupby.html#groupby-transform-window-resample).
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The `resample` function is very flexible and allows you to specify many different
    parameters to control the frequency conversion and resampling operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any built-in method available via [GroupBy](../reference/groupby.html#api-groupby)
    is available as a method of the returned object, including `sum`, `mean`, `std`,
    `sem`, `max`, `min`, `median`, `first`, `last`, `ohlc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'For downsampling, `closed` can be set to ‘left’ or ‘right’ to specify which
    end of the interval is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Parameters like `label` are used to manipulate the resulting labels. `label`
    specifies whether the result is labeled with the beginning or the end of the interval.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The default values for `label` and `closed` is ‘**left**’ for all frequency
    offsets except for ‘ME’, ‘YE’, ‘QE’, ‘BME’, ‘BYE’, ‘BQE’, and ‘W’ which all have
    a default of ‘right’.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might unintendedly lead to looking ahead, where the value for a later
    time is pulled back to a previous time as in the following example with the [`BusinessDay`](../reference/api/pandas.tseries.offsets.BusinessDay.html#pandas.tseries.offsets.BusinessDay
    "pandas.tseries.offsets.BusinessDay") frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the value for Sunday got pulled back to the previous Friday. To get
    the behavior where the value for Sunday is pushed to Monday, use instead
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The `axis` parameter can be set to 0 or 1 and allows you to resample the specified
    axis for a `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: '`kind` can be set to ‘timestamp’ or ‘period’ to convert the resulting index
    to/from timestamp and time span representations. By default `resample` retains
    the input representation.'
  prefs: []
  type: TYPE_NORMAL
- en: '`convention` can be set to ‘start’ or ‘end’ when resampling period data (detail
    below). It specifies how low frequency periods are converted to higher frequency
    periods.'
  prefs: []
  type: TYPE_NORMAL
- en: Upsampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For upsampling, you can specify a way to upsample and the `limit` parameter
    to interpolate over the gaps that are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Sparse resampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sparse timeseries are the ones where you have a lot fewer points relative to
    the amount of time you are looking to resample. Naively upsampling a sparse series
    can potentially generate lots of intermediate values. When you don’t want to use
    a method to fill these values, e.g. `fill_method` is `None`, then intermediate
    values will be filled with `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `resample` is a time-based groupby, the following is a method to efficiently
    resample only the groups that are not all `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to resample to the full range of the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instead only resample those groups where we have points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '### Aggregation'
  prefs: []
  type: TYPE_NORMAL
- en: The `resample()` method returns a `pandas.api.typing.Resampler` instance. Similar
    to the [aggregating API](basics.html#basics-aggregate), [groupby API](groupby.html#groupby-aggregate),
    and the [window API](window.html#window-overview), a `Resampler` can be selectively
    resampled.
  prefs: []
  type: TYPE_NORMAL
- en: Resampling a `DataFrame`, the default will be to act on all columns with the
    same function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: We can select a specific column or columns using standard getitem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass a list or dict of functions to do aggregation with, outputting
    a `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'On a resampled `DataFrame`, you can pass a list of functions to apply to each
    column, which produces an aggregated result with a hierarchical index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing a dict to `aggregate` you can apply a different aggregation to the
    columns of a `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The function names can also be strings. In order for a string to be valid it
    must be implemented on the resampled object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, you can also specify multiple aggregation functions for each column
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: If a `DataFrame` does not have a datetimelike index, but instead you want to
    resample based on datetimelike column in the frame, it can passed to the `on`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, if you instead want to resample by a datetimelike level of `MultiIndex`,
    its name or location can be passed to the `level` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]  ### Iterating through groups'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Resampler` object in hand, iterating through the grouped data is
    very natural and functions similarly to [`itertools.groupby()`](https://docs.python.org/3/library/itertools.html#itertools.groupby
    "(in Python v3.12)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'See [Iterating through groups](groupby.html#groupby-iterating-label) or `Resampler.__iter__`
    for more.  ### Use `origin` or `offset` to adjust the start of the bins'
  prefs: []
  type: TYPE_NORMAL
- en: The bins of the grouping are adjusted based on the beginning of the day of the
    time series starting point. This works well with frequencies that are multiples
    of a day (like `30D`) or that divide a day evenly (like `90s` or `1min`). This
    can create inconsistencies with some frequencies that do not meet this criteria.
    To change this behavior you can specify a fixed Timestamp with the argument `origin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that, when using `origin` with its default value (`''start_day''`),
    the result after `''2000-10-02 00:00:00''` are not identical depending on the
    start of time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that, when setting `origin` to `''epoch''`, the result after
    `''2000-10-02 00:00:00''` are identical depending on the start of time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'If needed you can use a custom timestamp for `origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'If needed you can just adjust the bins with an `offset` Timedelta that would
    be added to the default `origin`. Those two examples are equivalent for this time
    series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `'start'` for `origin` on the last example. In that case, `origin`
    will be set to the first value of the timeseries.
  prefs: []
  type: TYPE_NORMAL
- en: Backward resample
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New in version 1.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of adjusting the beginning of bins, sometimes we need to fix the end
    of the bins to make a backward resample with a given `freq`. The backward resample
    sets `closed` to `'right'` by default since the last value should be considered
    as the edge point for the last bin.
  prefs: []
  type: TYPE_NORMAL
- en: We can set `origin` to `'end'`. The value for a specific `Timestamp` index stands
    for the resample result from the current `Timestamp` minus `freq` to the current
    `Timestamp` with a right close.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Besides, in contrast with the `'start_day'` option, `end_day` is supported.
    This will set the origin as the ceiling midnight of the largest `Timestamp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The above result uses `2000-10-02 00:29:00` as the last bin’s right edge since
    the following computation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]  ## Time span representation'
  prefs: []
  type: TYPE_NORMAL
- en: Regular intervals of time are represented by `Period` objects in pandas while
    sequences of `Period` objects are collected in a `PeriodIndex`, which can be created
    with the convenience function `period_range`.
  prefs: []
  type: TYPE_NORMAL
- en: Period
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Period` represents a span of time (e.g., a day, a month, a quarter, etc).
    You can specify the span via `freq` keyword using a frequency alias like below.
    Because `freq` represents a span of `Period`, it cannot be negative like “-3D”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Adding and subtracting integers from periods shifts the period by its own frequency.
    Arithmetic is not allowed between `Period` with different `freq` (span).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: If `Period` freq is daily or higher (`D`, `h`, `min`, `s`, `ms`, `us`, and `ns`),
    `offsets` and `timedelta`-like can be added if the result can have the same freq.
    Otherwise, `ValueError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: If `Period` has other frequencies, only the same `offsets` can be added. Otherwise,
    `ValueError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking the difference of `Period` instances with the same frequency will return
    the number of frequency units between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: PeriodIndex and period_range
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regular sequences of `Period` objects can be collected in a `PeriodIndex`,
    which can be constructed using the `period_range` convenience function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PeriodIndex` constructor can also be used directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Passing multiplied frequency outputs a sequence of `Period` which has multiplied
    span.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: If `start` or `end` are `Period` objects, they will be used as anchor endpoints
    for a `PeriodIndex` with frequency matching that of the `PeriodIndex` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like `DatetimeIndex`, a `PeriodIndex` can also be used to index pandas
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '`PeriodIndex` supports addition and subtraction with the same rule as `Period`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '`PeriodIndex` has its own dtype named `period`, refer to [Period Dtypes](#timeseries-period-dtype).'
  prefs: []
  type: TYPE_NORMAL
- en: '### Period dtypes'
  prefs: []
  type: TYPE_NORMAL
- en: '`PeriodIndex` has a custom `period` dtype. This is a pandas extension dtype
    similar to the [timezone aware dtype](#timeseries-timezone-series) (`datetime64[ns,
    tz]`).'
  prefs: []
  type: TYPE_NORMAL
- en: The `period` dtype holds the `freq` attribute and is represented with `period[freq]`
    like `period[D]` or `period[M]`, using [frequency strings](#timeseries-period-aliases).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'The `period` dtype can be used in `.astype(...)`. It allows one to change the
    `freq` of a `PeriodIndex` like `.asfreq()` and convert a `DatetimeIndex` to `PeriodIndex`
    like `to_period()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: PeriodIndex partial string indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PeriodIndex now supports partial string slicing with non-monotonic indexes.
  prefs: []
  type: TYPE_NORMAL
- en: You can pass in dates and strings to `Series` and `DataFrame` with `PeriodIndex`,
    in the same manner as `DatetimeIndex`. For details, refer to [DatetimeIndex Partial
    String Indexing](#timeseries-partialindexing).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Passing a string representing a lower frequency than `PeriodIndex` returns partial
    sliced data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: As with `DatetimeIndex`, the endpoints will be included in the result. The example
    below slices data starting from 10:00 to 11:59.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Frequency conversion and resampling with PeriodIndex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The frequency of `Period` and `PeriodIndex` can be converted via the `asfreq`
    method. Let’s start with the fiscal year 2011, ending in December:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert it to a monthly frequency. Using the `how` parameter, we can
    specify whether to return the starting or ending month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The shorthands ‘s’ and ‘e’ are provided for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting to a “super-period” (e.g., annual frequency is a super-period of
    quarterly frequency) automatically returns the super-period that includes the
    input period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Note that since we converted to an annual frequency that ends the year in November,
    the monthly period of December 2011 is actually in the 2012 Y-NOV period.
  prefs: []
  type: TYPE_NORMAL
- en: Period conversions with anchored frequencies are particularly useful for working
    with various quarterly data common to economics, business, and other fields. Many
    organizations define quarters relative to the month in which their fiscal year
    starts and ends. Thus, first quarter of 2011 could start in 2010 or a few months
    into 2011\. Via anchored frequencies, pandas works for all quarterly frequencies
    `Q-JAN` through `Q-DEC`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Q-DEC` define regular calendar quarters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '`Q-MAR` defines fiscal year end in March:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]  ## Converting between representations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Timestamped data can be converted to PeriodIndex-ed data using `to_period`
    and vice-versa using `to_timestamp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that ‘s’ and ‘e’ can be used to return the timestamps at the start
    or end of the period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting between period and timestamp enables some convenient arithmetic
    functions to be used. In the following example, we convert a quarterly frequency
    with year ending in November to 9am of the end of the month following the quarter
    end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]  ## Representing out-of-bounds spans'
  prefs: []
  type: TYPE_NORMAL
- en: If you have data that is outside of the `Timestamp` bounds, see [Timestamp limitations](#timeseries-timestamp-limits),
    then you can use a `PeriodIndex` and/or `Series` of `Periods` to do computations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: To convert from an `int64` based YYYYMMDD representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'These can easily be converted to a `PeriodIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]  ## Time zone handling'
  prefs: []
  type: TYPE_NORMAL
- en: pandas provides rich support for working with timestamps in different time zones
    using the `pytz` and `dateutil` libraries or [`datetime.timezone`](https://docs.python.org/3/library/datetime.html#datetime.timezone
    "(in Python v3.12)") objects from the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Working with time zones
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, pandas objects are time zone unaware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: To localize these dates to a time zone (assign a particular time zone to a naive
    date), you can use the `tz_localize` method or the `tz` keyword argument in [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range"), [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp"), or [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex"). You can either pass `pytz` or `dateutil` time zone objects
    or Olson time zone database strings. Olson time zone strings will return `pytz`
    time zone objects by default. To return `dateutil` time zone objects, append `dateutil/`
    before the string.
  prefs: []
  type: TYPE_NORMAL
- en: In `pytz` you can find a list of common (and less common) time zones using `from
    pytz import common_timezones, all_timezones`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dateutil` uses the OS time zones so there isn’t a fixed list available. For
    common zones, the names are the same as `pytz`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `UTC` time zone is a special case in `dateutil` and should be
    constructed explicitly as an instance of `dateutil.tz.tzutc`. You can also construct
    other time zones objects explicitly first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: To convert a time zone aware pandas object from one time zone to another, you
    can use the `tz_convert` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using `pytz` time zones, [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") will construct a different time zone object than a [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") for the same time zone input. A [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") can hold a collection of [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") objects that may have different UTC offsets and cannot be
    succinctly represented by one `pytz` time zone instance while one [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") represents one point in time with a specific UTC offset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be wary of conversions between libraries. For some time zones, `pytz` and `dateutil`
    have different definitions of the zone. This is more of a problem for unusual
    time zones than for ‘standard’ zones like `US/Eastern`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that a time zone definition across versions of time zone libraries
    may not be considered equal. This may cause problems when working with stored
    data that is localized using one version and operated on with a different version.
    See [here](io.html#io-hdf5-notes) for how to handle such a situation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: For `pytz` time zones, it is incorrect to pass a time zone object directly into
    the `datetime.datetime` constructor (e.g., `datetime.datetime(2011, 1, 1, tzinfo=pytz.timezone('US/Eastern'))`.
    Instead, the datetime needs to be localized using the `localize` method on the
    `pytz` time zone object.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that for times in the future, correct conversion between time zones
    (and UTC) cannot be guaranteed by any time zone library because a timezone’s offset
    from UTC may be changed by the respective government.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: If you are using dates beyond 2038-01-18, due to current deficiencies in the
    underlying libraries caused by the year 2038 problem, daylight saving time (DST)
    adjustments to timezone aware dates will not be applied. If and when the underlying
    libraries are fixed, the DST transitions will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for two dates that are in British Summer Time (and so would normally
    be GMT+1), both the following asserts evaluate as true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, all timestamps are stored in UTC. Values from a time zone aware
    [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") or [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") will have their fields (day, hour, minute, etc.) localized
    to the time zone. However, timestamps with the same UTC value are still considered
    to be equal even if they are in different time zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Operations between [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") in different time zones will yield UTC [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), aligning the data on the UTC timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: To remove time zone information, use `tz_localize(None)` or `tz_convert(None)`.
    `tz_localize(None)` will remove the time zone yielding the local time representation.
    `tz_convert(None)` will remove the time zone after converting to UTC time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '### Fold'
  prefs: []
  type: TYPE_NORMAL
- en: For ambiguous times, pandas supports explicitly specifying the keyword-only
    fold argument. Due to daylight saving time, one wall clock time can occur twice
    when shifting from summer to winter time; fold describes whether the datetime-like
    corresponds to the first (0) or the second time (1) the wall clock hits the ambiguous
    time. Fold is supported only for constructing from naive `datetime.datetime` (see
    [datetime documentation](https://docs.python.org/3/library/datetime.html) for
    details) or from [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") or for constructing from components (see below). Only `dateutil`
    timezones are supported (see [dateutil documentation](https://dateutil.readthedocs.io/en/stable/tz.html#dateutil.tz.enfold)
    for `dateutil` methods that deal with ambiguous datetimes) as `pytz` timezones
    do not support fold (see [pytz documentation](http://pytz.sourceforge.net/index.html)
    for details on how `pytz` deals with ambiguous datetimes). To localize an ambiguous
    datetime with `pytz`, please use [`Timestamp.tz_localize()`](../reference/api/pandas.Timestamp.tz_localize.html#pandas.Timestamp.tz_localize
    "pandas.Timestamp.tz_localize"). In general, we recommend to rely on [`Timestamp.tz_localize()`](../reference/api/pandas.Timestamp.tz_localize.html#pandas.Timestamp.tz_localize
    "pandas.Timestamp.tz_localize") when localizing ambiguous datetimes if you need
    direct control over how they are handled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]  ### Ambiguous times when localizing'
  prefs: []
  type: TYPE_NORMAL
- en: '`tz_localize` may not be able to determine the UTC offset of a timestamp because
    daylight savings time (DST) in a local time zone causes some times to occur twice
    within one day (“clocks fall back”). The following options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''raise''`: Raises a `pytz.AmbiguousTimeError` (the default behavior)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''infer''`: Attempt to determine the correct offset base on the monotonicity
    of the timestamps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''NaT''`: Replaces ambiguous times with `NaT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`: `True` represents a DST time, `False` represents non-DST time. An array-like
    of `bool` values is supported for a sequence of times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: This will fail as there are ambiguous times (`'11/06/2011 01:00'`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Handle these ambiguous times by specifying the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]  ### Nonexistent times when localizing'
  prefs: []
  type: TYPE_NORMAL
- en: 'A DST transition may also shift the local time ahead by 1 hour creating nonexistent
    local times (“clocks spring forward”). The behavior of localizing a timeseries
    with nonexistent times can be controlled by the `nonexistent` argument. The following
    options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''raise''`: Raises a `pytz.NonExistentTimeError` (the default behavior)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''NaT''`: Replaces nonexistent times with `NaT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''shift_forward''`: Shifts nonexistent times forward to the closest real time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''shift_backward''`: Shifts nonexistent times backward to the closest real
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'timedelta object: Shifts nonexistent times by the timedelta duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Localization of nonexistent times will raise an error by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Transform nonexistent times to `NaT` or shift the times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]  ### Time zone Series operations'
  prefs: []
  type: TYPE_NORMAL
- en: A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    with time zone **naive** values is represented with a dtype of `datetime64[ns]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    with a time zone **aware** values is represented with a dtype of `datetime64[ns,
    tz]` where `tz` is the time zone
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Both of these [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    time zone information can be manipulated via the `.dt` accessor, see [the dt accessor
    section](basics.html#basics-dt-accessors).
  prefs: []
  type: TYPE_NORMAL
- en: For example, to localize and convert a naive stamp to time zone aware.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Time zone information can also be manipulated using the `astype` method. This
    method can convert between different timezone-aware dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Using [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") on a `Series`, returns a NumPy array of the data. NumPy
    does not currently support time zones (even though it is *printing* in the local
    time zone!), therefore an object array of Timestamps is returned for time zone
    aware data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: 'By converting to an object array of Timestamps, it preserves the time zone
    information. For example, when converting back to a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you want an actual NumPy `datetime64[ns]` array (with the values
    converted to UTC) instead of an array of objects, you can specify the `dtype`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]  ## Overview'
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas captures 4 general time related concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Date times: A specific date and time with timezone support. Similar to `datetime.datetime`
    from the standard library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Time deltas: An absolute time duration. Similar to `datetime.timedelta` from
    the standard library.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Time spans: A span of time defined by a point in time and its associated frequency.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Date offsets: A relative time duration that respects calendar arithmetic. Similar
    to `dateutil.relativedelta.relativedelta` from the `dateutil` package.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| Concept | Scalar Class | Array Class | pandas Data Type | Primary Creation
    Method |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Date times | `Timestamp` | `DatetimeIndex` | `datetime64[ns]` or `datetime64[ns,
    tz]` | `to_datetime` or `date_range` |'
  prefs: []
  type: TYPE_TB
- en: '| Time deltas | `Timedelta` | `TimedeltaIndex` | `timedelta64[ns]` | `to_timedelta`
    or `timedelta_range` |'
  prefs: []
  type: TYPE_TB
- en: '| Time spans | `Period` | `PeriodIndex` | `period[freq]` | `Period` or `period_range`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Date offsets | `DateOffset` | `None` | `None` | `DateOffset` |'
  prefs: []
  type: TYPE_TB
- en: For time series data, it’s conventional to represent the time component in the
    index of a [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    or [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    so manipulations can be performed with respect to the time element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: However, [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    and [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    can directly also support the time component as data itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    and [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame")
    have extended data type support and functionality for `datetime`, `timedelta`
    and `Period` data when passed into those constructors. `DateOffset` data however
    will be stored as `object` data.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, pandas represents null date times, time deltas, and time spans as `NaT`
    which is useful for representing missing or null date like values and behaves
    similar as `np.nan` does for float data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '## Timestamps vs. time spans'
  prefs: []
  type: TYPE_NORMAL
- en: Timestamped data is the most basic type of time series data that associates
    values with points in time. For pandas objects it means using the points in time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: However, in many cases it is more natural to associate things like change variables
    with a time span instead. The span represented by `Period` can be specified explicitly,
    or inferred from datetime string format.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp "pandas.Timestamp")
    and [`Period`](../reference/api/pandas.Period.html#pandas.Period "pandas.Period")
    can serve as an index. Lists of `Timestamp` and `Period` are automatically coerced
    to [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") and [`PeriodIndex`](../reference/api/pandas.PeriodIndex.html#pandas.PeriodIndex
    "pandas.PeriodIndex") respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: pandas allows you to capture both representations and convert between them.
    Under the hood, pandas represents timestamps using instances of `Timestamp` and
    sequences of timestamps using instances of `DatetimeIndex`. For regular time spans,
    pandas uses `Period` objects for scalar values and `PeriodIndex` for sequences
    of spans. Better support for irregular intervals with arbitrary start and end
    points are forth-coming in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: '## Converting to timestamps'
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    or list-like object of date-like objects e.g. strings, epochs, or a mixture, you
    can use the `to_datetime` function. When passed a `Series`, this returns a `Series`
    (with the same index), while a list-like is converted to a `DatetimeIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use dates which start with the day first (i.e. European style), you
    can pass the `dayfirst` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: You see in the above example that `dayfirst` isn’t strict. If a date can’t be
    parsed with the day being first it will be parsed as if `dayfirst` were `False`
    and a warning will also be raised.
  prefs: []
  type: TYPE_NORMAL
- en: If you pass a single string to `to_datetime`, it returns a single `Timestamp`.
    `Timestamp` can also accept string input, but it doesn’t accept string parsing
    options like `dayfirst` or `format`, so use `to_datetime` if these are required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `DatetimeIndex` constructor directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'The string ‘infer’ can be passed in order to set the frequency of the index
    as the inferred frequency upon creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: '### Providing a format argument'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the required datetime string, a `format` argument can be passed
    to ensure specific parsing. This could also potentially speed up the conversion
    considerably.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: For more information on the choices available when specifying the `format` option,
    see the Python [datetime documentation](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior).
  prefs: []
  type: TYPE_NORMAL
- en: Assembling datetime from multiple DataFrame columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also pass a `DataFrame` of integer or string columns to assemble into
    a `Series` of `Timestamps`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: You can pass only the columns that you need to assemble.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.to_datetime` looks for standard designations of the datetime component
    in the column names, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'required: `year`, `month`, `day`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional: `hour`, `minute`, `second`, `millisecond`, `microsecond`, `nanosecond`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default behavior, `errors=''raise''`, is to raise when unparsable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass `errors=''coerce''` to convert unparsable data to `NaT` (not a time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '### Epoch timestamps'
  prefs: []
  type: TYPE_NORMAL
- en: pandas supports converting integer or float epoch times to `Timestamp` and `DatetimeIndex`.
    The default unit is nanoseconds, since that is how `Timestamp` objects are stored
    internally. However, epochs are often stored in another `unit` which can be specified.
    These are computed from the starting point specified by the `origin` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `unit` parameter does not use the same strings as the `format` parameter
    that was discussed [above](#timeseries-converting-format)). The available units
    are listed on the documentation for [`pandas.to_datetime()`](../reference/api/pandas.to_datetime.html#pandas.to_datetime
    "pandas.to_datetime").
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructing a [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") or [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") with an epoch timestamp with the `tz` argument specified
    will raise a ValueError. If you have epochs in wall time in another timezone,
    you can read the epochs as timezone-naive timestamps and then localize to the
    appropriate timezone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Epoch times will be rounded to the nearest nanosecond.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Conversion of float epoch times can lead to inaccurate and unexpected results.
    [Python floats](https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues
    "(in Python v3.12)") have about 15 digits precision in decimal. Rounding during
    conversion from float to high precision `Timestamp` is unavoidable. The only way
    to achieve exact precision is to use a fixed-width types (e.g. an int64).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the origin parameter](#timeseries-origin)  ### From timestamps to epoch'
  prefs: []
  type: TYPE_NORMAL
- en: 'To invert the operation from above, namely, to convert from a `Timestamp` to
    a ‘unix’ epoch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: We subtract the epoch (midnight at January 1, 1970 UTC) and then floor divide
    by the “unit” (1 second).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]  ### Using the `origin` parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `origin` parameter, one can specify an alternative starting point
    for creation of a `DatetimeIndex`. For example, to use 1960-01-01 as the starting
    date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The default is set at `origin='unix'`, which defaults to `1970-01-01 00:00:00`.
    Commonly called ‘unix epoch’ or POSIX time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]  ### Providing a format argument'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the required datetime string, a `format` argument can be passed
    to ensure specific parsing. This could also potentially speed up the conversion
    considerably.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: For more information on the choices available when specifying the `format` option,
    see the Python [datetime documentation](https://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior).
  prefs: []
  type: TYPE_NORMAL
- en: Assembling datetime from multiple DataFrame columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also pass a `DataFrame` of integer or string columns to assemble into
    a `Series` of `Timestamps`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: You can pass only the columns that you need to assemble.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '`pd.to_datetime` looks for standard designations of the datetime component
    in the column names, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'required: `year`, `month`, `day`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'optional: `hour`, `minute`, `second`, `millisecond`, `microsecond`, `nanosecond`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invalid data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default behavior, `errors=''raise''`, is to raise when unparsable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: 'Pass `errors=''coerce''` to convert unparsable data to `NaT` (not a time):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '### Epoch timestamps'
  prefs: []
  type: TYPE_NORMAL
- en: pandas supports converting integer or float epoch times to `Timestamp` and `DatetimeIndex`.
    The default unit is nanoseconds, since that is how `Timestamp` objects are stored
    internally. However, epochs are often stored in another `unit` which can be specified.
    These are computed from the starting point specified by the `origin` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `unit` parameter does not use the same strings as the `format` parameter
    that was discussed [above](#timeseries-converting-format)). The available units
    are listed on the documentation for [`pandas.to_datetime()`](../reference/api/pandas.to_datetime.html#pandas.to_datetime
    "pandas.to_datetime").
  prefs: []
  type: TYPE_NORMAL
- en: 'Constructing a [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") or [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") with an epoch timestamp with the `tz` argument specified
    will raise a ValueError. If you have epochs in wall time in another timezone,
    you can read the epochs as timezone-naive timestamps and then localize to the
    appropriate timezone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Epoch times will be rounded to the nearest nanosecond.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Conversion of float epoch times can lead to inaccurate and unexpected results.
    [Python floats](https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues
    "(in Python v3.12)") have about 15 digits precision in decimal. Rounding during
    conversion from float to high precision `Timestamp` is unavoidable. The only way
    to achieve exact precision is to use a fixed-width types (e.g. an int64).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using the origin parameter](#timeseries-origin)'
  prefs: []
  type: TYPE_NORMAL
- en: '### From timestamps to epoch'
  prefs: []
  type: TYPE_NORMAL
- en: 'To invert the operation from above, namely, to convert from a `Timestamp` to
    a ‘unix’ epoch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: We subtract the epoch (midnight at January 1, 1970 UTC) and then floor divide
    by the “unit” (1 second).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '### Using the `origin` parameter'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `origin` parameter, one can specify an alternative starting point
    for creation of a `DatetimeIndex`. For example, to use 1960-01-01 as the starting
    date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: The default is set at `origin='unix'`, which defaults to `1970-01-01 00:00:00`.
    Commonly called ‘unix epoch’ or POSIX time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '## Generating ranges of timestamps'
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate an index with timestamps, you can use either the `DatetimeIndex`
    or `Index` constructor and pass in a list of datetime objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice this becomes very cumbersome because we often need a very long
    index with a large number of timestamps. If we need timestamps on a regular frequency,
    we can use the [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range") and [`bdate_range()`](../reference/api/pandas.bdate_range.html#pandas.bdate_range
    "pandas.bdate_range") functions to create a `DatetimeIndex`. The default frequency
    for `date_range` is a **calendar day** while the default for `bdate_range` is
    a **business day**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'Convenience functions like `date_range` and `bdate_range` can utilize a variety
    of [frequency aliases](#timeseries-offset-aliases):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '`date_range` and `bdate_range` make it easy to generate a range of dates using
    various combinations of parameters like `start`, `end`, `periods`, and `freq`.
    The start and end dates are strictly inclusive, so dates outside of those specified
    will not be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying `start`, `end`, and `periods` will generate a range of evenly spaced
    dates from `start` to `end` inclusively, with `periods` number of elements in
    the resulting `DatetimeIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '### Custom frequency ranges'
  prefs: []
  type: TYPE_NORMAL
- en: '`bdate_range` can also generate a range of custom frequency dates by using
    the `weekmask` and `holidays` parameters. These parameters will only be used if
    a custom frequency string is passed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Custom business days](#timeseries-custombusinessdays)  ### Custom frequency
    ranges'
  prefs: []
  type: TYPE_NORMAL
- en: '`bdate_range` can also generate a range of custom frequency dates by using
    the `weekmask` and `holidays` parameters. These parameters will only be used if
    a custom frequency string is passed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Custom business days](#timeseries-custombusinessdays)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Timestamp limitations'
  prefs: []
  type: TYPE_NORMAL
- en: 'The limits of timestamp representation depend on the chosen resolution. For
    nanosecond resolution, the time span that can be represented using a 64-bit integer
    is limited to approximately 584 years:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: When choosing second-resolution, the available range grows to `+/- 2.9e11 years`.
    Different resolutions can be converted to each other through `as_unit`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Representing out-of-bounds spans](#timeseries-oob)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Indexing'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the main uses for `DatetimeIndex` is as an index for pandas objects.
    The `DatetimeIndex` class contains many time series related optimizations:'
  prefs: []
  type: TYPE_NORMAL
- en: A large range of dates for various offsets are pre-computed and cached under
    the hood in order to make generating subsequent date ranges very fast (just have
    to grab a slice).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast shifting using the `shift` method on pandas objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unioning of overlapping `DatetimeIndex` objects with the same frequency is very
    fast (important for fast data alignment).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quick access to date fields via properties such as `year`, `month`, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularization functions like `snap` and very fast `asof` logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DatetimeIndex` objects have all the basic functionality of regular `Index`
    objects, and a smorgasbord of advanced time series specific methods for easy frequency
    processing.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Reindexing methods](basics.html#basics-reindexing)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While pandas does not force you to have a sorted date index, some of these methods
    may have unexpected or incorrect behavior if the dates are unsorted.
  prefs: []
  type: TYPE_NORMAL
- en: '`DatetimeIndex` can be used like a regular index and offers all of its intelligent
    functionality like selection, slicing, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '### Partial string indexing'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dates and strings that parse to timestamps can be passed as indexing parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide convenience for accessing longer time series, you can also pass
    in the year or year and month as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of slicing will work on a `DataFrame` with a `DatetimeIndex` as well.
    Since the partial string selection is a form of label slicing, the endpoints **will
    be** included. This would include matching times on an included date:'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Indexing `DataFrame` rows with a *single* string with getitem (e.g. `frame[dtstring]`)
    is deprecated starting with pandas 1.2.0 (given the ambiguity whether it is indexing
    the rows or selecting a column) and will be removed in a future version. The equivalent
    with `.loc` (e.g. `frame.loc[dtstring]`) is still supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'This starts on the very first time in the month, and includes the last date
    and time for the month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'This specifies a stop time **that includes all of the times on the last day**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'This specifies an **exact** stop time (and is not the same as the above):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: 'We are stopping on the included end-point as it is part of the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: '`DatetimeIndex` partial string indexing also works on a `DataFrame` with a
    `MultiIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Slicing with string indexing also honors UTC offset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]  ### Slice vs. exact match'
  prefs: []
  type: TYPE_NORMAL
- en: The same string used as an indexing parameter can be treated either as a slice
    or as an exact match depending on the resolution of the index. If the string is
    less accurate than the index, it will be treated as a slice, otherwise as an exact
    match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a `Series` object with a minute resolution index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: A timestamp string less accurate than a minute gives a `Series` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: A timestamp string with minute resolution (or more accurate), gives a scalar
    instead, i.e. it is not casted to a slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: If index resolution is second, then the minute-accurate timestamp gives a `Series`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: If the timestamp string is treated as a slice, it can be used to index `DataFrame`
    with `.loc[]` as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the string is treated as an exact match, the selection in `DataFrame`’s
    `[]` will be column-wise and not row-wise, see [Indexing Basics](indexing.html#indexing-basics).
    For example `dft_minute[''2011-12-31 23:59'']` will raise `KeyError` as `''2012-12-31
    23:59''` has the same resolution as the index and there is no column with such
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: To *always* have unambiguous selection, whether the row is treated as a slice
    or a single selection, use `.loc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Note also that `DatetimeIndex` resolution cannot be less precise than day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Exact indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in previous section, indexing a `DatetimeIndex` with a partial
    string depends on the “accuracy” of the period, in other words how specific the
    interval is in relation to the resolution of the index. In contrast, indexing
    with `Timestamp` or `datetime` objects is exact, because the objects have exact
    meaning. These also follow the semantics of *including both endpoints*.
  prefs: []
  type: TYPE_NORMAL
- en: These `Timestamp` and `datetime` objects have exact `hours, minutes,` and `seconds`,
    even though they were not explicitly specified (they are `0`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: With no defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Truncating & fancy indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A [`truncate()`](../reference/api/pandas.DataFrame.truncate.html#pandas.DataFrame.truncate
    "pandas.DataFrame.truncate") convenience function is provided that is similar
    to slicing. Note that `truncate` assumes a 0 value for any unspecified date component
    in a `DatetimeIndex` in contrast to slicing which returns any partially matching
    dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'Even complicated fancy indexing that breaks the `DatetimeIndex` frequency regularity
    will result in a `DatetimeIndex`, although frequency is lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '### Partial string indexing'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dates and strings that parse to timestamps can be passed as indexing parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: 'To provide convenience for accessing longer time series, you can also pass
    in the year or year and month as strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of slicing will work on a `DataFrame` with a `DatetimeIndex` as well.
    Since the partial string selection is a form of label slicing, the endpoints **will
    be** included. This would include matching times on an included date:'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Indexing `DataFrame` rows with a *single* string with getitem (e.g. `frame[dtstring]`)
    is deprecated starting with pandas 1.2.0 (given the ambiguity whether it is indexing
    the rows or selecting a column) and will be removed in a future version. The equivalent
    with `.loc` (e.g. `frame.loc[dtstring]`) is still supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: 'This starts on the very first time in the month, and includes the last date
    and time for the month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'This specifies a stop time **that includes all of the times on the last day**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: 'This specifies an **exact** stop time (and is not the same as the above):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'We are stopping on the included end-point as it is part of the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '`DatetimeIndex` partial string indexing also works on a `DataFrame` with a
    `MultiIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Slicing with string indexing also honors UTC offset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '### Slice vs. exact match'
  prefs: []
  type: TYPE_NORMAL
- en: The same string used as an indexing parameter can be treated either as a slice
    or as an exact match depending on the resolution of the index. If the string is
    less accurate than the index, it will be treated as a slice, otherwise as an exact
    match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a `Series` object with a minute resolution index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: A timestamp string less accurate than a minute gives a `Series` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: A timestamp string with minute resolution (or more accurate), gives a scalar
    instead, i.e. it is not casted to a slice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: If index resolution is second, then the minute-accurate timestamp gives a `Series`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: If the timestamp string is treated as a slice, it can be used to index `DataFrame`
    with `.loc[]` as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the string is treated as an exact match, the selection in `DataFrame`’s
    `[]` will be column-wise and not row-wise, see [Indexing Basics](indexing.html#indexing-basics).
    For example `dft_minute[''2011-12-31 23:59'']` will raise `KeyError` as `''2012-12-31
    23:59''` has the same resolution as the index and there is no column with such
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: To *always* have unambiguous selection, whether the row is treated as a slice
    or a single selection, use `.loc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Note also that `DatetimeIndex` resolution cannot be less precise than day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Exact indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As discussed in previous section, indexing a `DatetimeIndex` with a partial
    string depends on the “accuracy” of the period, in other words how specific the
    interval is in relation to the resolution of the index. In contrast, indexing
    with `Timestamp` or `datetime` objects is exact, because the objects have exact
    meaning. These also follow the semantics of *including both endpoints*.
  prefs: []
  type: TYPE_NORMAL
- en: These `Timestamp` and `datetime` objects have exact `hours, minutes,` and `seconds`,
    even though they were not explicitly specified (they are `0`).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: With no defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: Truncating & fancy indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A [`truncate()`](../reference/api/pandas.DataFrame.truncate.html#pandas.DataFrame.truncate
    "pandas.DataFrame.truncate") convenience function is provided that is similar
    to slicing. Note that `truncate` assumes a 0 value for any unspecified date component
    in a `DatetimeIndex` in contrast to slicing which returns any partially matching
    dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Even complicated fancy indexing that breaks the `DatetimeIndex` frequency regularity
    will result in a `DatetimeIndex`, although frequency is lost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '## Time/date components'
  prefs: []
  type: TYPE_NORMAL
- en: There are several time/date properties that one can access from `Timestamp`
    or a collection of timestamps like a `DatetimeIndex`.
  prefs: []
  type: TYPE_NORMAL
- en: '| Property | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| year | The year of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| month | The month of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| day | The days of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| hour | The hour of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| minute | The minutes of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| second | The seconds of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| microsecond | The microseconds of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| nanosecond | The nanoseconds of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| date | Returns datetime.date (does not contain timezone information) |'
  prefs: []
  type: TYPE_TB
- en: '| time | Returns datetime.time (does not contain timezone information) |'
  prefs: []
  type: TYPE_TB
- en: '| timetz | Returns datetime.time as local time with timezone information |'
  prefs: []
  type: TYPE_TB
- en: '| dayofyear | The ordinal day of year |'
  prefs: []
  type: TYPE_TB
- en: '| day_of_year | The ordinal day of year |'
  prefs: []
  type: TYPE_TB
- en: '| weekofyear | The week ordinal of the year |'
  prefs: []
  type: TYPE_TB
- en: '| week | The week ordinal of the year |'
  prefs: []
  type: TYPE_TB
- en: '| dayofweek | The number of the day of the week with Monday=0, Sunday=6 |'
  prefs: []
  type: TYPE_TB
- en: '| day_of_week | The number of the day of the week with Monday=0, Sunday=6 |'
  prefs: []
  type: TYPE_TB
- en: '| weekday | The number of the day of the week with Monday=0, Sunday=6 |'
  prefs: []
  type: TYPE_TB
- en: '| quarter | Quarter of the date: Jan-Mar = 1, Apr-Jun = 2, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| days_in_month | The number of days in the month of the datetime |'
  prefs: []
  type: TYPE_TB
- en: '| is_month_start | Logical indicating if first day of month (defined by frequency)
    |'
  prefs: []
  type: TYPE_TB
- en: '| is_month_end | Logical indicating if last day of month (defined by frequency)
    |'
  prefs: []
  type: TYPE_TB
- en: '| is_quarter_start | Logical indicating if first day of quarter (defined by
    frequency) |'
  prefs: []
  type: TYPE_TB
- en: '| is_quarter_end | Logical indicating if last day of quarter (defined by frequency)
    |'
  prefs: []
  type: TYPE_TB
- en: '| is_year_start | Logical indicating if first day of year (defined by frequency)
    |'
  prefs: []
  type: TYPE_TB
- en: '| is_year_end | Logical indicating if last day of year (defined by frequency)
    |'
  prefs: []
  type: TYPE_TB
- en: '| is_leap_year | Logical indicating if the date belongs to a leap year |'
  prefs: []
  type: TYPE_TB
- en: Furthermore, if you have a `Series` with datetimelike values, then you can access
    these properties via the `.dt` accessor, as detailed in the section on [.dt accessors](basics.html#basics-dt-accessors).
  prefs: []
  type: TYPE_NORMAL
- en: 'You may obtain the year, week and day components of the ISO year from the ISO
    8601 standard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '## DateOffset objects'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding examples, frequency strings (e.g. `''D''`) were used to specify
    a frequency that defined:'
  prefs: []
  type: TYPE_NORMAL
- en: how the date times in [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") were spaced when using [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the frequency of a [`Period`](../reference/api/pandas.Period.html#pandas.Period
    "pandas.Period") or [`PeriodIndex`](../reference/api/pandas.PeriodIndex.html#pandas.PeriodIndex
    "pandas.PeriodIndex")
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These frequency strings map to a `DateOffset` object and its subclasses. A `DateOffset`
    is similar to a [`Timedelta`](../reference/api/pandas.Timedelta.html#pandas.Timedelta
    "pandas.Timedelta") that represents a duration of time but follows specific calendar
    duration rules. For example, a [`Timedelta`](../reference/api/pandas.Timedelta.html#pandas.Timedelta
    "pandas.Timedelta") day will always increment `datetimes` by 24 hours, while a
    `DateOffset` day will increment `datetimes` to the same time the next day whether
    a day represents 23, 24 or 25 hours due to daylight savings time. However, all
    `DateOffset` subclasses that are an hour or smaller (`Hour`, `Minute`, `Second`,
    `Milli`, `Micro`, `Nano`) behave like [`Timedelta`](../reference/api/pandas.Timedelta.html#pandas.Timedelta
    "pandas.Timedelta") and respect absolute time.
  prefs: []
  type: TYPE_NORMAL
- en: The basic `DateOffset` acts similar to `dateutil.relativedelta` ([relativedelta
    documentation](https://dateutil.readthedocs.io/en/stable/relativedelta.html))
    that shifts a date time by the corresponding calendar duration specified. The
    arithmetic operator (`+`) can be used to perform the shift.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'Most `DateOffsets` have associated frequencies strings, or offset aliases,
    that can be passed into `freq` keyword arguments. The available date offsets and
    associated frequency strings can be found below:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Date Offset | Frequency String | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`DateOffset`](../reference/api/pandas.tseries.offsets.DateOffset.html#pandas.tseries.offsets.DateOffset
    "pandas.tseries.offsets.DateOffset") | None | Generic offset class, defaults to
    absolute 24 hours |'
  prefs: []
  type: TYPE_TB
- en: '| [`BDay`](../reference/api/pandas.tseries.offsets.BDay.html#pandas.tseries.offsets.BDay
    "pandas.tseries.offsets.BDay") or [`BusinessDay`](../reference/api/pandas.tseries.offsets.BusinessDay.html#pandas.tseries.offsets.BusinessDay
    "pandas.tseries.offsets.BusinessDay") | `''B''` | business day (weekday) |'
  prefs: []
  type: TYPE_TB
- en: '| [`CDay`](../reference/api/pandas.tseries.offsets.CDay.html#pandas.tseries.offsets.CDay
    "pandas.tseries.offsets.CDay") or [`CustomBusinessDay`](../reference/api/pandas.tseries.offsets.CustomBusinessDay.html#pandas.tseries.offsets.CustomBusinessDay
    "pandas.tseries.offsets.CustomBusinessDay") | `''C''` | custom business day |'
  prefs: []
  type: TYPE_TB
- en: '| [`Week`](../reference/api/pandas.tseries.offsets.Week.html#pandas.tseries.offsets.Week
    "pandas.tseries.offsets.Week") | `''W''` | one week, optionally anchored on a
    day of the week |'
  prefs: []
  type: TYPE_TB
- en: '| [`WeekOfMonth`](../reference/api/pandas.tseries.offsets.WeekOfMonth.html#pandas.tseries.offsets.WeekOfMonth
    "pandas.tseries.offsets.WeekOfMonth") | `''WOM''` | the x-th day of the y-th week
    of each month |'
  prefs: []
  type: TYPE_TB
- en: '| [`LastWeekOfMonth`](../reference/api/pandas.tseries.offsets.LastWeekOfMonth.html#pandas.tseries.offsets.LastWeekOfMonth
    "pandas.tseries.offsets.LastWeekOfMonth") | `''LWOM''` | the x-th day of the last
    week of each month |'
  prefs: []
  type: TYPE_TB
- en: '| [`MonthEnd`](../reference/api/pandas.tseries.offsets.MonthEnd.html#pandas.tseries.offsets.MonthEnd
    "pandas.tseries.offsets.MonthEnd") | `''ME''` | calendar month end |'
  prefs: []
  type: TYPE_TB
- en: '| [`MonthBegin`](../reference/api/pandas.tseries.offsets.MonthBegin.html#pandas.tseries.offsets.MonthBegin
    "pandas.tseries.offsets.MonthBegin") | `''MS''` | calendar month begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`BMonthEnd`](../reference/api/pandas.tseries.offsets.BMonthEnd.html#pandas.tseries.offsets.BMonthEnd
    "pandas.tseries.offsets.BMonthEnd") or [`BusinessMonthEnd`](../reference/api/pandas.tseries.offsets.BusinessMonthEnd.html#pandas.tseries.offsets.BusinessMonthEnd
    "pandas.tseries.offsets.BusinessMonthEnd") | `''BME''` | business month end |'
  prefs: []
  type: TYPE_TB
- en: '| [`BMonthBegin`](../reference/api/pandas.tseries.offsets.BMonthBegin.html#pandas.tseries.offsets.BMonthBegin
    "pandas.tseries.offsets.BMonthBegin") or [`BusinessMonthBegin`](../reference/api/pandas.tseries.offsets.BusinessMonthBegin.html#pandas.tseries.offsets.BusinessMonthBegin
    "pandas.tseries.offsets.BusinessMonthBegin") | `''BMS''` | business month begin
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`CBMonthEnd`](../reference/api/pandas.tseries.offsets.CBMonthEnd.html#pandas.tseries.offsets.CBMonthEnd
    "pandas.tseries.offsets.CBMonthEnd") or [`CustomBusinessMonthEnd`](../reference/api/pandas.tseries.offsets.CustomBusinessMonthEnd.html#pandas.tseries.offsets.CustomBusinessMonthEnd
    "pandas.tseries.offsets.CustomBusinessMonthEnd") | `''CBME''` | custom business
    month end |'
  prefs: []
  type: TYPE_TB
- en: '| [`CBMonthBegin`](../reference/api/pandas.tseries.offsets.CBMonthBegin.html#pandas.tseries.offsets.CBMonthBegin
    "pandas.tseries.offsets.CBMonthBegin") or [`CustomBusinessMonthBegin`](../reference/api/pandas.tseries.offsets.CustomBusinessMonthBegin.html#pandas.tseries.offsets.CustomBusinessMonthBegin
    "pandas.tseries.offsets.CustomBusinessMonthBegin") | `''CBMS''` | custom business
    month begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`SemiMonthEnd`](../reference/api/pandas.tseries.offsets.SemiMonthEnd.html#pandas.tseries.offsets.SemiMonthEnd
    "pandas.tseries.offsets.SemiMonthEnd") | `''SME''` | 15th (or other day_of_month)
    and calendar month end |'
  prefs: []
  type: TYPE_TB
- en: '| [`SemiMonthBegin`](../reference/api/pandas.tseries.offsets.SemiMonthBegin.html#pandas.tseries.offsets.SemiMonthBegin
    "pandas.tseries.offsets.SemiMonthBegin") | `''SMS''` | 15th (or other day_of_month)
    and calendar month begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`QuarterEnd`](../reference/api/pandas.tseries.offsets.QuarterEnd.html#pandas.tseries.offsets.QuarterEnd
    "pandas.tseries.offsets.QuarterEnd") | `''QE''` | calendar quarter end |'
  prefs: []
  type: TYPE_TB
- en: '| [`QuarterBegin`](../reference/api/pandas.tseries.offsets.QuarterBegin.html#pandas.tseries.offsets.QuarterBegin
    "pandas.tseries.offsets.QuarterBegin") | `''QS''` | calendar quarter begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`BQuarterEnd`](../reference/api/pandas.tseries.offsets.BQuarterEnd.html#pandas.tseries.offsets.BQuarterEnd
    "pandas.tseries.offsets.BQuarterEnd") | `''BQE` | business quarter end |'
  prefs: []
  type: TYPE_TB
- en: '| [`BQuarterBegin`](../reference/api/pandas.tseries.offsets.BQuarterBegin.html#pandas.tseries.offsets.BQuarterBegin
    "pandas.tseries.offsets.BQuarterBegin") | `''BQS''` | business quarter begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`FY5253Quarter`](../reference/api/pandas.tseries.offsets.FY5253Quarter.html#pandas.tseries.offsets.FY5253Quarter
    "pandas.tseries.offsets.FY5253Quarter") | `''REQ''` | retail (aka 52-53 week)
    quarter |'
  prefs: []
  type: TYPE_TB
- en: '| [`YearEnd`](../reference/api/pandas.tseries.offsets.YearEnd.html#pandas.tseries.offsets.YearEnd
    "pandas.tseries.offsets.YearEnd") | `''YE''` | calendar year end |'
  prefs: []
  type: TYPE_TB
- en: '| [`YearBegin`](../reference/api/pandas.tseries.offsets.YearBegin.html#pandas.tseries.offsets.YearBegin
    "pandas.tseries.offsets.YearBegin") | `''YS''` or `''BYS''` | calendar year begin
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`BYearEnd`](../reference/api/pandas.tseries.offsets.BYearEnd.html#pandas.tseries.offsets.BYearEnd
    "pandas.tseries.offsets.BYearEnd") | `''BYE''` | business year end |'
  prefs: []
  type: TYPE_TB
- en: '| [`BYearBegin`](../reference/api/pandas.tseries.offsets.BYearBegin.html#pandas.tseries.offsets.BYearBegin
    "pandas.tseries.offsets.BYearBegin") | `''BYS''` | business year begin |'
  prefs: []
  type: TYPE_TB
- en: '| [`FY5253`](../reference/api/pandas.tseries.offsets.FY5253.html#pandas.tseries.offsets.FY5253
    "pandas.tseries.offsets.FY5253") | `''RE''` | retail (aka 52-53 week) year |'
  prefs: []
  type: TYPE_TB
- en: '| [`Easter`](../reference/api/pandas.tseries.offsets.Easter.html#pandas.tseries.offsets.Easter
    "pandas.tseries.offsets.Easter") | None | Easter holiday |'
  prefs: []
  type: TYPE_TB
- en: '| [`BusinessHour`](../reference/api/pandas.tseries.offsets.BusinessHour.html#pandas.tseries.offsets.BusinessHour
    "pandas.tseries.offsets.BusinessHour") | `''bh''` | business hour |'
  prefs: []
  type: TYPE_TB
- en: '| [`CustomBusinessHour`](../reference/api/pandas.tseries.offsets.CustomBusinessHour.html#pandas.tseries.offsets.CustomBusinessHour
    "pandas.tseries.offsets.CustomBusinessHour") | `''cbh''` | custom business hour
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Day`](../reference/api/pandas.tseries.offsets.Day.html#pandas.tseries.offsets.Day
    "pandas.tseries.offsets.Day") | `''D''` | one absolute day |'
  prefs: []
  type: TYPE_TB
- en: '| [`Hour`](../reference/api/pandas.tseries.offsets.Hour.html#pandas.tseries.offsets.Hour
    "pandas.tseries.offsets.Hour") | `''h''` | one hour |'
  prefs: []
  type: TYPE_TB
- en: '| [`Minute`](../reference/api/pandas.tseries.offsets.Minute.html#pandas.tseries.offsets.Minute
    "pandas.tseries.offsets.Minute") | `''min''` | one minute |'
  prefs: []
  type: TYPE_TB
- en: '| [`Second`](../reference/api/pandas.tseries.offsets.Second.html#pandas.tseries.offsets.Second
    "pandas.tseries.offsets.Second") | `''s''` | one second |'
  prefs: []
  type: TYPE_TB
- en: '| [`Milli`](../reference/api/pandas.tseries.offsets.Milli.html#pandas.tseries.offsets.Milli
    "pandas.tseries.offsets.Milli") | `''ms''` | one millisecond |'
  prefs: []
  type: TYPE_TB
- en: '| [`Micro`](../reference/api/pandas.tseries.offsets.Micro.html#pandas.tseries.offsets.Micro
    "pandas.tseries.offsets.Micro") | `''us''` | one microsecond |'
  prefs: []
  type: TYPE_TB
- en: '| [`Nano`](../reference/api/pandas.tseries.offsets.Nano.html#pandas.tseries.offsets.Nano
    "pandas.tseries.offsets.Nano") | `''ns''` | one nanosecond |'
  prefs: []
  type: TYPE_TB
- en: '`DateOffsets` additionally have `rollforward()` and `rollback()` methods for
    moving a date forward or backward respectively to a valid offset date relative
    to the offset. For example, business offsets will roll dates that land on the
    weekends (Saturday and Sunday) forward to Monday since business offsets operate
    on the weekdays.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: These operations preserve time (hour, minute, etc) information by default. To
    reset time to midnight, use `normalize()` before or after applying the operation
    (depending on whether you want the time information included in the operation).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Parametric offsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the offsets can be “parameterized” when created to result in different
    behaviors. For example, the `Week` offset for generating weekly data accepts a
    `weekday` parameter which results in the generated dates always lying on a particular
    day of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: The `normalize` option will be effective for addition and subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example is parameterizing `YearEnd` with the specific ending month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '### Using offsets with `Series` / `DatetimeIndex`'
  prefs: []
  type: TYPE_NORMAL
- en: Offsets can be used with either a `Series` or `DatetimeIndex` to apply the offset
    to each element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: If the offset class maps directly to a `Timedelta` (`Day`, `Hour`, `Minute`,
    `Second`, `Micro`, `Milli`, `Nano`) it can be used exactly like a `Timedelta`
    - see the [Timedelta section](timedeltas.html#timedeltas-operations) for more
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Note that some offsets (such as `BQuarterEnd`) do not have a vectorized implementation.
    They can still be used but may calculate significantly slower and will show a
    `PerformanceWarning`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]  ### Custom business days'
  prefs: []
  type: TYPE_NORMAL
- en: The `CDay` or `CustomBusinessDay` class provides a parametric `BusinessDay`
    class which can be used to create customized business day calendars which account
    for local holidays and local weekend conventions.
  prefs: []
  type: TYPE_NORMAL
- en: As an interesting example, let’s look at Egypt where a Friday-Saturday weekend
    is observed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s map to the weekday names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Holiday calendars can be used to provide the list of holidays. See the [holiday
    calendar](#timeseries-holiday) section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: Monthly offsets that respect a certain holiday calendar can be defined in the
    usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The frequency string ‘C’ is used to indicate that a CustomBusinessDay DateOffset
    is used, it is important to note that since CustomBusinessDay is a parameterised
    type, instances of CustomBusinessDay may differ and this is not detectable from
    the ‘C’ frequency string. The user therefore needs to ensure that the ‘C’ frequency
    string is used consistently within the user’s application.  ### Business hour'
  prefs: []
  type: TYPE_NORMAL
- en: The `BusinessHour` class provides a business hour representation on `BusinessDay`,
    allowing to use specific start and end times.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `BusinessHour` uses 9:00 - 17:00 as business hours. Adding `BusinessHour`
    will increment `Timestamp` by hourly frequency. If target `Timestamp` is out of
    business hours, move to the next business hour then increment it. If the result
    exceeds the business hours end, the remaining hours are added to the next business
    day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: You can also specify `start` and `end` time by keywords. The argument must be
    a `str` with an `hour:minute` representation or a `datetime.time` instance. Specifying
    seconds, microseconds and nanoseconds as business hour results in `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Passing `start` time later than `end` represents midnight business hour. In
    this case, business hour exceeds midnight and overlap to the next day. Valid business
    hours are distinguished by whether it started from valid `BusinessDay`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Applying `BusinessHour.rollforward` and `rollback` to out of business hours
    results in the next business hour start or previous day’s end. Different from
    other offsets, `BusinessHour.rollforward` may output different results from `apply`
    by definition.
  prefs: []
  type: TYPE_NORMAL
- en: This is because one day’s business hour end is equal to next day’s business
    hour start. For example, under the default business hours (9:00 - 17:00), there
    is no gap (0 minutes) between `2014-08-01 17:00` and `2014-08-04 09:00`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '`BusinessHour` regards Saturday and Sunday as holidays. To use arbitrary holidays,
    you can use `CustomBusinessHour` offset, as explained in the following subsection.  ###
    Custom business hour'
  prefs: []
  type: TYPE_NORMAL
- en: The `CustomBusinessHour` is a mixture of `BusinessHour` and `CustomBusinessDay`
    which allows you to specify arbitrary holidays. `CustomBusinessHour` works as
    the same as `BusinessHour` except that it skips specified custom holidays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: You can use keyword arguments supported by either `BusinessHour` and `CustomBusinessDay`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]  ### Offset aliases'
  prefs: []
  type: TYPE_NORMAL
- en: A number of string aliases are given to useful common time series frequencies.
    We will refer to these aliases as *offset aliases*.
  prefs: []
  type: TYPE_NORMAL
- en: '| Alias | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| B | business day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| C | custom business day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| D | calendar day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| W | weekly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| ME | month end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| SME | semi-month end frequency (15th and end of month) |'
  prefs: []
  type: TYPE_TB
- en: '| BME | business month end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| CBME | custom business month end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| MS | month start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| SMS | semi-month start frequency (1st and 15th) |'
  prefs: []
  type: TYPE_TB
- en: '| BMS | business month start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| CBMS | custom business month start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| QE | quarter end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BQE | business quarter end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| QS | quarter start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BQS | business quarter start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| YE | year end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BYE | business year end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| YS | year start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BYS | business year start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| h | hourly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| bh | business hour frequency |'
  prefs: []
  type: TYPE_TB
- en: '| cbh | custom business hour frequency |'
  prefs: []
  type: TYPE_TB
- en: '| min | minutely frequency |'
  prefs: []
  type: TYPE_TB
- en: '| s | secondly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| ms | milliseconds |'
  prefs: []
  type: TYPE_TB
- en: '| us | microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| ns | nanoseconds |'
  prefs: []
  type: TYPE_TB
- en: 'Deprecated since version 2.2.0: Aliases `H`, `BH`, `CBH`, `T`, `S`, `L`, `U`,
    and `N` are deprecated in favour of the aliases `h`, `bh`, `cbh`, `min`, `s`,
    `ms`, `us`, and `ns`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using the offset aliases above, it should be noted that functions such
    as [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range"), [`bdate_range()`](../reference/api/pandas.bdate_range.html#pandas.bdate_range
    "pandas.bdate_range"), will only return timestamps that are in the interval defined
    by `start_date` and `end_date`. If the `start_date` does not correspond to the
    frequency, the returned timestamps will start at the next valid timestamp, same
    for `end_date`, the returned timestamps will stop at the previous valid timestamp.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, for the offset `MS`, if the `start_date` is not the first of the
    month, the returned timestamps will start with the first day of the next month.
    If `end_date` is not the first day of a month, the last returned timestamp will
    be the first day of the corresponding month.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in the above example [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range") and [`bdate_range()`](../reference/api/pandas.bdate_range.html#pandas.bdate_range
    "pandas.bdate_range") will only return the valid timestamps between the `start_date`
    and `end_date`. If these are not valid timestamps for the given frequency it will
    roll to the next value for `start_date` (respectively previous for the `end_date`)  ###
    Period aliases'
  prefs: []
  type: TYPE_NORMAL
- en: A number of string aliases are given to useful common time series frequencies.
    We will refer to these aliases as *period aliases*.
  prefs: []
  type: TYPE_NORMAL
- en: '| Alias | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| B | business day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| D | calendar day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| W | weekly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| M | monthly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| Q | quarterly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| Y | yearly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| h | hourly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| min | minutely frequency |'
  prefs: []
  type: TYPE_TB
- en: '| s | secondly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| ms | milliseconds |'
  prefs: []
  type: TYPE_TB
- en: '| us | microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| ns | nanoseconds |'
  prefs: []
  type: TYPE_TB
- en: 'Deprecated since version 2.2.0: Aliases `A`, `H`, `T`, `S`, `L`, `U`, and `N`
    are deprecated in favour of the aliases `Y`, `h`, `min`, `s`, `ms`, `us`, and
    `ns`.'
  prefs: []
  type: TYPE_NORMAL
- en: Combining aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have seen previously, the alias and the offset instance are fungible
    in most functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine together day and intraday offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: Anchored offsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For some frequencies you can specify an anchoring suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Alias | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| W-SUN | weekly frequency (Sundays). Same as ‘W’ |'
  prefs: []
  type: TYPE_TB
- en: '| W-MON | weekly frequency (Mondays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-TUE | weekly frequency (Tuesdays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-WED | weekly frequency (Wednesdays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-THU | weekly frequency (Thursdays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-FRI | weekly frequency (Fridays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-SAT | weekly frequency (Saturdays) |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-DEC | quarterly frequency, year ends in December. Same as ‘QE’
    |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-JAN | quarterly frequency, year ends in January |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-FEB | quarterly frequency, year ends in February |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-MAR | quarterly frequency, year ends in March |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-APR | quarterly frequency, year ends in April |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-MAY | quarterly frequency, year ends in May |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-JUN | quarterly frequency, year ends in June |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-JUL | quarterly frequency, year ends in July |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-AUG | quarterly frequency, year ends in August |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-SEP | quarterly frequency, year ends in September |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-OCT | quarterly frequency, year ends in October |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-NOV | quarterly frequency, year ends in November |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-DEC | annual frequency, anchored end of December. Same as ‘YE’
    |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-JAN | annual frequency, anchored end of January |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-FEB | annual frequency, anchored end of February |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-MAR | annual frequency, anchored end of March |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-APR | annual frequency, anchored end of April |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-MAY | annual frequency, anchored end of May |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-JUN | annual frequency, anchored end of June |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-JUL | annual frequency, anchored end of July |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-AUG | annual frequency, anchored end of August |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-SEP | annual frequency, anchored end of September |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-OCT | annual frequency, anchored end of October |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-NOV | annual frequency, anchored end of November |'
  prefs: []
  type: TYPE_TB
- en: These can be used as arguments to `date_range`, `bdate_range`, constructors
    for `DatetimeIndex`, as well as various other timeseries-related functions in
    pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Anchored offset semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those offsets that are anchored to the start or end of specific frequency
    (`MonthEnd`, `MonthBegin`, `WeekEnd`, etc), the following rules apply to rolling
    forward and backwards.
  prefs: []
  type: TYPE_NORMAL
- en: When `n` is not 0, if the given date is not on an anchor point, it snapped to
    the next(previous) anchor point, and moved `|n|-1` additional steps forwards or
    backwards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: If the given date *is* on an anchor point, it is moved `|n|` points forwards
    or backwards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: For the case when `n=0`, the date is not moved if on an anchor point, otherwise
    it is rolled forward to the next anchor point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '### Holidays / holiday calendars'
  prefs: []
  type: TYPE_NORMAL
- en: Holidays and calendars provide a simple way to define holiday rules to be used
    with `CustomBusinessDay` or in other analysis that requires a predefined set of
    holidays. The `AbstractHolidayCalendar` class provides all the necessary methods
    to return a list of holidays and only `rules` need to be defined in a specific
    holiday calendar class. Furthermore, the `start_date` and `end_date` class attributes
    determine over what date range holidays are generated. These should be overwritten
    on the `AbstractHolidayCalendar` class to have the range apply to all calendar
    subclasses. `USFederalHolidayCalendar` is the only calendar that exists and primarily
    serves as an example for developing other calendars.
  prefs: []
  type: TYPE_NORMAL
- en: 'For holidays that occur on fixed dates (e.g., US Memorial Day or July 4th)
    an observance rule determines when that holiday is observed if it falls on a weekend
    or some other non-observed day. Defined observance rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Rule | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| nearest_workday | move Saturday to Friday and Sunday to Monday |'
  prefs: []
  type: TYPE_TB
- en: '| sunday_to_monday | move Sunday to following Monday |'
  prefs: []
  type: TYPE_TB
- en: '| next_monday_or_tuesday | move Saturday to Monday and Sunday/Monday to Tuesday
    |'
  prefs: []
  type: TYPE_TB
- en: '| previous_friday | move Saturday and Sunday to previous Friday” |'
  prefs: []
  type: TYPE_TB
- en: '| next_monday | move Saturday and Sunday to following Monday |'
  prefs: []
  type: TYPE_TB
- en: 'An example of how holidays and holiday calendars are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '**weekday=MO(2)** is same as **2 * Week(weekday=2)**'
  prefs: []
  type: TYPE_NORMAL
- en: Using this calendar, creating an index or doing offset arithmetic skips weekends
    and holidays (i.e., Memorial Day/July 4th). For example, the below defines a custom
    business day offset using the `ExampleCalendar`. Like any other offset, it can
    be used to create a `DatetimeIndex` or added to `datetime` or `Timestamp` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Ranges are defined by the `start_date` and `end_date` class attributes of `AbstractHolidayCalendar`.
    The defaults are shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: These dates can be overwritten by setting the attributes as datetime/Timestamp/string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: Every calendar class is accessible by name using the `get_calendar` function
    which returns a holiday class instance. Any imported calendar class will automatically
    be available by this function. Also, `HolidayCalendarFactory` provides an easy
    interface to create calendars that are combinations of calendars or calendars
    with additional rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Parametric offsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the offsets can be “parameterized” when created to result in different
    behaviors. For example, the `Week` offset for generating weekly data accepts a
    `weekday` parameter which results in the generated dates always lying on a particular
    day of the week:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: The `normalize` option will be effective for addition and subtraction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'Another example is parameterizing `YearEnd` with the specific ending month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '### Using offsets with `Series` / `DatetimeIndex`'
  prefs: []
  type: TYPE_NORMAL
- en: Offsets can be used with either a `Series` or `DatetimeIndex` to apply the offset
    to each element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: If the offset class maps directly to a `Timedelta` (`Day`, `Hour`, `Minute`,
    `Second`, `Micro`, `Milli`, `Nano`) it can be used exactly like a `Timedelta`
    - see the [Timedelta section](timedeltas.html#timedeltas-operations) for more
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Note that some offsets (such as `BQuarterEnd`) do not have a vectorized implementation.
    They can still be used but may calculate significantly slower and will show a
    `PerformanceWarning`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '### Custom business days'
  prefs: []
  type: TYPE_NORMAL
- en: The `CDay` or `CustomBusinessDay` class provides a parametric `BusinessDay`
    class which can be used to create customized business day calendars which account
    for local holidays and local weekend conventions.
  prefs: []
  type: TYPE_NORMAL
- en: As an interesting example, let’s look at Egypt where a Friday-Saturday weekend
    is observed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s map to the weekday names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: Holiday calendars can be used to provide the list of holidays. See the [holiday
    calendar](#timeseries-holiday) section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Monthly offsets that respect a certain holiday calendar can be defined in the
    usual way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The frequency string ‘C’ is used to indicate that a CustomBusinessDay DateOffset
    is used, it is important to note that since CustomBusinessDay is a parameterised
    type, instances of CustomBusinessDay may differ and this is not detectable from
    the ‘C’ frequency string. The user therefore needs to ensure that the ‘C’ frequency
    string is used consistently within the user’s application.
  prefs: []
  type: TYPE_NORMAL
- en: '### Business hour'
  prefs: []
  type: TYPE_NORMAL
- en: The `BusinessHour` class provides a business hour representation on `BusinessDay`,
    allowing to use specific start and end times.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `BusinessHour` uses 9:00 - 17:00 as business hours. Adding `BusinessHour`
    will increment `Timestamp` by hourly frequency. If target `Timestamp` is out of
    business hours, move to the next business hour then increment it. If the result
    exceeds the business hours end, the remaining hours are added to the next business
    day.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: You can also specify `start` and `end` time by keywords. The argument must be
    a `str` with an `hour:minute` representation or a `datetime.time` instance. Specifying
    seconds, microseconds and nanoseconds as business hour results in `ValueError`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Passing `start` time later than `end` represents midnight business hour. In
    this case, business hour exceeds midnight and overlap to the next day. Valid business
    hours are distinguished by whether it started from valid `BusinessDay`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: Applying `BusinessHour.rollforward` and `rollback` to out of business hours
    results in the next business hour start or previous day’s end. Different from
    other offsets, `BusinessHour.rollforward` may output different results from `apply`
    by definition.
  prefs: []
  type: TYPE_NORMAL
- en: This is because one day’s business hour end is equal to next day’s business
    hour start. For example, under the default business hours (9:00 - 17:00), there
    is no gap (0 minutes) between `2014-08-01 17:00` and `2014-08-04 09:00`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '`BusinessHour` regards Saturday and Sunday as holidays. To use arbitrary holidays,
    you can use `CustomBusinessHour` offset, as explained in the following subsection.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Custom business hour'
  prefs: []
  type: TYPE_NORMAL
- en: The `CustomBusinessHour` is a mixture of `BusinessHour` and `CustomBusinessDay`
    which allows you to specify arbitrary holidays. `CustomBusinessHour` works as
    the same as `BusinessHour` except that it skips specified custom holidays.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: You can use keyword arguments supported by either `BusinessHour` and `CustomBusinessDay`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '### Offset aliases'
  prefs: []
  type: TYPE_NORMAL
- en: A number of string aliases are given to useful common time series frequencies.
    We will refer to these aliases as *offset aliases*.
  prefs: []
  type: TYPE_NORMAL
- en: '| Alias | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| B | business day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| C | custom business day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| D | calendar day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| W | weekly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| ME | month end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| SME | semi-month end frequency (15th and end of month) |'
  prefs: []
  type: TYPE_TB
- en: '| BME | business month end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| CBME | custom business month end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| MS | month start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| SMS | semi-month start frequency (1st and 15th) |'
  prefs: []
  type: TYPE_TB
- en: '| BMS | business month start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| CBMS | custom business month start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| QE | quarter end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BQE | business quarter end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| QS | quarter start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BQS | business quarter start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| YE | year end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BYE | business year end frequency |'
  prefs: []
  type: TYPE_TB
- en: '| YS | year start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| BYS | business year start frequency |'
  prefs: []
  type: TYPE_TB
- en: '| h | hourly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| bh | business hour frequency |'
  prefs: []
  type: TYPE_TB
- en: '| cbh | custom business hour frequency |'
  prefs: []
  type: TYPE_TB
- en: '| min | minutely frequency |'
  prefs: []
  type: TYPE_TB
- en: '| s | secondly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| ms | milliseconds |'
  prefs: []
  type: TYPE_TB
- en: '| us | microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| ns | nanoseconds |'
  prefs: []
  type: TYPE_TB
- en: 'Deprecated since version 2.2.0: Aliases `H`, `BH`, `CBH`, `T`, `S`, `L`, `U`,
    and `N` are deprecated in favour of the aliases `h`, `bh`, `cbh`, `min`, `s`,
    `ms`, `us`, and `ns`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using the offset aliases above, it should be noted that functions such
    as [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range"), [`bdate_range()`](../reference/api/pandas.bdate_range.html#pandas.bdate_range
    "pandas.bdate_range"), will only return timestamps that are in the interval defined
    by `start_date` and `end_date`. If the `start_date` does not correspond to the
    frequency, the returned timestamps will start at the next valid timestamp, same
    for `end_date`, the returned timestamps will stop at the previous valid timestamp.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: For example, for the offset `MS`, if the `start_date` is not the first of the
    month, the returned timestamps will start with the first day of the next month.
    If `end_date` is not the first day of a month, the last returned timestamp will
    be the first day of the corresponding month.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: We can see in the above example [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range") and [`bdate_range()`](../reference/api/pandas.bdate_range.html#pandas.bdate_range
    "pandas.bdate_range") will only return the valid timestamps between the `start_date`
    and `end_date`. If these are not valid timestamps for the given frequency it will
    roll to the next value for `start_date` (respectively previous for the `end_date`)
  prefs: []
  type: TYPE_NORMAL
- en: '### Period aliases'
  prefs: []
  type: TYPE_NORMAL
- en: A number of string aliases are given to useful common time series frequencies.
    We will refer to these aliases as *period aliases*.
  prefs: []
  type: TYPE_NORMAL
- en: '| Alias | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| B | business day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| D | calendar day frequency |'
  prefs: []
  type: TYPE_TB
- en: '| W | weekly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| M | monthly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| Q | quarterly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| Y | yearly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| h | hourly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| min | minutely frequency |'
  prefs: []
  type: TYPE_TB
- en: '| s | secondly frequency |'
  prefs: []
  type: TYPE_TB
- en: '| ms | milliseconds |'
  prefs: []
  type: TYPE_TB
- en: '| us | microseconds |'
  prefs: []
  type: TYPE_TB
- en: '| ns | nanoseconds |'
  prefs: []
  type: TYPE_TB
- en: 'Deprecated since version 2.2.0: Aliases `A`, `H`, `T`, `S`, `L`, `U`, and `N`
    are deprecated in favour of the aliases `Y`, `h`, `min`, `s`, `ms`, `us`, and
    `ns`.'
  prefs: []
  type: TYPE_NORMAL
- en: Combining aliases
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we have seen previously, the alias and the offset instance are fungible
    in most functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine together day and intraday offsets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: Anchored offsets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For some frequencies you can specify an anchoring suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Alias | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| W-SUN | weekly frequency (Sundays). Same as ‘W’ |'
  prefs: []
  type: TYPE_TB
- en: '| W-MON | weekly frequency (Mondays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-TUE | weekly frequency (Tuesdays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-WED | weekly frequency (Wednesdays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-THU | weekly frequency (Thursdays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-FRI | weekly frequency (Fridays) |'
  prefs: []
  type: TYPE_TB
- en: '| W-SAT | weekly frequency (Saturdays) |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-DEC | quarterly frequency, year ends in December. Same as ‘QE’
    |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-JAN | quarterly frequency, year ends in January |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-FEB | quarterly frequency, year ends in February |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-MAR | quarterly frequency, year ends in March |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-APR | quarterly frequency, year ends in April |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-MAY | quarterly frequency, year ends in May |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-JUN | quarterly frequency, year ends in June |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-JUL | quarterly frequency, year ends in July |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-AUG | quarterly frequency, year ends in August |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-SEP | quarterly frequency, year ends in September |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-OCT | quarterly frequency, year ends in October |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Q(E)(S)-NOV | quarterly frequency, year ends in November |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-DEC | annual frequency, anchored end of December. Same as ‘YE’
    |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-JAN | annual frequency, anchored end of January |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-FEB | annual frequency, anchored end of February |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-MAR | annual frequency, anchored end of March |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-APR | annual frequency, anchored end of April |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-MAY | annual frequency, anchored end of May |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-JUN | annual frequency, anchored end of June |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-JUL | annual frequency, anchored end of July |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-AUG | annual frequency, anchored end of August |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-SEP | annual frequency, anchored end of September |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-OCT | annual frequency, anchored end of October |'
  prefs: []
  type: TYPE_TB
- en: '| (B)Y(E)(S)-NOV | annual frequency, anchored end of November |'
  prefs: []
  type: TYPE_TB
- en: These can be used as arguments to `date_range`, `bdate_range`, constructors
    for `DatetimeIndex`, as well as various other timeseries-related functions in
    pandas.
  prefs: []
  type: TYPE_NORMAL
- en: Anchored offset semantics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For those offsets that are anchored to the start or end of specific frequency
    (`MonthEnd`, `MonthBegin`, `WeekEnd`, etc), the following rules apply to rolling
    forward and backwards.
  prefs: []
  type: TYPE_NORMAL
- en: When `n` is not 0, if the given date is not on an anchor point, it snapped to
    the next(previous) anchor point, and moved `|n|-1` additional steps forwards or
    backwards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: If the given date *is* on an anchor point, it is moved `|n|` points forwards
    or backwards.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: For the case when `n=0`, the date is not moved if on an anchor point, otherwise
    it is rolled forward to the next anchor point.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '### Holidays / holiday calendars'
  prefs: []
  type: TYPE_NORMAL
- en: Holidays and calendars provide a simple way to define holiday rules to be used
    with `CustomBusinessDay` or in other analysis that requires a predefined set of
    holidays. The `AbstractHolidayCalendar` class provides all the necessary methods
    to return a list of holidays and only `rules` need to be defined in a specific
    holiday calendar class. Furthermore, the `start_date` and `end_date` class attributes
    determine over what date range holidays are generated. These should be overwritten
    on the `AbstractHolidayCalendar` class to have the range apply to all calendar
    subclasses. `USFederalHolidayCalendar` is the only calendar that exists and primarily
    serves as an example for developing other calendars.
  prefs: []
  type: TYPE_NORMAL
- en: 'For holidays that occur on fixed dates (e.g., US Memorial Day or July 4th)
    an observance rule determines when that holiday is observed if it falls on a weekend
    or some other non-observed day. Defined observance rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Rule | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| nearest_workday | move Saturday to Friday and Sunday to Monday |'
  prefs: []
  type: TYPE_TB
- en: '| sunday_to_monday | move Sunday to following Monday |'
  prefs: []
  type: TYPE_TB
- en: '| next_monday_or_tuesday | move Saturday to Monday and Sunday/Monday to Tuesday
    |'
  prefs: []
  type: TYPE_TB
- en: '| previous_friday | move Saturday and Sunday to previous Friday” |'
  prefs: []
  type: TYPE_TB
- en: '| next_monday | move Saturday and Sunday to following Monday |'
  prefs: []
  type: TYPE_TB
- en: 'An example of how holidays and holiday calendars are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '**weekday=MO(2)** is same as **2 * Week(weekday=2)**'
  prefs: []
  type: TYPE_NORMAL
- en: Using this calendar, creating an index or doing offset arithmetic skips weekends
    and holidays (i.e., Memorial Day/July 4th). For example, the below defines a custom
    business day offset using the `ExampleCalendar`. Like any other offset, it can
    be used to create a `DatetimeIndex` or added to `datetime` or `Timestamp` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: Ranges are defined by the `start_date` and `end_date` class attributes of `AbstractHolidayCalendar`.
    The defaults are shown below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: These dates can be overwritten by setting the attributes as datetime/Timestamp/string.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: Every calendar class is accessible by name using the `get_calendar` function
    which returns a holiday class instance. Any imported calendar class will automatically
    be available by this function. Also, `HolidayCalendarFactory` provides an easy
    interface to create calendars that are combinations of calendars or calendars
    with additional rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '## Time Series-related instance methods'
  prefs: []
  type: TYPE_NORMAL
- en: Shifting / lagging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One may want to *shift* or *lag* the values in a time series back and forward
    in time. The method for this is [`shift()`](../reference/api/pandas.Series.shift.html#pandas.Series.shift
    "pandas.Series.shift"), which is available on all of the pandas objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: The `shift` method accepts an `freq` argument which can accept a `DateOffset`
    class or other `timedelta`-like object or also an [offset alias](#timeseries-offset-aliases).
  prefs: []
  type: TYPE_NORMAL
- en: 'When `freq` is specified, `shift` method changes all the dates in the index
    rather than changing the alignment of the data and the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: Note that with when `freq` is specified, the leading entry is no longer NaN
    because the data is not being realigned.
  prefs: []
  type: TYPE_NORMAL
- en: Frequency conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary function for changing frequencies is the [`asfreq()`](../reference/api/pandas.Series.asfreq.html#pandas.Series.asfreq
    "pandas.Series.asfreq") method. For a `DatetimeIndex`, this is basically just
    a thin, but convenient wrapper around [`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") which generates a `date_range` and calls `reindex`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '`asfreq` provides a further convenience so you can specify an interpolation
    method for any gaps that may appear after the frequency conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: Filling forward / backward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Related to `asfreq` and `reindex` is [`fillna()`](../reference/api/pandas.Series.fillna.html#pandas.Series.fillna
    "pandas.Series.fillna"), which is documented in the [missing data section](missing_data.html#missing-data-fillna).
  prefs: []
  type: TYPE_NORMAL
- en: Converting to Python datetimes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`DatetimeIndex` can be converted to an array of Python native [`datetime.datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime
    "(in Python v3.12)") objects using the `to_pydatetime` method.'
  prefs: []
  type: TYPE_NORMAL
- en: Shifting / lagging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One may want to *shift* or *lag* the values in a time series back and forward
    in time. The method for this is [`shift()`](../reference/api/pandas.Series.shift.html#pandas.Series.shift
    "pandas.Series.shift"), which is available on all of the pandas objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: The `shift` method accepts an `freq` argument which can accept a `DateOffset`
    class or other `timedelta`-like object or also an [offset alias](#timeseries-offset-aliases).
  prefs: []
  type: TYPE_NORMAL
- en: 'When `freq` is specified, `shift` method changes all the dates in the index
    rather than changing the alignment of the data and the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: Note that with when `freq` is specified, the leading entry is no longer NaN
    because the data is not being realigned.
  prefs: []
  type: TYPE_NORMAL
- en: Frequency conversion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary function for changing frequencies is the [`asfreq()`](../reference/api/pandas.Series.asfreq.html#pandas.Series.asfreq
    "pandas.Series.asfreq") method. For a `DatetimeIndex`, this is basically just
    a thin, but convenient wrapper around [`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") which generates a `date_range` and calls `reindex`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: '`asfreq` provides a further convenience so you can specify an interpolation
    method for any gaps that may appear after the frequency conversion.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: Filling forward / backward
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Related to `asfreq` and `reindex` is [`fillna()`](../reference/api/pandas.Series.fillna.html#pandas.Series.fillna
    "pandas.Series.fillna"), which is documented in the [missing data section](missing_data.html#missing-data-fillna).
  prefs: []
  type: TYPE_NORMAL
- en: Converting to Python datetimes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`DatetimeIndex` can be converted to an array of Python native [`datetime.datetime`](https://docs.python.org/3/library/datetime.html#datetime.datetime
    "(in Python v3.12)") objects using the `to_pydatetime` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Resampling'
  prefs: []
  type: TYPE_NORMAL
- en: pandas has a simple, powerful, and efficient functionality for performing resampling
    operations during frequency conversion (e.g., converting secondly data into 5-minutely
    data). This is extremely common in, but not limited to, financial applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[`resample()`](../reference/api/pandas.Series.resample.html#pandas.Series.resample
    "pandas.Series.resample") is a time-based groupby, followed by a reduction method
    on each of its groups. See some [cookbook examples](cookbook.html#cookbook-resample)
    for some advanced strategies.'
  prefs: []
  type: TYPE_NORMAL
- en: The `resample()` method can be used directly from `DataFrameGroupBy` objects,
    see the [groupby docs](groupby.html#groupby-transform-window-resample).
  prefs: []
  type: TYPE_NORMAL
- en: Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: The `resample` function is very flexible and allows you to specify many different
    parameters to control the frequency conversion and resampling operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any built-in method available via [GroupBy](../reference/groupby.html#api-groupby)
    is available as a method of the returned object, including `sum`, `mean`, `std`,
    `sem`, `max`, `min`, `median`, `first`, `last`, `ohlc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: 'For downsampling, `closed` can be set to ‘left’ or ‘right’ to specify which
    end of the interval is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: Parameters like `label` are used to manipulate the resulting labels. `label`
    specifies whether the result is labeled with the beginning or the end of the interval.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The default values for `label` and `closed` is ‘**left**’ for all frequency
    offsets except for ‘ME’, ‘YE’, ‘QE’, ‘BME’, ‘BYE’, ‘BQE’, and ‘W’ which all have
    a default of ‘right’.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might unintendedly lead to looking ahead, where the value for a later
    time is pulled back to a previous time as in the following example with the [`BusinessDay`](../reference/api/pandas.tseries.offsets.BusinessDay.html#pandas.tseries.offsets.BusinessDay
    "pandas.tseries.offsets.BusinessDay") frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the value for Sunday got pulled back to the previous Friday. To get
    the behavior where the value for Sunday is pushed to Monday, use instead
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: The `axis` parameter can be set to 0 or 1 and allows you to resample the specified
    axis for a `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: '`kind` can be set to ‘timestamp’ or ‘period’ to convert the resulting index
    to/from timestamp and time span representations. By default `resample` retains
    the input representation.'
  prefs: []
  type: TYPE_NORMAL
- en: '`convention` can be set to ‘start’ or ‘end’ when resampling period data (detail
    below). It specifies how low frequency periods are converted to higher frequency
    periods.'
  prefs: []
  type: TYPE_NORMAL
- en: Upsampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For upsampling, you can specify a way to upsample and the `limit` parameter
    to interpolate over the gaps that are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: Sparse resampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sparse timeseries are the ones where you have a lot fewer points relative to
    the amount of time you are looking to resample. Naively upsampling a sparse series
    can potentially generate lots of intermediate values. When you don’t want to use
    a method to fill these values, e.g. `fill_method` is `None`, then intermediate
    values will be filled with `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `resample` is a time-based groupby, the following is a method to efficiently
    resample only the groups that are not all `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to resample to the full range of the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instead only resample those groups where we have points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: '### Aggregation'
  prefs: []
  type: TYPE_NORMAL
- en: The `resample()` method returns a `pandas.api.typing.Resampler` instance. Similar
    to the [aggregating API](basics.html#basics-aggregate), [groupby API](groupby.html#groupby-aggregate),
    and the [window API](window.html#window-overview), a `Resampler` can be selectively
    resampled.
  prefs: []
  type: TYPE_NORMAL
- en: Resampling a `DataFrame`, the default will be to act on all columns with the
    same function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: We can select a specific column or columns using standard getitem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass a list or dict of functions to do aggregation with, outputting
    a `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: 'On a resampled `DataFrame`, you can pass a list of functions to apply to each
    column, which produces an aggregated result with a hierarchical index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing a dict to `aggregate` you can apply a different aggregation to the
    columns of a `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'The function names can also be strings. In order for a string to be valid it
    must be implemented on the resampled object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, you can also specify multiple aggregation functions for each column
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: If a `DataFrame` does not have a datetimelike index, but instead you want to
    resample based on datetimelike column in the frame, it can passed to the `on`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, if you instead want to resample by a datetimelike level of `MultiIndex`,
    its name or location can be passed to the `level` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]  ### Iterating through groups'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Resampler` object in hand, iterating through the grouped data is
    very natural and functions similarly to [`itertools.groupby()`](https://docs.python.org/3/library/itertools.html#itertools.groupby
    "(in Python v3.12)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: 'See [Iterating through groups](groupby.html#groupby-iterating-label) or `Resampler.__iter__`
    for more.  ### Use `origin` or `offset` to adjust the start of the bins'
  prefs: []
  type: TYPE_NORMAL
- en: The bins of the grouping are adjusted based on the beginning of the day of the
    time series starting point. This works well with frequencies that are multiples
    of a day (like `30D`) or that divide a day evenly (like `90s` or `1min`). This
    can create inconsistencies with some frequencies that do not meet this criteria.
    To change this behavior you can specify a fixed Timestamp with the argument `origin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that, when using `origin` with its default value (`''start_day''`),
    the result after `''2000-10-02 00:00:00''` are not identical depending on the
    start of time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that, when setting `origin` to `''epoch''`, the result after
    `''2000-10-02 00:00:00''` are identical depending on the start of time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'If needed you can use a custom timestamp for `origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'If needed you can just adjust the bins with an `offset` Timedelta that would
    be added to the default `origin`. Those two examples are equivalent for this time
    series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `'start'` for `origin` on the last example. In that case, `origin`
    will be set to the first value of the timeseries.
  prefs: []
  type: TYPE_NORMAL
- en: Backward resample
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New in version 1.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of adjusting the beginning of bins, sometimes we need to fix the end
    of the bins to make a backward resample with a given `freq`. The backward resample
    sets `closed` to `'right'` by default since the last value should be considered
    as the edge point for the last bin.
  prefs: []
  type: TYPE_NORMAL
- en: We can set `origin` to `'end'`. The value for a specific `Timestamp` index stands
    for the resample result from the current `Timestamp` minus `freq` to the current
    `Timestamp` with a right close.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: Besides, in contrast with the `'start_day'` option, `end_day` is supported.
    This will set the origin as the ceiling midnight of the largest `Timestamp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: The above result uses `2000-10-02 00:29:00` as the last bin’s right edge since
    the following computation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: Basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: The `resample` function is very flexible and allows you to specify many different
    parameters to control the frequency conversion and resampling operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any built-in method available via [GroupBy](../reference/groupby.html#api-groupby)
    is available as a method of the returned object, including `sum`, `mean`, `std`,
    `sem`, `max`, `min`, `median`, `first`, `last`, `ohlc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: 'For downsampling, `closed` can be set to ‘left’ or ‘right’ to specify which
    end of the interval is closed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: Parameters like `label` are used to manipulate the resulting labels. `label`
    specifies whether the result is labeled with the beginning or the end of the interval.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The default values for `label` and `closed` is ‘**left**’ for all frequency
    offsets except for ‘ME’, ‘YE’, ‘QE’, ‘BME’, ‘BYE’, ‘BQE’, and ‘W’ which all have
    a default of ‘right’.
  prefs: []
  type: TYPE_NORMAL
- en: 'This might unintendedly lead to looking ahead, where the value for a later
    time is pulled back to a previous time as in the following example with the [`BusinessDay`](../reference/api/pandas.tseries.offsets.BusinessDay.html#pandas.tseries.offsets.BusinessDay
    "pandas.tseries.offsets.BusinessDay") frequency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the value for Sunday got pulled back to the previous Friday. To get
    the behavior where the value for Sunday is pushed to Monday, use instead
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs: []
  type: TYPE_PRE
- en: The `axis` parameter can be set to 0 or 1 and allows you to resample the specified
    axis for a `DataFrame`.
  prefs: []
  type: TYPE_NORMAL
- en: '`kind` can be set to ‘timestamp’ or ‘period’ to convert the resulting index
    to/from timestamp and time span representations. By default `resample` retains
    the input representation.'
  prefs: []
  type: TYPE_NORMAL
- en: '`convention` can be set to ‘start’ or ‘end’ when resampling period data (detail
    below). It specifies how low frequency periods are converted to higher frequency
    periods.'
  prefs: []
  type: TYPE_NORMAL
- en: Upsampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For upsampling, you can specify a way to upsample and the `limit` parameter
    to interpolate over the gaps that are created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: Sparse resampling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sparse timeseries are the ones where you have a lot fewer points relative to
    the amount of time you are looking to resample. Naively upsampling a sparse series
    can potentially generate lots of intermediate values. When you don’t want to use
    a method to fill these values, e.g. `fill_method` is `None`, then intermediate
    values will be filled with `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: Since `resample` is a time-based groupby, the following is a method to efficiently
    resample only the groups that are not all `NaN`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to resample to the full range of the series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: 'We can instead only resample those groups where we have points as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '### Aggregation'
  prefs: []
  type: TYPE_NORMAL
- en: The `resample()` method returns a `pandas.api.typing.Resampler` instance. Similar
    to the [aggregating API](basics.html#basics-aggregate), [groupby API](groupby.html#groupby-aggregate),
    and the [window API](window.html#window-overview), a `Resampler` can be selectively
    resampled.
  prefs: []
  type: TYPE_NORMAL
- en: Resampling a `DataFrame`, the default will be to act on all columns with the
    same function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: We can select a specific column or columns using standard getitem.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: 'You can pass a list or dict of functions to do aggregation with, outputting
    a `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs: []
  type: TYPE_PRE
- en: 'On a resampled `DataFrame`, you can pass a list of functions to apply to each
    column, which produces an aggregated result with a hierarchical index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing a dict to `aggregate` you can apply a different aggregation to the
    columns of a `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: 'The function names can also be strings. In order for a string to be valid it
    must be implemented on the resampled object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: Furthermore, you can also specify multiple aggregation functions for each column
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: If a `DataFrame` does not have a datetimelike index, but instead you want to
    resample based on datetimelike column in the frame, it can passed to the `on`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, if you instead want to resample by a datetimelike level of `MultiIndex`,
    its name or location can be passed to the `level` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: '### Iterating through groups'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `Resampler` object in hand, iterating through the grouped data is
    very natural and functions similarly to [`itertools.groupby()`](https://docs.python.org/3/library/itertools.html#itertools.groupby
    "(in Python v3.12)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: See [Iterating through groups](groupby.html#groupby-iterating-label) or `Resampler.__iter__`
    for more.
  prefs: []
  type: TYPE_NORMAL
- en: '### Use `origin` or `offset` to adjust the start of the bins'
  prefs: []
  type: TYPE_NORMAL
- en: The bins of the grouping are adjusted based on the beginning of the day of the
    time series starting point. This works well with frequencies that are multiples
    of a day (like `30D`) or that divide a day evenly (like `90s` or `1min`). This
    can create inconsistencies with some frequencies that do not meet this criteria.
    To change this behavior you can specify a fixed Timestamp with the argument `origin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that, when using `origin` with its default value (`''start_day''`),
    the result after `''2000-10-02 00:00:00''` are not identical depending on the
    start of time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we can see that, when setting `origin` to `''epoch''`, the result after
    `''2000-10-02 00:00:00''` are identical depending on the start of time series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'If needed you can use a custom timestamp for `origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'If needed you can just adjust the bins with an `offset` Timedelta that would
    be added to the default `origin`. Those two examples are equivalent for this time
    series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: Note the use of `'start'` for `origin` on the last example. In that case, `origin`
    will be set to the first value of the timeseries.
  prefs: []
  type: TYPE_NORMAL
- en: Backward resample
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New in version 1.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of adjusting the beginning of bins, sometimes we need to fix the end
    of the bins to make a backward resample with a given `freq`. The backward resample
    sets `closed` to `'right'` by default since the last value should be considered
    as the edge point for the last bin.
  prefs: []
  type: TYPE_NORMAL
- en: We can set `origin` to `'end'`. The value for a specific `Timestamp` index stands
    for the resample result from the current `Timestamp` minus `freq` to the current
    `Timestamp` with a right close.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Besides, in contrast with the `'start_day'` option, `end_day` is supported.
    This will set the origin as the ceiling midnight of the largest `Timestamp`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: The above result uses `2000-10-02 00:29:00` as the last bin’s right edge since
    the following computation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: '## Time span representation'
  prefs: []
  type: TYPE_NORMAL
- en: Regular intervals of time are represented by `Period` objects in pandas while
    sequences of `Period` objects are collected in a `PeriodIndex`, which can be created
    with the convenience function `period_range`.
  prefs: []
  type: TYPE_NORMAL
- en: Period
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Period` represents a span of time (e.g., a day, a month, a quarter, etc).
    You can specify the span via `freq` keyword using a frequency alias like below.
    Because `freq` represents a span of `Period`, it cannot be negative like “-3D”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: Adding and subtracting integers from periods shifts the period by its own frequency.
    Arithmetic is not allowed between `Period` with different `freq` (span).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: If `Period` freq is daily or higher (`D`, `h`, `min`, `s`, `ms`, `us`, and `ns`),
    `offsets` and `timedelta`-like can be added if the result can have the same freq.
    Otherwise, `ValueError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: If `Period` has other frequencies, only the same `offsets` can be added. Otherwise,
    `ValueError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking the difference of `Period` instances with the same frequency will return
    the number of frequency units between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: PeriodIndex and period_range
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regular sequences of `Period` objects can be collected in a `PeriodIndex`,
    which can be constructed using the `period_range` convenience function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PeriodIndex` constructor can also be used directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: Passing multiplied frequency outputs a sequence of `Period` which has multiplied
    span.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: If `start` or `end` are `Period` objects, they will be used as anchor endpoints
    for a `PeriodIndex` with frequency matching that of the `PeriodIndex` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like `DatetimeIndex`, a `PeriodIndex` can also be used to index pandas
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: '`PeriodIndex` supports addition and subtraction with the same rule as `Period`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: '`PeriodIndex` has its own dtype named `period`, refer to [Period Dtypes](#timeseries-period-dtype).'
  prefs: []
  type: TYPE_NORMAL
- en: '### Period dtypes'
  prefs: []
  type: TYPE_NORMAL
- en: '`PeriodIndex` has a custom `period` dtype. This is a pandas extension dtype
    similar to the [timezone aware dtype](#timeseries-timezone-series) (`datetime64[ns,
    tz]`).'
  prefs: []
  type: TYPE_NORMAL
- en: The `period` dtype holds the `freq` attribute and is represented with `period[freq]`
    like `period[D]` or `period[M]`, using [frequency strings](#timeseries-period-aliases).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: 'The `period` dtype can be used in `.astype(...)`. It allows one to change the
    `freq` of a `PeriodIndex` like `.asfreq()` and convert a `DatetimeIndex` to `PeriodIndex`
    like `to_period()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: PeriodIndex partial string indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PeriodIndex now supports partial string slicing with non-monotonic indexes.
  prefs: []
  type: TYPE_NORMAL
- en: You can pass in dates and strings to `Series` and `DataFrame` with `PeriodIndex`,
    in the same manner as `DatetimeIndex`. For details, refer to [DatetimeIndex Partial
    String Indexing](#timeseries-partialindexing).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: Passing a string representing a lower frequency than `PeriodIndex` returns partial
    sliced data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: As with `DatetimeIndex`, the endpoints will be included in the result. The example
    below slices data starting from 10:00 to 11:59.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: Frequency conversion and resampling with PeriodIndex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The frequency of `Period` and `PeriodIndex` can be converted via the `asfreq`
    method. Let’s start with the fiscal year 2011, ending in December:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert it to a monthly frequency. Using the `how` parameter, we can
    specify whether to return the starting or ending month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: 'The shorthands ‘s’ and ‘e’ are provided for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting to a “super-period” (e.g., annual frequency is a super-period of
    quarterly frequency) automatically returns the super-period that includes the
    input period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: Note that since we converted to an annual frequency that ends the year in November,
    the monthly period of December 2011 is actually in the 2012 Y-NOV period.
  prefs: []
  type: TYPE_NORMAL
- en: Period conversions with anchored frequencies are particularly useful for working
    with various quarterly data common to economics, business, and other fields. Many
    organizations define quarters relative to the month in which their fiscal year
    starts and ends. Thus, first quarter of 2011 could start in 2010 or a few months
    into 2011\. Via anchored frequencies, pandas works for all quarterly frequencies
    `Q-JAN` through `Q-DEC`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Q-DEC` define regular calendar quarters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '`Q-MAR` defines fiscal year end in March:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: Period
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A `Period` represents a span of time (e.g., a day, a month, a quarter, etc).
    You can specify the span via `freq` keyword using a frequency alias like below.
    Because `freq` represents a span of `Period`, it cannot be negative like “-3D”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: Adding and subtracting integers from periods shifts the period by its own frequency.
    Arithmetic is not allowed between `Period` with different `freq` (span).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: If `Period` freq is daily or higher (`D`, `h`, `min`, `s`, `ms`, `us`, and `ns`),
    `offsets` and `timedelta`-like can be added if the result can have the same freq.
    Otherwise, `ValueError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: If `Period` has other frequencies, only the same `offsets` can be added. Otherwise,
    `ValueError` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: 'Taking the difference of `Period` instances with the same frequency will return
    the number of frequency units between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: PeriodIndex and period_range
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Regular sequences of `Period` objects can be collected in a `PeriodIndex`,
    which can be constructed using the `period_range` convenience function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PeriodIndex` constructor can also be used directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: Passing multiplied frequency outputs a sequence of `Period` which has multiplied
    span.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: If `start` or `end` are `Period` objects, they will be used as anchor endpoints
    for a `PeriodIndex` with frequency matching that of the `PeriodIndex` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like `DatetimeIndex`, a `PeriodIndex` can also be used to index pandas
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '`PeriodIndex` supports addition and subtraction with the same rule as `Period`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: '`PeriodIndex` has its own dtype named `period`, refer to [Period Dtypes](#timeseries-period-dtype).'
  prefs: []
  type: TYPE_NORMAL
- en: '### Period dtypes'
  prefs: []
  type: TYPE_NORMAL
- en: '`PeriodIndex` has a custom `period` dtype. This is a pandas extension dtype
    similar to the [timezone aware dtype](#timeseries-timezone-series) (`datetime64[ns,
    tz]`).'
  prefs: []
  type: TYPE_NORMAL
- en: The `period` dtype holds the `freq` attribute and is represented with `period[freq]`
    like `period[D]` or `period[M]`, using [frequency strings](#timeseries-period-aliases).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'The `period` dtype can be used in `.astype(...)`. It allows one to change the
    `freq` of a `PeriodIndex` like `.asfreq()` and convert a `DatetimeIndex` to `PeriodIndex`
    like `to_period()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: PeriodIndex partial string indexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PeriodIndex now supports partial string slicing with non-monotonic indexes.
  prefs: []
  type: TYPE_NORMAL
- en: You can pass in dates and strings to `Series` and `DataFrame` with `PeriodIndex`,
    in the same manner as `DatetimeIndex`. For details, refer to [DatetimeIndex Partial
    String Indexing](#timeseries-partialindexing).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: Passing a string representing a lower frequency than `PeriodIndex` returns partial
    sliced data.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: As with `DatetimeIndex`, the endpoints will be included in the result. The example
    below slices data starting from 10:00 to 11:59.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: Frequency conversion and resampling with PeriodIndex
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The frequency of `Period` and `PeriodIndex` can be converted via the `asfreq`
    method. Let’s start with the fiscal year 2011, ending in December:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: 'We can convert it to a monthly frequency. Using the `how` parameter, we can
    specify whether to return the starting or ending month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: 'The shorthands ‘s’ and ‘e’ are provided for convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting to a “super-period” (e.g., annual frequency is a super-period of
    quarterly frequency) automatically returns the super-period that includes the
    input period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: Note that since we converted to an annual frequency that ends the year in November,
    the monthly period of December 2011 is actually in the 2012 Y-NOV period.
  prefs: []
  type: TYPE_NORMAL
- en: Period conversions with anchored frequencies are particularly useful for working
    with various quarterly data common to economics, business, and other fields. Many
    organizations define quarters relative to the month in which their fiscal year
    starts and ends. Thus, first quarter of 2011 could start in 2010 or a few months
    into 2011\. Via anchored frequencies, pandas works for all quarterly frequencies
    `Q-JAN` through `Q-DEC`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Q-DEC` define regular calendar quarters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: '`Q-MAR` defines fiscal year end in March:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: '## Converting between representations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Timestamped data can be converted to PeriodIndex-ed data using `to_period`
    and vice-versa using `to_timestamp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that ‘s’ and ‘e’ can be used to return the timestamps at the start
    or end of the period:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting between period and timestamp enables some convenient arithmetic
    functions to be used. In the following example, we convert a quarterly frequency
    with year ending in November to 9am of the end of the month following the quarter
    end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs: []
  type: TYPE_PRE
- en: '## Representing out-of-bounds spans'
  prefs: []
  type: TYPE_NORMAL
- en: If you have data that is outside of the `Timestamp` bounds, see [Timestamp limitations](#timeseries-timestamp-limits),
    then you can use a `PeriodIndex` and/or `Series` of `Periods` to do computations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs: []
  type: TYPE_PRE
- en: To convert from an `int64` based YYYYMMDD representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs: []
  type: TYPE_PRE
- en: 'These can easily be converted to a `PeriodIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs: []
  type: TYPE_PRE
- en: '## Time zone handling'
  prefs: []
  type: TYPE_NORMAL
- en: pandas provides rich support for working with timestamps in different time zones
    using the `pytz` and `dateutil` libraries or [`datetime.timezone`](https://docs.python.org/3/library/datetime.html#datetime.timezone
    "(in Python v3.12)") objects from the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: Working with time zones
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, pandas objects are time zone unaware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs: []
  type: TYPE_PRE
- en: To localize these dates to a time zone (assign a particular time zone to a naive
    date), you can use the `tz_localize` method or the `tz` keyword argument in [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range"), [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp"), or [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex"). You can either pass `pytz` or `dateutil` time zone objects
    or Olson time zone database strings. Olson time zone strings will return `pytz`
    time zone objects by default. To return `dateutil` time zone objects, append `dateutil/`
    before the string.
  prefs: []
  type: TYPE_NORMAL
- en: In `pytz` you can find a list of common (and less common) time zones using `from
    pytz import common_timezones, all_timezones`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dateutil` uses the OS time zones so there isn’t a fixed list available. For
    common zones, the names are the same as `pytz`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE437]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `UTC` time zone is a special case in `dateutil` and should be
    constructed explicitly as an instance of `dateutil.tz.tzutc`. You can also construct
    other time zones objects explicitly first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs: []
  type: TYPE_PRE
- en: To convert a time zone aware pandas object from one time zone to another, you
    can use the `tz_convert` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using `pytz` time zones, [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") will construct a different time zone object than a [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") for the same time zone input. A [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") can hold a collection of [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") objects that may have different UTC offsets and cannot be
    succinctly represented by one `pytz` time zone instance while one [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") represents one point in time with a specific UTC offset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be wary of conversions between libraries. For some time zones, `pytz` and `dateutil`
    have different definitions of the zone. This is more of a problem for unusual
    time zones than for ‘standard’ zones like `US/Eastern`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that a time zone definition across versions of time zone libraries
    may not be considered equal. This may cause problems when working with stored
    data that is localized using one version and operated on with a different version.
    See [here](io.html#io-hdf5-notes) for how to handle such a situation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: For `pytz` time zones, it is incorrect to pass a time zone object directly into
    the `datetime.datetime` constructor (e.g., `datetime.datetime(2011, 1, 1, tzinfo=pytz.timezone('US/Eastern'))`.
    Instead, the datetime needs to be localized using the `localize` method on the
    `pytz` time zone object.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that for times in the future, correct conversion between time zones
    (and UTC) cannot be guaranteed by any time zone library because a timezone’s offset
    from UTC may be changed by the respective government.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: If you are using dates beyond 2038-01-18, due to current deficiencies in the
    underlying libraries caused by the year 2038 problem, daylight saving time (DST)
    adjustments to timezone aware dates will not be applied. If and when the underlying
    libraries are fixed, the DST transitions will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for two dates that are in British Summer Time (and so would normally
    be GMT+1), both the following asserts evaluate as true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, all timestamps are stored in UTC. Values from a time zone aware
    [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") or [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") will have their fields (day, hour, minute, etc.) localized
    to the time zone. However, timestamps with the same UTC value are still considered
    to be equal even if they are in different time zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs: []
  type: TYPE_PRE
- en: 'Operations between [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") in different time zones will yield UTC [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), aligning the data on the UTC timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: To remove time zone information, use `tz_localize(None)` or `tz_convert(None)`.
    `tz_localize(None)` will remove the time zone yielding the local time representation.
    `tz_convert(None)` will remove the time zone after converting to UTC time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: '### Fold'
  prefs: []
  type: TYPE_NORMAL
- en: For ambiguous times, pandas supports explicitly specifying the keyword-only
    fold argument. Due to daylight saving time, one wall clock time can occur twice
    when shifting from summer to winter time; fold describes whether the datetime-like
    corresponds to the first (0) or the second time (1) the wall clock hits the ambiguous
    time. Fold is supported only for constructing from naive `datetime.datetime` (see
    [datetime documentation](https://docs.python.org/3/library/datetime.html) for
    details) or from [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") or for constructing from components (see below). Only `dateutil`
    timezones are supported (see [dateutil documentation](https://dateutil.readthedocs.io/en/stable/tz.html#dateutil.tz.enfold)
    for `dateutil` methods that deal with ambiguous datetimes) as `pytz` timezones
    do not support fold (see [pytz documentation](http://pytz.sourceforge.net/index.html)
    for details on how `pytz` deals with ambiguous datetimes). To localize an ambiguous
    datetime with `pytz`, please use [`Timestamp.tz_localize()`](../reference/api/pandas.Timestamp.tz_localize.html#pandas.Timestamp.tz_localize
    "pandas.Timestamp.tz_localize"). In general, we recommend to rely on [`Timestamp.tz_localize()`](../reference/api/pandas.Timestamp.tz_localize.html#pandas.Timestamp.tz_localize
    "pandas.Timestamp.tz_localize") when localizing ambiguous datetimes if you need
    direct control over how they are handled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]  ### Ambiguous times when localizing'
  prefs: []
  type: TYPE_NORMAL
- en: '`tz_localize` may not be able to determine the UTC offset of a timestamp because
    daylight savings time (DST) in a local time zone causes some times to occur twice
    within one day (“clocks fall back”). The following options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''raise''`: Raises a `pytz.AmbiguousTimeError` (the default behavior)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''infer''`: Attempt to determine the correct offset base on the monotonicity
    of the timestamps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''NaT''`: Replaces ambiguous times with `NaT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`: `True` represents a DST time, `False` represents non-DST time. An array-like
    of `bool` values is supported for a sequence of times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs: []
  type: TYPE_PRE
- en: This will fail as there are ambiguous times (`'11/06/2011 01:00'`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs: []
  type: TYPE_PRE
- en: Handle these ambiguous times by specifying the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]  ### Nonexistent times when localizing'
  prefs: []
  type: TYPE_NORMAL
- en: 'A DST transition may also shift the local time ahead by 1 hour creating nonexistent
    local times (“clocks spring forward”). The behavior of localizing a timeseries
    with nonexistent times can be controlled by the `nonexistent` argument. The following
    options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''raise''`: Raises a `pytz.NonExistentTimeError` (the default behavior)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''NaT''`: Replaces nonexistent times with `NaT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''shift_forward''`: Shifts nonexistent times forward to the closest real time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''shift_backward''`: Shifts nonexistent times backward to the closest real
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'timedelta object: Shifts nonexistent times by the timedelta duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs: []
  type: TYPE_PRE
- en: Localization of nonexistent times will raise an error by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs: []
  type: TYPE_PRE
- en: Transform nonexistent times to `NaT` or shift the times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]  ### Time zone Series operations'
  prefs: []
  type: TYPE_NORMAL
- en: A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    with time zone **naive** values is represented with a dtype of `datetime64[ns]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    with a time zone **aware** values is represented with a dtype of `datetime64[ns,
    tz]` where `tz` is the time zone
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: Both of these [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    time zone information can be manipulated via the `.dt` accessor, see [the dt accessor
    section](basics.html#basics-dt-accessors).
  prefs: []
  type: TYPE_NORMAL
- en: For example, to localize and convert a naive stamp to time zone aware.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: Time zone information can also be manipulated using the `astype` method. This
    method can convert between different timezone-aware dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Using [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") on a `Series`, returns a NumPy array of the data. NumPy
    does not currently support time zones (even though it is *printing* in the local
    time zone!), therefore an object array of Timestamps is returned for time zone
    aware data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: 'By converting to an object array of Timestamps, it preserves the time zone
    information. For example, when converting back to a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you want an actual NumPy `datetime64[ns]` array (with the values
    converted to UTC) instead of an array of objects, you can specify the `dtype`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: Working with time zones
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, pandas objects are time zone unaware:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: To localize these dates to a time zone (assign a particular time zone to a naive
    date), you can use the `tz_localize` method or the `tz` keyword argument in [`date_range()`](../reference/api/pandas.date_range.html#pandas.date_range
    "pandas.date_range"), [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp"), or [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex"). You can either pass `pytz` or `dateutil` time zone objects
    or Olson time zone database strings. Olson time zone strings will return `pytz`
    time zone objects by default. To return `dateutil` time zone objects, append `dateutil/`
    before the string.
  prefs: []
  type: TYPE_NORMAL
- en: In `pytz` you can find a list of common (and less common) time zones using `from
    pytz import common_timezones, all_timezones`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dateutil` uses the OS time zones so there isn’t a fixed list available. For
    common zones, the names are the same as `pytz`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `UTC` time zone is a special case in `dateutil` and should be
    constructed explicitly as an instance of `dateutil.tz.tzutc`. You can also construct
    other time zones objects explicitly first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: To convert a time zone aware pandas object from one time zone to another, you
    can use the `tz_convert` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using `pytz` time zones, [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") will construct a different time zone object than a [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") for the same time zone input. A [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") can hold a collection of [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") objects that may have different UTC offsets and cannot be
    succinctly represented by one `pytz` time zone instance while one [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") represents one point in time with a specific UTC offset.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be wary of conversions between libraries. For some time zones, `pytz` and `dateutil`
    have different definitions of the zone. This is more of a problem for unusual
    time zones than for ‘standard’ zones like `US/Eastern`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that a time zone definition across versions of time zone libraries
    may not be considered equal. This may cause problems when working with stored
    data that is localized using one version and operated on with a different version.
    See [here](io.html#io-hdf5-notes) for how to handle such a situation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: For `pytz` time zones, it is incorrect to pass a time zone object directly into
    the `datetime.datetime` constructor (e.g., `datetime.datetime(2011, 1, 1, tzinfo=pytz.timezone('US/Eastern'))`.
    Instead, the datetime needs to be localized using the `localize` method on the
    `pytz` time zone object.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that for times in the future, correct conversion between time zones
    (and UTC) cannot be guaranteed by any time zone library because a timezone’s offset
    from UTC may be changed by the respective government.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: If you are using dates beyond 2038-01-18, due to current deficiencies in the
    underlying libraries caused by the year 2038 problem, daylight saving time (DST)
    adjustments to timezone aware dates will not be applied. If and when the underlying
    libraries are fixed, the DST transitions will be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for two dates that are in British Summer Time (and so would normally
    be GMT+1), both the following asserts evaluate as true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: 'Under the hood, all timestamps are stored in UTC. Values from a time zone aware
    [`DatetimeIndex`](../reference/api/pandas.DatetimeIndex.html#pandas.DatetimeIndex
    "pandas.DatetimeIndex") or [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") will have their fields (day, hour, minute, etc.) localized
    to the time zone. However, timestamps with the same UTC value are still considered
    to be equal even if they are in different time zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: 'Operations between [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") in different time zones will yield UTC [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), aligning the data on the UTC timestamps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: To remove time zone information, use `tz_localize(None)` or `tz_convert(None)`.
    `tz_localize(None)` will remove the time zone yielding the local time representation.
    `tz_convert(None)` will remove the time zone after converting to UTC time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: '### Fold'
  prefs: []
  type: TYPE_NORMAL
- en: For ambiguous times, pandas supports explicitly specifying the keyword-only
    fold argument. Due to daylight saving time, one wall clock time can occur twice
    when shifting from summer to winter time; fold describes whether the datetime-like
    corresponds to the first (0) or the second time (1) the wall clock hits the ambiguous
    time. Fold is supported only for constructing from naive `datetime.datetime` (see
    [datetime documentation](https://docs.python.org/3/library/datetime.html) for
    details) or from [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") or for constructing from components (see below). Only `dateutil`
    timezones are supported (see [dateutil documentation](https://dateutil.readthedocs.io/en/stable/tz.html#dateutil.tz.enfold)
    for `dateutil` methods that deal with ambiguous datetimes) as `pytz` timezones
    do not support fold (see [pytz documentation](http://pytz.sourceforge.net/index.html)
    for details on how `pytz` deals with ambiguous datetimes). To localize an ambiguous
    datetime with `pytz`, please use [`Timestamp.tz_localize()`](../reference/api/pandas.Timestamp.tz_localize.html#pandas.Timestamp.tz_localize
    "pandas.Timestamp.tz_localize"). In general, we recommend to rely on [`Timestamp.tz_localize()`](../reference/api/pandas.Timestamp.tz_localize.html#pandas.Timestamp.tz_localize
    "pandas.Timestamp.tz_localize") when localizing ambiguous datetimes if you need
    direct control over how they are handled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: '### Ambiguous times when localizing'
  prefs: []
  type: TYPE_NORMAL
- en: '`tz_localize` may not be able to determine the UTC offset of a timestamp because
    daylight savings time (DST) in a local time zone causes some times to occur twice
    within one day (“clocks fall back”). The following options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''raise''`: Raises a `pytz.AmbiguousTimeError` (the default behavior)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''infer''`: Attempt to determine the correct offset base on the monotonicity
    of the timestamps'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''NaT''`: Replaces ambiguous times with `NaT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool`: `True` represents a DST time, `False` represents non-DST time. An array-like
    of `bool` values is supported for a sequence of times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: This will fail as there are ambiguous times (`'11/06/2011 01:00'`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: Handle these ambiguous times by specifying the following.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: '### Nonexistent times when localizing'
  prefs: []
  type: TYPE_NORMAL
- en: 'A DST transition may also shift the local time ahead by 1 hour creating nonexistent
    local times (“clocks spring forward”). The behavior of localizing a timeseries
    with nonexistent times can be controlled by the `nonexistent` argument. The following
    options are available:'
  prefs: []
  type: TYPE_NORMAL
- en: '`''raise''`: Raises a `pytz.NonExistentTimeError` (the default behavior)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''NaT''`: Replaces nonexistent times with `NaT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''shift_forward''`: Shifts nonexistent times forward to the closest real time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''shift_backward''`: Shifts nonexistent times backward to the closest real
    time'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'timedelta object: Shifts nonexistent times by the timedelta duration'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: Localization of nonexistent times will raise an error by default.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: Transform nonexistent times to `NaT` or shift the times.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: '### Time zone Series operations'
  prefs: []
  type: TYPE_NORMAL
- en: A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    with time zone **naive** values is represented with a dtype of `datetime64[ns]`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: A [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    with a time zone **aware** values is represented with a dtype of `datetime64[ns,
    tz]` where `tz` is the time zone
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: Both of these [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series")
    time zone information can be manipulated via the `.dt` accessor, see [the dt accessor
    section](basics.html#basics-dt-accessors).
  prefs: []
  type: TYPE_NORMAL
- en: For example, to localize and convert a naive stamp to time zone aware.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: Time zone information can also be manipulated using the `astype` method. This
    method can convert between different timezone-aware dtypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Using [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") on a `Series`, returns a NumPy array of the data. NumPy
    does not currently support time zones (even though it is *printing* in the local
    time zone!), therefore an object array of Timestamps is returned for time zone
    aware data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: 'By converting to an object array of Timestamps, it preserves the time zone
    information. For example, when converting back to a Series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you want an actual NumPy `datetime64[ns]` array (with the values
    converted to UTC) instead of an array of objects, you can specify the `dtype`
    argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
