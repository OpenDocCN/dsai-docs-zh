- en: Integrals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/integrals/integrals.html](https://docs.sympy.org/latest/modules/integrals/integrals.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `integrals` module in SymPy implements methods to calculate definite and
    indefinite integrals of expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Principal method in this module is [`integrate()`](#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate")
  prefs: []
  type: TYPE_NORMAL
- en: '`integrate(f, x)` returns the indefinite integral \(\int f\,dx\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`integrate(f, (x, a, b))` returns the definite integral \(\int_{a}^{b} f\,dx\)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SymPy can integrate a vast array of functions. It can integrate polynomial
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Rational functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Exponential-polynomial functions. These multiplicative combinations of polynomials
    and the functions `exp`, `cos` and `sin` can be integrated by hand using repeated
    integration by parts, which is an extremely tedious process. Happily, SymPy will
    deal with these integrals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'even a few nonelementary integrals (in particular, some integrals involving
    the error function) can be evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '## Integral Transforms'
  prefs: []
  type: TYPE_NORMAL
- en: SymPy has special support for definite integrals, and integral transforms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Compute the Mellin transform \(F(s)\) of \(f(x)\),
  prefs: []
  type: TYPE_NORMAL
- en: \[F(s) = \int_0^\infty x^{s-1} f(x) \mathrm{d}x.\]
  prefs: []
  type: TYPE_NORMAL
- en: For all “sensible” functions, this converges absolutely in a strip
  prefs: []
  type: TYPE_NORMAL
- en: \(a < \operatorname{Re}(s) < b\).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The Mellin transform is related via change of variables to the Fourier transform,
    and also to the (bilateral) Laplace transform.
  prefs: []
  type: TYPE_NORMAL
- en: This function returns `(F, (a, b), cond)` where `F` is the Mellin transform
    of `f`, `(a, b)` is the fundamental strip (as above), and `cond` are auxiliary
    convergence conditions.
  prefs: []
  type: TYPE_NORMAL
- en: If the integral cannot be computed in closed form, this function returns an
    unevaluated [`MellinTransform`](#sympy.integrals.transforms.MellinTransform "sympy.integrals.transforms.MellinTransform")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit"). If `noconds=False`, then
    only \(F\) will be returned (i.e. not `cond`, and also not the strip `(a, b)`).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inverse_mellin_transform`](#sympy.integrals.transforms.inverse_mellin_transform
    "sympy.integrals.transforms.inverse_mellin_transform"), [`laplace_transform`](#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform"), [`fourier_transform`](#sympy.integrals.transforms.fourier_transform
    "sympy.integrals.transforms.fourier_transform"), [`hankel_transform`](#sympy.integrals.transforms.hankel_transform
    "sympy.integrals.transforms.hankel_transform"), [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated Mellin transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute Mellin transforms, see the [`mellin_transform()`](#sympy.integrals.transforms.mellin_transform
    "sympy.integrals.transforms.mellin_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Compute the inverse Mellin transform of \(F(s)\) over the fundamental strip
    given by `strip=(a, b)`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This can be defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[f(x) = \frac{1}{2\pi i} \int_{c - i\infty}^{c + i\infty} x^{-s} F(s) \mathrm{d}s,\]
  prefs: []
  type: TYPE_NORMAL
- en: for any \(c\) in the fundamental strip. Under certain regularity conditions
    on \(F\) and/or \(f\), this recovers \(f\) from its Mellin transform \(F\) (and
    vice versa), for positive real \(x\).
  prefs: []
  type: TYPE_NORMAL
- en: One of \(a\) or \(b\) may be passed as `None`; a suitable \(c\) will be inferred.
  prefs: []
  type: TYPE_NORMAL
- en: If the integral cannot be computed in closed form, this function returns an
    unevaluated [`InverseMellinTransform`](#sympy.integrals.transforms.InverseMellinTransform
    "sympy.integrals.transforms.InverseMellinTransform") object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this function will assume x to be positive and real, regardless of
    the SymPy assumptions!
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The fundamental strip matters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`mellin_transform`](#sympy.integrals.transforms.mellin_transform "sympy.integrals.transforms.mellin_transform"),
    [`hankel_transform`](#sympy.integrals.transforms.hankel_transform "sympy.integrals.transforms.hankel_transform"),
    [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated inverse Mellin transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute inverse Mellin transforms, see the [`inverse_mellin_transform()`](#sympy.integrals.transforms.inverse_mellin_transform
    "sympy.integrals.transforms.inverse_mellin_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Compute the Laplace Transform \(F(s)\) of \(f(t)\),
  prefs: []
  type: TYPE_NORMAL
- en: \[F(s) = \int_{0^{-}}^\infty e^{-st} f(t) \mathrm{d}t.\]
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: For all sensible functions, this converges absolutely in a half-plane
  prefs: []
  type: TYPE_NORMAL
- en: \[a < \operatorname{Re}(s)\]
  prefs: []
  type: TYPE_NORMAL
- en: This function returns `(F, a, cond)` where `F` is the Laplace transform of `f`,
    \(a\) is the half-plane of convergence, and \(cond\) are auxiliary convergence
    conditions.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is rule-based, and if you are interested in which rules are
    applied, and whether integration is attempted, you can switch debug information
    on by setting `sympy.SYMPY_DEBUG=True`. The numbers of the rules in the debug
    information (and the code) refer to Bateman’s Tables of Integral Transforms [1].
  prefs: []
  type: TYPE_NORMAL
- en: The lower bound is \(0-\), meaning that this bound should be approached from
    the lower side. This is only necessary if distributions are involved. At present,
    it is only done if \(f(t)\) contains `DiracDelta`, in which case the Laplace transform
    is computed implicitly as
  prefs: []
  type: TYPE_NORMAL
- en: \[F(s) = \lim_{\tau\to 0^{-}} \int_{\tau}^\infty e^{-st} f(t) \mathrm{d}t\]
  prefs: []
  type: TYPE_NORMAL
- en: by applying rules.
  prefs: []
  type: TYPE_NORMAL
- en: If the Laplace transform cannot be fully computed in closed form, this function
    returns expressions containing unevaluated [`LaplaceTransform`](#sympy.integrals.transforms.LaplaceTransform
    "sympy.integrals.transforms.LaplaceTransform") objects.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit"). If `noconds=True`, only
    \(F\) will be returned (i.e. not `cond`, and also not the plane `a`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.9: Legacy behavior for matrices where `laplace_transform`
    with `noconds=False` (the default) returns a Matrix whose elements are tuples.
    The behavior of `laplace_transform` for matrices will change in a future release
    of SymPy to return a tuple of the transformed Matrix and the convergence conditions
    for the matrix as a whole. Use `legacy_matrix=False` to enable the new behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: There are also helper functions that make it easy to solve differential equations
    by Laplace transform. For example, to solve
  prefs: []
  type: TYPE_NORMAL
- en: \[m x''(t) + d x'(t) + k x(t) = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: 'with initial value \(0\) and initial derivative \(v\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inverse_laplace_transform`](#sympy.integrals.transforms.inverse_laplace_transform
    "sympy.integrals.transforms.inverse_laplace_transform"), [`mellin_transform`](#sympy.integrals.transforms.mellin_transform
    "sympy.integrals.transforms.mellin_transform"), [`fourier_transform`](#sympy.integrals.transforms.fourier_transform
    "sympy.integrals.transforms.fourier_transform"), [`hankel_transform`](#sympy.integrals.transforms.hankel_transform
    "sympy.integrals.transforms.hankel_transform"), [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R567](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Erdelyi, A. (ed.), Tables of Integral Transforms, Volume 1, Bateman Manuscript
    Prooject, McGraw-Hill (1954), available: [https://resolver.caltech.edu/CaltechAUTHORS:20140123-101456353](https://resolver.caltech.edu/CaltechAUTHORS:20140123-101456353)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This helper function takes a function \(f\) that is the result of a `laplace_transform`
    or an `inverse_laplace_transform`. It replaces all unevaluated `LaplaceTransform(y(t),
    t, s)` by \(Y(s)\) for any \(s\) and all `InverseLaplaceTransform(Y(s), s, t)`
    by \(y(t)\) for any \(t\) if `fdict` contains a correspondence `{y: Y}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f** : sympy expression'
  prefs: []
  type: TYPE_NORMAL
- en: Expression containing unevaluated `LaplaceTransform` or `LaplaceTransform` objects.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**fdict** : dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionary containing one or more function correspondences, e.g., `{x: X, y:
    Y}` meaning that `X` and `Y` are the Laplace transforms of `x` and `y`, respectively.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This helper function takes a function \(f\) that is the result of a `laplace_transform`.
    It takes an fdict of the form `{y: [1, 4, 2]}`, where the values in the list are
    the initial value, the initial slope, the initial second derivative, etc., of
    the function \(y(t)\), and replaces all unevaluated initial conditions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f** : sympy expression'
  prefs: []
  type: TYPE_NORMAL
- en: Expression containing initial conditions of unevaluated functions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**t** : sympy expression'
  prefs: []
  type: TYPE_NORMAL
- en: Variable for which the initial conditions are to be applied.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**fdict** : dictionary'
  prefs: []
  type: TYPE_NORMAL
- en: 'Dictionary containing a list of initial conditions for every function, e.g.,
    `{y: [0, 1, 2], x: [3, 4, 5]}`. The order of derivatives is ascending, so \(0\),
    \(1\), \(2\) are \(y(0)\), \(y''(0)\), and \(y''''(0)\), respectively.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated Laplace transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute Laplace transforms, see the [`laplace_transform()`](#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: If this is called with `.doit()`, it returns the Laplace transform as an expression.
    If it is called with `.doit(noconds=False)`, it returns a tuple containing the
    same expression, a convergence plane, and conditions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Try to evaluate the transform in closed form.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard hints are the following: - `noconds`: if True, do not return convergence
    conditions. The default setting is \(True\). - `simplify`: if True, it simplifies
    the final result. The default setting is \(False\).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Compute the inverse Laplace transform of \(F(s)\), defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[f(t) = \frac{1}{2\pi i} \int_{c-i\infty}^{c+i\infty} e^{st} F(s) \mathrm{d}s,\]
  prefs: []
  type: TYPE_NORMAL
- en: for \(c\) so large that \(F(s)\) has no singularites in the half-plane \(\operatorname{Re}(s)
    > c-\epsilon\).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The plane can be specified by argument `plane`, but will be inferred if passed
    as None.
  prefs: []
  type: TYPE_NORMAL
- en: Under certain regularity conditions, this recovers \(f(t)\) from its Laplace
    Transform \(F(s)\), for non-negative \(t\), and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: If the integral cannot be computed in closed form, this function returns an
    unevaluated [`InverseLaplaceTransform`](#sympy.integrals.transforms.InverseLaplaceTransform
    "sympy.integrals.transforms.InverseLaplaceTransform") object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this function will always assume \(t\) to be real, regardless of the
    SymPy assumption on \(t\).
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`laplace_transform`](#sympy.integrals.transforms.laplace_transform "sympy.integrals.transforms.laplace_transform"),
    [`hankel_transform`](#sympy.integrals.transforms.hankel_transform "sympy.integrals.transforms.hankel_transform"),
    [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated inverse Laplace transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute inverse Laplace transforms, see the [`inverse_laplace_transform()`](#sympy.integrals.transforms.inverse_laplace_transform
    "sympy.integrals.transforms.inverse_laplace_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Try to evaluate the transform in closed form.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard hints are the following: - `noconds`: if True, do not return convergence
    conditions. The default setting is \(True\). - `simplify`: if True, it simplifies
    the final result. The default setting is \(False\).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Compute the unitary, ordinary-frequency Fourier transform of `f`, defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[F(k) = \int_{-\infty}^\infty f(x) e^{-2\pi i x k} \mathrm{d} x.\]
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If the transform cannot be computed in closed form, this function returns an
    unevaluated [`FourierTransform`](#sympy.integrals.transforms.FourierTransform
    "sympy.integrals.transforms.FourierTransform") object.
  prefs: []
  type: TYPE_NORMAL
- en: For other Fourier transform conventions, see the function [`sympy.integrals.transforms._fourier_transform()`](#sympy.integrals.transforms._fourier_transform
    "sympy.integrals.transforms._fourier_transform").
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit"). Note that for this transform,
    by default `noconds=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`inverse_fourier_transform`](#sympy.integrals.transforms.inverse_fourier_transform
    "sympy.integrals.transforms.inverse_fourier_transform"), [`sine_transform`](#sympy.integrals.transforms.sine_transform
    "sympy.integrals.transforms.sine_transform"), [`inverse_sine_transform`](#sympy.integrals.transforms.inverse_sine_transform
    "sympy.integrals.transforms.inverse_sine_transform"), [`cosine_transform`](#sympy.integrals.transforms.cosine_transform
    "sympy.integrals.transforms.cosine_transform"), [`inverse_cosine_transform`](#sympy.integrals.transforms.inverse_cosine_transform
    "sympy.integrals.transforms.inverse_cosine_transform"), [`hankel_transform`](#sympy.integrals.transforms.hankel_transform
    "sympy.integrals.transforms.hankel_transform"), [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform"), [`mellin_transform`](#sympy.integrals.transforms.mellin_transform
    "sympy.integrals.transforms.mellin_transform"), [`laplace_transform`](#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Compute a general Fourier-type transform
  prefs: []
  type: TYPE_NORMAL
- en: \[F(k) = a \int_{-\infty}^{\infty} e^{bixk} f(x)\, dx.\]
  prefs: []
  type: TYPE_NORMAL
- en: For suitable choice of *a* and *b*, this reduces to the standard Fourier and
    inverse Fourier transforms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated Fourier transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute Fourier transforms, see the [`fourier_transform()`](#sympy.integrals.transforms.fourier_transform
    "sympy.integrals.transforms.fourier_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Compute the unitary, ordinary-frequency inverse Fourier transform of \(F\),
    defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[f(x) = \int_{-\infty}^\infty F(k) e^{2\pi i x k} \mathrm{d} k.\]
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If the transform cannot be computed in closed form, this function returns an
    unevaluated [`InverseFourierTransform`](#sympy.integrals.transforms.InverseFourierTransform
    "sympy.integrals.transforms.InverseFourierTransform") object.
  prefs: []
  type: TYPE_NORMAL
- en: For other Fourier transform conventions, see the function [`sympy.integrals.transforms._fourier_transform()`](#sympy.integrals.transforms._fourier_transform
    "sympy.integrals.transforms._fourier_transform").
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit"). Note that for this transform,
    by default `noconds=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`fourier_transform`](#sympy.integrals.transforms.fourier_transform "sympy.integrals.transforms.fourier_transform"),
    [`sine_transform`](#sympy.integrals.transforms.sine_transform "sympy.integrals.transforms.sine_transform"),
    [`inverse_sine_transform`](#sympy.integrals.transforms.inverse_sine_transform
    "sympy.integrals.transforms.inverse_sine_transform"), [`cosine_transform`](#sympy.integrals.transforms.cosine_transform
    "sympy.integrals.transforms.cosine_transform"), [`inverse_cosine_transform`](#sympy.integrals.transforms.inverse_cosine_transform
    "sympy.integrals.transforms.inverse_cosine_transform"), [`hankel_transform`](#sympy.integrals.transforms.hankel_transform
    "sympy.integrals.transforms.hankel_transform"), [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform"), [`mellin_transform`](#sympy.integrals.transforms.mellin_transform
    "sympy.integrals.transforms.mellin_transform"), [`laplace_transform`](#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated inverse Fourier transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute inverse Fourier transforms, see the [`inverse_fourier_transform()`](#sympy.integrals.transforms.inverse_fourier_transform
    "sympy.integrals.transforms.inverse_fourier_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Compute the unitary, ordinary-frequency sine transform of \(f\), defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[F(k) = \sqrt{\frac{2}{\pi}} \int_{0}^\infty f(x) \sin(2\pi x k) \mathrm{d}
    x.\]
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If the transform cannot be computed in closed form, this function returns an
    unevaluated [`SineTransform`](#sympy.integrals.transforms.SineTransform "sympy.integrals.transforms.SineTransform")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit"). Note that for this transform,
    by default `noconds=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`fourier_transform`](#sympy.integrals.transforms.fourier_transform "sympy.integrals.transforms.fourier_transform"),
    [`inverse_fourier_transform`](#sympy.integrals.transforms.inverse_fourier_transform
    "sympy.integrals.transforms.inverse_fourier_transform"), [`inverse_sine_transform`](#sympy.integrals.transforms.inverse_sine_transform
    "sympy.integrals.transforms.inverse_sine_transform"), [`cosine_transform`](#sympy.integrals.transforms.cosine_transform
    "sympy.integrals.transforms.cosine_transform"), [`inverse_cosine_transform`](#sympy.integrals.transforms.inverse_cosine_transform
    "sympy.integrals.transforms.inverse_cosine_transform"), [`hankel_transform`](#sympy.integrals.transforms.hankel_transform
    "sympy.integrals.transforms.hankel_transform"), [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform"), [`mellin_transform`](#sympy.integrals.transforms.mellin_transform
    "sympy.integrals.transforms.mellin_transform"), [`laplace_transform`](#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated sine transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute sine transforms, see the [`sine_transform()`](#sympy.integrals.transforms.sine_transform
    "sympy.integrals.transforms.sine_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Compute the unitary, ordinary-frequency inverse sine transform of \(F\), defined
    as
  prefs: []
  type: TYPE_NORMAL
- en: \[f(x) = \sqrt{\frac{2}{\pi}} \int_{0}^\infty F(k) \sin(2\pi x k) \mathrm{d}
    k.\]
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If the transform cannot be computed in closed form, this function returns an
    unevaluated [`InverseSineTransform`](#sympy.integrals.transforms.InverseSineTransform
    "sympy.integrals.transforms.InverseSineTransform") object.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit"). Note that for this transform,
    by default `noconds=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`fourier_transform`](#sympy.integrals.transforms.fourier_transform "sympy.integrals.transforms.fourier_transform"),
    [`inverse_fourier_transform`](#sympy.integrals.transforms.inverse_fourier_transform
    "sympy.integrals.transforms.inverse_fourier_transform"), [`sine_transform`](#sympy.integrals.transforms.sine_transform
    "sympy.integrals.transforms.sine_transform"), [`cosine_transform`](#sympy.integrals.transforms.cosine_transform
    "sympy.integrals.transforms.cosine_transform"), [`inverse_cosine_transform`](#sympy.integrals.transforms.inverse_cosine_transform
    "sympy.integrals.transforms.inverse_cosine_transform"), [`hankel_transform`](#sympy.integrals.transforms.hankel_transform
    "sympy.integrals.transforms.hankel_transform"), [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform"), [`mellin_transform`](#sympy.integrals.transforms.mellin_transform
    "sympy.integrals.transforms.mellin_transform"), [`laplace_transform`](#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated inverse sine transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute inverse sine transforms, see the [`inverse_sine_transform()`](#sympy.integrals.transforms.inverse_sine_transform
    "sympy.integrals.transforms.inverse_sine_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Compute the unitary, ordinary-frequency cosine transform of \(f\), defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[F(k) = \sqrt{\frac{2}{\pi}} \int_{0}^\infty f(x) \cos(2\pi x k) \mathrm{d}
    x.\]
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If the transform cannot be computed in closed form, this function returns an
    unevaluated [`CosineTransform`](#sympy.integrals.transforms.CosineTransform "sympy.integrals.transforms.CosineTransform")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit"). Note that for this transform,
    by default `noconds=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`fourier_transform`](#sympy.integrals.transforms.fourier_transform "sympy.integrals.transforms.fourier_transform"),
    [`inverse_fourier_transform`](#sympy.integrals.transforms.inverse_fourier_transform
    "sympy.integrals.transforms.inverse_fourier_transform"), [`sine_transform`](#sympy.integrals.transforms.sine_transform
    "sympy.integrals.transforms.sine_transform"), [`inverse_sine_transform`](#sympy.integrals.transforms.inverse_sine_transform
    "sympy.integrals.transforms.inverse_sine_transform"), [`inverse_cosine_transform`](#sympy.integrals.transforms.inverse_cosine_transform
    "sympy.integrals.transforms.inverse_cosine_transform"), [`hankel_transform`](#sympy.integrals.transforms.hankel_transform
    "sympy.integrals.transforms.hankel_transform"), [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform"), [`mellin_transform`](#sympy.integrals.transforms.mellin_transform
    "sympy.integrals.transforms.mellin_transform"), [`laplace_transform`](#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated cosine transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute cosine transforms, see the [`cosine_transform()`](#sympy.integrals.transforms.cosine_transform
    "sympy.integrals.transforms.cosine_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Compute the unitary, ordinary-frequency inverse cosine transform of \(F\), defined
    as
  prefs: []
  type: TYPE_NORMAL
- en: \[f(x) = \sqrt{\frac{2}{\pi}} \int_{0}^\infty F(k) \cos(2\pi x k) \mathrm{d}
    k.\]
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If the transform cannot be computed in closed form, this function returns an
    unevaluated [`InverseCosineTransform`](#sympy.integrals.transforms.InverseCosineTransform
    "sympy.integrals.transforms.InverseCosineTransform") object.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit"). Note that for this transform,
    by default `noconds=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`fourier_transform`](#sympy.integrals.transforms.fourier_transform "sympy.integrals.transforms.fourier_transform"),
    [`inverse_fourier_transform`](#sympy.integrals.transforms.inverse_fourier_transform
    "sympy.integrals.transforms.inverse_fourier_transform"), [`sine_transform`](#sympy.integrals.transforms.sine_transform
    "sympy.integrals.transforms.sine_transform"), [`inverse_sine_transform`](#sympy.integrals.transforms.inverse_sine_transform
    "sympy.integrals.transforms.inverse_sine_transform"), [`cosine_transform`](#sympy.integrals.transforms.cosine_transform
    "sympy.integrals.transforms.cosine_transform"), [`hankel_transform`](#sympy.integrals.transforms.hankel_transform
    "sympy.integrals.transforms.hankel_transform"), [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform"), [`mellin_transform`](#sympy.integrals.transforms.mellin_transform
    "sympy.integrals.transforms.mellin_transform"), [`laplace_transform`](#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated inverse cosine transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute inverse cosine transforms, see the [`inverse_cosine_transform()`](#sympy.integrals.transforms.inverse_cosine_transform
    "sympy.integrals.transforms.inverse_cosine_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Compute the Hankel transform of \(f\), defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[F_\nu(k) = \int_{0}^\infty f(r) J_\nu(k r) r \mathrm{d} r.\]
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If the transform cannot be computed in closed form, this function returns an
    unevaluated [`HankelTransform`](#sympy.integrals.transforms.HankelTransform "sympy.integrals.transforms.HankelTransform")
    object.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit"). Note that for this transform,
    by default `noconds=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`fourier_transform`](#sympy.integrals.transforms.fourier_transform "sympy.integrals.transforms.fourier_transform"),
    [`inverse_fourier_transform`](#sympy.integrals.transforms.inverse_fourier_transform
    "sympy.integrals.transforms.inverse_fourier_transform"), [`sine_transform`](#sympy.integrals.transforms.sine_transform
    "sympy.integrals.transforms.sine_transform"), [`inverse_sine_transform`](#sympy.integrals.transforms.inverse_sine_transform
    "sympy.integrals.transforms.inverse_sine_transform"), [`cosine_transform`](#sympy.integrals.transforms.cosine_transform
    "sympy.integrals.transforms.cosine_transform"), [`inverse_cosine_transform`](#sympy.integrals.transforms.inverse_cosine_transform
    "sympy.integrals.transforms.inverse_cosine_transform"), [`inverse_hankel_transform`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform"), [`mellin_transform`](#sympy.integrals.transforms.mellin_transform
    "sympy.integrals.transforms.mellin_transform"), [`laplace_transform`](#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated Hankel transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute Hankel transforms, see the [`hankel_transform()`](#sympy.integrals.transforms.hankel_transform
    "sympy.integrals.transforms.hankel_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Compute the inverse Hankel transform of \(F\) defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[f(r) = \int_{0}^\infty F_\nu(k) J_\nu(k r) k \mathrm{d} k.\]
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If the transform cannot be computed in closed form, this function returns an
    unevaluated [`InverseHankelTransform`](#sympy.integrals.transforms.InverseHankelTransform
    "sympy.integrals.transforms.InverseHankelTransform") object.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of possible hints, refer to the docstring of [`sympy.integrals.transforms.IntegralTransform.doit()`](#sympy.integrals.transforms.IntegralTransform.doit
    "sympy.integrals.transforms.IntegralTransform.doit"). Note that for this transform,
    by default `noconds=True`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`fourier_transform`](#sympy.integrals.transforms.fourier_transform "sympy.integrals.transforms.fourier_transform"),
    [`inverse_fourier_transform`](#sympy.integrals.transforms.inverse_fourier_transform
    "sympy.integrals.transforms.inverse_fourier_transform"), [`sine_transform`](#sympy.integrals.transforms.sine_transform
    "sympy.integrals.transforms.sine_transform"), [`inverse_sine_transform`](#sympy.integrals.transforms.inverse_sine_transform
    "sympy.integrals.transforms.inverse_sine_transform"), [`cosine_transform`](#sympy.integrals.transforms.cosine_transform
    "sympy.integrals.transforms.cosine_transform"), [`inverse_cosine_transform`](#sympy.integrals.transforms.inverse_cosine_transform
    "sympy.integrals.transforms.inverse_cosine_transform"), [`hankel_transform`](#sympy.integrals.transforms.hankel_transform
    "sympy.integrals.transforms.hankel_transform"), [`mellin_transform`](#sympy.integrals.transforms.mellin_transform
    "sympy.integrals.transforms.mellin_transform"), [`laplace_transform`](#sympy.integrals.transforms.laplace_transform
    "sympy.integrals.transforms.laplace_transform")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Class representing unevaluated inverse Hankel transforms.
  prefs: []
  type: TYPE_NORMAL
- en: For usage of this class, see the [`IntegralTransform`](#sympy.integrals.transforms.IntegralTransform
    "sympy.integrals.transforms.IntegralTransform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: For how to compute inverse Hankel transforms, see the [`inverse_hankel_transform()`](#sympy.integrals.transforms.inverse_hankel_transform
    "sympy.integrals.transforms.inverse_hankel_transform") docstring.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Base class for integral transforms.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This class represents unevaluated transforms.
  prefs: []
  type: TYPE_NORMAL
- en: To implement a concrete transform, derive from this class and implement the
    `_compute_transform(f, x, s, **hints)` and `_as_integral(f, x, s)` functions.
    If the transform cannot be computed, raise [`IntegralTransformError`](#sympy.integrals.transforms.IntegralTransformError
    "sympy.integrals.transforms.IntegralTransformError").
  prefs: []
  type: TYPE_NORMAL
- en: Also set `cls._name`. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Implement `self._collapse_extra` if your function returns more than just a number
    and possibly a convergence condition.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Try to evaluate the transform in closed form.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This general function handles linearity, but apart from that leaves pretty much
    everything to _compute_transform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard hints are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`simplify`: whether or not to simplify the result'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`noconds`: if True, do not return convergence conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`needeval`: if True, raise IntegralTransformError instead of'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: returning IntegralTransform objects
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The default values of these hints depend on the concrete transform, usually
    the default is `(simplify, noconds, needeval) = (True, False, False)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The function to be transformed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The dependent variable of the function to be transformed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The independent transform variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Exception raised in relation to problems computing transforms.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This class is mostly used internally; if integrals cannot be computed objects
    representing unevaluated transforms are usually returned.
  prefs: []
  type: TYPE_NORMAL
- en: The hint `needeval=True` can be used to disable returning transform objects,
    and instead raise this exception if an integral cannot be computed.
  prefs: []
  type: TYPE_NORMAL
- en: Internals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy uses a number of algorithms to compute integrals. Algorithms are tried
    in order until one produces an answer. Most of these algorithms can be enabled
    or disabled manually using various flags to [`integrate()`](#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate") or [`doit()`](#sympy.integrals.integrals.Integral.doit
    "sympy.integrals.integrals.Integral.doit").
  prefs: []
  type: TYPE_NORMAL
- en: 'SymPy first applies several heuristic algorithms, as these are the fastest:'
  prefs: []
  type: TYPE_NORMAL
- en: If the function is a rational function, there is a complete algorithm for integrating
    rational functions called the Lazard-Rioboo-Trager and the Horowitz-Ostrogradsky
    algorithms. They are implemented in [`ratint()`](#sympy.integrals.rationaltools.ratint
    "sympy.integrals.rationaltools.ratint").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Performs indefinite integration of rational functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a field \(K\) and a rational function \(f = p/q\), where \(p\) and \(q\)
    are polynomials in \(K[x]\), returns a function \(g\) such that \(f = g'\).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`sympy.integrals.integrals.Integral.doit`](#sympy.integrals.integrals.Integral.doit
    "sympy.integrals.integrals.Integral.doit"), [`sympy.integrals.rationaltools.ratint_logpart`](#sympy.integrals.rationaltools.ratint_logpart
    "sympy.integrals.rationaltools.ratint_logpart"), [`sympy.integrals.rationaltools.ratint_ratpart`](#sympy.integrals.rationaltools.ratint_ratpart
    "sympy.integrals.rationaltools.ratint_ratpart")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[[R568](#id2)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'M. Bronstein, Symbolic Integration I: Transcendental Functions, Second Edition,
    Springer-Verlag, 2005, pp. 35-70'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Horowitz-Ostrogradsky algorithm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Given a field K and polynomials f and g in K[x], such that f and g are coprime
    and deg(f) < deg(g), returns fractions A and B in K(x), such that f/g = A’ + B
    and B has square-free denominator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ratint`](#sympy.integrals.rationaltools.ratint "sympy.integrals.rationaltools.ratint"),
    [`ratint_logpart`](#sympy.integrals.rationaltools.ratint_logpart "sympy.integrals.rationaltools.ratint_logpart")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lazard-Rioboo-Trager algorithm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Given a field K and polynomials f and g in K[x], such that f and g are coprime,
    deg(f) < deg(g) and g is square-free, returns a list of tuples (s_i, q_i) of polynomials,
    for i = 1..n, such that s_i in K[t, x] and q_i in K[t], and:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ratint`](#sympy.integrals.rationaltools.ratint "sympy.integrals.rationaltools.ratint"),
    [`ratint_ratpart`](#sympy.integrals.rationaltools.ratint_ratpart "sympy.integrals.rationaltools.ratint_ratpart")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`trigintegrate()`](#sympy.integrals.trigonometry.trigintegrate "sympy.integrals.trigonometry.trigintegrate")
    solves integrals of trigonometric functions using pattern matching'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Integrate f = Mul(trig) over x.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`sympy.integrals.integrals.Integral.doit`](#sympy.integrals.integrals.Integral.doit
    "sympy.integrals.integrals.Integral.doit"), [`sympy.integrals.integrals.Integral`](#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[[R569](#id3)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://en.wikibooks.org/wiki/Calculus/Integration_techniques](https://en.wikibooks.org/wiki/Calculus/Integration_techniques)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`deltaintegrate()`](#sympy.integrals.deltafunctions.deltaintegrate "sympy.integrals.deltafunctions.deltaintegrate")
    solves integrals with [`DiracDelta`](../functions/special.html#sympy.functions.special.delta_functions.DiracDelta
    "sympy.functions.special.delta_functions.DiracDelta") objects.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The idea for integration is the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we are dealing with a DiracDelta expression, i.e. DiracDelta(g(x)), we try
    to simplify it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we could simplify it, then we integrate the resulting expression. We already
    know we can integrate a simplified expression, because only simple DiracDelta
    expressions are involved.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we couldn’t simplify it, there are two cases:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The expression is a simple expression: we return the integral, taking care
    if we are dealing with a Derivative or with a proper DiracDelta.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The expression is not simple (i.e. DiracDelta(cos(x))): we can do nothing at
    all.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the node is a multiplication node having a DiracDelta term:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: First we expand it.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: If the expansion did work, then we try to integrate the expansion.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If not, we try to extract a simple DiracDelta term, then we have two cases:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: We have a simple DiracDelta term, so we return the integral.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: We didn’t have a simple term, but we do have an expression with simplified DiracDelta
    terms, so we integrate this expression.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`sympy.functions.special.delta_functions.DiracDelta`](../functions/special.html#sympy.functions.special.delta_functions.DiracDelta
    "sympy.functions.special.delta_functions.DiracDelta"), [`sympy.integrals.integrals.Integral`](#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`singularityintegrate()`](#sympy.integrals.singularityfunctions.singularityintegrate
    "sympy.integrals.singularityfunctions.singularityintegrate") is applied if the
    function contains a [`SingularityFunction`](../functions/special.html#sympy.functions.special.singularity_functions.SingularityFunction
    "sympy.functions.special.singularity_functions.SingularityFunction")'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function handles the indefinite integrations of Singularity functions.
    The `integrate` function calls this function internally whenever an instance of
    SingularityFunction is passed as argument.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The idea for integration is the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we are dealing with a SingularityFunction expression, i.e. `SingularityFunction(x,
    a, n)`, we just return `SingularityFunction(x, a, n + 1)/(n + 1)` if `n >= 0`
    and `SingularityFunction(x, a, n + 1)` if `n < 0`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the node is a multiplication or power node having a SingularityFunction term
    we rewrite the whole expression in terms of Heaviside and DiracDelta and then
    integrate the output. Lastly, we rewrite the output of integration back in terms
    of SingularityFunction.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If none of the above case arises, we return None.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the heuristic algorithms cannot be applied, [`risch_integrate()`](#sympy.integrals.risch.risch_integrate
    "sympy.integrals.risch.risch_integrate") is tried next. The *Risch algorithm*
    is a general method for calculating antiderivatives of elementary functions. The
    Risch algorithm is a decision procedure that can determine whether an elementary
    solution exists, and in that case calculate it. It can be extended to handle many
    nonelementary functions in addition to the elementary ones. However, the version
    implemented in SymPy only supports a small subset of the full algorithm, particularly,
    on part of the transcendental algorithm for exponentials and logarithms is implemented.
    An advantage of [`risch_integrate()`](#sympy.integrals.risch.risch_integrate "sympy.integrals.risch.risch_integrate")
    over other methods is that if it returns an instance of [`NonElementaryIntegral`](#sympy.integrals.risch.NonElementaryIntegral
    "sympy.integrals.risch.NonElementaryIntegral"), the integral is proven to be nonelementary
    by the algorithm, meaning the integral cannot be represented using a combination
    of exponentials, logarithms, trig functions, powers, rational functions, algebraic
    functions, and function composition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Risch Integration Algorithm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Only transcendental functions are supported. Currently, only exponentials and
    logarithms are supported, but support for trigonometric functions is forthcoming.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If this function returns an unevaluated Integral in the result, it means that
    it has proven that integral to be nonelementary. Any errors will result in raising
    NotImplementedError. The unevaluated Integral will be an instance of NonElementaryIntegral,
    a subclass of Integral.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: handle_first may be either ‘exp’ or ‘log’. This changes the order in which the
    extension is built, and may result in a different (but equivalent) solution (for
    an example of this, see issue 5109). It is also possible that the integral may
    be computed with one but not the other, because not all cases have been implemented
    yet. It defaults to ‘log’ so that the outer extension is exponential when possible,
    because more of the exponential case has been implemented.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If `separate_integral` is `True`, the result is returned as a tuple (ans, i),
    where the integral is ans + i, ans is elementary, and i is either a NonElementaryIntegral
    or 0\. This useful if you want to try further integrating the NonElementaryIntegral
    part using other algorithms to possibly get a solution in terms of special functions.
    It is False by default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we try integrating exp(-x**2). Except for a constant factor of 2/sqrt(pi),
    this is the famous error function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The unevaluated Integral in the result means that risch_integrate() has proven
    that exp(-x**2) does not have an elementary anti-derivative.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In many cases, risch_integrate() can split out the elementary anti-derivative
    part from the nonelementary anti-derivative part. For example,
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This means that it has proven that the integral of 1/log(x) is nonelementary.
    This function is also known as the logarithmic integral, and is often denoted
    as Li(x).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: risch_integrate() currently only accepts purely transcendental functions with
    exponentials and logarithms, though note that this can include nested exponentials
    and logarithms, as well as exponentials with bases other than E.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Represents a nonelementary Integral.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the result of integrate() is an instance of this class, it is guaranteed
    to be nonelementary. Note that integrate() by default will try to find any closed-form
    solution, even in terms of special functions which may themselves not be elementary.
    To make integrate() only give elementary solutions, or, in the cases where it
    can prove the integral to be nonelementary, instances of this class, use integrate(risch=True).
    In this case, integrate() may raise NotImplementedError if it cannot make such
    a determination.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: integrate() uses the deterministic Risch algorithm to integrate elementary functions
    or prove that they have no elementary integral. In some cases, this algorithm
    can split an integral into an elementary and nonelementary part, so that the result
    of integrate will be the sum of an elementary expression and a NonElementaryIntegral.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For non-elementary definite integrals, SymPy uses so-called Meijer G-functions.
    Details are described in [Computing Integrals using Meijer G-Functions](g-functions.html#g-functions).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All the algorithms mentioned thus far are either pattern-matching based heuristic,
    or solve integrals using algorithms that are much different from the way most
    people are taught in their calculus courses. SymPy also implements a method that
    can solve integrals in much the same way you would in calculus. The advantage
    of this method is that it is possible to extract the integration steps from, so
    that one can see how to compute the integral “by hand”. This is used by [SymPy
    Gamma](https://sympygamma.com). This is implemented in the [`manualintegrate()`](#sympy.integrals.manualintegrate.manualintegrate
    "sympy.integrals.manualintegrate.manualintegrate") function. The steps for an
    integral can be seen with the [`integral_steps()`](#sympy.integrals.manualintegrate.integral_steps
    "sympy.integrals.manualintegrate.integral_steps") function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Explanation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute indefinite integral of a single variable using an algorithm that resembles
    what a student would do by hand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Unlike [`integrate()`](#sympy.integrals.integrals.integrate "sympy.integrals.integrals.integrate"),
    var can only be a single symbol.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`sympy.integrals.integrals.integrate`](#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate"), [`sympy.integrals.integrals.Integral.doit`](#sympy.integrals.integrals.Integral.doit
    "sympy.integrals.integrals.Integral.doit"), [`sympy.integrals.integrals.Integral`](#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Returns the steps needed to compute an integral.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**rule** : Rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The first step; most rules have substeps that must also be considered. These
    substeps can be evaluated using `manualintegrate` to obtain a result.
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This function attempts to mirror what a student would do by hand as closely
    as possible.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SymPy Gamma uses this to provide a step-by-step explanation of an integral.
    The code it uses to format the results of this function can be found at [https://github.com/sympy/sympy_gamma/blob/master/app/logic/intsteps.py](https://github.com/sympy/sympy_gamma/blob/master/app/logic/intsteps.py).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, if all the above fail, SymPy also uses a simplified version of the
    Risch algorithm, called the *Risch-Norman algorithm*. This algorithm is tried
    last because it is often the slowest to compute. This is implemented in [`heurisch()`](#sympy.integrals.heurisch.heurisch
    "sympy.integrals.heurisch.heurisch"):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compute indefinite integral using heuristic Risch algorithm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Explanation
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is a heuristic approach to indefinite integration in finite terms using
    the extended heuristic (parallel) Risch algorithm, based on Manuel Bronstein’s
    “Poor Man’s Integrator”.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The algorithm supports various classes of functions including transcendental
    elementary or special functions like Airy, Bessel, Whittaker and Lambert.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that this algorithm is not a decision procedure. If it isn’t able to compute
    the antiderivative for a given function, then this is not a proof that such a
    functions does not exist. One should use recursive Risch algorithm in such case.
    It’s an open question if this algorithm can be made a full decision procedure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is an internal integrator procedure. You should use top level ‘integrate’
    function in most cases, as this procedure needs some preprocessing steps and otherwise
    may fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Specification
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: heurisch(f, x, rewrite=False, hints=None)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: where
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'f : expression x : symbol'
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: rewrite -> force rewrite ‘f’ in terms of ‘tan’ and ‘tanh’ hints -> a list of
    functions that may appear in anti-derivate
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  type: TYPE_NORMAL
- en: hints = None –> no suggestions at all
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: hints = [ ] –> try to figure out
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: hints = [f1, …, fn] –> we know better
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'See Manuel Bronstein’s “Poor Man’s Integrator”:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`sympy.integrals.integrals.Integral.doit`](#sympy.integrals.integrals.Integral.doit
    "sympy.integrals.integrals.Integral.doit"), [`sympy.integrals.integrals.Integral`](#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral"), [`sympy.integrals.heurisch.components`](#sympy.integrals.heurisch.components
    "sympy.integrals.heurisch.components")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[[R570](#id4)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html](https://www-sop.inria.fr/cafe/Manuel.Bronstein/pmint/index.html)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For more information on the implemented algorithm refer to:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[[R571](#id5)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: K. Geddes, L. Stefanus, On the Risch-Norman Integration Method and its Implementation
    in Maple, Proceedings of ISSAC’89, ACM Press, 212-217.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[[R572](#id6)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: J. H. Davenport, On the Parallel Risch Algorithm (I), Proceedings of EUROCAM’82,
    LNCS 144, Springer, 144-157.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[[R573](#id7)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'J. H. Davenport, On the Parallel Risch Algorithm (III): Use of Tangents, SIGSAM
    Bulletin 16 (1982), 3-6.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[[R574](#id8)]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: J. H. Davenport, B. M. Trager, On the Parallel Risch Algorithm (II), ACM Transactions
    on Mathematical Software 11 (1985), 356-362.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Returns a set of all functional components of the given expression which includes
    symbols, function applications and compositions and non-integer powers. Fractional
    powers are collected with minimal, positive exponents.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`heurisch`](#sympy.integrals.heurisch.heurisch "sympy.integrals.heurisch.heurisch")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: API reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Deprecated since version 1.6: Using `integrate()` with [`Poly`](../polys/reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") is deprecated. Use [`Poly.integrate()`](../polys/reference.html#sympy.polys.polytools.Poly.integrate
    "sympy.polys.polytools.Poly.integrate") instead. See [Using integrate with Poly](../../explanation/active-deprecations.html#deprecated-integrate-poly).'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Compute definite or indefinite integral of one or more variables using Risch-Norman
    algorithm and table lookup. This procedure is able to handle elementary algebraic
    and transcendental functions and also a huge class of special functions, including
    Airy, Bessel, Whittaker and Lambert.
  prefs: []
  type: TYPE_NORMAL
- en: 'var can be:'
  prefs: []
  type: TYPE_NORMAL
- en: a symbol – indefinite integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a tuple (symbol, a) – indefinite integration with result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: given with `a` replacing `symbol`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: a tuple (symbol, a, b) – definite integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several variables can be specified, in which case the result is multiple integration.
    (If var is omitted and the integrand is univariate, the indefinite integral in
    that variable will be performed.)
  prefs: []
  type: TYPE_NORMAL
- en: Indefinite integrals are returned without terms that are independent of the
    integration variables. (see examples)
  prefs: []
  type: TYPE_NORMAL
- en: Definite improper integrals often entail delicate convergence conditions. Pass
    conds=’piecewise’, ‘separate’ or ‘none’ to have these returned, respectively,
    as a Piecewise function, as a separate result (i.e. result will be a tuple), or
    not at all (default is ‘piecewise’).
  prefs: []
  type: TYPE_NORMAL
- en: '**Strategy**'
  prefs: []
  type: TYPE_NORMAL
- en: SymPy uses various approaches to definite integration. One method is to find
    an antiderivative for the integrand, and then use the fundamental theorem of calculus.
    Various functions are implemented to integrate polynomial, rational and trigonometric
    functions, and integrands containing DiracDelta terms.
  prefs: []
  type: TYPE_NORMAL
- en: SymPy also implements the part of the Risch algorithm, which is a decision procedure
    for integrating elementary functions, i.e., the algorithm can either find an elementary
    antiderivative, or prove that one does not exist. There is also a (very successful,
    albeit somewhat slow) general implementation of the heuristic Risch algorithm.
    This algorithm will eventually be phased out as more of the full Risch algorithm
    is implemented. See the docstring of Integral._eval_integral() for more details
    on computing the antiderivative using algebraic methods.
  prefs: []
  type: TYPE_NORMAL
- en: The option risch=True can be used to use only the (full) Risch algorithm. This
    is useful if you want to know if an elementary function has an elementary antiderivative.
    If the indefinite Integral returned by this function is an instance of NonElementaryIntegral,
    that means that the Risch algorithm has proven that integral to be non-elementary.
    Note that by default, additional methods (such as the Meijer G method outlined
    below) are tried on these integrals, as they may be expressible in terms of special
    functions, so if you only care about elementary answers, use risch=True. Also
    note that an unevaluated Integral returned by this function is not necessarily
    a NonElementaryIntegral, even with risch=True, as it may just be an indication
    that the particular part of the Risch algorithm needed to integrate that function
    is not yet implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Another family of strategies comes from re-writing the integrand in terms of
    so-called Meijer G-functions. Indefinite integrals of a single G-function can
    always be computed, and the definite integral of a product of two G-functions
    can be computed from zero to infinity. Various strategies are implemented to rewrite
    integrands as G-functions, and use this information to compute integrals (see
    the `meijerint` module).
  prefs: []
  type: TYPE_NORMAL
- en: The option manual=True can be used to use only an algorithm that tries to mimic
    integration by hand. This algorithm does not handle as many integrands as the
    other algorithms implemented but may return results in a more familiar form. The
    `manualintegrate` module has functions that return the steps used (see the module
    docstring for more information).
  prefs: []
  type: TYPE_NORMAL
- en: In general, the algebraic methods work best for computing antiderivatives of
    (possibly complicated) combinations of elementary functions. The G-function methods
    work best for computing definite integrals from zero to infinity of moderately
    complicated combinations of special functions, or indefinite integrals of very
    simple combinations of special functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The strategy employed by the integration code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If computing a definite integral, and both limits are real, and at least one
    limit is +- oo, try the G-function method of definite integration first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to find an antiderivative, using all available methods, ordered by performance
    (that is try fastest method first, slowest last; in particular polynomial integration
    is tried first, Meijer G-functions second to last, and heuristic Risch last).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If still not successful, try G-functions irrespective of the limits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The option meijerg=True, False, None can be used to, respectively: always use
    G-function methods and no others, never use G-function methods, or use all available
    methods (in order as described above). It defaults to None.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Terms that are independent of x are dropped by indefinite integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Note that `integrate(x)` syntax is meant only for convenience in interactive
    sessions and should be avoided in library code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Integral`](#sympy.integrals.integrals.Integral "sympy.integrals.integrals.Integral"),
    [`Integral.doit`](#sympy.integrals.integrals.Integral.doit "sympy.integrals.integrals.Integral.doit")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Compute the line integral.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.integrals.integrals.integrate`](#sympy.integrals.integrals.integrate
    "sympy.integrals.integrals.integrate"), [`Integral`](#sympy.integrals.integrals.Integral
    "sympy.integrals.integrals.Integral")'
  prefs: []
  type: TYPE_NORMAL
- en: The class [`Integral`](#sympy.integrals.integrals.Integral "sympy.integrals.integrals.Integral")
    represents an unevaluated integral and has some methods that help in the integration
    of an expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Represents unevaluated integral.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Returns whether all the free symbols in the integral are commutative.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Approximates a definite integral by a sum.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n :**'
  prefs: []
  type: TYPE_NORMAL
- en: The number of subintervals to use, optional.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**method :**'
  prefs: []
  type: TYPE_NORMAL
- en: 'One of: ‘left’, ‘right’, ‘midpoint’, ‘trapezoid’.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**evaluate** : bool'
  prefs: []
  type: TYPE_NORMAL
- en: If False, returns an unevaluated Sum expression. The default is True, evaluate
    the sum.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: These methods of approximate integration are described in [1].
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: For demonstration purposes, this interval will only be split into 2 regions,
    bounded by [3, 5] and [5, 7].
  prefs: []
  type: TYPE_NORMAL
- en: 'The left-hand rule uses function evaluations at the left of each interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The midpoint rule uses evaluations at the center of each interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'The right-hand rule uses function evaluations at the right of each interval:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The trapezoid rule uses function evaluations on both sides of the intervals.
    This is equivalent to taking the average of the left and right hand rule results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the discontinuity at x = 0 can be avoided by using the midpoint or right-hand
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The left- or trapezoid method will encounter the discontinuity and return infinity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The number of intervals can be symbolic. If omitted, a dummy symbol will be
    used for it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows that the midpoint rule is more accurate, as its error term decays
    as the square of n:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'A symbolic sum is returned with evaluate=False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Integral.doit`](#sympy.integrals.integrals.Integral.doit "sympy.integrals.integrals.Integral.doit")'
  prefs: []
  type: TYPE_NORMAL
- en: Perform the integration using any hints
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R575](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Riemann_sum#Riemann_summation_methods](https://en.wikipedia.org/wiki/Riemann_sum#Riemann_summation_methods)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Perform the integration using any hints given.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.integrals.trigonometry.trigintegrate`](#sympy.integrals.trigonometry.trigintegrate
    "sympy.integrals.trigonometry.trigintegrate"), [`sympy.integrals.heurisch.heurisch`](#sympy.integrals.heurisch.heurisch
    "sympy.integrals.heurisch.heurisch"), [`sympy.integrals.rationaltools.ratint`](#sympy.integrals.rationaltools.ratint
    "sympy.integrals.rationaltools.ratint")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_sum`](#sympy.integrals.integrals.Integral.as_sum "sympy.integrals.integrals.Integral.as_sum")'
  prefs: []
  type: TYPE_NORMAL
- en: Approximate the integral using a sum
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This method returns the symbols that will exist when the integral is evaluated.
    This is useful if one is trying to determine whether an integral depends on a
    certain symbol or not.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.concrete.expr_with_limits.ExprWithLimits.function`](#sympy.concrete.expr_with_limits.ExprWithLimits.function
    "sympy.concrete.expr_with_limits.ExprWithLimits.function"), [`sympy.concrete.expr_with_limits.ExprWithLimits.limits`](#sympy.concrete.expr_with_limits.ExprWithLimits.limits
    "sympy.concrete.expr_with_limits.ExprWithLimits.limits"), [`sympy.concrete.expr_with_limits.ExprWithLimits.variables`](#sympy.concrete.expr_with_limits.ExprWithLimits.variables
    "sympy.concrete.expr_with_limits.ExprWithLimits.variables")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Compute the Cauchy Principal Value of the definite integral of a real function
    in the given interval on the real axis.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: In mathematics, the Cauchy principal value, is a method for assigning values
    to certain improper integrals which would otherwise be undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R576](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Cauchy_principal_value](https://en.wikipedia.org/wiki/Cauchy_principal_value)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R577](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/CauchyPrincipalValue.html](https://mathworld.wolfram.com/CauchyPrincipalValue.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Performs a change of variables from \(x\) to \(u\) using the relationship given
    by \(x\) and \(u\) which will define the transformations \(f\) and \(F\) (which
    are inverses of each other) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: If \(x\) is a Symbol (which is a variable of integration) then \(u\) will be
    interpreted as some function, f(u), with inverse F(u). This, in effect, just makes
    the substitution of x with f(x).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If \(u\) is a Symbol then \(x\) will be interpreted as some function, F(x),
    with inverse f(u). This is commonly referred to as u-substitution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once f and F have been identified, the transformation is made as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_a^b x \mathrm{d}x \rightarrow \int_{F(a)}^{F(b)} f(x) \frac{\mathrm{d}}{\mathrm{d}x}\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(F(x)\) is the inverse of \(f(x)\) and the limits and integrand have
    been corrected so as to retain the same value after integration.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The mappings, F(x) or f(u), must lead to a unique integral. Linear or rational
    linear expression, `2*x`, `1/x` and `sqrt(x)`, will always work; quadratic expressions
    like `x**2 - 1` are acceptable as long as the resulting integrand does not depend
    on the sign of the solutions (see examples).
  prefs: []
  type: TYPE_NORMAL
- en: The integral will be returned unchanged if `x` is not a variable of integration.
  prefs: []
  type: TYPE_NORMAL
- en: '`x` must be (or contain) only one of of the integration variables. If `u` has
    more than one free symbol then it should be sent as a tuple (`u`, `uvar`) where
    `uvar` identifies which variable is replacing the integration variable. XXX can
    it contain another integration variable?'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: transform can change the variable of integration
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'transform can perform u-substitution as long as a unique integrand is obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'This attempt fails because x = +/-sqrt(u + 1) and the sign does not cancel
    out of the integrand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'transform can do a substitution. Here, the previous result is transformed back
    into the original expression using “u-substitution”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'We can accomplish the same with a regular substitution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'If the \(x\) does not contain a symbol of integration then the integral will
    be returned unchanged. Integral \(i\) does not have an integration variable \(a\)
    so no change is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'When \(u\) has more than one free symbol the symbol that is replacing \(x\)
    must be identified by passing \(u\) as a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.concrete.expr_with_limits.ExprWithLimits.variables`](#sympy.concrete.expr_with_limits.ExprWithLimits.variables
    "sympy.concrete.expr_with_limits.ExprWithLimits.variables")'
  prefs: []
  type: TYPE_NORMAL
- en: Lists the integration variables
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_dummy`](../core.html#sympy.core.basic.Basic.as_dummy "sympy.core.basic.Basic.as_dummy")'
  prefs: []
  type: TYPE_NORMAL
- en: Replace integration variables with dummy ones
  prefs: []
  type: TYPE_NORMAL
- en: '[`Integral`](#sympy.integrals.integrals.Integral "sympy.integrals.integrals.Integral")
    subclasses from [`ExprWithLimits`](#sympy.concrete.expr_with_limits.ExprWithLimits
    "sympy.concrete.expr_with_limits.ExprWithLimits"), which is a common superclass
    of [`Integral`](#sympy.integrals.integrals.Integral "sympy.integrals.integrals.Integral")
    and [`Sum`](../concrete.html#sympy.concrete.summations.Sum "sympy.concrete.summations.Sum").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Return only variables that are dummy variables.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`function`](#sympy.concrete.expr_with_limits.ExprWithLimits.function "sympy.concrete.expr_with_limits.ExprWithLimits.function"),
    [`limits`](#sympy.concrete.expr_with_limits.ExprWithLimits.limits "sympy.concrete.expr_with_limits.ExprWithLimits.limits"),
    [`free_symbols`](#sympy.concrete.expr_with_limits.ExprWithLimits.free_symbols
    "sympy.concrete.expr_with_limits.ExprWithLimits.free_symbols")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_dummy`](../core.html#sympy.core.basic.Basic.as_dummy "sympy.core.basic.Basic.as_dummy")'
  prefs: []
  type: TYPE_NORMAL
- en: Rename dummy variables
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.integrals.integrals.Integral.transform`](#sympy.integrals.integrals.Integral.transform
    "sympy.integrals.integrals.Integral.transform")'
  prefs: []
  type: TYPE_NORMAL
- en: Perform mapping on the dummy variable
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: This method returns the symbols in the object, excluding those that take on
    a specific value (i.e. the dummy symbols).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Return the function applied across limits.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`limits`](#sympy.concrete.expr_with_limits.ExprWithLimits.limits "sympy.concrete.expr_with_limits.ExprWithLimits.limits"),
    [`variables`](#sympy.concrete.expr_with_limits.ExprWithLimits.variables "sympy.concrete.expr_with_limits.ExprWithLimits.variables"),
    [`free_symbols`](#sympy.concrete.expr_with_limits.ExprWithLimits.free_symbols
    "sympy.concrete.expr_with_limits.ExprWithLimits.free_symbols")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if the limits are known to be finite, either by the explicit bounds,
    assumptions on the bounds, or assumptions on the variables. False if known to
    be infinite, based on the bounds. None if not enough information is available
    to determine.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`has_reversed_limits`](#sympy.concrete.expr_with_limits.ExprWithLimits.has_reversed_limits
    "sympy.concrete.expr_with_limits.ExprWithLimits.has_reversed_limits")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if the limits are known to be in reversed order, either by the
    explicit bounds, assumptions on the bounds, or assumptions on the variables. False
    if known to be in normal order, based on the bounds. None if not enough information
    is available to determine.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.has_empty_sequence`](../concrete.html#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.has_empty_sequence
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.has_empty_sequence")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the Sum has no free symbols, else False.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Return the limits of expression.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`function`](#sympy.concrete.expr_with_limits.ExprWithLimits.function "sympy.concrete.expr_with_limits.ExprWithLimits.function"),
    [`variables`](#sympy.concrete.expr_with_limits.ExprWithLimits.variables "sympy.concrete.expr_with_limits.ExprWithLimits.variables"),
    [`free_symbols`](#sympy.concrete.expr_with_limits.ExprWithLimits.free_symbols
    "sympy.concrete.expr_with_limits.ExprWithLimits.free_symbols")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of the limit variables.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`function`](#sympy.concrete.expr_with_limits.ExprWithLimits.function "sympy.concrete.expr_with_limits.ExprWithLimits.function"),
    [`limits`](#sympy.concrete.expr_with_limits.ExprWithLimits.limits "sympy.concrete.expr_with_limits.ExprWithLimits.limits"),
    [`free_symbols`](#sympy.concrete.expr_with_limits.ExprWithLimits.free_symbols
    "sympy.concrete.expr_with_limits.ExprWithLimits.free_symbols")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_dummy`](../core.html#sympy.core.basic.Basic.as_dummy "sympy.core.basic.Basic.as_dummy")'
  prefs: []
  type: TYPE_NORMAL
- en: Rename dummy variables
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.integrals.integrals.Integral.transform`](#sympy.integrals.integrals.Integral.transform
    "sympy.integrals.integrals.Integral.transform")'
  prefs: []
  type: TYPE_NORMAL
- en: Perform mapping on the dummy variable
  prefs: []
  type: TYPE_NORMAL
- en: TODO and Bugs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are still lots of functions that SymPy does not know how to integrate.
    For bugs related to this module, see [https://github.com/sympy/sympy/issues?q=is%3Aissue+is%3Aopen+label%3Aintegrals](https://github.com/sympy/sympy/issues?q=is%3Aissue+is%3Aopen+label%3Aintegrals)
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Integrals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SymPy has functions to calculate points and weights for Gaussian quadrature
    of any order and any precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Computes the Gauss-Legendre quadrature [[R578]](#r578) points and weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n :**'
  prefs: []
  type: TYPE_NORMAL
- en: The order of quadrature.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n_digits :**'
  prefs: []
  type: TYPE_NORMAL
- en: Number of significant digits of the points and weights to return.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(x, w)** : the `x` and `w` are lists of points and weights as Floats.'
  prefs: []
  type: TYPE_NORMAL
- en: The points \(x_i\) and weights \(w_i\) are returned as `(x, w)` tuple of lists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gauss-Legendre quadrature approximates the integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_{-1}^1 f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodes \(x_i\) of an order \(n\) quadrature rule are the roots of \(P_n\)
    and the weights \(w_i\) are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[w_i = \frac{2}{\left(1-x_i^2\right) \left(P'_n(x_i)\right)^2}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`gauss_laguerre`](#sympy.integrals.quadrature.gauss_laguerre "sympy.integrals.quadrature.gauss_laguerre"),
    [`gauss_gen_laguerre`](#sympy.integrals.quadrature.gauss_gen_laguerre "sympy.integrals.quadrature.gauss_gen_laguerre"),
    [`gauss_hermite`](#sympy.integrals.quadrature.gauss_hermite "sympy.integrals.quadrature.gauss_hermite"),
    [`gauss_chebyshev_t`](#sympy.integrals.quadrature.gauss_chebyshev_t "sympy.integrals.quadrature.gauss_chebyshev_t"),
    [`gauss_chebyshev_u`](#sympy.integrals.quadrature.gauss_chebyshev_u "sympy.integrals.quadrature.gauss_chebyshev_u"),
    [`gauss_jacobi`](#sympy.integrals.quadrature.gauss_jacobi "sympy.integrals.quadrature.gauss_jacobi"),
    [`gauss_lobatto`](#sympy.integrals.quadrature.gauss_lobatto "sympy.integrals.quadrature.gauss_lobatto")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R578] ([1](#id12),[2](#id13))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Gaussian_quadrature](https://en.wikipedia.org/wiki/Gaussian_quadrature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R579](#id14)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html](https://people.sc.fsu.edu/~jburkardt/cpp_src/legendre_rule/legendre_rule.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Computes the Gauss-Laguerre quadrature [[R580]](#r580) points and weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n :**'
  prefs: []
  type: TYPE_NORMAL
- en: The order of quadrature.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n_digits :**'
  prefs: []
  type: TYPE_NORMAL
- en: Number of significant digits of the points and weights to return.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(x, w)** : The `x` and `w` are lists of points and weights as Floats.'
  prefs: []
  type: TYPE_NORMAL
- en: The points \(x_i\) and weights \(w_i\) are returned as `(x, w)` tuple of lists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gauss-Laguerre quadrature approximates the integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_0^{\infty} e^{-x} f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodes \(x_i\) of an order \(n\) quadrature rule are the roots of \(L_n\)
    and the weights \(w_i\) are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[w_i = \frac{x_i}{(n+1)^2 \left(L_{n+1}(x_i)\right)^2}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`gauss_legendre`](#sympy.integrals.quadrature.gauss_legendre "sympy.integrals.quadrature.gauss_legendre"),
    [`gauss_gen_laguerre`](#sympy.integrals.quadrature.gauss_gen_laguerre "sympy.integrals.quadrature.gauss_gen_laguerre"),
    [`gauss_hermite`](#sympy.integrals.quadrature.gauss_hermite "sympy.integrals.quadrature.gauss_hermite"),
    [`gauss_chebyshev_t`](#sympy.integrals.quadrature.gauss_chebyshev_t "sympy.integrals.quadrature.gauss_chebyshev_t"),
    [`gauss_chebyshev_u`](#sympy.integrals.quadrature.gauss_chebyshev_u "sympy.integrals.quadrature.gauss_chebyshev_u"),
    [`gauss_jacobi`](#sympy.integrals.quadrature.gauss_jacobi "sympy.integrals.quadrature.gauss_jacobi"),
    [`gauss_lobatto`](#sympy.integrals.quadrature.gauss_lobatto "sympy.integrals.quadrature.gauss_lobatto")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R580] ([1](#id15),[2](#id16))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature](https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R581](#id17)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html](https://people.sc.fsu.edu/~jburkardt/cpp_src/laguerre_rule/laguerre_rule.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Computes the Gauss-Hermite quadrature [[R582]](#r582) points and weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n :**'
  prefs: []
  type: TYPE_NORMAL
- en: The order of quadrature.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n_digits :**'
  prefs: []
  type: TYPE_NORMAL
- en: Number of significant digits of the points and weights to return.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(x, w)** : The `x` and `w` are lists of points and weights as Floats.'
  prefs: []
  type: TYPE_NORMAL
- en: The points \(x_i\) and weights \(w_i\) are returned as `(x, w)` tuple of lists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gauss-Hermite quadrature approximates the integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_{-\infty}^{\infty} e^{-x^2} f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodes \(x_i\) of an order \(n\) quadrature rule are the roots of \(H_n\)
    and the weights \(w_i\) are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[w_i = \frac{2^{n-1} n! \sqrt{\pi}}{n^2 \left(H_{n-1}(x_i)\right)^2}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`gauss_legendre`](#sympy.integrals.quadrature.gauss_legendre "sympy.integrals.quadrature.gauss_legendre"),
    [`gauss_laguerre`](#sympy.integrals.quadrature.gauss_laguerre "sympy.integrals.quadrature.gauss_laguerre"),
    [`gauss_gen_laguerre`](#sympy.integrals.quadrature.gauss_gen_laguerre "sympy.integrals.quadrature.gauss_gen_laguerre"),
    [`gauss_chebyshev_t`](#sympy.integrals.quadrature.gauss_chebyshev_t "sympy.integrals.quadrature.gauss_chebyshev_t"),
    [`gauss_chebyshev_u`](#sympy.integrals.quadrature.gauss_chebyshev_u "sympy.integrals.quadrature.gauss_chebyshev_u"),
    [`gauss_jacobi`](#sympy.integrals.quadrature.gauss_jacobi "sympy.integrals.quadrature.gauss_jacobi"),
    [`gauss_lobatto`](#sympy.integrals.quadrature.gauss_lobatto "sympy.integrals.quadrature.gauss_lobatto")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R582] ([1](#id18),[2](#id19))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Gauss-Hermite_Quadrature](https://en.wikipedia.org/wiki/Gauss-Hermite_Quadrature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R583](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html](https://people.sc.fsu.edu/~jburkardt/cpp_src/hermite_rule/hermite_rule.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R584](#id21)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html](https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_hermite_rule/gen_hermite_rule.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Computes the generalized Gauss-Laguerre quadrature [[R585]](#r585) points and
    weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n :**'
  prefs: []
  type: TYPE_NORMAL
- en: The order of quadrature.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**alpha :**'
  prefs: []
  type: TYPE_NORMAL
- en: The exponent of the singularity, \(\alpha > -1\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n_digits :**'
  prefs: []
  type: TYPE_NORMAL
- en: Number of significant digits of the points and weights to return.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(x, w)** : the `x` and `w` are lists of points and weights as Floats.'
  prefs: []
  type: TYPE_NORMAL
- en: The points \(x_i\) and weights \(w_i\) are returned as `(x, w)` tuple of lists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The generalized Gauss-Laguerre quadrature approximates the integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_{0}^\infty x^{\alpha} e^{-x} f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodes \(x_i\) of an order \(n\) quadrature rule are the roots of \(L^{\alpha}_n\)
    and the weights \(w_i\) are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[w_i = \frac{\Gamma(\alpha+n)} {n \Gamma(n) L^{\alpha}_{n-1}(x_i) L^{\alpha+1}_{n-1}(x_i)}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`gauss_legendre`](#sympy.integrals.quadrature.gauss_legendre "sympy.integrals.quadrature.gauss_legendre"),
    [`gauss_laguerre`](#sympy.integrals.quadrature.gauss_laguerre "sympy.integrals.quadrature.gauss_laguerre"),
    [`gauss_hermite`](#sympy.integrals.quadrature.gauss_hermite "sympy.integrals.quadrature.gauss_hermite"),
    [`gauss_chebyshev_t`](#sympy.integrals.quadrature.gauss_chebyshev_t "sympy.integrals.quadrature.gauss_chebyshev_t"),
    [`gauss_chebyshev_u`](#sympy.integrals.quadrature.gauss_chebyshev_u "sympy.integrals.quadrature.gauss_chebyshev_u"),
    [`gauss_jacobi`](#sympy.integrals.quadrature.gauss_jacobi "sympy.integrals.quadrature.gauss_jacobi"),
    [`gauss_lobatto`](#sympy.integrals.quadrature.gauss_lobatto "sympy.integrals.quadrature.gauss_lobatto")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R585] ([1](#id22),[2](#id23))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature](https://en.wikipedia.org/wiki/Gauss%E2%80%93Laguerre_quadrature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R586](#id24)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html](https://people.sc.fsu.edu/~jburkardt/cpp_src/gen_laguerre_rule/gen_laguerre_rule.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Computes the Gauss-Chebyshev quadrature [[R587]](#r587) points and weights of
    the first kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n :**'
  prefs: []
  type: TYPE_NORMAL
- en: The order of quadrature.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n_digits :**'
  prefs: []
  type: TYPE_NORMAL
- en: Number of significant digits of the points and weights to return.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(x, w)** : the `x` and `w` are lists of points and weights as Floats.'
  prefs: []
  type: TYPE_NORMAL
- en: The points \(x_i\) and weights \(w_i\) are returned as `(x, w)` tuple of lists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gauss-Chebyshev quadrature of the first kind approximates the integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_{-1}^{1} \frac{1}{\sqrt{1-x^2}} f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodes \(x_i\) of an order \(n\) quadrature rule are the roots of \(T_n\)
    and the weights \(w_i\) are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[w_i = \frac{\pi}{n}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`gauss_legendre`](#sympy.integrals.quadrature.gauss_legendre "sympy.integrals.quadrature.gauss_legendre"),
    [`gauss_laguerre`](#sympy.integrals.quadrature.gauss_laguerre "sympy.integrals.quadrature.gauss_laguerre"),
    [`gauss_hermite`](#sympy.integrals.quadrature.gauss_hermite "sympy.integrals.quadrature.gauss_hermite"),
    [`gauss_gen_laguerre`](#sympy.integrals.quadrature.gauss_gen_laguerre "sympy.integrals.quadrature.gauss_gen_laguerre"),
    [`gauss_chebyshev_u`](#sympy.integrals.quadrature.gauss_chebyshev_u "sympy.integrals.quadrature.gauss_chebyshev_u"),
    [`gauss_jacobi`](#sympy.integrals.quadrature.gauss_jacobi "sympy.integrals.quadrature.gauss_jacobi"),
    [`gauss_lobatto`](#sympy.integrals.quadrature.gauss_lobatto "sympy.integrals.quadrature.gauss_lobatto")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R587] ([1](#id25),[2](#id26))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature](https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R588](#id27)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html](https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev1_rule/chebyshev1_rule.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Computes the Gauss-Chebyshev quadrature [[R589]](#r589) points and weights of
    the second kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : the order of quadrature'
  prefs: []
  type: TYPE_NORMAL
- en: '**n_digits** : number of significant digits of the points and weights to return'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(x, w)** : the `x` and `w` are lists of points and weights as Floats.'
  prefs: []
  type: TYPE_NORMAL
- en: The points \(x_i\) and weights \(w_i\) are returned as `(x, w)` tuple of lists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gauss-Chebyshev quadrature of the second kind approximates the integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_{-1}^{1} \sqrt{1-x^2} f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodes \(x_i\) of an order \(n\) quadrature rule are the roots of \(U_n\)
    and the weights \(w_i\) are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[w_i = \frac{\pi}{n+1} \sin^2 \left(\frac{i}{n+1}\pi\right)\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`gauss_legendre`](#sympy.integrals.quadrature.gauss_legendre "sympy.integrals.quadrature.gauss_legendre"),
    [`gauss_laguerre`](#sympy.integrals.quadrature.gauss_laguerre "sympy.integrals.quadrature.gauss_laguerre"),
    [`gauss_hermite`](#sympy.integrals.quadrature.gauss_hermite "sympy.integrals.quadrature.gauss_hermite"),
    [`gauss_gen_laguerre`](#sympy.integrals.quadrature.gauss_gen_laguerre "sympy.integrals.quadrature.gauss_gen_laguerre"),
    [`gauss_chebyshev_t`](#sympy.integrals.quadrature.gauss_chebyshev_t "sympy.integrals.quadrature.gauss_chebyshev_t"),
    [`gauss_jacobi`](#sympy.integrals.quadrature.gauss_jacobi "sympy.integrals.quadrature.gauss_jacobi"),
    [`gauss_lobatto`](#sympy.integrals.quadrature.gauss_lobatto "sympy.integrals.quadrature.gauss_lobatto")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R589] ([1](#id28),[2](#id29))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature](https://en.wikipedia.org/wiki/Chebyshev%E2%80%93Gauss_quadrature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R590](#id30)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html](https://people.sc.fsu.edu/~jburkardt/cpp_src/chebyshev2_rule/chebyshev2_rule.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Computes the Gauss-Jacobi quadrature [[R591]](#r591) points and weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : the order of quadrature'
  prefs: []
  type: TYPE_NORMAL
- en: '**alpha** : the first parameter of the Jacobi Polynomial, \(\alpha > -1\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**beta** : the second parameter of the Jacobi Polynomial, \(\beta > -1\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**n_digits** : number of significant digits of the points and weights to return'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(x, w)** : the `x` and `w` are lists of points and weights as Floats.'
  prefs: []
  type: TYPE_NORMAL
- en: The points \(x_i\) and weights \(w_i\) are returned as `(x, w)` tuple of lists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gauss-Jacobi quadrature of the first kind approximates the integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_{-1}^1 (1-x)^\alpha (1+x)^\beta f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodes \(x_i\) of an order \(n\) quadrature rule are the roots of \(P^{(\alpha,\beta)}_n\)
    and the weights \(w_i\) are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[w_i = -\frac{2n+\alpha+\beta+2}{n+\alpha+\beta+1} \frac{\Gamma(n+\alpha+1)\Gamma(n+\beta+1)}
    {\Gamma(n+\alpha+\beta+1)(n+1)!} \frac{2^{\alpha+\beta}}{P'_n(x_i) P^{(\alpha,\beta)}_{n+1}(x_i)}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`gauss_legendre`](#sympy.integrals.quadrature.gauss_legendre "sympy.integrals.quadrature.gauss_legendre"),
    [`gauss_laguerre`](#sympy.integrals.quadrature.gauss_laguerre "sympy.integrals.quadrature.gauss_laguerre"),
    [`gauss_hermite`](#sympy.integrals.quadrature.gauss_hermite "sympy.integrals.quadrature.gauss_hermite"),
    [`gauss_gen_laguerre`](#sympy.integrals.quadrature.gauss_gen_laguerre "sympy.integrals.quadrature.gauss_gen_laguerre"),
    [`gauss_chebyshev_t`](#sympy.integrals.quadrature.gauss_chebyshev_t "sympy.integrals.quadrature.gauss_chebyshev_t"),
    [`gauss_chebyshev_u`](#sympy.integrals.quadrature.gauss_chebyshev_u "sympy.integrals.quadrature.gauss_chebyshev_u"),
    [`gauss_lobatto`](#sympy.integrals.quadrature.gauss_lobatto "sympy.integrals.quadrature.gauss_lobatto")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R591] ([1](#id31),[2](#id32))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature](https://en.wikipedia.org/wiki/Gauss%E2%80%93Jacobi_quadrature)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R592](#id33)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html](https://people.sc.fsu.edu/~jburkardt/cpp_src/jacobi_rule/jacobi_rule.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R593](#id34)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html](https://people.sc.fsu.edu/~jburkardt/cpp_src/gegenbauer_rule/gegenbauer_rule.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Computes the Gauss-Lobatto quadrature [[R594]](#r594) points and weights.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** : the order of quadrature'
  prefs: []
  type: TYPE_NORMAL
- en: '**n_digits** : number of significant digits of the points and weights to return'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(x, w)** : the `x` and `w` are lists of points and weights as Floats.'
  prefs: []
  type: TYPE_NORMAL
- en: The points \(x_i\) and weights \(w_i\) are returned as `(x, w)` tuple of lists.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gauss-Lobatto quadrature approximates the integral:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_{-1}^1 f(x)\,dx \approx \sum_{i=1}^n w_i f(x_i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodes \(x_i\) of an order \(n\) quadrature rule are the roots of \(P''_(n-1)\)
    and the weights \(w_i\) are given by:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}&w_i = \frac{2}{n(n-1) \left[P_{n-1}(x_i)\right]^2},\quad x\neq\pm
    1\\ &w_i = \frac{2}{n(n-1)},\quad x=\pm 1\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`gauss_legendre`](#sympy.integrals.quadrature.gauss_legendre "sympy.integrals.quadrature.gauss_legendre"),
    [`gauss_laguerre`](#sympy.integrals.quadrature.gauss_laguerre "sympy.integrals.quadrature.gauss_laguerre"),
    [`gauss_gen_laguerre`](#sympy.integrals.quadrature.gauss_gen_laguerre "sympy.integrals.quadrature.gauss_gen_laguerre"),
    [`gauss_hermite`](#sympy.integrals.quadrature.gauss_hermite "sympy.integrals.quadrature.gauss_hermite"),
    [`gauss_chebyshev_t`](#sympy.integrals.quadrature.gauss_chebyshev_t "sympy.integrals.quadrature.gauss_chebyshev_t"),
    [`gauss_chebyshev_u`](#sympy.integrals.quadrature.gauss_chebyshev_u "sympy.integrals.quadrature.gauss_chebyshev_u"),
    [`gauss_jacobi`](#sympy.integrals.quadrature.gauss_jacobi "sympy.integrals.quadrature.gauss_jacobi")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R594] ([1](#id35),[2](#id36))'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules](https://en.wikipedia.org/wiki/Gaussian_quadrature#Gauss.E2.80.93Lobatto_rules)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R595](#id37)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm](https://web.archive.org/web/20200118141346/http://people.math.sfu.ca/~cbm/aands/page_888.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Integration over Polytopes'
  prefs: []
  type: TYPE_NORMAL
- en: The `intpoly` module in SymPy implements methods to calculate the integral of
    a polynomial over 2/3-Polytopes. Uses evaluation techniques as described in Chin
    et al. (2015) [1].
  prefs: []
  type: TYPE_NORMAL
- en: The input for 2-Polytope or Polygon uses the already existing `Polygon` data
    structure in SymPy. See [`sympy.geometry.polygon`](../geometry/polygons.html#module-sympy.geometry.polygon
    "sympy.geometry.polygon") for how to create a polygon.
  prefs: []
  type: TYPE_NORMAL
- en: For the 3-Polytope or Polyhedron, the most economical representation is to specify
    a list of vertices and then to provide each constituting face(Polygon) as a list
    of vertex indices.
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider the unit cube. Here is how it would be represented.
  prefs: []
  type: TYPE_NORMAL
- en: '`unit_cube = [[(0, 0, 0), (0, 0, 1), (0, 1, 0), (0, 1, 1), (1, 0, 0),(1, 0,
    1), (1, 1, 0), (1, 1, 1)],`'
  prefs: []
  type: TYPE_NORMAL
- en: '`[3, 7, 6, 2], [1, 5, 7, 3], [5, 4, 6, 7], [0, 4, 5, 1], [2, 0, 1, 3], [2,
    6, 4, 0]]`'
  prefs: []
  type: TYPE_NORMAL
- en: Here, the first sublist is the list of vertices. The other smaller lists such
    as `[3, 7, 6, 2]` represent a 2D face of the polyhedra with vertices having index
    `3, 7, 6 and 2` in the first sublist(in that order).
  prefs: []
  type: TYPE_NORMAL
- en: Principal method in this module is [`polytope_integrate()`](#sympy.integrals.intpoly.polytope_integrate
    "sympy.integrals.intpoly.polytope_integrate")
  prefs: []
  type: TYPE_NORMAL
- en: '`polytope_integrate(Polygon((0, 0), (0, 1), (1, 0)), x)` returns the integral
    of \(x\) over the triangle with vertices (0, 0), (0, 1) and (1, 0)'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`polytope_integrate(unit_cube, x + y + z)` returns the integral of \(x + y
    + z\) over the unit cube.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[1] : Chin, Eric B., Jean B. Lasserre, and N. Sukumar. “Numerical integration
    of homogeneous functions on convex and nonconvex polygons and polyhedra.” Computational
    Mechanics 56.6 (2015): 967-981'
  prefs: []
  type: TYPE_NORMAL
- en: 'PDF link : [http://dilbert.engr.ucdavis.edu/~suku/quadrature/cls-integration.pdf](http://dilbert.engr.ucdavis.edu/~suku/quadrature/cls-integration.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For 2D Polygons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Single Polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'List of specified polynomials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'Computing all monomials up to a maximum degree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: For 3-Polytopes/Polyhedra
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Single Polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'List of specified polynomials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Computing all monomials up to a maximum degree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: API reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: Integrates polynomials over 2/3-Polytopes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**poly** : The input Polygon.'
  prefs: []
  type: TYPE_NORMAL
- en: '**expr** : The input polynomial.'
  prefs: []
  type: TYPE_NORMAL
- en: '**clockwise** : Binary value to sort input points of 2-Polytope clockwise.(Optional)'
  prefs: []
  type: TYPE_NORMAL
- en: '**max_degree** : The maximum degree of any monomial of the input polynomial.(Optional)'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This function accepts the polytope in `poly` and the function in `expr` (uni/bi/trivariate
    polynomials are implemented) and returns the exact integral of `expr` over `poly`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
