- en: Bit Generators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/random/bit_generators/index.html](https://numpy.org/doc/1.26/reference/random/bit_generators/index.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The random values produced by [`Generator`](../generator.html#numpy.random.Generator
    "numpy.random.Generator") originate in a BitGenerator. The BitGenerators do not
    directly provide random numbers and only contains methods used for seeding, getting
    or setting the state, jumping or advancing the state, and for accessing low-level
    wrappers for consumption by code that can efficiently access the functions provided,
    e.g., [numba](https://numba.pydata.org).
  prefs: []
  type: TYPE_NORMAL
- en: Supported BitGenerators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The included BitGenerators are:'
  prefs: []
  type: TYPE_NORMAL
- en: PCG-64 - The default. A fast generator that can be advanced by an arbitrary
    amount. See the documentation for [`advance`](generated/numpy.random.PCG64.advance.html#numpy.random.PCG64.advance
    "numpy.random.PCG64.advance"). PCG-64 has a period of \(2^{128}\). See the [PCG
    author’s page](http://www.pcg-random.org/) for more details about this class of
    PRNG.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PCG-64 DXSM - An upgraded version of PCG-64 with better statistical properties
    in parallel contexts. See [Upgrading PCG64 with PCG64DXSM](../upgrading-pcg64.html#upgrading-pcg64)
    for more information on these improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MT19937 - The standard Python BitGenerator. Adds a [`MT19937.jumped`](generated/numpy.random.MT19937.jumped.html#numpy.random.MT19937.jumped
    "numpy.random.MT19937.jumped") function that returns a new generator with state
    as-if \(2^{128}\) draws have been made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Philox - A counter-based generator capable of being advanced an arbitrary number
    of steps or generating independent streams. See the [Random123](https://www.deshawresearch.com/resources_random123.html)
    page for more details about this class of bit generators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFC64 - A fast generator based on random invertible mappings. Usually the fastest
    generator of the four. See the [SFC author’s page](http://pracrand.sourceforge.net/RNG_engines.txt)
    for (a little) more detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| [`BitGenerator`](generated/numpy.random.BitGenerator.html#numpy.random.BitGenerator
    "numpy.random.BitGenerator")([seed]) | Base Class for generic BitGenerators, which
    provide a stream of random bits based on different algorithms. |'
  prefs: []
  type: TYPE_TB
- en: '[MT19937](mt19937.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PCG64](pcg64.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PCG64DXSM](pcg64dxsm.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Philox](philox.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SFC64](sfc64.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported BitGenerators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The included BitGenerators are:'
  prefs: []
  type: TYPE_NORMAL
- en: PCG-64 - The default. A fast generator that can be advanced by an arbitrary
    amount. See the documentation for [`advance`](generated/numpy.random.PCG64.advance.html#numpy.random.PCG64.advance
    "numpy.random.PCG64.advance"). PCG-64 has a period of \(2^{128}\). See the [PCG
    author’s page](http://www.pcg-random.org/) for more details about this class of
    PRNG.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PCG-64 DXSM - An upgraded version of PCG-64 with better statistical properties
    in parallel contexts. See [Upgrading PCG64 with PCG64DXSM](../upgrading-pcg64.html#upgrading-pcg64)
    for more information on these improvements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MT19937 - The standard Python BitGenerator. Adds a [`MT19937.jumped`](generated/numpy.random.MT19937.jumped.html#numpy.random.MT19937.jumped
    "numpy.random.MT19937.jumped") function that returns a new generator with state
    as-if \(2^{128}\) draws have been made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Philox - A counter-based generator capable of being advanced an arbitrary number
    of steps or generating independent streams. See the [Random123](https://www.deshawresearch.com/resources_random123.html)
    page for more details about this class of bit generators.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFC64 - A fast generator based on random invertible mappings. Usually the fastest
    generator of the four. See the [SFC author’s page](http://pracrand.sourceforge.net/RNG_engines.txt)
    for (a little) more detail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| [`BitGenerator`](generated/numpy.random.BitGenerator.html#numpy.random.BitGenerator
    "numpy.random.BitGenerator")([seed]) | Base Class for generic BitGenerators, which
    provide a stream of random bits based on different algorithms. |'
  prefs: []
  type: TYPE_TB
- en: '[MT19937](mt19937.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PCG64](pcg64.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PCG64DXSM](pcg64dxsm.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Philox](philox.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SFC64](sfc64.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '# Seeding and Entropy'
  prefs: []
  type: TYPE_NORMAL
- en: A BitGenerator provides a stream of random values. In order to generate reproducible
    streams, BitGenerators support setting their initial state via a seed. All of
    the provided BitGenerators will take an arbitrary-sized non-negative integer,
    or a list of such integers, as a seed. BitGenerators need to take those inputs
    and process them into a high-quality internal state for the BitGenerator. All
    of the BitGenerators in numpy delegate that task to [`SeedSequence`](generated/numpy.random.SeedSequence.html#numpy.random.SeedSequence
    "numpy.random.SeedSequence"), which uses hashing techniques to ensure that even
    low-quality seeds generate high-quality initial states.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[`SeedSequence`](generated/numpy.random.SeedSequence.html#numpy.random.SeedSequence
    "numpy.random.SeedSequence") is designed to be convenient for implementing best
    practices. We recommend that a stochastic program defaults to using entropy from
    the OS so that each run is different. The program should print out or log that
    entropy. In order to reproduce a past value, the program should allow the user
    to provide that value through some mechanism, a command-line argument is common,
    so that the user can then re-enter that entropy to reproduce the result. [`SeedSequence`](generated/numpy.random.SeedSequence.html#numpy.random.SeedSequence
    "numpy.random.SeedSequence") can take care of everything except for communicating
    with the user, which is up to you.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We default to using a 128-bit integer using entropy gathered from the OS. This
    is a good amount of entropy to initialize all of the generators that we have in
    numpy. We do not recommend using small seeds below 32 bits for general use. Using
    just a small set of seeds to instantiate larger state spaces means that there
    are some initial states that are impossible to reach. This creates some biases
    if everyone uses such values.
  prefs: []
  type: TYPE_NORMAL
- en: There will not be anything *wrong* with the results, per se; even a seed of
    0 is perfectly fine thanks to the processing that [`SeedSequence`](generated/numpy.random.SeedSequence.html#numpy.random.SeedSequence
    "numpy.random.SeedSequence") does. If you just need *some* fixed value for unit
    tests or debugging, feel free to use whatever seed you like. But if you want to
    make inferences from the results or publish them, drawing from a larger set of
    seeds is good practice.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to generate a good seed “offline”, then `SeedSequence().entropy`
    or using `secrets.randbits(128)` from the standard library are both convenient
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to run several stochastic simulations in parallel, best practice
    is to construct a random generator instance for each simulation. To make sure
    that the random streams have distinct initial states, you can use the *spawn*
    method of [`SeedSequence`](generated/numpy.random.SeedSequence.html#numpy.random.SeedSequence
    "numpy.random.SeedSequence"). For instance, here we construct a list of 12 instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you already have an initial random generator instance, you can shorten the
    above by using the [`spawn`](generated/numpy.random.BitGenerator.spawn.html#numpy.random.BitGenerator.spawn
    "numpy.random.BitGenerator.spawn") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: An alternative way is to use the fact that a [`SeedSequence`](generated/numpy.random.SeedSequence.html#numpy.random.SeedSequence
    "numpy.random.SeedSequence") can be initialized by a tuple of elements. Here we
    use a base entropy value and an integer `worker_id`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the sequences produced by the latter method will be distinct from
    those constructed via [`spawn`](generated/numpy.random.SeedSequence.spawn.html#numpy.random.SeedSequence.spawn
    "numpy.random.SeedSequence.spawn").
  prefs: []
  type: TYPE_NORMAL
- en: '| [`SeedSequence`](generated/numpy.random.SeedSequence.html#numpy.random.SeedSequence
    "numpy.random.SeedSequence")([entropy, spawn_key, pool_size]) | SeedSequence mixes
    sources of entropy in a reproducible way to set the initial state for independent
    and very probably non-overlapping BitGenerators. |'
  prefs: []
  type: TYPE_TB
