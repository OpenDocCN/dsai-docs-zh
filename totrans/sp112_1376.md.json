["```py\nscipy.stats.sobol_indices(*, func, n, dists=None, method='saltelli_2010', random_state=None)\n```", "```py\nfunc(x: ArrayLike) -> ArrayLike \n```", "```py\nfunc(f_A: np.ndarray, f_B: np.ndarray, f_AB: np.ndarray)\n-> Tuple[np.ndarray, np.ndarray] \n```", "```py\n>>> import numpy as np\n>>> from scipy.stats import sobol_indices, uniform\n>>> rng = np.random.default_rng()\n>>> def f_ishigami(x):\n...     f_eval = (\n...         np.sin(x[0])\n...         + 7 * np.sin(x[1])**2\n...         + 0.1 * (x[2]**4) * np.sin(x[0])\n...     )\n...     return f_eval\n>>> indices = sobol_indices(\n...     func=f_ishigami, n=1024,\n...     dists=[\n...         uniform(loc=-np.pi, scale=2*np.pi),\n...         uniform(loc=-np.pi, scale=2*np.pi),\n...         uniform(loc=-np.pi, scale=2*np.pi)\n...     ],\n...     random_state=rng\n... )\n>>> indices.first_order\narray([0.31637954, 0.43781162, 0.00318825])\n>>> indices.total_order\narray([0.56122127, 0.44287857, 0.24229595]) \n```", "```py\n>>> boot = indices.bootstrap() \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> fig, axs = plt.subplots(1, 2, figsize=(9, 4))\n>>> _ = axs[0].errorbar(\n...     [1, 2, 3], indices.first_order, fmt='o',\n...     yerr=[\n...         indices.first_order - boot.first_order.confidence_interval.low,\n...         boot.first_order.confidence_interval.high - indices.first_order\n...     ],\n... )\n>>> axs[0].set_ylabel(\"First order Sobol' indices\")\n>>> axs[0].set_xlabel('Input parameters')\n>>> axs[0].set_xticks([1, 2, 3])\n>>> _ = axs[1].errorbar(\n...     [1, 2, 3], indices.total_order, fmt='o',\n...     yerr=[\n...         indices.total_order - boot.total_order.confidence_interval.low,\n...         boot.total_order.confidence_interval.high - indices.total_order\n...     ],\n... )\n>>> axs[1].set_ylabel(\"Total order Sobol' indices\")\n>>> axs[1].set_xlabel('Input parameters')\n>>> axs[1].set_xticks([1, 2, 3])\n>>> plt.tight_layout()\n>>> plt.show() \n```", "```py\n>>> from scipy.stats import qmc\n>>> n_dim = 3\n>>> p_labels = ['$x_1$', '$x_2$', '$x_3$']\n>>> sample = qmc.Sobol(d=n_dim, seed=rng).random(1024)\n>>> sample = qmc.scale(\n...     sample=sample,\n...     l_bounds=[-np.pi, -np.pi, -np.pi],\n...     u_bounds=[np.pi, np.pi, np.pi]\n... )\n>>> output = f_ishigami(sample.T) \n```", "```py\n>>> fig, ax = plt.subplots(1, n_dim, figsize=(12, 4))\n>>> for i in range(n_dim):\n...     xi = sample[:, i]\n...     ax[i].scatter(xi, output, marker='+')\n...     ax[i].set_xlabel(p_labels[i])\n>>> ax[0].set_ylabel('Y')\n>>> plt.tight_layout()\n>>> plt.show() \n```", "```py\n>>> mini = np.min(output)\n>>> maxi = np.max(output)\n>>> n_bins = 10\n>>> bins = np.linspace(-np.pi, np.pi, num=n_bins, endpoint=False)\n>>> dx = bins[1] - bins[0]\n>>> fig, ax = plt.subplots(1, n_dim, figsize=(12, 4))\n>>> for i in range(n_dim):\n...     xi = sample[:, i]\n...     ax[i].scatter(xi, output, marker='+')\n...     ax[i].set_xlabel(p_labels[i])\n...     for bin_ in bins:\n...         idx = np.where((bin_ <= xi) & (xi <= bin_ + dx))\n...         xi_ = xi[idx]\n...         y_ = output[idx]\n...         ave_y_ = np.mean(y_)\n...         ax[i].plot([bin_ + dx/2] * 2, [mini, maxi], c='k')\n...         ax[i].scatter(bin_ + dx/2, ave_y_, c='r')\n>>> ax[0].set_ylabel('Y')\n>>> plt.tight_layout()\n>>> plt.show() \n```"]