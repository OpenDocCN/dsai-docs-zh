- en: numpy.sort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.sort.html](https://numpy.org/doc/1.26/reference/generated/numpy.sort.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Return a sorted copy of an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Array to be sorted.
  prefs: []
  type: TYPE_NORMAL
- en: '**axis**int or None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Axis along which to sort. If None, the array is flattened before sorting. The
    default is -1, which sorts along the last axis.
  prefs: []
  type: TYPE_NORMAL
- en: '**kind**{‘quicksort’, ‘mergesort’, ‘heapsort’, ‘stable’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Sorting algorithm. The default is ‘quicksort’. Note that both ‘stable’ and ‘mergesort’
    use timsort or radix sort under the covers and, in general, the actual implementation
    will vary with data type. The ‘mergesort’ option is retained for backwards compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.15.0.: The ‘stable’ option was added.'
  prefs: []
  type: TYPE_NORMAL
- en: '**order**str or list of str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: When *a* is an array with fields defined, this argument specifies which fields
    to compare first, second, etc. A single field can be specified as a string, and
    not all fields need be specified, but unspecified fields will still be used, in
    the order in which they come up in the dtype, to break ties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sorted_array**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Array of the same type and shape as *a*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ndarray.sort`](numpy.ndarray.sort.html#numpy.ndarray.sort "numpy.ndarray.sort")'
  prefs: []
  type: TYPE_NORMAL
- en: Method to sort an array in-place.
  prefs: []
  type: TYPE_NORMAL
- en: '[`argsort`](numpy.argsort.html#numpy.argsort "numpy.argsort")'
  prefs: []
  type: TYPE_NORMAL
- en: Indirect sort.
  prefs: []
  type: TYPE_NORMAL
- en: '[`lexsort`](numpy.lexsort.html#numpy.lexsort "numpy.lexsort")'
  prefs: []
  type: TYPE_NORMAL
- en: Indirect stable sort on multiple keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[`searchsorted`](numpy.searchsorted.html#numpy.searchsorted "numpy.searchsorted")'
  prefs: []
  type: TYPE_NORMAL
- en: Find elements in a sorted array.
  prefs: []
  type: TYPE_NORMAL
- en: '[`partition`](numpy.partition.html#numpy.partition "numpy.partition")'
  prefs: []
  type: TYPE_NORMAL
- en: Partial sort.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'The various sorting algorithms are characterized by their average speed, worst
    case performance, work space size, and whether they are stable. A stable sort
    keeps items with the same key in the same relative order. The four algorithms
    implemented in NumPy have the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '| kind | speed | worst case | work space | stable |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| ‘quicksort’ | 1 | O(n^2) | 0 | no |'
  prefs: []
  type: TYPE_TB
- en: '| ‘heapsort’ | 3 | O(n*log(n)) | 0 | no |'
  prefs: []
  type: TYPE_TB
- en: '| ‘mergesort’ | 2 | O(n*log(n)) | ~n/2 | yes |'
  prefs: []
  type: TYPE_TB
- en: '| ‘timsort’ | 2 | O(n*log(n)) | ~n/2 | yes |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The datatype determines which of ‘mergesort’ or ‘timsort’ is actually used,
    even if ‘mergesort’ is specified. User selection at a finer scale is not currently
    available.
  prefs: []
  type: TYPE_NORMAL
- en: All the sort algorithms make temporary copies of the data when sorting along
    any but the last axis. Consequently, sorting along the last axis is faster and
    uses less space than sorting along any other axis.
  prefs: []
  type: TYPE_NORMAL
- en: The sort order for complex numbers is lexicographic. If both the real and imaginary
    parts are non-nan then the order is determined by the real parts except when they
    are equal, in which case the order is determined by the imaginary parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previous to numpy 1.4.0 sorting real and complex arrays containing nan values
    led to undefined behaviour. In numpy versions >= 1.4.0 nan values are sorted to
    the end. The extended sort order is:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Real: [R, nan]'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: where R is a non-nan real value. Complex values with the same nan placements
    are sorted according to the non-nan part if it exists. Non-nan values are sorted
    as before.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.12.0.
  prefs: []
  type: TYPE_NORMAL
- en: quicksort has been changed to [introsort](https://en.wikipedia.org/wiki/Introsort).
    When sorting does not make enough progress it switches to [heapsort](https://en.wikipedia.org/wiki/Heapsort).
    This implementation makes quicksort O(n*log(n)) in the worst case.
  prefs: []
  type: TYPE_NORMAL
- en: ‘stable’ automatically chooses the best stable sorting algorithm for the data
    type being sorted. It, along with ‘mergesort’ is currently mapped to [timsort](https://en.wikipedia.org/wiki/Timsort)
    or [radix sort](https://en.wikipedia.org/wiki/Radix_sort) depending on the data
    type. API forward compatibility currently limits the ability to select the implementation
    and it is hardwired for the different data types.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.17.0.
  prefs: []
  type: TYPE_NORMAL
- en: Timsort is added for better performance on already or nearly sorted data. On
    random data timsort is almost identical to mergesort. It is now used for stable
    sort while quicksort is still the default sort if none is chosen. For timsort
    details, refer to [CPython listsort.txt](https://github.com/python/cpython/blob/3.7/Objects/listsort.txt).
    ‘mergesort’ and ‘stable’ are mapped to radix sort for integer data types. Radix
    sort is an O(n) sort instead of O(n log n).
  prefs: []
  type: TYPE_NORMAL
- en: Changed in version 1.18.0.
  prefs: []
  type: TYPE_NORMAL
- en: NaT now sorts to the end of arrays for consistency with NaN.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the *order* keyword to specify a field to use when sorting a structured
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Sort by age, then height if ages are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
