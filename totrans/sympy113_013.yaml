- en: Matrices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/tutorials/intro-tutorial/matrices.html](https://docs.sympy.org/latest/tutorials/intro-tutorial/matrices.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To make a matrix in SymPy, use the `Matrix` object. A matrix is constructed
    by providing a list of row vectors that make up the matrix. For example, to construct
    the matrix
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\left[\begin{array}{cc}1 & -1\\3 & 4\\0 & 2\end{array}\right]\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: use
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To make it easy to make column vectors, a list of elements is considered to
    be a column vector.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Matrices are manipulated just like any other object in SymPy or Python.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: One important thing to note about SymPy matrices is that, unlike every other
    object in SymPy, they are mutable. This means that they can be modified in place,
    as we will see below. The downside to this is that `Matrix` cannot be used in
    places that require immutability, such as inside other SymPy expressions or as
    keys to dictionaries. If you need an immutable version of `Matrix`, use `ImmutableMatrix`.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some basic operations on `Matrix`.
  prefs: []
  type: TYPE_NORMAL
- en: Shape
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get the shape of a matrix, use [`shape()`](../../modules/codegen.html#sympy.codegen.fnodes.shape
    "sympy.codegen.fnodes.shape") function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Accessing Rows and Columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To get an individual row or column of a matrix, use `row` or `col`. For example,
    `M.row(0)` will get the first row. `M.col(-1)` will get the last column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Deleting and Inserting Rows and Columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To delete a row or column, use `row_del` or `col_del`. These operations will
    modify the Matrix **in place**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To insert rows or columns, use `row_insert` or `col_insert`. These operations
    **do not** operate in place.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Unless explicitly stated, the methods mentioned below do not operate in place.
    In general, a method that does not operate in place will return a new `Matrix`
    and a method that does operate in place will return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As noted above, simple operations like addition, multiplication and power are
    done just by using `+`, `*`, and `**`. To find the inverse of a matrix, just raise
    it to the `-1` power.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To take the transpose of a Matrix, use `T`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Matrix Constructors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several constructors exist for creating common matrices. To create an identity
    matrix, use `eye`. `eye(n)` will create an \(n\times n\) identity matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To create a matrix of all zeros, use `zeros`. `zeros(n, m)` creates an \(n\times
    m\) matrix of \(0\)s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, `ones` creates a matrix of ones.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: To create diagonal matrices, use `diag`. The arguments to `diag` can be either
    numbers or matrices. A number is interpreted as a \(1\times 1\) matrix. The matrices
    are stacked diagonally. The remaining elements are filled with \(0\)s.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Advanced Methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Determinant
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To compute the determinant of a matrix, use `det`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: RREF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To put a matrix into reduced row echelon form, use `rref`. `rref` returns a
    tuple of two elements. The first is the reduced row echelon form, and the second
    is a tuple of indices of the pivot columns.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The first element of the tuple returned by `rref` is of type `Matrix`. The second
    is of type `tuple`.
  prefs: []
  type: TYPE_NORMAL
- en: Nullspace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find the nullspace of a matrix, use `nullspace`. `nullspace` returns a `list`
    of column vectors that span the nullspace of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Columnspace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To find the columnspace of a matrix, use `columnspace`. `columnspace` returns
    a `list` of column vectors that span the columnspace of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Eigenvalues, Eigenvectors, and Diagonalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To find the eigenvalues of a matrix, use `eigenvals`. `eigenvals` returns a
    dictionary of `eigenvalue: algebraic_multiplicity` pairs (similar to the output
    of [roots](solvers.html#tutorial-roots)).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This means that `M` has eigenvalues -2, 3, and 5, and that the eigenvalues -2
    and 3 have algebraic multiplicity 1 and that the eigenvalue 5 has algebraic multiplicity
    2.
  prefs: []
  type: TYPE_NORMAL
- en: To find the eigenvectors of a matrix, use `eigenvects`. `eigenvects` returns
    a list of tuples of the form `(eigenvalue, algebraic_multiplicity, [eigenvectors])`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that, for example, the eigenvalue 5 also has geometric multiplicity
    2, because it has two eigenvectors. Because the algebraic and geometric multiplicities
    are the same for all the eigenvalues, `M` is diagonalizable.
  prefs: []
  type: TYPE_NORMAL
- en: To diagonalize a matrix, use `diagonalize`. `diagonalize` returns a tuple \((P,
    D)\), where \(D\) is diagonal and \(M = PDP^{-1}\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that since `eigenvects` also includes the eigenvalues, you should use it
    instead of `eigenvals` if you also want the eigenvectors. However, as computing
    the eigenvectors may often be costly, `eigenvals` should be preferred if you only
    wish to find the eigenvalues.
  prefs: []
  type: TYPE_NORMAL
- en: If all you want is the characteristic polynomial, use `charpoly`. This is more
    efficient than `eigenvals`, because sometimes symbolic roots can be expensive
    to calculate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Possible Issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Zero Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your matrix operations are failing or returning wrong answers, the common
    reasons would likely be from zero testing. If there is an expression not properly
    zero-tested, it can possibly bring issues in finding pivots for gaussian elimination,
    or deciding whether the matrix is inversible, or any high level functions which
    relies on the prior procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the SymPy’s default method of zero testing `_iszero` is only guaranteed
    to be accurate in some limited domain of numerics and symbols, and any complicated
    expressions beyond its decidability are treated as `None`, which behaves similarly
    to logical `False`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of methods using zero testing procedures are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`echelon_form` , `is_echelon` , `rank` , `rref` , `nullspace` , `eigenvects`
    , `inverse_ADJ` , `inverse_GE` , `inverse_LU` , `LUdecomposition` , `LUdecomposition_Simple`
    , `LUsolve`'
  prefs: []
  type: TYPE_NORMAL
- en: They have property `iszerofunc` opened up for user to specify zero testing method,
    which can accept any function with single input and boolean output, while being
    defaulted with `_iszero`.
  prefs: []
  type: TYPE_NORMAL
- en: Here is an example of solving an issue caused by undertested zero. While the
    output for this particular matrix has since been improved, the technique below
    is still of interest. [[1]](#zerotestexampleidea-fn) [[2]](#zerotestexamplediscovery-fn)
    [[3]](#zerotestexampleimproved-fn)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You can trace down which expression is being underevaluated, by injecting a
    custom zero test with warnings enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this case, `(-exp(q) - 2*cosh(q/3))*(-2*cosh(q/3) - exp(-q)) - (4*cosh(q/3)**2
    - 1)**2` should yield zero, but the zero testing had failed to catch. possibly
    meaning that a stronger zero test should be introduced. For this specific example,
    rewriting to exponentials and applying simplify would make zero test stronger
    for hyperbolics, while being harmless to other polynomials or transcendental functions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can clearly see `nullspace` returning proper result, after injecting an
    alternative zero test.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this approach is only valid for some limited cases of matrices containing
    only numerics, hyperbolics, and exponentials. For other matrices, you should use
    different method opted for their domains.
  prefs: []
  type: TYPE_NORMAL
- en: Possible suggestions would be either taking advantage of rewriting and simplifying,
    with tradeoff of speed [[4]](#zerotestsimplifysolution-fn) , or using random numeric
    testing, with tradeoff of accuracy [[5]](#zerotestnumerictestsolution-fn) .
  prefs: []
  type: TYPE_NORMAL
- en: If you wonder why there is no generic algorithm for zero testing that can work
    with any symbolic entities, it’s because of the constant problem stating that
    zero testing is undecidable [[6]](#constantproblemwikilink-fn) , and not only
    the SymPy, but also other computer algebra systems [[7]](#mathematicazero-fn)
    [[8]](#matlabzero-fn) would face the same fundamental issue.
  prefs: []
  type: TYPE_NORMAL
- en: However, discovery of any zero test failings can provide some good examples
    to improve SymPy, so if you have encountered one, you can report the issue to
    SymPy issue tracker [[9]](#sympyissues-fn) to get detailed help from the community.
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
