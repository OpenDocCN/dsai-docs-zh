["```py\nclass sympy.physics.continuum_mechanics.beam.Beam(length, elastic_modulus, second_moment, area=A, variable=x, base_char='C')\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols, Piecewise\n>>> E, I = symbols('E, I')\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(4, E, I)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(6, 2, 0)\n>>> b.apply_load(R2, 4, -1)\n>>> b.bc_deflection = [(0, 0), (4, 0)]\n>>> b.boundary_conditions\n{'deflection': [(0, 0), (4, 0)], 'slope': []}\n>>> b.load\nR1*SingularityFunction(x, 0, -1) + R2*SingularityFunction(x, 4, -1) + 6*SingularityFunction(x, 2, 0)\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.load\n-3*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 2, 0) - 9*SingularityFunction(x, 4, -1)\n>>> b.shear_force()\n3*SingularityFunction(x, 0, 0) - 6*SingularityFunction(x, 2, 1) + 9*SingularityFunction(x, 4, 0)\n>>> b.bending_moment()\n3*SingularityFunction(x, 0, 1) - 3*SingularityFunction(x, 2, 2) + 9*SingularityFunction(x, 4, 1)\n>>> b.slope()\n(-3*SingularityFunction(x, 0, 2)/2 + SingularityFunction(x, 2, 3) - 9*SingularityFunction(x, 4, 2)/2 + 7)/(E*I)\n>>> b.deflection()\n(7*x - SingularityFunction(x, 0, 3)/2 + SingularityFunction(x, 2, 4)/4 - 3*SingularityFunction(x, 4, 3)/2)/(E*I)\n>>> b.deflection().rewrite(Piecewise)\n(7*x - Piecewise((x**3, x >= 0), (0, True))/2\n - 3*Piecewise(((x - 4)**3, x >= 4), (0, True))/2\n + Piecewise(((x - 2)**4, x >= 2), (0, True))/4)/(E*I) \n```", "```py\n>>> E, I = symbols('E, I')\n>>> L = symbols(\"L\", positive=True)\n>>> P1, P2, M1, M2, q1, q2 = symbols(\"P1, P2, M1, M2, q1, q2\")\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(L, E, I)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(R2, L, -1)\n>>> b.apply_load(P1, L/4, -1)\n>>> b.apply_load(-P2, L/8, -1)\n>>> b.apply_load(M1, L/2, -2)\n>>> b.apply_load(-M2, 3*L/4, -2)\n>>> b.apply_load(q1, L/2, 0, 3*L/4)\n>>> b.apply_load(-q2, 3*L/4, 0, L)\n>>> b.bc_deflection = [(0, 0), (L, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> print(b.reaction_loads[R1])\n(-3*L**2*q1 + L**2*q2 - 24*L*P1 + 28*L*P2 - 32*M1 + 32*M2)/(32*L)\n>>> print(b.reaction_loads[R2])\n(-5*L**2*q1 + 7*L**2*q2 - 8*L*P1 + 4*L*P2 + 32*M1 - 32*M2)/(32*L) \n```", "```py\nproperty applied_loads\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> b = Beam(4, E, I)\n>>> b.apply_load(-3, 0, -2)\n>>> b.apply_load(4, 2, -1)\n>>> b.apply_load(5, 2, -1)\n>>> b.load\n-3*SingularityFunction(x, 0, -2) + 9*SingularityFunction(x, 2, -1)\n>>> b.applied_loads\n[(-3, 0, -2, None), (4, 2, -1, None), (5, 2, -1, None)] \n```", "```py\napply_load(value, start, order, end=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> b = Beam(4, E, I)\n>>> b.apply_load(-3, 0, -2)\n>>> b.apply_load(4, 2, -1)\n>>> b.apply_load(-2, 2, 2, end=3)\n>>> b.load\n-3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 2, 2) + 2*SingularityFunction(x, 3, 0) + 4*SingularityFunction(x, 3, 1) + 2*SingularityFunction(x, 3, 2) \n```", "```py\napply_support(loc, type='fixed')\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> b = Beam(20, E, I)\n>>> p0, m0 = b.apply_support(0, 'fixed')\n>>> p1 = b.apply_support(20, 'roller')\n>>> b.apply_load(-8, 10, -1)\n>>> b.apply_load(100, 20, -2)\n>>> b.solve_for_reaction_loads(p0, m0, p1)\n>>> b.reaction_loads\n{M_0: 20, R_0: -2, R_20: 10}\n>>> b.reaction_loads[p0]\n-2\n>>> b.load\n20*SingularityFunction(x, 0, -2) - 2*SingularityFunction(x, 0, -1)\n- 8*SingularityFunction(x, 10, -1) + 100*SingularityFunction(x, 20, -2)\n+ 10*SingularityFunction(x, 20, -1) \n```", "```py\nproperty area\n```", "```py\nbending_moment()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(30, E, I)\n>>> b.apply_load(-8, 0, -1)\n>>> b.apply_load(R1, 10, -1)\n>>> b.apply_load(R2, 30, -1)\n>>> b.apply_load(120, 30, -2)\n>>> b.bc_deflection = [(10, 0), (30, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.bending_moment()\n8*SingularityFunction(x, 0, 1) - 6*SingularityFunction(x, 10, 1) - 120*SingularityFunction(x, 30, 0) - 2*SingularityFunction(x, 30, 1) \n```", "```py\nproperty boundary_conditions\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> b = Beam(4, E, I)\n>>> b.bc_deflection = [(0, 2)]\n>>> b.bc_slope = [(0, 1)]\n>>> b.boundary_conditions\n{'deflection': [(0, 2)], 'slope': [(0, 1)]} \n```", "```py\nproperty cross_section\n```", "```py\ndeflection()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(30, E, I)\n>>> b.apply_load(-8, 0, -1)\n>>> b.apply_load(R1, 10, -1)\n>>> b.apply_load(R2, 30, -1)\n>>> b.apply_load(120, 30, -2)\n>>> b.bc_deflection = [(10, 0), (30, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.deflection()\n(4000*x/3 - 4*SingularityFunction(x, 0, 3)/3 + SingularityFunction(x, 10, 3)\n + 60*SingularityFunction(x, 30, 2) + SingularityFunction(x, 30, 3)/3 - 12000)/(E*I) \n```", "```py\ndraw(pictorial=True)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> P1, P2, M = symbols('P1, P2, M')\n>>> E, I = symbols('E, I')\n>>> b = Beam(50, 20, 30)\n>>> b.apply_load(-10, 2, -1)\n>>> b.apply_load(15, 26, -1)\n>>> b.apply_load(P1, 10, -1)\n>>> b.apply_load(-P2, 40, -1)\n>>> b.apply_load(90, 5, 0, 23)\n>>> b.apply_load(10, 30, 1, 50)\n>>> b.apply_load(M, 15, -2)\n>>> b.apply_load(-M, 30, -2)\n>>> p50 = b.apply_support(50, \"pin\")\n>>> p0, m0 = b.apply_support(0, \"fixed\")\n>>> p20 = b.apply_support(20, \"roller\")\n>>> p = b.draw()  \n>>> p  \nPlot object containing:\n[0]: cartesian line: 25*SingularityFunction(x, 5, 0) - 25*SingularityFunction(x, 23, 0)\n+ SingularityFunction(x, 30, 1) - 20*SingularityFunction(x, 50, 0)\n- SingularityFunction(x, 50, 1) + 5 for x over (0.0, 50.0)\n[1]: cartesian line: 5 for x over (0.0, 50.0)\n...\n>>> p.show() \n```", "```py\nproperty elastic_modulus\n```", "```py\nproperty ild_moment\n```", "```py\nproperty ild_reactions\n```", "```py\nproperty ild_shear\n```", "```py\njoin(beam, via='fixed')\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> R1, R2 = symbols('R1, R2')\n>>> b1 = Beam(2, E, 1.5*I)\n>>> b2 = Beam(2, E, I)\n>>> b = b1.join(b2, \"fixed\")\n>>> b.apply_load(20, 4, -1)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(R2, 0, -2)\n>>> b.bc_slope = [(0, 0)]\n>>> b.bc_deflection = [(0, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.load\n80*SingularityFunction(x, 0, -2) - 20*SingularityFunction(x, 0, -1) + 20*SingularityFunction(x, 4, -1)\n>>> b.slope()\n(-((-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))/I + 120/I)/E + 80.0/(E*I))*SingularityFunction(x, 2, 0)\n- 0.666666666666667*(-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))*SingularityFunction(x, 0, 0)/(E*I)\n+ 0.666666666666667*(-80*SingularityFunction(x, 0, 1) + 10*SingularityFunction(x, 0, 2) - 10*SingularityFunction(x, 4, 2))*SingularityFunction(x, 2, 0)/(E*I) \n```", "```py\nproperty length\n```", "```py\nproperty load\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> b = Beam(4, E, I)\n>>> b.apply_load(-3, 0, -2)\n>>> b.apply_load(4, 2, -1)\n>>> b.apply_load(-2, 3, 2)\n>>> b.load\n-3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 3, 2) \n```", "```py\nmax_bmoment()\n```", "```py\nmax_deflection()\n```", "```py\nmax_shear_force()\n```", "```py\nplot_bending_moment(subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(8, 200*(10**9), 400*(10**-6))\n>>> b.apply_load(5000, 2, -1)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(R2, 8, -1)\n>>> b.apply_load(10000, 4, 0, end=8)\n>>> b.bc_deflection = [(0, 0), (8, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.plot_bending_moment()\nPlot object containing:\n[0]: cartesian line: 13750*SingularityFunction(x, 0, 1) - 5000*SingularityFunction(x, 2, 1)\n- 5000*SingularityFunction(x, 4, 2) + 31250*SingularityFunction(x, 8, 1)\n+ 5000*SingularityFunction(x, 8, 2) for x over (0.0, 8.0) \n```", "```py\nplot_deflection(subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(8, 200*(10**9), 400*(10**-6))\n>>> b.apply_load(5000, 2, -1)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(R2, 8, -1)\n>>> b.apply_load(10000, 4, 0, end=8)\n>>> b.bc_deflection = [(0, 0), (8, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.plot_deflection()\nPlot object containing:\n[0]: cartesian line: 0.00138541666666667*x - 2.86458333333333e-5*SingularityFunction(x, 0, 3)\n+ 1.04166666666667e-5*SingularityFunction(x, 2, 3) + 5.20833333333333e-6*SingularityFunction(x, 4, 4)\n- 6.51041666666667e-5*SingularityFunction(x, 8, 3) - 5.20833333333333e-6*SingularityFunction(x, 8, 4)\nfor x over (0.0, 8.0) \n```", "```py\nplot_ild_moment(subs=None)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> E, I = symbols('E, I')\n>>> R_0, R_8 = symbols('R_0, R_8')\n>>> b = Beam(12, E, I)\n>>> p0 = b.apply_support(0, 'roller')\n>>> p8 = b.apply_support(8, 'roller')\n>>> b.solve_for_ild_reactions(1, R_0, R_8)\n>>> b.solve_for_ild_moment(4, 1, R_0, R_8)\n>>> b.ild_moment\nPiecewise((-x/2, x < 4), (x/2 - 4, x > 4))\n>>> b.plot_ild_moment()\nPlot object containing:\n[0]: cartesian line: Piecewise((-x/2, x < 4), (x/2 - 4, x > 4)) for x over (0.0, 12.0) \n```", "```py\nplot_ild_reactions(subs=None)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> E, I = symbols('E, I')\n>>> R_0, R_7 = symbols('R_0, R_7')\n>>> b = Beam(10, E, I)\n>>> p0 = b.apply_support(0, 'roller')\n>>> p7 = b.apply_support(7, 'roller')\n>>> b.apply_load(5,4,-1)\n>>> b.solve_for_ild_reactions(1,R_0,R_7)\n>>> b.ild_reactions\n{R_0: x/7 - 22/7, R_7: -x/7 - 20/7}\n>>> b.plot_ild_reactions()\nPlotGrid object containing:\nPlot[0]:Plot object containing:\n[0]: cartesian line: x/7 - 22/7 for x over (0.0, 10.0)\nPlot[1]:Plot object containing:\n[0]: cartesian line: -x/7 - 20/7 for x over (0.0, 10.0) \n```", "```py\nplot_ild_shear(subs=None)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> E, I = symbols('E, I')\n>>> R_0, R_8 = symbols('R_0, R_8')\n>>> b = Beam(12, E, I)\n>>> p0 = b.apply_support(0, 'roller')\n>>> p8 = b.apply_support(8, 'roller')\n>>> b.solve_for_ild_reactions(1, R_0, R_8)\n>>> b.solve_for_ild_shear(4, 1, R_0, R_8)\n>>> b.ild_shear\nPiecewise((x/8, x < 4), (x/8 - 1, x > 4))\n>>> b.plot_ild_shear()\nPlot object containing:\n[0]: cartesian line: Piecewise((x/8, x < 4), (x/8 - 1, x > 4)) for x over (0.0, 12.0) \n```", "```py\nplot_loading_results(subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(8, 200*(10**9), 400*(10**-6))\n>>> b.apply_load(5000, 2, -1)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(R2, 8, -1)\n>>> b.apply_load(10000, 4, 0, end=8)\n>>> b.bc_deflection = [(0, 0), (8, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> axes = b.plot_loading_results() \n```", "```py\nplot_shear_force(subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(8, 200*(10**9), 400*(10**-6))\n>>> b.apply_load(5000, 2, -1)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(R2, 8, -1)\n>>> b.apply_load(10000, 4, 0, end=8)\n>>> b.bc_deflection = [(0, 0), (8, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.plot_shear_force()\nPlot object containing:\n[0]: cartesian line: 13750*SingularityFunction(x, 0, 0) - 5000*SingularityFunction(x, 2, 0)\n- 10000*SingularityFunction(x, 4, 1) + 31250*SingularityFunction(x, 8, 0)\n+ 10000*SingularityFunction(x, 8, 1) for x over (0.0, 8.0) \n```", "```py\nplot_shear_stress(subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(8, 200*(10**9), 400*(10**-6), 2)\n>>> b.apply_load(5000, 2, -1)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(R2, 8, -1)\n>>> b.apply_load(10000, 4, 0, end=8)\n>>> b.bc_deflection = [(0, 0), (8, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.plot_shear_stress()\nPlot object containing:\n[0]: cartesian line: 6875*SingularityFunction(x, 0, 0) - 2500*SingularityFunction(x, 2, 0)\n- 5000*SingularityFunction(x, 4, 1) + 15625*SingularityFunction(x, 8, 0)\n+ 5000*SingularityFunction(x, 8, 1) for x over (0.0, 8.0) \n```", "```py\nplot_slope(subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(8, 200*(10**9), 400*(10**-6))\n>>> b.apply_load(5000, 2, -1)\n>>> b.apply_load(R1, 0, -1)\n>>> b.apply_load(R2, 8, -1)\n>>> b.apply_load(10000, 4, 0, end=8)\n>>> b.bc_deflection = [(0, 0), (8, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.plot_slope()\nPlot object containing:\n[0]: cartesian line: -8.59375e-5*SingularityFunction(x, 0, 2) + 3.125e-5*SingularityFunction(x, 2, 2)\n+ 2.08333333333333e-5*SingularityFunction(x, 4, 3) - 0.0001953125*SingularityFunction(x, 8, 2)\n- 2.08333333333333e-5*SingularityFunction(x, 8, 3) + 0.00138541666666667 for x over (0.0, 8.0) \n```", "```py\npoint_cflexure()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> b = Beam(10, E, I)\n>>> b.apply_load(-4, 0, -1)\n>>> b.apply_load(-46, 6, -1)\n>>> b.apply_load(10, 2, -1)\n>>> b.apply_load(20, 4, -1)\n>>> b.apply_load(3, 6, 0)\n>>> b.point_cflexure()\n[10/3] \n```", "```py\nproperty reaction_loads\n```", "```py\nremove_load(value, start, order, end=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> b = Beam(4, E, I)\n>>> b.apply_load(-3, 0, -2)\n>>> b.apply_load(4, 2, -1)\n>>> b.apply_load(-2, 2, 2, end=3)\n>>> b.load\n-3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) - 2*SingularityFunction(x, 2, 2) + 2*SingularityFunction(x, 3, 0) + 4*SingularityFunction(x, 3, 1) + 2*SingularityFunction(x, 3, 2)\n>>> b.remove_load(-2, 2, 2, end = 3)\n>>> b.load\n-3*SingularityFunction(x, 0, -2) + 4*SingularityFunction(x, 2, -1) \n```", "```py\nproperty second_moment\n```", "```py\nshear_force()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(30, E, I)\n>>> b.apply_load(-8, 0, -1)\n>>> b.apply_load(R1, 10, -1)\n>>> b.apply_load(R2, 30, -1)\n>>> b.apply_load(120, 30, -2)\n>>> b.bc_deflection = [(10, 0), (30, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.shear_force()\n8*SingularityFunction(x, 0, 0) - 6*SingularityFunction(x, 10, 0) - 120*SingularityFunction(x, 30, -1) - 2*SingularityFunction(x, 30, 0) \n```", "```py\nshear_stress()\n```", "```py\nslope()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(30, E, I)\n>>> b.apply_load(-8, 0, -1)\n>>> b.apply_load(R1, 10, -1)\n>>> b.apply_load(R2, 30, -1)\n>>> b.apply_load(120, 30, -2)\n>>> b.bc_deflection = [(10, 0), (30, 0)]\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.slope()\n(-4*SingularityFunction(x, 0, 2) + 3*SingularityFunction(x, 10, 2)\n + 120*SingularityFunction(x, 30, 1) + SingularityFunction(x, 30, 2) + 4000/3)/(E*I) \n```", "```py\nsolve_for_ild_moment(distance, value, *reactions)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> E, I = symbols('E, I')\n>>> R_0, R_8 = symbols('R_0, R_8')\n>>> b = Beam(12, E, I)\n>>> p0 = b.apply_support(0, 'roller')\n>>> p8 = b.apply_support(8, 'roller')\n>>> b.solve_for_ild_reactions(1, R_0, R_8)\n>>> b.solve_for_ild_moment(4, 1, R_0, R_8)\n>>> b.ild_moment\nPiecewise((-x/2, x < 4), (x/2 - 4, x > 4)) \n```", "```py\nsolve_for_ild_reactions(value, *reactions)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> E, I = symbols('E, I')\n>>> R_0, R_10 = symbols('R_0, R_10')\n>>> b = Beam(10, E, I)\n>>> p0 = b.apply_support(0, 'roller')\n>>> p10 = b.apply_support(10, 'roller')\n>>> b.solve_for_ild_reactions(1,R_0,R_10)\n>>> b.ild_reactions\n{R_0: x/10 - 1, R_10: -x/10} \n```", "```py\nsolve_for_ild_shear(distance, value, *reactions)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> E, I = symbols('E, I')\n>>> R_0, R_8 = symbols('R_0, R_8')\n>>> b = Beam(12, E, I)\n>>> p0 = b.apply_support(0, 'roller')\n>>> p8 = b.apply_support(8, 'roller')\n>>> b.solve_for_ild_reactions(1, R_0, R_8)\n>>> b.solve_for_ild_shear(4, 1, R_0, R_8)\n>>> b.ild_shear\nPiecewise((x/8, x < 4), (x/8 - 1, x > 4)) \n```", "```py\nsolve_for_reaction_loads(*reactions)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I = symbols('E, I')\n>>> R1, R2 = symbols('R1, R2')\n>>> b = Beam(30, E, I)\n>>> b.apply_load(-8, 0, -1)\n>>> b.apply_load(R1, 10, -1)  # Reaction force at x = 10\n>>> b.apply_load(R2, 30, -1)  # Reaction force at x = 30\n>>> b.apply_load(120, 30, -2)\n>>> b.bc_deflection = [(10, 0), (30, 0)]\n>>> b.load\nR1*SingularityFunction(x, 10, -1) + R2*SingularityFunction(x, 30, -1)\n - 8*SingularityFunction(x, 0, -1) + 120*SingularityFunction(x, 30, -2)\n>>> b.solve_for_reaction_loads(R1, R2)\n>>> b.reaction_loads\n{R1: 6, R2: 2}\n>>> b.load\n-8*SingularityFunction(x, 0, -1) + 6*SingularityFunction(x, 10, -1)\n + 120*SingularityFunction(x, 30, -2) + 2*SingularityFunction(x, 30, -1) \n```", "```py\nproperty variable\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam\n>>> from sympy import symbols\n>>> E, I, A = symbols('E, I, A')\n>>> x, y, z = symbols('x, y, z')\n>>> b = Beam(4, E, I)\n>>> b.variable\nx\n>>> b.variable = y\n>>> b.variable\ny\n>>> b = Beam(4, E, I, A, z)\n>>> b.variable\nz \n```", "```py\nclass sympy.physics.continuum_mechanics.beam.Beam3D(length, elastic_modulus, shear_modulus, second_moment, area, variable=x)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols, simplify, collect, factor\n>>> l, E, G, I, A = symbols('l, E, G, I, A')\n>>> b = Beam3D(l, E, G, I, A)\n>>> x, q, m = symbols('x, q, m')\n>>> b.apply_load(q, 0, 0, dir=\"y\")\n>>> b.apply_moment_load(m, 0, -1, dir=\"z\")\n>>> b.shear_force()\n[0, -q*x, 0]\n>>> b.bending_moment()\n[0, 0, -m*x + q*x**2/2]\n>>> b.bc_slope = [(0, [0, 0, 0]), (l, [0, 0, 0])]\n>>> b.bc_deflection = [(0, [0, 0, 0]), (l, [0, 0, 0])]\n>>> b.solve_slope_deflection()\n>>> factor(b.slope())\n[0, 0, x*(-l + x)*(-A*G*l**3*q + 2*A*G*l**2*q*x - 12*E*I*l*q\n - 72*E*I*m + 24*E*I*q*x)/(12*E*I*(A*G*l**2 + 12*E*I))]\n>>> dx, dy, dz = b.deflection()\n>>> dy = collect(simplify(dy), x)\n>>> dx == dz == 0\nTrue\n>>> dy == (x*(12*E*I*l*(A*G*l**2*q - 2*A*G*l*m + 12*E*I*q)\n... + x*(A*G*l*(3*l*(A*G*l**2*q - 2*A*G*l*m + 12*E*I*q) + x*(-2*A*G*l**2*q + 4*A*G*l*m - 24*E*I*q))\n... + A*G*(A*G*l**2 + 12*E*I)*(-2*l**2*q + 6*l*m - 4*m*x + q*x**2)\n... - 12*E*I*q*(A*G*l**2 + 12*E*I)))/(24*A*E*G*I*(A*G*l**2 + 12*E*I)))\nTrue \n```", "```py\nangular_deflection()\n```", "```py\napply_load(value, start, order, dir='y')\n```", "```py\napply_moment_load(value, start, order, dir='y')\n```", "```py\nproperty area\n```", "```py\naxial_force()\n```", "```py\naxial_stress()\n```", "```py\nbending_moment()\n```", "```py\nproperty boundary_conditions\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(30, E, G, I, A, x)\n>>> b.bc_slope = [(0, (4, 0, 0))]\n>>> b.bc_deflection = [(4, [0, 0, 0])]\n>>> b.boundary_conditions\n{'deflection': [(4, [0, 0, 0])], 'slope': [(0, (4, 0, 0))]} \n```", "```py\ndeflection()\n```", "```py\nproperty load_vector\n```", "```py\nmax_bending_moment()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, 40, 21, 100, 25, x)\n>>> b.apply_load(15, start=0, order=0, dir=\"z\")\n>>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.max_bending_moment()\n[(0, 0), (20, 3000), (20, 16000)] \n```", "```py\nmax_bmoment()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, 40, 21, 100, 25, x)\n>>> b.apply_load(15, start=0, order=0, dir=\"z\")\n>>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.max_bending_moment()\n[(0, 0), (20, 3000), (20, 16000)] \n```", "```py\nmax_deflection()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, 40, 21, 100, 25, x)\n>>> b.apply_load(15, start=0, order=0, dir=\"z\")\n>>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.solve_slope_deflection()\n>>> b.max_deflection()\n[(0, 0), (10, 495/14), (-10 + 10*sqrt(10793)/43, (10 - 10*sqrt(10793)/43)**3/160 - 20/7 + (10 - 10*sqrt(10793)/43)**4/6400 + 20*sqrt(10793)/301 + 27*(10 - 10*sqrt(10793)/43)**2/560)] \n```", "```py\nmax_shear_force()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, 40, 21, 100, 25, x)\n>>> b.apply_load(15, start=0, order=0, dir=\"z\")\n>>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.max_shear_force()\n[(0, 0), (20, 2400), (20, 300)] \n```", "```py\nproperty moment_load_vector\n```", "```py\nplot_bending_moment(dir='all', subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, E, G, I, A, x)\n>>> b.apply_load(15, start=0, order=0, dir=\"z\")\n>>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.plot_bending_moment()\nPlotGrid object containing:\nPlot[0]:Plot object containing:\n[0]: cartesian line: 0 for x over (0.0, 20.0)\nPlot[1]:Plot object containing:\n[0]: cartesian line: -15*x**2/2 for x over (0.0, 20.0)\nPlot[2]:Plot object containing:\n[0]: cartesian line: 2*x**3 for x over (0.0, 20.0) \n```", "```py\nplot_deflection(dir='all', subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, 40, 21, 100, 25, x)\n>>> b.apply_load(15, start=0, order=0, dir=\"z\")\n>>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.solve_slope_deflection()\n>>> b.plot_deflection()\nPlotGrid object containing:\nPlot[0]:Plot object containing:\n[0]: cartesian line: 0 for x over (0.0, 20.0)\nPlot[1]:Plot object containing:\n[0]: cartesian line: x**5/40000 - 4013*x**3/90300 + 26*x**2/43 + 1520*x/903 for x over (0.0, 20.0)\nPlot[2]:Plot object containing:\n[0]: cartesian line: x**4/6400 - x**3/160 + 27*x**2/560 + 2*x/7 for x over (0.0, 20.0) \n```", "```py\nplot_loading_results(dir='x', subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, E, G, I, A, x)\n>>> subs = {E:40, G:21, I:100, A:25}\n>>> b.apply_load(15, start=0, order=0, dir=\"z\")\n>>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.solve_slope_deflection()\n>>> b.plot_loading_results('y',subs)\nPlotGrid object containing:\nPlot[0]:Plot object containing:\n[0]: cartesian line: -6*x**2 for x over (0.0, 20.0)\nPlot[1]:Plot object containing:\n[0]: cartesian line: -15*x**2/2 for x over (0.0, 20.0)\nPlot[2]:Plot object containing:\n[0]: cartesian line: -x**3/1600 + 3*x**2/160 - x/8 for x over (0.0, 20.0)\nPlot[3]:Plot object containing:\n[0]: cartesian line: x**5/40000 - 4013*x**3/90300 + 26*x**2/43 + 1520*x/903 for x over (0.0, 20.0) \n```", "```py\nplot_shear_force(dir='all', subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, E, G, I, A, x)\n>>> b.apply_load(15, start=0, order=0, dir=\"z\")\n>>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.plot_shear_force()\nPlotGrid object containing:\nPlot[0]:Plot object containing:\n[0]: cartesian line: 0 for x over (0.0, 20.0)\nPlot[1]:Plot object containing:\n[0]: cartesian line: -6*x**2 for x over (0.0, 20.0)\nPlot[2]:Plot object containing:\n[0]: cartesian line: -15*x for x over (0.0, 20.0) \n```", "```py\nplot_shear_stress(dir='all', subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, E, G, I, 2, x)\n>>> b.apply_load(15, start=0, order=0, dir=\"z\")\n>>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.plot_shear_stress()\nPlotGrid object containing:\nPlot[0]:Plot object containing:\n[0]: cartesian line: 0 for x over (0.0, 20.0)\nPlot[1]:Plot object containing:\n[0]: cartesian line: -3*x**2 for x over (0.0, 20.0)\nPlot[2]:Plot object containing:\n[0]: cartesian line: -15*x/2 for x over (0.0, 20.0) \n```", "```py\nplot_slope(dir='all', subs=None)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, 40, 21, 100, 25, x)\n>>> b.apply_load(15, start=0, order=0, dir=\"z\")\n>>> b.apply_load(12*x, start=0, order=0, dir=\"y\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (20, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R2, start=20, order=-1, dir=\"z\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R4, start=20, order=-1, dir=\"y\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.solve_slope_deflection()\n>>> b.plot_slope()\nPlotGrid object containing:\nPlot[0]:Plot object containing:\n[0]: cartesian line: 0 for x over (0.0, 20.0)\nPlot[1]:Plot object containing:\n[0]: cartesian line: -x**3/1600 + 3*x**2/160 - x/8 for x over (0.0, 20.0)\nPlot[2]:Plot object containing:\n[0]: cartesian line: x**4/8000 - 19*x**2/172 + 52*x/43 for x over (0.0, 20.0) \n```", "```py\npolar_moment()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A = symbols('l, E, G, I, A')\n>>> b = Beam3D(l, E, G, I, A)\n>>> b.polar_moment()\n2*I\n>>> I1 = [9, 15]\n>>> b = Beam3D(l, E, G, I1, A)\n>>> b.polar_moment()\n24 \n```", "```py\nproperty second_moment\n```", "```py\nshear_force()\n```", "```py\nproperty shear_modulus\n```", "```py\nshear_stress()\n```", "```py\nslope()\n```", "```py\nsolve_for_reaction_loads(*reaction)\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(30, E, G, I, A, x)\n>>> b.apply_load(8, start=0, order=0, dir=\"y\")\n>>> b.apply_load(9*x, start=0, order=0, dir=\"z\")\n>>> b.bc_deflection = [(0, [0, 0, 0]), (30, [0, 0, 0])]\n>>> R1, R2, R3, R4 = symbols('R1, R2, R3, R4')\n>>> b.apply_load(R1, start=0, order=-1, dir=\"y\")\n>>> b.apply_load(R2, start=30, order=-1, dir=\"y\")\n>>> b.apply_load(R3, start=0, order=-1, dir=\"z\")\n>>> b.apply_load(R4, start=30, order=-1, dir=\"z\")\n>>> b.solve_for_reaction_loads(R1, R2, R3, R4)\n>>> b.reaction_loads\n{R1: -120, R2: -120, R3: -1350, R4: -2700} \n```", "```py\nsolve_for_torsion()\n```", "```py\n>>> from sympy.physics.continuum_mechanics.beam import Beam3D\n>>> from sympy import symbols\n>>> l, E, G, I, A, x = symbols('l, E, G, I, A, x')\n>>> b = Beam3D(20, E, G, I, A, x)\n>>> b.apply_moment_load(4, 4, -2, dir='x')\n>>> b.apply_moment_load(4, 8, -2, dir='x')\n>>> b.apply_moment_load(4, 8, -2, dir='x')\n>>> b.solve_for_torsion()\n>>> b.angular_deflection().subs(x, 3)\n18/(G*I) \n```", "```py\ntorsional_moment()\n```"]