["```py\n>>> from sympy import Matrix\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = Matrix([\n... [1, 2],\n... [3, 4]])\n>>> A\nMatrix([\n[1, 2],\n[3, 4]]) \n```", "```py\nsympy.polys.matrices.domainmatrix.DM(rows, domain)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> DM([[1, 2], [3, 4]], ZZ)\nDomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ) \n```", "```py\nclass sympy.polys.matrices.domainmatrix.DomainMatrix(rows, shape, domain, *, fmt=None)\n```", "```py\n>>> from sympy import Matrix\n>>> from sympy.polys.matrices import DomainMatrix\n>>> Matrix1 = Matrix([\n...    [1, 2],\n...    [3, 4]])\n>>> A = DomainMatrix.from_Matrix(Matrix1)\n>>> A\nDomainMatrix({0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}}, (2, 2), ZZ) \n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> A\nDomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ) \n```", "```py\nadd(B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> B = DomainMatrix([\n...    [ZZ(4), ZZ(3)],\n...    [ZZ(2), ZZ(1)]], (2, 2), ZZ) \n```", "```py\n>>> A.add(B)\nDomainMatrix([[5, 5], [5, 5]], (2, 2), ZZ) \n```", "```py\nadj_det()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([\n...     [ZZ(1), ZZ(2)],\n...     [ZZ(3), ZZ(4)]], ZZ)\n>>> adjA, detA = A.adj_det()\n>>> adjA\nDomainMatrix([[4, -2], [-3, 1]], (2, 2), ZZ)\n>>> detA\n-2 \n```", "```py\nadj_poly_det(cp=None)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)\n>>> p, detA = A.adj_poly_det()\n>>> p\n[-1, 5]\n>>> p_A = A.eval_poly(p)\n>>> p_A\nDomainMatrix([[4, -2], [-3, 1]], (2, 2), QQ)\n>>> p[0]*A**1 + p[1]*A**0 == p_A\nTrue\n>>> p_A == A.adjugate()\nTrue\n>>> A * A.adjugate() == detA * A.eye(A.shape, A.domain).to_dense()\nTrue \n```", "```py\nadjugate()\n```", "```py\nadj(A) = det(A) * A.inv() \n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)\n>>> A.adjugate()\nDomainMatrix([[4, -2], [-3, 1]], (2, 2), ZZ) \n```", "```py\ncancel_denom(denom)\n```", "```py\n>>> from sympy.polys.matrices import DM\n>>> from sympy import ZZ\n>>> M = DM([[2, 2, 0],\n...         [0, 2, 2],\n...         [0, 0, 2]], ZZ)\n>>> Minv, den = M.inv_den()\n>>> Minv.to_Matrix()\nMatrix([\n[1, -1,  1],\n[0,  1, -1],\n[0,  0,  1]])\n>>> den\n2\n>>> Minv_reduced, den_reduced = Minv.cancel_denom(den)\n>>> Minv_reduced.to_Matrix()\nMatrix([\n[1, -1,  1],\n[0,  1, -1],\n[0,  0,  1]])\n>>> den_reduced\n2\n>>> Minv_reduced.to_field() / den_reduced == Minv.to_field() / den\nTrue \n```", "```py\n>>> M = DM([[2, 2, 0]], ZZ)\n>>> den = ZZ(-4)\n>>> M.cancel_denom(den)\n(DomainMatrix([[-1, -1, 0]], (1, 3), ZZ), 2) \n```", "```py\n>>> M = DM([[4, 6]], ZZ)\n>>> den = ZZ(12)\n>>> M.cancel_denom(den)\n(DomainMatrix([[2, 3]], (1, 2), ZZ), 6)\n>>> numers, denoms = M.cancel_denom_elementwise(den)\n>>> numers\nDomainMatrix([[1, 1]], (1, 2), ZZ)\n>>> denoms\nDomainMatrix([[3, 2]], (1, 2), ZZ)\n>>> M.to_field() / den\nDomainMatrix([[1/3, 1/2]], (1, 2), QQ) \n```", "```py\ncancel_denom_elementwise(denom)\n```", "```py\n>>> from sympy.polys.matrices import DM\n>>> from sympy import ZZ\n>>> M = DM([[2, 3], [4, 12]], ZZ)\n>>> denom = ZZ(6)\n>>> numers, denoms = M.cancel_denom_elementwise(denom)\n>>> numers.to_Matrix()\nMatrix([\n[1, 1],\n[2, 2]])\n>>> denoms.to_Matrix()\nMatrix([\n[3, 2],\n[3, 1]])\n>>> M_frac = (M.to_field() / denom).to_Matrix()\n>>> M_frac\nMatrix([\n[1/3, 1/2],\n[2/3,   2]])\n>>> denoms_inverted = denoms.to_Matrix().applyfunc(lambda e: 1/e)\n>>> numers.to_Matrix().multiply_elementwise(denoms_inverted) == M_frac\nTrue \n```", "```py\ncharpoly()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ) \n```", "```py\n>>> A.charpoly()\n[1, -5, -2] \n```", "```py\ncharpoly_base()\n```", "```py\ncharpoly_berk()\n```", "```py\n>>> from sympy.polys.matrices import DM\n>>> from sympy import QQ\n>>> M = DM([[6, -1, 0, 0],\n...         [9, 12, 0, 0],\n...         [0,  0, 1, 2],\n...         [0,  0, 5, 6]], QQ)\n>>> M.charpoly_berk()\n[1, -25, 203, -495, -324] \n```", "```py\ncharpoly_factor_blocks()\n```", "```py\n>>> from sympy.polys.matrices import DM\n>>> from sympy import ZZ\n>>> M = DM([[6, -1, 0, 0],\n...         [9, 12, 0, 0],\n...         [0,  0, 1, 2],\n...         [0,  0, 5, 6]], ZZ) \n```", "```py\n>>> M.charpoly_factor_blocks()\n[([1, -18, 81], 1), ([1, -7, -4], 1)] \n```", "```py\n>>> DM([[6, -1], [9, 12]], ZZ).charpoly()\n[1, -18, 81]\n>>> DM([[1, 2], [5, 6]], ZZ).charpoly()\n[1, -7, -4] \n```", "```py\n>>> M.charpoly_factor_list()\n[([1, -9], 2), ([1, -7, -4], 1)] \n```", "```py\n>>> M.charpoly()\n[1, -25, 203, -495, -324] \n```", "```py\ncharpoly_factor_list()\n```", "```py\n>>> from sympy.polys.matrices import DM\n>>> from sympy import ZZ\n>>> M = DM([[6, -1, 0, 0],\n...         [9, 12, 0, 0],\n...         [0,  0, 1, 2],\n...         [0,  0, 5, 6]], ZZ) \n```", "```py\n>>> M.charpoly_factor_list()\n[([1, -9], 2), ([1, -7, -4], 1)] \n```", "```py\n>>> M.charpoly()\n[1, -25, 203, -495, -324] \n```", "```py\n>>> M.to_Matrix().charpoly().as_expr()\nlambda**4 - 25*lambda**3 + 203*lambda**2 - 495*lambda - 324\n>>> M.to_Matrix().charpoly().as_expr().factor()\n(lambda - 9)**2*(lambda**2 - 7*lambda - 4) \n```", "```py\nchoose_domain(**opts)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> M = DM([[1, 2], [3, 4]], ZZ)\n>>> M\nDomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n>>> M.choose_domain(field=True)\nDomainMatrix([[1, 2], [3, 4]], (2, 2), QQ) \n```", "```py\n>>> from sympy.abc import x\n>>> M = DM([[1, x], [x**2, x**3]], ZZ[x])\n>>> M.choose_domain(field=True).domain\nZZ(x) \n```", "```py\nclear_denoms(convert=False)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[(1,2), (1,3)], [(1,4), (1,5)]], QQ)\n>>> den, Anum = A.clear_denoms()\n>>> den.to_sympy()\n60\n>>> Anum.to_Matrix()\nMatrix([\n[30, 20],\n[15, 12]])\n>>> den * A == Anum\nTrue \n```", "```py\n>>> A.clear_denoms()[1].domain\nQQ\n>>> A.clear_denoms(convert=True)[1].domain\nZZ \n```", "```py\n>>> A.clear_denoms()[0].domain\nZZ\n>>> A.domain.get_ring()\nZZ \n```", "```py\nclear_denoms_rowwise(convert=False)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[(1,2), (1,3), (1,4)], [(1,5), (1,6), (1,7)]], QQ)\n>>> den, Anum = A.clear_denoms_rowwise()\n>>> den.to_Matrix()\nMatrix([\n[12,   0],\n[ 0, 210]])\n>>> Anum.to_Matrix()\nMatrix([\n[ 6,  4,  3],\n[42, 35, 30]]) \n```", "```py\n>>> den * A == Anum\nTrue\n>>> A == den.to_field().inv() * Anum\nTrue \n```", "```py\n>>> A.clear_denoms_rowwise()[1].domain\nQQ\n>>> A.clear_denoms_rowwise(convert=True)[1].domain\nZZ \n```", "```py\n>>> A.clear_denoms_rowwise()[0].domain\nZZ \n```", "```py\ncolumnspace()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [QQ(1), QQ(-1)],\n...    [QQ(2), QQ(-2)]], (2, 2), QQ)\n>>> A.columnspace()\nDomainMatrix([[1], [2]], (2, 1), QQ) \n```", "```py\ncontent()\n```", "```py\n>>> from sympy.polys.matrices import DM\n>>> from sympy import ZZ\n>>> M = DM([[2, 4], [4, 12]], ZZ)\n>>> M.content()\n2 \n```", "```py\nconvert_to(K)\n```", "```py\n>>> from sympy import ZZ, ZZ_I\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ) \n```", "```py\n>>> A.convert_to(ZZ_I)\nDomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ_I) \n```", "```py\ndet()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ) \n```", "```py\n>>> A.det()\n-2 \n```", "```py\nclassmethod diag(diagonal, domain, shape=None)\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import ZZ\n>>> DomainMatrix.diag([ZZ(5), ZZ(6)], ZZ)\nDomainMatrix({0: {0: 5}, 1: {1: 6}}, (2, 2), ZZ) \n```", "```py\ndiagonal()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> M = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)\n>>> M.diagonal()\n[1, 4] \n```", "```py\neval_poly(p)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)\n>>> p = [QQ(1), QQ(2), QQ(3)]\n>>> p_A = A.eval_poly(p)\n>>> p_A\nDomainMatrix([[12, 14], [21, 33]], (2, 2), QQ)\n>>> p_A == p[0]*A**2 + p[1]*A + p[2]*A**0\nTrue \n```", "```py\neval_poly_mul(p, B)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[QQ(1), QQ(2)], [QQ(3), QQ(4)]], QQ)\n>>> b = DM([[QQ(5)], [QQ(6)]], QQ)\n>>> p = [QQ(1), QQ(2), QQ(3)]\n>>> p_A_b = A.eval_poly_mul(p, b)\n>>> p_A_b\nDomainMatrix([[144], [303]], (2, 1), QQ)\n>>> p_A_b == p[0]*A**2*b + p[1]*A*b + p[2]*b\nTrue\n>>> A.eval_poly_mul(p, b) == A.eval_poly(p)*b\nTrue \n```", "```py\nclassmethod eye(shape, domain)\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import QQ\n>>> DomainMatrix.eye(3, QQ)\nDomainMatrix({0: {0: 1}, 1: {1: 1}, 2: {2: 1}}, (3, 3), QQ) \n```", "```py\nclassmethod from_Matrix(M, fmt='sparse', **kwargs)\n```", "```py\n>>> from sympy import Matrix\n>>> from sympy.polys.matrices import DomainMatrix\n>>> M = Matrix([\n...    [1.0, 3.4],\n...    [2.4, 1]])\n>>> A = DomainMatrix.from_Matrix(M)\n>>> A\nDomainMatrix({0: {0: 1.0, 1: 3.4}, 1: {0: 2.4, 1: 1.0}}, (2, 2), RR) \n```", "```py\nclassmethod from_dict_sympy(nrows, ncols, elemsdict, **kwargs)\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy.abc import x,y,z\n>>> elemsdict = {0: {0:x}, 1:{1: y}, 2: {2: z}}\n>>> A = DomainMatrix.from_dict_sympy(3, 3, elemsdict)\n>>> A\nDomainMatrix({0: {0: x}, 1: {1: y}, 2: {2: z}}, (3, 3), ZZ[x,y,z]) \n```", "```py\nclassmethod from_dod(dod, shape, domain)\n```", "```py\nfrom_dod_like(dod, domain=None)\n```", "```py\nclassmethod from_dok(dok, shape, domain)\n```", "```py\nfrom_flat_nz(elements, data, domain)\n```", "```py\nclassmethod from_list(rows, domain)\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import FF, QQ, ZZ\n>>> A = DomainMatrix.from_list([[1, 0, 1], [0, 0, 1]], ZZ)\n>>> A\nDomainMatrix([[1, 0, 1], [0, 0, 1]], (2, 3), ZZ)\n>>> B = DomainMatrix.from_list([[1, 0, 1], [0, 0, 1]], FF(7))\n>>> B\nDomainMatrix([[1 mod 7, 0 mod 7, 1 mod 7], [0 mod 7, 0 mod 7, 1 mod 7]], (2, 3), GF(7))\n>>> C = DomainMatrix.from_list([[(1, 2), (3, 1)], [(1, 4), (5, 1)]], QQ)\n>>> C\nDomainMatrix([[1/2, 3], [1/4, 5]], (2, 2), QQ) \n```", "```py\nclassmethod from_list_flat(elements, shape, domain)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> element_list = [ZZ(1), ZZ(2), ZZ(3), ZZ(4)]\n>>> A = DomainMatrix.from_list_flat(element_list, (2, 2), ZZ)\n>>> A\nDomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ)\n>>> A == A.from_list_flat(A.to_list_flat(), A.shape, A.domain)\nTrue \n```", "```py\nclassmethod from_list_sympy(nrows, ncols, rows, **kwargs)\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy.abc import x, y, z\n>>> A = DomainMatrix.from_list_sympy(1, 3, [[x, y, z]])\n>>> A\nDomainMatrix([[x, y, z]], (1, 3), ZZ[x,y,z]) \n```", "```py\nclassmethod from_rep(rep)\n```", "```py\n>>> from sympy.polys.domains import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy.polys.matrices.ddm import DDM\n>>> drep = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> dM = DomainMatrix.from_rep(drep)\n>>> dM\nDomainMatrix([[1, 2], [3, 4]], (2, 2), ZZ) \n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import ZZ\n>>> drep = SDM({0:{1:ZZ(1)},1:{0:ZZ(2)}}, (2, 2), ZZ)\n>>> dM = DomainMatrix.from_rep(drep)\n>>> dM\nDomainMatrix({0: {1: 1}, 1: {0: 2}}, (2, 2), ZZ) \n```", "```py\nhstack(*B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix \n```", "```py\n>>> A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> B = DomainMatrix([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)\n>>> A.hstack(B)\nDomainMatrix([[1, 2, 5, 6], [3, 4, 7, 8]], (2, 4), ZZ) \n```", "```py\n>>> C = DomainMatrix([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)\n>>> A.hstack(B, C)\nDomainMatrix([[1, 2, 5, 6, 9, 10], [3, 4, 7, 8, 11, 12]], (2, 6), ZZ) \n```", "```py\ninv()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...     [QQ(2), QQ(-1), QQ(0)],\n...     [QQ(-1), QQ(2), QQ(-1)],\n...     [QQ(0), QQ(0), QQ(2)]], (3, 3), QQ)\n>>> A.inv()\nDomainMatrix([[2/3, 1/3, 1/6], [1/3, 2/3, 1/3], [0, 0, 1/2]], (3, 3), QQ) \n```", "```py\ninv_den(method=None)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...     [ZZ(2), ZZ(-1), ZZ(0)],\n...     [ZZ(-1), ZZ(2), ZZ(-1)],\n...     [ZZ(0), ZZ(0), ZZ(2)]], (3, 3), ZZ)\n>>> Ainv, den = A.inv_den()\n>>> den\n6\n>>> Ainv\nDomainMatrix([[4, 2, 1], [2, 4, 2], [0, 0, 3]], (3, 3), ZZ)\n>>> A * Ainv == den * A.eye(A.shape, A.domain).to_dense()\nTrue \n```", "```py\nproperty is_diagonal\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> M = DM([[ZZ(1), ZZ(0)], [ZZ(0), ZZ(1)]], ZZ)\n>>> M.is_diagonal\nTrue \n```", "```py\nproperty is_lower\n```", "```py\nproperty is_square\n```", "```py\nproperty is_upper\n```", "```py\niter_items()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([[ZZ(1), ZZ(0)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> list(A.iter_items())\n[((0, 0), 1), ((1, 0), 3), ((1, 1), 4)] \n```", "```py\niter_values()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([[ZZ(1), ZZ(0)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> list(A.iter_values())\n[1, 3, 4] \n```", "```py\nlll(delta=MPQ(3, 4))\n```", "```py\n>>> from sympy.polys.domains import ZZ, QQ\n>>> from sympy.polys.matrices import DM\n>>> x = DM([[1, 0, 0, 0, -20160],\n...         [0, 1, 0, 0, 33768],\n...         [0, 0, 1, 0, 39578],\n...         [0, 0, 0, 1, 47757]], ZZ)\n>>> y = DM([[10, -3, -2, 8, -4],\n...         [3, -9, 8, 1, -11],\n...         [-3, 13, -9, -3, -9],\n...         [-12, -7, -11, 9, -1]], ZZ)\n>>> assert x.lll(delta=QQ(5, 6)) == y \n```", "```py\nlll_transform(delta=MPQ(3, 4))\n```", "```py\n>>> from sympy.polys.domains import ZZ, QQ\n>>> from sympy.polys.matrices import DM\n>>> X = DM([[1, 0, 0, 0, -20160],\n...         [0, 1, 0, 0, 33768],\n...         [0, 0, 1, 0, 39578],\n...         [0, 0, 0, 1, 47757]], ZZ)\n>>> B, T = X.lll_transform(delta=QQ(5, 6))\n>>> T * X == B\nTrue \n```", "```py\nlu()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [QQ(1), QQ(-1)],\n...    [QQ(2), QQ(-2)]], (2, 2), QQ)\n>>> L, U, exchange = A.lu()\n>>> L\nDomainMatrix([[1, 0], [2, 1]], (2, 2), QQ)\n>>> U\nDomainMatrix([[1, -1], [0, 0]], (2, 2), QQ)\n>>> exchange\n[] \n```", "```py\nlu_solve(rhs)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [QQ(1), QQ(2)],\n...    [QQ(3), QQ(4)]], (2, 2), QQ)\n>>> B = DomainMatrix([\n...    [QQ(1), QQ(1)],\n...    [QQ(0), QQ(1)]], (2, 2), QQ) \n```", "```py\n>>> A.lu_solve(B)\nDomainMatrix([[-2, -1], [3/2, 1]], (2, 2), QQ) \n```", "```py\nmatmul(B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> B = DomainMatrix([\n...    [ZZ(1), ZZ(1)],\n...    [ZZ(0), ZZ(1)]], (2, 2), ZZ) \n```", "```py\n>>> A.matmul(B)\nDomainMatrix([[1, 3], [3, 7]], (2, 2), ZZ) \n```", "```py\nmul(b)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> b = ZZ(2) \n```", "```py\n>>> A.mul(b)\nDomainMatrix([[2, 4], [6, 8]], (2, 2), ZZ) \n```", "```py\nneg()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ) \n```", "```py\n>>> A.neg()\nDomainMatrix([[-1, -2], [-3, -4]], (2, 2), ZZ) \n```", "```py\nnnz()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[1, 0], [0, 4]], ZZ)\n>>> A.nnz()\n2 \n```", "```py\nnullspace(divide_last=False)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([\n...    [QQ(2), QQ(-2)],\n...    [QQ(4), QQ(-4)]], QQ)\n>>> A.nullspace()\nDomainMatrix([[1, 1]], (1, 2), QQ) \n```", "```py\n>>> A_null = A.nullspace().transpose()\n>>> A * A_null\nDomainMatrix([[0], [0]], (2, 1), QQ)\n>>> rows, cols = A.shape\n>>> nullity = rows - A.rank()\n>>> A_null.shape == (cols, nullity)\nTrue \n```", "```py\n>>> from sympy import ZZ\n>>> B = DM([[6, -3],\n...         [4, -2]], ZZ)\n>>> B.nullspace()\nDomainMatrix([[3, 6]], (1, 2), ZZ)\n>>> B.nullspace(divide_last=True)\nTraceback (most recent call last):\n...\nDMNotAField: Cannot normalize vectors over a non-field \n```", "```py\n>>> B.nullspace().primitive()\n(3, DomainMatrix([[1, 2]], (1, 2), ZZ)) \n```", "```py\n>>> from sympy.abc import a, b, c\n>>> from sympy import Matrix\n>>> M = Matrix([[        a*b,       b + c,        c],\n...             [      a - b,         b*c,     c**2],\n...             [a*b + a - b, b*c + b + c, c**2 + c]])\n>>> M.to_DM().domain\nZZ[a,b,c]\n>>> M.to_DM().nullspace().to_Matrix().transpose()\nMatrix([\n[                             c**3],\n[            -a*b*c**2 + a*c - b*c],\n[a*b**2*c - a*b - a*c + b**2 + b*c]]) \n```", "```py\n>>> M.to_DM().to_field().nullspace(divide_last=True).to_Matrix().transpose()\nMatrix([\n[                   c**3/(a*b**2*c - a*b - a*c + b**2 + b*c)],\n[(-a*b*c**2 + a*c - b*c)/(a*b**2*c - a*b - a*c + b**2 + b*c)],\n[                                                          1]]) \n```", "```py\nnullspace_from_rref(pivots=None)\n```", "```py\nclassmethod ones(shape, domain)\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import QQ\n>>> DomainMatrix.ones((2,3), QQ)\nDomainMatrix([[1, 1, 1], [1, 1, 1]], (2, 3), QQ) \n```", "```py\npow(n)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(1)],\n...    [ZZ(0), ZZ(1)]], (2, 2), ZZ) \n```", "```py\n>>> A.pow(2)\nDomainMatrix([[1, 2], [0, 1]], (2, 2), ZZ) \n```", "```py\nprimitive()\n```", "```py\n>>> from sympy.polys.matrices import DM\n>>> from sympy import ZZ\n>>> M = DM([[2, 4], [4, 12]], ZZ)\n>>> content, M_primitive = M.primitive()\n>>> content\n2\n>>> M_primitive\nDomainMatrix([[1, 2], [2, 6]], (2, 2), ZZ)\n>>> content * M_primitive == M\nTrue\n>>> M_primitive.content() == ZZ(1)\nTrue \n```", "```py\nrowspace()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [QQ(1), QQ(-1)],\n...    [QQ(2), QQ(-2)]], (2, 2), QQ)\n>>> A.rowspace()\nDomainMatrix([[1, -1]], (1, 2), QQ) \n```", "```py\nrref(*, method='auto')\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...     [QQ(2), QQ(-1), QQ(0)],\n...     [QQ(-1), QQ(2), QQ(-1)],\n...     [QQ(0), QQ(0), QQ(2)]], (3, 3), QQ) \n```", "```py\n>>> rref_matrix, rref_pivots = A.rref()\n>>> rref_matrix\nDomainMatrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]], (3, 3), QQ)\n>>> rref_pivots\n(0, 1, 2) \n```", "```py\nrref_den(*, method='auto', keep_domain=True)\n```", "```py\n>>> from sympy import ZZ, QQ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...     [ZZ(2), ZZ(-1), ZZ(0)],\n...     [ZZ(-1), ZZ(2), ZZ(-1)],\n...     [ZZ(0), ZZ(0), ZZ(2)]], (3, 3), ZZ) \n```", "```py\n>>> A_rref, denom, pivots = A.rref_den()\n>>> A_rref\nDomainMatrix([[6, 0, 0], [0, 6, 0], [0, 0, 6]], (3, 3), ZZ)\n>>> denom\n6\n>>> pivots\n(0, 1, 2)\n>>> A_rref.to_field() / denom\nDomainMatrix([[1, 0, 0], [0, 1, 0], [0, 0, 1]], (3, 3), QQ)\n>>> A_rref.to_field() / denom == A.convert_to(QQ).rref()[0]\nTrue \n```", "```py\nscc()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> M = DomainMatrix([[ZZ(1), ZZ(0), ZZ(2)],\n...                   [ZZ(0), ZZ(3), ZZ(0)],\n...                   [ZZ(4), ZZ(6), ZZ(5)]], (3, 3), ZZ)\n>>> M.scc()\n[[1], [0, 2]] \n```", "```py\n>>> MM = M.to_Matrix()\n>>> MM\nMatrix([\n[1, 0, 2],\n[0, 3, 0],\n[4, 6, 5]])\n>>> MM[[1], [1]]\nMatrix([[3]])\n>>> MM[[0, 2], [0, 2]]\nMatrix([\n[1, 2],\n[4, 5]])\n>>> MM.det()\n-9\n>>> MM[[1], [1]].det() * MM[[0, 2], [0, 2]].det()\n-9 \n```", "```py\n>>> MM[[1, 0, 2], [1, 0, 2]]\nMatrix([\n[3, 0, 0],\n[0, 1, 2],\n[6, 4, 5]]) \n```", "```py\nsolve_den(b, method=None)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)\n>>> b = DM([[ZZ(5)], [ZZ(6)]], ZZ)\n>>> xnum, xden = A.solve_den(b)\n>>> xden\n-2\n>>> xnum\nDomainMatrix([[8], [-9]], (2, 1), ZZ)\n>>> A * xnum == xden * b\nTrue \n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.abc import x, y, z, a, b\n>>> R = ZZ[x, y, z, a, b]\n>>> M = DM([[x*y, x*z], [y*z, x*z]], R)\n>>> b = DM([[a], [b]], R)\n>>> M.to_Matrix()\nMatrix([\n[x*y, x*z],\n[y*z, x*z]])\n>>> b.to_Matrix()\nMatrix([\n[a],\n[b]])\n>>> xnum, xden = M.solve_den(b)\n>>> xden\nx**2*y*z - x*y*z**2\n>>> xnum.to_Matrix()\nMatrix([\n[ a*x*z - b*x*z],\n[-a*y*z + b*x*y]])\n>>> M * xnum == xden * b\nTrue \n```", "```py\n>>> xsol = xnum.to_field() / xden\n>>> xsol.to_Matrix()\nMatrix([\n[           (a - b)/(x*y - y*z)],\n[(-a*z + b*x)/(x**2*z - x*z**2)]])\n>>> (M * xsol).to_Matrix() == b.to_Matrix()\nTrue \n```", "```py\n>>> xsol_uncancelled = xnum.to_Matrix() / xnum.domain.to_sympy(xden)\n>>> xsol_uncancelled\nMatrix([\n[ (a*x*z - b*x*z)/(x**2*y*z - x*y*z**2)],\n[(-a*y*z + b*x*y)/(x**2*y*z - x*y*z**2)]])\n>>> from sympy import cancel\n>>> cancel(xsol_uncancelled) == xsol.to_Matrix()\nTrue \n```", "```py\nsolve_den_charpoly(b, cp=None, check=True)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)\n>>> b = DM([[ZZ(5)], [ZZ(6)]], ZZ)\n>>> xnum, detA = A.solve_den_charpoly(b)\n>>> detA\n-2\n>>> xnum\nDomainMatrix([[8], [-9]], (2, 1), ZZ)\n>>> A * xnum == detA * b\nTrue \n```", "```py\nsolve_den_rref(b)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], ZZ)\n>>> b = DM([[ZZ(5)], [ZZ(6)]], ZZ)\n>>> xnum, xden = A.solve_den_rref(b)\n>>> xden\n-2\n>>> xnum\nDomainMatrix([[8], [-9]], (2, 1), ZZ)\n>>> A * xnum == xden * b\nTrue \n```", "```py\nsub(B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> B = DomainMatrix([\n...    [ZZ(4), ZZ(3)],\n...    [ZZ(2), ZZ(1)]], (2, 2), ZZ) \n```", "```py\n>>> A.sub(B)\nDomainMatrix([[-3, -1], [1, 3]], (2, 2), ZZ) \n```", "```py\nto_Matrix()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ) \n```", "```py\n>>> A.to_Matrix()\nMatrix([\n [1, 2],\n [3, 4]]) \n```", "```py\nto_ddm()\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import QQ\n>>> A = DomainMatrix({0: {0: 1}, 1: {1: 2}}, (2, 2), QQ)\n>>> ddm = A.to_ddm()\n>>> ddm\n[[1, 0], [0, 2]]\n>>> type(ddm)\n<class 'sympy.polys.matrices.ddm.DDM'> \n```", "```py\nto_dense()\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import QQ\n>>> A = DomainMatrix({0: {0: 1}, 1: {1: 2}}, (2, 2), QQ)\n>>> A.rep\n{0: {0: 1}, 1: {1: 2}}\n>>> B = A.to_dense()\n>>> B.rep\n[[1, 0], [0, 2]] \n```", "```py\nto_dfm()\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import QQ\n>>> A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)\n>>> dfm = A.to_dfm()\n>>> dfm\n[[1, 0], [0, 2]]\n>>> type(dfm)\n<class 'sympy.polys.matrices._dfm.DFM'> \n```", "```py\nto_dfm_or_ddm()\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import QQ\n>>> A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)\n>>> dfm = A.to_dfm_or_ddm()\n>>> dfm\n[[1, 0], [0, 2]]\n>>> type(dfm)  # Depends on the ground domain and ground types\n<class 'sympy.polys.matrices._dfm.DFM'> \n```", "```py\nto_dod()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DM\n>>> A = DM([[ZZ(1), ZZ(2), ZZ(0)], [ZZ(3), ZZ(0), ZZ(4)]], ZZ)\n>>> A.to_dod()\n{0: {0: 1, 1: 2}, 1: {0: 3, 2: 4}}\n>>> A.to_sparse() == A.from_dod(A.to_dod(), A.shape, A.domain)\nTrue\n>>> A == A.from_dod_like(A.to_dod())\nTrue \n```", "```py\nto_dok()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(0)],\n...    [ZZ(0), ZZ(4)]], (2, 2), ZZ)\n>>> A.to_dok()\n{(0, 0): 1, (1, 1): 4} \n```", "```py\n>>> A.to_sparse() == A.from_dok(A.to_dok(), A.shape, A.domain)\nTrue \n```", "```py\nto_field()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ) \n```", "```py\n>>> A.to_field()\nDomainMatrix([[1, 2], [3, 4]], (2, 2), QQ) \n```", "```py\nto_flat_nz()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([\n...    [ZZ(1), ZZ(2)],\n...    [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> elements, data = A.to_flat_nz()\n>>> elements\n[1, 2, 3, 4]\n>>> A == A.from_flat_nz(elements, data, A.domain)\nTrue \n```", "```py\n>>> elements_doubled = [2*x for x in elements]\n>>> A2 = A.from_flat_nz(elements_doubled, data, A.domain)\n>>> A2 == 2*A\nTrue \n```", "```py\nto_list()\n```", "```py\nto_list_flat()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> A.to_list_flat()\n[1, 2, 3, 4] \n```", "```py\nto_sdm()\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import QQ\n>>> A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)\n>>> sdm = A.to_sdm()\n>>> sdm\n{0: {0: 1}, 1: {1: 2}}\n>>> type(sdm)\n<class 'sympy.polys.matrices.sdm.SDM'> \n```", "```py\nto_sparse()\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import QQ\n>>> A = DomainMatrix([[1, 0],[0, 2]], (2, 2), QQ)\n>>> A.rep\n[[1, 0], [0, 2]]\n>>> B = A.to_sparse()\n>>> B.rep\n{0: {0: 1}, 1: {1: 2}} \n```", "```py\ntranspose()\n```", "```py\nunify(*others, fmt=None)\n```", "```py\n>>> from sympy import ZZ, QQ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n>>> B = DomainMatrix([[QQ(1, 2), QQ(2)]], (1, 2), QQ)\n>>> Aq, Bq = A.unify(B)\n>>> Aq\nDomainMatrix([[1, 2]], (1, 2), QQ)\n>>> Bq\nDomainMatrix([[1/2, 2]], (1, 2), QQ) \n```", "```py\n>>> A = DomainMatrix([[ZZ(1), ZZ(2)]], (1, 2), ZZ)\n>>> B = DomainMatrix({0:{0: ZZ(1)}}, (2, 2), ZZ)\n>>> B.rep\n{0: {0: 1}} \n```", "```py\n>>> A2, B2 = A.unify(B, fmt='dense')\n>>> B2.rep\n[[1, 0], [0, 0]] \n```", "```py\nvstack(*B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix \n```", "```py\n>>> A = DomainMatrix([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> B = DomainMatrix([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)\n>>> A.vstack(B)\nDomainMatrix([[1, 2], [3, 4], [5, 6], [7, 8]], (4, 2), ZZ) \n```", "```py\n>>> C = DomainMatrix([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)\n>>> A.vstack(B, C)\nDomainMatrix([[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]], (6, 2), ZZ) \n```", "```py\nclassmethod zeros(shape, domain, *, fmt='sparse')\n```", "```py\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy import QQ\n>>> DomainMatrix.zeros((2, 3), QQ)\nDomainMatrix({}, (2, 3), QQ) \n```", "```py\n>>> from sympy import ZZ, QQ\n>>> from sympy.polys.matrices.ddm import DDM\n>>> A = DDM([[ZZ(0), ZZ(1)], [ZZ(-1), ZZ(0)]], (2, 2), ZZ)\n>>> A.shape\n(2, 2)\n>>> A\n[[0, 1], [-1, 0]]\n>>> type(A)\n<class 'sympy.polys.matrices.ddm.DDM'>\n>>> A @ A\n[[-1, 0], [0, -1]] \n```", "```py\n>>> from sympy.polys.matrices.dense import ddm_idet\n>>> ddm_idet(A, QQ)\n1\n>>> ddm_idet([[0, 1], [-1, 0]], QQ)\n1\n>>> A\n[[-1, 0], [0, -1]] \n```", "```py\n>>> B = DDM([[ZZ(0), ZZ(1)], [ZZ(-1), ZZ(0)]], (2, 2), ZZ)\n>>> B.det()\n1 \n```", "```py\nclass sympy.polys.matrices.ddm.DDM(rowslist, shape, domain)\n```", "```py\nadd(b)\n```", "```py\ncharpoly()\n```", "```py\ndet()\n```", "```py\nclassmethod diag(values, domain)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import DDM\n>>> DDM.diag([ZZ(1), ZZ(2), ZZ(3)], ZZ)\n[[1, 0, 0], [0, 2, 0], [0, 0, 3]] \n```", "```py\ndiagonal()\n```", "```py\nclassmethod from_dod(dod, shape, domain)\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> dod = {0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}}\n>>> A = DDM.from_dod(dod, (2, 2), QQ)\n>>> A\n[[1, 2], [3, 4]] \n```", "```py\nclassmethod from_dok(dok, shape, domain)\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> dok = {(0, 0): 1, (0, 1): 2, (1, 0): 3, (1, 1): 4}\n>>> A = DDM.from_dok(dok, (2, 2), QQ)\n>>> A\n[[1, 2], [3, 4]] \n```", "```py\nclassmethod from_flat_nz(elements, data, domain)\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n>>> elements, data = A.to_flat_nz()\n>>> elements\n[1, 2, 3, 4]\n>>> A == DDM.from_flat_nz(elements, data, A.domain)\nTrue \n```", "```py\nclassmethod from_list(rowslist, shape, domain)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.ddm import DDM\n>>> A = DDM.from_list([[ZZ(0), ZZ(1)], [ZZ(-1), ZZ(0)]], (2, 2), ZZ)\n>>> A\n[[0, 1], [-1, 0]]\n>>> A == DDM([[ZZ(0), ZZ(1)], [ZZ(-1), ZZ(0)]], (2, 2), ZZ)\nTrue \n```", "```py\nclassmethod from_list_flat(flat, shape, domain)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.ddm import DDM\n>>> A = DDM.from_list_flat([1, 2, 3, 4], (2, 2), QQ)\n>>> A\n[[1, 2], [3, 4]]\n>>> A == DDM.from_list_flat(A.to_list_flat(), A.shape, A.domain)\nTrue \n```", "```py\nhstack(*B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import DDM \n```", "```py\n>>> A = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> B = DDM([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)\n>>> A.hstack(B)\n[[1, 2, 5, 6], [3, 4, 7, 8]] \n```", "```py\n>>> C = DDM([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)\n>>> A.hstack(B, C)\n[[1, 2, 5, 6, 9, 10], [3, 4, 7, 8, 11, 12]] \n```", "```py\ninv()\n```", "```py\nis_diagonal()\n```", "```py\nis_lower()\n```", "```py\nis_upper()\n```", "```py\nis_zero_matrix()\n```", "```py\niter_items()\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> A = DDM([[QQ(1), QQ(0)], [QQ(3), QQ(4)]], (2, 2), QQ)\n>>> list(A.iter_items())\n[((0, 0), 1), ((1, 0), 3), ((1, 1), 4)] \n```", "```py\niter_values()\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> A = DDM([[QQ(1), QQ(0)], [QQ(3), QQ(4)]], (2, 2), QQ)\n>>> list(A.iter_values())\n[1, 3, 4] \n```", "```py\nlu()\n```", "```py\nlu_solve(b)\n```", "```py\nmatmul(b)\n```", "```py\nneg()\n```", "```py\nnnz()\n```", "```py\nnullspace()\n```", "```py\nnullspace_from_rref(pivots=None)\n```", "```py\nrref()\n```", "```py\nrref_den()\n```", "```py\nscc()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import DDM\n>>> A = DDM([[ZZ(1), ZZ(0)], [ZZ(0), ZZ(1)]], (2, 2), ZZ)\n>>> A.scc()\n[[0], [1]] \n```", "```py\nsub(b)\n```", "```py\nto_ddm()\n```", "```py\nto_dfm()\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n>>> A.to_dfm()\n[[1, 2], [3, 4]]\n>>> type(A.to_dfm())\n<class 'sympy.polys.matrices._dfm.DFM'> \n```", "```py\nto_dfm_or_ddm()\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n>>> A.to_dfm_or_ddm()\n[[1, 2], [3, 4]]\n>>> type(A.to_dfm_or_ddm())\n<class 'sympy.polys.matrices._dfm.DFM'> \n```", "```py\nto_dod()\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n>>> A.to_dod()\n{0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}} \n```", "```py\nto_dok()\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n>>> A.to_dok()\n{(0, 0): 1, (0, 1): 2, (1, 0): 3, (1, 1): 4} \n```", "```py\nto_flat_nz()\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n>>> elements, data = A.to_flat_nz()\n>>> elements\n[1, 2, 3, 4]\n>>> A == DDM.from_flat_nz(elements, data, A.domain)\nTrue \n```", "```py\nto_list()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.ddm import DDM\n>>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n>>> A.to_list()\n[[1, 2], [3, 4]] \n```", "```py\nto_list_flat()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.ddm import DDM\n>>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n>>> A.to_list_flat()\n[1, 2, 3, 4]\n>>> A == DDM.from_list_flat(A.to_list_flat(), A.shape, A.domain)\nTrue \n```", "```py\nto_sdm()\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy import QQ\n>>> A = DDM([[1, 2], [3, 4]], (2, 2), QQ)\n>>> A.to_sdm()\n{0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}}\n>>> type(A.to_sdm())\n<class 'sympy.polys.matrices.sdm.SDM'> \n```", "```py\nvstack(*B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import DDM \n```", "```py\n>>> A = DDM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> B = DDM([[ZZ(5), ZZ(6)], [ZZ(7), ZZ(8)]], (2, 2), ZZ)\n>>> A.vstack(B)\n[[1, 2], [3, 4], [5, 6], [7, 8]] \n```", "```py\n>>> C = DDM([[ZZ(9), ZZ(10)], [ZZ(11), ZZ(12)]], (2, 2), ZZ)\n>>> A.vstack(B, C)\n[[1, 2], [3, 4], [5, 6], [7, 8], [9, 10], [11, 12]] \n```", "```py\n>>> from sympy.polys.matrices.dense import ddm_irref\n>>> M = [[1, 2, 3], [4, 5, 6]]\n>>> pivots = ddm_irref(M)\n>>> M\n[[1.0, 0.0, -1.0], [0, 1.0, 2.0]] \n```", "```py\n>>> from sympy.polys.domains import QQ\n>>> from sympy.polys.matrices.ddm import DDM\n>>> M = DDM([[QQ(1), QQ(2), QQ(3)], [QQ(4), QQ(5), QQ(6)]], (2, 3), QQ)\n>>> M\n[[1, 2, 3], [4, 5, 6]]\n>>> Mrref, pivots = M.rref()\n>>> Mrref\n[[1, 0, -1], [0, 1, 2]] \n```", "```py\nclass sympy.polys.matrices.dense.R\n```", "```py\nclass sympy.polys.matrices.dense.T\n```", "```py\nsympy.polys.matrices.dense.ddm_berk(M, K)\n```", "```py\n>>> from sympy import Matrix\n>>> from sympy.polys.matrices.dense import ddm_berk\n>>> from sympy.polys.domains import ZZ\n>>> M = [[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]]\n>>> ddm_berk(M, ZZ)\n[[1], [-5], [-2]]\n>>> Matrix(M).charpoly()\nPurePoly(lambda**2 - 5*lambda - 2, lambda, domain='ZZ') \n```", "```py\nsympy.polys.matrices.dense.ddm_iadd(a: list[list[R]], b: Sequence[Sequence[R]]) → None\n```", "```py\nsympy.polys.matrices.dense.ddm_idet(a, K)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.ddm import ddm_idet\n>>> a = [[ZZ(1), ZZ(2), ZZ(3)], [ZZ(4), ZZ(5), ZZ(6)], [ZZ(7), ZZ(8), ZZ(9)]]\n>>> a\n[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n>>> ddm_idet(a, ZZ)\n0\n>>> a\n[[1, 2, 3], [4, -3, -6], [7, -6, 0]]\n>>> [a[i][i] for i in range(len(a))]\n[1, -3, 0] \n```", "```py\nsympy.polys.matrices.dense.ddm_iinv(ainv, a, K)\n```", "```py\n>>> from sympy.polys.matrices.ddm import ddm_iinv, ddm_imatmul\n>>> from sympy import QQ\n>>> a = [[QQ(1), QQ(2)], [QQ(3), QQ(4)]]\n>>> ainv = [[None, None], [None, None]]\n>>> ddm_iinv(ainv, a, QQ)\n>>> ainv\n[[-2, 1], [3/2, -1/2]]\n>>> result = [[QQ(0), QQ(0)], [QQ(0), QQ(0)]]\n>>> ddm_imatmul(result, a, ainv)\n>>> result\n[[1, 0], [0, 1]] \n```", "```py\nsympy.polys.matrices.dense.ddm_ilu(a)\n```", "```py\n>>> from sympy.polys.matrices.dense import ddm_ilu\n>>> from sympy import QQ\n>>> a = [[QQ(1, 2), QQ(1, 3)], [QQ(1, 4), QQ(1, 5)]]\n>>> swaps = ddm_ilu(a)\n>>> swaps\n[]\n>>> a\n[[1/2, 1/3], [1/2, 1/30]] \n```", "```py\n>>> from sympy import Matrix, S\n>>> M = Matrix([[S(1)/2, S(1)/3], [S(1)/4, S(1)/5]])\n>>> L, U, swaps = M.LUdecomposition()\n>>> L\nMatrix([\n[  1, 0],\n[1/2, 1]])\n>>> U\nMatrix([\n[1/2,  1/3],\n[  0, 1/30]])\n>>> swaps\n[] \n```", "```py\nsympy.polys.matrices.dense.ddm_ilu_solve(x, L, U, swaps, b)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.dense import ddm_ilu, ddm_ilu_solve\n>>> A = [[QQ(1), QQ(2)], [QQ(3), QQ(4)]]\n>>> swaps = ddm_ilu(A)\n>>> A\n[[1, 2], [3, -2]]\n>>> L = U = A \n```", "```py\n>>> b = [[QQ(5)], [QQ(6)]]\n>>> x = [[None], [None]]\n>>> ddm_ilu_solve(x, L, U, swaps, b)\n>>> x\n[[-4], [9/2]] \n```", "```py\nsympy.polys.matrices.dense.ddm_ilu_split(L, U, K)\n```", "```py\n>>> from sympy.polys.matrices.ddm import ddm_ilu_split\n>>> from sympy import QQ\n>>> L = [[QQ(0), QQ(0)], [QQ(0), QQ(0)]]\n>>> U = [[QQ(1), QQ(2)], [QQ(3), QQ(4)]]\n>>> swaps = ddm_ilu_split(L, U, QQ)\n>>> swaps\n[]\n>>> L\n[[0, 0], [3, 0]]\n>>> U\n[[1, 2], [0, -2]] \n```", "```py\nsympy.polys.matrices.dense.ddm_imatmul(a: list[list[R]], b: Sequence[Sequence[R]], c: Sequence[Sequence[R]]) → None\n```", "```py\nsympy.polys.matrices.dense.ddm_imul(a: list[list[R]], b: R) → None\n```", "```py\nsympy.polys.matrices.dense.ddm_ineg(a: list[list[R]]) → None\n```", "```py\nsympy.polys.matrices.dense.ddm_irmul(a: list[list[R]], b: R) → None\n```", "```py\nsympy.polys.matrices.dense.ddm_irref(a, _partial_pivot=False)\n```", "```py\n>>> from sympy.polys.matrices.dense import ddm_irref\n>>> from sympy import QQ\n>>> M = [[QQ(1), QQ(2), QQ(3)], [QQ(4), QQ(5), QQ(6)]]\n>>> pivots = ddm_irref(M)\n>>> M\n[[1, 0, -1], [0, 1, 2]]\n>>> pivots\n[0, 1] \n```", "```py\nsympy.polys.matrices.dense.ddm_irref_den(a, K)\n```", "```py\n>>> from sympy.polys.matrices.dense import ddm_irref_den\n>>> from sympy import ZZ, Matrix\n>>> M = [[ZZ(1), ZZ(2), ZZ(3)], [ZZ(4), ZZ(5), ZZ(6)]]\n>>> den, pivots = ddm_irref_den(M, ZZ)\n>>> M\n[[-3, 0, 3], [0, -3, -6]]\n>>> den\n-3\n>>> pivots\n[0, 1]\n>>> Matrix(M).rref()[0]\nMatrix([\n[1, 0, -1],\n[0, 1,  2]]) \n```", "```py\nsympy.polys.matrices.dense.ddm_isub(a: list[list[R]], b: Sequence[Sequence[R]]) → None\n```", "```py\nsympy.polys.matrices.dense.ddm_transpose(matrix: Sequence[Sequence[T]]) → list[list[T]]\n```", "```py\nclass sympy.polys.matrices._typing.RingElement(*args, **kwargs)\n```", "```py\nclass sympy.polys.matrices.sdm.SDM(elemsdict, shape, domain)\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> elemsdict = {0:{1:QQ(1, 2)}}\n>>> A = SDM(elemsdict, (2, 2), QQ)\n>>> A\n{0: {1: 1/2}} \n```", "```py\n>>> from sympy import ZZ\n>>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n>>> B  = SDM({0:{0: ZZ(3)}, 1:{1:ZZ(4)}}, (2, 2), ZZ)\n>>> A + B\n{0: {0: 3, 1: 2}, 1: {0: 1, 1: 4}} \n```", "```py\n>>> A*B\n{0: {1: 8}, 1: {0: 3}}\n>>> A*ZZ(2)\n{0: {1: 4}, 1: {0: 2}} \n```", "```py\nadd(B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n>>> B = SDM({0:{0: ZZ(3)}, 1:{1:ZZ(4)}}, (2, 2), ZZ)\n>>> A.add(B)\n{0: {0: 3, 1: 2}, 1: {0: 1, 1: 4}} \n```", "```py\ncharpoly()\n```", "```py\n>>> from sympy import QQ, Symbol\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy.polys import Poly\n>>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(3), 1:QQ(4)}}, (2, 2), QQ)\n>>> A.charpoly()\n[1, -5, -2] \n```", "```py\n>>> x = Symbol('x')\n>>> p = Poly(A.charpoly(), x, domain=A.domain)\n>>> p\nPoly(x**2 - 5*x - 2, x, domain='QQ') \n```", "```py\nconvert_to(K)\n```", "```py\n>>> from sympy import ZZ, QQ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n>>> A.convert_to(QQ)\n{0: {1: 2}, 1: {0: 1}} \n```", "```py\ncopy()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> elemsdict = {0:{1:QQ(2)}, 1:{}}\n>>> A = SDM(elemsdict, (2, 2), QQ)\n>>> B = A.copy()\n>>> B\n{0: {1: 2}, 1: {}} \n```", "```py\ndet()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(3), 1:QQ(4)}}, (2, 2), QQ)\n>>> A.det()\n-2 \n```", "```py\ndiagonal()\n```", "```py\nclassmethod eye(shape, domain)\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> I = SDM.eye((2, 2), QQ)\n>>> I\n{0: {0: 1}, 1: {1: 1}} \n```", "```py\nclassmethod from_ddm(ddm)\n```", "```py\n>>> from sympy.polys.matrices.ddm import DDM\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> ddm = DDM( [[QQ(1, 2), 0], [0, QQ(3, 4)]], (2, 2), QQ)\n>>> A = SDM.from_ddm(ddm)\n>>> A\n{0: {0: 1/2}, 1: {1: 3/4}}\n>>> SDM.from_ddm(ddm).to_ddm() == ddm\nTrue \n```", "```py\nclassmethod from_dod(dod, shape, domain)\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> dod = {0: {1: QQ(2)}, 1: {0: QQ(3)}}\n>>> A = SDM.from_dod(dod, (2, 2), QQ)\n>>> A\n{0: {1: 2}, 1: {0: 3}}\n>>> A == SDM.from_dod(A.to_dod(), A.shape, A.domain)\nTrue \n```", "```py\nclassmethod from_dok(dok, shape, domain)\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> dok = {(0, 1): QQ(2), (1, 0): QQ(3)}\n>>> A = SDM.from_dok(dok, (2, 2), QQ)\n>>> A\n{0: {1: 2}, 1: {0: 3}}\n>>> A == SDM.from_dok(A.to_dok(), A.shape, A.domain)\nTrue \n```", "```py\nclassmethod from_flat_nz(elements, data, domain)\n```", "```py\nclassmethod from_list(ddm, shape, domain)\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> ddm = [[QQ(1, 2), QQ(0)], [QQ(0), QQ(3, 4)]]\n>>> A = SDM.from_list(ddm, (2, 2), QQ)\n>>> A\n{0: {0: 1/2}, 1: {1: 3/4}} \n```", "```py\nclassmethod from_list_flat(elements, shape, domain)\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM.from_list_flat([QQ(0), QQ(2), QQ(0), QQ(0)], (2, 2), QQ)\n>>> A\n{0: {1: 2}}\n>>> A == A.from_list_flat(A.to_list_flat(), A.shape, A.domain)\nTrue \n```", "```py\nhstack(*B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import SDM \n```", "```py\n>>> A = SDM({0: {0: ZZ(1), 1: ZZ(2)}, 1: {0: ZZ(3), 1: ZZ(4)}}, (2, 2), ZZ)\n>>> B = SDM({0: {0: ZZ(5), 1: ZZ(6)}, 1: {0: ZZ(7), 1: ZZ(8)}}, (2, 2), ZZ)\n>>> A.hstack(B)\n{0: {0: 1, 1: 2, 2: 5, 3: 6}, 1: {0: 3, 1: 4, 2: 7, 3: 8}} \n```", "```py\n>>> C = SDM({0: {0: ZZ(9), 1: ZZ(10)}, 1: {0: ZZ(11), 1: ZZ(12)}}, (2, 2), ZZ)\n>>> A.hstack(B, C)\n{0: {0: 1, 1: 2, 2: 5, 3: 6, 4: 9, 5: 10}, 1: {0: 3, 1: 4, 2: 7, 3: 8, 4: 11, 5: 12}} \n```", "```py\ninv()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(3), 1:QQ(4)}}, (2, 2), QQ)\n>>> A.inv()\n{0: {0: -2, 1: 1}, 1: {0: 3/2, 1: -1/2}} \n```", "```py\nis_diagonal()\n```", "```py\nis_lower()\n```", "```py\nis_upper()\n```", "```py\nis_zero_matrix()\n```", "```py\niter_items()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM({0: {1: QQ(2)}, 1: {0: QQ(3)}}, (2, 2), QQ)\n>>> list(A.iter_items())\n[((0, 1), 2), ((1, 0), 3)] \n```", "```py\niter_values()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM({0: {1: QQ(2)}, 1: {0: QQ(3)}}, (2, 2), QQ)\n>>> list(A.iter_values())\n[2, 3] \n```", "```py\nlll(delta=MPQ(3, 4))\n```", "```py\nlll_transform(delta=MPQ(3, 4))\n```", "```py\nlu()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(3), 1:QQ(4)}}, (2, 2), QQ)\n>>> A.lu()\n({0: {0: 1}, 1: {0: 3, 1: 1}}, {0: {0: 1, 1: 2}, 1: {1: -2}}, []) \n```", "```py\nlu_solve(b)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(3), 1:QQ(4)}}, (2, 2), QQ)\n>>> b = SDM({0:{0:QQ(1)}, 1:{0:QQ(2)}}, (2, 1), QQ)\n>>> A.lu_solve(b)\n{1: {0: 1/2}} \n```", "```py\nmatmul(B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n>>> B = SDM({0:{0:ZZ(2), 1:ZZ(3)}, 1:{0:ZZ(4)}}, (2, 2), ZZ)\n>>> A.matmul(B)\n{0: {0: 8}, 1: {0: 2, 1: 3}} \n```", "```py\nmul(b)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n>>> A.mul(ZZ(3))\n{0: {1: 6}, 1: {0: 3}} \n```", "```py\nneg()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n>>> A.neg()\n{0: {1: -2}, 1: {0: -1}} \n```", "```py\nclassmethod new(sdm, shape, domain)\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> elemsdict = {0:{1: QQ(2)}}\n>>> A = SDM.new(elemsdict, (2, 2), QQ)\n>>> A\n{0: {1: 2}} \n```", "```py\nnnz()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n>>> A.nnz()\n2 \n```", "```py\nnullspace()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0: QQ(2), 1: QQ(4)}}, (2, 2), QQ)\n>>> A.nullspace()\n({0: {0: -2, 1: 1}}, [1]) \n```", "```py\nnullspace_from_rref(pivots=None)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0: QQ(2), 1: QQ(4)}}, (2, 2), QQ)\n>>> A_rref, pivots = A.rref()\n>>> A_null, nonpivots = A_rref.nullspace_from_rref(pivots)\n>>> A_null\n{0: {0: -2, 1: 1}}\n>>> pivots\n[0]\n>>> nonpivots\n[1] \n```", "```py\nrref()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(2), 1:QQ(4)}}, (2, 2), QQ)\n>>> A.rref()\n({0: {0: 1, 1: 2}}, [0]) \n```", "```py\nrref_den()\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{0:QQ(1), 1:QQ(2)}, 1:{0:QQ(2), 1:QQ(4)}}, (2, 2), QQ)\n>>> A.rref_den()\n({0: {0: 1, 1: 2}}, 1, [0]) \n```", "```py\nscc()\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{0: ZZ(2)}, 1:{1:ZZ(1)}}, (2, 2), ZZ)\n>>> A.scc()\n[[0], [1]] \n```", "```py\nsub(B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import SDM\n>>> A = SDM({0:{1: ZZ(2)}, 1:{0:ZZ(1)}}, (2, 2), ZZ)\n>>> B  = SDM({0:{0: ZZ(3)}, 1:{1:ZZ(4)}}, (2, 2), ZZ)\n>>> A.sub(B)\n{0: {0: -3, 1: 2}, 1: {0: 1, 1: -4}} \n```", "```py\nto_ddm()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM({0:{1:QQ(2)}, 1:{}}, (2, 2), QQ)\n>>> A.to_ddm()\n[[0, 2], [0, 0]] \n```", "```py\nto_dfm()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM({0:{1:QQ(2)}, 1:{}}, (2, 2), QQ)\n>>> A.to_dfm()\n[[0, 2], [0, 0]] \n```", "```py\nto_dfm_or_ddm()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM({0:{1:QQ(2)}, 1:{}}, (2, 2), QQ)\n>>> A.to_dfm_or_ddm()\n[[0, 2], [0, 0]]\n>>> type(A.to_dfm_or_ddm())  # depends on the ground types\n<class 'sympy.polys.matrices._dfm.DFM'> \n```", "```py\nto_dod()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM({0: {1: QQ(2)}, 1: {0: QQ(3)}}, (2, 2), QQ)\n>>> A.to_dod()\n{0: {1: 2}, 1: {0: 3}} \n```", "```py\nto_dok()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM({0: {1: QQ(2)}, 1: {0: QQ(3)}}, (2, 2), QQ)\n>>> A.to_dok()\n{(0, 1): 2, (1, 0): 3} \n```", "```py\nto_flat_nz()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM({0:{1:QQ(2)}, 1:{0: QQ(3)}}, (2, 2), QQ)\n>>> elements, data = A.to_flat_nz()\n>>> elements\n[2, 3]\n>>> A == A.from_flat_nz(elements, data, A.domain)\nTrue \n```", "```py\nto_list()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> elemsdict = {0:{1:QQ(2)}, 1:{}}\n>>> A = SDM(elemsdict, (2, 2), QQ)\n>>> A.to_list()\n[[0, 2], [0, 0]] \n```", "```py\nto_list_flat()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM({0:{1:QQ(2)}, 1:{0: QQ(3)}}, (2, 2), QQ)\n>>> A.to_list_flat()\n[0, 2, 3, 0]\n>>> A == A.from_list_flat(A.to_list_flat(), A.shape, A.domain)\nTrue \n```", "```py\nto_sdm()\n```", "```py\ntranspose()\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM({0:{1:QQ(2)}, 1:{}}, (2, 2), QQ)\n>>> A.transpose()\n{1: {0: 2}} \n```", "```py\nvstack(*B)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices.sdm import SDM \n```", "```py\n>>> A = SDM({0: {0: ZZ(1), 1: ZZ(2)}, 1: {0: ZZ(3), 1: ZZ(4)}}, (2, 2), ZZ)\n>>> B = SDM({0: {0: ZZ(5), 1: ZZ(6)}, 1: {0: ZZ(7), 1: ZZ(8)}}, (2, 2), ZZ)\n>>> A.vstack(B)\n{0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}, 2: {0: 5, 1: 6}, 3: {0: 7, 1: 8}} \n```", "```py\n>>> C = SDM({0: {0: ZZ(9), 1: ZZ(10)}, 1: {0: ZZ(11), 1: ZZ(12)}}, (2, 2), ZZ)\n>>> A.vstack(B, C)\n{0: {0: 1, 1: 2}, 1: {0: 3, 1: 4}, 2: {0: 5, 1: 6}, 3: {0: 7, 1: 8}, 4: {0: 9, 1: 10}, 5: {0: 11, 1: 12}} \n```", "```py\nclassmethod zeros(shape, domain)\n```", "```py\n>>> from sympy.polys.matrices.sdm import SDM\n>>> from sympy import QQ\n>>> A = SDM.zeros((2, 3), QQ)\n>>> A\n{} \n```", "```py\nsympy.polys.matrices.sdm.sdm_berk(M, n, K)\n```", "```py\n>>> from sympy import Matrix\n>>> from sympy.polys.matrices.sdm import sdm_berk\n>>> from sympy.polys.domains import ZZ\n>>> M = {0: {0: ZZ(1), 1:ZZ(2)}, 1: {0:ZZ(3), 1:ZZ(4)}}\n>>> sdm_berk(M, 2, ZZ)\n{0: 1, 1: -5, 2: -2}\n>>> Matrix([[1, 2], [3, 4]]).charpoly()\nPurePoly(lambda**2 - 5*lambda - 2, lambda, domain='ZZ') \n```", "```py\nsympy.polys.matrices.sdm.sdm_irref(A)\n```", "```py\n>>> from sympy import QQ\n>>> from sympy.polys.matrices.sdm import sdm_irref\n>>> A = {0: {0: QQ(1), 1: QQ(2)}, 1: {0: QQ(3), 1: QQ(4)}}\n>>> Arref, pivots, _ = sdm_irref(A)\n>>> Arref\n{0: {0: 1}, 1: {1: 1}}\n>>> pivots\n[0, 1] \n```", "```py\n>>> from sympy import Matrix\n>>> M = Matrix([[1, 2], [3, 4]])\n>>> Mrref, pivots = M.rref()\n>>> Mrref\nMatrix([\n[1, 0],\n[0, 1]])\n>>> pivots\n(0, 1) \n```", "```py\nsympy.polys.matrices.sdm.sdm_nullspace_from_rref(A, one, ncols, pivots, nonzero_cols)\n```", "```py\nsympy.polys.matrices.sdm.sdm_particular_from_rref(A, ncols, pivots)\n```", "```py\nsympy.polys.matrices.sdm.sdm_rref_den(A, K)\n```", "```py\n>>> from sympy.polys.matrices.sdm import sdm_rref_den\n>>> from sympy.polys.domains import ZZ\n>>> A = {0: {0: ZZ(1), 1: ZZ(2)}, 1: {0: ZZ(3), 1: ZZ(4)}}\n>>> A_rref, den, pivots = sdm_rref_den(A, ZZ)\n>>> A_rref\n{0: {0: -2}, 1: {1: -2}}\n>>> den\n-2\n>>> pivots\n[0, 1] \n```", "```py\nclass sympy.polys.matrices._dfm.DFM(rowslist, shape, domain)\n```", "```py\n>>> from sympy.polys.domains import ZZ\n>>> from sympy.polys.matrices.dfm import DFM\n>>> dfm = DFM([[ZZ(1), ZZ(2)], [ZZ(3), ZZ(4)]], (2, 2), ZZ)\n>>> dfm\n[[1, 2], [3, 4]]\n>>> dfm.rep\n[1, 2]\n[3, 4]\n>>> type(dfm.rep)  \n<class 'flint._flint.fmpz_mat'> \n```", "```py\n>>> from sympy.polys.matrices.domainmatrix import DM\n>>> dM = DM([[1, 2], [3, 4]], ZZ)\n>>> dM.rep\n[[1, 2], [3, 4]] \n```", "```py\n>>> dM.to_dfm()\n[[1, 2], [3, 4]] \n```", "```py\nadd(other)\n```", "```py\napplyfunc(func, domain)\n```", "```py\ncharpoly()\n```", "```py\n>>> from sympy import Matrix\n>>> M = Matrix([[1, 2], [3, 4]])\n>>> dfm = M.to_DM().to_dfm()  # need ground types = 'flint'\n>>> dfm\n[[1, 2], [3, 4]]\n>>> dfm.charpoly()\n[1, -5, -2] \n```", "```py\nconvert_to(domain)\n```", "```py\ncopy()\n```", "```py\ndet()\n```", "```py\n>>> from sympy import Matrix\n>>> M = Matrix([[1, 2], [3, 4]])\n>>> dfm = M.to_DM().to_dfm()\n>>> dfm\n[[1, 2], [3, 4]]\n>>> dfm.det()\n-2 \n```", "```py\nclassmethod diag(elements, domain)\n```", "```py\ndiagonal()\n```", "```py\nextract(rowslist, colslist)\n```", "```py\nextract_slice(rowslice, colslice)\n```", "```py\nclassmethod eye(n, domain)\n```", "```py\nclassmethod from_ddm(ddm)\n```", "```py\nclassmethod from_dod(dod, shape, domain)\n```", "```py\nclassmethod from_dok(dok, shape, domain)\n```", "```py\nclassmethod from_flat_nz(elements, data, domain)\n```", "```py\nclassmethod from_list(rowslist, shape, domain)\n```", "```py\nclassmethod from_list_flat(elements, shape, domain)\n```", "```py\ngetitem(i, j)\n```", "```py\nhstack(*others)\n```", "```py\ninv()\n```", "```py\n>>> from sympy import Matrix, QQ\n>>> M = Matrix([[1, 2], [3, 4]])\n>>> dfm = M.to_DM().to_dfm().convert_to(QQ)\n>>> dfm\n[[1, 2], [3, 4]]\n>>> dfm.inv()\n[[-2, 1], [3/2, -1/2]]\n>>> dfm.matmul(dfm.inv())\n[[1, 0], [0, 1]] \n```", "```py\nis_diagonal()\n```", "```py\nis_lower()\n```", "```py\nis_upper()\n```", "```py\nis_zero_matrix()\n```", "```py\niter_items()\n```", "```py\niter_values()\n```", "```py\nlll(delta=0.75)\n```", "```py\n>>> from sympy import Matrix\n>>> M = Matrix([[1, 2, 3], [4, 5, 6]])\n>>> M.to_DM().to_dfm().lll()\n[[2, 1, 0], [-1, 1, 3]] \n```", "```py\nlll_transform(delta=0.75)\n```", "```py\n>>> from sympy import Matrix\n>>> M = Matrix([[1, 2, 3], [4, 5, 6]]).to_DM().to_dfm()\n>>> M_lll, T = M.lll_transform()\n>>> M_lll\n[[2, 1, 0], [-1, 1, 3]]\n>>> T\n[[-2, 1], [3, -1]]\n>>> T.matmul(M) == M_lll\nTrue \n```", "```py\nlu()\n```", "```py\nlu_solve(rhs)\n```", "```py\n>>> from sympy import Matrix, QQ\n>>> M = Matrix([[1, 2], [3, 4]])\n>>> dfm = M.to_DM().to_dfm().convert_to(QQ)\n>>> dfm\n[[1, 2], [3, 4]]\n>>> rhs = Matrix([1, 2]).to_DM().to_dfm().convert_to(QQ)\n>>> dfm.lu_solve(rhs)\n[[0], [1/2]] \n```", "```py\nmatmul(other)\n```", "```py\nmul(other)\n```", "```py\nmul_elementwise(other)\n```", "```py\nneg()\n```", "```py\nnnz()\n```", "```py\nnullspace()\n```", "```py\nnullspace_from_rref(pivots=None)\n```", "```py\nclassmethod ones(shape, domain)\n```", "```py\nparticular()\n```", "```py\nrmul(other)\n```", "```py\nscc()\n```", "```py\nsetitem(i, j, value)\n```", "```py\nsub(other)\n```", "```py\nto_ddm()\n```", "```py\nto_dfm()\n```", "```py\nto_dfm_or_ddm()\n```", "```py\nto_dod()\n```", "```py\nto_dok()\n```", "```py\nto_flat_nz()\n```", "```py\nto_list()\n```", "```py\nto_list_flat()\n```", "```py\nto_sdm()\n```", "```py\ntranspose()\n```", "```py\nvstack(*others)\n```", "```py\nclassmethod zeros(shape, domain)\n```", "```py\nsympy.polys.matrices.normalforms.smith_normal_form(m)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy.polys.matrices.normalforms import smith_normal_form\n>>> m = DomainMatrix([[ZZ(12), ZZ(6), ZZ(4)],\n...                   [ZZ(3), ZZ(9), ZZ(6)],\n...                   [ZZ(2), ZZ(16), ZZ(14)]], (3, 3), ZZ)\n>>> print(smith_normal_form(m).to_Matrix())\nMatrix([[1, 0, 0], [0, 10, 0], [0, 0, -30]]) \n```", "```py\nsympy.polys.matrices.normalforms.hermite_normal_form(A, *, D=None, check_rank=False)\n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.matrices import DomainMatrix\n>>> from sympy.polys.matrices.normalforms import hermite_normal_form\n>>> m = DomainMatrix([[ZZ(12), ZZ(6), ZZ(4)],\n...                   [ZZ(3), ZZ(9), ZZ(6)],\n...                   [ZZ(2), ZZ(16), ZZ(14)]], (3, 3), ZZ)\n>>> print(hermite_normal_form(m).to_Matrix())\nMatrix([[10, 0, 2], [0, 15, 3], [0, 0, 2]]) \n```"]