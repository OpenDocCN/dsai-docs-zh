- en: scipy.optimize.fmin_cobyla
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.fmin_cobyla.html#scipy.optimize.fmin_cobyla](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.fmin_cobyla.html#scipy.optimize.fmin_cobyla)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Minimize a function using the Constrained Optimization By Linear Approximation
    (COBYLA) method. This method wraps a FORTRAN implementation of the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func**callable'
  prefs: []
  type: TYPE_NORMAL
- en: Function to minimize. In the form func(x, *args).
  prefs: []
  type: TYPE_NORMAL
- en: '**x0**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Initial guess.
  prefs: []
  type: TYPE_NORMAL
- en: '**cons**sequence'
  prefs: []
  type: TYPE_NORMAL
- en: Constraint functions; must all be `>=0` (a single function if only 1 constraint).
    Each function takes the parameters *x* as its first argument, and it can return
    either a single number or an array or list of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Extra arguments to pass to function.
  prefs: []
  type: TYPE_NORMAL
- en: '**consargs**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Extra arguments to pass to constraint functions (default of None means use same
    extra arguments as those passed to func). Use `()` for no extra arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '**rhobeg**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Reasonable initial changes to the variables.
  prefs: []
  type: TYPE_NORMAL
- en: '**rhoend**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Final accuracy in the optimization (not precisely guaranteed). This is a lower
    bound on the size of the trust region.
  prefs: []
  type: TYPE_NORMAL
- en: '**disp**{0, 1, 2, 3}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Controls the frequency of output; 0 implies no output.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxfun**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Maximum number of function evaluations.
  prefs: []
  type: TYPE_NORMAL
- en: '**catol**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute tolerance for constraint violations.
  prefs: []
  type: TYPE_NORMAL
- en: '**callback**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Called after each iteration, as `callback(x)`, where `x` is the current parameter
    vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The argument that minimises *f*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minimize`](scipy.optimize.minimize.html#scipy.optimize.minimize "scipy.optimize.minimize")'
  prefs: []
  type: TYPE_NORMAL
- en: Interface to minimization algorithms for multivariate functions. See the ‘COBYLA’
    *method* in particular.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This algorithm is based on linear approximations to the objective function and
    each constraint. We briefly describe the algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose the function is being minimized over k variables. At the jth iteration
    the algorithm has k+1 points v_1, …, v_(k+1), an approximate solution x_j, and
    a radius RHO_j. (i.e., linear plus a constant) approximations to the objective
    function and constraint functions such that their function values agree with the
    linear approximation on the k+1 points v_1,.., v_(k+1). This gives a linear program
    to solve (where the linear approximations of the constraint functions are constrained
    to be non-negative).
  prefs: []
  type: TYPE_NORMAL
- en: However, the linear approximations are likely only good approximations near
    the current simplex, so the linear program is given the further requirement that
    the solution, which will become x_(j+1), must be within RHO_j from x_j. RHO_j
    only decreases, never increases. The initial RHO_j is rhobeg and the final RHO_j
    is rhoend. In this way COBYLA’s iterations behave like a trust region algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the linear program may be inconsistent, or the approximation may
    give poor improvement. For details about how these issues are resolved, as well
    as how the points v_i are updated, refer to the source code or the references
    below.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: Powell M.J.D. (1994), “A direct search optimization method that models the objective
    and constraint functions by linear interpolation.”, in Advances in Optimization
    and Numerical Analysis, eds. S. Gomez and J-P Hennart, Kluwer Academic (Dordrecht),
    pp. 51-67
  prefs: []
  type: TYPE_NORMAL
- en: Powell M.J.D. (1998), “Direct search algorithms for optimization calculations”,
    Acta Numerica 7, 287-336
  prefs: []
  type: TYPE_NORMAL
- en: Powell M.J.D. (2007), “A view of algorithms for optimization without derivatives”,
    Cambridge University Technical Report DAMTP 2007/NA03
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Minimize the objective function f(x,y) = x*y subject to the constraints x**2
    + y**2 < 1 and y > 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The exact solution is (-sqrt(2)/2, sqrt(2)/2).
  prefs: []
  type: TYPE_NORMAL
