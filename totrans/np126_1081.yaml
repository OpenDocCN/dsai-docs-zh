- en: How does the CPU dispatcher work?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/simd/how-it-works.html](https://numpy.org/doc/1.26/reference/simd/how-it-works.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: NumPy dispatcher is based on multi-source compiling, which means taking a certain
    source and compiling it multiple times with different compiler flags and also
    with different **C** definitions that affect the code paths. This enables certain
    instruction-sets for each compiled object depending on the required optimizations
    and ends with linking the returned objects together.
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/opt-infra.png](../Images/f17831baf7d16b32813ea2f514d72c2d.png)'
  prefs: []
  type: TYPE_IMG
- en: This mechanism should support all compilers and it doesn’t require any compiler-specific
    extension, but at the same time it adds a few steps to normal compilation that
    are explained as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 1- Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuring the required optimization by the user before starting to build
    the source files via the two command arguments as explained above:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--cpu-baseline`: minimal set of required optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-dispatch`: dispatched set of additional optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2- Discovering the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this part, we check the compiler and platform architecture and cache some
    of the intermediary results to speed up rebuilding.
  prefs: []
  type: TYPE_NORMAL
- en: 3- Validating the requested optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By testing them against the compiler, and seeing what the compiler can support
    according to the requested optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 4- Generating the main configuration header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The generated header `_cpu_dispatch.h` contains all the definitions and headers
    of instruction-sets for the required optimizations that have been validated during
    the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: It also contains extra C definitions that are used for defining NumPy’s Python-level
    module attributes `__cpu_baseline__` and `__cpu_dispatch__`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is in this header?**'
  prefs: []
  type: TYPE_NORMAL
- en: The example header was dynamically generated by gcc on an X86 machine. The compiler
    supports `--cpu-baseline="sse sse2 sse3"` and `--cpu-dispatch="ssse3 sse41"`,
    and the result is below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**Baseline features** are the minimal set of required optimizations configured
    via `--cpu-baseline`. They have no preprocessor guards and they’re always on,
    which means they can be used in any source.'
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean NumPy’s infrastructure passes the compiler’s flags of baseline
    features to all sources?
  prefs: []
  type: TYPE_NORMAL
- en: Definitely, yes. But the [dispatch-able sources](#dispatchable-sources) are
    treated differently.
  prefs: []
  type: TYPE_NORMAL
- en: What if the user specifies certain **baseline features** during the build but
    at runtime the machine doesn’t support even these features? Will the compiled
    code be called via one of these definitions, or maybe the compiler itself auto-generated/vectorized
    certain piece of code based on the provided command line compiler flags?
  prefs: []
  type: TYPE_NORMAL
- en: During the loading of the NumPy module, there’s a validation step which detects
    this behavior. It will raise a Python runtime error to inform the user. This is
    to prevent the CPU reaching an illegal instruction error causing a segfault.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dispatch-able features** are our dispatched set of additional optimizations
    that were configured via `--cpu-dispatch`. They are not activated by default and
    are always guarded by other C definitions prefixed with `NPY__CPU_TARGET_`. C
    definitions `NPY__CPU_TARGET_` are only enabled within **dispatch-able sources**.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 5- Dispatch-able sources and configuration statements'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch-able sources are special **C** files that can be compiled multiple
    times with different compiler flags and also with different **C** definitions.
    These affect code paths to enable certain instruction-sets for each compiled object
    according to “**the configuration statements**” that must be declared between
    a **C** comment`(/**/)` and start with a special mark **@targets** at the top
    of each dispatch-able source. At the same time, dispatch-able sources will be
    treated as normal **C** sources if the optimization was disabled by the command
    argument `--disable-optimization` .
  prefs: []
  type: TYPE_NORMAL
- en: '**What are configuration statements?**'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration statements are sort of keywords combined together to determine
    the required optimization for the dispatch-able source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The keywords mainly represent the additional optimizations configured through
    `--cpu-dispatch`, but it can also represent other options such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Target groups: pre-configured configuration statements used for managing the
    required optimizations from outside the dispatch-able source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Policies: collections of options used for changing the default behaviors or
    forcing the compilers to perform certain things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“baseline”: a unique keyword represents the minimal optimizations that configured
    through `--cpu-baseline`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numpy’s infrastructure handles dispatch-able sources in four steps**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(A) Recognition**: Just like source templates and F2PY, the dispatch-able
    sources requires a special extension `*.dispatch.c` to mark C dispatch-able source
    files, and for C++ `*.dispatch.cpp` or `*.dispatch.cxx` **NOTE**: C++ not supported
    yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(B) Parsing and validating**: In this step, the dispatch-able sources that
    had been filtered by the previous step are parsed and validated by the configuration
    statements for each one of them one by one in order to determine the required
    optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(C) Wrapping**: This is the approach taken by NumPy’s infrastructure, which
    has proved to be sufficiently flexible in order to compile a single source multiple
    times with different **C** definitions and flags that affect the code paths. The
    process is achieved by creating a temporary **C** source for each required optimization
    that related to the additional optimization, which contains the declarations of
    the **C** definitions and includes the involved source via the **C** directive
    **#include**. For more clarification take a look at the following code for AVX512F
    :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**(D) Dispatch-able configuration header**: The infrastructure generates a
    config header for each dispatch-able source, this header mainly contains two abstract
    **C** macros used for identifying the generated objects, so they can be used for
    runtime dispatching certain symbols from the generated objects by any **C** source.
    It is also used for forward declarations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generated header takes the name of the dispatch-able source after excluding
    the extension and replace it with `.h`, for example assume we have a dispatch-able
    source called `hello.dispatch.c` and contains the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now assume you attached **hello.dispatch.c** to the source tree, then the infrastructure
    should generate a temporary config header called **hello.dispatch.h** that can
    be reached by any source in the source tree, and it should contain the following
    code :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An example of using the config header in light of the above:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 1- Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Configuring the required optimization by the user before starting to build
    the source files via the two command arguments as explained above:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--cpu-baseline`: minimal set of required optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-dispatch`: dispatched set of additional optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2- Discovering the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this part, we check the compiler and platform architecture and cache some
    of the intermediary results to speed up rebuilding.
  prefs: []
  type: TYPE_NORMAL
- en: 3- Validating the requested optimizations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By testing them against the compiler, and seeing what the compiler can support
    according to the requested optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: 4- Generating the main configuration header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The generated header `_cpu_dispatch.h` contains all the definitions and headers
    of instruction-sets for the required optimizations that have been validated during
    the previous step.
  prefs: []
  type: TYPE_NORMAL
- en: It also contains extra C definitions that are used for defining NumPy’s Python-level
    module attributes `__cpu_baseline__` and `__cpu_dispatch__`.
  prefs: []
  type: TYPE_NORMAL
- en: '**What is in this header?**'
  prefs: []
  type: TYPE_NORMAL
- en: The example header was dynamically generated by gcc on an X86 machine. The compiler
    supports `--cpu-baseline="sse sse2 sse3"` and `--cpu-dispatch="ssse3 sse41"`,
    and the result is below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Baseline features** are the minimal set of required optimizations configured
    via `--cpu-baseline`. They have no preprocessor guards and they’re always on,
    which means they can be used in any source.'
  prefs: []
  type: TYPE_NORMAL
- en: Does this mean NumPy’s infrastructure passes the compiler’s flags of baseline
    features to all sources?
  prefs: []
  type: TYPE_NORMAL
- en: Definitely, yes. But the [dispatch-able sources](#dispatchable-sources) are
    treated differently.
  prefs: []
  type: TYPE_NORMAL
- en: What if the user specifies certain **baseline features** during the build but
    at runtime the machine doesn’t support even these features? Will the compiled
    code be called via one of these definitions, or maybe the compiler itself auto-generated/vectorized
    certain piece of code based on the provided command line compiler flags?
  prefs: []
  type: TYPE_NORMAL
- en: During the loading of the NumPy module, there’s a validation step which detects
    this behavior. It will raise a Python runtime error to inform the user. This is
    to prevent the CPU reaching an illegal instruction error causing a segfault.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dispatch-able features** are our dispatched set of additional optimizations
    that were configured via `--cpu-dispatch`. They are not activated by default and
    are always guarded by other C definitions prefixed with `NPY__CPU_TARGET_`. C
    definitions `NPY__CPU_TARGET_` are only enabled within **dispatch-able sources**.'
  prefs: []
  type: TYPE_NORMAL
- en: '## 5- Dispatch-able sources and configuration statements'
  prefs: []
  type: TYPE_NORMAL
- en: Dispatch-able sources are special **C** files that can be compiled multiple
    times with different compiler flags and also with different **C** definitions.
    These affect code paths to enable certain instruction-sets for each compiled object
    according to “**the configuration statements**” that must be declared between
    a **C** comment`(/**/)` and start with a special mark **@targets** at the top
    of each dispatch-able source. At the same time, dispatch-able sources will be
    treated as normal **C** sources if the optimization was disabled by the command
    argument `--disable-optimization` .
  prefs: []
  type: TYPE_NORMAL
- en: '**What are configuration statements?**'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration statements are sort of keywords combined together to determine
    the required optimization for the dispatch-able source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The keywords mainly represent the additional optimizations configured through
    `--cpu-dispatch`, but it can also represent other options such as:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Target groups: pre-configured configuration statements used for managing the
    required optimizations from outside the dispatch-able source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Policies: collections of options used for changing the default behaviors or
    forcing the compilers to perform certain things.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '“baseline”: a unique keyword represents the minimal optimizations that configured
    through `--cpu-baseline`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Numpy’s infrastructure handles dispatch-able sources in four steps**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(A) Recognition**: Just like source templates and F2PY, the dispatch-able
    sources requires a special extension `*.dispatch.c` to mark C dispatch-able source
    files, and for C++ `*.dispatch.cpp` or `*.dispatch.cxx` **NOTE**: C++ not supported
    yet.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(B) Parsing and validating**: In this step, the dispatch-able sources that
    had been filtered by the previous step are parsed and validated by the configuration
    statements for each one of them one by one in order to determine the required
    optimizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**(C) Wrapping**: This is the approach taken by NumPy’s infrastructure, which
    has proved to be sufficiently flexible in order to compile a single source multiple
    times with different **C** definitions and flags that affect the code paths. The
    process is achieved by creating a temporary **C** source for each required optimization
    that related to the additional optimization, which contains the declarations of
    the **C** definitions and includes the involved source via the **C** directive
    **#include**. For more clarification take a look at the following code for AVX512F
    :'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**(D) Dispatch-able configuration header**: The infrastructure generates a
    config header for each dispatch-able source, this header mainly contains two abstract
    **C** macros used for identifying the generated objects, so they can be used for
    runtime dispatching certain symbols from the generated objects by any **C** source.
    It is also used for forward declarations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The generated header takes the name of the dispatch-able source after excluding
    the extension and replace it with `.h`, for example assume we have a dispatch-able
    source called `hello.dispatch.c` and contains the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now assume you attached **hello.dispatch.c** to the source tree, then the infrastructure
    should generate a temporary config header called **hello.dispatch.h** that can
    be reached by any source in the source tree, and it should contain the following
    code :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'An example of using the config header in light of the above:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
