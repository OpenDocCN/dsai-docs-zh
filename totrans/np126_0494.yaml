- en: Discrete Fourier Transform (numpy.fft)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 离散傅里叶变换（numpy.fft）
- en: 原文：[https://numpy.org/doc/1.26/reference/routines.fft.html](https://numpy.org/doc/1.26/reference/routines.fft.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://numpy.org/doc/1.26/reference/routines.fft.html](https://numpy.org/doc/1.26/reference/routines.fft.html)
- en: The SciPy module [`scipy.fft`](https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft
    "(in SciPy v1.11.2)") is a more comprehensive superset of `numpy.fft`, which includes
    only a basic set of routines.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[SciPy模块](https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft
    "\(在SciPy v1.11.2中\)")[`scipy.fft`](https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft
    "(在SciPy v1.11.2)")是`numpy.fft`的更全面的超集，包括了一个基本的例程。'
- en: Standard FFTs
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准FFT
- en: '| [`fft`](generated/numpy.fft.fft.html#numpy.fft.fft "numpy.fft.fft")(a[, n, axis, norm])
    | Compute the one-dimensional discrete Fourier Transform. |'
  id: totrans-4
  prefs: []
  type: TYPE_TB
  zh: '| [`fft`](generated/numpy.fft.fft.html#numpy.fft.fft "numpy.fft.fft")(a[, n, axis, norm])
    | 计算一维离散傅里叶变换。'
- en: '| [`ifft`](generated/numpy.fft.ifft.html#numpy.fft.ifft "numpy.fft.ifft")(a[, n, axis, norm])
    | Compute the one-dimensional inverse discrete Fourier Transform. |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| [`ifft`](generated/numpy.fft.ifft.html#numpy.fft.ifft "numpy.fft.ifft")(a[, n, axis, norm])
    | 计算一维逆离散傅里叶变换。'
- en: '| [`fft2`](generated/numpy.fft.fft2.html#numpy.fft.fft2 "numpy.fft.fft2")(a[, s, axes, norm])
    | Compute the 2-dimensional discrete Fourier Transform. |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| [`fft2`](generated/numpy.fft.fft2.html#numpy.fft.fft2 "numpy.fft.fft2")(a[, s, axes, norm])
    | 计算二维离散傅里叶变换。'
- en: '| [`ifft2`](generated/numpy.fft.ifft2.html#numpy.fft.ifft2 "numpy.fft.ifft2")(a[, s, axes, norm])
    | Compute the 2-dimensional inverse discrete Fourier Transform. |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| [`ifft2`](generated/numpy.fft.ifft2.html#numpy.fft.ifft2 "numpy.fft.ifft2")(a[, s, axes, norm])
    | 计算二维逆离散傅里叶变换。'
- en: '| [`fftn`](generated/numpy.fft.fftn.html#numpy.fft.fftn "numpy.fft.fftn")(a[, s, axes, norm])
    | Compute the N-dimensional discrete Fourier Transform. |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| [`fftn`](generated/numpy.fft.fftn.html#numpy.fft.fftn "numpy.fft.fftn")(a[, s, axes, norm])
    | 计算N维离散傅里叶变换。'
- en: '| [`ifftn`](generated/numpy.fft.ifftn.html#numpy.fft.ifftn "numpy.fft.ifftn")(a[, s, axes, norm])
    | Compute the N-dimensional inverse discrete Fourier Transform. |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [`ifftn`](generated/numpy.fft.ifftn.html#numpy.fft.ifftn "numpy.fft.ifftn")(a[, s, axes, norm])
    | 计算N维逆离散傅里叶变换。'
- en: Real FFTs
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实FFT
- en: '| [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")(a[, n, axis, norm])
    | Compute the one-dimensional discrete Fourier Transform for real input. |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")(a[, n, axis, norm])
    | 为实输入计算一维离散傅里叶变换。'
- en: '| [`irfft`](generated/numpy.fft.irfft.html#numpy.fft.irfft "numpy.fft.irfft")(a[, n, axis, norm])
    | Computes the inverse of [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft
    "numpy.fft.rfft"). |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| [`irfft`](generated/numpy.fft.irfft.html#numpy.fft.irfft "numpy.fft.irfft")(a[, n, axis, norm])
    | 计算[`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")的逆。'
- en: '| [`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2 "numpy.fft.rfft2")(a[, s, axes, norm])
    | Compute the 2-dimensional FFT of a real array. |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| [`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2 "numpy.fft.rfft2")(a[, s, axes, norm])
    | 计算实数组的二维FFT。'
- en: '| [`irfft2`](generated/numpy.fft.irfft2.html#numpy.fft.irfft2 "numpy.fft.irfft2")(a[, s, axes, norm])
    | Computes the inverse of [`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2
    "numpy.fft.rfft2"). |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| [`irfft2`](generated/numpy.fft.irfft2.html#numpy.fft.irfft2 "numpy.fft.irfft2")(a[, s, axes, norm])
    | 计算[`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2 "numpy.fft.rfft2")的逆。'
- en: '| [`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn "numpy.fft.rfftn")(a[, s, axes, norm])
    | Compute the N-dimensional discrete Fourier Transform for real input. |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| [`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn "numpy.fft.rfftn")(a[, s, axes, norm])
    | 为实输入计算N维离散傅里叶变换。'
- en: '| [`irfftn`](generated/numpy.fft.irfftn.html#numpy.fft.irfftn "numpy.fft.irfftn")(a[, s, axes, norm])
    | Computes the inverse of [`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn
    "numpy.fft.rfftn"). |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| [`irfftn`](generated/numpy.fft.irfftn.html#numpy.fft.irfftn "numpy.fft.irfftn")(a[, s, axes, norm])
    | 计算[`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn "numpy.fft.rfftn")的逆。'
- en: Hermitian FFTs
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 厄米FFT
- en: '| [`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft")(a[, n, axis, norm])
    | Compute the FFT of a signal that has Hermitian symmetry, i.e., a real spectrum.
    |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| [`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft")(a[, n, axis, norm])
    | 计算具有厄米对称性的信号的FFT，即实谱。'
- en: '| [`ihfft`](generated/numpy.fft.ihfft.html#numpy.fft.ihfft "numpy.fft.ihfft")(a[, n, axis, norm])
    | Compute the inverse FFT of a signal that has Hermitian symmetry. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| [`ihfft`](generated/numpy.fft.ihfft.html#numpy.fft.ihfft "numpy.fft.ihfft")(a[, n, axis, norm])
    | 计算具有厄米对称性的信号的逆FFT。'
- en: Helper routines
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助例程
- en: '| [`fftfreq`](generated/numpy.fft.fftfreq.html#numpy.fft.fftfreq "numpy.fft.fftfreq")(n[, d])
    | Return the Discrete Fourier Transform sample frequencies. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| [`fftfreq`](generated/numpy.fft.fftfreq.html#numpy.fft.fftfreq "numpy.fft.fftfreq")(n[, d])
    | 返回离散傅里叶变换的采样频率。'
- en: '| [`rfftfreq`](generated/numpy.fft.rfftfreq.html#numpy.fft.rfftfreq "numpy.fft.rfftfreq")(n[, d])
    | Return the Discrete Fourier Transform sample frequencies (for usage with rfft,
    irfft). |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| [`rfftfreq`](generated/numpy.fft.rfftfreq.html#numpy.fft.rfftfreq "numpy.fft.rfftfreq")(n[, d])
    | 返回离散傅里叶变换的采样频率（在与rfft、irfft一起使用时）。 |'
- en: '| [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift "numpy.fft.fftshift")(x[, axes])
    | Shift the zero-frequency component to the center of the spectrum. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift "numpy.fft.fftshift")(x[, axes])
    | 将零频率分量移至频谱的中心。 |'
- en: '| [`ifftshift`](generated/numpy.fft.ifftshift.html#numpy.fft.ifftshift "numpy.fft.ifftshift")(x[, axes])
    | The inverse of [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift
    "numpy.fft.fftshift"). |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| [`ifftshift`](generated/numpy.fft.ifftshift.html#numpy.fft.ifftshift "numpy.fft.ifftshift")(x[, axes])
    | [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift "numpy.fft.fftshift")的反函数。
    |'
- en: Background information
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景信息
- en: Fourier analysis is fundamentally a method for expressing a function as a sum
    of periodic components, and for recovering the function from those components.
    When both the function and its Fourier transform are replaced with discretized
    counterparts, it is called the discrete Fourier transform (DFT). The DFT has become
    a mainstay of numerical computing in part because of a very fast algorithm for
    computing it, called the Fast Fourier Transform (FFT), which was known to Gauss
    (1805) and was brought to light in its current form by Cooley and Tukey [[CT]](#rfb1dc64dd6a5-ct).
    Press et al. [[NR]](#rfb1dc64dd6a5-nr) provide an accessible introduction to Fourier
    analysis and its applications.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶分析基本上是一种将函数表示为周期性分量之和，并从这些分量中恢复函数的方法。当函数及其傅里叶变换都被替换为离散化的对应物时，就称为离散傅里叶变换(DFT)。DFT在数值计算中已经成为一种主要方法，部分原因是计算DFT的一个非常快速的算法，称为快速傅里叶变换(FFT)，这个算法早在高斯(1805年)之前就被知晓，并由库利和图基以其当前形式公之于众[[CT]](#rfb1dc64dd6a5-ct)。Press等人[[NR]](#rfb1dc64dd6a5-nr)提供了对傅里叶分析及其应用的易于理解的介绍。
- en: Because the discrete Fourier transform separates its input into components that
    contribute at discrete frequencies, it has a great number of applications in digital
    signal processing, e.g., for filtering, and in this context the discretized input
    to the transform is customarily referred to as a *signal*, which exists in the
    *time domain*. The output is called a *spectrum* or *transform* and exists in
    the *frequency domain*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于离散傅里叶变换将输入分解为在离散频率上起作用的分量，所以它在数字信号处理中有很多应用，例如用于滤波，在这种情况下，变换的输入被称为一个*信号*，它存在于*时域*中。输出被称为*频谱*或*变换*，存在于*频域*中。
- en: Implementation details
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现细节
- en: There are many ways to define the DFT, varying in the sign of the exponent,
    normalization, etc. In this implementation, the DFT is defined as
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多方法可以定义离散傅里叶变换(DFT)，可能会涉及到指数符号的正负、归一化等。在这个实现中，DFT的定义如下：
- en: \[A_k = \sum_{m=0}^{n-1} a_m \exp\left\{-2\pi i{mk \over n}\right\} \qquad k
    = 0,\ldots,n-1.\]
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: \[A_k = \sum_{m=0}^{n-1} a_m \exp\left\{-2\pi i{mk \over n}\right\} \qquad k
    = 0,\ldots,n-1.\]
- en: The DFT is in general defined for complex inputs and outputs, and a single-frequency
    component at linear frequency \(f\) is represented by a complex exponential \(a_m
    = \exp\{2\pi i\,f m\Delta t\}\), where \(\Delta t\) is the sampling interval.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: DFT一般来说是针对复数输入和输出定义的，线性频率为\(f\)的单频分量由复指数表示为\(a_m = \exp\{2\pi i\,f m\Delta t\}\)，其中\(\Delta
    t\)为采样间隔。
- en: 'The values in the result follow so-called “standard” order: If `A = fft(a,
    n)`, then `A[0]` contains the zero-frequency term (the sum of the signal), which
    is always purely real for real inputs. Then `A[1:n/2]` contains the positive-frequency
    terms, and `A[n/2+1:]` contains the negative-frequency terms, in order of decreasingly
    negative frequency. For an even number of input points, `A[n/2]` represents both
    positive and negative Nyquist frequency, and is also purely real for real input.
    For an odd number of input points, `A[(n-1)/2]` contains the largest positive
    frequency, while `A[(n+1)/2]` contains the largest negative frequency. The routine
    `np.fft.fftfreq(n)` returns an array giving the frequencies of corresponding elements
    in the output. The routine `np.fft.fftshift(A)` shifts transforms and their frequencies
    to put the zero-frequency components in the middle, and `np.fft.ifftshift(A)`
    undoes that shift.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中的值遵循所谓的“标准”顺序：如果 `A = fft(a, n)`，那么 `A[0]` 包含零频率项（信号的总和），对于实数输入总是纯实的。然后 `A[1:n/2]`
    包含正频率项，而 `A[n/2+1:]` 包含负频率项，按照递减的负频率顺序。对于偶数个输入点，`A[n/2]` 代表正负奈奎斯特频率，并且对于实数输入总是纯实的。对于奇数个输入点，`A[(n-1)/2]`
    包含最大正频率，而 `A[(n+1)/2]` 包含最大负频率。例程 `np.fft.fftfreq(n)` 返回一个数组，其中包含输出元素的频率。例程 `np.fft.fftshift(A)`
    将变换及其频率移动以使零频率分量位于中间，而 `np.fft.ifftshift(A)` 撤销了该移位。
- en: When the input *a* is a time-domain signal and `A = fft(a)`, `np.abs(A)` is
    its amplitude spectrum and `np.abs(A)**2` is its power spectrum. The phase spectrum
    is obtained by `np.angle(A)`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入 *a* 是时域信号，并且 `A = fft(a)`，`np.abs(A)` 是其幅度谱，`np.abs(A)**2` 是其功率谱。相位谱由 `np.angle(A)`
    获得。
- en: The inverse DFT is defined as
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 逆DFT被定义为
- en: \[a_m = \frac{1}{n}\sum_{k=0}^{n-1}A_k\exp\left\{2\pi i{mk\over n}\right\} \qquad
    m = 0,\ldots,n-1.\]
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: \[a_m = \frac{1}{n}\sum_{k=0}^{n-1}A_k\exp\left\{2\pi i{mk\over n}\right\} \qquad
    m = 0,\ldots,n-1.\]
- en: It differs from the forward transform by the sign of the exponential argument
    and the default normalization by \(1/n\).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 它与正向变换的指数参数的符号不同，以及默认标准化为 \(\frac{1}{n}\)。
- en: Type Promotion
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提升
- en: '[`numpy.fft`](#module-numpy.fft "numpy.fft") promotes `float32` and `complex64`
    arrays to `float64` and `complex128` arrays respectively. For an FFT implementation
    that does not promote input arrays, see [`scipy.fftpack`](https://docs.scipy.org/doc/scipy/reference/fftpack.html#module-scipy.fftpack
    "(in SciPy v1.11.2)").'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[`numpy.fft`](#module-numpy.fft "numpy.fft") 将 `float32` 和 `complex64` 数组分别提升为
    `float64` 和 `complex128` 数组。对于不提升输入数组的FFT实现，请参见[`scipy.fftpack`](https://docs.scipy.org/doc/scipy/reference/fftpack.html#module-scipy.fftpack
    "(在SciPy v1.11.2中)")。'
- en: Normalization
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准化
- en: The argument `norm` indicates which direction of the pair of direct/inverse
    transforms is scaled and with what normalization factor. The default normalization
    (`"backward"`) has the direct (forward) transforms unscaled and the inverse (backward)
    transforms scaled by \(1/n\). It is possible to obtain unitary transforms by setting
    the keyword argument `norm` to `"ortho"` so that both direct and inverse transforms
    are scaled by \(1/\sqrt{n}\). Finally, setting the keyword argument `norm` to
    `"forward"` has the direct transforms scaled by \(1/n\) and the inverse transforms
    unscaled (i.e. exactly opposite to the default `"backward"`). *None* is an alias
    of the default option `"backward"` for backward compatibility.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`norm`表示直接/反向变换对的方向和标准化因子。默认的标准化（“backward”）使得直接（正向）变换不经缩放，而反向（逆向）变换经缩放 \(\frac{1}{n}\)。可以通过将关键字参数`norm`设置为`"ortho"`获得单位变换，从而使得直接和逆向变换都经缩放
    \(\frac{1}{\sqrt{n}}\)。最后，通过将关键字参数`norm`设置为`"forward"`，使得直接变换经缩放 \(\frac{1}{n}\)，而逆向变换不经缩放（即与默认的`"backward"`完全相反）。对于向后兼容性，`*None*`是默认选项`"backward"`的别名。
- en: Real and Hermitian transforms
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实部和厄米变换
- en: When the input is purely real, its transform is Hermitian, i.e., the component
    at frequency \(f_k\) is the complex conjugate of the component at frequency \(-f_k\),
    which means that for real inputs there is no information in the negative frequency
    components that is not already available from the positive frequency components.
    The family of [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")
    functions is designed to operate on real inputs, and exploits this symmetry by
    computing only the positive frequency components, up to and including the Nyquist
    frequency. Thus, `n` input points produce `n/2+1` complex output points. The inverses
    of this family assumes the same symmetry of its input, and for an output of `n`
    points uses `n/2+1` input points.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入是纯实数时，其变换是埃尔米特的，即频率\(f_k\)处的分量是频率\(-f_k\)处分量的复共轭，这意味着对于实数输入，负频率分量中没有任何来自正频率分量中不可从中获取的信息。[`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft
    "numpy.fft.rfft") 函数族旨在对实数输入进行操作，并且通过仅计算正频率分量（包括奈奎斯特频率）利用了此对称性。因此，`n`输入点会产生`n/2+1`个复数输出点。这个函数族的逆假设了其输入的对称性，并且对于`n`个点的输出使用`n/2+1`个输入点。
- en: Correspondingly, when the spectrum is purely real, the signal is Hermitian.
    The [`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft") family
    of functions exploits this symmetry by using `n/2+1` complex points in the input
    (time) domain for `n` real points in the frequency domain.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，当频谱是纯实时，信号是埃尔米特的。[`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft")
    函数族利用了这种对称性，使用`n/2+1`输入（时间）域中的复点对`n`频域中的实点。
- en: In higher dimensions, FFTs are used, e.g., for image analysis and filtering.
    The computational efficiency of the FFT means that it can also be a faster way
    to compute large convolutions, using the property that a convolution in the time
    domain is equivalent to a point-by-point multiplication in the frequency domain.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高维度中，会使用FFT，例如用于图像分析和滤波。FFT的计算效率意味着它也可以是计算大型卷积的更快捷方式，利用了时域中卷积等效于频域中逐点相乘的性质。
- en: Higher dimensions
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更高维度
- en: In two dimensions, the DFT is defined as
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维中，DFT的定义如下：
- en: \[A_{kl} = \sum_{m=0}^{M-1} \sum_{n=0}^{N-1} a_{mn}\exp\left\{-2\pi i \left({mk\over
    M}+{nl\over N}\right)\right\} \qquad k = 0, \ldots, M-1;\quad l = 0, \ldots, N-1,\]
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: \[A_{kl} = \sum_{m=0}^{M-1} \sum_{n=0}^{N-1} a_{mn}\exp\left\{-2\pi i \left({mk\over
    M}+{nl\over N}\right)\right\} \qquad k = 0, \ldots, M-1;\quad l = 0, \ldots, N-1,\]
- en: which extends in the obvious way to higher dimensions, and the inverses in higher
    dimensions also extend in the same way.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 它以明显的方式扩展到更高维，而高维中的逆变换也以相同的方式扩展。
- en: References
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考
- en: '[[CT](#id1)]'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[[CT](#id1)]'
- en: 'Cooley, James W., and John W. Tukey, 1965, “An algorithm for the machine calculation
    of complex Fourier series,” *Math. Comput.* 19: 297-301.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cooley, James W., and John W. Tukey, 1965, “The Fast Fourier Transform,” *Math.
    Comput.* 19: 297-301.'
- en: '[[NR](#id2)]'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[[NR](#id2)]'
- en: 'Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P., 2007, *Numerical
    Recipes: The Art of Scientific Computing*, ch. 12-13\. Cambridge Univ. Press,
    Cambridge, UK.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 'Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P., 2007, *Numerical
    Recipes: The Art of Scientific Computing*, 第 12-13 章。剑桥大学出版社，剑桥，英国。'
- en: Examples
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: For examples, see the various functions.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 例如, 请参见各种函数。
- en: Standard FFTs
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标准 FFTs
- en: '| [`fft`](generated/numpy.fft.fft.html#numpy.fft.fft "numpy.fft.fft")(a[, n, axis, norm])
    | Compute the one-dimensional discrete Fourier Transform. |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| [`fft`](generated/numpy.fft.fft.html#numpy.fft.fft "numpy.fft.fft")(a[, n, axis, norm])
    | 计算一维离散傅立叶变换。|'
- en: '| [`ifft`](generated/numpy.fft.ifft.html#numpy.fft.ifft "numpy.fft.ifft")(a[, n, axis, norm])
    | Compute the one-dimensional inverse discrete Fourier Transform. |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| [`ifft`](generated/numpy.fft.ifft.html#numpy.fft.ifft "numpy.fft.ifft")(a[, n, axis, norm])
    | 计算一维离散傅立叶逆变换。|'
- en: '| [`fft2`](generated/numpy.fft.fft2.html#numpy.fft.fft2 "numpy.fft.fft2")(a[, s, axes, norm])
    | Compute the 2-dimensional discrete Fourier Transform. |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| [`fft2`](generated/numpy.fft.fft2.html#numpy.fft.fft2 "numpy.fft.fft2")(a[, s, axes, norm])
    | 计算二维离散傅立叶变换。|'
- en: '| [`ifft2`](generated/numpy.fft.ifft2.html#numpy.fft.ifft2 "numpy.fft.ifft2")(a[, s, axes, norm])
    | Compute the 2-dimensional inverse discrete Fourier Transform. |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| [`ifft2`](generated/numpy.fft.ifft2.html#numpy.fft.ifft2 "numpy.fft.ifft2")(a[, s, axes, norm])
    | 计算二维离散傅立叶逆变换。|'
- en: '| [`fftn`](generated/numpy.fft.fftn.html#numpy.fft.fftn "numpy.fft.fftn")(a[, s, axes, norm])
    | Compute the N-dimensional discrete Fourier Transform. |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| [`fftn`](generated/numpy.fft.fftn.html#numpy.fft.fftn "numpy.fft.fftn")(a[, s, axes, norm])
    | 计算 N 维离散傅立叶变换。|'
- en: '| [`ifftn`](generated/numpy.fft.ifftn.html#numpy.fft.ifftn "numpy.fft.ifftn")(a[, s, axes, norm])
    | Compute the N-dimensional inverse discrete Fourier Transform. |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| [`ifftn`](generated/numpy.fft.ifftn.html#numpy.fft.ifftn "numpy.fft.ifftn")(a[, s, axes, norm])
    | 计算N维离散傅立叶逆变换。'
- en: Real FFTs
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实数FFT
- en: '| [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")(a[, n, axis, norm])
    | Compute the one-dimensional discrete Fourier Transform for real input. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")(a[, n, axis, norm])
    | 为实输入计算一维离散傅立叶变换。'
- en: '| [`irfft`](generated/numpy.fft.irfft.html#numpy.fft.irfft "numpy.fft.irfft")(a[, n, axis, norm])
    | Computes the inverse of [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft
    "numpy.fft.rfft"). |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| [`irfft`](generated/numpy.fft.irfft.html#numpy.fft.irfft "numpy.fft.irfft")(a[, n, axis, norm])
    | 计算[`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")的逆。'
- en: '| [`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2 "numpy.fft.rfft2")(a[, s, axes, norm])
    | Compute the 2-dimensional FFT of a real array. |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| [`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2 "numpy.fft.rfft2")(a[, s, axes, norm])
    | 计算实数组的二维FFT。'
- en: '| [`irfft2`](generated/numpy.fft.irfft2.html#numpy.fft.irfft2 "numpy.fft.irfft2")(a[, s, axes, norm])
    | Computes the inverse of [`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2
    "numpy.fft.rfft2"). |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| [`irfft2`](generated/numpy.fft.irfft2.html#numpy.fft.irfft2 "numpy.fft.irfft2")(a[, s, axes, norm])
    | 计算[`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2 "numpy.fft.rfft2")的逆。'
- en: '| [`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn "numpy.fft.rfftn")(a[, s, axes, norm])
    | Compute the N-dimensional discrete Fourier Transform for real input. |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| [`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn "numpy.fft.rfftn")(a[, s, axes, norm])
    | 为实输入计算N维离散傅立叶变换。'
- en: '| [`irfftn`](generated/numpy.fft.irfftn.html#numpy.fft.irfftn "numpy.fft.irfftn")(a[, s, axes, norm])
    | Computes the inverse of [`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn
    "numpy.fft.rfftn"). |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| [`irfftn`](generated/numpy.fft.irfftn.html#numpy.fft.irfftn "numpy.fft.irfftn")(a[, s, axes, norm])
    | 计算[`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn "numpy.fft.rfftn")的逆。'
- en: Hermitian FFTs
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 共轭对称FFT
- en: '| [`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft")(a[, n, axis, norm])
    | Compute the FFT of a signal that has Hermitian symmetry, i.e., a real spectrum.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| [`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft")(a[, n, axis, norm])
    | 计算具有共轭对称性的信号的FFT，即实谱。'
- en: '| [`ihfft`](generated/numpy.fft.ihfft.html#numpy.fft.ihfft "numpy.fft.ihfft")(a[, n, axis, norm])
    | Compute the inverse FFT of a signal that has Hermitian symmetry. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| [`ihfft`](generated/numpy.fft.ihfft.html#numpy.fft.ihfft "numpy.fft.ihfft")(a[, n, axis, norm])
    | 计算具有共轭对称性的信号的逆FFT。'
- en: Helper routines
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 辅助程序
- en: '| [`fftfreq`](generated/numpy.fft.fftfreq.html#numpy.fft.fftfreq "numpy.fft.fftfreq")(n[, d])
    | Return the Discrete Fourier Transform sample frequencies. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| [`fftfreq`](generated/numpy.fft.fftfreq.html#numpy.fft.fftfreq "numpy.fft.fftfreq")(n[, d])
    | 返回离散傅立叶变换的采样频率。'
- en: '| [`rfftfreq`](generated/numpy.fft.rfftfreq.html#numpy.fft.rfftfreq "numpy.fft.rfftfreq")(n[, d])
    | Return the Discrete Fourier Transform sample frequencies (for usage with rfft,
    irfft). |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| [`rfftfreq`](generated/numpy.fft.rfftfreq.html#numpy.fft.rfftfreq "numpy.fft.rfftfreq")(n[, d])
    | 返回离散傅立叶变换的采样频率（用于rfft、irfft）。'
- en: '| [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift "numpy.fft.fftshift")(x[, axes])
    | Shift the zero-frequency component to the center of the spectrum. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift "numpy.fft.fftshift")(x[, axes])
    | 将零频率分量移至频谱的中心。'
- en: '| [`ifftshift`](generated/numpy.fft.ifftshift.html#numpy.fft.ifftshift "numpy.fft.ifftshift")(x[, axes])
    | The inverse of [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift
    "numpy.fft.fftshift"). |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| [`ifftshift`](generated/numpy.fft.ifftshift.html#numpy.fft.ifftshift "numpy.fft.ifftshift")(x[, axes])
    | [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift "numpy.fft.fftshift")的逆。'
- en: Background information
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 背景信息
- en: Fourier analysis is fundamentally a method for expressing a function as a sum
    of periodic components, and for recovering the function from those components.
    When both the function and its Fourier transform are replaced with discretized
    counterparts, it is called the discrete Fourier transform (DFT). The DFT has become
    a mainstay of numerical computing in part because of a very fast algorithm for
    computing it, called the Fast Fourier Transform (FFT), which was known to Gauss
    (1805) and was brought to light in its current form by Cooley and Tukey [[CT]](#rfb1dc64dd6a5-ct).
    Press et al. [[NR]](#rfb1dc64dd6a5-nr) provide an accessible introduction to Fourier
    analysis and its applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 傅里叶分析基本上是一种将函数表示为周期分量之和的方法，并从这些分量中恢复函数。当函数和它的傅里叶变换都用离散化的对应物代替时，它被称为离散傅里叶变换 (DFT)。DFT已成为数值计算的主要工具之一，部分原因是有一个非常快的计算算法，叫做快速傅里叶变换
    (FFT)，它在高斯时期 (1805年) 就被知晓，并在目前的形式中由库利和图基 [[CT]](#rfb1dc64dd6a5-ct) 揭示出来。Press等人
    [[NR]](#rfb1dc64dd6a5-nr) 提供了对傅里叶分析及其应用的易懂介绍。
- en: Because the discrete Fourier transform separates its input into components that
    contribute at discrete frequencies, it has a great number of applications in digital
    signal processing, e.g., for filtering, and in this context the discretized input
    to the transform is customarily referred to as a *signal*, which exists in the
    *time domain*. The output is called a *spectrum* or *transform* and exists in
    the *frequency domain*.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于离散傅里叶变换将输入分解为在离散频率上有贡献的分量，因此它在数字信号处理中有很多应用，例如滤波，而在此背景下，变换的离散输入通常被称为*信号*，存在于*时域*中。输出称为*频谱*或*变换*，存在于*频域*中。
- en: Implementation details
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现细节
- en: There are many ways to define the DFT, varying in the sign of the exponent,
    normalization, etc. In this implementation, the DFT is defined as
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多方式来定义DFT，包括指数的符号、归一化等。在这个实现中，DFT被定义为
- en: \[A_k = \sum_{m=0}^{n-1} a_m \exp\left\{-2\pi i{mk \over n}\right\} \qquad k
    = 0,\ldots,n-1.\]
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: \[A_k = \sum_{m=0}^{n-1} a_m \exp\left\{-2\pi i{mk \over n}\right\} \qquad k
    = 0,\ldots,n-1.\]
- en: The DFT is in general defined for complex inputs and outputs, and a single-frequency
    component at linear frequency \(f\) is represented by a complex exponential \(a_m
    = \exp\{2\pi i\,f m\Delta t\}\), where \(\Delta t\) is the sampling interval.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: DFT 通常用于复数输入和输出，线性频率 \(f\) 的单频率分量通过复指数 \(a_m = \exp\{2\pi i\,f m\Delta t\}\)
    来表示，其中 \(\Delta t\) 是采样间隔。
- en: 'The values in the result follow so-called “standard” order: If `A = fft(a,
    n)`, then `A[0]` contains the zero-frequency term (the sum of the signal), which
    is always purely real for real inputs. Then `A[1:n/2]` contains the positive-frequency
    terms, and `A[n/2+1:]` contains the negative-frequency terms, in order of decreasingly
    negative frequency. For an even number of input points, `A[n/2]` represents both
    positive and negative Nyquist frequency, and is also purely real for real input.
    For an odd number of input points, `A[(n-1)/2]` contains the largest positive
    frequency, while `A[(n+1)/2]` contains the largest negative frequency. The routine
    `np.fft.fftfreq(n)` returns an array giving the frequencies of corresponding elements
    in the output. The routine `np.fft.fftshift(A)` shifts transforms and their frequencies
    to put the zero-frequency components in the middle, and `np.fft.ifftshift(A)`
    undoes that shift.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 结果中的值按所谓的“标准”顺序排列：如果 `A = fft(a, n)`，那么 `A[0]` 包含零频率项 (信号的总和)，对于实数输入，它始终是纯实数的。然后
    `A[1:n/2]` 包含正频率项，`A[n/2+1:]` 按照逐渐减小的负频率顺序包含负频率项。对于偶数个输入点，`A[n/2]` 表示正负奈奎斯特频率，对于实数输入，它也是纯实数的。对于奇数个输入点，`A[(n-1)/2]`
    包含最大的正频率，而 `A[(n+1)/2]` 包含最大的负频率。例程 `np.fft.fftfreq(n)` 返回一个数组，给出了输出中对应元素的频率。例程
    `np.fft.fftshift(A)` 将变换和它们的频率移位，使得零频率分量位于中间，而 `np.fft.ifftshift(A)` 则撤消了这种移位。
- en: When the input *a* is a time-domain signal and `A = fft(a)`, `np.abs(A)` is
    its amplitude spectrum and `np.abs(A)**2` is its power spectrum. The phase spectrum
    is obtained by `np.angle(A)`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入 *a* 是一个时域信号，且 `A = fft(a)`，`np.abs(A)` 是其幅度谱，`np.abs(A)**2` 是其功率谱。相位谱可以通过
    `np.angle(A)` 得到。
- en: The inverse DFT is defined as
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 逆DFT被定义为
- en: \[a_m = \frac{1}{n}\sum_{k=0}^{n-1}A_k\exp\left\{2\pi i{mk\over n}\right\} \qquad
    m = 0,\ldots,n-1.\]
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: \[a_m = \frac{1}{n}\sum_{k=0}^{n-1}A_k\exp\left\{2\pi i{mk\over n}\right\} \qquad
    m = 0,\ldots,n-1.\]
- en: It differs from the forward transform by the sign of the exponential argument
    and the default normalization by \(1/n\).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 它与正向变换的差别在于指数参数的符号以及默认的归一化因子 \(1/n\)。
- en: Type Promotion
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型提升
- en: '[`numpy.fft`](#module-numpy.fft "numpy.fft") promotes `float32` and `complex64`
    arrays to `float64` and `complex128` arrays respectively. For an FFT implementation
    that does not promote input arrays, see [`scipy.fftpack`](https://docs.scipy.org/doc/scipy/reference/fftpack.html#module-scipy.fftpack
    "(in SciPy v1.11.2)").'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '[`numpy.fft`](#module-numpy.fft "numpy.fft") 将 `float32` 和 `complex64` 数组提升为分别的
    `float64` 和 `complex128` 数组。对于不提升输入数组的FFT实现，请参阅 [`scipy.fftpack`](https://docs.scipy.org/doc/scipy/reference/fftpack.html#module-scipy.fftpack
    "(在SciPy v1.11.2中)").'
- en: Normalization
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 归一化
- en: The argument `norm` indicates which direction of the pair of direct/inverse
    transforms is scaled and with what normalization factor. The default normalization
    (`"backward"`) has the direct (forward) transforms unscaled and the inverse (backward)
    transforms scaled by \(1/n\). It is possible to obtain unitary transforms by setting
    the keyword argument `norm` to `"ortho"` so that both direct and inverse transforms
    are scaled by \(1/\sqrt{n}\). Finally, setting the keyword argument `norm` to
    `"forward"` has the direct transforms scaled by \(1/n\) and the inverse transforms
    unscaled (i.e. exactly opposite to the default `"backward"`). *None* is an alias
    of the default option `"backward"` for backward compatibility.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 参数`norm`指示了一对直接/逆变换的哪个方向被缩放以及使用什么归一化因子。默认的归一化（`"backward"`）使得直接（正向）变换未缩放，而逆（反向）变换则按
    \(1/n\) 缩放。通过将关键字参数`norm`设置为`"ortho"`，可以获得幺正变换，这样直接和逆变换都按 \(1/\sqrt{n}\) 缩放。最后，将关键字参数`norm`设置为`"forward"`将使直接变换按
    \(1/n\) 缩放，而逆变换不进行缩放（即与默认的`"backward"`完全相反）。*None* 是默认选项`"backward"`的一个别名，用于向后兼容性。
- en: Real and Hermitian transforms
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实数和Hermitian变换
- en: When the input is purely real, its transform is Hermitian, i.e., the component
    at frequency \(f_k\) is the complex conjugate of the component at frequency \(-f_k\),
    which means that for real inputs there is no information in the negative frequency
    components that is not already available from the positive frequency components.
    The family of [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")
    functions is designed to operate on real inputs, and exploits this symmetry by
    computing only the positive frequency components, up to and including the Nyquist
    frequency. Thus, `n` input points produce `n/2+1` complex output points. The inverses
    of this family assumes the same symmetry of its input, and for an output of `n`
    points uses `n/2+1` input points.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入纯粹为实数时，其变换是Hermitian的，即，在频率\(f_k\)处的分量是频率\(-f_k\)处分量的复共轭，这意味着对于实数输入，在负频率分量中没有额外的信息，这些信息在正频率分量中已经可用。[`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft
    "numpy.fft.rfft") 函数族旨在处理实数输入，并通过仅计算正频率分量来利用这种对称性，直至包括奈奎斯特频率。因此，`n` 个输入点产生 `n/2+1`
    个复数输出点。这个函数族的反变换假设其输入具有相同的对称性，对于 `n` 个点的输出使用 `n/2+1` 个输入点。
- en: Correspondingly, when the spectrum is purely real, the signal is Hermitian.
    The [`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft") family
    of functions exploits this symmetry by using `n/2+1` complex points in the input
    (time) domain for `n` real points in the frequency domain.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 相应地，当频谱纯粹为实时，信号为Hermitian。[`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft
    "numpy.fft.hfft") 函数族利用这种对称性，使用 `n/2+1` 个复数点作为输入（时间）域，用于 `n` 个实数点的频率域。
- en: In higher dimensions, FFTs are used, e.g., for image analysis and filtering.
    The computational efficiency of the FFT means that it can also be a faster way
    to compute large convolutions, using the property that a convolution in the time
    domain is equivalent to a point-by-point multiplication in the frequency domain.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高维度中，FFT被用于图像分析和滤波等任务。FFT的计算效率意味着它也可以是计算大卷积的一种更快捷的方法，利用了时域中的卷积等于频域中按点相乘的属性。
- en: Higher dimensions
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更高维度
- en: In two dimensions, the DFT is defined as
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维中，DFT被定义为
- en: \[A_{kl} = \sum_{m=0}^{M-1} \sum_{n=0}^{N-1} a_{mn}\exp\left\{-2\pi i \left({mk\over
    M}+{nl\over N}\right)\right\} \qquad k = 0, \ldots, M-1;\quad l = 0, \ldots, N-1,\]
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: \[A_{kl} = \sum_{m=0}^{M-1} \sum_{n=0}^{N-1} a_{mn}\exp\left\{-2\pi i \left({mk\over
    M}+{nl\over N}\right)\right\} \qquad k = 0, \ldots, M-1;\quad l = 0, \ldots, N-1,\]
- en: which extends in the obvious way to higher dimensions, and the inverses in higher
    dimensions also extend in the same way.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式直观地扩展到更高维度，而在更高维度中的逆变换也是以相同的方式扩展的。
- en: References
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: '[[CT](#id1)]'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[[CT](#id1)]'
- en: 'Cooley, James W., and John W. Tukey, 1965, “An algorithm for the machine calculation
    of complex Fourier series,” *Math. Comput.* 19: 297-301.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 'Cooley, James W., 和 John W. Tukey, 1965, “用于计算复傅里叶级数的算法,” *Math. Comput.* 19:
    297-301.'
- en: '[[NR](#id2)]'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[[NR](#id2)]'
- en: 'Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P., 2007, *Numerical
    Recipes: The Art of Scientific Computing*, ch. 12-13\. Cambridge Univ. Press,
    Cambridge, UK.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 'Press, W., Teukolsky, S., Vetterline, W.T., 和 Flannery, B.P., 2007, *Numerical
    Recipes: The Art of Scientific Computing*, ch. 12-13\. 剑桥大学出版社, 剑桥, 英国.'
- en: Examples
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 例子
- en: For examples, see the various functions.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 有关例子，请参见各种函数。
