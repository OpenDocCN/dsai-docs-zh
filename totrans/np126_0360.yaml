- en: numpy.block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.block.html](https://numpy.org/doc/1.26/reference/generated/numpy.block.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Assemble an nd-array from nested lists of blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks in the innermost lists are concatenated (see [`concatenate`](numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate")) along the last dimension (-1), then these are concatenated
    along the second-last dimension (-2), and so on until the outermost list is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Blocks can be of any dimension, but will not be broadcasted using the normal
    rules. Instead, leading axes of size 1 are inserted, to make `block.ndim` the
    same for all blocks. This is primarily useful for working with scalars, and means
    that code like `np.block([v, 1])` is valid, where `v.ndim == 1`.
  prefs: []
  type: TYPE_NORMAL
- en: When the nested list is two levels deep, this allows block matrices to be constructed
    from their components.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.13.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**arrays**nested list of array_like or scalars (but not tuples)'
  prefs: []
  type: TYPE_NORMAL
- en: If passed a single ndarray or scalar (a nested list of depth 0), this is returned
    unmodified (and not copied).
  prefs: []
  type: TYPE_NORMAL
- en: Elements shapes must match along the appropriate axes (without broadcasting),
    but leading 1s will be prepended to the shape as necessary to make the dimensions
    match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**block_array**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The array assembled from the given blocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The dimensionality of the output is equal to the greatest of: * the dimensionality
    of all the inputs * the depth to which the input list is nested'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: ValueError
  prefs: []
  type: TYPE_NORMAL
- en: If list depths are mismatched - for instance, `[[a, b], c]` is illegal, and
    should be spelt `[[a, b], [c]]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If lists are empty - for instance, `[[a, b], []]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`concatenate`](numpy.concatenate.html#numpy.concatenate "numpy.concatenate")'
  prefs: []
  type: TYPE_NORMAL
- en: Join a sequence of arrays along an existing axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[`stack`](numpy.stack.html#numpy.stack "numpy.stack")'
  prefs: []
  type: TYPE_NORMAL
- en: Join a sequence of arrays along a new axis.
  prefs: []
  type: TYPE_NORMAL
- en: '[`vstack`](numpy.vstack.html#numpy.vstack "numpy.vstack")'
  prefs: []
  type: TYPE_NORMAL
- en: Stack arrays in sequence vertically (row wise).
  prefs: []
  type: TYPE_NORMAL
- en: '[`hstack`](numpy.hstack.html#numpy.hstack "numpy.hstack")'
  prefs: []
  type: TYPE_NORMAL
- en: Stack arrays in sequence horizontally (column wise).
  prefs: []
  type: TYPE_NORMAL
- en: '[`dstack`](numpy.dstack.html#numpy.dstack "numpy.dstack")'
  prefs: []
  type: TYPE_NORMAL
- en: Stack arrays in sequence depth wise (along third axis).
  prefs: []
  type: TYPE_NORMAL
- en: '[`column_stack`](numpy.column_stack.html#numpy.column_stack "numpy.column_stack")'
  prefs: []
  type: TYPE_NORMAL
- en: Stack 1-D arrays as columns into a 2-D array.
  prefs: []
  type: TYPE_NORMAL
- en: '[`vsplit`](numpy.vsplit.html#numpy.vsplit "numpy.vsplit")'
  prefs: []
  type: TYPE_NORMAL
- en: Split an array into multiple sub-arrays vertically (row-wise).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: When called with only scalars, `np.block` is equivalent to an ndarray call.
    So `np.block([[1, 2], [3, 4]])` is equivalent to `np.array([[1, 2], [3, 4]])`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function does not enforce that the blocks lie on a fixed grid. `np.block([[a,
    b], [c, d]])` is not restricted to arrays of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'But is also allowed to produce, for some `a, b, c, d`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Since concatenation happens along the last axis first, [`block`](#numpy.block
    "numpy.block") is _not_ capable of producing the following directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Matlab’s “square bracket stacking”, `[A, B, ...; p, q, ...]`, is equivalent
    to `np.block([[A, B, ...], [p, q, ...]])`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: The most common use of this function is to build a block matrix
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With a list of depth 1, [`block`](#numpy.block "numpy.block") can be used as
    [`hstack`](numpy.hstack.html#numpy.hstack "numpy.hstack")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With a list of depth 2, [`block`](#numpy.block "numpy.block") can be used in
    place of [`vstack`](numpy.vstack.html#numpy.vstack "numpy.vstack"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It can also be used in places of [`atleast_1d`](numpy.atleast_1d.html#numpy.atleast_1d
    "numpy.atleast_1d") and [`atleast_2d`](numpy.atleast_2d.html#numpy.atleast_2d
    "numpy.atleast_2d")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
