- en: Calculus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/tutorials/intro-tutorial/calculus.html](https://docs.sympy.org/latest/tutorials/intro-tutorial/calculus.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section covers how to do basic calculus tasks such as derivatives, integrals,
    limits, and series expansions in SymPy. If you are not familiar with the math
    of any part of this section, you may safely skip it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '## Derivatives'
  prefs: []
  type: TYPE_NORMAL
- en: To take derivatives, use the `diff` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`diff` can take multiple derivatives at once. To take multiple derivatives,
    pass the variable as many times as you wish to differentiate, or pass a number
    after the variable. For example, both of the following find the third derivative
    of \(x^4\).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You can also take derivatives with respect to many variables at once. Just pass
    each derivative in order, using the same syntax as for single variable derivatives.
    For example, each of the following will compute \(\frac{\partial^7}{\partial x\partial
    y^2\partial z^4} e^{x y z}\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '`diff` can also be called as a method. The two ways of calling `diff` are exactly
    the same, and are provided only for convenience.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To create an unevaluated derivative, use the `Derivative` class. It has the
    same syntax as `diff`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To evaluate an unevaluated derivative, use the `doit` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These unevaluated objects are useful for delaying the evaluation of the derivative,
    or for printing purposes. They are also used when SymPy does not know how to compute
    the derivative of an expression (for example, if it contains an undefined function,
    which are described in the [Solving Differential Equations](solvers.html#tutorial-dsolve)
    section).
  prefs: []
  type: TYPE_NORMAL
- en: Derivatives of unspecified order can be created using tuple `(x, n)` where `n`
    is the order of the derivative with respect to `x`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Integrals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To compute an integral, use the `integrate` function. There are two kinds of
    integrals, definite and indefinite. To compute an indefinite integral, that is,
    an antiderivative, or primitive, just pass the variable after the expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that SymPy does not include the constant of integration. If you want it,
    you can add one yourself, or rephrase your problem as a differential equation
    and use `dsolve` to solve it, which does add the constant (see [Solving Differential
    Equations](solvers.html#tutorial-dsolve)).
  prefs: []
  type: TYPE_NORMAL
- en: To compute a definite integral, pass the argument `(integration_variable, lower_limit,
    upper_limit)`. For example, to compute
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_0^\infty e^{-x}\,dx,\]
  prefs: []
  type: TYPE_NORMAL
- en: we would do
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As with indefinite integrals, you can pass multiple limit tuples to perform
    a multiple integral. For example, to compute
  prefs: []
  type: TYPE_NORMAL
- en: \[\int_{-\infty}^{\infty}\int_{-\infty}^{\infty} e^{- x^{2} - y^{2}}\, dx\,
    dy,\]
  prefs: []
  type: TYPE_NORMAL
- en: do
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If `integrate` is unable to compute an integral, it returns an unevaluated `Integral`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As with `Derivative`, you can create an unevaluated integral using `Integral`.
    To later evaluate this integral, call `doit`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`integrate` uses powerful algorithms that are always improving to compute both
    definite and indefinite integrals, including heuristic pattern matching type algorithms,
    a partial implementation of the [Risch algorithm](https://en.wikipedia.org/wiki/Risch_algorithm),
    and an algorithm using [Meijer G-functions](https://en.wikipedia.org/wiki/Meijer_g-function)
    that is useful for computing integrals in terms of special functions, especially
    definite integrals. Here is a sampling of some of the power of `integrate`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This last example returned a `Piecewise` expression because the integral does
    not converge unless \(\Re(y) > -1.\)
  prefs: []
  type: TYPE_NORMAL
- en: Numeric Integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Numeric integration is a method employed in mathematical analysis to estimate
    the definite integral of a function across a simplified range. SymPy not only
    facilitates symbolic integration but also provides support for numeric integration.
    It leverages the precision capabilities of the `mpmath` library to enhance the
    accuracy of numeric integration calculations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the integral with a specified precision:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Numeric integration becomes a viable approach in situations where symbolic
    integration is impractical or impossible. This method allows for the computation
    of integrals through numerical techniques, even when dealing with infinite intervals
    or integrands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy can compute symbolic limits with the `limit` function. The syntax to compute
  prefs: []
  type: TYPE_NORMAL
- en: \[\lim_{x\to x_0} f(x)\]
  prefs: []
  type: TYPE_NORMAL
- en: is `limit(f(x), x, x0)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`limit` should be used instead of `subs` whenever the point of evaluation is
    a singularity. Even though SymPy has objects to represent \(\infty\), using them
    for evaluation is not reliable because they do not keep track of things like rate
    of growth. Also, things like \(\infty - \infty\) and \(\frac{\infty}{\infty}\)
    return \(\mathrm{nan}\) (not-a-number). For example'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Like `Derivative` and `Integral`, `limit` has an unevaluated counterpart, `Limit`.
    To evaluate it, use `doit`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: To evaluate a limit at one side only, pass `'+'` or `'-'` as a fourth argument
    to `limit`. For example, to compute
  prefs: []
  type: TYPE_NORMAL
- en: \[\lim_{x\to 0^+}\frac{1}{x},\]
  prefs: []
  type: TYPE_NORMAL
- en: do
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As opposed to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Series Expansion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy can compute asymptotic series expansions of functions around a point.
    To compute the expansion of \(f(x)\) around the point \(x = x_0\) terms of order
    \(x^n\), use `f(x).series(x, x0, n)`. `x0` and `n` can be omitted, in which case
    the defaults `x0=0` and `n=6` will be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The \(O\left(x^4\right)\) term at the end represents the Landau order term at
    \(x=0\) (not to be confused with big O notation used in computer science, which
    generally represents the Landau order term at \(x\) where \(x \rightarrow \infty\)).
    It means that all x terms with power greater than or equal to \(x^4\) are omitted.
    Order terms can be created and manipulated outside of `series`. They automatically
    absorb higher order terms.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you do not want the order term, use the `removeO` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `O` notation supports arbitrary limit points (other than 0):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '## Finite differences'
  prefs: []
  type: TYPE_NORMAL
- en: So far we have looked at expressions with analytic derivatives and primitive
    functions respectively. But what if we want to have an expression to estimate
    a derivative of a curve for which we lack a closed form representation, or for
    which we don’t know the functional values for yet. One approach would be to use
    a finite difference approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way the differentiate using finite differences is to use the `differentiate_finite`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If you already have a `Derivative` instance, you can use the `as_finite_difference`
    method to generate approximations of the derivative to arbitrary order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'here the first order derivative was approximated around x using a minimum number
    of points (2 for 1st order derivative) evaluated equidistantly using a step-size
    of 1\. We can use arbitrary steps (possibly containing symbolic expressions):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are just interested in evaluating the weights, you can do so manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: note that we only need the last element in the last sublist returned from `finite_diff_weights`.
    The reason for this is that the function also generates weights for lower derivatives
    and using fewer points (see the documentation of `finite_diff_weights` for more
    details).
  prefs: []
  type: TYPE_NORMAL
- en: 'If using `finite_diff_weights` directly looks complicated, and the `as_finite_difference`
    method of `Derivative` instances is not flexible enough, you can use `apply_finite_diff`
    which takes `order`, `x_list`, `y_list` and `x0` as parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
