- en: Predicates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/assumptions/predicates.html](https://docs.sympy.org/latest/modules/assumptions/predicates.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Common'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Generic predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.is_true(x))` is true iff `x` is true. This only makes sense if `x` is
    a boolean object.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping another applied predicate just returns the applied predicate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Wrapping binary relation classes in SymPy core returns applied binary relational
    predicates.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This class is designed to wrap the boolean objects so that they can behave as
    if they are applied predicates. Consequently, wrapping another applied predicate
    is unnecessary and thus it just returns the argument. Also, binary relation classes
    in SymPy core have binary predicates to represent themselves and thus wrapping
    them with `Q.is_true` converts them to these applied predicates.
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: IsTrueHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapper allowing to query the truth value of a boolean expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Commutative predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.commutative(x))` is true iff `x` commutes with any other object with
    respect to multiplication operation.'
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: CommutativeHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘commutative’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Calculus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Finite number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.finite(x)` is true if `x` is a number but neither an infinity nor a `NaN`.
    In other words, `ask(Q.finite(x))` is true for all numerical `x` having a bounded
    absolute value.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: FiniteHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.finite. Test that an expression is bounded respect to all its
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R9](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Finite](https://en.wikipedia.org/wiki/Finite)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Infinite number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.infinite(x)` is true iff the absolute value of `x` is infinity.'
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: InfiniteHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.infinite key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Matrix
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Symmetric matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.symmetric(x)` is true iff `x` is a square matrix and is equal to its transpose.
    Every square diagonal matrix is a symmetric matrix.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: SymmetricHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R10](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Symmetric_matrix](https://en.wikipedia.org/wiki/Symmetric_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Invertible matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.invertible(x)` is true iff `x` is an invertible matrix. A square matrix
    is called invertible only if its determinant is 0.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: InvertibleHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.invertible.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R11](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Invertible_matrix](https://en.wikipedia.org/wiki/Invertible_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Orthogonal matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.orthogonal(x)` is true iff `x` is an orthogonal matrix. A square matrix
    `M` is an orthogonal matrix if it satisfies `M^TM = MM^T = I` where `M^T` is the
    transpose matrix of `M` and `I` is an identity matrix. Note that an orthogonal
    matrix is necessarily invertible.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: OrthogonalHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘orthogonal’.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R12](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Orthogonal_matrix](https://en.wikipedia.org/wiki/Orthogonal_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Unitary matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.unitary(x)` is true iff `x` is a unitary matrix. Unitary matrix is an analogue
    to orthogonal matrix. A square matrix `M` with complex elements is unitary if
    :math:`M^TM = MM^T= I` where :math:`M^T` is the conjugate transpose matrix of
    `M`.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: UnitaryHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘unitary’.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R13](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Unitary_matrix](https://en.wikipedia.org/wiki/Unitary_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Positive definite matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If \(M\) is a \(n \times n\) symmetric real matrix, it is said to be positive
    definite if \(Z^TMZ\) is positive for every non-zero column vector \(Z\) of \(n\)
    real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: PositiveDefiniteHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘positive_definite’.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R14](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Positive-definite_matrix](https://en.wikipedia.org/wiki/Positive-definite_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Upper triangular matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A matrix \(M\) is called upper triangular matrix if \(M_{ij}=0\) for \(i<j\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: UpperTriangularHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘upper_triangular’.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R15](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/UpperTriangularMatrix.html](https://mathworld.wolfram.com/UpperTriangularMatrix.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Lower triangular matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A matrix \(M\) is called lower triangular matrix if \(M_{ij}=0\) for \(i>j\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: LowerTriangularHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘lower_triangular’.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R16](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/LowerTriangularMatrix.html](https://mathworld.wolfram.com/LowerTriangularMatrix.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Diagonal matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.diagonal(x)` is true iff `x` is a diagonal matrix. A diagonal matrix is
    a matrix in which the entries outside the main diagonal are all zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: DiagonalHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘diagonal’.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R17](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Diagonal_matrix](https://en.wikipedia.org/wiki/Diagonal_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Fullrank matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.fullrank(x)` is true iff `x` is a full rank matrix. A matrix is full rank
    if all rows and columns of the matrix are linearly independent. A square matrix
    is full rank iff its determinant is nonzero.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: FullRankHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘fullrank’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Square matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.square(x)` is true iff `x` is a square matrix. A square matrix is a matrix
    with the same number of rows and columns.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: SquareHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.square.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R18](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Square_matrix](https://en.wikipedia.org/wiki/Square_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Integer elements matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.integer_elements(x)` is true iff all the elements of `x` are integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: IntegerElementsHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘integer_elements’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Real elements matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.real_elements(x)` is true iff all the elements of `x` are real numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: RealElementsHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘real_elements’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Complex elements matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.complex_elements(x)` is true iff all the elements of `x` are complex numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: ComplexElementsHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘complex_elements’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Singular matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: A matrix is singular iff the value of its determinant is 0.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: SingularHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate fore key ‘singular’.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R19](#id12)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/SingularMatrix.html](https://mathworld.wolfram.com/SingularMatrix.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Normal matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: A matrix is normal if it commutes with its conjugate transpose.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: NormalHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate fore key ‘normal’.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R20](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Normal_matrix](https://en.wikipedia.org/wiki/Normal_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Triangular matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.triangular(X)` is true if `X` is one that is either lower triangular or
    upper triangular.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: TriangularHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate fore key ‘triangular’.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R21](#id14)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Triangular_matrix](https://en.wikipedia.org/wiki/Triangular_matrix)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Unit triangular matrix predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A unit triangular matrix is a triangular matrix with 1s on the diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: UnitTriangularHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Predicate fore key ‘unit_triangular’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Number Theory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Even number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.even(x))` is true iff `x` belongs to the set of even integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: EvenHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘even’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Odd number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.odd(x))` is true iff `x` belongs to the set of odd numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: OddHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘odd’. Test that an expression represents an odd number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Prime number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.prime(x))` is true iff `x` is a natural number greater than 1 that has
    no positive divisors other than `1` and the number itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: PrimeHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘prime’. Test that an expression represents a prime number.
    When the expression is an exact number, the result (when True) is subject to the
    limitations of isprime() which is used to return the result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Composite number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.composite(x))` is true iff `x` is a positive integer and has at least
    one positive divisor other than `1` and the number itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: CompositeHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘composite’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Order
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Positive real number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.positive(x)` is true iff `x` is real and \(x > 0\), that is if `x` is in
    the interval \((0, \infty)\). In particular, infinity is not positive.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important facts about positive numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `Q.nonpositive` and `~Q.positive` are *not* the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: thing. `~Q.positive(x)` simply means that `x` is not positive, whereas `Q.nonpositive(x)`
    means that `x` is real and not positive, i.e., `Q.nonpositive(x)` is logically
    equivalent to \(Q.negative(x) | Q.zero(x)`\). So for example, `~Q.positive(I)`
    is true, whereas `Q.nonpositive(I)` is false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See the documentation of `Q.real` for more information about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: related facts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: PositiveHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘positive’. Test that an expression is strictly greater than
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Negative number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.negative(x)` is true iff `x` is a real number and \(x < 0\), that is, it
    is in the interval \((-\infty, 0)\). Note in particular that negative infinity
    is not negative.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important facts about negative numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `Q.nonnegative` and `~Q.negative` are *not* the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: thing. `~Q.negative(x)` simply means that `x` is not negative, whereas `Q.nonnegative(x)`
    means that `x` is real and not negative, i.e., `Q.nonnegative(x)` is logically
    equivalent to `Q.zero(x) | Q.positive(x)`. So for example, `~Q.negative(I)` is
    true, whereas `Q.nonnegative(I)` is false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See the documentation of `Q.real` for more information about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: related facts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: NegativeHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.negative. Test that an expression is strictly less than zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Zero number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.zero(x))` is true iff the value of `x` is zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: ZeroHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘zero’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Nonzero real number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.nonzero(x))` is true iff `x` is real and `x` is not zero. Note in particular
    that `Q.nonzero(x)` is false if `x` is not real. Use `~Q.zero(x)` if you want
    the negation of being zero without any real assumptions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important facts about nonzero numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.nonzero` is logically equivalent to `Q.positive | Q.negative`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the documentation of `Q.real` for more information about
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: related facts.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: NonZeroHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘nonzero’. Test that an expression is not identically zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Nonpositive real number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.nonpositive(x))` is true iff `x` belongs to the set of negative numbers
    including zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `Q.nonpositive` and `~Q.positive` are *not* the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: thing. `~Q.positive(x)` simply means that `x` is not positive, whereas `Q.nonpositive(x)`
    means that `x` is real and not positive, i.e., `Q.nonpositive(x)` is logically
    equivalent to \(Q.negative(x) | Q.zero(x)`\). So for example, `~Q.positive(I)`
    is true, whereas `Q.nonpositive(I)` is false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: NonPositiveHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key ‘nonpositive’.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Nonnegative real number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.nonnegative(x))` is true iff `x` belongs to the set of positive numbers
    including zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that `Q.nonnegative` and `~Q.negative` are *not* the same
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: thing. `~Q.negative(x)` simply means that `x` is not negative, whereas `Q.nonnegative(x)`
    means that `x` is real and not negative, i.e., `Q.nonnegative(x)` is logically
    equivalent to `Q.zero(x) | Q.positive(x)`. So for example, `~Q.negative(I)` is
    true, whereas `Q.nonnegative(I)` is false.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: NonNegativeHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.nonnegative.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Integer predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.integer(x)` is true iff `x` belongs to the set of integer numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: IntegerHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.integer.
  prefs: []
  type: TYPE_NORMAL
- en: Test that an expression belongs to the field of integer numbers.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R22](#id15)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Integer](https://en.wikipedia.org/wiki/Integer)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Rational number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.rational(x)` is true iff `x` belongs to the set of rational numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: RationalHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.rational.
  prefs: []
  type: TYPE_NORMAL
- en: Test that an expression belongs to the field of rational numbers.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R23](#id16)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Rational_number](https://en.wikipedia.org/wiki/Rational_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Irrational number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.irrational(x)` is true iff `x` is any real number that cannot be expressed
    as a ratio of integers.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: IrrationalHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.irrational.
  prefs: []
  type: TYPE_NORMAL
- en: Test that an expression is irrational numbers.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R24](#id17)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Irrational_number](https://en.wikipedia.org/wiki/Irrational_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Real number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.real(x)` is true iff `x` is a real number, i.e., it is in the interval \((-\infty,
    \infty)\). Note that, in particular the infinities are not real. Use `Q.extended_real`
    if you want to consider those as well.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A few important facts about reals:'
  prefs: []
  type: TYPE_NORMAL
- en: Every real number is positive, negative, or zero. Furthermore,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: because these sets are pairwise disjoint, each real number is exactly one of
    those three.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Every real number is also complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every real number is finite.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every real number is either rational or irrational.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every real number is either algebraic or transcendental.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The facts `Q.negative`, `Q.zero`, `Q.positive`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Q.nonnegative`, `Q.nonpositive`, `Q.nonzero`, `Q.integer`, `Q.rational`, and
    `Q.irrational` all imply `Q.real`, as do all facts that imply those facts.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The facts `Q.algebraic`, and `Q.transcendental` do not imply
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Q.real`; they imply `Q.complex`. An algebraic or transcendental number may
    or may not be real.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The “non” facts (i.e., `Q.nonnegative`, `Q.nonzero`,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Q.nonpositive` and `Q.noninteger`) are not equivalent to not the fact, but
    rather, not the fact *and* `Q.real`. For example, `Q.nonnegative` means `~Q.negative
    & Q.real`. So for example, `I` is not nonnegative, nonzero, or nonpositive.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: RealHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.real.
  prefs: []
  type: TYPE_NORMAL
- en: Test that an expression belongs to the field of real numbers.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R25](#id18)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Real_number](https://en.wikipedia.org/wiki/Real_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Extended real predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.extended_real(x)` is true iff `x` is a real number or \(\{-\infty, \infty\}\).'
  prefs: []
  type: TYPE_NORMAL
- en: See documentation of `Q.real` for more information about related facts.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: ExtendedRealHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.extended_real.
  prefs: []
  type: TYPE_NORMAL
- en: Test that an expression belongs to the field of extended real
  prefs: []
  type: TYPE_NORMAL
- en: numbers, that is real numbers union {Infinity, -Infinity}.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Hermitian predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`ask(Q.hermitian(x))` is true iff `x` belongs to the set of Hermitian operators.'
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: HermitianHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.hermitian.
  prefs: []
  type: TYPE_NORMAL
- en: Test that an expression belongs to the field of Hermitian operators.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R26](#id19)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/HermitianOperator.html](https://mathworld.wolfram.com/HermitianOperator.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Complex number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.complex(x)` is true iff `x` belongs to the set of complex numbers. Note
    that every complex number is finite.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: ComplexHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.complex.
  prefs: []
  type: TYPE_NORMAL
- en: Test that an expression belongs to the field of complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R27](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Complex_number](https://en.wikipedia.org/wiki/Complex_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Imaginary number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.imaginary(x)` is true iff `x` can be written as a real number multiplied
    by the imaginary unit `I`. Please note that `0` is not considered to be an imaginary
    number.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: ImaginaryHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.imaginary.
  prefs: []
  type: TYPE_NORMAL
- en: Test that an expression belongs to the field of imaginary numbers,
  prefs: []
  type: TYPE_NORMAL
- en: that is, numbers in the form x*I, where x is real.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R28](#id21)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Imaginary_number](https://en.wikipedia.org/wiki/Imaginary_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Antihermitian predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.antihermitian(x)` is true iff `x` belongs to the field of antihermitian
    operators, i.e., operators in the form `x*I`, where `x` is Hermitian.'
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: AntiHermitianHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.antihermitian.
  prefs: []
  type: TYPE_NORMAL
- en: Test that an expression belongs to the field of anti-Hermitian
  prefs: []
  type: TYPE_NORMAL
- en: operators, that is, operators in the form x*I, where x is Hermitian.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R29](#id22)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://mathworld.wolfram.com/HermitianOperator.html](https://mathworld.wolfram.com/HermitianOperator.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Algebraic number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.algebraic(x)` is true iff `x` belongs to the set of algebraic numbers. `x`
    is algebraic if there is some polynomial in `p(x)\in \mathbb\{Q\}[x]` such that
    `p(x) = 0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: AskAlgebraicpredicateHandler'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for key AskAlgebraicpredicateHandler
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R30](#id23)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Algebraic_number](https://en.wikipedia.org/wiki/Algebraic_number)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Transcedental number predicate.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Q.transcendental(x)` is true iff `x` belongs to the set of transcendental
    numbers. A transcendental number is a real or complex number that is not algebraic.'
  prefs: []
  type: TYPE_NORMAL
- en: Handler
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiply dispatched method: Transcendental'
  prefs: []
  type: TYPE_NORMAL
- en: Handler for Q.transcendental key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
