["```py\nclass sympy.vector.coordsysrect.CoordSys3D(name, transformation=None, parent=None, location=None, rotation_matrix=None, vector_names=None, variable_names=None)\n```", "```py\n__init__(name, location=None, rotation_matrix=None, parent=None, vector_names=None, variable_names=None, latex_vects=None, pretty_vects=None, latex_scalars=None, pretty_scalars=None, transformation=None)\n```", "```py\ncreate_new(name, transformation, variable_names=None, vector_names=None)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> a = CoordSys3D('a')\n>>> b = a.create_new('b', transformation='spherical')\n>>> b.transformation_to_parent()\n(b.r*sin(b.theta)*cos(b.phi), b.r*sin(b.phi)*sin(b.theta), b.r*cos(b.theta))\n>>> b.transformation_from_parent()\n(sqrt(a.x**2 + a.y**2 + a.z**2), acos(a.z/sqrt(a.x**2 + a.y**2 + a.z**2)), atan2(a.y, a.x)) \n```", "```py\nlocate_new(name, position, vector_names=None, variable_names=None)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> A = CoordSys3D('A')\n>>> B = A.locate_new('B', 10 * A.i)\n>>> B.origin.position_wrt(A.origin)\n10*A.i \n```", "```py\norient_new(name, orienters, location=None, vector_names=None, variable_names=None)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> from sympy import symbols\n>>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n>>> N = CoordSys3D('N') \n```", "```py\n>>> from sympy.vector import AxisOrienter\n>>> axis_orienter = AxisOrienter(q1, N.i + 2 * N.j)\n>>> A = N.orient_new('A', (axis_orienter, )) \n```", "```py\n>>> from sympy.vector import BodyOrienter\n>>> body_orienter = BodyOrienter(q1, q2, q3, '123')\n>>> B = N.orient_new('B', (body_orienter, )) \n```", "```py\n>>> from sympy.vector import SpaceOrienter\n>>> space_orienter = SpaceOrienter(q1, q2, q3, '312')\n>>> C = N.orient_new('C', (space_orienter, )) \n```", "```py\n>>> from sympy.vector import QuaternionOrienter\n>>> q_orienter = QuaternionOrienter(q0, q1, q2, q3)\n>>> D = N.orient_new('D', (q_orienter, )) \n```", "```py\norient_new_axis(name, angle, axis, location=None, vector_names=None, variable_names=None)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> from sympy import symbols\n>>> q1 = symbols('q1')\n>>> N = CoordSys3D('N')\n>>> B = N.orient_new_axis('B', q1, N.i + 2 * N.j) \n```", "```py\norient_new_body(name, angle1, angle2, angle3, rotation_order, location=None, vector_names=None, variable_names=None)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> from sympy import symbols\n>>> q1, q2, q3 = symbols('q1 q2 q3')\n>>> N = CoordSys3D('N') \n```", "```py\n>>> D = N.orient_new_body('D', q1, q2, q3, '123') \n```", "```py\n>>> D = N.orient_new_axis('D', q1, N.i)\n>>> D = D.orient_new_axis('D', q2, D.j)\n>>> D = D.orient_new_axis('D', q3, D.k) \n```", "```py\n>>> B = N.orient_new_body('B', q1, q2, q3, '123')\n>>> B = N.orient_new_body('B', q1, q2, 0, 'ZXZ')\n>>> B = N.orient_new_body('B', 0, 0, 0, 'XYX') \n```", "```py\norient_new_quaternion(name, q0, q1, q2, q3, location=None, vector_names=None, variable_names=None)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> from sympy import symbols\n>>> q0, q1, q2, q3 = symbols('q0 q1 q2 q3')\n>>> N = CoordSys3D('N')\n>>> B = N.orient_new_quaternion('B', q0, q1, q2, q3) \n```", "```py\norient_new_space(name, angle1, angle2, angle3, rotation_order, location=None, vector_names=None, variable_names=None)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> from sympy import symbols\n>>> q1, q2, q3 = symbols('q1 q2 q3')\n>>> N = CoordSys3D('N') \n```", "```py\n>>> D = N.orient_new_space('D', q1, q2, q3, '312') \n```", "```py\n>>> B = N.orient_new_axis('B', q1, N.i)\n>>> C = B.orient_new_axis('C', q2, N.j)\n>>> D = C.orient_new_axis('D', q3, N.k) \n```", "```py\nposition_wrt(other)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> N = CoordSys3D('N')\n>>> N1 = N.locate_new('N1', 10 * N.i)\n>>> N.position_wrt(N1)\n(-10)*N.i \n```", "```py\nrotation_matrix(other)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> from sympy import symbols\n>>> q1 = symbols('q1')\n>>> N = CoordSys3D('N')\n>>> A = N.orient_new_axis('A', q1, N.i)\n>>> N.rotation_matrix(A)\nMatrix([\n[1,       0,        0],\n[0, cos(q1), -sin(q1)],\n[0, sin(q1),  cos(q1)]]) \n```", "```py\nscalar_map(other)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> from sympy import Symbol\n>>> A = CoordSys3D('A')\n>>> q = Symbol('q')\n>>> B = A.orient_new_axis('B', q, A.k)\n>>> A.scalar_map(B)\n{A.x: B.x*cos(q) - B.y*sin(q), A.y: B.x*sin(q) + B.y*cos(q), A.z: B.z} \n```", "```py\nclass sympy.vector.vector.Vector(*args)\n```", "```py\nproperty components\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> C = CoordSys3D('C')\n>>> v = 3*C.i + 4*C.j + 5*C.k\n>>> v.components\n{C.i: 3, C.j: 4, C.k: 5} \n```", "```py\ncross(other)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> C = CoordSys3D('C')\n>>> C.i.cross(C.j)\nC.k\n>>> C.i ^ C.i\n0\n>>> v = 3*C.i + 4*C.j + 5*C.k\n>>> v ^ C.i\n5*C.j + (-4)*C.k\n>>> d = C.i.outer(C.i)\n>>> C.j.cross(d)\n(-1)*(C.k|C.i) \n```", "```py\ndot(other)\n```", "```py\n>>> from sympy.vector import CoordSys3D, Del\n>>> C = CoordSys3D('C')\n>>> delop = Del()\n>>> C.i.dot(C.j)\n0\n>>> C.i & C.i\n1\n>>> v = 3*C.i + 4*C.j + 5*C.k\n>>> v.dot(C.k)\n5\n>>> (C.i & delop)(C.x*C.y*C.z)\nC.y*C.z\n>>> d = C.i.outer(C.i)\n>>> C.i.dot(d)\nC.i \n```", "```py\nmagnitude()\n```", "```py\nnormalize()\n```", "```py\nouter(other)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> N = CoordSys3D('N')\n>>> N.i.outer(N.j)\n(N.i|N.j) \n```", "```py\nprojection(other, scalar=False)\n```", "```py\n>>> from sympy.vector.coordsysrect import CoordSys3D\n>>> C = CoordSys3D('C')\n>>> i, j, k = C.base_vectors()\n>>> v1 = i + j + k\n>>> v2 = 3*i + 4*j\n>>> v1.projection(v2)\n7/3*C.i + 7/3*C.j + 7/3*C.k\n>>> v1.projection(v2, scalar=True)\n7/3 \n```", "```py\nseparate()\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> R1 = CoordSys3D('R1')\n>>> R2 = CoordSys3D('R2')\n>>> v = R1.i + R2.i\n>>> v.separate() == {R1: R1.i, R2: R2.i}\nTrue \n```", "```py\nto_matrix(system)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> C = CoordSys3D('C')\n>>> from sympy.abc import a, b, c\n>>> v = a*C.i + b*C.j + c*C.k\n>>> v.to_matrix(C)\nMatrix([\n[a],\n[b],\n[c]]) \n```", "```py\nclass sympy.vector.dyadic.Dyadic(*args)\n```", "```py\nproperty components\n```", "```py\ncross(other)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> N = CoordSys3D('N')\n>>> d = N.i.outer(N.i)\n>>> d.cross(N.j)\n(N.i|N.k) \n```", "```py\ndot(other)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> N = CoordSys3D('N')\n>>> D1 = N.i.outer(N.j)\n>>> D2 = N.j.outer(N.j)\n>>> D1.dot(D2)\n(N.i|N.j)\n>>> D1.dot(N.j)\nN.i \n```", "```py\nto_matrix(system, second_system=None)\n```", "```py\n>>> from sympy.vector import CoordSys3D\n>>> N = CoordSys3D('N')\n>>> v = N.i + 2*N.j\n>>> d = v.outer(N.i)\n>>> d.to_matrix(N)\nMatrix([\n[1, 0, 0],\n[2, 0, 0],\n[0, 0, 0]])\n>>> from sympy import Symbol\n>>> q = Symbol('q')\n>>> P = N.orient_new_axis('P', q, N.k)\n>>> d.to_matrix(N, P)\nMatrix([\n[  cos(q),   -sin(q), 0],\n[2*cos(q), -2*sin(q), 0],\n[       0,         0, 0]]) \n```", "```py\nclass sympy.vector.deloperator.Del\n```", "```py\ncross(vect, doit=False)\n```", "```py\n>>> from sympy.vector import CoordSys3D, Del\n>>> C = CoordSys3D('C')\n>>> delop = Del()\n>>> v = C.x*C.y*C.z * (C.i + C.j + C.k)\n>>> delop.cross(v, doit = True)\n(-C.x*C.y + C.x*C.z)*C.i + (C.x*C.y - C.y*C.z)*C.j +\n (-C.x*C.z + C.y*C.z)*C.k\n>>> (delop ^ C.i).doit()\n0 \n```", "```py\ndot(vect, doit=False)\n```", "```py\n>>> from sympy.vector import CoordSys3D, Del\n>>> delop = Del()\n>>> C = CoordSys3D('C')\n>>> delop.dot(C.x*C.i)\nDerivative(C.x, C.x)\n>>> v = C.x*C.y*C.z * (C.i + C.j + C.k)\n>>> (delop & v).doit()\nC.x*C.y + C.x*C.z + C.y*C.z \n```", "```py\ngradient(scalar_field, doit=False)\n```", "```py\n>>> from sympy.vector import CoordSys3D, Del\n>>> C = CoordSys3D('C')\n>>> delop = Del()\n>>> delop.gradient(9)\n0\n>>> delop(C.x*C.y*C.z).doit()\nC.y*C.z*C.i + C.x*C.z*C.j + C.x*C.y*C.k \n```", "```py\nclass sympy.vector.parametricregion.ParametricRegion(definition, *bounds)\n```", "```py\n>>> from sympy import cos, sin, pi\n>>> from sympy.abc import r, theta, t, a, b, x, y\n>>> from sympy.vector import ParametricRegion \n```", "```py\n>>> ParametricRegion((t, t**2), (t, -1, 2))\nParametricRegion((t, t**2), (t, -1, 2))\n>>> ParametricRegion((x, y), (x, 3, 4), (y, 5, 6))\nParametricRegion((x, y), (x, 3, 4), (y, 5, 6))\n>>> ParametricRegion((r*cos(theta), r*sin(theta)), (r, -2, 2), (theta, 0, pi))\nParametricRegion((r*cos(theta), r*sin(theta)), (r, -2, 2), (theta, 0, pi))\n>>> ParametricRegion((a*cos(t), b*sin(t)), t)\nParametricRegion((a*cos(t), b*sin(t)), t) \n```", "```py\n>>> circle = ParametricRegion((r*cos(theta), r*sin(theta)), r, (theta, 0, pi))\n>>> circle.parameters\n(r, theta)\n>>> circle.definition\n(r*cos(theta), r*sin(theta))\n>>> circle.limits\n{theta: (0, pi)} \n```", "```py\n>>> circle.dimensions\n1 \n```", "```py\nclass sympy.vector.implicitregion.ImplicitRegion(variables, equation)\n```", "```py\n>>> from sympy import Eq\n>>> from sympy.abc import x, y, z, t\n>>> from sympy.vector import ImplicitRegion \n```", "```py\n>>> ImplicitRegion((x, y), x**2 + y**2 - 4)\nImplicitRegion((x, y), x**2 + y**2 - 4)\n>>> ImplicitRegion((x, y), Eq(y*x, 1))\nImplicitRegion((x, y), x*y - 1) \n```", "```py\n>>> parabola = ImplicitRegion((x, y), y**2 - 4*x)\n>>> parabola.degree\n2\n>>> parabola.equation\n-4*x + y**2\n>>> parabola.rational_parametrization(t)\n(4/t**2, 4/t) \n```", "```py\n>>> r = ImplicitRegion((x, y, z), Eq(z, x**2 + y**2))\n>>> r.variables\n(x, y, z)\n>>> r.singular_points()\nEmptySet\n>>> r.regular_point()\n(-10, -10, 200) \n```", "```py\nmultiplicity(point)\n```", "```py\n>>> from sympy.abc import x, y, z\n>>> from sympy.vector import ImplicitRegion\n>>> I = ImplicitRegion((x, y, z), x**2 + y**3 - z**4)\n>>> I.singular_points()\n{(0, 0, 0)}\n>>> I.multiplicity((0, 0, 0))\n2 \n```", "```py\nrational_parametrization(parameters=('t', 's'), reg_point=None)\n```", "```py\n>>> from sympy import Eq\n>>> from sympy.abc import x, y, z, s, t\n>>> from sympy.vector import ImplicitRegion \n```", "```py\n>>> parabola = ImplicitRegion((x, y), y**2 - 4*x)\n>>> parabola.rational_parametrization()\n(4/t**2, 4/t) \n```", "```py\n>>> circle = ImplicitRegion((x, y), Eq(x**2 + y**2, 4))\n>>> circle.rational_parametrization()\n(4*t/(t**2 + 1), 4*t**2/(t**2 + 1) - 2) \n```", "```py\n>>> I = ImplicitRegion((x, y), x**3 + x**2 - y**2)\n>>> I.rational_parametrization()\n(t**2 - 1, t*(t**2 - 1)) \n```", "```py\n>>> cubic_curve = ImplicitRegion((x, y), x**3 + x**2 - y**2)\n>>> cubic_curve.rational_parametrization(parameters=(t))\n(t**2 - 1, t*(t**2 - 1)) \n```", "```py\n>>> sphere = ImplicitRegion((x, y, z), x**2 + y**2 + z**2 - 4)\n>>> sphere.rational_parametrization(parameters=(t, s))\n(-2 + 4/(s**2 + t**2 + 1), 4*s/(s**2 + t**2 + 1), 4*t/(s**2 + t**2 + 1)) \n```", "```py\n>>> c = ImplicitRegion((x, y), (x  - 1/2)**2 + (y)**2 - (1/4)**2)\n>>> c.rational_parametrization(reg_point=(3/4, 0))\n(0.75 - 0.5/(t**2 + 1), -0.5*t/(t**2 + 1)) \n```", "```py\nregular_point()\n```", "```py\n>>> from sympy.abc import x, y, z\n>>> from sympy.vector import ImplicitRegion\n>>> circle = ImplicitRegion((x, y), (x + 2)**2 + (y - 3)**2 - 16)\n>>> circle.regular_point()\n(-2, -1)\n>>> parabola = ImplicitRegion((x, y), x**2 - 4*y)\n>>> parabola.regular_point()\n(0, 0)\n>>> r = ImplicitRegion((x, y, z), (x + y + z)**4)\n>>> r.regular_point()\n(-10, -10, 20) \n```", "```py\nsingular_points()\n```", "```py\n>>> from sympy.abc import x, y\n>>> from sympy.vector import ImplicitRegion\n>>> I = ImplicitRegion((x, y), (y-1)**2 -x**3 + 2*x**2 -x)\n>>> I.singular_points()\n{(1, 1)} \n```", "```py\nclass sympy.vector.integrals.ParametricIntegral(field, parametricregion)\n```", "```py\n>>> from sympy import cos, sin, pi\n>>> from sympy.vector import CoordSys3D, ParametricRegion, ParametricIntegral\n>>> from sympy.abc import r, t, theta, phi \n```", "```py\n>>> C = CoordSys3D('C')\n>>> curve = ParametricRegion((3*t - 2, t + 1), (t, 1, 2))\n>>> ParametricIntegral(C.x, curve)\n5*sqrt(10)/2\n>>> length = ParametricIntegral(1, curve)\n>>> length\nsqrt(10)\n>>> semisphere = ParametricRegion((2*sin(phi)*cos(theta), 2*sin(phi)*sin(theta), 2*cos(phi)),                            (theta, 0, 2*pi), (phi, 0, pi/2))\n>>> ParametricIntegral(C.z, semisphere)\n8*pi \n```", "```py\n>>> ParametricIntegral(C.j + C.k, ParametricRegion((r*cos(theta), r*sin(theta)), r, theta))\n0 \n```"]