- en: scipy.optimize.brute
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.brute.html#scipy.optimize.brute](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.optimize.brute.html#scipy.optimize.brute)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Minimize a function over a given range by brute force.
  prefs: []
  type: TYPE_NORMAL
- en: Uses the “brute force” method, i.e., computes the function’s value at each point
    of a multidimensional grid of points, to find the global minimum of the function.
  prefs: []
  type: TYPE_NORMAL
- en: The function is evaluated everywhere in the range with the datatype of the first
    call to the function, as enforced by the `vectorize` NumPy function. The value
    and type of the function evaluation returned when `full_output=True` are affected
    in addition by the `finish` argument (see Notes).
  prefs: []
  type: TYPE_NORMAL
- en: The brute force approach is inefficient because the number of grid points increases
    exponentially - the number of grid points to evaluate is `Ns ** len(x)`. Consequently,
    even with coarse grid spacing, even moderately sized problems can take a long
    time to run, and/or run into memory limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**func**callable'
  prefs: []
  type: TYPE_NORMAL
- en: The objective function to be minimized. Must be in the form `f(x, *args)`, where
    `x` is the argument in the form of a 1-D array and `args` is a tuple of any additional
    fixed parameters needed to completely specify the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**ranges**tuple'
  prefs: []
  type: TYPE_NORMAL
- en: Each component of the *ranges* tuple must be either a “slice object” or a range
    tuple of the form `(low, high)`. The program uses these to create the grid of
    points on which the objective function will be computed. See *Note 2* for more
    detail.
  prefs: []
  type: TYPE_NORMAL
- en: '**args**tuple, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Any additional fixed parameters needed to completely specify the function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ns**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Number of grid points along the axes, if not otherwise specified. See *Note2*.
  prefs: []
  type: TYPE_NORMAL
- en: '**full_output**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, return the evaluation grid and the objective function’s values on it.
  prefs: []
  type: TYPE_NORMAL
- en: '**finish**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: An optimization function that is called with the result of brute force minimization
    as initial guess. *finish* should take *func* and the initial guess as positional
    arguments, and take *args* as keyword arguments. It may additionally take *full_output*
    and/or *disp* as keyword arguments. Use None if no “polishing” function is to
    be used. See Notes for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '**disp**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Set to True to print convergence messages from the *finish* callable.
  prefs: []
  type: TYPE_NORMAL
- en: '**workers**int or map-like callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *workers* is an int the grid is subdivided into *workers* sections and evaluated
    in parallel (uses [`multiprocessing.Pool`](https://docs.python.org/3/library/multiprocessing.html#module-multiprocessing
    "(in Python v3.12)")). Supply *-1* to use all cores available to the Process.
    Alternatively supply a map-like callable, such as *multiprocessing.Pool.map* for
    evaluating the grid in parallel. This evaluation is carried out as `workers(func,
    iterable)`. Requires that *func* be pickleable.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x0**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: A 1-D array containing the coordinates of a point at which the objective function
    had its minimum value. (See *Note 1* for which point is returned.)
  prefs: []
  type: TYPE_NORMAL
- en: '**fval**float'
  prefs: []
  type: TYPE_NORMAL
- en: Function value at the point *x0*. (Returned when *full_output* is True.)
  prefs: []
  type: TYPE_NORMAL
- en: '**grid**tuple'
  prefs: []
  type: TYPE_NORMAL
- en: Representation of the evaluation grid. It has the same length as *x0*. (Returned
    when *full_output* is True.)
  prefs: []
  type: TYPE_NORMAL
- en: '**Jout**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Function values at each point of the evaluation grid, i.e., `Jout = func(*grid)`.
    (Returned when *full_output* is True.)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`basinhopping`](scipy.optimize.basinhopping.html#scipy.optimize.basinhopping
    "scipy.optimize.basinhopping"), [`differential_evolution`](scipy.optimize.differential_evolution.html#scipy.optimize.differential_evolution
    "scipy.optimize.differential_evolution")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: '*Note 1*: The program finds the gridpoint at which the lowest value of the
    objective function occurs. If *finish* is None, that is the point returned. When
    the global minimum occurs within (or not very far outside) the grid’s boundaries,
    and the grid is fine enough, that point will be in the neighborhood of the global
    minimum.'
  prefs: []
  type: TYPE_NORMAL
- en: However, users often employ some other optimization program to “polish” the
    gridpoint values, i.e., to seek a more precise (local) minimum near *brute’s*
    best gridpoint. The [`brute`](#scipy.optimize.brute "scipy.optimize.brute") function’s
    *finish* option provides a convenient way to do that. Any polishing program used
    must take *brute’s* output as its initial guess as a positional argument, and
    take *brute’s* input values for *args* as keyword arguments, otherwise an error
    will be raised. It may additionally take *full_output* and/or *disp* as keyword
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[`brute`](#scipy.optimize.brute "scipy.optimize.brute") assumes that the *finish*
    function returns either an [`OptimizeResult`](scipy.optimize.OptimizeResult.html#scipy.optimize.OptimizeResult
    "scipy.optimize.OptimizeResult") object or a tuple in the form: `(xmin, Jmin,
    ... , statuscode)`, where `xmin` is the minimizing value of the argument, `Jmin`
    is the minimum value of the objective function, “…” may be some other returned
    values (which are not used by [`brute`](#scipy.optimize.brute "scipy.optimize.brute")),
    and `statuscode` is the status code of the *finish* program.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that when *finish* is not None, the values returned are those of the *finish*
    program, *not* the gridpoint ones. Consequently, while [`brute`](#scipy.optimize.brute
    "scipy.optimize.brute") confines its search to the input grid points, the *finish*
    program’s results usually will not coincide with any gridpoint, and may fall outside
    the grid’s boundary. Thus, if a minimum only needs to be found over the provided
    grid points, make sure to pass in *finish=None*.
  prefs: []
  type: TYPE_NORMAL
- en: '*Note 2*: The grid of points is a [`numpy.mgrid`](https://numpy.org/devdocs/reference/generated/numpy.mgrid.html#numpy.mgrid
    "(in NumPy v2.0.dev0)") object. For [`brute`](#scipy.optimize.brute "scipy.optimize.brute")
    the *ranges* and *Ns* inputs have the following effect. Each component of the
    *ranges* tuple can be either a slice object or a two-tuple giving a range of values,
    such as (0, 5). If the component is a slice object, [`brute`](#scipy.optimize.brute
    "scipy.optimize.brute") uses it directly. If the component is a two-tuple range,
    [`brute`](#scipy.optimize.brute "scipy.optimize.brute") internally converts it
    to a slice object that interpolates *Ns* points from its low-value to its high-value,
    inclusive.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: We illustrate the use of [`brute`](#scipy.optimize.brute "scipy.optimize.brute")
    to seek the global minimum of a function of two variables that is given as the
    sum of a positive-definite quadratic and two deep “Gaussian-shaped” craters. Specifically,
    define the objective function *f* as the sum of three other functions, `f = f1
    + f2 + f3`. We suppose each of these has a signature `(z, *params)`, where `z
    = (x, y)`, and `params` and the functions are as defined below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, the objective function may have local minima near the minimum of each
    of the three functions of which it is composed. To use [`fmin`](scipy.optimize.fmin.html#scipy.optimize.fmin
    "scipy.optimize.fmin") to polish its gridpoint result, we may then continue as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that if *finish* had been set to None, we would have gotten the gridpoint
    [-1.0 1.75] where the rounded function value is -2.892.
  prefs: []
  type: TYPE_NORMAL
