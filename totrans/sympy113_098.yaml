- en: Concrete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/concrete.html](https://docs.sympy.org/latest/modules/concrete.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Hypergeometric terms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The center stage, in recurrence solving and summations, play hypergeometric
    terms. Formally these are sequences annihilated by first order linear recurrence
    operators. In simple words if we are given term \(a(n)\) then it is hypergeometric
    if its consecutive term ratio is a rational function in \(n\).
  prefs: []
  type: TYPE_NORMAL
- en: 'To check if a sequence is of this type you can use the `is_hypergeometric`
    method which is available in Basic class. Here is simple example involving a polynomial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course polynomials are hypergeometric but are there any more complicated
    sequences of this type? Here are some trivial examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We see that all species used in summations and other parts of concrete mathematics
    are hypergeometric. Note also that binomial coefficients and both rising and falling
    factorials are hypergeometric in both their arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To say more, all previously shown examples are valid for integer linear arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However nonlinear arguments make those sequences fail to be hypergeometric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If not only the knowledge of being hypergeometric or not is needed, you can
    use `hypersimp()` function. It will try to simplify combinatorial expression and
    if the term given is hypergeometric it will return a quotient of polynomials of
    minimal degree. Otherwise is will return \(None\) to say that sequence is not
    hypergeometric:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Concrete Class Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Represents unevaluated summation.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Sum` represents a finite or infinite series, with the first argument being
    the general form of terms in the series, and the second argument being `(dummy_variable,
    start, end)`, with `dummy_variable` taking all integer values from `start` through
    `end`. In accordance with long-standing mathematical convention, the end term
    is included in the summation.'
  prefs: []
  type: TYPE_NORMAL
- en: Finite Sums
  prefs: []
  type: TYPE_NORMAL
- en: 'For finite sums (and sums with symbolic limits assumed to be finite) we follow
    the summation convention described by Karr [1], especially definition 3 of section
    1.4\. The sum:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{m \leq i < n} f(i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'has *the obvious meaning* for \(m < n\), namely:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{m \leq i < n} f(i) = f(m) + f(m+1) + \ldots + f(n-2) + f(n-1)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'with the upper limit value \(f(n)\) excluded. The sum over an empty set is
    zero if and only if \(m = n\):'
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{m \leq i < n} f(i) = 0 \quad \mathrm{for} \quad m = n\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for all other sums over empty sets we assume the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{m \leq i < n} f(i) = - \sum_{n \leq i < m} f(i) \quad \mathrm{for} \quad
    m > n\]
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that Karr defines all sums with the upper limit being
    exclusive. This is in contrast to the usual mathematical notation, but does not
    affect the summation convention. Indeed we have:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{m \leq i < n} f(i) = \sum_{i = m}^{n - 1} f(i)\]
  prefs: []
  type: TYPE_NORMAL
- en: where the difference in notation is intentional to emphasize the meaning, with
    limits typeset on the top being inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are examples to do summation with symbolic indices. You can use either
    Function of IndexedBase classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An example showing that the symbolic result of a summation is still valid for
    seemingly nonsensical values of the limits. Then the Karr convention allows us
    to give a perfectly valid interpretation to those sums by interchanging the limits
    according to the above rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'An explicit example of the Karr summation convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`summation`](#sympy.concrete.summations.summation "sympy.concrete.summations.summation"),
    [`Product`](#sympy.concrete.products.Product "sympy.concrete.products.Product"),
    [`sympy.concrete.products.product`](#sympy.concrete.products.product "sympy.concrete.products.product")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R98](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: Michael Karr, “Summation in Finite Terms”, Journal of the ACM, Volume 28 Issue
    2, April 1981, Pages 305-350 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
  prefs: []
  type: TYPE_NORMAL
- en: '[[R99](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Summation#Capital-sigma_notation](https://en.wikipedia.org/wiki/Summation#Capital-sigma_notation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R100](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Empty_sum](https://en.wikipedia.org/wiki/Empty_sum)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Return an Euler-Maclaurin approximation of self, where m is the number of leading
    terms to sum directly and n is the number of terms in the tail.
  prefs: []
  type: TYPE_NORMAL
- en: With m = n = 0, this is simply the corresponding integral plus a first-order
    endpoint correction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns (s, e) where s is the Euler-Maclaurin approximation and e is the estimated
    error (taken to be the magnitude of the first omitted term in the tail):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The endpoints may be symbolic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If the function is a polynomial of degree at most 2n+1, the Euler-Maclaurin
    formula becomes exact (and e = 0 is returned):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With a nonzero eps specified, the summation is ended as soon as the remainder
    term is less than the epsilon.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Check whether the function matches with the zeta function.
  prefs: []
  type: TYPE_NORMAL
- en: If it matches, then return a \(Piecewise\) expression because zeta function
    does not converge unless \(s > 1\) and \(q > 0\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Checks for the absolute convergence of an infinite series.
  prefs: []
  type: TYPE_NORMAL
- en: Same as checking convergence of absolute value of sequence_term of an infinite
    series.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Sum.is_convergent`](#sympy.concrete.summations.Sum.is_convergent "sympy.concrete.summations.Sum.is_convergent")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R101](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Absolute_convergence](https://en.wikipedia.org/wiki/Absolute_convergence)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Checks for the convergence of a Sum.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: We divide the study of convergence of infinite sums and products in two parts.
  prefs: []
  type: TYPE_NORMAL
- en: 'First Part: One part is the question whether all the terms are well defined,
    i.e., they are finite in a sum and also non-zero in a product. Zero is the analogy
    of (minus) infinity in products as \(e^{-\infty} = 0\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second Part: The second part is the question of convergence after infinities,
    and zeros in products, have been omitted assuming that their number is finite.
    This means that we only consider the tail of the sum or product, starting from
    some point after which all terms are well defined.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a sum of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{1 \leq i < \infty} \frac{1}{n^2 + an + b}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'where a and b are numbers. The routine will return true, even if there are
    infinities in the term sequence (at most two). An analogous product would be:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\prod_{1 \leq i < \infty} e^{\frac{1}{n^2 + an + b}}\]
  prefs: []
  type: TYPE_NORMAL
- en: This is how convergence is interpreted. It is concerned with what happens at
    the limit. Finding the bad terms is another independent matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: It is responsibility of user to see that the sum or product is well defined.'
  prefs: []
  type: TYPE_NORMAL
- en: There are various tests employed to check the convergence like divergence test,
    root test, integral test, alternating series test, comparison tests, Dirichlet
    tests. It returns true if Sum is convergent and false if divergent and NotImplementedError
    if it cannot be checked.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Sum.is_absolutely_convergent`](#sympy.concrete.summations.Sum.is_absolutely_convergent
    "sympy.concrete.summations.Sum.is_absolutely_convergent"), [`sympy.concrete.products.Product.is_convergent`](#sympy.concrete.products.Product.is_convergent
    "sympy.concrete.products.Product.is_convergent")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R102](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Convergence_tests](https://en.wikipedia.org/wiki/Convergence_tests)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Reverse the order of a limit in a Sum.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`reverse_order(self, *indices)` reverses some limits in the expression `self`
    which can be either a `Sum` or a `Product`. The selectors in the argument `indices`
    specify some indices whose limits get reversed. These selectors are either variable
    names or numerical indices counted starting from the inner-most limit tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: While one should prefer variable names when specifying which limits to reverse,
    the index counting notation comes in handy in case there are several symbols with
    the same name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course we can mix both notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R103](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: Michael Karr, “Summation in Finite Terms”, Journal of the ACM, Volume 28 Issue
    2, April 1981, Pages 305-350 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Represents unevaluated products.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`Product` represents a finite or infinite product, with the first argument
    being the general form of terms in the series, and the second argument being `(dummy_variable,
    start, end)`, with `dummy_variable` taking all integer values from `start` through
    `end`. In accordance with long-standing mathematical convention, the end term
    is included in the product.'
  prefs: []
  type: TYPE_NORMAL
- en: Finite Products
  prefs: []
  type: TYPE_NORMAL
- en: 'For finite products (and products with symbolic limits assumed to be finite)
    we follow the analogue of the summation convention described by Karr [1], especially
    definition 3 of section 1.4\. The product:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\prod_{m \leq i < n} f(i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'has *the obvious meaning* for \(m < n\), namely:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\prod_{m \leq i < n} f(i) = f(m) f(m+1) \cdot \ldots \cdot f(n-2) f(n-1)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'with the upper limit value \(f(n)\) excluded. The product over an empty set
    is one if and only if \(m = n\):'
  prefs: []
  type: TYPE_NORMAL
- en: \[\prod_{m \leq i < n} f(i) = 1 \quad \mathrm{for} \quad m = n\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for all other products over empty sets we assume the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\prod_{m \leq i < n} f(i) = \frac{1}{\prod_{n \leq i < m} f(i)} \quad \mathrm{for}
    \quad m > n\]
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that above we define all products with the upper limit
    being exclusive. This is in contrast to the usual mathematical notation, but does
    not affect the product convention. Indeed we have:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\prod_{m \leq i < n} f(i) = \prod_{i = m}^{n - 1} f(i)\]
  prefs: []
  type: TYPE_NORMAL
- en: where the difference in notation is intentional to emphasize the meaning, with
    limits typeset on the top being inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Wallis’ product for pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Direct computation currently fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'But we can approach the infinite product by a limit of finite products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'By the same formula we can compute sin(pi/2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Products with the lower limit being larger than the upper one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The empty product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'An example showing that the symbolic result of a product is still valid for
    seemingly nonsensical values of the limits. Then the Karr convention allows us
    to give a perfectly valid interpretation to those products by interchanging the
    limits according to the above rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'An explicit example of the Karr summation convention applied to products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'And another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Sum`](#sympy.concrete.summations.Sum "sympy.concrete.summations.Sum"), [`summation`](#sympy.concrete.summations.summation
    "sympy.concrete.summations.summation"), [`product`](#sympy.concrete.products.product
    "sympy.concrete.products.product")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R104](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: Michael Karr, “Summation in Finite Terms”, Journal of the ACM, Volume 28 Issue
    2, April 1981, Pages 305-350 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
  prefs: []
  type: TYPE_NORMAL
- en: '[[R105](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Multiplication#Capital_Pi_notation](https://en.wikipedia.org/wiki/Multiplication#Capital_Pi_notation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R106](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Empty_product](https://en.wikipedia.org/wiki/Empty_product)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See docs of [`Sum.is_convergent()`](#sympy.concrete.summations.Sum.is_convergent
    "sympy.concrete.summations.Sum.is_convergent") for explanation of convergence
    in SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The infinite product:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\prod_{1 \leq i < \infty} f(i)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'is defined by the sequence of partial products:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\prod_{i=1}^{n} f(i) = f(1) f(2) \cdots f(n)\]
  prefs: []
  type: TYPE_NORMAL
- en: 'as n increases without bound. The product converges to a non-zero value if
    and only if the sum:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{1 \leq i < \infty} \log{f(n)}\]
  prefs: []
  type: TYPE_NORMAL
- en: converges.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R107](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Infinite_product](https://en.wikipedia.org/wiki/Infinite_product)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Reverse the order of a limit in a Product.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`reverse_order(expr, *indices)` reverses some limits in the expression `expr`
    which can be either a `Sum` or a `Product`. The selectors in the argument `indices`
    specify some indices whose limits get reversed. These selectors are either variable
    names or numerical indices counted starting from the inner-most limit tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: While one should prefer variable names when specifying which limits to reverse,
    the index counting notation comes in handy in case there are several symbols with
    the same name.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course we can mix both notations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R108](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: Michael Karr, “Summation in Finite Terms”, Journal of the ACM, Volume 28 Issue
    2, April 1981, Pages 305-350 [https://dl.acm.org/doi/10.1145/322248.322255](https://dl.acm.org/doi/10.1145/322248.322255)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Superclass for Product and Sum.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.concrete.expr_with_limits.ExprWithLimits`](integrals/integrals.html#sympy.concrete.expr_with_limits.ExprWithLimits
    "sympy.concrete.expr_with_limits.ExprWithLimits"), [`sympy.concrete.products.Product`](#sympy.concrete.products.Product
    "sympy.concrete.products.Product"), [`sympy.concrete.summations.Sum`](#sympy.concrete.summations.Sum
    "sympy.concrete.summations.Sum")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Change index of a Sum or Product.
  prefs: []
  type: TYPE_NORMAL
- en: Perform a linear transformation \(x \mapsto a x + b\) on the index variable
    \(x\). For \(a\) the only values allowed are \(\pm 1\). A new variable to be used
    after the change of index can also be specified.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`change_index(expr, var, trafo, newvar=None)` where `var` specifies the index
    variable \(x\) to transform. The transformation `trafo` must be linear and given
    in terms of `var`. If the optional argument `newvar` is provided then `var` gets
    replaced by `newvar` in the final expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'When dealing with symbols only, we can make a general linear transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: However, the last result can be inconsistent with usual summation where the
    index increment is always 1\. This is obvious as we get back the original value
    only for `u` equal +1 or -1.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder"), [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Returns True if the Sum or Product is computed for an empty sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`has_reversed_limits`](integrals/integrals.html#sympy.concrete.expr_with_limits.ExprWithLimits.has_reversed_limits
    "sympy.concrete.expr_with_limits.ExprWithLimits.has_reversed_limits"), [`has_finite_limits`](integrals/integrals.html#sympy.concrete.expr_with_limits.ExprWithLimits.has_finite_limits
    "sympy.concrete.expr_with_limits.ExprWithLimits.has_finite_limits")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Return the index of a dummy variable in the list of limits.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`index(expr, x)` returns the index of the dummy variable `x` in the limits
    of `expr`. Note that we start counting with 0 at the inner-most limits tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder"), [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Reorder limits in a expression containing a Sum or a Product.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`expr.reorder(*arg)` reorders the limits in the expression `expr` according
    to the list of tuples given by `arg`. These tuples can contain numerical indices
    or index variable names or involve both.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also select the index variables by counting them, starting with the
    inner-most one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And of course we can mix both schemes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`reorder_limit`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder_limit"), [`index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index
    "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"), [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Interchange two limit tuples of a Sum or Product expression.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`expr.reorder_limit(x, y)` interchanges two limit tuples. The arguments `x`
    and `y` are integers corresponding to the index variables of the two limits which
    are to be interchanged. The expression `expr` has to be either a Sum or a Product.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`index`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.index"),
    [`reorder`](#sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder "sympy.concrete.expr_with_intlimits.ExprWithIntLimits.reorder"),
    [`sympy.concrete.summations.Sum.reverse_order`](#sympy.concrete.summations.Sum.reverse_order
    "sympy.concrete.summations.Sum.reverse_order"), [`sympy.concrete.products.Product.reverse_order`](#sympy.concrete.products.Product.reverse_order
    "sympy.concrete.products.Product.reverse_order")'
  prefs: []
  type: TYPE_NORMAL
- en: Concrete Functions Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Compute the summation of f with respect to symbols.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The notation for symbols is similar to the notation used in Integral. summation(f,
    (i, a, b)) computes the sum of f with respect to i from a to b, i.e.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'If it cannot compute the sum, it returns an unevaluated Sum object. Repeated
    sums can be computed by introducing additional symbols tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Sum`](#sympy.concrete.summations.Sum "sympy.concrete.summations.Sum"), [`Product`](#sympy.concrete.products.Product
    "sympy.concrete.products.Product"), [`sympy.concrete.products.product`](#sympy.concrete.products.product
    "sympy.concrete.products.product")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Compute the product.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The notation for symbols is similar to the notation used in Sum or Integral.
    product(f, (i, a, b)) computes the product of f with respect to i from a to b,
    i.e.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'If it cannot compute the product, it returns an unevaluated Product object.
    Repeated products can be computed by introducing additional symbols tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Compute the Gosper’s normal form of `f` and `g`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Given relatively prime univariate polynomials `f` and `g`, rewrite their quotient
    to a normal form defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\frac{f(n)}{g(n)} = Z \cdot \frac{A(n) C(n+1)}{B(n) C(n)}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'where `Z` is an arbitrary constant and `A`, `B`, `C` are monic polynomials
    in `n` with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: \(\gcd(A(n), B(n+h)) = 1 \forall h \in \mathbb{N}\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(\gcd(B(n), C(n+1)) = 1\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(\gcd(A(n), C(n)) = 1\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This normal form, or rational factorization in other words, is a crucial step
    in Gosper’s algorithm and in solving of difference equations. It can be also used
    to decide if two hypergeometric terms are similar or not.
  prefs: []
  type: TYPE_NORMAL
- en: This procedure will return a tuple containing elements of this factorization
    in the form `(Z*A, B, C)`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Compute Gosper’s hypergeometric term for `f`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose `f` is a hypergeometric term such that:'
  prefs: []
  type: TYPE_NORMAL
- en: \[s_n = \sum_{k=0}^{n-1} f_k\]
  prefs: []
  type: TYPE_NORMAL
- en: and \(f_k\) does not depend on \(n\). Returns a hypergeometric term \(g_n\)
    such that \(g_{n+1} - g_n = f_n\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Gosper’s hypergeometric summation algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a hypergeometric term `f` such that:'
  prefs: []
  type: TYPE_NORMAL
- en: \[s_n = \sum_{k=0}^{n-1} f_k\]
  prefs: []
  type: TYPE_NORMAL
- en: and \(f(n)\) does not depend on \(n\), returns \(g_{n} - g(0)\) where \(g_{n+1}
    - g_n = f_n\), or `None` if \(s_n\) cannot be expressed in closed form as a sum
    of hypergeometric terms.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R109](#id12)]'
  prefs: []
  type: TYPE_NORMAL
- en: Marko Petkovsek, Herbert S. Wilf, Doron Zeilberger, A = B, AK Peters, Ltd.,
    Wellesley, MA, USA, 1997, pp. 73–100
  prefs: []
  type: TYPE_NORMAL
