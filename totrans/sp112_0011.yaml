- en: Sparse eigenvalue problems with ARPACK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/arpack.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/arpack.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ARPACK [[1]](#id3) is a Fortran package which provides routines for quickly
    finding a few eigenvalues/eigenvectors of large sparse matrices. In order to find
    these solutions, it requires only left-multiplication by the matrix in question.
    This operation is performed through a *reverse-communication* interface. The result
    of this structure is that ARPACK is able to find eigenvalues and eigenvectors
    of any linear function mapping a vector to a vector.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: All of the functionality provided in ARPACK is contained within the two high-level
    interfaces [`scipy.sparse.linalg.eigs`](../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs
    "scipy.sparse.linalg.eigs") and [`scipy.sparse.linalg.eigsh`](../reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh
    "scipy.sparse.linalg.eigsh"). [`eigs`](../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs
    "scipy.sparse.linalg.eigs") provides interfaces for finding the eigenvalues/vectors
    of real or complex nonsymmetric square matrices, while [`eigsh`](../reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh
    "scipy.sparse.linalg.eigsh") provides interfaces for real-symmetric or complex-hermitian
    matrices.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Basic functionality
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ARPACK can solve either standard eigenvalue problems of the form
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: \[A \mathbf{x} = \lambda \mathbf{x}\]
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: or general eigenvalue problems of the form
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: \[A \mathbf{x} = \lambda M \mathbf{x}.\]
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'The power of ARPACK is that it can compute only a specified subset of eigenvalue/eigenvector
    pairs. This is accomplished through the keyword `which`. The following values
    of `which` are available:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '`which = ''LM''` : Eigenvalues with largest magnitude (`eigs`, `eigsh`), that
    is, largest eigenvalues in the euclidean norm of complex numbers.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`which = ''SM''` : Eigenvalues with smallest magnitude (`eigs`, `eigsh`), that
    is, smallest eigenvalues in the euclidean norm of complex numbers.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`which = ''LR''` : Eigenvalues with largest real part (`eigs`).'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`which = ''SR''` : Eigenvalues with smallest real part (`eigs`).'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`which = ''LI''` : Eigenvalues with largest imaginary part (`eigs`).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`which = ''SI''` : Eigenvalues with smallest imaginary part (`eigs`).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`which = ''LA''` : Eigenvalues with largest algebraic value (`eigsh`), that
    is, largest eigenvalues inclusive of any negative sign.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`which = ''SA''` : Eigenvalues with smallest algebraic value (`eigsh`), that
    is, smallest eigenvalues inclusive of any negative sign.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`which = ''BE''` : Eigenvalues from both ends of the spectrum (`eigsh`).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that ARPACK is generally better at finding extremal eigenvalues, that is,
    eigenvalues with large magnitudes. In particular, using `which = 'SM'` may lead
    to slow execution time and/or anomalous results. A better approach is to use *shift-invert
    mode*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Shift-invert mode
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shift-invert mode relies on the following observation. For the generalized eigenvalue
    problem
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: \[A \mathbf{x} = \lambda M \mathbf{x},\]
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: it can be shown that
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: \[(A - \sigma M)^{-1} M \mathbf{x} = \nu \mathbf{x},\]
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: where
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: \[\nu = \frac{1}{\lambda - \sigma}.\]
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Imagine you’d like to find the smallest and largest eigenvalues and the corresponding
    eigenvectors for a large matrix. ARPACK can handle many forms of input: dense
    matrices ,such as [`numpy.ndarray`](https://numpy.org/devdocs/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v2.0.dev0)") instances, sparse matrices, such as [`scipy.sparse.csr_matrix`](../reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix
    "scipy.sparse.csr_matrix"), or a general linear operator derived from [`scipy.sparse.linalg.LinearOperator`](../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator"). For this example, for simplicity, we’ll
    construct a symmetric, positive-definite matrix.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We now have a symmetric matrix `X`, with which to test the routines. First,
    compute a standard eigenvalue decomposition using `eigh`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As the dimension of `X` grows, this routine becomes very slow. Especially,
    if only a few eigenvectors and eigenvalues are needed, `ARPACK` can be a better
    option. First let’s compute the largest eigenvalues (`which = ''LM''`) of `X`
    and compare them to the known results:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The results are as expected. ARPACK recovers the desired eigenvalues and they
    match the previously known results. Furthermore, the eigenvectors are orthogonal,
    as we’d expect. Now, let’s attempt to solve for the eigenvalues with smallest
    magnitude:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Oops. We see that, as mentioned above, `ARPACK` is not quite as adept at finding
    small eigenvalues. There are a few ways this problem can be addressed. We could
    increase the tolerance (`tol`) to lead to faster convergence:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This works, but we lose the precision in the results. Another option is to
    increase the maximum number of iterations (`maxiter`) from 1000 to 5000:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We get the results we’d hoped for, but the computation time is much longer.
    Fortunately, `ARPACK` contains a mode that allows a quick determination of non-external
    eigenvalues: *shift-invert mode*. As mentioned above, this mode involves transforming
    the eigenvalue problem to an equivalent problem with different eigenvalues. In
    this case, we hope to find eigenvalues near zero, so we’ll choose `sigma = 0`.
    The transformed eigenvalues will then satisfy \(\nu = 1/(\lambda - \sigma) = 1/\lambda\),
    so our small eigenvalues \(\lambda\) become large eigenvalues \(\nu\).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We get the results we were hoping for, with much less computational time. Note
    that the transformation from \(\nu \to \lambda\) takes place entirely in the background.
    The user need not worry about the details.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'The shift-invert mode provides more than just a fast way to obtain a few small
    eigenvalues. Say, you desire to find internal eigenvalues and eigenvectors, e.g.,
    those nearest to \(\lambda = 1\). Simply set `sigma = 1` and ARPACK will take
    care of the rest:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 移位-反转模式提供的不仅仅是获取少量小特征值的快速方法。比如，您希望找到内部特征值和特征向量，例如那些接近\(\lambda = 1\)的。只需设置`sigma
    = 1`，ARPACK将处理其余部分：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The eigenvalues come out in a different order, but they’re all there. Note that
    the shift-invert mode requires the internal solution of a matrix inverse. This
    is taken care of automatically by `eigsh` and [`eigs`](../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs
    "scipy.sparse.linalg.eigs"), but the operation can also be specified by the user.
    See the docstring of [`scipy.sparse.linalg.eigsh`](../reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh
    "scipy.sparse.linalg.eigsh") and [`scipy.sparse.linalg.eigs`](../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs
    "scipy.sparse.linalg.eigs") for details.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 特征值的顺序不同，但它们都在那里。请注意，移位-反转模式需要内部解决矩阵的逆问题。这由`eigsh`和[`eigs`](../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs
    "scipy.sparse.linalg.eigs")自动处理，但用户也可以指定该操作。有关详细信息，请参阅[`scipy.sparse.linalg.eigsh`](../reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh
    "scipy.sparse.linalg.eigsh")和[`scipy.sparse.linalg.eigs`](../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs
    "scipy.sparse.linalg.eigs")的文档字符串。
- en: Use of LinearOperator
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用LinearOperator
- en: 'We consider now the case where you’d like to avoid creating a dense matrix
    and use [`scipy.sparse.linalg.LinearOperator`](../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator") instead. Our first linear operator applies
    element-wise multiplication between the input vector and a vector \(\mathbf{d}\)
    provided by the user to the operator itself. This operator mimics a diagonal matrix
    with the elements of \(\mathbf{d}\) along the main diagonal and it has the main
    benefit that the forward and adjoint operations are simple element-wise multiplications
    other than matrix-vector multiplications. For a diagonal matrix, we expect the
    eigenvalues to be equal to the elements along the main diagonal, in this case
    \(\mathbf{d}\). The eigenvalues and eigenvectors obtained with `eigsh` are compared
    to those obtained by using `eigh` when applied to the dense matrix:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑一个情况，您想避免创建密集矩阵，而是使用[`scipy.sparse.linalg.LinearOperator`](../reference/generated/scipy.sparse.linalg.LinearOperator.html#scipy.sparse.linalg.LinearOperator
    "scipy.sparse.linalg.LinearOperator")。我们的第一个线性算子应用于输入向量和用户提供给算子本身的向量\(\mathbf{d}\)之间的逐元素乘法。这个算子模拟了一个对角矩阵，其主对角线上的元素是\(\mathbf{d}\)，它的主要优点在于前向和伴随操作都是简单的逐元素乘法，而不是矩阵-向量乘法。对于对角矩阵，我们期望的特征值等于沿主对角线的元素，即\(\mathbf{d}\)。使用`eigsh`得到的特征值和特征向量与应用于密集矩阵时使用`eigh`得到的进行比较：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this case, we have created a quick and easy `Diagonal` operator. The external
    library [PyLops](https://pylops.readthedocs.io) provides similar capabilities
    in the [Diagonal](https://pylops.readthedocs.io/en/latest/api/generated/pylops.Diagonal.html#pylops.Diagonal)
    operator, as well as several other operators.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个快速且简单的`Diagonal`算子。外部库[PyLops](https://pylops.readthedocs.io)提供了与[Diagonal](https://pylops.readthedocs.io/en/latest/api/generated/pylops.Diagonal.html#pylops.Diagonal)算子类似的功能，以及其他几个算子。
- en: 'Finally, we consider a linear operator that mimics the application of a first-derivative
    stencil. In this case, the operator is equivalent to a real nonsymmetric matrix.
    Once again, we compare the estimated eigenvalues and eigenvectors with those from
    a dense matrix that applies the same first derivative to an input signal:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们考虑一个线性算子，模仿一阶导数模板的应用。在这种情况下，该算子等效于一个实非对称矩阵。再次，我们将估计的特征值和特征向量与将相同的一阶导数应用于输入信号的密集矩阵进行比较：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that the eigenvalues of this operator are all imaginary. Moreover, the
    keyword `which='LI'` of [`scipy.sparse.linalg.eigs`](../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs
    "scipy.sparse.linalg.eigs") produces the eigenvalues with largest absolute imaginary
    part (both positive and negative). Again, a more advanced implementation of the
    first-derivative operator is available in the [PyLops](https://pylops.readthedocs.io)
    library under the name of [FirstDerivative](https://pylops.readthedocs.io/en/latest/api/generated/pylops.FirstDerivative.html)
    operator.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个算子的特征值都是虚数。此外，[`scipy.sparse.linalg.eigs`](../reference/generated/scipy.sparse.linalg.eigs.html#scipy.sparse.linalg.eigs
    "scipy.sparse.linalg.eigs")函数的关键字`which='LI'`会产生具有最大绝对虚部（正负都有）的特征值。同样，在[PyLops](https://pylops.readthedocs.io)库中有一个更高级的一阶导数算子的实现，名为[FirstDerivative](https://pylops.readthedocs.io/en/latest/api/generated/pylops.FirstDerivative.html)算子。
- en: References
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
