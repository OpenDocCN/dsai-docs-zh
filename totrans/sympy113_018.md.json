["```py\n>>> import sympy as sm\n>>> import sympy.physics.mechanics as me \n```", "```py\n>>> k, c = sm.symbols('k, c', real=True, nonnegative=True)\n>>> x = me.dynamicsymbols('x', real=True) \n```", "```py\n>>> N = me.ReferenceFrame('N')\n>>> O, P = me.Point('O'), me.Point('P') \n```", "```py\n>>> P.set_pos(O, x*N.x)\n>>> P.set_vel(N, x.diff()*N.x) \n```", "```py\n>>> force_on_P = me.Force(P, -k*P.pos_from(O) - c*P.vel(N))\n>>> force_on_P\n(P, (-c*Derivative(x(t), t) - k*x(t))*N.x) \n```", "```py\n>>> force_on_O = me.Force(O, k*P.pos_from(O) + c*P.vel(N))\n>>> force_on_O\n(O, (c*Derivative(x(t), t) + k*x(t))*N.x) \n```", "```py\n>>> lpathway = me.LinearPathway(O, P)\n>>> lpathway\nLinearPathway(O, P)\n>>> lpathway.length\nAbs(x(t))\n>>> lpathway.extension_velocity\nsign(x(t))*Derivative(x(t), t) \n```", "```py\n>>> import pprint\n>>> pprint.pprint(lpathway.to_loads(-k*x - k*x.diff()))\n[Force(point=O, force=(k*x(t) + k*Derivative(x(t), t))*x(t)/Abs(x(t))*N.x),\n Force(point=P, force=(-k*x(t) - k*Derivative(x(t), t))*x(t)/Abs(x(t))*N.x)] \n```", "```py\n>>> Q, R = me.Point('Q'), me.Point('R')\n>>> Q.set_pos(O, 1*N.y)\n>>> R.set_pos(O, 1*N.x + 1*N.y)\n>>> opathway = me.ObstacleSetPathway(O, Q, R, P)\n>>> opathway.length\nsqrt((x(t) - 1)**2 + 1) + 2\n>>> opathway.extension_velocity\n(x(t) - 1)*Derivative(x(t), t)/sqrt((x(t) - 1)**2 + 1)\n>>> pprint.pprint(opathway.to_loads(-k*opathway.length))\n[Force(point=O, force=k*(sqrt((x(t) - 1)**2 + 1) + 2)*N.y),\n Force(point=Q, force=- k*(sqrt((x(t) - 1)**2 + 1) + 2)*N.y),\n Force(point=Q, force=k*(sqrt((x(t) - 1)**2 + 1) + 2)*N.x),\n Force(point=R, force=- k*(sqrt((x(t) - 1)**2 + 1) + 2)*N.x),\n Force(point=R, force=k*(sqrt((x(t) - 1)**2 + 1) + 2)*(x(t) - 1)/sqrt((x(t) - 1)**2 + 1)*N.x - k*(sqrt((x(t) - 1)**2 + 1) + 2)/sqrt((x(t) - 1)**2 + 1)*N.y),\n Force(point=P, force=- k*(sqrt((x(t) - 1)**2 + 1) + 2)*(x(t) - 1)/sqrt((x(t) - 1)**2 + 1)*N.x + k*(sqrt((x(t) - 1)**2 + 1) + 2)/sqrt((x(t) - 1)**2 + 1)*N.y)] \n```", "```py\n>>> for load in opathway.to_loads(-k*opathway.length):\n...     pprint.pprint(me.Force(load[0], load[1].subs({x: 1})))\nForce(point=O, force=3*k*N.y)\nForce(point=Q, force=- 3*k*N.y)\nForce(point=Q, force=3*k*N.x)\nForce(point=R, force=- 3*k*N.x)\nForce(point=R, force=- 3*k*N.y)\nForce(point=P, force=3*k*N.y) \n```", "```py\n>>> r = sm.symbols('r', real=True, nonegative=True)\n>>> theta = me.dynamicsymbols('theta', real=True)\n>>> O, P, Q = sm.symbols('O, P, Q', cls=me.Point)\n>>> A = me.ReferenceFrame('A') \n```", "```py\n>>> A.orient_axis(N, theta, N.z) \n```", "```py\n>>> P.set_pos(O, r*N.x)\n>>> Q.set_pos(O, N.z + r*A.x) \n```", "```py\n>>> cyl = me.WrappingCylinder(r, O, N.z)\n>>> wpathway = me.WrappingPathway(P, Q, cyl)\n>>> pprint.pprint(wpathway.to_loads(-k*wpathway.length))\n[Force(point=P, force=- k*r*Abs(theta(t))*N.y - k*N.z),\n Force(point=Q, force=k*N.z + k*r*Abs(theta(t))*A.y),\n Force(point=O, force=k*r*Abs(theta(t))*N.y - k*r*Abs(theta(t))*A.y)] \n```", "```py\n>>> N = me.ReferenceFrame('N')\n>>> O, P = me.Point('O'), me.Point('P')\n>>> P.set_pos(O, x*N.x) \n```", "```py\n>>> class SpringDamper(me.ActuatorBase):\n...\n...     # positive x spring is in tension\n...     # negative x spring is in compression\n...     def __init__(self, P1, P2, spring_constant, damper_constant):\n...         self.P1 = P1\n...         self.P2 = P2\n...         self.k = spring_constant\n...         self.c = damper_constant\n...\n...     def to_loads(self):\n...         x = self.P2.pos_from(self.P1).magnitude()\n...         v = x.diff(me.dynamicsymbols._t)\n...         dir_vec = self.P2.pos_from(self.P1).normalize()\n...         force_P1 = me.Force(self.P1,\n...                             self.k*x*dir_vec + self.c*v*dir_vec)\n...         force_P2 = me.Force(self.P2,\n...                             -self.k*x*dir_vec - self.c*v*dir_vec)\n...         return [force_P1, force_P2]\n... \n```", "```py\n>>> spring_damper = SpringDamper(O, P, k, c)\n>>> pprint.pprint(spring_damper.to_loads())\n[Force(point=O, force=(c*x(t)*sign(x(t))*Derivative(x(t), t)/Abs(x(t)) + k*x(t))*N.x),\n Force(point=P, force=(-c*x(t)*sign(x(t))*Derivative(x(t), t)/Abs(x(t)) - k*x(t))*N.x)] \n```", "```py\n>>> class SpringDamper(me.ForceActuator):\n...\n...     # positive x spring is in tension\n...     # negative x spring is in compression\n...     def __init__(self, pathway, spring_constant, damper_constant):\n...         self.pathway = pathway\n...         self.force = (-spring_constant*pathway.length -\n...                       damper_constant*pathway.extension_velocity)\n...\n>>> spring_damper2 = SpringDamper(lpathway, k, c)\n>>> pprint.pprint(spring_damper2.to_loads())\n[Force(point=O, force=(c*sign(x(t))*Derivative(x(t), t) + k*Abs(x(t)))*x(t)/Abs(x(t))*N.x),\n Force(point=P, force=(-c*sign(x(t))*Derivative(x(t), t) - k*Abs(x(t)))*x(t)/Abs(x(t))*N.x)] \n```", "```py\n>>> spring_damper3 = SpringDamper(wpathway, k, c)\n>>> pprint.pprint(spring_damper3.to_loads())\n[Force(point=P, force=r*(-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))*Abs(theta(t))/sqrt(r**2*theta(t)**2 + 1)*N.y + (-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))/sqrt(r**2*theta(t)**2 + 1)*N.z),\n Force(point=Q, force=- (-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))/sqrt(r**2*theta(t)**2 + 1)*N.z - r*(-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))*Abs(theta(t))/sqrt(r**2*theta(t)**2 + 1)*A.y),\n Force(point=O, force=- r*(-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))*Abs(theta(t))/sqrt(r**2*theta(t)**2 + 1)*N.y + r*(-c*r**2*theta(t)*Derivative(theta(t), t)/sqrt(r**2*theta(t)**2 + 1) - k*sqrt(r**2*theta(t)**2 + 1))*Abs(theta(t))/sqrt(r**2*theta(t)**2 + 1)*A.y)] \n```", "```py\n>>> e = me.dynamicsymbols('e')\n>>> e\ne(t)\n>>> a = e\n>>> a\ne(t) \n```", "```py\n>>> a = me.dynamicsymbols('a')\n>>> zeroth_order_activation = {a: e}\n>>> a.subs(zeroth_order_activation)\ne(t) \n```", "```py\n>>> from sympy.physics.biomechanics import ZerothOrderActivation\n>>> actz = ZerothOrderActivation('zeroth')\n>>> actz\nZerothOrderActivation('zeroth') \n```", "```py\n>>> actz.excitation\ne_zeroth(t)\n>>> actz.activation\ne_zeroth(t) \n```", "```py\n>>> actz.rhs()\nMatrix(0, 1, []) \n```", "```py\n>>> tau_a, tau_d, b = sm.symbols('tau_a, tau_d, b')\n>>> f = sm.tanh(b*(e - a))/2\n>>> dadt = ((1/(tau_a*(1 + 3*a)))*(1 + 2*f) + ((1 + 3*a)/(4*tau_d))*(1 - 2*f))*(e - a) \n```", "```py\n>>> from sympy.physics.biomechanics import FirstOrderActivationDeGroote2016\n>>> actf = FirstOrderActivationDeGroote2016('first', tau_a, tau_d, b)\n>>> actf.excitation\ne_first(t)\n>>> actf.activation\na_first(t) \n```", "```py\n>>> actf.rhs()\nMatrix([[((1/2 - tanh(b*(-a_first(t) + e_first(t)))/2)*(3*a_first(t)/2 + 1/2)/tau_d + (tanh(b*(-a_first(t) + e_first(t)))/2 + 1/2)/(tau_a*(3*a_first(t)/2 + 1/2)))*(-a_first(t) + e_first(t))]]) \n```", "```py\n>>> actf2 = FirstOrderActivationDeGroote2016.with_defaults('first')\n>>> actf2.rhs()\nMatrix([[((1/2 - tanh(10.0*a_first(t) - 10.0*e_first(t))/2)/(0.0225*a_first(t) + 0.0075) + 16.6666666666667*(3*a_first(t)/2 + 1/2)*(tanh(10.0*a_first(t) - 10.0*e_first(t))/2 + 1/2))*(-a_first(t) + e_first(t))]])\n>>> constants = {tau_a: sm.Float('0.015'), tau_d: sm.Float('0.060'), b: sm.Float('10.0')}\n>>> actf.rhs().subs(constants)\nMatrix([[(66.6666666666667*(1/2 - tanh(10.0*a_first(t) - 10.0*e_first(t))/2)/(3*a_first(t)/2 + 1/2) + 16.6666666666667*(3*a_first(t)/2 + 1/2)*(tanh(10.0*a_first(t) - 10.0*e_first(t))/2 + 1/2))*(-a_first(t) + e_first(t))]]) \n```", "```py\n>>> l_T_tilde = me.dynamicsymbols('l_T_tilde')\n>>> c0, c1, c2, c3 = sm.symbols('c0, c1, c2, c3') \n```", "```py\n>>> fl_T = c0*sm.exp(c3*(l_T_tilde - c1)) - c2\n>>> fl_T\nc0*exp(c3*(-c1 + l_T_tilde(t))) - c2 \n```", "```py\n>>> l_T = me.dynamicsymbols('l_T')\n>>> l_T_slack = sm.symbols('l_T_slack') \n```", "```py\n>>> fl_T = c0*sm.exp(c3*(l_T/l_T_slack - c1)) - c2\n>>> fl_T\nc0*exp(c3*(-c1 + l_T(t)/l_T_slack)) - c2 \n```", "```py\n>>> from sympy.physics.biomechanics import TendonForceLengthDeGroote2016 \n```", "```py\n>>> fl_T2 = TendonForceLengthDeGroote2016(l_T/l_T_slack, c0, c1, c2, c3)\n>>> fl_T2\nTendonForceLengthDeGroote2016(l_T(t)/l_T_slack, c0, c1, c2, c3) \n```", "```py\n>>> fl_T2.doit()\nc0*exp(c3*(-c1 + l_T(t)/l_T_slack)) - c2 \n```", "```py\n>>> fl_T3 = TendonForceLengthDeGroote2016.with_defaults(l_T/l_T_slack)\n>>> fl_T3\nTendonForceLengthDeGroote2016(l_T(t)/l_T_slack, 0.2, 0.995, 0.25, 33.93669377311689) \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> import numpy as np\n>>> from sympy.physics.biomechanics import TendonForceLengthDeGroote2016 \n```", "```py\n>>> l_T_tilde = me.dynamicsymbols('l_T_tilde')\n>>> fl_T = TendonForceLengthDeGroote2016.with_defaults(l_T_tilde)\n>>> fl_T_callable = sm.lambdify(l_T_tilde, fl_T)\n>>> l_T_tilde_num = np.linspace(0.95, 1.05) \n```", "```py\n>>> fig, ax = plt.subplots()\n>>> _ = ax.plot(l_T_tilde_num, fl_T_callable(l_T_tilde_num))\n>>> _ = ax.set_xlabel('Normalized tendon length')\n>>> _ = ax.set_ylabel('Normalized tendon force-length') \n```", "```py\n>>> from sympy.physics.biomechanics import TendonForceLengthInverseDeGroote2016 \n```", "```py\n>>> fl_T_sym =me.dynamicsymbols('fl_T')\n>>> fl_T_inv = TendonForceLengthInverseDeGroote2016(fl_T_sym, c0, c1, c2, c3)\n>>> fl_T_inv\nTendonForceLengthInverseDeGroote2016(fl_T(t), c0, c1, c2, c3) \n```", "```py\n>>> fl_T_inv2 = TendonForceLengthInverseDeGroote2016.with_defaults(fl_T_sym)\n>>> fl_T_inv2\nTendonForceLengthInverseDeGroote2016(fl_T(t), 0.2, 0.995, 0.25, 33.93669377311689) \n```", "```py\n>>> l_M_tilde = me.dynamicsymbols('l_M_tilde')\n>>> c0, c1 = sm.symbols('c0, c1') \n```", "```py\n>>> fl_M_pas = (sm.exp(c1*(l_M_tilde - 1)/c0) - 1)/(sm.exp(c1) - 1)\n>>> fl_M_pas\n(exp(c1*(l_M_tilde(t) - 1)/c0) - 1)/(exp(c1) - 1) \n```", "```py\n>>> l_M = me.dynamicsymbols('l_M')\n>>> l_M_opt = sm.symbols('l_M_opt') \n```", "```py\n>>> fl_M_pas2 = (sm.exp(c1*(l_M/l_M_opt - 1)/c0) - 1)/(sm.exp(c1) - 1)\n>>> fl_M_pas2\n(exp(c1*(-1 + l_M(t)/l_M_opt)/c0) - 1)/(exp(c1) - 1) \n```", "```py\n>>> from sympy.physics.biomechanics import FiberForceLengthPassiveDeGroote2016 \n```", "```py\n>>> fl_M_pas2 = FiberForceLengthPassiveDeGroote2016(l_M/l_M_opt, c0, c1)\n>>> fl_M_pas2\nFiberForceLengthPassiveDeGroote2016(l_M(t)/l_M_opt, c0, c1)\n>>> fl_M_pas2.doit()\n(exp(c1*(-1 + l_M(t)/l_M_opt)/c0) - 1)/(exp(c1) - 1) \n```", "```py\n>>> fl_M_pas3 = FiberForceLengthPassiveDeGroote2016.with_defaults(l_M/l_M_opt)\n>>> fl_M_pas3\nFiberForceLengthPassiveDeGroote2016(l_M(t)/l_M_opt, 0.6, 4.0)\n>>> fl_M_pas3.doit()\n2.37439874427164e-5*exp(6.66666666666667*l_M(t)/l_M_opt) - 0.0186573603637741 \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> import numpy as np\n>>> from sympy.physics.biomechanics import FiberForceLengthPassiveDeGroote2016 \n```", "```py\n>>> l_M_tilde = me.dynamicsymbols('l_M_tilde')\n>>> fl_M_pas = FiberForceLengthPassiveDeGroote2016.with_defaults(l_M_tilde)\n>>> fl_M_pas_callable = sm.lambdify(l_M_tilde, fl_M_pas)\n>>> l_M_tilde_num = np.linspace(0.0, 2.0) \n```", "```py\n>>> fig, ax = plt.subplots()\n>>> _ = ax.plot(l_M_tilde_num, fl_M_pas_callable(l_M_tilde_num))\n>>> _ = ax.set_xlabel('Normalized fiber length')\n>>> _ = ax.set_ylabel('Normalized fiber passive force-length') \n```", "```py\n>>> from sympy.physics.biomechanics import FiberForceLengthPassiveInverseDeGroote2016 \n```", "```py\n>>> fl_M_pas_sym =me.dynamicsymbols('fl_M_pas')\n>>> fl_M_pas_inv = FiberForceLengthPassiveInverseDeGroote2016(fl_M_pas_sym, c0, c1)\n>>> fl_M_pas_inv\nFiberForceLengthPassiveInverseDeGroote2016(fl_M_pas(t), c0, c1) \n```", "```py\n>>> fl_M_pas_inv2 = FiberForceLengthPassiveInverseDeGroote2016.with_defaults(fl_M_pas_sym)\n>>> fl_M_pas_inv2\nFiberForceLengthPassiveInverseDeGroote2016(fl_M_pas(t), 0.6, 4.0) \n```", "```py\n>>> constants = sm.symbols('c0:12')\n>>> c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11 = constants \n```", "```py\n>>> fl_M_act = (c0*sm.exp(-(((l_M_tilde - c1)/(c2 + c3*l_M_tilde))**2)/2) + c4*sm.exp(-(((l_M_tilde - c5)/(c6 + c7*l_M_tilde))**2)/2) + c8*sm.exp(-(((l_M_tilde - c9)/(c10 + c11*l_M_tilde))**2)/2))\n>>> fl_M_act\nc0*exp(-(-c1 + l_M_tilde(t))**2/(2*(c2 + c3*l_M_tilde(t))**2)) + c4*exp(-(-c5 + l_M_tilde(t))**2/(2*(c6 + c7*l_M_tilde(t))**2)) + c8*exp(-(-c9 + l_M_tilde(t))**2/(2*(c10 + c11*l_M_tilde(t))**2)) \n```", "```py\n>>> from sympy.physics.biomechanics import FiberForceLengthActiveDeGroote2016 \n```", "```py\n>>> fl_M_act2 = FiberForceLengthActiveDeGroote2016(l_M/l_M_opt, *constants)\n>>> fl_M_act2\nFiberForceLengthActiveDeGroote2016(l_M(t)/l_M_opt, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, c10, c11)\n>>> fl_M_act2.doit()\nc0*exp(-(-c1 + l_M(t)/l_M_opt)**2/(2*(c2 + c3*l_M(t)/l_M_opt)**2)) + c4*exp(-(-c5 + l_M(t)/l_M_opt)**2/(2*(c6 + c7*l_M(t)/l_M_opt)**2)) + c8*exp(-(-c9 + l_M(t)/l_M_opt)**2/(2*(c10 + c11*l_M(t)/l_M_opt)**2)) \n```", "```py\n>>> fl_M_act3 = FiberForceLengthActiveDeGroote2016.with_defaults(l_M/l_M_opt)\n>>> fl_M_act3\nFiberForceLengthActiveDeGroote2016(l_M(t)/l_M_opt, 0.814, 1.06, 0.162, 0.0633, 0.433, 0.717, -0.0299, 0.2, 0.1, 1.0, 0.354, 0.0)\n>>> fl_M_act3.doit()\n0.1*exp(-3.98991349867535*(-1 + l_M(t)/l_M_opt)**2) + 0.433*exp(-12.5*(-0.717 + l_M(t)/l_M_opt)**2/(-0.1495 + l_M(t)/l_M_opt)**2) + 0.814*exp(-21.4067977442463*(-1 + 0.943396226415094*l_M(t)/l_M_opt)**2/(1 + 0.390740740740741*l_M(t)/l_M_opt)**2) \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> import numpy as np\n>>> from sympy.physics.biomechanics import FiberForceLengthActiveDeGroote2016 \n```", "```py\n>>> l_M_tilde = me.dynamicsymbols('l_M_tilde')\n>>> fl_M_act = FiberForceLengthActiveDeGroote2016.with_defaults(l_M_tilde)\n>>> fl_M_act_callable = sm.lambdify(l_M_tilde, fl_M_act)\n>>> l_M_tilde_num = np.linspace(0.0, 2.0) \n```", "```py\n>>> fig, ax = plt.subplots()\n>>> _ = ax.plot(l_M_tilde_num, fl_M_act_callable(l_M_tilde_num))\n>>> _ = ax.set_xlabel('Normalized fiber length')\n>>> _ = ax.set_ylabel('Normalized fiber active force-length') \n```", "```py\n>>> v_M_tilde = me.dynamicsymbols('v_M_tilde')\n>>> c0, c1, c2, c3 = sm.symbols('c0, c1, c2, c3') \n```", "```py\n>>> fv_M = c0*sm.log(c1*v_M_tilde + c2 + sm.sqrt((c1*v_M_tilde + c2)**2 + 1)) + c3\n>>> fv_M\nc0*log(c1*v_M_tilde(t) + c2 + sqrt((c1*v_M_tilde(t) + c2)**2 + 1)) + c3 \n```", "```py\n>>> v_M = me.dynamicsymbols('v_M')\n>>> v_M_max = sm.symbols('v_M_max') \n```", "```py\n>>> fv_M_pas2 = c0*sm.log(c1*v_M/v_M_max + c2 + sm.sqrt((c1*v_M/v_M_max + c2)**2 + 1)) + c3\n>>> fv_M_pas2\nc0*log(c1*v_M(t)/v_M_max + c2 + sqrt((c1*v_M(t)/v_M_max + c2)**2 + 1)) + c3 \n```", "```py\n>>> from sympy.physics.biomechanics import FiberForceVelocityDeGroote2016 \n```", "```py\n>>> fv_M2 = FiberForceVelocityDeGroote2016(v_M/v_M_max, c0, c1, c2, c3)\n>>> fv_M2\nFiberForceVelocityDeGroote2016(v_M(t)/v_M_max, c0, c1, c2, c3)\n>>> fv_M2.doit()\nc0*log(c1*v_M(t)/v_M_max + c2 + sqrt((c1*v_M(t)/v_M_max + c2)**2 + 1)) + c3 \n```", "```py\n>>> fv_M3 = FiberForceVelocityDeGroote2016.with_defaults(v_M/v_M_max)\n>>> fv_M3\nFiberForceVelocityDeGroote2016(v_M(t)/v_M_max, -0.318, -8.149, -0.374, 0.886)\n>>> fv_M3.doit()\n0.886 - 0.318*log(8.149*sqrt((-0.0458952018652595 - v_M(t)/v_M_max)**2 + 0.0150588346410601) - 0.374 - 8.149*v_M(t)/v_M_max) \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> import numpy as np\n>>> from sympy.physics.biomechanics import FiberForceVelocityDeGroote2016 \n```", "```py\n>>> v_M_tilde = me.dynamicsymbols('v_M_tilde')\n>>> fv_M = FiberForceVelocityDeGroote2016.with_defaults(v_M_tilde)\n>>> fv_M_callable = sm.lambdify(v_M_tilde, fv_M)\n>>> v_M_tilde_num = np.linspace(-1.0, 1.0) \n```", "```py\n>>> fig, ax = plt.subplots()\n>>> _ = ax.plot(l_M_tilde_num, fv_M_callable(v_M_tilde_num))\n>>> _ = ax.set_xlabel('Normalized fiber velocity')\n>>> _ = ax.set_ylabel('Normalized fiber force-velocity') \n```", "```py\n>>> from sympy.physics.biomechanics import FiberForceVelocityInverseDeGroote2016 \n```", "```py\n>>> fv_M_sym = me.dynamicsymbols('fv_M')\n>>> fv_M_inv = FiberForceVelocityInverseDeGroote2016(fv_M_sym, c0, c1, c2, c3)\n>>> fv_M_inv\nFiberForceVelocityInverseDeGroote2016(fv_M(t), c0, c1, c2, c3) \n```", "```py\n>>> fv_M_inv2 = FiberForceVelocityInverseDeGroote2016.with_defaults(fv_M_sym)\n>>> fv_M_inv2\nFiberForceVelocityInverseDeGroote2016(fv_M(t), -0.318, -8.149, -0.374, 0.886) \n```", "```py\n>>> l_MT, v_MT, a = me.dynamicsymbols('l_MT, v_MT, a')\n>>> l_T_slack, l_M_opt, F_M_max = sm.symbols('l_T_slack, l_M_opt, F_M_max')\n>>> v_M_max, alpha_opt, beta = sm.symbols('v_M_max, alpha_opt, beta') \n```", "```py\n>>> l_M = sm.sqrt((l_MT - l_T_slack)**2 + (l_M_opt*sm.sin(alpha_opt))**2)\n>>> l_M\nsqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2) \n```", "```py\n>>> v_M = v_MT*(l_MT - l_T_slack)/l_M\n>>> v_M\n(-l_T_slack + l_MT(t))*v_MT(t)/sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2) \n```", "```py\n>>> fl_M_pas = FiberForceLengthPassiveDeGroote2016.with_defaults(l_M/l_M_opt)\n>>> fl_M_pas\nFiberForceLengthPassiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)/l_M_opt, 0.6, 4.0) \n```", "```py\n>>> fl_M_act = FiberForceLengthActiveDeGroote2016.with_defaults(l_M/l_M_opt)\n>>> fl_M_act\nFiberForceLengthActiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)/l_M_opt, 0.814, 1.06, 0.162, 0.0633, 0.433, 0.717, -0.0299, 0.2, 0.1, 1.0, 0.354, 0.0) \n```", "```py\n>>> fv_M = FiberForceVelocityDeGroote2016.with_defaults(v_M/v_M_max)\n>>> fv_M\nFiberForceVelocityDeGroote2016((-l_T_slack + l_MT(t))*v_MT(t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)), -0.318, -8.149, -0.374, 0.886) \n```", "```py\n>>> F_M = a*fl_M_act*fv_M + fl_M_pas + beta*v_M/v_M_max\n>>> F_M\nbeta*(-l_T_slack + l_MT(t))*v_MT(t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)) + a(t)*FiberForceLengthActiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)/l_M_opt, 0.814, 1.06, 0.162, 0.0633, 0.433, 0.717, -0.0299, 0.2, 0.1, 1.0, 0.354, 0.0)*FiberForceVelocityDeGroote2016((-l_T_slack + l_MT(t))*v_MT(t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)), -0.318, -8.149, -0.374, 0.886) + FiberForceLengthPassiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)/l_M_opt, 0.6, 4.0) \n```", "```py\n>>> F_T = F_M_max*F_M*sm.sqrt(1 - sm.sin(alpha_opt)**2)\n>>> F_T\nF_M_max*sqrt(1 - sin(alpha_opt)**2)*(beta*(-l_T_slack + l_MT(t))*v_MT(t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)) + a(t)*FiberForceLengthActiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)/l_M_opt, 0.814, 1.06, 0.162, 0.0633, 0.433, 0.717, -0.0299, 0.2, 0.1, 1.0, 0.354, 0.0)*FiberForceVelocityDeGroote2016((-l_T_slack + l_MT(t))*v_MT(t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)), -0.318, -8.149, -0.374, 0.886) + FiberForceLengthPassiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + l_MT(t))**2)/l_M_opt, 0.6, 4.0)) \n```", "```py\n>>> import pprint\n>>> import sympy as sm\n>>> import sympy.physics.mechanics as me \n```", "```py\n>>> q, u = me.dynamicsymbols('q, u', real=True)\n>>> m, g = sm.symbols('m, g', real=True, positive=True) \n```", "```py\n>>> N = me.ReferenceFrame('N')\n>>> O, P = sm.symbols('O, P', cls=me.Point) \n```", "```py\n>>> P.set_pos(O, q*N.x)\n>>> O.set_vel(N, 0)\n>>> P.set_vel(N, u*N.x) \n```", "```py\n>>> gravity = me.Force(P, m*g*N.x) \n```", "```py\n>>> block = me.Particle('block', P, m) \n```", "```py\n>>> from sympy.physics.mechanics.pathway import LinearPathway \n```", "```py\n>>> muscle_pathway = LinearPathway(O, P) \n```", "```py\n>>> muscle_pathway.attachments\n(O, P) \n```", "```py\n>>> muscle_pathway.length\nAbs(q(t))\n>>> muscle_pathway.extension_velocity\nsign(q(t))*Derivative(q(t), t) \n```", "```py\n>>> muscle_pathway.to_loads(m*g)\n[(O, - g*m*q(t)/Abs(q(t))*N.x), (P, g*m*q(t)/Abs(q(t))*N.x)] \n```", "```py\n>>> from sympy.physics.biomechanics import FirstOrderActivationDeGroote2016\n>>> muscle_activation = FirstOrderActivationDeGroote2016.with_defaults('muscle') \n```", "```py\n>>> muscle_activation.x\nMatrix([[a_muscle(t)]])\n>>> muscle_activation.r\nMatrix([[e_muscle(t)]])\n>>> muscle_activation.p\nMatrix(0, 1, []) \n```", "```py\n>>> muscle_activation.rhs()\nMatrix([[((1/2 - tanh(10.0*a_muscle(t) - 10.0*e_muscle(t))/2)/(0.0225*a_muscle(t) + 0.0075) + 16.6666666666667*(3*a_muscle(t)/2 + 1/2)*(tanh(10.0*a_muscle(t) - 10.0*e_muscle(t))/2 + 1/2))*(-a_muscle(t) + e_muscle(t))]]) \n```", "```py\n>>> from sympy.physics.biomechanics import MusculotendonDeGroote2016 \n```", "```py\n>>> F_M_max, l_M_opt, l_T_slack = sm.symbols('F_M_max, l_M_opt, l_T_slack', real=True)\n>>> v_M_max, alpha_opt, beta = sm.symbols('v_M_max, alpha_opt, beta', real=True) \n```", "```py\n>>> muscle = MusculotendonDeGroote2016.with_defaults(\n...     'muscle',\n...     muscle_pathway,\n...     muscle_activation,\n...     tendon_slack_length=l_T_slack,\n...     peak_isometric_force=F_M_max,\n...     optimal_fiber_length=l_M_opt,\n...     maximal_fiber_velocity=v_M_max,\n...     optimal_pennation_angle=alpha_opt,\n...     fiber_damping_coefficient=beta,\n... )\n... \n```", "```py\n>>> muscle.musculotendon_dynamics\n0\n>>> muscle.x\nMatrix([[a_muscle(t)]])\n>>> muscle.r\nMatrix([[e_muscle(t)]])\n>>> muscle.p\nMatrix([\n[l_T_slack],\n[  F_M_max],\n[  l_M_opt],\n[  v_M_max],\n[alpha_opt],\n[     beta]])\n>>> muscle.rhs()\nMatrix([[((1/2 - tanh(10.0*a_muscle(t) - 10.0*e_muscle(t))/2)/(0.0225*a_muscle(t) + 0.0075) + 16.6666666666667*(3*a_muscle(t)/2 + 1/2)*(tanh(10.0*a_muscle(t) - 10.0*e_muscle(t))/2 + 1/2))*(-a_muscle(t) + e_muscle(t))]]) \n```", "```py\n>>> muscle_loads = muscle.to_loads()\n>>> pprint.pprint(muscle_loads)\n[Force(point=O, force=F_M_max*(beta*(-l_T_slack + Abs(q(t)))*sign(q(t))*Derivative(q(t), t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)) + a_muscle(t)*FiberForceLengthActiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)/l_M_opt, 0.814, 1.06, 0.162, 0.0633, 0.433, 0.717, -0.0299, 0.2, 0.1, 1.0, 0.354, 0.0)*FiberForceVelocityDeGroote2016((-l_T_slack + Abs(q(t)))*sign(q(t))*Derivative(q(t), t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)), -0.318, -8.149, -0.374, 0.886) + FiberForceLengthPassiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)/l_M_opt, 0.6, 4.0))*q(t)*cos(alpha_opt)/Abs(q(t))*N.x),\n Force(point=P, force=- F_M_max*(beta*(-l_T_slack + Abs(q(t)))*sign(q(t))*Derivative(q(t), t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)) + a_muscle(t)*FiberForceLengthActiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)/l_M_opt, 0.814, 1.06, 0.162, 0.0633, 0.433, 0.717, -0.0299, 0.2, 0.1, 1.0, 0.354, 0.0)*FiberForceVelocityDeGroote2016((-l_T_slack + Abs(q(t)))*sign(q(t))*Derivative(q(t), t)/(v_M_max*sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)), -0.318, -8.149, -0.374, 0.886) + FiberForceLengthPassiveDeGroote2016(sqrt(l_M_opt**2*sin(alpha_opt)**2 + (-l_T_slack + Abs(q(t)))**2)/l_M_opt, 0.6, 4.0))*q(t)*cos(alpha_opt)/Abs(q(t))*N.x)] \n```", "```py\n>>> kane = me.KanesMethod(N, (q,), (u,), kd_eqs=(u - q.diff(),))\n>>> Fr, Frs = kane.kanes_equations((block,), (muscle_loads + [gravity])) \n```", "```py\n>>> dqdt = u\n>>> dudt = kane.forcing[0]/m\n>>> dadt = muscle.rhs()[0] \n```", "```py\n>>> a = muscle.a\n>>> e = muscle.e\n>>> state = [q, u, a]\n>>> inputs = [e]\n>>> constants = [m, g, F_M_max, l_M_opt, l_T_slack, v_M_max, alpha_opt, beta] \n```", "```py\n>>> eval_eom = sm.lambdify((state, inputs, constants), (dqdt, dudt, dadt)) \n```", "```py\n>>> force = muscle.force.xreplace({q.diff(): u})\n>>> eval_force = sm.lambdify((state, constants), force) \n```", "```py\n>>> import numpy as np\n>>> p_vals = np.array([\n...     0.5,  # m [kg]\n...     9.81,  # g [m/s/s]\n...     10.0,  # F_M_max [N]\n...     0.18,  # l_M_opt [m]\n...     0.17,  # l_T_slack [m]\n...     10.0,  # v_M_max [m/s]\n...     0.0,  # alpha_opt\n...     0.1,  # beta\n... ])\n... \n```", "```py\n>>> x_vals = np.array([\n...     p_vals[3] + p_vals[4],  # q [m]\n...     0.0,  # u [m/s]\n...     0.1,  # a [unitless]\n... ])\n... \n```", "```py\n>>> r_vals = np.array([\n...     1.0,  # e\n... ])\n...\n>>> eval_eom(x_vals, r_vals, p_vals)\n(0.0, 7.817106179880225, 92.30769105034035)\n>>> eval_force(x_vals, p_vals)\n-0.9964469100598874 \n```", "```py\n>>> def eval_rhs(t, x):\n...\n...     r = np.array([1.0])\n...\n...     return eval_eom(x, r, p_vals)\n...\n>>> from scipy.integrate import solve_ivp\n>>> t0, tf = 0.0, 6.0\n>>> times = np.linspace(t0, tf, num=601)\n>>> sol = solve_ivp(eval_rhs,\n...                 (t0, tf),\n...                 x_vals, t_eval=times)\n...\n>>> import matplotlib.pyplot as plt\n>>> fig, axes = plt.subplots(4, 1, sharex=True)\n>>> _ = axes[0].plot(sol.t, sol.y[0] - p_vals[4], label='length of muscle')\n>>> _ = axes[0].set_ylabel('Distance [m]')\n>>> _ = axes[1].plot(sol.t, sol.y[1], label=state[1])\n>>> _ = axes[1].set_ylabel('Speed [m/s]')\n>>> _ = axes[2].plot(sol.t, sol.y[2], label=state[2])\n>>> _ = axes[2].set_ylabel('Activation')\n>>> _ = axes[3].plot(sol.t, eval_force(sol.y, p_vals).T, label='force')\n>>> _ = axes[3].set_ylabel('Force [N]')\n>>> _ = axes[3].set_xlabel('Time [s]')\n>>> _ = axes[0].legend(), axes[1].legend(), axes[2].legend(), axes[3].legend() \n```"]