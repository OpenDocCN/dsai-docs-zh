- en: NumPy 1.20.0 Release Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/release/1.20.0-notes.html](https://numpy.org/doc/1.26/release/1.20.0-notes.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This NumPy release is the largest so made to date, some 684 PRs contributed
    by 184 people have been merged. See the list of highlights below for more details.
    The Python versions supported for this release are 3.7-3.9, support for Python
    3.6 has been dropped. Highlights are
  prefs: []
  type: TYPE_NORMAL
- en: Annotations for NumPy functions. This work is ongoing and improvements can be
    expected pending feedback from users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wider use of SIMD to increase execution speed of ufuncs. Much work has been
    done in introducing universal functions that will ease use of modern features
    across different hardware platforms. This work is ongoing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preliminary work in changing the dtype and casting implementations in order
    to provide an easier path to extending dtypes. This work is ongoing but enough
    has been done to allow experimentation and feedback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensive documentation improvements comprising some 185 PR merges. This work
    is ongoing and part of the larger project to improve NumPy’s online presence and
    usefulness to new users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further cleanups related to removing Python 2.7\. This improves code readability
    and removes technical debt.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Preliminary support for the upcoming Cython 3.0.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The random.Generator class has a new `permuted` function.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new function differs from `shuffle` and `permutation` in that the subarrays
    indexed by an axis are permuted rather than the axis being treated as a separate
    1-D array for every combination of the other indexes. For example, it is now possible
    to permute the rows or columns of a 2-D array.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15121](https://github.com/numpy/numpy/pull/15121))
  prefs: []
  type: TYPE_NORMAL
- en: '`sliding_window_view` provides a sliding window view for numpy arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`numpy.lib.stride_tricks.sliding_window_view`](../reference/generated/numpy.lib.stride_tricks.sliding_window_view.html#numpy.lib.stride_tricks.sliding_window_view
    "numpy.lib.stride_tricks.sliding_window_view") constructs views on numpy arrays
    that offer a sliding or moving window access to the array. This allows for the
    simple implementation of certain algorithms, such as running means.'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17394](https://github.com/numpy/numpy/pull/17394))
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.broadcast_shapes`](../reference/generated/numpy.broadcast_shapes.html#numpy.broadcast_shapes
    "numpy.broadcast_shapes") is a new user-facing function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`broadcast_shapes`](../reference/generated/numpy.broadcast_shapes.html#numpy.broadcast_shapes
    "numpy.broadcast_shapes") gets the resulting shape from broadcasting the given
    shape tuples against each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-17535](https://github.com/numpy/numpy/pull/17535))
  prefs: []
  type: TYPE_NORMAL
- en: Deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the aliases of builtin types like `np.int` is deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a long time, `np.int` has been an alias of the builtin `int`. This is repeatedly
    a cause of confusion for newcomers, and existed mainly for historic reasons.
  prefs: []
  type: TYPE_NORMAL
- en: These aliases have been deprecated. The table below shows the full list of deprecated
    aliases, along with their exact meaning. Replacing uses of items in the first
    column with the contents of the second column will work identically and silence
    the deprecation warning.
  prefs: []
  type: TYPE_NORMAL
- en: The third column lists alternative NumPy names which may occasionally be preferential.
    See also [Data types](../user/basics.types.html#basics-types) for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: '| Deprecated name | Identical to | NumPy scalar type names |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.bool` | `bool` | [`numpy.bool_`](../reference/arrays.scalars.html#numpy.bool_
    "numpy.bool_") |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.int` | `int` | [`numpy.int_`](../reference/arrays.scalars.html#numpy.int_
    "numpy.int_") (default), `numpy.int64`, or `numpy.int32` |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.float` | `float` | [`numpy.float64`](../reference/arrays.scalars.html#numpy.float64
    "numpy.float64"), [`numpy.float_`](../reference/arrays.scalars.html#numpy.float_
    "numpy.float_"), [`numpy.double`](../reference/arrays.scalars.html#numpy.double
    "numpy.double") (equivalent) |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.complex` | `complex` | [`numpy.complex128`](../reference/arrays.scalars.html#numpy.complex128
    "numpy.complex128"), [`numpy.complex_`](../reference/arrays.scalars.html#numpy.complex_
    "numpy.complex_"), [`numpy.cdouble`](../reference/arrays.scalars.html#numpy.cdouble
    "numpy.cdouble") (equivalent) |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.object` | `object` | [`numpy.object_`](../reference/arrays.scalars.html#numpy.object_
    "numpy.object_") |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.str` | `str` | [`numpy.str_`](../reference/arrays.scalars.html#numpy.str_
    "numpy.str_") |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.long` | `int` | [`numpy.int_`](../reference/arrays.scalars.html#numpy.int_
    "numpy.int_") (C `long`), [`numpy.longlong`](../reference/arrays.scalars.html#numpy.longlong
    "numpy.longlong") (largest integer type) |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.unicode` | `str` | [`numpy.unicode_`](../reference/arrays.scalars.html#numpy.unicode_
    "numpy.unicode_") |'
  prefs: []
  type: TYPE_TB
- en: To give a clear guideline for the vast majority of cases, for the types `bool`,
    `object`, `str` (and `unicode`) using the plain version is shorter and clear,
    and generally a good replacement. For `float` and `complex` you can use `float64`
    and `complex128` if you wish to be more explicit about the precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `np.int` a direct replacement with `np.int_` or `int` is also good and
    will not change behavior, but the precision will continue to depend on the computer
    and operating system. If you want to be more explicit and review the current use,
    you have the following alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.int64` or `np.int32` to specify the precision exactly. This ensures that
    results cannot depend on the computer or operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.int_` or `int` (the default), but be aware that it depends on the computer
    and operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The C types: `np.cint` (int), `np.int_` (long), `np.longlong`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.intp` which is 32bit on 32bit machines 64bit on 64bit machines. This can
    be the best type to use for indexing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When used with `np.dtype(...)` or `dtype=...` changing it to the NumPy name
    as mentioned above will have no effect on the output. If used as a scalar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: changing it can subtly change the result. In this case, the Python version `float(123)`
    or `int(12.)` is normally preferable, although the NumPy version may be useful
    for consistency with NumPy arrays (for example, NumPy behaves differently for
    things like division by zero).
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-14882](https://github.com/numpy/numpy/pull/14882))
  prefs: []
  type: TYPE_NORMAL
- en: Passing `shape=None` to functions with a non-optional shape argument is deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, this was an alias for passing `shape=()`. This deprecation is emitted
    by *PyArray_IntpConverter* in the C API. If your API is intended to support passing
    `None`, then you should check for `None` prior to invoking the converter, so as
    to be able to distinguish `None` and `()`.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15886](https://github.com/numpy/numpy/pull/15886))
  prefs: []
  type: TYPE_NORMAL
- en: Indexing errors will be reported even when index result is empty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the future, NumPy will raise an IndexError when an integer array index contains
    out of bound values even if a non-indexed dimension is of length 0\. This will
    now emit a DeprecationWarning. This can happen when the array is previously empty,
    or an empty slice is involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Previously the non-empty index `[20]` was not checked for correctness. It will
    now be checked causing a deprecation warning which will be turned into an error.
    This also applies to assignments.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15900](https://github.com/numpy/numpy/pull/15900))
  prefs: []
  type: TYPE_NORMAL
- en: Inexact matches for `mode` and `searchside` are deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inexact and case insensitive matches for `mode` and `searchside` were valid
    inputs earlier and will give a DeprecationWarning now. For example, below are
    some example usages which are now deprecated and will give a DeprecationWarning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16056](https://github.com/numpy/numpy/pull/16056))
  prefs: []
  type: TYPE_NORMAL
- en: Deprecation of *numpy.dual*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The module *numpy.dual* is deprecated. Instead of importing functions from *numpy.dual*,
    the functions should be imported directly from NumPy or SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16156](https://github.com/numpy/numpy/pull/16156))
  prefs: []
  type: TYPE_NORMAL
- en: '`outer` and `ufunc.outer` deprecated for matrix'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.matrix` use with [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer") or generic ufunc outer calls such as `numpy.add.outer`. Previously,
    matrix was converted to an array here. This will not be done in the future requiring
    a manual conversion to arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16232](https://github.com/numpy/numpy/pull/16232))
  prefs: []
  type: TYPE_NORMAL
- en: Further Numeric Style types Deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The remaining numeric-style type codes `Bytes0`, `Str0`, `Uint32`, `Uint64`,
    and `Datetime64` have been deprecated. The lower-case variants should be used
    instead. For bytes and string `"S"` and `"U"` are further alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16554](https://github.com/numpy/numpy/pull/16554))
  prefs: []
  type: TYPE_NORMAL
- en: The `ndincr` method of `ndindex` is deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The documentation has warned against using this function since NumPy 1.8. Use
    `next(it)` instead of `it.ndincr()`.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17233](https://github.com/numpy/numpy/pull/17233))
  prefs: []
  type: TYPE_NORMAL
- en: ArrayLike objects which do not define `__len__` and `__getitem__`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects which define one of the protocols `__array__`, `__array_interface__`,
    or `__array_struct__` but are not sequences (usually defined by having a `__len__`
    and `__getitem__`) will behave differently during array-coercion in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'When nested inside sequences, such as `np.array([array_like])`, these were
    handled as a single Python object rather than an array. In the future they will
    behave identically to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This change should only have an effect if `np.array(array_like)` is not 0-D.
    The solution to this warning may depend on the object:'
  prefs: []
  type: TYPE_NORMAL
- en: Some array-likes may expect the new behaviour, and users can ignore the warning.
    The object can choose to expose the sequence protocol to opt-in to the new behaviour.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `shapely` will allow conversion to an array-like using `line.coords`
    rather than `np.asarray(line)`. Users may work around the warning, or use the
    new convention when it becomes available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, using the new behaviour can only be achieved by calling `np.array(array_like)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to ensure that the old behaviour remains unchanged, please create
    an object array and then fill it explicitly, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure NumPy knows to not enter the array-like and use it as a object
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17973](https://github.com/numpy/numpy/pull/17973))
  prefs: []
  type: TYPE_NORMAL
- en: Future Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays cannot be using subarray dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Array creation and casting using `np.array(arr, dtype)` and `arr.astype(dtype)`
    will use different logic when `dtype` is a subarray dtype such as `np.dtype("(2)i,")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For such a `dtype` the following behaviour is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'But `res` is filled using the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'which uses incorrect broadcasting (and often leads to an error). In the future,
    this will instead cast each element individually, leading to the same result as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Which can normally be used to opt-in to the new behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: This change does not affect `np.array(list, dtype="(2)i,")` unless the `list`
    itself includes at least one array. In particular, the behaviour is unchanged
    for a list of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17596](https://github.com/numpy/numpy/pull/17596))
  prefs: []
  type: TYPE_NORMAL
- en: Expired deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The deprecation of numeric style type-codes `np.dtype("Complex64")` (with upper
    case spelling), is expired. `"Complex64"` corresponded to `"complex128"` and `"Complex32"`
    corresponded to `"complex64"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deprecation of `np.sctypeNA` and `np.typeNA` is expired. Both have been
    removed from the public API. Use `np.typeDict` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([gh-16554](https://github.com/numpy/numpy/pull/16554))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The 14-year deprecation of `np.ctypeslib.ctypes_load_library` is expired. Use
    [`load_library`](../reference/routines.ctypeslib.html#numpy.ctypeslib.load_library
    "numpy.ctypeslib.load_library") instead, which is identical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([gh-17116](https://github.com/numpy/numpy/pull/17116))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Financial functions removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In accordance with NEP 32, the financial functions are removed from NumPy 1.20\.
    The functions that have been removed are `fv`, `ipmt`, `irr`, `mirr`, `nper`,
    `npv`, `pmt`, `ppmt`, `pv`, and `rate`. These functions are available in the [numpy_financial](https://pypi.org/project/numpy-financial)
    library.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17067](https://github.com/numpy/numpy/pull/17067))
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`isinstance(dtype, np.dtype)` and not `type(dtype) is not np.dtype`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy dtypes are not direct instances of `np.dtype` anymore. Code that may have
    used `type(dtype) is np.dtype` will always return `False` and must be updated
    to use the correct version `isinstance(dtype, np.dtype)`.
  prefs: []
  type: TYPE_NORMAL
- en: This change also affects the C-side macro `PyArray_DescrCheck` if compiled against
    a NumPy older than 1.16.6\. If code uses this macro and wishes to compile against
    an older version of NumPy, it must replace the macro (see also [C API changes](#c-api-changes)
    section).
  prefs: []
  type: TYPE_NORMAL
- en: Same kind casting in concatenate with `axis=None`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate") is called with `axis=None`, the flattened arrays were cast
    with `unsafe`. Any other axis choice uses “same kind”. That different default
    has been deprecated and “same kind” casting will be used instead. The new `casting`
    keyword argument can be used to retain the old behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16134](https://github.com/numpy/numpy/pull/16134))
  prefs: []
  type: TYPE_NORMAL
- en: NumPy Scalars are cast when assigned to arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating or assigning to arrays, in all relevant cases NumPy scalars will
    now be cast identically to NumPy arrays. In particular this changes the behaviour
    in some cases which previously raised an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'will succeed and return an undefined result (usually the smallest possible
    integer). This also affects assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'At this time, NumPy retains the behaviour for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The above changes do not affect Python scalars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'remains unaffected (`np.nan` is a Python `float`, not a NumPy one). Unlike
    signed integers, unsigned integers do not retain this special case, since they
    always behaved more like casting. The following code stops raising an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To avoid backward compatibility issues, at this time assignment from `datetime64`
    scalar to strings of too short length remains supported. This means that `np.asarray(np.datetime64("2020-10-10"),
    dtype="S5")` succeeds now, when it failed before. In the long term this may be
    deprecated or the unsafe cast may be allowed generally to make assignment of arrays
    and scalars behave consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Array coercion changes when Strings and other types are mixed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When strings and other types are mixed, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The results will change, which may lead to string dtypes with longer strings
    in some cases. In particularly, if `dtype="S"` is not provided any numerical value
    will lead to a string results long enough to hold all possible numerical values.
    (e.g. “S32” for floats). Note that you should always provide `dtype="S"` when
    converting non-strings to strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `dtype="S"` is provided the results will be largely identical to before,
    but NumPy scalars (not a Python float like `1.0`), will still enforce a uniform
    string length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Previously the first version gave the same result as the second.
  prefs: []
  type: TYPE_NORMAL
- en: Array coercion restructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Array coercion has been restructured. In general, this should not affect users.
    In extremely rare corner cases where array-likes are nested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Things will now be more consistent with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This can subtly change output for some badly defined array-likes. One example
    for this are array-like objects which are not also sequences of matching shape.
    In NumPy 1.20, a warning will be given when an array-like is not also a sequence
    (but behaviour remains identical, see deprecations). If an array like is also
    a sequence (defines `__getitem__` and `__len__`) NumPy will now only use the result
    given by `__array__`, `__array_interface__`, or `__array_struct__`. This will
    result in differences when the (nested) sequence describes a different shape.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16200](https://github.com/numpy/numpy/pull/16200))
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the result of [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") will export readonly buffers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In NumPy 1.17 [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") started warning when the resulting array was written
    to. This warning was skipped when the array was used through the buffer interface
    (e.g. `memoryview(arr)`). The same thing will now occur for the two protocols
    `__array_interface__`, and `__array_struct__` returning read-only buffers instead
    of giving a warning.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16350](https://github.com/numpy/numpy/pull/16350))
  prefs: []
  type: TYPE_NORMAL
- en: Numeric-style type names have been removed from type dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To stay in sync with the deprecation for `np.dtype("Complex64")` and other numeric-style
    (capital case) types. These were removed from `np.sctypeDict` and `np.typeDict`.
    You should use the lower case versions instead. Note that `"Complex64"` corresponds
    to `"complex128"` and `"Complex32"` corresponds to `"complex64"`. The numpy style
    (new) versions, denote the full size and not the size of the real/imaginary part.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16554](https://github.com/numpy/numpy/pull/16554))
  prefs: []
  type: TYPE_NORMAL
- en: The `operator.concat` function now raises TypeError for array arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous behavior was to fall back to addition and add the two arrays, which
    was thought to be unexpected behavior for a concatenation function.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16570](https://github.com/numpy/numpy/pull/16570))
  prefs: []
  type: TYPE_NORMAL
- en: '`nickname` attribute removed from ABCPolyBase'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An abstract property `nickname` has been removed from `ABCPolyBase` as it was
    no longer used in the derived convenience classes. This may affect users who have
    derived classes from `ABCPolyBase` and overridden the methods for representation
    and display, e.g. `__str__`, `__repr__`, `_repr_latex`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16589](https://github.com/numpy/numpy/pull/16589))
  prefs: []
  type: TYPE_NORMAL
- en: '`float->timedelta` and `uint64->timedelta` promotion will raise a TypeError'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Float and timedelta promotion consistently raises a TypeError. `np.promote_types("float32",
    "m8")` aligns with `np.promote_types("m8", "float32")` now and both raise a TypeError.
    Previously, `np.promote_types("float32", "m8")` returned `"m8"` which was considered
    a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Uint64 and timedelta promotion consistently raises a TypeError. `np.promote_types("uint64",
    "m8")` aligns with `np.promote_types("m8", "uint64")` now and both raise a TypeError.
    Previously, `np.promote_types("uint64", "m8")` returned `"m8"` which was considered
    a bug.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16592](https://github.com/numpy/numpy/pull/16592))
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.genfromtxt` now correctly unpacks structured arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, [`numpy.genfromtxt`](../reference/generated/numpy.genfromtxt.html#numpy.genfromtxt
    "numpy.genfromtxt") failed to unpack if it was called with `unpack=True` and a
    structured datatype was passed to the `dtype` argument (or `dtype=None` was passed
    and a structured datatype was inferred). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Structured arrays will now correctly unpack into a list of arrays, one for
    each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16650](https://github.com/numpy/numpy/pull/16650))
  prefs: []
  type: TYPE_NORMAL
- en: '`mgrid`, `r_`, etc. consistently return correct outputs for non-default precision
    input'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, `np.mgrid[np.float32(0.1):np.float32(0.35):np.float32(0.1),]` and
    `np.r_[0:10:np.complex64(3j)]` failed to return meaningful output. This bug potentially
    affects [`mgrid`](../reference/generated/numpy.mgrid.html#numpy.mgrid "numpy.mgrid"),
    [`ogrid`](../reference/generated/numpy.ogrid.html#numpy.ogrid "numpy.ogrid"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_"), and [`c_`](../reference/generated/numpy.c_.html#numpy.c_
    "numpy.c_") when an input with dtype other than the default `float64` and `complex128`
    and equivalent Python types were used. The methods have been fixed to handle varying
    precision correctly.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16815](https://github.com/numpy/numpy/pull/16815))
  prefs: []
  type: TYPE_NORMAL
- en: Boolean array indices with mismatching shapes now properly give `IndexError`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, if a boolean array index matched the size of the indexed array but
    not the shape, it was incorrectly allowed in some cases. In other cases, it gave
    an error, but the error was incorrectly a `ValueError` with a message about broadcasting
    instead of the correct `IndexError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following used to incorrectly give `ValueError: operands could
    not be broadcast together with shapes (2,2) (1,4)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following used to incorrectly return `array([], dtype=float64)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Both now correctly give `IndexError: boolean index did not match indexed array
    along dimension 0; dimension is 2 but corresponding boolean dimension is 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17010](https://github.com/numpy/numpy/pull/17010))
  prefs: []
  type: TYPE_NORMAL
- en: Casting errors interrupt Iteration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When iterating while casting values, an error may stop the iteration earlier
    than before. In any case, a failed casting operation always returned undefined,
    partial results. Those may now be even more undefined and partial. For users of
    the `NpyIter` C-API such cast errors will now cause the *iternext()* function
    to return 0 and thus abort iteration. Currently, there is no API to detect such
    an error directly. It is necessary to check `PyErr_Occurred()`, which may be problematic
    in combination with `NpyIter_Reset`. These issues always existed, but new API
    could be added if required by users.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17029](https://github.com/numpy/numpy/pull/17029))
  prefs: []
  type: TYPE_NORMAL
- en: f2py generated code may return unicode instead of byte strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some byte strings previously returned by f2py generated code may now be unicode
    strings. This results from the ongoing Python2 -> Python3 cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17068](https://github.com/numpy/numpy/pull/17068))
  prefs: []
  type: TYPE_NORMAL
- en: The first element of the `__array_interface__["data"]` tuple must be an integer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This has been the documented interface for many years, but there was still code
    that would accept a byte string representation of the pointer address. That code
    has been removed, passing the address as a byte string will now raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17241](https://github.com/numpy/numpy/pull/17241))
  prefs: []
  type: TYPE_NORMAL
- en: poly1d respects the dtype of all-zero argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, constructing an instance of `poly1d` with all-zero coefficients
    would cast the coefficients to `np.float64`. This affected the output dtype of
    methods which construct `poly1d` instances internally, such as `np.polymul`.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17577](https://github.com/numpy/numpy/pull/17577))
  prefs: []
  type: TYPE_NORMAL
- en: The numpy.i file for swig is Python 3 only.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Uses of Python 2.7 C-API functions have been updated to Python 3 only. Users
    who need the old version should take it from an older version of NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17580](https://github.com/numpy/numpy/pull/17580))
  prefs: []
  type: TYPE_NORMAL
- en: Void dtype discovery in `np.array`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In calls using `np.array(..., dtype="V")`, `arr.astype("V")`, and similar a
    TypeError will now be correctly raised unless all elements have the identical
    void length. An example for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Which previously returned an array with dtype `"V2"` which cannot represent
    `b"1"` faithfully.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17706](https://github.com/numpy/numpy/pull/17706))
  prefs: []
  type: TYPE_NORMAL
- en: C API changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PyArray_DescrCheck` macro is modified
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `PyArray_DescrCheck` macro has been updated since NumPy 1.16.6 to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with NumPy 1.20 code that is compiled against an earlier version will
    be API incompatible with NumPy 1.20. The fix is to either compile against 1.16.6
    (if the NumPy 1.16 release is the oldest release you wish to support), or manually
    inline the macro by replacing it with the new definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: which is compatible with all NumPy versions.
  prefs: []
  type: TYPE_NORMAL
- en: Size of `np.ndarray` and `np.void_` changed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The size of the `PyArrayObject` and `PyVoidScalarObject` structures have changed.
    The following header definition has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'since the size must not be considered a compile time constant: it will change
    for different runtime versions of NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: The most likely relevant use are potential subclasses written in C which will
    have to be recompiled and should be updated. Please see the documentation for
    [`PyArrayObject`](../reference/c-api/types-and-structures.html#c.PyArrayObject
    "PyArrayObject") for more details and contact the NumPy developers if you are
    affected by this change.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy will attempt to give a graceful error but a program expecting a fixed
    structure size may have undefined behaviour and likely crash.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16938](https://github.com/numpy/numpy/pull/16938))
  prefs: []
  type: TYPE_NORMAL
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`where` keyword argument for `numpy.all` and `numpy.any` functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword argument `where` is added and allows to only consider specified
    elements or subaxes from an array in the Boolean evaluation of `all` and `any`.
    This new keyword is available to the functions `all` and `any` both via `numpy`
    directly or in the methods of `numpy.ndarray`.
  prefs: []
  type: TYPE_NORMAL
- en: Any broadcastable Boolean array or a scalar can be set as `where`. It defaults
    to `True` to evaluate the functions for all elements in an array if `where` is
    not set by the user. Examples are given in the documentation of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: '`where` keyword argument for `numpy` functions `mean`, `std`, `var`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword argument `where` is added and allows to limit the scope in the calculation
    of `mean`, `std` and `var` to only a subset of elements. It is available both
    via `numpy` directly or in the methods of `numpy.ndarray`.
  prefs: []
  type: TYPE_NORMAL
- en: Any broadcastable Boolean array or a scalar can be set as `where`. It defaults
    to `True` to evaluate the functions for all elements in an array if `where` is
    not set by the user. Examples are given in the documentation of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15852](https://github.com/numpy/numpy/pull/15852))
  prefs: []
  type: TYPE_NORMAL
- en: '`norm=backward`, `forward` keyword options for `numpy.fft` functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword argument option `norm=backward` is added as an alias for `None`
    and acts as the default option; using it has the direct transforms unscaled and
    the inverse transforms scaled by `1/n`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new keyword argument option `norm=forward` has the direct transforms
    scaled by `1/n` and the inverse transforms unscaled (i.e. exactly opposite to
    the default option `norm=backward`).
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16476](https://github.com/numpy/numpy/pull/16476))
  prefs: []
  type: TYPE_NORMAL
- en: NumPy is now typed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type annotations have been added for large parts of NumPy. There is also a new
    [`numpy.typing`](../reference/typing.html#module-numpy.typing "numpy.typing")
    module that contains useful types for end-users. The currently available types
    are
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrayLike`: for objects that can be coerced to an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DtypeLike`: for objects that can be coerced to a dtype'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([gh-16515](https://github.com/numpy/numpy/pull/16515))
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.typing` is accessible at runtime'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The types in `numpy.typing` can now be imported at runtime. Code like the following
    will now work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16558](https://github.com/numpy/numpy/pull/16558))
  prefs: []
  type: TYPE_NORMAL
- en: New `__f2py_numpy_version__` attribute for f2py generated modules.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because f2py is released together with NumPy, `__f2py_numpy_version__` provides
    a way to track the version f2py used to generate the module.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16594](https://github.com/numpy/numpy/pull/16594))
  prefs: []
  type: TYPE_NORMAL
- en: '`mypy` tests can be run via runtests.py'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently running mypy with the NumPy stubs configured requires either:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing NumPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the source directory to MYPYPATH and linking to the `mypy.ini`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both options are somewhat inconvenient, so add a `--mypy` option to runtests
    that handles setting things up for you. This will also be useful in the future
    for any typing codegen since it will ensure the project is built before type checking.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17123](https://github.com/numpy/numpy/pull/17123))
  prefs: []
  type: TYPE_NORMAL
- en: Negation of user defined BLAS/LAPACK detection order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    allows negation of libraries when determining BLAS/LAPACK libraries. This may
    be used to remove an item from the library resolution phase, i.e. to disallow
    NetLIB libraries one could do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That will use any of the accelerated libraries instead.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17219](https://github.com/numpy/numpy/pull/17219))
  prefs: []
  type: TYPE_NORMAL
- en: Allow passing optimizations arguments to asv build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is now possible to pass `-j`, `--cpu-baseline`, `--cpu-dispatch` and `--disable-optimization`
    flags to ASV build when the `--bench-compare` argument is used.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17284](https://github.com/numpy/numpy/pull/17284))
  prefs: []
  type: TYPE_NORMAL
- en: The NVIDIA HPC SDK nvfortran compiler is now supported
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for the nvfortran compiler, a version of pgfortran, has been added.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17344](https://github.com/numpy/numpy/pull/17344))
  prefs: []
  type: TYPE_NORMAL
- en: '`dtype` option for `cov` and `corrcoef`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dtype` option is now available for [`numpy.cov`](../reference/generated/numpy.cov.html#numpy.cov
    "numpy.cov") and [`numpy.corrcoef`](../reference/generated/numpy.corrcoef.html#numpy.corrcoef
    "numpy.corrcoef"). It specifies which data-type the returned result should have.
    By default the functions still return a [`numpy.float64`](../reference/arrays.scalars.html#numpy.float64
    "numpy.float64") result.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17456](https://github.com/numpy/numpy/pull/17456))
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improved string representation for polynomials (`__str__`)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The string representation (`__str__`) of all six polynomial types in [`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") has been updated to give the polynomial as a mathematical
    expression instead of an array of coefficients. Two package-wide formats for the
    polynomial expressions are available - one using Unicode characters for superscripts
    and subscripts, and another using only ASCII characters.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15666](https://github.com/numpy/numpy/pull/15666))
  prefs: []
  type: TYPE_NORMAL
- en: Remove the Accelerate library as a candidate LAPACK library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apple no longer supports Accelerate. Remove it.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15759](https://github.com/numpy/numpy/pull/15759))
  prefs: []
  type: TYPE_NORMAL
- en: Object arrays containing multi-line objects have a more readable `repr`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If elements of an object array have a `repr` containing new lines, then the
    wrapped lines will be aligned by column. Notably, this improves the `repr` of
    nested arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-15997](https://github.com/numpy/numpy/pull/15997))
  prefs: []
  type: TYPE_NORMAL
- en: Concatenate supports providing an output dtype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support was added to [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate") to provide an output `dtype` and `casting` using keyword
    arguments. The `dtype` argument cannot be provided in conjunction with the `out`
    one.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16134](https://github.com/numpy/numpy/pull/16134))
  prefs: []
  type: TYPE_NORMAL
- en: Thread safe f2py callback functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Callback functions in f2py are now thread safe.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16519](https://github.com/numpy/numpy/pull/16519))
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.core.records.fromfile`](../reference/generated/numpy.core.records.fromfile.html#numpy.core.records.fromfile
    "numpy.core.records.fromfile") now supports file-like objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`numpy.rec.fromfile` can now use file-like objects, for instance [`io.BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO
    "(in Python v3.11)")'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16675](https://github.com/numpy/numpy/pull/16675))
  prefs: []
  type: TYPE_NORMAL
- en: RPATH support on AIX added to distutils
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This allows SciPy to be built on AIX.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16710](https://github.com/numpy/numpy/pull/16710))
  prefs: []
  type: TYPE_NORMAL
- en: Use f90 compiler specified by the command line args
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The compiler command selection for Fortran Portland Group Compiler is changed
    in `numpy.distutils.fcompiler`. This only affects the linking command. This forces
    the use of the executable provided by the command line option (if provided) instead
    of the pgfortran executable. If no executable is provided to the command line
    option it defaults to the pgf90 executable, which is an alias for pgfortran according
    to the PGI documentation.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16730](https://github.com/numpy/numpy/pull/16730))
  prefs: []
  type: TYPE_NORMAL
- en: Add NumPy declarations for Cython 3.0 and later
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pxd declarations for Cython 3.0 were improved to avoid using deprecated
    NumPy C-API features. Extension modules built with Cython 3.0+ that use NumPy
    can now set the C macro `NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION` to avoid C
    compiler warnings about deprecated API usage.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16986](https://github.com/numpy/numpy/pull/16986))
  prefs: []
  type: TYPE_NORMAL
- en: Make the window functions exactly symmetric
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure the window functions provided by NumPy are symmetric. There were previously
    small deviations from symmetry due to numerical precision that are now avoided
    by better arrangement of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17195](https://github.com/numpy/numpy/pull/17195))
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvements and changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enable multi-platform SIMD compiler optimizations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A series of improvements for NumPy infrastructure to pave the way to **NEP-38**,
    that can be summarized as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Build Arguments**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-baseline` to specify the minimal set of required optimizations, default
    value is `min` which provides the minimum CPU features that can safely run on
    a wide range of users platforms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-dispatch` to specify the dispatched set of additional optimizations,
    default value is `max -xop -fma4` which enables all CPU features, except for AMD
    legacy features.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--disable-optimization` to explicitly disable the whole new improvements,
    It also adds a new **C** compiler #definition called `NPY_DISABLE_OPTIMIZATION`
    which it can be used as guard for any SIMD code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced CPU dispatcher**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flexible cross-architecture CPU dispatcher built on the top of Python/Numpy
    distutils, support all common compilers with a wide range of CPU features.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The new dispatcher requires a special file extension `*.dispatch.c` to mark
    the dispatch-able **C** sources. These sources have the ability to be compiled
    multiple times so that each compilation process represents certain CPU features
    and provides different #definitions and flags that affect the code paths.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**New auto-generated C header ``core/src/common/_cpu_dispatch.h``**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This header is generated by the distutils module `ccompiler_opt`, and contains
    all the #definitions and headers of instruction sets, that had been configured
    through command arguments ‘–cpu-baseline’ and ‘–cpu-dispatch’.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**New C header ``core/src/common/npy_cpu_dispatch.h``**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This header contains all utilities that required for the whole CPU dispatching
    process, it also can be considered as a bridge linking the new infrastructure
    work with NumPy CPU runtime detection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Add new attributes to NumPy umath module(Python level)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__cpu_baseline__` a list contains the minimal set of required optimizations
    that supported by the compiler and platform according to the specified values
    to command argument ‘–cpu-baseline’.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__cpu_dispatch__` a list contains the dispatched set of additional optimizations
    that supported by the compiler and platform according to the specified values
    to command argument ‘–cpu-dispatch’.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Print the supported CPU features during the run of PytestTester**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([gh-13516](https://github.com/numpy/numpy/pull/13516))
  prefs: []
  type: TYPE_NORMAL
- en: Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changed behavior of `divmod(1., 0.)` and related functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The changes also assure that different compiler versions have the same behavior
    for nan or inf usages in these operations. This was previously compiler dependent,
    we now force the invalid and divide by zero flags, making the results the same
    across compilers. For example, gcc-5, gcc-8, or gcc-9 now result in the same behavior.
    The changes are tabulated below:'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of New Behavior
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Old Warning | New Warning | Old Result | New Result | Works on
    MacOS |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| np.divmod(1.0, 0.0) | Invalid | Invalid and Dividebyzero | nan, nan | inf,
    nan | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| np.fmod(1.0, 0.0) | Invalid | Invalid | nan | nan | No? Yes |'
  prefs: []
  type: TYPE_TB
- en: '| np.floor_divide(1.0, 0.0) | Invalid | Dividebyzero | nan | inf | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| np.remainder(1.0, 0.0) | Invalid | Invalid | nan | nan | Yes |'
  prefs: []
  type: TYPE_TB
- en: ([gh-16161](https://github.com/numpy/numpy/pull/16161))
  prefs: []
  type: TYPE_NORMAL
- en: '`np.linspace` on integers now uses floor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using a `int` dtype in [`numpy.linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), previously float values would be rounded towards zero. Now
    [`numpy.floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor")
    is used instead, which rounds toward `-inf`. This changes the results for negative
    values. For example, the following would previously give:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'and now results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The former result can still be obtained with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16841](https://github.com/numpy/numpy/pull/16841))
  prefs: []
  type: TYPE_NORMAL
- en: New functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The random.Generator class has a new `permuted` function.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new function differs from `shuffle` and `permutation` in that the subarrays
    indexed by an axis are permuted rather than the axis being treated as a separate
    1-D array for every combination of the other indexes. For example, it is now possible
    to permute the rows or columns of a 2-D array.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15121](https://github.com/numpy/numpy/pull/15121))
  prefs: []
  type: TYPE_NORMAL
- en: '`sliding_window_view` provides a sliding window view for numpy arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`numpy.lib.stride_tricks.sliding_window_view`](../reference/generated/numpy.lib.stride_tricks.sliding_window_view.html#numpy.lib.stride_tricks.sliding_window_view
    "numpy.lib.stride_tricks.sliding_window_view") constructs views on numpy arrays
    that offer a sliding or moving window access to the array. This allows for the
    simple implementation of certain algorithms, such as running means.'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17394](https://github.com/numpy/numpy/pull/17394))
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.broadcast_shapes`](../reference/generated/numpy.broadcast_shapes.html#numpy.broadcast_shapes
    "numpy.broadcast_shapes") is a new user-facing function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`broadcast_shapes`](../reference/generated/numpy.broadcast_shapes.html#numpy.broadcast_shapes
    "numpy.broadcast_shapes") gets the resulting shape from broadcasting the given
    shape tuples against each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-17535](https://github.com/numpy/numpy/pull/17535))
  prefs: []
  type: TYPE_NORMAL
- en: The random.Generator class has a new `permuted` function.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new function differs from `shuffle` and `permutation` in that the subarrays
    indexed by an axis are permuted rather than the axis being treated as a separate
    1-D array for every combination of the other indexes. For example, it is now possible
    to permute the rows or columns of a 2-D array.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15121](https://github.com/numpy/numpy/pull/15121))
  prefs: []
  type: TYPE_NORMAL
- en: '`sliding_window_view` provides a sliding window view for numpy arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`numpy.lib.stride_tricks.sliding_window_view`](../reference/generated/numpy.lib.stride_tricks.sliding_window_view.html#numpy.lib.stride_tricks.sliding_window_view
    "numpy.lib.stride_tricks.sliding_window_view") constructs views on numpy arrays
    that offer a sliding or moving window access to the array. This allows for the
    simple implementation of certain algorithms, such as running means.'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17394](https://github.com/numpy/numpy/pull/17394))
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.broadcast_shapes`](../reference/generated/numpy.broadcast_shapes.html#numpy.broadcast_shapes
    "numpy.broadcast_shapes") is a new user-facing function'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`broadcast_shapes`](../reference/generated/numpy.broadcast_shapes.html#numpy.broadcast_shapes
    "numpy.broadcast_shapes") gets the resulting shape from broadcasting the given
    shape tuples against each other.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-17535](https://github.com/numpy/numpy/pull/17535))
  prefs: []
  type: TYPE_NORMAL
- en: Deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the aliases of builtin types like `np.int` is deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a long time, `np.int` has been an alias of the builtin `int`. This is repeatedly
    a cause of confusion for newcomers, and existed mainly for historic reasons.
  prefs: []
  type: TYPE_NORMAL
- en: These aliases have been deprecated. The table below shows the full list of deprecated
    aliases, along with their exact meaning. Replacing uses of items in the first
    column with the contents of the second column will work identically and silence
    the deprecation warning.
  prefs: []
  type: TYPE_NORMAL
- en: The third column lists alternative NumPy names which may occasionally be preferential.
    See also [Data types](../user/basics.types.html#basics-types) for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: '| Deprecated name | Identical to | NumPy scalar type names |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.bool` | `bool` | [`numpy.bool_`](../reference/arrays.scalars.html#numpy.bool_
    "numpy.bool_") |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.int` | `int` | [`numpy.int_`](../reference/arrays.scalars.html#numpy.int_
    "numpy.int_") (default), `numpy.int64`, or `numpy.int32` |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.float` | `float` | [`numpy.float64`](../reference/arrays.scalars.html#numpy.float64
    "numpy.float64"), [`numpy.float_`](../reference/arrays.scalars.html#numpy.float_
    "numpy.float_"), [`numpy.double`](../reference/arrays.scalars.html#numpy.double
    "numpy.double") (equivalent) |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.complex` | `complex` | [`numpy.complex128`](../reference/arrays.scalars.html#numpy.complex128
    "numpy.complex128"), [`numpy.complex_`](../reference/arrays.scalars.html#numpy.complex_
    "numpy.complex_"), [`numpy.cdouble`](../reference/arrays.scalars.html#numpy.cdouble
    "numpy.cdouble") (equivalent) |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.object` | `object` | [`numpy.object_`](../reference/arrays.scalars.html#numpy.object_
    "numpy.object_") |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.str` | `str` | [`numpy.str_`](../reference/arrays.scalars.html#numpy.str_
    "numpy.str_") |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.long` | `int` | [`numpy.int_`](../reference/arrays.scalars.html#numpy.int_
    "numpy.int_") (C `long`), [`numpy.longlong`](../reference/arrays.scalars.html#numpy.longlong
    "numpy.longlong") (largest integer type) |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.unicode` | `str` | [`numpy.unicode_`](../reference/arrays.scalars.html#numpy.unicode_
    "numpy.unicode_") |'
  prefs: []
  type: TYPE_TB
- en: To give a clear guideline for the vast majority of cases, for the types `bool`,
    `object`, `str` (and `unicode`) using the plain version is shorter and clear,
    and generally a good replacement. For `float` and `complex` you can use `float64`
    and `complex128` if you wish to be more explicit about the precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `np.int` a direct replacement with `np.int_` or `int` is also good and
    will not change behavior, but the precision will continue to depend on the computer
    and operating system. If you want to be more explicit and review the current use,
    you have the following alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.int64` or `np.int32` to specify the precision exactly. This ensures that
    results cannot depend on the computer or operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.int_` or `int` (the default), but be aware that it depends on the computer
    and operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The C types: `np.cint` (int), `np.int_` (long), `np.longlong`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.intp` which is 32bit on 32bit machines 64bit on 64bit machines. This can
    be the best type to use for indexing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When used with `np.dtype(...)` or `dtype=...` changing it to the NumPy name
    as mentioned above will have no effect on the output. If used as a scalar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: changing it can subtly change the result. In this case, the Python version `float(123)`
    or `int(12.)` is normally preferable, although the NumPy version may be useful
    for consistency with NumPy arrays (for example, NumPy behaves differently for
    things like division by zero).
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-14882](https://github.com/numpy/numpy/pull/14882))
  prefs: []
  type: TYPE_NORMAL
- en: Passing `shape=None` to functions with a non-optional shape argument is deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, this was an alias for passing `shape=()`. This deprecation is emitted
    by *PyArray_IntpConverter* in the C API. If your API is intended to support passing
    `None`, then you should check for `None` prior to invoking the converter, so as
    to be able to distinguish `None` and `()`.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15886](https://github.com/numpy/numpy/pull/15886))
  prefs: []
  type: TYPE_NORMAL
- en: Indexing errors will be reported even when index result is empty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the future, NumPy will raise an IndexError when an integer array index contains
    out of bound values even if a non-indexed dimension is of length 0\. This will
    now emit a DeprecationWarning. This can happen when the array is previously empty,
    or an empty slice is involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Previously the non-empty index `[20]` was not checked for correctness. It will
    now be checked causing a deprecation warning which will be turned into an error.
    This also applies to assignments.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15900](https://github.com/numpy/numpy/pull/15900))
  prefs: []
  type: TYPE_NORMAL
- en: Inexact matches for `mode` and `searchside` are deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inexact and case insensitive matches for `mode` and `searchside` were valid
    inputs earlier and will give a DeprecationWarning now. For example, below are
    some example usages which are now deprecated and will give a DeprecationWarning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16056](https://github.com/numpy/numpy/pull/16056))
  prefs: []
  type: TYPE_NORMAL
- en: Deprecation of *numpy.dual*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The module *numpy.dual* is deprecated. Instead of importing functions from *numpy.dual*,
    the functions should be imported directly from NumPy or SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16156](https://github.com/numpy/numpy/pull/16156))
  prefs: []
  type: TYPE_NORMAL
- en: '`outer` and `ufunc.outer` deprecated for matrix'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.matrix` use with [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer") or generic ufunc outer calls such as `numpy.add.outer`. Previously,
    matrix was converted to an array here. This will not be done in the future requiring
    a manual conversion to arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16232](https://github.com/numpy/numpy/pull/16232))
  prefs: []
  type: TYPE_NORMAL
- en: Further Numeric Style types Deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The remaining numeric-style type codes `Bytes0`, `Str0`, `Uint32`, `Uint64`,
    and `Datetime64` have been deprecated. The lower-case variants should be used
    instead. For bytes and string `"S"` and `"U"` are further alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16554](https://github.com/numpy/numpy/pull/16554))
  prefs: []
  type: TYPE_NORMAL
- en: The `ndincr` method of `ndindex` is deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The documentation has warned against using this function since NumPy 1.8. Use
    `next(it)` instead of `it.ndincr()`.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17233](https://github.com/numpy/numpy/pull/17233))
  prefs: []
  type: TYPE_NORMAL
- en: ArrayLike objects which do not define `__len__` and `__getitem__`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects which define one of the protocols `__array__`, `__array_interface__`,
    or `__array_struct__` but are not sequences (usually defined by having a `__len__`
    and `__getitem__`) will behave differently during array-coercion in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'When nested inside sequences, such as `np.array([array_like])`, these were
    handled as a single Python object rather than an array. In the future they will
    behave identically to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This change should only have an effect if `np.array(array_like)` is not 0-D.
    The solution to this warning may depend on the object:'
  prefs: []
  type: TYPE_NORMAL
- en: Some array-likes may expect the new behaviour, and users can ignore the warning.
    The object can choose to expose the sequence protocol to opt-in to the new behaviour.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `shapely` will allow conversion to an array-like using `line.coords`
    rather than `np.asarray(line)`. Users may work around the warning, or use the
    new convention when it becomes available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, using the new behaviour can only be achieved by calling `np.array(array_like)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to ensure that the old behaviour remains unchanged, please create
    an object array and then fill it explicitly, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure NumPy knows to not enter the array-like and use it as a object
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17973](https://github.com/numpy/numpy/pull/17973))
  prefs: []
  type: TYPE_NORMAL
- en: Using the aliases of builtin types like `np.int` is deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a long time, `np.int` has been an alias of the builtin `int`. This is repeatedly
    a cause of confusion for newcomers, and existed mainly for historic reasons.
  prefs: []
  type: TYPE_NORMAL
- en: These aliases have been deprecated. The table below shows the full list of deprecated
    aliases, along with their exact meaning. Replacing uses of items in the first
    column with the contents of the second column will work identically and silence
    the deprecation warning.
  prefs: []
  type: TYPE_NORMAL
- en: The third column lists alternative NumPy names which may occasionally be preferential.
    See also [Data types](../user/basics.types.html#basics-types) for additional details.
  prefs: []
  type: TYPE_NORMAL
- en: '| Deprecated name | Identical to | NumPy scalar type names |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.bool` | `bool` | [`numpy.bool_`](../reference/arrays.scalars.html#numpy.bool_
    "numpy.bool_") |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.int` | `int` | [`numpy.int_`](../reference/arrays.scalars.html#numpy.int_
    "numpy.int_") (default), `numpy.int64`, or `numpy.int32` |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.float` | `float` | [`numpy.float64`](../reference/arrays.scalars.html#numpy.float64
    "numpy.float64"), [`numpy.float_`](../reference/arrays.scalars.html#numpy.float_
    "numpy.float_"), [`numpy.double`](../reference/arrays.scalars.html#numpy.double
    "numpy.double") (equivalent) |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.complex` | `complex` | [`numpy.complex128`](../reference/arrays.scalars.html#numpy.complex128
    "numpy.complex128"), [`numpy.complex_`](../reference/arrays.scalars.html#numpy.complex_
    "numpy.complex_"), [`numpy.cdouble`](../reference/arrays.scalars.html#numpy.cdouble
    "numpy.cdouble") (equivalent) |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.object` | `object` | [`numpy.object_`](../reference/arrays.scalars.html#numpy.object_
    "numpy.object_") |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.str` | `str` | [`numpy.str_`](../reference/arrays.scalars.html#numpy.str_
    "numpy.str_") |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.long` | `int` | [`numpy.int_`](../reference/arrays.scalars.html#numpy.int_
    "numpy.int_") (C `long`), [`numpy.longlong`](../reference/arrays.scalars.html#numpy.longlong
    "numpy.longlong") (largest integer type) |'
  prefs: []
  type: TYPE_TB
- en: '| `numpy.unicode` | `str` | [`numpy.unicode_`](../reference/arrays.scalars.html#numpy.unicode_
    "numpy.unicode_") |'
  prefs: []
  type: TYPE_TB
- en: To give a clear guideline for the vast majority of cases, for the types `bool`,
    `object`, `str` (and `unicode`) using the plain version is shorter and clear,
    and generally a good replacement. For `float` and `complex` you can use `float64`
    and `complex128` if you wish to be more explicit about the precision.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `np.int` a direct replacement with `np.int_` or `int` is also good and
    will not change behavior, but the precision will continue to depend on the computer
    and operating system. If you want to be more explicit and review the current use,
    you have the following alternatives:'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.int64` or `np.int32` to specify the precision exactly. This ensures that
    results cannot depend on the computer or operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.int_` or `int` (the default), but be aware that it depends on the computer
    and operating system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The C types: `np.cint` (int), `np.int_` (long), `np.longlong`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`np.intp` which is 32bit on 32bit machines 64bit on 64bit machines. This can
    be the best type to use for indexing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When used with `np.dtype(...)` or `dtype=...` changing it to the NumPy name
    as mentioned above will have no effect on the output. If used as a scalar with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: changing it can subtly change the result. In this case, the Python version `float(123)`
    or `int(12.)` is normally preferable, although the NumPy version may be useful
    for consistency with NumPy arrays (for example, NumPy behaves differently for
    things like division by zero).
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-14882](https://github.com/numpy/numpy/pull/14882))
  prefs: []
  type: TYPE_NORMAL
- en: Passing `shape=None` to functions with a non-optional shape argument is deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, this was an alias for passing `shape=()`. This deprecation is emitted
    by *PyArray_IntpConverter* in the C API. If your API is intended to support passing
    `None`, then you should check for `None` prior to invoking the converter, so as
    to be able to distinguish `None` and `()`.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15886](https://github.com/numpy/numpy/pull/15886))
  prefs: []
  type: TYPE_NORMAL
- en: Indexing errors will be reported even when index result is empty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the future, NumPy will raise an IndexError when an integer array index contains
    out of bound values even if a non-indexed dimension is of length 0\. This will
    now emit a DeprecationWarning. This can happen when the array is previously empty,
    or an empty slice is involved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Previously the non-empty index `[20]` was not checked for correctness. It will
    now be checked causing a deprecation warning which will be turned into an error.
    This also applies to assignments.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15900](https://github.com/numpy/numpy/pull/15900))
  prefs: []
  type: TYPE_NORMAL
- en: Inexact matches for `mode` and `searchside` are deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inexact and case insensitive matches for `mode` and `searchside` were valid
    inputs earlier and will give a DeprecationWarning now. For example, below are
    some example usages which are now deprecated and will give a DeprecationWarning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16056](https://github.com/numpy/numpy/pull/16056))
  prefs: []
  type: TYPE_NORMAL
- en: Deprecation of *numpy.dual*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The module *numpy.dual* is deprecated. Instead of importing functions from *numpy.dual*,
    the functions should be imported directly from NumPy or SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16156](https://github.com/numpy/numpy/pull/16156))
  prefs: []
  type: TYPE_NORMAL
- en: '`outer` and `ufunc.outer` deprecated for matrix'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`np.matrix` use with [`outer`](../reference/generated/numpy.outer.html#numpy.outer
    "numpy.outer") or generic ufunc outer calls such as `numpy.add.outer`. Previously,
    matrix was converted to an array here. This will not be done in the future requiring
    a manual conversion to arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16232](https://github.com/numpy/numpy/pull/16232))
  prefs: []
  type: TYPE_NORMAL
- en: Further Numeric Style types Deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The remaining numeric-style type codes `Bytes0`, `Str0`, `Uint32`, `Uint64`,
    and `Datetime64` have been deprecated. The lower-case variants should be used
    instead. For bytes and string `"S"` and `"U"` are further alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16554](https://github.com/numpy/numpy/pull/16554))
  prefs: []
  type: TYPE_NORMAL
- en: The `ndincr` method of `ndindex` is deprecated
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The documentation has warned against using this function since NumPy 1.8. Use
    `next(it)` instead of `it.ndincr()`.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17233](https://github.com/numpy/numpy/pull/17233))
  prefs: []
  type: TYPE_NORMAL
- en: ArrayLike objects which do not define `__len__` and `__getitem__`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Objects which define one of the protocols `__array__`, `__array_interface__`,
    or `__array_struct__` but are not sequences (usually defined by having a `__len__`
    and `__getitem__`) will behave differently during array-coercion in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'When nested inside sequences, such as `np.array([array_like])`, these were
    handled as a single Python object rather than an array. In the future they will
    behave identically to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This change should only have an effect if `np.array(array_like)` is not 0-D.
    The solution to this warning may depend on the object:'
  prefs: []
  type: TYPE_NORMAL
- en: Some array-likes may expect the new behaviour, and users can ignore the warning.
    The object can choose to expose the sequence protocol to opt-in to the new behaviour.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, `shapely` will allow conversion to an array-like using `line.coords`
    rather than `np.asarray(line)`. Users may work around the warning, or use the
    new convention when it becomes available.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, using the new behaviour can only be achieved by calling `np.array(array_like)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish to ensure that the old behaviour remains unchanged, please create
    an object array and then fill it explicitly, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This will ensure NumPy knows to not enter the array-like and use it as a object
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17973](https://github.com/numpy/numpy/pull/17973))
  prefs: []
  type: TYPE_NORMAL
- en: Future Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arrays cannot be using subarray dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Array creation and casting using `np.array(arr, dtype)` and `arr.astype(dtype)`
    will use different logic when `dtype` is a subarray dtype such as `np.dtype("(2)i,")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For such a `dtype` the following behaviour is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But `res` is filled using the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'which uses incorrect broadcasting (and often leads to an error). In the future,
    this will instead cast each element individually, leading to the same result as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Which can normally be used to opt-in to the new behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: This change does not affect `np.array(list, dtype="(2)i,")` unless the `list`
    itself includes at least one array. In particular, the behaviour is unchanged
    for a list of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17596](https://github.com/numpy/numpy/pull/17596))
  prefs: []
  type: TYPE_NORMAL
- en: Arrays cannot be using subarray dtypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Array creation and casting using `np.array(arr, dtype)` and `arr.astype(dtype)`
    will use different logic when `dtype` is a subarray dtype such as `np.dtype("(2)i,")`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For such a `dtype` the following behaviour is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'But `res` is filled using the logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'which uses incorrect broadcasting (and often leads to an error). In the future,
    this will instead cast each element individually, leading to the same result as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Which can normally be used to opt-in to the new behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: This change does not affect `np.array(list, dtype="(2)i,")` unless the `list`
    itself includes at least one array. In particular, the behaviour is unchanged
    for a list of tuples.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17596](https://github.com/numpy/numpy/pull/17596))
  prefs: []
  type: TYPE_NORMAL
- en: Expired deprecations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The deprecation of numeric style type-codes `np.dtype("Complex64")` (with upper
    case spelling), is expired. `"Complex64"` corresponded to `"complex128"` and `"Complex32"`
    corresponded to `"complex64"`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deprecation of `np.sctypeNA` and `np.typeNA` is expired. Both have been
    removed from the public API. Use `np.typeDict` instead.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([gh-16554](https://github.com/numpy/numpy/pull/16554))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The 14-year deprecation of `np.ctypeslib.ctypes_load_library` is expired. Use
    [`load_library`](../reference/routines.ctypeslib.html#numpy.ctypeslib.load_library
    "numpy.ctypeslib.load_library") instead, which is identical.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([gh-17116](https://github.com/numpy/numpy/pull/17116))
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Financial functions removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In accordance with NEP 32, the financial functions are removed from NumPy 1.20\.
    The functions that have been removed are `fv`, `ipmt`, `irr`, `mirr`, `nper`,
    `npv`, `pmt`, `ppmt`, `pv`, and `rate`. These functions are available in the [numpy_financial](https://pypi.org/project/numpy-financial)
    library.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17067](https://github.com/numpy/numpy/pull/17067))
  prefs: []
  type: TYPE_NORMAL
- en: Financial functions removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In accordance with NEP 32, the financial functions are removed from NumPy 1.20\.
    The functions that have been removed are `fv`, `ipmt`, `irr`, `mirr`, `nper`,
    `npv`, `pmt`, `ppmt`, `pv`, and `rate`. These functions are available in the [numpy_financial](https://pypi.org/project/numpy-financial)
    library.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17067](https://github.com/numpy/numpy/pull/17067))
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility notes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`isinstance(dtype, np.dtype)` and not `type(dtype) is not np.dtype`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy dtypes are not direct instances of `np.dtype` anymore. Code that may have
    used `type(dtype) is np.dtype` will always return `False` and must be updated
    to use the correct version `isinstance(dtype, np.dtype)`.
  prefs: []
  type: TYPE_NORMAL
- en: This change also affects the C-side macro `PyArray_DescrCheck` if compiled against
    a NumPy older than 1.16.6\. If code uses this macro and wishes to compile against
    an older version of NumPy, it must replace the macro (see also [C API changes](#c-api-changes)
    section).
  prefs: []
  type: TYPE_NORMAL
- en: Same kind casting in concatenate with `axis=None`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate") is called with `axis=None`, the flattened arrays were cast
    with `unsafe`. Any other axis choice uses “same kind”. That different default
    has been deprecated and “same kind” casting will be used instead. The new `casting`
    keyword argument can be used to retain the old behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16134](https://github.com/numpy/numpy/pull/16134))
  prefs: []
  type: TYPE_NORMAL
- en: NumPy Scalars are cast when assigned to arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating or assigning to arrays, in all relevant cases NumPy scalars will
    now be cast identically to NumPy arrays. In particular this changes the behaviour
    in some cases which previously raised an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'will succeed and return an undefined result (usually the smallest possible
    integer). This also affects assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'At this time, NumPy retains the behaviour for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The above changes do not affect Python scalars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'remains unaffected (`np.nan` is a Python `float`, not a NumPy one). Unlike
    signed integers, unsigned integers do not retain this special case, since they
    always behaved more like casting. The following code stops raising an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: To avoid backward compatibility issues, at this time assignment from `datetime64`
    scalar to strings of too short length remains supported. This means that `np.asarray(np.datetime64("2020-10-10"),
    dtype="S5")` succeeds now, when it failed before. In the long term this may be
    deprecated or the unsafe cast may be allowed generally to make assignment of arrays
    and scalars behave consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Array coercion changes when Strings and other types are mixed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When strings and other types are mixed, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The results will change, which may lead to string dtypes with longer strings
    in some cases. In particularly, if `dtype="S"` is not provided any numerical value
    will lead to a string results long enough to hold all possible numerical values.
    (e.g. “S32” for floats). Note that you should always provide `dtype="S"` when
    converting non-strings to strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `dtype="S"` is provided the results will be largely identical to before,
    but NumPy scalars (not a Python float like `1.0`), will still enforce a uniform
    string length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Previously the first version gave the same result as the second.
  prefs: []
  type: TYPE_NORMAL
- en: Array coercion restructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Array coercion has been restructured. In general, this should not affect users.
    In extremely rare corner cases where array-likes are nested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Things will now be more consistent with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This can subtly change output for some badly defined array-likes. One example
    for this are array-like objects which are not also sequences of matching shape.
    In NumPy 1.20, a warning will be given when an array-like is not also a sequence
    (but behaviour remains identical, see deprecations). If an array like is also
    a sequence (defines `__getitem__` and `__len__`) NumPy will now only use the result
    given by `__array__`, `__array_interface__`, or `__array_struct__`. This will
    result in differences when the (nested) sequence describes a different shape.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16200](https://github.com/numpy/numpy/pull/16200))
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the result of [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") will export readonly buffers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In NumPy 1.17 [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") started warning when the resulting array was written
    to. This warning was skipped when the array was used through the buffer interface
    (e.g. `memoryview(arr)`). The same thing will now occur for the two protocols
    `__array_interface__`, and `__array_struct__` returning read-only buffers instead
    of giving a warning.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16350](https://github.com/numpy/numpy/pull/16350))
  prefs: []
  type: TYPE_NORMAL
- en: Numeric-style type names have been removed from type dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To stay in sync with the deprecation for `np.dtype("Complex64")` and other numeric-style
    (capital case) types. These were removed from `np.sctypeDict` and `np.typeDict`.
    You should use the lower case versions instead. Note that `"Complex64"` corresponds
    to `"complex128"` and `"Complex32"` corresponds to `"complex64"`. The numpy style
    (new) versions, denote the full size and not the size of the real/imaginary part.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16554](https://github.com/numpy/numpy/pull/16554))
  prefs: []
  type: TYPE_NORMAL
- en: The `operator.concat` function now raises TypeError for array arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous behavior was to fall back to addition and add the two arrays, which
    was thought to be unexpected behavior for a concatenation function.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16570](https://github.com/numpy/numpy/pull/16570))
  prefs: []
  type: TYPE_NORMAL
- en: '`nickname` attribute removed from ABCPolyBase'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An abstract property `nickname` has been removed from `ABCPolyBase` as it was
    no longer used in the derived convenience classes. This may affect users who have
    derived classes from `ABCPolyBase` and overridden the methods for representation
    and display, e.g. `__str__`, `__repr__`, `_repr_latex`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16589](https://github.com/numpy/numpy/pull/16589))
  prefs: []
  type: TYPE_NORMAL
- en: '`float->timedelta` and `uint64->timedelta` promotion will raise a TypeError'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Float and timedelta promotion consistently raises a TypeError. `np.promote_types("float32",
    "m8")` aligns with `np.promote_types("m8", "float32")` now and both raise a TypeError.
    Previously, `np.promote_types("float32", "m8")` returned `"m8"` which was considered
    a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Uint64 and timedelta promotion consistently raises a TypeError. `np.promote_types("uint64",
    "m8")` aligns with `np.promote_types("m8", "uint64")` now and both raise a TypeError.
    Previously, `np.promote_types("uint64", "m8")` returned `"m8"` which was considered
    a bug.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16592](https://github.com/numpy/numpy/pull/16592))
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.genfromtxt` now correctly unpacks structured arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, [`numpy.genfromtxt`](../reference/generated/numpy.genfromtxt.html#numpy.genfromtxt
    "numpy.genfromtxt") failed to unpack if it was called with `unpack=True` and a
    structured datatype was passed to the `dtype` argument (or `dtype=None` was passed
    and a structured datatype was inferred). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Structured arrays will now correctly unpack into a list of arrays, one for
    each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16650](https://github.com/numpy/numpy/pull/16650))
  prefs: []
  type: TYPE_NORMAL
- en: '`mgrid`, `r_`, etc. consistently return correct outputs for non-default precision
    input'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, `np.mgrid[np.float32(0.1):np.float32(0.35):np.float32(0.1),]` and
    `np.r_[0:10:np.complex64(3j)]` failed to return meaningful output. This bug potentially
    affects [`mgrid`](../reference/generated/numpy.mgrid.html#numpy.mgrid "numpy.mgrid"),
    [`ogrid`](../reference/generated/numpy.ogrid.html#numpy.ogrid "numpy.ogrid"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_"), and [`c_`](../reference/generated/numpy.c_.html#numpy.c_
    "numpy.c_") when an input with dtype other than the default `float64` and `complex128`
    and equivalent Python types were used. The methods have been fixed to handle varying
    precision correctly.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16815](https://github.com/numpy/numpy/pull/16815))
  prefs: []
  type: TYPE_NORMAL
- en: Boolean array indices with mismatching shapes now properly give `IndexError`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, if a boolean array index matched the size of the indexed array but
    not the shape, it was incorrectly allowed in some cases. In other cases, it gave
    an error, but the error was incorrectly a `ValueError` with a message about broadcasting
    instead of the correct `IndexError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following used to incorrectly give `ValueError: operands could
    not be broadcast together with shapes (2,2) (1,4)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following used to incorrectly return `array([], dtype=float64)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Both now correctly give `IndexError: boolean index did not match indexed array
    along dimension 0; dimension is 2 but corresponding boolean dimension is 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17010](https://github.com/numpy/numpy/pull/17010))
  prefs: []
  type: TYPE_NORMAL
- en: Casting errors interrupt Iteration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When iterating while casting values, an error may stop the iteration earlier
    than before. In any case, a failed casting operation always returned undefined,
    partial results. Those may now be even more undefined and partial. For users of
    the `NpyIter` C-API such cast errors will now cause the *iternext()* function
    to return 0 and thus abort iteration. Currently, there is no API to detect such
    an error directly. It is necessary to check `PyErr_Occurred()`, which may be problematic
    in combination with `NpyIter_Reset`. These issues always existed, but new API
    could be added if required by users.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17029](https://github.com/numpy/numpy/pull/17029))
  prefs: []
  type: TYPE_NORMAL
- en: f2py generated code may return unicode instead of byte strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some byte strings previously returned by f2py generated code may now be unicode
    strings. This results from the ongoing Python2 -> Python3 cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17068](https://github.com/numpy/numpy/pull/17068))
  prefs: []
  type: TYPE_NORMAL
- en: The first element of the `__array_interface__["data"]` tuple must be an integer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This has been the documented interface for many years, but there was still code
    that would accept a byte string representation of the pointer address. That code
    has been removed, passing the address as a byte string will now raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17241](https://github.com/numpy/numpy/pull/17241))
  prefs: []
  type: TYPE_NORMAL
- en: poly1d respects the dtype of all-zero argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, constructing an instance of `poly1d` with all-zero coefficients
    would cast the coefficients to `np.float64`. This affected the output dtype of
    methods which construct `poly1d` instances internally, such as `np.polymul`.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17577](https://github.com/numpy/numpy/pull/17577))
  prefs: []
  type: TYPE_NORMAL
- en: The numpy.i file for swig is Python 3 only.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Uses of Python 2.7 C-API functions have been updated to Python 3 only. Users
    who need the old version should take it from an older version of NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17580](https://github.com/numpy/numpy/pull/17580))
  prefs: []
  type: TYPE_NORMAL
- en: Void dtype discovery in `np.array`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In calls using `np.array(..., dtype="V")`, `arr.astype("V")`, and similar a
    TypeError will now be correctly raised unless all elements have the identical
    void length. An example for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Which previously returned an array with dtype `"V2"` which cannot represent
    `b"1"` faithfully.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17706](https://github.com/numpy/numpy/pull/17706))
  prefs: []
  type: TYPE_NORMAL
- en: '`isinstance(dtype, np.dtype)` and not `type(dtype) is not np.dtype`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NumPy dtypes are not direct instances of `np.dtype` anymore. Code that may have
    used `type(dtype) is np.dtype` will always return `False` and must be updated
    to use the correct version `isinstance(dtype, np.dtype)`.
  prefs: []
  type: TYPE_NORMAL
- en: This change also affects the C-side macro `PyArray_DescrCheck` if compiled against
    a NumPy older than 1.16.6\. If code uses this macro and wishes to compile against
    an older version of NumPy, it must replace the macro (see also [C API changes](#c-api-changes)
    section).
  prefs: []
  type: TYPE_NORMAL
- en: Same kind casting in concatenate with `axis=None`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate") is called with `axis=None`, the flattened arrays were cast
    with `unsafe`. Any other axis choice uses “same kind”. That different default
    has been deprecated and “same kind” casting will be used instead. The new `casting`
    keyword argument can be used to retain the old behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16134](https://github.com/numpy/numpy/pull/16134))
  prefs: []
  type: TYPE_NORMAL
- en: NumPy Scalars are cast when assigned to arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When creating or assigning to arrays, in all relevant cases NumPy scalars will
    now be cast identically to NumPy arrays. In particular this changes the behaviour
    in some cases which previously raised an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'will succeed and return an undefined result (usually the smallest possible
    integer). This also affects assignments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'At this time, NumPy retains the behaviour for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The above changes do not affect Python scalars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'remains unaffected (`np.nan` is a Python `float`, not a NumPy one). Unlike
    signed integers, unsigned integers do not retain this special case, since they
    always behaved more like casting. The following code stops raising an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: To avoid backward compatibility issues, at this time assignment from `datetime64`
    scalar to strings of too short length remains supported. This means that `np.asarray(np.datetime64("2020-10-10"),
    dtype="S5")` succeeds now, when it failed before. In the long term this may be
    deprecated or the unsafe cast may be allowed generally to make assignment of arrays
    and scalars behave consistently.
  prefs: []
  type: TYPE_NORMAL
- en: Array coercion changes when Strings and other types are mixed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When strings and other types are mixed, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The results will change, which may lead to string dtypes with longer strings
    in some cases. In particularly, if `dtype="S"` is not provided any numerical value
    will lead to a string results long enough to hold all possible numerical values.
    (e.g. “S32” for floats). Note that you should always provide `dtype="S"` when
    converting non-strings to strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `dtype="S"` is provided the results will be largely identical to before,
    but NumPy scalars (not a Python float like `1.0`), will still enforce a uniform
    string length:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Previously the first version gave the same result as the second.
  prefs: []
  type: TYPE_NORMAL
- en: Array coercion restructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Array coercion has been restructured. In general, this should not affect users.
    In extremely rare corner cases where array-likes are nested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Things will now be more consistent with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: This can subtly change output for some badly defined array-likes. One example
    for this are array-like objects which are not also sequences of matching shape.
    In NumPy 1.20, a warning will be given when an array-like is not also a sequence
    (but behaviour remains identical, see deprecations). If an array like is also
    a sequence (defines `__getitem__` and `__len__`) NumPy will now only use the result
    given by `__array__`, `__array_interface__`, or `__array_struct__`. This will
    result in differences when the (nested) sequence describes a different shape.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16200](https://github.com/numpy/numpy/pull/16200))
  prefs: []
  type: TYPE_NORMAL
- en: Writing to the result of [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") will export readonly buffers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In NumPy 1.17 [`numpy.broadcast_arrays`](../reference/generated/numpy.broadcast_arrays.html#numpy.broadcast_arrays
    "numpy.broadcast_arrays") started warning when the resulting array was written
    to. This warning was skipped when the array was used through the buffer interface
    (e.g. `memoryview(arr)`). The same thing will now occur for the two protocols
    `__array_interface__`, and `__array_struct__` returning read-only buffers instead
    of giving a warning.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16350](https://github.com/numpy/numpy/pull/16350))
  prefs: []
  type: TYPE_NORMAL
- en: Numeric-style type names have been removed from type dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To stay in sync with the deprecation for `np.dtype("Complex64")` and other numeric-style
    (capital case) types. These were removed from `np.sctypeDict` and `np.typeDict`.
    You should use the lower case versions instead. Note that `"Complex64"` corresponds
    to `"complex128"` and `"Complex32"` corresponds to `"complex64"`. The numpy style
    (new) versions, denote the full size and not the size of the real/imaginary part.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16554](https://github.com/numpy/numpy/pull/16554))
  prefs: []
  type: TYPE_NORMAL
- en: The `operator.concat` function now raises TypeError for array arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous behavior was to fall back to addition and add the two arrays, which
    was thought to be unexpected behavior for a concatenation function.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16570](https://github.com/numpy/numpy/pull/16570))
  prefs: []
  type: TYPE_NORMAL
- en: '`nickname` attribute removed from ABCPolyBase'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An abstract property `nickname` has been removed from `ABCPolyBase` as it was
    no longer used in the derived convenience classes. This may affect users who have
    derived classes from `ABCPolyBase` and overridden the methods for representation
    and display, e.g. `__str__`, `__repr__`, `_repr_latex`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16589](https://github.com/numpy/numpy/pull/16589))
  prefs: []
  type: TYPE_NORMAL
- en: '`float->timedelta` and `uint64->timedelta` promotion will raise a TypeError'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Float and timedelta promotion consistently raises a TypeError. `np.promote_types("float32",
    "m8")` aligns with `np.promote_types("m8", "float32")` now and both raise a TypeError.
    Previously, `np.promote_types("float32", "m8")` returned `"m8"` which was considered
    a bug.
  prefs: []
  type: TYPE_NORMAL
- en: Uint64 and timedelta promotion consistently raises a TypeError. `np.promote_types("uint64",
    "m8")` aligns with `np.promote_types("m8", "uint64")` now and both raise a TypeError.
    Previously, `np.promote_types("uint64", "m8")` returned `"m8"` which was considered
    a bug.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16592](https://github.com/numpy/numpy/pull/16592))
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.genfromtxt` now correctly unpacks structured arrays'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, [`numpy.genfromtxt`](../reference/generated/numpy.genfromtxt.html#numpy.genfromtxt
    "numpy.genfromtxt") failed to unpack if it was called with `unpack=True` and a
    structured datatype was passed to the `dtype` argument (or `dtype=None` was passed
    and a structured datatype was inferred). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Structured arrays will now correctly unpack into a list of arrays, one for
    each column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16650](https://github.com/numpy/numpy/pull/16650))
  prefs: []
  type: TYPE_NORMAL
- en: '`mgrid`, `r_`, etc. consistently return correct outputs for non-default precision
    input'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, `np.mgrid[np.float32(0.1):np.float32(0.35):np.float32(0.1),]` and
    `np.r_[0:10:np.complex64(3j)]` failed to return meaningful output. This bug potentially
    affects [`mgrid`](../reference/generated/numpy.mgrid.html#numpy.mgrid "numpy.mgrid"),
    [`ogrid`](../reference/generated/numpy.ogrid.html#numpy.ogrid "numpy.ogrid"),
    [`r_`](../reference/generated/numpy.r_.html#numpy.r_ "numpy.r_"), and [`c_`](../reference/generated/numpy.c_.html#numpy.c_
    "numpy.c_") when an input with dtype other than the default `float64` and `complex128`
    and equivalent Python types were used. The methods have been fixed to handle varying
    precision correctly.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16815](https://github.com/numpy/numpy/pull/16815))
  prefs: []
  type: TYPE_NORMAL
- en: Boolean array indices with mismatching shapes now properly give `IndexError`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, if a boolean array index matched the size of the indexed array but
    not the shape, it was incorrectly allowed in some cases. In other cases, it gave
    an error, but the error was incorrectly a `ValueError` with a message about broadcasting
    instead of the correct `IndexError`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following used to incorrectly give `ValueError: operands could
    not be broadcast together with shapes (2,2) (1,4)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'And the following used to incorrectly return `array([], dtype=float64)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Both now correctly give `IndexError: boolean index did not match indexed array
    along dimension 0; dimension is 2 but corresponding boolean dimension is 1`.'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17010](https://github.com/numpy/numpy/pull/17010))
  prefs: []
  type: TYPE_NORMAL
- en: Casting errors interrupt Iteration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When iterating while casting values, an error may stop the iteration earlier
    than before. In any case, a failed casting operation always returned undefined,
    partial results. Those may now be even more undefined and partial. For users of
    the `NpyIter` C-API such cast errors will now cause the *iternext()* function
    to return 0 and thus abort iteration. Currently, there is no API to detect such
    an error directly. It is necessary to check `PyErr_Occurred()`, which may be problematic
    in combination with `NpyIter_Reset`. These issues always existed, but new API
    could be added if required by users.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17029](https://github.com/numpy/numpy/pull/17029))
  prefs: []
  type: TYPE_NORMAL
- en: f2py generated code may return unicode instead of byte strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some byte strings previously returned by f2py generated code may now be unicode
    strings. This results from the ongoing Python2 -> Python3 cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17068](https://github.com/numpy/numpy/pull/17068))
  prefs: []
  type: TYPE_NORMAL
- en: The first element of the `__array_interface__["data"]` tuple must be an integer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This has been the documented interface for many years, but there was still code
    that would accept a byte string representation of the pointer address. That code
    has been removed, passing the address as a byte string will now raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17241](https://github.com/numpy/numpy/pull/17241))
  prefs: []
  type: TYPE_NORMAL
- en: poly1d respects the dtype of all-zero argument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previously, constructing an instance of `poly1d` with all-zero coefficients
    would cast the coefficients to `np.float64`. This affected the output dtype of
    methods which construct `poly1d` instances internally, such as `np.polymul`.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17577](https://github.com/numpy/numpy/pull/17577))
  prefs: []
  type: TYPE_NORMAL
- en: The numpy.i file for swig is Python 3 only.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Uses of Python 2.7 C-API functions have been updated to Python 3 only. Users
    who need the old version should take it from an older version of NumPy.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17580](https://github.com/numpy/numpy/pull/17580))
  prefs: []
  type: TYPE_NORMAL
- en: Void dtype discovery in `np.array`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In calls using `np.array(..., dtype="V")`, `arr.astype("V")`, and similar a
    TypeError will now be correctly raised unless all elements have the identical
    void length. An example for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Which previously returned an array with dtype `"V2"` which cannot represent
    `b"1"` faithfully.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17706](https://github.com/numpy/numpy/pull/17706))
  prefs: []
  type: TYPE_NORMAL
- en: C API changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `PyArray_DescrCheck` macro is modified
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `PyArray_DescrCheck` macro has been updated since NumPy 1.16.6 to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with NumPy 1.20 code that is compiled against an earlier version will
    be API incompatible with NumPy 1.20. The fix is to either compile against 1.16.6
    (if the NumPy 1.16 release is the oldest release you wish to support), or manually
    inline the macro by replacing it with the new definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: which is compatible with all NumPy versions.
  prefs: []
  type: TYPE_NORMAL
- en: Size of `np.ndarray` and `np.void_` changed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The size of the `PyArrayObject` and `PyVoidScalarObject` structures have changed.
    The following header definition has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'since the size must not be considered a compile time constant: it will change
    for different runtime versions of NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: The most likely relevant use are potential subclasses written in C which will
    have to be recompiled and should be updated. Please see the documentation for
    [`PyArrayObject`](../reference/c-api/types-and-structures.html#c.PyArrayObject
    "PyArrayObject") for more details and contact the NumPy developers if you are
    affected by this change.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy will attempt to give a graceful error but a program expecting a fixed
    structure size may have undefined behaviour and likely crash.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16938](https://github.com/numpy/numpy/pull/16938))
  prefs: []
  type: TYPE_NORMAL
- en: The `PyArray_DescrCheck` macro is modified
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `PyArray_DescrCheck` macro has been updated since NumPy 1.16.6 to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with NumPy 1.20 code that is compiled against an earlier version will
    be API incompatible with NumPy 1.20. The fix is to either compile against 1.16.6
    (if the NumPy 1.16 release is the oldest release you wish to support), or manually
    inline the macro by replacing it with the new definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: which is compatible with all NumPy versions.
  prefs: []
  type: TYPE_NORMAL
- en: Size of `np.ndarray` and `np.void_` changed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The size of the `PyArrayObject` and `PyVoidScalarObject` structures have changed.
    The following header definition has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'since the size must not be considered a compile time constant: it will change
    for different runtime versions of NumPy.'
  prefs: []
  type: TYPE_NORMAL
- en: The most likely relevant use are potential subclasses written in C which will
    have to be recompiled and should be updated. Please see the documentation for
    [`PyArrayObject`](../reference/c-api/types-and-structures.html#c.PyArrayObject
    "PyArrayObject") for more details and contact the NumPy developers if you are
    affected by this change.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy will attempt to give a graceful error but a program expecting a fixed
    structure size may have undefined behaviour and likely crash.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16938](https://github.com/numpy/numpy/pull/16938))
  prefs: []
  type: TYPE_NORMAL
- en: New Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`where` keyword argument for `numpy.all` and `numpy.any` functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword argument `where` is added and allows to only consider specified
    elements or subaxes from an array in the Boolean evaluation of `all` and `any`.
    This new keyword is available to the functions `all` and `any` both via `numpy`
    directly or in the methods of `numpy.ndarray`.
  prefs: []
  type: TYPE_NORMAL
- en: Any broadcastable Boolean array or a scalar can be set as `where`. It defaults
    to `True` to evaluate the functions for all elements in an array if `where` is
    not set by the user. Examples are given in the documentation of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: '`where` keyword argument for `numpy` functions `mean`, `std`, `var`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword argument `where` is added and allows to limit the scope in the calculation
    of `mean`, `std` and `var` to only a subset of elements. It is available both
    via `numpy` directly or in the methods of `numpy.ndarray`.
  prefs: []
  type: TYPE_NORMAL
- en: Any broadcastable Boolean array or a scalar can be set as `where`. It defaults
    to `True` to evaluate the functions for all elements in an array if `where` is
    not set by the user. Examples are given in the documentation of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15852](https://github.com/numpy/numpy/pull/15852))
  prefs: []
  type: TYPE_NORMAL
- en: '`norm=backward`, `forward` keyword options for `numpy.fft` functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword argument option `norm=backward` is added as an alias for `None`
    and acts as the default option; using it has the direct transforms unscaled and
    the inverse transforms scaled by `1/n`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new keyword argument option `norm=forward` has the direct transforms
    scaled by `1/n` and the inverse transforms unscaled (i.e. exactly opposite to
    the default option `norm=backward`).
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16476](https://github.com/numpy/numpy/pull/16476))
  prefs: []
  type: TYPE_NORMAL
- en: NumPy is now typed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type annotations have been added for large parts of NumPy. There is also a new
    [`numpy.typing`](../reference/typing.html#module-numpy.typing "numpy.typing")
    module that contains useful types for end-users. The currently available types
    are
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrayLike`: for objects that can be coerced to an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DtypeLike`: for objects that can be coerced to a dtype'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([gh-16515](https://github.com/numpy/numpy/pull/16515))
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.typing` is accessible at runtime'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The types in `numpy.typing` can now be imported at runtime. Code like the following
    will now work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16558](https://github.com/numpy/numpy/pull/16558))
  prefs: []
  type: TYPE_NORMAL
- en: New `__f2py_numpy_version__` attribute for f2py generated modules.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because f2py is released together with NumPy, `__f2py_numpy_version__` provides
    a way to track the version f2py used to generate the module.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16594](https://github.com/numpy/numpy/pull/16594))
  prefs: []
  type: TYPE_NORMAL
- en: '`mypy` tests can be run via runtests.py'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently running mypy with the NumPy stubs configured requires either:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing NumPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the source directory to MYPYPATH and linking to the `mypy.ini`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both options are somewhat inconvenient, so add a `--mypy` option to runtests
    that handles setting things up for you. This will also be useful in the future
    for any typing codegen since it will ensure the project is built before type checking.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17123](https://github.com/numpy/numpy/pull/17123))
  prefs: []
  type: TYPE_NORMAL
- en: Negation of user defined BLAS/LAPACK detection order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    allows negation of libraries when determining BLAS/LAPACK libraries. This may
    be used to remove an item from the library resolution phase, i.e. to disallow
    NetLIB libraries one could do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: That will use any of the accelerated libraries instead.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17219](https://github.com/numpy/numpy/pull/17219))
  prefs: []
  type: TYPE_NORMAL
- en: Allow passing optimizations arguments to asv build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is now possible to pass `-j`, `--cpu-baseline`, `--cpu-dispatch` and `--disable-optimization`
    flags to ASV build when the `--bench-compare` argument is used.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17284](https://github.com/numpy/numpy/pull/17284))
  prefs: []
  type: TYPE_NORMAL
- en: The NVIDIA HPC SDK nvfortran compiler is now supported
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for the nvfortran compiler, a version of pgfortran, has been added.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17344](https://github.com/numpy/numpy/pull/17344))
  prefs: []
  type: TYPE_NORMAL
- en: '`dtype` option for `cov` and `corrcoef`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dtype` option is now available for [`numpy.cov`](../reference/generated/numpy.cov.html#numpy.cov
    "numpy.cov") and [`numpy.corrcoef`](../reference/generated/numpy.corrcoef.html#numpy.corrcoef
    "numpy.corrcoef"). It specifies which data-type the returned result should have.
    By default the functions still return a [`numpy.float64`](../reference/arrays.scalars.html#numpy.float64
    "numpy.float64") result.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17456](https://github.com/numpy/numpy/pull/17456))
  prefs: []
  type: TYPE_NORMAL
- en: '`where` keyword argument for `numpy.all` and `numpy.any` functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword argument `where` is added and allows to only consider specified
    elements or subaxes from an array in the Boolean evaluation of `all` and `any`.
    This new keyword is available to the functions `all` and `any` both via `numpy`
    directly or in the methods of `numpy.ndarray`.
  prefs: []
  type: TYPE_NORMAL
- en: Any broadcastable Boolean array or a scalar can be set as `where`. It defaults
    to `True` to evaluate the functions for all elements in an array if `where` is
    not set by the user. Examples are given in the documentation of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: '`where` keyword argument for `numpy` functions `mean`, `std`, `var`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword argument `where` is added and allows to limit the scope in the calculation
    of `mean`, `std` and `var` to only a subset of elements. It is available both
    via `numpy` directly or in the methods of `numpy.ndarray`.
  prefs: []
  type: TYPE_NORMAL
- en: Any broadcastable Boolean array or a scalar can be set as `where`. It defaults
    to `True` to evaluate the functions for all elements in an array if `where` is
    not set by the user. Examples are given in the documentation of the functions.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15852](https://github.com/numpy/numpy/pull/15852))
  prefs: []
  type: TYPE_NORMAL
- en: '`norm=backward`, `forward` keyword options for `numpy.fft` functions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The keyword argument option `norm=backward` is added as an alias for `None`
    and acts as the default option; using it has the direct transforms unscaled and
    the inverse transforms scaled by `1/n`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the new keyword argument option `norm=forward` has the direct transforms
    scaled by `1/n` and the inverse transforms unscaled (i.e. exactly opposite to
    the default option `norm=backward`).
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16476](https://github.com/numpy/numpy/pull/16476))
  prefs: []
  type: TYPE_NORMAL
- en: NumPy is now typed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Type annotations have been added for large parts of NumPy. There is also a new
    [`numpy.typing`](../reference/typing.html#module-numpy.typing "numpy.typing")
    module that contains useful types for end-users. The currently available types
    are
  prefs: []
  type: TYPE_NORMAL
- en: '`ArrayLike`: for objects that can be coerced to an array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DtypeLike`: for objects that can be coerced to a dtype'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([gh-16515](https://github.com/numpy/numpy/pull/16515))
  prefs: []
  type: TYPE_NORMAL
- en: '`numpy.typing` is accessible at runtime'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The types in `numpy.typing` can now be imported at runtime. Code like the following
    will now work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16558](https://github.com/numpy/numpy/pull/16558))
  prefs: []
  type: TYPE_NORMAL
- en: New `__f2py_numpy_version__` attribute for f2py generated modules.
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because f2py is released together with NumPy, `__f2py_numpy_version__` provides
    a way to track the version f2py used to generate the module.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16594](https://github.com/numpy/numpy/pull/16594))
  prefs: []
  type: TYPE_NORMAL
- en: '`mypy` tests can be run via runtests.py'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently running mypy with the NumPy stubs configured requires either:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing NumPy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the source directory to MYPYPATH and linking to the `mypy.ini`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both options are somewhat inconvenient, so add a `--mypy` option to runtests
    that handles setting things up for you. This will also be useful in the future
    for any typing codegen since it will ensure the project is built before type checking.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17123](https://github.com/numpy/numpy/pull/17123))
  prefs: []
  type: TYPE_NORMAL
- en: Negation of user defined BLAS/LAPACK detection order
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[`distutils`](../reference/distutils.html#module-numpy.distutils "numpy.distutils")
    allows negation of libraries when determining BLAS/LAPACK libraries. This may
    be used to remove an item from the library resolution phase, i.e. to disallow
    NetLIB libraries one could do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: That will use any of the accelerated libraries instead.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17219](https://github.com/numpy/numpy/pull/17219))
  prefs: []
  type: TYPE_NORMAL
- en: Allow passing optimizations arguments to asv build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is now possible to pass `-j`, `--cpu-baseline`, `--cpu-dispatch` and `--disable-optimization`
    flags to ASV build when the `--bench-compare` argument is used.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17284](https://github.com/numpy/numpy/pull/17284))
  prefs: []
  type: TYPE_NORMAL
- en: The NVIDIA HPC SDK nvfortran compiler is now supported
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support for the nvfortran compiler, a version of pgfortran, has been added.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17344](https://github.com/numpy/numpy/pull/17344))
  prefs: []
  type: TYPE_NORMAL
- en: '`dtype` option for `cov` and `corrcoef`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `dtype` option is now available for [`numpy.cov`](../reference/generated/numpy.cov.html#numpy.cov
    "numpy.cov") and [`numpy.corrcoef`](../reference/generated/numpy.corrcoef.html#numpy.corrcoef
    "numpy.corrcoef"). It specifies which data-type the returned result should have.
    By default the functions still return a [`numpy.float64`](../reference/arrays.scalars.html#numpy.float64
    "numpy.float64") result.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17456](https://github.com/numpy/numpy/pull/17456))
  prefs: []
  type: TYPE_NORMAL
- en: Improvements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improved string representation for polynomials (`__str__`)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The string representation (`__str__`) of all six polynomial types in [`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") has been updated to give the polynomial as a mathematical
    expression instead of an array of coefficients. Two package-wide formats for the
    polynomial expressions are available - one using Unicode characters for superscripts
    and subscripts, and another using only ASCII characters.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15666](https://github.com/numpy/numpy/pull/15666))
  prefs: []
  type: TYPE_NORMAL
- en: Remove the Accelerate library as a candidate LAPACK library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apple no longer supports Accelerate. Remove it.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15759](https://github.com/numpy/numpy/pull/15759))
  prefs: []
  type: TYPE_NORMAL
- en: Object arrays containing multi-line objects have a more readable `repr`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If elements of an object array have a `repr` containing new lines, then the
    wrapped lines will be aligned by column. Notably, this improves the `repr` of
    nested arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-15997](https://github.com/numpy/numpy/pull/15997))
  prefs: []
  type: TYPE_NORMAL
- en: Concatenate supports providing an output dtype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support was added to [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate") to provide an output `dtype` and `casting` using keyword
    arguments. The `dtype` argument cannot be provided in conjunction with the `out`
    one.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16134](https://github.com/numpy/numpy/pull/16134))
  prefs: []
  type: TYPE_NORMAL
- en: Thread safe f2py callback functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Callback functions in f2py are now thread safe.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16519](https://github.com/numpy/numpy/pull/16519))
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.core.records.fromfile`](../reference/generated/numpy.core.records.fromfile.html#numpy.core.records.fromfile
    "numpy.core.records.fromfile") now supports file-like objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`numpy.rec.fromfile` can now use file-like objects, for instance [`io.BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO
    "(in Python v3.11)")'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16675](https://github.com/numpy/numpy/pull/16675))
  prefs: []
  type: TYPE_NORMAL
- en: RPATH support on AIX added to distutils
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This allows SciPy to be built on AIX.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16710](https://github.com/numpy/numpy/pull/16710))
  prefs: []
  type: TYPE_NORMAL
- en: Use f90 compiler specified by the command line args
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The compiler command selection for Fortran Portland Group Compiler is changed
    in `numpy.distutils.fcompiler`. This only affects the linking command. This forces
    the use of the executable provided by the command line option (if provided) instead
    of the pgfortran executable. If no executable is provided to the command line
    option it defaults to the pgf90 executable, which is an alias for pgfortran according
    to the PGI documentation.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16730](https://github.com/numpy/numpy/pull/16730))
  prefs: []
  type: TYPE_NORMAL
- en: Add NumPy declarations for Cython 3.0 and later
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pxd declarations for Cython 3.0 were improved to avoid using deprecated
    NumPy C-API features. Extension modules built with Cython 3.0+ that use NumPy
    can now set the C macro `NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION` to avoid C
    compiler warnings about deprecated API usage.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16986](https://github.com/numpy/numpy/pull/16986))
  prefs: []
  type: TYPE_NORMAL
- en: Make the window functions exactly symmetric
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure the window functions provided by NumPy are symmetric. There were previously
    small deviations from symmetry due to numerical precision that are now avoided
    by better arrangement of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17195](https://github.com/numpy/numpy/pull/17195))
  prefs: []
  type: TYPE_NORMAL
- en: Improved string representation for polynomials (`__str__`)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The string representation (`__str__`) of all six polynomial types in [`numpy.polynomial`](../reference/routines.polynomials.package.html#module-numpy.polynomial
    "numpy.polynomial") has been updated to give the polynomial as a mathematical
    expression instead of an array of coefficients. Two package-wide formats for the
    polynomial expressions are available - one using Unicode characters for superscripts
    and subscripts, and another using only ASCII characters.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15666](https://github.com/numpy/numpy/pull/15666))
  prefs: []
  type: TYPE_NORMAL
- en: Remove the Accelerate library as a candidate LAPACK library
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apple no longer supports Accelerate. Remove it.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-15759](https://github.com/numpy/numpy/pull/15759))
  prefs: []
  type: TYPE_NORMAL
- en: Object arrays containing multi-line objects have a more readable `repr`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If elements of an object array have a `repr` containing new lines, then the
    wrapped lines will be aligned by column. Notably, this improves the `repr` of
    nested arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-15997](https://github.com/numpy/numpy/pull/15997))
  prefs: []
  type: TYPE_NORMAL
- en: Concatenate supports providing an output dtype
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Support was added to [`concatenate`](../reference/generated/numpy.concatenate.html#numpy.concatenate
    "numpy.concatenate") to provide an output `dtype` and `casting` using keyword
    arguments. The `dtype` argument cannot be provided in conjunction with the `out`
    one.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16134](https://github.com/numpy/numpy/pull/16134))
  prefs: []
  type: TYPE_NORMAL
- en: Thread safe f2py callback functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Callback functions in f2py are now thread safe.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16519](https://github.com/numpy/numpy/pull/16519))
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.core.records.fromfile`](../reference/generated/numpy.core.records.fromfile.html#numpy.core.records.fromfile
    "numpy.core.records.fromfile") now supports file-like objects'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`numpy.rec.fromfile` can now use file-like objects, for instance [`io.BytesIO`](https://docs.python.org/3/library/io.html#io.BytesIO
    "(in Python v3.11)")'
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16675](https://github.com/numpy/numpy/pull/16675))
  prefs: []
  type: TYPE_NORMAL
- en: RPATH support on AIX added to distutils
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This allows SciPy to be built on AIX.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16710](https://github.com/numpy/numpy/pull/16710))
  prefs: []
  type: TYPE_NORMAL
- en: Use f90 compiler specified by the command line args
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The compiler command selection for Fortran Portland Group Compiler is changed
    in `numpy.distutils.fcompiler`. This only affects the linking command. This forces
    the use of the executable provided by the command line option (if provided) instead
    of the pgfortran executable. If no executable is provided to the command line
    option it defaults to the pgf90 executable, which is an alias for pgfortran according
    to the PGI documentation.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16730](https://github.com/numpy/numpy/pull/16730))
  prefs: []
  type: TYPE_NORMAL
- en: Add NumPy declarations for Cython 3.0 and later
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pxd declarations for Cython 3.0 were improved to avoid using deprecated
    NumPy C-API features. Extension modules built with Cython 3.0+ that use NumPy
    can now set the C macro `NPY_NO_DEPRECATED_API=NPY_1_7_API_VERSION` to avoid C
    compiler warnings about deprecated API usage.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-16986](https://github.com/numpy/numpy/pull/16986))
  prefs: []
  type: TYPE_NORMAL
- en: Make the window functions exactly symmetric
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure the window functions provided by NumPy are symmetric. There were previously
    small deviations from symmetry due to numerical precision that are now avoided
    by better arrangement of the computation.
  prefs: []
  type: TYPE_NORMAL
- en: ([gh-17195](https://github.com/numpy/numpy/pull/17195))
  prefs: []
  type: TYPE_NORMAL
- en: Performance improvements and changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enable multi-platform SIMD compiler optimizations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A series of improvements for NumPy infrastructure to pave the way to **NEP-38**,
    that can be summarized as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Build Arguments**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-baseline` to specify the minimal set of required optimizations, default
    value is `min` which provides the minimum CPU features that can safely run on
    a wide range of users platforms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-dispatch` to specify the dispatched set of additional optimizations,
    default value is `max -xop -fma4` which enables all CPU features, except for AMD
    legacy features.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--disable-optimization` to explicitly disable the whole new improvements,
    It also adds a new **C** compiler #definition called `NPY_DISABLE_OPTIMIZATION`
    which it can be used as guard for any SIMD code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced CPU dispatcher**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flexible cross-architecture CPU dispatcher built on the top of Python/Numpy
    distutils, support all common compilers with a wide range of CPU features.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The new dispatcher requires a special file extension `*.dispatch.c` to mark
    the dispatch-able **C** sources. These sources have the ability to be compiled
    multiple times so that each compilation process represents certain CPU features
    and provides different #definitions and flags that affect the code paths.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**New auto-generated C header ``core/src/common/_cpu_dispatch.h``**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This header is generated by the distutils module `ccompiler_opt`, and contains
    all the #definitions and headers of instruction sets, that had been configured
    through command arguments ‘–cpu-baseline’ and ‘–cpu-dispatch’.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**New C header ``core/src/common/npy_cpu_dispatch.h``**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This header contains all utilities that required for the whole CPU dispatching
    process, it also can be considered as a bridge linking the new infrastructure
    work with NumPy CPU runtime detection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Add new attributes to NumPy umath module(Python level)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__cpu_baseline__` a list contains the minimal set of required optimizations
    that supported by the compiler and platform according to the specified values
    to command argument ‘–cpu-baseline’.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__cpu_dispatch__` a list contains the dispatched set of additional optimizations
    that supported by the compiler and platform according to the specified values
    to command argument ‘–cpu-dispatch’.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Print the supported CPU features during the run of PytestTester**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([gh-13516](https://github.com/numpy/numpy/pull/13516))
  prefs: []
  type: TYPE_NORMAL
- en: Enable multi-platform SIMD compiler optimizations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A series of improvements for NumPy infrastructure to pave the way to **NEP-38**,
    that can be summarized as follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '**New Build Arguments**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-baseline` to specify the minimal set of required optimizations, default
    value is `min` which provides the minimum CPU features that can safely run on
    a wide range of users platforms.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-dispatch` to specify the dispatched set of additional optimizations,
    default value is `max -xop -fma4` which enables all CPU features, except for AMD
    legacy features.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--disable-optimization` to explicitly disable the whole new improvements,
    It also adds a new **C** compiler #definition called `NPY_DISABLE_OPTIMIZATION`
    which it can be used as guard for any SIMD code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Advanced CPU dispatcher**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flexible cross-architecture CPU dispatcher built on the top of Python/Numpy
    distutils, support all common compilers with a wide range of CPU features.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The new dispatcher requires a special file extension `*.dispatch.c` to mark
    the dispatch-able **C** sources. These sources have the ability to be compiled
    multiple times so that each compilation process represents certain CPU features
    and provides different #definitions and flags that affect the code paths.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**New auto-generated C header ``core/src/common/_cpu_dispatch.h``**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This header is generated by the distutils module `ccompiler_opt`, and contains
    all the #definitions and headers of instruction sets, that had been configured
    through command arguments ‘–cpu-baseline’ and ‘–cpu-dispatch’.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**New C header ``core/src/common/npy_cpu_dispatch.h``**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This header contains all utilities that required for the whole CPU dispatching
    process, it also can be considered as a bridge linking the new infrastructure
    work with NumPy CPU runtime detection.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Add new attributes to NumPy umath module(Python level)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__cpu_baseline__` a list contains the minimal set of required optimizations
    that supported by the compiler and platform according to the specified values
    to command argument ‘–cpu-baseline’.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`__cpu_dispatch__` a list contains the dispatched set of additional optimizations
    that supported by the compiler and platform according to the specified values
    to command argument ‘–cpu-dispatch’.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Print the supported CPU features during the run of PytestTester**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ([gh-13516](https://github.com/numpy/numpy/pull/13516))
  prefs: []
  type: TYPE_NORMAL
- en: Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changed behavior of `divmod(1., 0.)` and related functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The changes also assure that different compiler versions have the same behavior
    for nan or inf usages in these operations. This was previously compiler dependent,
    we now force the invalid and divide by zero flags, making the results the same
    across compilers. For example, gcc-5, gcc-8, or gcc-9 now result in the same behavior.
    The changes are tabulated below:'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of New Behavior
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Old Warning | New Warning | Old Result | New Result | Works on
    MacOS |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| np.divmod(1.0, 0.0) | Invalid | Invalid and Dividebyzero | nan, nan | inf,
    nan | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| np.fmod(1.0, 0.0) | Invalid | Invalid | nan | nan | No? Yes |'
  prefs: []
  type: TYPE_TB
- en: '| np.floor_divide(1.0, 0.0) | Invalid | Dividebyzero | nan | inf | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| np.remainder(1.0, 0.0) | Invalid | Invalid | nan | nan | Yes |'
  prefs: []
  type: TYPE_TB
- en: ([gh-16161](https://github.com/numpy/numpy/pull/16161))
  prefs: []
  type: TYPE_NORMAL
- en: '`np.linspace` on integers now uses floor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using a `int` dtype in [`numpy.linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), previously float values would be rounded towards zero. Now
    [`numpy.floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor")
    is used instead, which rounds toward `-inf`. This changes the results for negative
    values. For example, the following would previously give:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'and now results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The former result can still be obtained with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16841](https://github.com/numpy/numpy/pull/16841))
  prefs: []
  type: TYPE_NORMAL
- en: Changed behavior of `divmod(1., 0.)` and related functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The changes also assure that different compiler versions have the same behavior
    for nan or inf usages in these operations. This was previously compiler dependent,
    we now force the invalid and divide by zero flags, making the results the same
    across compilers. For example, gcc-5, gcc-8, or gcc-9 now result in the same behavior.
    The changes are tabulated below:'
  prefs: []
  type: TYPE_NORMAL
- en: Summary of New Behavior
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Old Warning | New Warning | Old Result | New Result | Works on
    MacOS |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| np.divmod(1.0, 0.0) | Invalid | Invalid and Dividebyzero | nan, nan | inf,
    nan | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| np.fmod(1.0, 0.0) | Invalid | Invalid | nan | nan | No? Yes |'
  prefs: []
  type: TYPE_TB
- en: '| np.floor_divide(1.0, 0.0) | Invalid | Dividebyzero | nan | inf | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| np.remainder(1.0, 0.0) | Invalid | Invalid | nan | nan | Yes |'
  prefs: []
  type: TYPE_TB
- en: ([gh-16161](https://github.com/numpy/numpy/pull/16161))
  prefs: []
  type: TYPE_NORMAL
- en: '`np.linspace` on integers now uses floor'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using a `int` dtype in [`numpy.linspace`](../reference/generated/numpy.linspace.html#numpy.linspace
    "numpy.linspace"), previously float values would be rounded towards zero. Now
    [`numpy.floor`](../reference/generated/numpy.floor.html#numpy.floor "numpy.floor")
    is used instead, which rounds toward `-inf`. This changes the results for negative
    values. For example, the following would previously give:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'and now results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The former result can still be obtained with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: ([gh-16841](https://github.com/numpy/numpy/pull/16841))
  prefs: []
  type: TYPE_NORMAL
