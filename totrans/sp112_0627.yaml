- en: scipy.signal.zpk2sos
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.zpk2sos.html#scipy.signal.zpk2sos](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.zpk2sos.html#scipy.signal.zpk2sos)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Return second-order sections from zeros, poles, and gain of a system
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**z**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Zeros of the transfer function.
  prefs: []
  type: TYPE_NORMAL
- en: '**p**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Poles of the transfer function.
  prefs: []
  type: TYPE_NORMAL
- en: '**k**float'
  prefs: []
  type: TYPE_NORMAL
- en: System gain.
  prefs: []
  type: TYPE_NORMAL
- en: '**pairing**{None, ‘nearest’, ‘keep_odd’, ‘minimal’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The method to use to combine pairs of poles and zeros into sections. If analog
    is False and pairing is None, pairing is set to ‘nearest’; if analog is True,
    pairing must be ‘minimal’, and is set to that if it is None.
  prefs: []
  type: TYPE_NORMAL
- en: '**analog**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, system is analog, otherwise discrete.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.8.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sos**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Array of second-order filter coefficients, with shape `(n_sections, 6)`. See
    [`sosfilt`](scipy.signal.sosfilt.html#scipy.signal.sosfilt "scipy.signal.sosfilt")
    for the SOS filter format specification.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sosfilt`](scipy.signal.sosfilt.html#scipy.signal.sosfilt "scipy.signal.sosfilt")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm used to convert ZPK to SOS format is designed to minimize errors
    due to numerical precision issues. The pairing algorithm attempts to minimize
    the peak gain of each biquadratic section. This is done by pairing poles with
    the nearest zeros, starting with the poles closest to the unit circle for discrete-time
    systems, and poles closest to the imaginary axis for continuous-time systems.
  prefs: []
  type: TYPE_NORMAL
- en: '`pairing=''minimal''` outputs may not be suitable for [`sosfilt`](scipy.signal.sosfilt.html#scipy.signal.sosfilt
    "scipy.signal.sosfilt"), and `analog=True` outputs will never be suitable for
    [`sosfilt`](scipy.signal.sosfilt.html#scipy.signal.sosfilt "scipy.signal.sosfilt").'
  prefs: []
  type: TYPE_NORMAL
- en: '*Algorithms*'
  prefs: []
  type: TYPE_NORMAL
- en: The steps in the `pairing='nearest'`, `pairing='keep_odd'`, and `pairing='minimal'`
    algorithms are mostly shared. The `'nearest'` algorithm attempts to minimize the
    peak gain, while `'keep_odd'` minimizes peak gain under the constraint that odd-order
    systems should retain one section as first order. `'minimal'` is similar to `'keep_odd'`,
    but no additional poles or zeros are introduced
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As a pre-processing step for `pairing='nearest'`, `pairing='keep_odd'`, add
    poles or zeros to the origin as necessary to obtain the same number of poles and
    zeros for pairing. If `pairing == 'nearest'` and there are an odd number of poles,
    add an additional pole and a zero at the origin.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps are then iterated over until no more poles or zeros remain:'
  prefs: []
  type: TYPE_NORMAL
- en: Take the (next remaining) pole (complex or real) closest to the unit circle
    (or imaginary axis, for `analog=True`) to begin a new filter section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the pole is real and there are no other remaining real poles [[1]](#id2),
    add the closest real zero to the section and leave it as a first order section.
    Note that after this step we are guaranteed to be left with an even number of
    real poles, complex poles, real zeros, and complex zeros for subsequent pairing
    iterations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Else:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the pole is complex and the zero is the only remaining real zero*, then pair
    the pole with the *next* closest zero (guaranteed to be complex). This is necessary
    to ensure that there will be a real zero remaining to eventually create a first-order
    section (thus keeping the odd order).
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Else pair the pole with the closest remaining zero (complex or real).
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Proceed to complete the second-order section by adding another pole and zero
    to the current pole and zero in the section:'
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If the current pole and zero are both complex, add their conjugates.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Else if the pole is complex and the zero is real, add the conjugate pole and
    the next closest real zero.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Else if the pole is real and the zero is complex, add the conjugate zero and
    the real pole closest to those zeros.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Else (we must have a real pole and real zero) add the next real pole closest
    to the unit circle, and then add the real zero closest to that pole.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: New in version 0.16.0.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Design a 6th order low-pass elliptic digital filter for a system with a sampling
    rate of 8000 Hz that has a pass-band corner frequency of 1000 Hz. The ripple in
    the pass-band should not exceed 0.087 dB, and the attenuation in the stop-band
    should be at least 90 dB.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following call to [`ellip`](scipy.signal.ellip.html#scipy.signal.ellip
    "scipy.signal.ellip"), we could use `output=''sos''`, but for this example, we’ll
    use `output=''zpk''`, and then convert to SOS format with [`zpk2sos`](#scipy.signal.zpk2sos
    "scipy.signal.zpk2sos"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now convert to SOS format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The coefficients of the numerators of the sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The symmetry in the coefficients occurs because all the zeros are on the unit
    circle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coefficients of the denominators of the sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The next example shows the effect of the *pairing* option. We have a system
    with three poles and three zeros, so the SOS array will have shape (2, 6). The
    means there is, in effect, an extra pole and an extra zero at the origin in the
    SOS representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: With `pairing='nearest'` (the default), we obtain
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first section has the zeros {-0.5-0.05j, -0.5+0.5j} and the poles {0, 0.75},
    and the second section has the zeros {-1, 0} and poles {0.8+0.1j, 0.8-0.1j}. Note
    that the extra pole and zero at the origin have been assigned to different sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `pairing=''keep_odd''`, we obtain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The extra pole and zero at the origin are in the same section. The first section
    is, in effect, a first-order section.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `pairing=''minimal''`, the first-order section doesn’t have the extra
    pole and zero at the origin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
