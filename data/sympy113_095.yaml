- en: Solveset
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Solveset
- en: Original text：[https://docs.sympy.org/latest/modules/solvers/solveset.html](https://docs.sympy.org/latest/modules/solvers/solveset.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文链接：[https://docs.sympy.org/latest/modules/solvers/solveset.html](https://docs.sympy.org/latest/modules/solvers/solveset.html)
- en: This is the official documentation of the `solveset` module in solvers. It contains
    the frequently asked questions about our new module to solve equations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`solvers`中`solveset`模块的官方文档。它包含关于我们解方程新模块的常见问题。
- en: Note
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a beginner-friendly guide focused on solving common types of equations,
    refer to [Solve Equations](../../guides/solving/index.html#solving-guide).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 想要一个适合初学者的指南，专注于解决常见类型的方程，请参阅[Solve Equations](../../guides/solving/index.html#solving-guide)。
- en: 'What’s wrong with solve():'
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`solve()` 有什么问题：'
- en: 'SymPy already has a pretty powerful `solve` function. But it has some deficiencies.
    For example:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 已经有一个相当强大的 `solve` 函数。但是它有一些缺陷。例如：
- en: 'It doesn’t have a consistent output for various types of solutions It needs
    to return a lot of types of solutions consistently:'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它没有一致的输出类型来处理各种类型的解决方案。它需要始终返回很多类型的解决方案：
- en: 'Single solution : \(x = 1\)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一解：\(x = 1\)
- en: 'Multiple solutions: \(x^2 = 1\)'
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多解方程：\(x^2 = 1\)
- en: 'No Solution: \(x^2 + 1 = 0 ; x \in \mathbb{R}\)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无解：\(x^2 + 1 = 0 ; x \in \mathbb{R}\)
- en: 'Interval of solution: \(\lfloor x \rfloor = 0\)'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解的区间：\(\lfloor x \rfloor = 0\)
- en: 'Infinitely many solutions: \(\sin(x) = 0\)'
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限多解：\(\sin(x) = 0\)
- en: 'Multivariate functions with point solutions: \(x^2 + y^2 = 0\)'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多元函数有点解：\(x^2 + y^2 = 0\)
- en: 'Multivariate functions with non-point solution: \(x^2 + y^2 = 1\)'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多元函数有非点解：\(x^2 + y^2 = 1\)
- en: 'System of equations: \(x + y = 1\) and \(x - y = 0\)'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程组：\(x + y = 1\) 和 \(x - y = 0\)
- en: 'Relational: \(x > 0\)'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系表达式：\(x > 0\)
- en: 'And the most important case: “We don’t Know”'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 而且最重要的案例是：“我们不知道”
- en: The input API has a lot of parameters and it can be difficult to use.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入 API 有很多参数，使用起来可能会有困难。
- en: There are cases like finding the maxima and minima of function using critical
    points where it is important to know if it has returned all the solutions. `solve`
    does not guarantee this.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 有时候在使用临界点找出函数的极大值和极小值时，知道它是否返回了所有的解决方案是很重要的。`solve`不能保证这一点。
- en: '## Why Solveset?'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '## 为什么要使用 Solveset？'
- en: '`solveset` has an alternative consistent input and output interface: `solveset`
    returns a set object and a set object takes care of all types of output. For cases
    where it does not “know” all the solutions a `ConditionSet` with a partial solution
    is returned. For input it only takes the equation, the variables to solve for
    and the optional argument `domain` over which the equation is to be solved.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`solveset` 有一个备选的一致的输入和输出接口：`solveset` 返回一个集合对象，而集合对象负责处理所有类型的输出。对于它不“知道”所有解决方案的情况，会返回一个具有部分解决方案的
    `ConditionSet`。对于输入，它只接受方程、要解的变量和可选的参数 `domain`，这个参数表示解方程的定义域。'
- en: '`solveset` can return infinitely many solutions. For example solving for \(\sin{(x)}
    = 0\) returns \(\{2 n \pi | n \in \mathbb{Z}\} \cup \{2 n \pi + \pi | n \in \mathbb{Z}\}\),
    whereas `solve` only returns \([0, \pi]\).'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`solveset` 可以返回无限多个解。例如，求解 \(\sin{(x)} = 0\) 会返回 \(\{2 n \pi | n \in \mathbb{Z}\}
    \cup \{2 n \pi + \pi | n \in \mathbb{Z}\}\)，而 `solve` 只返回区间 \([0, \pi]\)。'
- en: There is a clear code level and interface level separation between solvers for
    equations in the complex domain and the real domain. For example solving \(e^x
    = 1\) when \(x\) is to be solved in the complex domain, returns the set of all
    solutions, that is \(\{2 n i \pi | n \in \mathbb{Z}\}\), whereas if \(x\) is to
    be solved in the real domain then only \(\{0\}\) is returned.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在复数域和实数域中，对方程求解器在代码级别和接口级别上有明确的分离。例如，在复数域中解 \(e^x = 1\)，返回所有解的集合，即 \(\{2 n i
    \pi | n \in \mathbb{Z}\}\)，而在实数域中，仅返回 \(\{0\}\)。
- en: Why do we use Sets as an output type?
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们要将集合作为输出类型使用？
- en: 'SymPy has a well developed sets module, which can represent most of the set
    containers in mathematics such as:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 有一个完善的集合模块，可以表示数学中大多数集合容器，比如：
- en: '[`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")'
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")'
- en: ''
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-28
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents a finite set of discrete numbers.
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示离散数字的有限集。
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Interval`](../sets.html#sympy.sets.sets.Interval "sympy.sets.sets.Interval")'
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Interval`](../sets.html#sympy.sets.sets.Interval "sympy.sets.sets.Interval")'
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents a real interval as a set.
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示实数区间作为一个集合。
- en: ''
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-39
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ProductSet`](../sets.html#sympy.sets.sets.ProductSet "sympy.sets.sets.ProductSet")'
  id: totrans-40
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ProductSet`](../sets.html#sympy.sets.sets.ProductSet "sympy.sets.sets.ProductSet")'
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-42
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents a Cartesian product of sets.
  id: totrans-44
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示集合的笛卡尔积。
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-46
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ImageSet`](../sets.html#sympy.sets.fancysets.ImageSet "sympy.sets.fancysets.ImageSet")'
  id: totrans-47
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ImageSet`](../sets.html#sympy.sets.fancysets.ImageSet "sympy.sets.fancysets.ImageSet")'
- en: ''
  id: totrans-48
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-50
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the image of a set under a mathematical function
  id: totrans-51
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示数学函数下的集合的像
- en: ''
  id: totrans-52
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-54
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-55
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: ''
  id: totrans-56
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ComplexRegion`](../sets.html#sympy.sets.fancysets.ComplexRegion "sympy.sets.fancysets.ComplexRegion")'
  id: totrans-58
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ComplexRegion`](../sets.html#sympy.sets.fancysets.ComplexRegion "sympy.sets.fancysets.ComplexRegion")'
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-60
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the set of all complex numbers in a region in the Argand plane.
  id: totrans-62
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示在阿格朗平面的区域中所有复数的集合。
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet "sympy.sets.conditionset.ConditionSet")'
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet "sympy.sets.conditionset.ConditionSet")'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the set of elements, which satisfies a given condition.
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示满足给定条件的元素集合。
- en: 'Also, the predefined set classes such as:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有预定义的集合类，如：
- en: '[`Naturals`](../sets.html#sympy.sets.fancysets.Naturals "sympy.sets.fancysets.Naturals"),
    $mathbb{N}'
  id: totrans-71
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Naturals`](../sets.html#sympy.sets.fancysets.Naturals "sympy.sets.fancysets.Naturals"),
    \(\mathbb{N}\)'
- en: ''
  id: totrans-72
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the natural numbers (or counting numbers), which are all positive
    integers starting from 1.
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示自然数（或计数数），即从1开始的所有正整数。
- en: ''
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Naturals0`](../sets.html#sympy.sets.fancysets.Naturals0 "sympy.sets.fancysets.Naturals0"),
    \(\mathbb{N_0}\)'
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Naturals0`](../sets.html#sympy.sets.fancysets.Naturals0 "sympy.sets.fancysets.Naturals0"),
    \(\mathbb{N_0}\)'
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-80
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the whole numbers, which are all the non-negative integers, inclusive
    of 0.
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示整数，即所有非负整数，包括0。
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Integers`](../sets.html#sympy.sets.fancysets.Integers "sympy.sets.fancysets.Integers"),
    \(\mathbb{Z}\)'
  id: totrans-85
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Integers`](../sets.html#sympy.sets.fancysets.Integers "sympy.sets.fancysets.Integers"),
    \(\mathbb{Z}\)'
- en: ''
  id: totrans-86
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Represents all integers: positive, negative and zero.'
  id: totrans-89
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示所有整数：正数、负数和零。
- en: ''
  id: totrans-90
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Reals`](../sets.html#sympy.sets.fancysets.Reals "sympy.sets.fancysets.Reals"),
    \(\mathbb{R}\)'
  id: totrans-92
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Reals`](../sets.html#sympy.sets.fancysets.Reals "sympy.sets.fancysets.Reals"),
    \(\mathbb{R}\)'
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-94
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the set of all real numbers.
  id: totrans-96
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示所有实数的集合。
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-98
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Complexes`](../sets.html#sympy.sets.fancysets.Complexes "sympy.sets.fancysets.Complexes"),
    \(\mathbb{C}\)'
  id: totrans-99
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Complexes`](../sets.html#sympy.sets.fancysets.Complexes "sympy.sets.fancysets.Complexes"),
    \(\mathbb{C}\)'
- en: ''
  id: totrans-100
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-102
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the set of all complex numbers.
  id: totrans-103
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示所有复数的集合。
- en: ''
  id: totrans-104
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`EmptySet`](../sets.html#sympy.sets.sets.EmptySet "sympy.sets.sets.EmptySet"),
    \(\emptyset\)'
  id: totrans-106
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`EmptySet`](../sets.html#sympy.sets.sets.EmptySet "sympy.sets.sets.EmptySet"),
    \(\emptyset\)'
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-108
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Represents the empty set.
  id: totrans-110
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 表示空集。
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-112
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-113
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The above six sets are available as Singletons, like `S.Integers`.
  id: totrans-114
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 上述六个集合都可以作为单例集合，如 `S.Integers`。
- en: 'It is capable of most of the set operations in mathematics:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 它能够执行大多数数学中的集合运算：
- en: '`Union`'
  id: totrans-116
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Union`'
- en: ''
  id: totrans-117
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-118
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Intersection`'
  id: totrans-119
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Intersection`'
- en: ''
  id: totrans-120
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-121
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Complement`'
  id: totrans-122
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Complement`'
- en: ''
  id: totrans-123
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`SymmetricDifference`'
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SymmetricDifference`'
- en: 'The main reason for using sets as output to solvers is that it can consistently
    represent many types of solutions. For the single variable case it can represent:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集合作为解算器的输出的主要原因是它可以一致地表示许多类型的解。对于单变量情况，它可以表示：
- en: No solution (by the empty set).
  id: totrans-127
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无解（由空集）。
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Finitely many solutions (by `FiniteSet`).
  id: totrans-130
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有限多的解（通过 `FiniteSet`）。
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Infinitely many solutions, both countably and uncountably infinite solutions
    (using the `ImageSet` module).
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无限多的解，包括可数和不可数的无限多解（使用 `ImageSet` 模块）。
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Interval`'
  id: totrans-136
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Interval`'
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: There can also be bizarre solutions to equations like the set of rational numbers.
  id: totrans-139
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程的解集也可能是奇怪的，如有理数的集合。
- en: No other Python object (list, dictionary, generator, Python sets) provides the
    flexibility of mathematical sets which our sets module tries to emulate. The second
    reason to use sets is that they are close to the entities which mathematicians
    deal with and it makes it easier to reason about them. Set objects conform to
    Pythonic conventions when possible, i.e., `x in A` and `for i in A` both work
    when they can be computed. Another advantage of using objects closer to mathematical
    entities is that the user won’t have to “learn” our representation and she can
    have her expectations transferred from her mathematical experience.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 没有其他Python对象（列表、字典、生成器、Python集合）能够提供我们集合模块试图模拟的数学集的灵活性。使用集合的第二个原因是它们接近数学家处理的实体，这样更容易对它们进行推理。当可能时，集合对象遵循Pythonic约定，即
    `x in A` 和 `for i in A` 都在可以计算时起作用。使用更接近数学实体的对象的另一个优势是用户不必“学习”我们的表示，她可以从她的数学经验中传递她的期望。
- en: For the multivariate case we represent solutions as a set of points in a n-dimensional
    space and a point is represented by a `FiniteSet` of ordered tuples, which is
    a point in \(\mathbb{R}^n\) or \(\mathbb{C}^n\).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于多变量情况，我们将解表示为n维空间中的一组点集，点由有序元组的 `FiniteSet` 表示，这是 \(\mathbb{R}^n\) 或 \(\mathbb{C}^n\)
    中的点。
- en: Please note that, the general `FiniteSet` is unordered, but a `FiniteSet` with
    a tuple as its only argument becomes ordered, since a tuple is ordered. So the
    order in the tuple is mapped to a pre-defined order of variables while returning
    solutions.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一般的 `FiniteSet` 是无序的，但带有元组作为其唯一参数的 `FiniteSet` 是有序的，因为元组是有序的。因此，元组中的顺序被映射到变量的预定义顺序，而返回解决方案。
- en: 'For example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE1]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Why not use dicts as output?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不使用字典作为输出？
- en: 'Dictionary are easy to deal with programmatically but mathematically they are
    not very precise and use of them can quickly lead to inconsistency and a lot of
    confusion. For example:'
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在程序上处理字典很容易，但在数学上它们并不是非常精确的，使用它们很快会导致不一致和混乱。例如：
- en: ''
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'There are a lot of cases where we don’t know the complete solution and we may
    like to output a partial solution, consider the equation \(fg = 0\). The solution
    of this equation is the union of the solution of the following two equations:
    \(f = 0\), \(g = 0\). Let’s say that we are able to solve \(f = 0\) but solving
    \(g = 0\) isn’t supported yet. In this case we cannot represent partial solution
    of the given equation \(fg = 0\) using dicts. This problem is solved with sets
    using a `ConditionSet` object:'
  id: totrans-148
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在许多情况我们不知道完整的解决方案，我们可能希望输出一个部分解决方案，考虑方程 \(fg = 0\)。这个方程的解是以下两个方程的解的并集：\(f =
    0\)，\(g = 0\)。假设我们能解决 \(f = 0\)，但尚不支持解决 \(g = 0\)。在这种情况下，我们不能使用字典表示给定方程 \(fg =
    0\) 的部分解决方案。使用 `ConditionSet` 对象解决了这个问题。
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(sol_f \cup \{x | x ∊ \mathbb{R} ∧ g = 0\}\), where \(sol_f\) is the solution
    of the equation \(f = 0\).
  id: totrans-152
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: \(\left\{sol_f \cup \{x | x ∊ \mathbb{R} ∧ g = 0\}\right\}\)，其中 \(\left\{sol_f\right\}\)
    是方程 \(f = 0\) 的解。
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using a dict may lead to surprising results like:'
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用字典可能会导致意外的结果，比如：
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`solve(Eq(x**2, 1), x) != solve(Eq(y**2, 1), y)`'
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`solve(Eq(x**2, 1), x) != solve(Eq(y**2, 1), y)`'
- en: ''
  id: totrans-159
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-160
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-161
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Mathematically, this doesn’t make sense. Using `FiniteSet` here solves the problem.
  id: totrans-162
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在数学上，这是没有意义的。在这里使用 `FiniteSet` 解决了这个问题。
- en: ''
  id: totrans-163
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-164
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: It also cannot represent solutions for equations like \(|x| < 1\), which is
    a disk of radius 1 in the Argand Plane. This problem is solved using complex sets
    implemented as `ComplexRegion`.
  id: totrans-165
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它也不能表示像 \(|x| < 1\) 这样的方程的解，这在阿尔干平面中是半径为 1 的圆盘。使用 `ComplexRegion` 实现解决了这个问题。
- en: Input API of `solveset`
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`solveset` 的输入 API'
- en: '`solveset` has simpler input API, unlike `solve`. It takes a maximum of three
    arguments:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`solveset` 具有更简单的输入 API，不像 `solve`。它最多接受三个参数：'
- en: '`solveset(equation, variable=None, domain=S.Complexes)`'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`solveset(equation, variable=None, domain=S.Complexes)`'
- en: Equation
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 方程
- en: The equation to solve.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决的方程。
- en: Variable
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 变量
- en: The variable for which the equation is to be solved.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决的方程的变量。
- en: Domain
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 域
- en: The domain in which the equation is to be solved.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 方程的解决域。
- en: '`solveset` removes the `flags` argument of `solve`, which had made the input
    API more complicated and output API inconsistent.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`solveset` 移除了 `solve` 的 `flags` 参数，这使得输入 API 更加复杂且输出 API 不一致。'
- en: '## What is this domain argument about?'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '## 这个域参数是什么？'
- en: Solveset is designed to be independent of the assumptions on the variable being
    solved for and instead, uses the `domain` argument to decide the solver to dispatch
    the equation to, namely `solveset_real` or `solveset_complex`. It’s unlike the
    old `solve` which considers the assumption on the variable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Solveset 设计为与被解决的变量的假设无关，而是使用 `domain` 参数来决定分派给解算器的方程，即 `solveset_real` 或 `solveset_complex`。这与旧的
    `solve` 不同，后者考虑变量的假设。
- en: '[PRE2]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What are the general methods employed by solveset to solve an equation?
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解方程所采用的一般方法是什么？
- en: 'Solveset uses various methods to solve an equation, here is a brief overview
    of the methodology:'
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Solveset 使用各种方法来解决方程，以下是方法论的简要概述：
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `domain` argument is first considered to know the domain in which the user
    is interested to get the solution.
  id: totrans-182
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先考虑 `domain` 参数，以确定用户感兴趣的解决方案的域。
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-184
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If the given function is a relational (`>=`, `<=`, `>`, `<`), and the domain
    is real, then `solve_univariate_inequality` and solutions are returned. Solving
    for complex solutions of inequalities, like \(x^2 < 0\) is not yet supported.
  id: totrans-185
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定函数是一个关系式 (`>=`, `<=`, `>`, `<`)，且域为实数，则使用 `solve_univariate_inequality`
    并返回解。目前尚不支持解决复数不等式的复数解，例如 \(x^2 < 0\)。
- en: ''
  id: totrans-186
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Based on the `domain`, the equation is dispatched to one of the two functions
    `solveset_real` or `solveset_complex`, which solves the given equation in the
    complex or real domain, respectively.
  id: totrans-188
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于 `domain`，方程被分派到 `solveset_real` 或 `solveset_complex` 中的一个函数来解决，分别在复数域或实数域中解决给定的方程。
- en: ''
  id: totrans-189
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-190
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If the given expression is a product of two or more functions, like say \(gh
    = 0\), then the solution to the given equation is the Union of the solution of
    the equations \(g = 0\) and \(h = 0\), if and only if both \(g\) and \(h\) are
    finite for a finite input. So, the solution is built up recursively.
  id: totrans-191
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果给定表达式是两个或更多函数的乘积，比如说 \(gh = 0\)，那么给定方程的解是方程 \(g = 0\) 和 \(h = 0\) 的并集，当且仅当
    \(g\) 和 \(h\) 都对有限输入有限时。因此，解是递归构建的。
- en: ''
  id: totrans-192
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-193
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If the function is trigonometric or hyperbolic, the function `_solve_real_trig`
    is called, which solves it by converting it to complex exponential form.
  id: totrans-194
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果函数是三角函数或双曲函数，则调用函数 `_solve_real_trig`，通过将其转换为复数指数形式来解决它。
- en: ''
  id: totrans-195
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-196
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The function is now checked if there is any instance of a `Piecewise` expression,
    if it is, then it’s converted to explicit expression and set pairs and then solved
    recursively.
  id: totrans-197
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在检查函数是否存在 `Piecewise` 表达式的任何实例，如果有，则将其转换为显式表达式和设置对，并进行递归求解。
- en: ''
  id: totrans-198
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-199
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The respective solver now tries to invert the equation using the routines `invert_real`
    and `invert_complex`. These routines are based on the concept of mathematical
    inverse (though not exactly). It reduces the real/complex valued equation \(f(x)
    = y\) to a set of equations: \(\{g(x) = h_1(y), g(x) = h_2(y), ..., g(x) = h_n(y)
    \}\) where \(g(x)\) is a simpler function than \(f(x)\). There is some work needed
    to be done in this to find invert of more complex expressions.'
  id: totrans-200
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相应的求解器现在尝试使用例程 `invert_real` 和 `invert_complex` 反转方程。这些例程基于数学反函数的概念（虽然不完全相同）。它将实数/复数值方程
    \(f(x) = y\) 简化为一组方程：\(\{g(x) = h_1(y), g(x) = h_2(y), ..., g(x) = h_n(y) \}\)，其中
    \(g(x)\) 比 \(f(x)\) 更简单。这需要一些工作来查找更复杂表达式的反函数。
- en: ''
  id: totrans-201
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-202
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: After the invert, the equations are checked for radical or Abs (Modulus), then
    the method `_solve_radical` tries to simplify the radical, by removing it using
    techniques like squaring, cubing etc, and `_solve_abs` solves nested Modulus by
    considering the positive and negative variants, iteratively.
  id: totrans-203
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在反转之后，方程检查是否有根式或绝对值（模）部分，然后方法 `_solve_radical` 尝试通过诸如平方、立方等技术简化根式，并且 `_solve_abs`
    迭代地解决嵌套的绝对值。
- en: ''
  id: totrans-204
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-205
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If none of the above method is successful, then methods of polynomial is used
    as follows:'
  id: totrans-206
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上述方法都不成功，则使用多项式的方法如下：
- en: ''
  id: totrans-207
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-208
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The method to solve the rational function, `_solve_as_rational`, is called.
    Based on the domain, the respective poly solver `_solve_as_poly_real` or `_solve_as_poly_complex`
    is called to solve `f` as a polynomial.
  id: totrans-209
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决有理函数的方法 `_solve_as_rational` 被调用。根据定义域，分别调用相应的多项式求解器 `_solve_as_poly_real`
    或 `_solve_as_poly_complex` 来将 `f` 作为多项式求解。
- en: ''
  id: totrans-210
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-211
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The underlying method `_solve_as_poly` solves the equation using polynomial
    techniques if it’s already a polynomial equation or, with a change of variables,
    can be made so.
  id: totrans-212
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 底层方法 `_solve_as_poly` 使用多项式技术解方程，如果它已经是多项式方程或者可以通过变量变换变成多项式方程。
- en: ''
  id: totrans-213
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-214
  prefs:
  - PREF_BQ
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The final solution set returned by `solveset` is the intersection of the set
    of solutions found above and the input domain.
  id: totrans-215
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`solveset` 返回的最终解集是上述解集和输入定义域的交集。'
- en: How do we manipulate and return an infinite solution?
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作并返回无限解？
- en: 'In the real domain, we use our `ImageSet` class in the sets module to return
    infinite solutions. `ImageSet` is an image of a set under a mathematical function.
    For example, to represent the solution of the equation \(\sin{(x)} = 0\), we can
    use the `ImageSet` as:'
  id: totrans-217
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在实数域中，我们使用集合模块中的 `ImageSet` 类返回无限解。`ImageSet` 是数学函数下的一个集合的图像。例如，要表示方程 \(\sin{(x)}
    = 0\) 的解，我们可以使用 `ImageSet` 如下：
- en: ''
  id: totrans-218
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-219
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-220
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-221
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: ''
  id: totrans-222
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-223
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-224
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Where `n` is a dummy variable. It is basically the image of the set of integers
    under the function \(2\pi n\).
  id: totrans-225
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里 `n` 是一个虚拟变量。基本上是整数集合在函数 \(2\pi n\) 下的图像。
- en: ''
  id: totrans-226
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-227
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the complex domain, we use complex sets, which are implemented as the `ComplexRegion`
    class in the sets module, to represent infinite solution in the Argand plane.
    For example to represent the solution of the equation \(|z| = 1\), which is a
    unit circle, we can use the `ComplexRegion` as:'
  id: totrans-228
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在复数域中，我们使用复数集合，它们在集合模块中实现为 `ComplexRegion` 类，用来表示阿格朗平面中的无限解。例如，要表示方程 \(|z| =
    1\) 的解，即单位圆，我们可以使用 `ComplexRegion` 如下：
- en: ''
  id: totrans-229
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-230
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-231
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-232
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: ''
  id: totrans-233
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-234
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-235
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Where the `FiniteSet` in the `ProductSet` is the range of the value of \(r\),
    which is the radius of the circle and the `Interval` is the range of \(\theta\),
    the angle from the \(x\) axis representing a unit circle in the Argand plane.
  id: totrans-236
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`FiniteSet` 在 `ProductSet` 中是 \(r\) 的值域，即圆的半径，而 `Interval` 是 \(\theta\) 的范围，表示阿格朗平面中单位圆上的角度。'
- en: ''
  id: totrans-237
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-238
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-239
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note: We also have non-polar form notation for representing solution in rectangular
    form. For example, to represent first two quadrants in the Argand plane, we can
    write the `ComplexRegion` as:'
  id: totrans-240
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：我们还有用于以直角坐标形式表示解的非极坐标形式符号。例如，在阿格朗平面的前两象限中表示 `ComplexRegion`，我们可以写成：
- en: ''
  id: totrans-241
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-242
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-243
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-244
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ''
  id: totrans-245
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-246
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-247
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: where the Intervals are the range of \(x\) and \(y\) for the set of complex
    numbers \(x + iy\).
  id: totrans-248
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中区间是复数集合 \(x + iy\) 的 \(x\) 和 \(y\) 的范围。
- en: How does `solveset` ensure that it is not returning any wrong solution?
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`solveset` 如何确保不返回任何错误的解？'
- en: 'Solvers in a Computer Algebra System are based on heuristic algorithms, so
    it’s usually very hard to ensure 100% percent correctness, in every possible case.
    However there are still a lot of cases where we can ensure correctness. Solveset
    tries to verify correctness wherever it can. For example:'
  id: totrans-250
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 计算代数系统中的求解器基于启发式算法，因此通常很难确保在每种可能情况下都能达到100%的正确性。然而，在许多情况下，我们仍然可以确保正确性。`Solveset`
    尝试在可能的情况下验证正确性。例如：
- en: ''
  id: totrans-251
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Consider the equation \(|x| = n\). A naive method to solve this equation would
    return `{-n, n}` as its solution, which is not correct since `{-n, n}` can be
    its solution if and only if `n` is positive. Solveset returns this information
    as well to ensure correctness.
  id: totrans-252
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 考虑方程 \(|x| = n\)。解这个方程的一个天真的方法会返回 `{-n, n}` 作为其解，这是不正确的，因为只有当 `n` 是正数时，`{-n,
    n}` 才可能是其解。Solveset 也会返回这些信息以确保正确性。
- en: ''
  id: totrans-253
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-254
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE6]'
- en: ''
  id: totrans-255
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Though, there still a lot of work needs to be done in this regard.
  id: totrans-256
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管在这方面仍需大量工作。
- en: Search based solver and step-by-step solution
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于搜索的求解器和逐步解决方案
- en: 'Note: This is under Development.'
  id: totrans-258
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 注意：这还在开发中。
- en: ''
  id: totrans-259
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: After the introduction of [`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet
    "sympy.sets.conditionset.ConditionSet"), the solving of equations can be seen
    as set transformations. Here is an abstract view of the things we can do to solve
    equations.
  id: totrans-260
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 引入 [`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet "sympy.sets.conditionset.ConditionSet")
    后，解方程可以看作是集合转换。以下是我们可以用来解方程的抽象视图。
- en: ''
  id: totrans-261
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Apply various set transformations on the given set.
  id: totrans-262
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在给定集合上应用各种集合转换。
- en: ''
  id: totrans-263
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-264
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Define a metric of the usability of solutions, or a notion of some solutions
    being better than others.
  id: totrans-265
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义解的可用性度量，或者某些解比其他解更好的概念。
- en: ''
  id: totrans-266
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-267
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Different transformations would be the nodes of a tree.
  id: totrans-268
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的转换可以是树的节点。
- en: ''
  id: totrans-269
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-270
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Suitable searching techniques could be applied to get the best solution.
  id: totrans-271
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以应用适当的搜索技术来获得最佳解决方案。
- en: ''
  id: totrans-272
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-273
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-274
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ConditionSet` gives us the ability to represent unevaluated equations and
    inequalities in forms like \(\{x|f(x)=0; x \in S\}\) and \(\{x|f(x)>0; x \in S\}\)
    but a more powerful thing about `ConditionSet` is that it allows us to write the
    intermediate steps as set to set transformation. Some of the transformations are:'
  id: totrans-275
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ConditionSet` 给我们提供了以形如 \(\{x|f(x)=0; x \in S\}\) 和 \(\{x|f(x)>0; x \in S\}\)
    的形式表示未评估的方程和不等式的能力，但 `ConditionSet` 更强大的地方在于它允许我们将中间步骤写为集合到集合的转换。一些转换包括：'
- en: ''
  id: totrans-276
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Composition: \(\{x|f(g(x))=0;x \in S\} \Rightarrow \{x|g(x)=y; x \in S, y \in
    \{z|f(z)=0; z \in S\}\}\)'
  id: totrans-277
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合：\(\{x|f(g(x))=0;x \in S\} \Rightarrow \{x|g(x)=y; x \in S, y \in \{z|f(z)=0;
    z \in S\}\}\)
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Polynomial Solver: \(\{x | P(x) = 0;x \in S\} \Rightarrow \{x_1,x_2, ... ,x_n\}
    \cap S\),'
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式求解器：\(\{x | P(x) = 0;x \in S\} \Rightarrow \{x_1,x_2, ... ,x_n\} \cap S\),
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-282
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-283
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: where \(x_i\) are roots of \(P(x)\).
  id: totrans-286
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 \(x_i\) 是 \(P(x)\) 的根。
- en: ''
  id: totrans-287
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-288
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-289
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-290
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Invert solver: \(\{x|f(x)=0;x \in S\} \Rightarrow \{g(0)| \text{ all g such
    that } f(g(x)) = x\}\)'
  id: totrans-291
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转求解器：\(\{x|f(x)=0;x \in S\} \Rightarrow \{g(0)| \text{ 所有的 } g \text{ 使得 }
    f(g(x)) = x\}\)
- en: ''
  id: totrans-292
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-293
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'logcombine: \(\{x| \log(f(x)) + \log(g(x));x \in S\}\)'
  id: totrans-294
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: logcombine：\(\{x| \log(f(x)) + \log(g(x));x \in S\}\)
- en: ''
  id: totrans-295
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-296
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-297
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-298
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-299
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(\Rightarrow \{x| \log(f(x).g(x)); x \in S\} \text{ if } f(x) > 0 \text{ and
    } g(x) > 0\) \(\Rightarrow \{x| \log(f(x)) + \log(g(x));x \in S\} \text{ otherwise}\)
  id: totrans-300
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: \(\Rightarrow \{x| \log(f(x).g(x)); x \in S\} \text{ 如果 } f(x) > 0 \text{ 和
    } g(x) > 0\) \(\Rightarrow \{x| \log(f(x)) + \log(g(x));x \in S\} \text{ 否则}\)
- en: ''
  id: totrans-301
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-302
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-303
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-304
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'product solve: \(\{x|f(x)g(x)=0; x \in S\}\)'
  id: totrans-305
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 产品求解：\(\{x|f(x)g(x)=0; x \in S\}\)
- en: ''
  id: totrans-306
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-307
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-308
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-309
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: \(\Rightarrow \{x|f(x)=0; x \in S\} U \{x|g(x)=0; x \in S\}\) \(\text{ given
    } f(x) \text{ and } g(x) \text{ are bounded.}\) \(\Rightarrow \{x|f(x)g(x)=0;
    x \in S\}, \text{ otherwise}\)
  id: totrans-311
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
  zh: \(\Rightarrow \{x|f(x)=0; x \in S\} \cup \{x|g(x)=0; x \in S\}\) \(\text{ 给定
    } f(x) \text{ 和 } g(x) \text{ 是有界的。}\) \(\Rightarrow \{x|f(x)g(x)=0; x \in S\},
    \text{ 否则}\)
- en: ''
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Since the output type is same as the input type any composition of these transformations
    is also a valid transformation. And our aim is to find the right sequence of compositions
    (given the atoms) which transforms the given condition set to a set which is not
    a condition set i.e., FiniteSet, Interval, Set of Integers and their Union, Intersection,
    Complement or ImageSet. We can assign a cost function to each set, such that,
    the more desirable that form of set is to us, the less the value of the cost function.
    This way our problem is now reduced to finding the path from the initial ConditionSet
    to the lowest valued set on a graph where the atomic transformations forms the
    edges.
  id: totrans-317
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 由于输出类型与输入类型相同，这些变换的任何组合也是有效的变换。我们的目标是找到变换序列（给定原子），将给定的条件集转换为非条件集，如 FiniteSet、Interval、整数集及其并、交、补或图像集。我们可以为每个集合分配一个成本函数，使得我们对这种形式的集合越喜欢，成本函数的值就越小。这样，我们的问题现在被简化为在图中找到从初始
    ConditionSet 到值最低的集合的路径，其中原子变换形成边。
- en: How do we deal with cases where only some of the solutions are known?
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何处理仅部分解已知的情况？
- en: Creating a universal equation solver, which can solve each and every equation
    we encounter in mathematics is an ideal case for solvers in a Computer Algebra
    System. When cases which are not solved or can only be solved incompletely, a
    `ConditionSet` is used and acts as an unevaluated solveset object.
  id: totrans-319
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 创建一个通用方程求解器，它可以解决我们在数学中遇到的每一个方程，是计算代数系统中的理想情况。对于无法解决或只能部分解决的情况，使用 `ConditionSet`
    并充当未评估的 solveset 对象。
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that, mathematically, finding a complete set of solutions for an equation
    is undecidable. See [Richardson’s theorem](https://en.wikipedia.org/wiki/Richardson%27s_theorem).
  id: totrans-321
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请注意，在数学上，找到方程的完全解集是不可判定的。参见 [Richardson's theorem](https://en.wikipedia.org/wiki/Richardson%27s_theorem)。
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`ConditionSet` is basically a Set of elements which satisfy a given condition.
    For example, to represent the solutions of the equation in the real domain:'
  id: totrans-323
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`ConditionSet` 基本上是满足给定条件的元素集合。例如，要表示实域中方程的解：'
- en: ''
  id: totrans-324
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \[(x^2 - 4)(\sin(x) + x)\]
  id: totrans-325
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \[(x^2 - 4)(\sin(x) + x)\]
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'We can represent it as:'
  id: totrans-327
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我们可以表示为：
- en: ''
  id: totrans-328
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \(\{-2, 2\} ∪ \{x | x \in \mathbb{R} ∧ x + \sin(x) = 0\}\)
  id: totrans-329
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \(\{-2, 2\} ∪ \{x | x \in \mathbb{R} ∧ x + \sin(x) = 0\}\)
- en: What is the plan for solve and solveset?
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对于 solve 和 solveset 的计划是什么？
- en: There are still a few things `solveset` can’t do, which `solve` can, such as
    solving nonlinear multivariate & LambertW type equations. Hence, it’s not yet
    a perfect replacement for `solve`. As the algorithms in `solveset` mature, `solveset`
    may be able to be used within `solve` to replace some of its algorithms.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '`solveset` 仍然不能做到的事情有些，而 `solve` 可以，比如解非线性多元和 LambertW 类型的方程。因此，它还不能完全替代 `solve`。随着
    `solveset` 中的算法成熟，`solveset` 可能能够在 `solve` 中替换一些算法。'
- en: How are symbolic parameters handled in solveset?
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何处理解集中的符号参数？
- en: 'Solveset is in its initial phase of development, so the symbolic parameters
    aren’t handled well for all the cases, but some work has been done in this regard
    to depict our ideology towards symbolic parameters. As an example, consider the
    solving of \(|x| = n\) for real \(x\), where \(n\) is a symbolic parameter. Solveset
    returns the value of \(x\) considering the domain of the symbolic parameter \(n\)
    as well:'
  id: totrans-333
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Solveset 处于初步开发阶段，因此并非所有情况下符号参数处理得当，但在这方面已经做了一些工作来表达我们对符号参数的思想。例如，考虑对于实数 \(x\)
    解 \(|x| = n\)，其中 \(n\) 是符号参数。Solveset 根据符号参数 \(n\) 的定义域返回 \(x\) 的值：
- en: ''
  id: totrans-334
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: \[([0, \infty) \cap \{n\}) \cup ((-\infty, 0] \cap \{-n\}).\]
  id: totrans-335
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: \([0, \infty) \cap \{n\}) \cup ((-\infty, 0] \cap \{-n\}).\]
- en: ''
  id: totrans-336
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This simply means \(n\) is the solution only when it belongs to the `Interval`
    \([0, \infty)\) and \(-n\) is the solution only when \(-n\) belongs to the `Interval`
    \((- \infty, 0]\).
  id: totrans-337
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这简单地意味着当 \(n\) 属于 `Interval` \([0, \infty)\) 时，\(n\) 是解，当 \(-n\) 属于 `Interval`
    \((- \infty, 0]\) 时，\(-n\) 是解。
- en: ''
  id: totrans-338
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are other cases to address too, like solving \(2^x + (a - 2)\) for \(x\)
    where \(a\) is a symbolic parameter. As of now, It returns the solution as an
    intersection with \(\mathbb{R}\), which is trivial, as it doesn’t reveal the domain
    of \(a\) in the solution.
  id: totrans-339
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 还有其他情况需要处理，例如解 \(2^x + (a - 2)\) 对 \(x\) 的方程，其中 \(a\) 是符号参数。目前，它返回解作为与 \(\mathbb{R}\)
    的交集，这是微不足道的，因为它不反映 \(a\) 在解中的定义域。
- en: ''
  id: totrans-340
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Recently, we have also implemented a function to find the domain of the expression
    in a FiniteSet (Intersection with the interval) in which it is not-empty. It is
    a useful addition for dealing with symbolic parameters. For example:'
  id: totrans-341
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 最近，我们还实现了一个在表达式的有限集（与区间的交集）中找到其非空域的函数。这对处理符号参数很有用。例如：
- en: ''
  id: totrans-342
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-343
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE7]'
- en: References
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考
- en: Solveset Module Reference
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Solveset 模块参考
- en: 'Use [`solveset()`](#sympy.solvers.solveset.solveset "sympy.solvers.solveset.solveset")
    to solve equations or expressions (assumed to be equal to 0) for a single variable.
    Solving an equation like \(x^2 == 1\) can be done as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`solveset()`](#sympy.solvers.solveset.solveset "sympy.solvers.solveset.solveset")
    解方程或表达式（假定等于 0）的单变量。可以如下解方程 \(x^2 == 1\)：
- en: '[PRE8]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or one may manually rewrite the equation as an expression equal to 0:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 或者可以手动将方程重写为等于 0 的表达式：
- en: '[PRE9]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The first argument for [`solveset()`](#sympy.solvers.solveset.solveset "sympy.solvers.solveset.solveset")
    is an expression (equal to zero) or an equation and the second argument is the
    symbol that we want to solve the equation for.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[`solveset()`](#sympy.solvers.solveset.solveset "sympy.solvers.solveset.solveset")
    的第一个参数是一个表达式（等于零）或一个方程，第二个参数是要解方程的符号。'
- en: '[PRE10]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Solves a given inequality or equation with set as output
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 解给定的不等式或方程，输出为集合
- en: 'Parameters:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**f** : Expr or a relational.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**f**：表达式或关系。'
- en: The target equation or inequality
  id: totrans-355
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 目标方程或不等式
- en: '**symbol** : Symbol'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '**symbol**：符号'
- en: The variable for which the equation is solved
  id: totrans-357
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要解方程的变量
- en: '**domain** : Set'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**domain**：集合'
- en: The domain over which the equation is solved
  id: totrans-359
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 方程的解决域
- en: 'Returns:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: Set
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 集合
- en: A set of values for \(symbol\) for which \(f\) is True or is equal to zero.
    An [`EmptySet`](../sets.html#sympy.sets.sets.EmptySet "sympy.sets.sets.EmptySet")
    is returned if \(f\) is False or nonzero. A [`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet
    "sympy.sets.conditionset.ConditionSet") is returned as unsolved object if algorithms
    to evaluate complete solution are not yet implemented.
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个值的集合 \(symbol\)，其中 \(f\) 为 True 或等于零。如果 \(f\) 为 False 或非零，则返回 [`EmptySet`](../sets.html#sympy.sets.sets.EmptySet
    "sympy.sets.sets.EmptySet")。如果尚未实现评估完整解决方案的算法，则返回 [`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet
    "sympy.sets.conditionset.ConditionSet") 作为未解决的对象。
- en: '`solveset` claims to be complete in the solution set that it returns.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '`solveset` 声称其返回的解集是完整的。'
- en: 'Raises:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**NotImplementedError**'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '**NotImplementedError**'
- en: The algorithms to solve inequalities in complex domain are not yet implemented.
  id: totrans-366
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尚未实现在复杂域中解决不等式的算法。
- en: '**ValueError**'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '**ValueError**'
- en: The input is not valid.
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入无效。
- en: '**RuntimeError**'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '**RuntimeError**'
- en: It is a bug, please report to the github issue tracker.
  id: totrans-370
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这是一个错误，请报告给 GitHub 问题跟踪器。
- en: Notes
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注释
- en: Python interprets 0 and 1 as False and True, respectively, but in this function
    they refer to solutions of an expression. So 0 and 1 return the domain and EmptySet,
    respectively, while True and False return the opposite (as they are assumed to
    be solutions of relational expressions).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: Python 将 0 和 1 解释为 False 和 True，但在此函数中，它们分别指的是表达式的解。因此，0 和 1 分别返回域和 EmptySet，而
    True 和 False 返回相反的值（因为它们被假定为关系表达式的解）。
- en: Examples
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE11]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The default domain is complex. Not specifying a domain will lead to the solving
    of the equation in the complex domain (and this is not affected by the assumptions
    on the symbol):'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认域为复数域。不指定域将导致在复数域中解方程（这与符号上的假设无关）：
- en: '[PRE12]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you want to use `solveset` to solve the equation in the real domain, provide
    a real domain. (Using `solveset_real` does this automatically.)
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要使用 `solveset` 在实数域中解决方程，请提供一个实数域。（使用 `solveset_real` 可自动完成此操作。）
- en: '[PRE14]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The solution is unaffected by assumptions on the symbol:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案不受符号假设的影响：
- en: '[PRE15]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When a [`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet "sympy.sets.conditionset.ConditionSet")
    is returned, symbols with assumptions that would alter the set are replaced with
    more generic symbols:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 当返回一个 [`ConditionSet`](../sets.html#sympy.sets.conditionset.ConditionSet "sympy.sets.conditionset.ConditionSet")
    时，将具有可能改变集合的假设的符号替换为更通用的符号：
- en: '[PRE16]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Inequalities can be solved over the real domain only. Use of a complex domain
    leads to a NotImplementedError.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能在实数域上解决不等式。使用复数域会导致 NotImplementedError。
- en: '[PRE17]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: See also
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`solveset_real`](#sympy.solvers.solveset.solveset_real "sympy.solvers.solveset.solveset_real")'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[`solveset_real`](#sympy.solvers.solveset.solveset_real "sympy.solvers.solveset.solveset_real")'
- en: solver for real domain
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 实数域求解器
- en: '[`solveset_complex`](#sympy.solvers.solveset.solveset_complex "sympy.solvers.solveset.solveset_complex")'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[`solveset_complex`](#sympy.solvers.solveset.solveset_complex "sympy.solvers.solveset.solveset_complex")'
- en: solver for complex domain
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 用于复数域的求解器
- en: '[PRE18]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Inverts a real-valued function. Same as [`invert_complex()`](#sympy.solvers.solveset.invert_complex
    "sympy.solvers.solveset.invert_complex"), but sets the domain to `S.Reals` before
    inverting.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 反转一个实值函数。与 [`invert_complex()`](#sympy.solvers.solveset.invert_complex "sympy.solvers.solveset.invert_complex")
    相同，但在反转之前将域设置为 `S.Reals`。
- en: '[PRE21]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Reduce the complex valued equation \(f(x) = y\) to a set of equations
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 将复值方程 \(f(x) = y\) 简化为一组方程
- en: \[\left\{g(x) = h_1(y),\ g(x) = h_2(y),\ \dots,\ g(x) = h_n(y) \right\}\]
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: \[\left\{g(x) = h_1(y),\ g(x) = h_2(y),\ \dots,\ g(x) = h_n(y) \right\}\]
- en: where \(g(x)\) is a simpler function than \(f(x)\). The return value is a tuple
    \((g(x), \mathrm{set}_h)\), where \(g(x)\) is a function of \(x\) and \(\mathrm{set}_h\)
    is the set of function \(\left\{h_1(y), h_2(y), \dots, h_n(y)\right\}\). Here,
    \(y\) is not necessarily a symbol.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 \(g(x)\) 是比 \(f(x)\) 更简单的函数。返回值是一个元组 \((g(x), \mathrm{set}_h)\)，其中 \(g(x)\)
    是 \(x\) 的函数，\(\mathrm{set}_h\) 是函数集合 \(\left\{h_1(y), h_2(y), \dots, h_n(y)\right\}\)。这里，\(y\)
    不一定是一个符号。
- en: '\(\mathrm{set}_h\) contains the functions, along with the information about
    the domain in which they are valid, through set operations. For instance, if \(y
    = |x| - n\) is inverted in the real domain, then \(\mathrm{set}_h\) is not simply
    \(\{-n, n\}\) as the nature of \(n\) is unknown; rather, it is:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: \(\mathrm{set}_h\) 包含函数及其在有效域内的信息，通过集合运算获得。例如，如果在实数域中反转 \(y = |x| - n\)，那么 \(\mathrm{set}_h\)
    不仅仅是 \(\{-n, n\}\)，因为 \(n\) 的性质未知；而是：
- en: $$ left(left[0, inftyright) cap left{nright}right) cup
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: $$ left(left[0, \infty\right) \cap \left\{n\right\}\right) \cup $$
- en: left(left(-infty, 0right] cap left{- nright}right)$$
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: $$ left(-\infty, 0\right] \cap \left\{- n\right\}$$
- en: By default, the complex domain is used which means that inverting even seemingly
    simple functions like \(\exp(x)\) will give very different results from those
    obtained in the real domain. (In the case of \(\exp(x)\), the inversion via \(\log\)
    is multi-valued in the complex domain, having infinitely many branches.)
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，使用复数域，这意味着即使是看似简单的函数如 \(\exp(x)\)，其在复数域中通过 \(\log\) 的反演结果与在实数域中获得的结果也大不相同。（对于
    \(\exp(x)\)，在复数域中通过 \(\log\) 的反演是多值的，具有无限多个分支。）
- en: If you are working with real values only (or you are not sure which function
    to use) you should probably set the domain to `S.Reals` (or use `invert_real`
    which does that automatically).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只处理实数值（或者不确定使用哪个函数），你可能应该将域设置为 `S.Reals`（或使用自动执行此操作的 `invert_real`）。
- en: Examples
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE22]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When does exp(x) == y?
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 何时 exp(x) == y？
- en: '[PRE23]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When does exp(x) == 1?
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 何时 exp(x) == 1？
- en: '[PRE24]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`invert_real`](#sympy.solvers.solveset.invert_real "sympy.solvers.solveset.invert_real"),
    [`invert_complex`](#sympy.solvers.solveset.invert_complex "sympy.solvers.solveset.invert_complex")'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[`invert_real`](#sympy.solvers.solveset.invert_real "sympy.solvers.solveset.invert_real"),
    [`invert_complex`](#sympy.solvers.solveset.invert_complex "sympy.solvers.solveset.invert_complex")'
- en: '[PRE25]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Returns False if point p is infinite or any subexpression of f is infinite or
    becomes so after replacing symbol with p. If none of these conditions is met then
    True will be returned.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点 p 是无限的，或者 f 的任何子表达式是无限的，或者在用 p 替换符号后变为无限，则返回 False。如果没有满足这些条件的情况，则返回 True。
- en: Examples
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE26]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The function relies on the assumption that the original form of the equation
    has not been changed by automatic simplification.
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数依赖于假设，即方程的原始形式未被自动简化改变。
- en: '[PRE27]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To deal with automatic evaluations use evaluate=False:'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要处理自动评估，请使用 evaluate=False：
- en: '[PRE28]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Solves an equation using solveset and returns the solution in accordance with
    the \(solve\) output API.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 solveset 解方程并根据 \(solve\) 输出 API 返回解。
- en: 'Returns:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: We classify the output based on the type of solution returned by \(solveset\).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们根据 \(solveset\) 返回的解类型对输出进行分类。
- en: 'Raises:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出：
- en: '**NotImplementedError**'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '**未实现错误**'
- en: A ConditionSet is the input.
  id: totrans-426
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: ConditionSet 是输入。
- en: Solution | Output
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案 | 输出
- en: FiniteSet | list
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: FiniteSet | 列表
- en: ImageSet, | list (if \(f\) is periodic) Union |
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: ImageSet，| 列表（如果 \(f\) 是周期的）并集 |
- en: Union | list (with FiniteSet)
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 并集 | 列表（包含 FiniteSet）
- en: EmptySet | empty list
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: EmptySet | 空列表
- en: Others | None
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 其他 | 无
- en: Examples
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE30]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Converts a given System of Equations into Matrix form. Here \(equations\) must
    be a linear system of equations in \(symbols\). Element `M[i, j]` corresponds
    to the coefficient of the jth symbol in the ith equation.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 将给定的方程组转换为矩阵形式。这里的 \(equations\) 必须是符号 \(symbols\) 的线性方程组。元素 `M[i, j]` 对应于第
    \(i\) 个方程中第 \(j\) 个符号的系数。
- en: 'The Matrix form corresponds to the augmented matrix form. For example:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵形式对应于增广矩阵形式。例如：
- en: \[4x + 2y + 3z = 1\]\[3x + y + z = -6\]\[2x + 4y + 9z = 2\]
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: \[4x + 2y + 3z = 1\]\[3x + y + z = -6\]\[2x + 4y + 9z = 2\]
- en: 'This system will return \(A\) and \(b\) as:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 此系统将返回A和b为：
- en: $$ A = left[begin{array}{ccc}
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: $$ A = left[begin{array}{ccc}
- en: 4 & 2 & 3 \ 3 & 1 & 1 \ 2 & 4 & 9 end{array}right] b = left[begin{array}{c}
    1 \ -6 \ 2 end{array}right] $$
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 4 & 2 & 3 \ 3 & 1 & 1 \ 2 & 4 & 9 end{array}right] b = left[begin{array}{c}
    1 \ -6 \ 2 end{array}right] $$
- en: The only simplification performed is to convert `Eq(a, b)` \(\Rightarrow a -
    b\).
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 执行的唯一简化是将`Eq(a, b)` \(\Rightarrow a - b\)转换。
- en: 'Raises:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 'Raises:'
- en: '**NonlinearError**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**非线性错误**'
- en: The equations contain a nonlinear term.
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 方程包含一个非线性项。
- en: '**ValueError**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值错误**'
- en: The symbols are not given or are not unique.
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 符号未给出或不唯一。
- en: Examples
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE33]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The coefficients (numerical or symbolic) of the symbols will be returned as
    matrices:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 符号的系数（数字或符号）将作为矩阵返回：
- en: '[PRE34]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This routine does not simplify expressions and will raise an error if nonlinearity
    is encountered:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 此例程不会简化表达式，并且如果遇到非线性，则会引发错误：
- en: '[PRE35]'
  id: totrans-454
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE35]'
- en: ''
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Simplifying these equations will discard the removable singularity in the first
    and reveal the linear structure of the second:'
  id: totrans-456
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 简化这些方程将丢弃第一个可去的奇异性，并显示第二个的线性结构：
- en: ''
  id: totrans-457
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-458
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE36]'
- en: ''
  id: totrans-459
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Any such simplification needed to eliminate nonlinear terms must be done *before*
    calling this routine.
  id: totrans-460
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 必须在调用此例程之前执行任何这样的简化，以消除非线性项。
- en: '[PRE37]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Solve system of \(N\) linear equations with \(M\) variables; both underdetermined
    and overdetermined systems are supported. The possible number of solutions is
    zero, one or infinite. Zero solutions throws a ValueError, whereas infinite solutions
    are represented parametrically in terms of the given symbols. For unique solution
    a [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")
    of ordered tuples is returned.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 解N个线性方程组，M个变量；支持欠定和超定系统。可能的解数为零、一或无限。零解引发ValueError，而无限解以给定符号的参数形式表示。对于唯一解，返回有序元组的[`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet
    "sympy.sets.sets.FiniteSet")。
- en: 'All standard input formats are supported: For the given set of equations, the
    respective input types are given below:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 支持所有标准输入格式：对于给定的方程组，给出了相应的输入类型如下：
- en: \[3x + 2y - z = 1\]\[2x - 2y + 4z = -2\]\[2x - y + 2z = 0\]
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: \[3x + 2y - z = 1\]\[2x - 2y + 4z = -2\]\[2x - y + 2z = 0\]
- en: 'Augmented matrix form, `system` given below:'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增广矩阵形式，`system`如下所示：
- en: $$ text{system} = left[{array}{cccc}
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: $$ text{system} = left[{array}{cccc}
- en: 3 & 2 & -1 & 1\ 2 & -2 & 4 & -2\ 2 & -1 & 2 & 0 end{array}right] $$
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 3 & 2 & -1 & 1\ 2 & -2 & 4 & -2\ 2 & -1 & 2 & 0 end{array}right] $$
- en: '[PRE38]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: List of equations form
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方程列表形式
- en: '[PRE39]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Input \(A\) and \(b\) in matrix form (from \(Ax = b\)) are given as:'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入的A和b以矩阵形式（从Ax = b）给出：
- en: $$ A = left[begin{array}{ccc}
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: $$ A = left[begin{array}{ccc}
- en: 3 & 2 & -1 \ 2 & -2 & 4 \ 2 & -1 & 2 end{array}right] b = left[begin{array}{c}
    1 \ -2 \ 0 end{array}right] $$
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 3 & 2 & -1 \ 2 & -2 & 4 \ 2 & -1 & 2 end{array}right] b = left[begin{array}{c}
    1 \ -2 \ 0 end{array}right] $$
- en: '[PRE40]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Symbols can always be passed but are actually only needed when 1) a system of
    equations is being passed and 2) the system is passed as an underdetermined matrix
    and one wants to control the name of the free variables in the result. An error
    is raised if no symbols are used for case 1, but if no symbols are provided for
    case 2, internally generated symbols will be provided. When providing symbols
    for case 2, there should be at least as many symbols are there are columns in
    matrix A.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 符号始终可以传递，但实际上只有在以下两种情况下才需要：1）传递一个方程组并且2）将系统作为欠定矩阵传递，并且希望控制结果中自由变量的名称。如果对于情况1没有使用符号，则会引发错误，但如果对于情况2没有提供符号，则会提供内部生成的符号。在为情况2提供符号时，矩阵A中的列数至少应与符号相同。
- en: The algorithm used here is Gauss-Jordan elimination, which results, after elimination,
    in a row echelon form matrix.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的算法是高斯-约当消元法，消元后得到行梯形形式的矩阵。
- en: 'Returns:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: A FiniteSet containing an ordered tuple of values for the
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 包含有序元组值的有限集FiniteSet
- en: unknowns for which the \(system\) has a solution. (Wrapping
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 未知数为\(system\)具有解决方案。（包裹
- en: the tuple in FiniteSet is used to maintain a consistent
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: FiniteSet中的元组用于维护一致的
- en: output format throughout solveset.)
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案格式始终贯穿solveset。
- en: Returns EmptySet, if the linear system is inconsistent.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果线性系统不一致，则返回EmptySet。
- en: 'Raises:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 'Raises:'
- en: '**ValueError**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**数值错误**'
- en: The input is not valid. The symbols are not given.
  id: totrans-485
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入无效。符号未给出。
- en: Examples
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE41]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Parametric Solution: In case the system is underdetermined, the function will
    return a parametric solution in terms of the given symbols. Those that are free
    will be returned unchanged. e.g. in the system below, \(z\) is returned as the
    solution for variable z; it can take on any value.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数化解：如果系统欠定，函数将返回以给定符号为参数的参数解。自由的符号将保持不变。例如，在下面的系统中，\(z\)被返回为变量\(z\)的解；它可以取任何值。
- en: '[PRE42]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'If no symbols are given, internally generated symbols will be used. The `tau0`
    in the third position indicates (as before) that the third variable – whatever
    it is named – can take on any value:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有给出符号，则将使用内部生成的符号。第三位置的`tau0`表示（与之前一样），第三个变量 - 无论其名称如何 - 可以取任何值：
- en: '[PRE43]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: List of equations as input
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为输入的方程组列表
- en: '[PRE44]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Augmented matrix as input
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为输入的增广矩阵
- en: '[PRE45]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Solve for symbolic coefficients
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为符号系数求解
- en: '[PRE46]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: A degenerate system returns solution as set of given symbols.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 退化系统返回给定符号的解集。
- en: '[PRE47]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For an empty system linsolve returns empty set
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于空系统，linsolve返回空集
- en: '[PRE48]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: An error is raised if any nonlinearity is detected, even if it could be removed
    with expansion
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果检测到任何非线性，则会引发错误，即使可以通过扩展删除
- en: '[PRE49]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Solve system of \(N\) nonlinear equations with \(M\) variables, which means
    both under and overdetermined systems are supported. Positive dimensional system
    is also supported (A system with infinitely many solutions is said to be positive-dimensional).
    In a positive dimensional system the solution will be dependent on at least one
    symbol. Returns both real solution and complex solution (if they exist).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 解\(N\)个非线性方程与\(M\)个变量的系统，这意味着支持欠定和超定系统。也支持正维系统（系统具有无限多个解被称为正维系统）。在正维系统中，解将依赖于至少一个符号。返回实数解和复数解（如果存在）。
- en: 'Parameters:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**system** : list of equations'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '**系统**：方程组列表'
- en: The target system of equations
  id: totrans-510
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 方程组的目标系统
- en: '**symbols** : list of Symbols'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '**symbols**：符号列表'
- en: symbols should be given as a sequence eg. list
  id: totrans-512
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 符号应作为序列给出，例如列表
- en: 'Returns:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: A [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")
    of ordered tuple of values of \(symbols\) for which the \(system\)
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")的有序元组，其值为\(symbols\)，以便\(system\)
- en: has solution. Order of values in the tuple is same as symbols present in
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 有解。元组中的值顺序与符号出现的顺序相同
- en: the parameter \(symbols\).
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 参数\(symbols\)。
- en: Please note that general [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet
    "sympy.sets.sets.FiniteSet") is unordered, the solution
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，一般的[`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")是无序的，解决方案
- en: returned here is not simply a [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet
    "sympy.sets.sets.FiniteSet") of solutions, rather it
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 这里返回的解不仅仅是一个[`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")的解集，而是
- en: is a [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")
    of ordered tuple, i.e. the first and only
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个[`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")的有序元组，即第一个也是唯一的
- en: argument to [`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")
    is a tuple of solutions, which is
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '[`FiniteSet`](../sets.html#sympy.sets.sets.FiniteSet "sympy.sets.sets.FiniteSet")的参数是一个解的元组，即'
- en: ordered, and, hence ,the returned solution is ordered.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 有序，因此，返回的解决方案是有序的。
- en: Also note that solution could also have been returned as an ordered tuple,
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，解也可以作为有序元组返回，
- en: FiniteSet is just a wrapper `{}` around the tuple. It has no other
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: FiniteSet只是元组周围的包装 `{}`。没有其他
- en: significance except for the fact it is just used to maintain a consistent
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 除了维持一致性外，没有其他重要性
- en: output format throughout the solveset.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案的输出格式始终保持在解集中。
- en: For the given set of equations, the respective input types
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的方程组，各自的输入类型
- en: 'are given below:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 给定如下：
- en: \[xy - 1 = 0\]\[4x^2 + y^2 - 5 = 0\]
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: \[xy - 1 = 0\]\[4x^2 + y^2 - 5 = 0\]
- en: '[PRE53]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Raises:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出：
- en: '**ValueError**'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '**ValueError**'
- en: The input is not valid. The symbols are not given.
  id: totrans-532
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入无效。未给出符号。
- en: '**AttributeError**'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**AttributeError**'
- en: The input symbols are not \(Symbol\) type.
  id: totrans-534
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 输入的符号不是\(Symbol\)类型。
- en: Examples
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE54]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Positive dimensional system and complements:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正维系统和补集：
- en: '[PRE55]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 2\. If some of the equations are non-polynomial then \(nonlinsolve\) will call
    the `substitution` function and return real and complex solutions, if present.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 如果一些方程不是多项式，则\(nonlinsolve\)将调用`substitution`函数并返回实数和复数解（如果存在）。
- en: '[PRE56]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '3\. If system is non-linear polynomial and zero-dimensional then it returns
    both solution (real and complex solutions, if present) using [`solve_poly_system()`](solvers.html#sympy.solvers.polysys.solve_poly_system
    "sympy.solvers.polysys.solve_poly_system"):'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 如果系统是非线性多项式且零维的，则使用[`solve_poly_system()`](solvers.html#sympy.solvers.polysys.solve_poly_system
    "sympy.solvers.polysys.solve_poly_system")返回解（如果有实数和复数解）：
- en: '[PRE57]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 4\. `nonlinsolve` can solve some linear (zero or positive dimensional) system
    (because it uses the [`sympy.polys.polytools.groebner()`](../polys/reference.html#sympy.polys.polytools.groebner
    "sympy.polys.polytools.groebner") function to get the groebner basis and then
    uses the `substitution` function basis as the new \(system\)). But it is not recommended
    to solve linear system using `nonlinsolve`, because [`linsolve()`](#sympy.solvers.solveset.linsolve
    "sympy.solvers.solveset.linsolve") is better for general linear systems.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 4\. `nonlinsolve`可以解决一些线性系统（零维或正维），因为它使用[`sympy.polys.polytools.groebner()`](../polys/reference.html#sympy.polys.polytools.groebner
    "sympy.polys.polytools.groebner")函数获取Groebner基础，然后使用`substitution`函数将基础作为新系统。但不推荐使用`nonlinsolve`解决线性系统，因为一般的线性系统最好使用[`linsolve()`](#sympy.solvers.solveset.linsolve
    "sympy.solvers.solveset.linsolve")。
- en: '[PRE58]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '5\. System having polynomial equations and only real solution is solved using
    [`solve_poly_system()`](solvers.html#sympy.solvers.polysys.solve_poly_system "sympy.solvers.polysys.solve_poly_system"):'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 5\. 只有多项式方程且仅有实数解的系统使用[`solve_poly_system()`](solvers.html#sympy.solvers.polysys.solve_poly_system
    "sympy.solvers.polysys.solve_poly_system")求解：
- en: '[PRE59]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 6\. It is better to use symbols instead of trigonometric functions or [`Function`](../core.html#sympy.core.function.Function
    "sympy.core.function.Function"). For example, replace \(\sin(x)\) with a symbol,
    replace \(f(x)\) with a symbol and so on. Get a solution from `nonlinsolve` and
    then use [`solveset()`](#sympy.solvers.solveset.solveset "sympy.solvers.solveset.solveset")
    to get the value of \(x\).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 6\. 最好使用符号而不是三角函数或[`Function`](../core.html#sympy.core.function.Function "sympy.core.function.Function")。例如，用符号替换\(\sin(x)\)，用符号替换\(f(x)\)等。从`nonlinsolve`获取解决方案，然后使用[`solveset()`](#sympy.solvers.solveset.solveset
    "sympy.solvers.solveset.solveset")得到\(x\)的值。
- en: 'How Nonlinsolve Is Better Than Old Solver `_solve_system` :'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 比老解算器 `_solve_system` 更好的`nonlinsolve`：
- en: '1\. A positive dimensional system solver: nonlinsolve can return solution for
    positive dimensional system. It finds the Groebner Basis of the positive dimensional
    system(calling it as basis) then we can start solving equation(having least number
    of variable first in the basis) using solveset and substituting that solved solutions
    into other equation(of basis) to get solution in terms of minimum variables. Here
    the important thing is how we are substituting the known values and in which equations.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 正维系统求解器：`nonlinsolve`可以返回正维系统的解。它找到正维系统的Groebner基础（称为基础），然后我们可以开始解方程（首先解最少变量的方程），使用solveset并将已解决的解值代入其他方程（基础方程）中，以获得最小变量的解。重要的是我们如何替换已知值以及替换到哪些方程中。
- en: '2\. Real and complex solutions: nonlinsolve returns both real and complex solution.
    If all the equations in the system are polynomial then using [`solve_poly_system()`](solvers.html#sympy.solvers.polysys.solve_poly_system
    "sympy.solvers.polysys.solve_poly_system") both real and complex solution is returned.
    If all the equations in the system are not polynomial equation then goes to `substitution`
    method with this polynomial and non polynomial equation(s), to solve for unsolved
    variables. Here to solve for particular variable solveset_real and solveset_complex
    is used. For both real and complex solution `_solve_using_known_values` is used
    inside `substitution` (`substitution` will be called when any non-polynomial equation
    is present). If a solution is valid its general solution is added to the final
    result.'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 实数和复数解：`nonlinsolve`返回实数和复数解。如果系统中的所有方程都是多项式，则使用[`solve_poly_system()`](solvers.html#sympy.solvers.polysys.solve_poly_system
    "sympy.solvers.polysys.solve_poly_system")返回实数和复数解。如果系统中的所有方程不是多项式方程，则使用`substitution`方法处理这些多项式和非多项式方程，以解决未解决的变量。在解决实数和复数解时，使用`solveset_real`和`solveset_complex`。对于实数和复数解，`_solve_using_known_values`在`substitution`内部使用（当存在非多项式方程时将调用`substitution`）。如果解是有效的，则将其一般解添加到最终结果中。
- en: '3\. [`Complement`](../sets.html#sympy.sets.sets.Complement "sympy.sets.sets.Complement")
    and [`Intersection`](../sets.html#sympy.sets.sets.Intersection "sympy.sets.sets.Intersection")
    will be added: nonlinsolve maintains dict for complements and intersections. If
    solveset find complements or/and intersections with any interval or set during
    the execution of `substitution` function, then complement or/and intersection
    for that variable is added before returning final solution.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. [`补集`](../sets.html#sympy.sets.sets.Complement "sympy.sets.sets.Complement")和[`交集`](../sets.html#sympy.sets.sets.Intersection
    "sympy.sets.sets.Intersection")将被添加：nonlinsolve在`substitution`函数执行期间保持补集和交集的字典。如果`solveset`在执行期间找到任何变量的补集或交集，那么在返回最终解之前将添加该变量的补集或交集。
- en: transolve
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: transolve
- en: '[PRE60]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Function to solve transcendental equations. It is a helper to `solveset` and
    should be used internally. `_transolve` currently supports the following class
    of equations:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 解超越方程的函数。这是`solveset`的一个辅助函数，应在内部使用。`_transolve`目前支持以下类型的方程：
- en: Exponential equations
  id: totrans-555
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指数方程
- en: ''
  id: totrans-556
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-557
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Logarithmic equations
  id: totrans-558
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对数方程
- en: 'Parameters:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**f** : Any transcendental equation that needs to be solved.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '**f**：需要解决的任何超越方程。'
- en: This needs to be an expression, which is assumed to be equal to `0`.
  id: totrans-561
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这应该是一个表达式，假设等于`0`。
- en: '**symbol** : The variable for which the equation is solved.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '**symbol**：要解方程的变量。'
- en: This needs to be of class `Symbol`.
  id: totrans-563
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这需要是`Symbol`类的。
- en: '**domain** : A set over which the equation is solved.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '**domain**：方程解的集合。'
- en: This needs to be of class `Set`.
  id: totrans-565
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 这应该是`Set`类的。
- en: 'Returns:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: Set
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 集合
- en: A set of values for `symbol` for which `f` is equal to zero. An `EmptySet` is
    returned if `f` does not have solutions in respective domain. A `ConditionSet`
    is returned as unsolved object if algorithms to evaluate complete solution are
    not yet implemented.
  id: totrans-568
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`symbol`的一组值，使得`f`等于零。如果`f`在相应域中没有解，则返回`EmptySet`。如果尚未实现评估完整解的算法，则返回`ConditionSet`作为未解决的对象。'
- en: How To Use `_transolve`
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用`_transolve`
- en: '`_transolve` should not be used as an independent function, because it assumes
    that the equation (`f`) and the `symbol` comes from `solveset` and might have
    undergone a few modification(s). To use `_transolve` as an independent function
    the equation (`f`) and the `symbol` should be passed as they would have been by
    `solveset`.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 不应独立使用`_transolve`作为一个独立函数，因为它假设方程(`f`)和`symbol`来自`solveset`并可能经历了一些修改。要将`_transolve`作为一个独立函数使用，方程(`f`)和`symbol`应作为它们由`solveset`传递的样子传递。
- en: Examples
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE61]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How `_transolve` Works
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`_transolve`的工作原理'
- en: '`_transolve` uses two types of helper functions to solve equations of a particular
    class:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '`_transolve`使用两种类型的辅助函数来解决特定类别的方程：'
- en: 'Identifying helpers: To determine whether a given equation belongs to a certain
    class of equation or not. Returns either `True` or `False`.'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 识别辅助函数：确定给定方程是否属于某一类方程。返回`True`或`False`。
- en: 'Solving helpers: Once an equation is identified, a corresponding helper either
    solves the equation or returns a form of the equation that `solveset` might better
    be able to handle.'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 解决辅助函数：一旦确定了方程，相应的辅助函数将解决方程或返回`solveset`更好处理的方程形式。
- en: Philosophy behind the module
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模块背后的哲学
- en: The purpose of `_transolve` is to take equations which are not already polynomial
    in their generator(s) and to either recast them as such through a valid transformation
    or to solve them outright. A pair of helper functions for each class of supported
    transcendental functions are employed for this purpose. One identifies the transcendental
    form of an equation and the other either solves it or recasts it into a tractable
    form that can be solved by `solveset`. For example, an equation in the form \(ab^{f(x)}
    - cd^{g(x)} = 0\) can be transformed to \(\log(a) + f(x)\log(b) - \log(c) - g(x)\log(d)
    = 0\) (under certain assumptions) and this can be solved with `solveset` if \(f(x)\)
    and \(g(x)\) are in polynomial form.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`_transolve`的目的是接受生成器中不是多项式的方程，并通过有效的转换将它们转换为这样的形式，或者直接解决它们。每类支持的超越函数都使用一对辅助函数来实现这一目的。其中一个识别方程的超越形式，另一个要么解决它，要么重新将其重塑为`solveset`可以处理的可处理形式。例如，形如
    \(ab^{f(x)} - cd^{g(x)} = 0\) 的方程在某些假设下可以转换为 \(\log(a) + f(x)\log(b) - \log(c)
    - g(x)\log(d) = 0\)，并且如果 \(f(x)\) 和 \(g(x)\) 是多项式形式，则可以使用`solveset`解决。'
- en: How `_transolve` Is Better Than `_tsolve`
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '`_transolve`为何优于`_tsolve`'
- en: Better output
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更好的输出
- en: '`_transolve` provides expressions in a more simplified form.'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '`_transolve`以更简化的形式提供表达式。'
- en: Consider a simple exponential equation
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个简单的指数方程
- en: '[PRE62]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Extensible
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可扩展的
- en: The API of `_transolve` is designed such that it is easily extensible, i.e.
    the code that solves a given class of equations is encapsulated in a helper and
    not mixed in with the code of `_transolve` itself.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`_transolve` 的 API 被设计成易于扩展，即解决给定类别方程的代码被封装在辅助函数中，而不是与 `_transolve` 代码混合在一起。'
- en: Modular
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模块化
- en: '`_transolve` is designed to be modular i.e, for every class of equation a separate
    helper for identification and solving is implemented. This makes it easy to change
    or modify any of the method implemented directly in the helpers without interfering
    with the actual structure of the API.'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '`_transolve` 被设计为模块化，即为每一类方程实现一个单独的识别和解决助手。这样可以轻松修改或更改任何直接实现在辅助函数中的方法，而不会干扰
    API 的实际结构。'
- en: Faster Computation
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更快的计算
- en: Solving equation via `_transolve` is much faster as compared to `_tsolve`. In
    `solve`, attempts are made computing every possibility to get the solutions. This
    series of attempts makes solving a bit slow. In `_transolve`, computation begins
    only after a particular type of equation is identified.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `_transolve` 解方程要比通过 `_tsolve` 快得多。在 `solve` 中，尝试计算每一种可能性以获取解决方案。这一系列尝试使得解决过程有些慢。在
    `_transolve` 中，只有在识别特定类型的方程后才开始计算。
- en: How To Add New Class Of Equations
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 如何添加新的方程类别
- en: 'Adding a new class of equation solver is a three-step procedure:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的方程类别求解器是一个三步骤过程：
- en: Identify the type of the equations
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定方程的类型
- en: 'Determine the type of the class of equations to which they belong: it could
    be of `Add`, `Pow`, etc. types. Separate internal functions are used for each
    type. Write identification and solving helpers and use them from within the routine
    for the given type of equation (after adding it, if necessary). Something like:'
  id: totrans-593
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确定它们所属的方程类别的类型：可以是 `Add`、`Pow` 等类型。使用不同的内部函数处理每种类型。编写识别和解决助手，并从例程中使用它们来处理给定类型的方程（如果需要添加）。
- en: '[PRE63]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Define the identification helper.
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义识别助手。
- en: Define the solving helper.
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义解决助手。
- en: 'Apart from this, a few other things needs to be taken care while adding an
    equation solver:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，添加方程求解器时需要注意的一些其他事项：
- en: 'Naming conventions: Name of the identification helper should be as `_is_class`
    where class will be the name or abbreviation of the class of equation. The solving
    helper will be named as `_solve_class`. For example: for exponential equations
    it becomes `_is_exponential` and `_solve_expo`.'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名约定：识别助手的名称应为 `_is_class`，其中类将是方程类别的名称或缩写。求解助手将命名为 `_solve_class`。例如，对于指数方程，它变为
    `_is_exponential` 和 `_solve_expo`。
- en: The identifying helpers should take two input parameters, the equation to be
    checked and the variable for which a solution is being sought, while solving helpers
    would require an additional domain parameter.
  id: totrans-599
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别助手应该接受两个输入参数，待检查的方程和正在寻找解的变量，而解决助手则需要一个额外的域参数。
- en: Be sure to consider corner cases.
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请务必考虑边界情况。
- en: Add tests for each helper.
  id: totrans-601
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个辅助函数添加测试。
- en: 'Add a docstring to your helper that describes the method implemented. The documentation
    of the helpers should identify:'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的辅助函数添加文档字符串，描述已实现的方法。辅助函数的文档应标识：
- en: the purpose of the helper,
  id: totrans-603
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助函数的目的，
- en: the method used to identify and solve the equation,
  id: totrans-604
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于识别和解决方程的方法，
- en: a proof of correctness
  id: totrans-605
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个正确性的证明
- en: the return values of the helpers
  id: totrans-606
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助函数的返回值
- en: '[PRE64]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Return `True` if one or more terms contain `symbol` only in exponents, else
    `False`.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个或多个项仅包含 `symbol` 的指数，则返回 `True`，否则返回 `False`。
- en: 'Parameters:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**f** : Expr'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '**f** : 表达式'
- en: The equation to be checked
  id: totrans-611
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要检查的方程
- en: '**symbol** : Symbol'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '**symbol** : 符号'
- en: The variable in which the equation is checked
  id: totrans-613
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 检查方程的变量
- en: Examples
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE65]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Philosophy behind the helper
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助函数背后的哲学
- en: The function extracts each term of the equation and checks if it is of exponential
    form w.r.t `symbol`.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数提取方程的每一项，并检查它是否符合相对于 `symbol` 的指数形式。
- en: '[PRE66]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Helper function for solving (supported) exponential equations.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解决（支持的）指数方程的辅助函数。
- en: Exponential equations are the sum of (currently) at most two terms with one
    or both of them having a power with a symbol-dependent exponent.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 指数方程目前最多由两项组成，其中一项或两项具有依赖于符号的指数。
- en: For example
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 例如
- en: \[5^{2x + 3} - 5^{3x - 1}\]\[4^{5 - 9x} - e^{2 - x}\]
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: \[5^{2x + 3} - 5^{3x - 1}\]\[4^{5 - 9x} - e^{2 - x}\]
- en: 'Parameters:'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**lhs, rhs** : Expr'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '**lhs, rhs** : 表达式'
- en: The exponential equation to be solved, \(lhs = rhs\)
  id: totrans-625
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要解决的指数方程，\(lhs = rhs\)
- en: '**symbol** : Symbol'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '**symbol** : 符号'
- en: The variable in which the equation is solved
  id: totrans-627
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在其中解方程的变量
- en: '**domain** : Set'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '**domain** : 集合'
- en: A set over which the equation is solved.
  id: totrans-629
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个解方程式的集合。
- en: 'Returns:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: A set of solutions satisfying the given equation.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 满足给定方程的解集。
- en: A `ConditionSet` if the equation is unsolvable or
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方程无法解决，就会出现 `ConditionSet` 或
- en: if the assumptions are not properly defined, in that case
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 如果假设没有适当定义，在这种情况下
- en: a different style of `ConditionSet` is returned having the
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 返回具有不同风格的 `ConditionSet`，其中
- en: solution(s) of the equation with the desired assumptions.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 方程式的解（解）与所需的假设。
- en: Examples
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE67]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Proof of correctness of the method
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法的正确性证明
- en: 'The logarithm function is the inverse of the exponential function. The defining
    relation between exponentiation and logarithm is:'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 对数函数是指数函数的反函数。指数和对数之间的定义关系是：
- en: \[{\log_b x} = y \enspace if \enspace b^y = x\]
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: \[{\log_b x} = y \enspace if \enspace b^y = x\]
- en: Therefore if we are given an equation with exponent terms, we can convert every
    term to its corresponding logarithmic form. This is achieved by taking logarithms
    and expanding the equation using logarithmic identities so that it can easily
    be handled by `solveset`.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们给出一个包含指数项的方程，我们可以将每个项转换为其相应的对数形式。这通过取对数和使用对数恒等式扩展方程来实现，以便 `solveset`
    轻松处理。
- en: 'For example:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: \[3^{2x} = 2^{x + 3}\]
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: \[3^{2x} = 2^{x + 3}\]
- en: Taking log both sides will reduce the equation to
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 对两边取对数将减少方程为
- en: \[(2x)\log(3) = (x + 3)\log(2)\]
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: \[(2x)\log(3) = (x + 3)\log(2)\]
- en: This form can be easily handed by `solveset`.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 可以很容易地由 `solveset` 处理此形式。
- en: '[PRE68]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Helper to solve logarithmic equations which are reducible to a single instance
    of \(\log\).
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助解决可以化简为单个 \(\log\) 实例的对数方程。
- en: Logarithmic equations are (currently) the equations that contains \(\log\) terms
    which can be reduced to a single \(\log\) term or a constant using various logarithmic
    identities.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 目前对数方程是包含可以使用各种对数恒等式将其化简为单个 \(\log\) 项或常数的方程。
- en: 'For example:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: \[\log(x) + \log(x - 4)\]
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: \[\log(x) + \log(x - 4)\]
- en: 'can be reduced to:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 可以简化为：
- en: \[\log(x(x - 4))\]
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: \[\log(x(x - 4))\]
- en: 'Parameters:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**lhs, rhs** : Expr'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '**lhs, rhs** : 表达式'
- en: The logarithmic equation to be solved, \(lhs = rhs\)
  id: totrans-656
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要解决的对数方程，\(lhs = rhs\)
- en: '**symbol** : Symbol'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '**symbol** : 符号'
- en: The variable in which the equation is solved
  id: totrans-658
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在其中解方程的变量
- en: '**domain** : Set'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '**domain** : 集合'
- en: A set over which the equation is solved.
  id: totrans-660
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一个解方程式的集合。
- en: 'Returns:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: A set of solutions satisfying the given equation.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 满足给定方程的解集。
- en: A `ConditionSet` if the equation is unsolvable.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方程无法解决，则返回 `ConditionSet`。
- en: Examples
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE69]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Proof of correctness
  id: totrans-666
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确性的证明
- en: A logarithm is another way to write exponent and is defined by
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 对数是另一种写指数的方法，并且由以下定义
- en: \[{\log_b x} = y \enspace if \enspace b^y = x\]
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: \[{\log_b x} = y \enspace if \enspace b^y = x\]
- en: When one side of the equation contains a single logarithm, the equation can
    be solved by rewriting the equation as an equivalent exponential equation as defined
    above. But if one side contains more than one logarithm, we need to use the properties
    of logarithm to condense it into a single logarithm.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 当方程的一边包含单个对数时，可以通过将方程重写为等效的指数方程来解决该方程，如上定义。但是，如果一边包含多个对数，则需要使用对数的性质将其压缩为单个对数。
- en: Take for example
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子
- en: \[\log(2x) - 15 = 0\]
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: \[\log(2x) - 15 = 0\]
- en: contains single logarithm, therefore we can directly rewrite it to exponential
    form as
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 包含单个对数，因此我们可以直接将其重写为指数形式
- en: \[x = \frac{e^{15}}{2}\]
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: \[x = \frac{e^{15}}{2}\]
- en: But if the equation has more than one logarithm as
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果方程具有多个对数，例如
- en: \[\log(x - 3) + \log(x + 3) = 0\]
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: \[\log(x - 3) + \log(x + 3) = 0\]
- en: we use logarithmic identities to convert it into a reduced form
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用对数恒等式将其转换为简化形式
- en: Using,
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 使用，
- en: \[\log(a) + \log(b) = \log(ab)\]
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: \[\log(a) + \log(b) = \log(ab)\]
- en: the equation becomes,
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 方程变为，
- en: \[\log((x - 3)(x + 3))\]
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: \[\log((x - 3)(x + 3))\]
- en: This equation contains one logarithm and can be solved by rewriting to exponents.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方程包含一个对数，可以通过重写为指数形式来解决。
- en: '[PRE70]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Return `True` if the equation is in the form \(a\log(f(x)) + b\log(g(x)) + ...
    + c\) else `False`.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方程是 \(a\log(f(x)) + b\log(g(x)) + ... + c\) 形式，则返回 `True`，否则返回 `False`。
- en: 'Parameters:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**f** : Expr'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '**f** : 表达式'
- en: The equation to be checked
  id: totrans-686
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 要检查的方程式
- en: '**symbol** : Symbol'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '**symbol** : 符号'
- en: The variable in which the equation is checked
  id: totrans-688
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在其中检查方程的变量
- en: 'Returns:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: '`True` if the equation is logarithmic otherwise `False`.'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方程是对数的，则返回 `True`。
- en: Examples
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE71]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Philosophy behind the helper
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 辅助工具背后的哲学
- en: The function extracts each term and checks whether it is logarithmic w.r.t `symbol`.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数提取每个项并检查其是否对于`symbol`是对数的。
- en: Diophantine Equations (DEs)
  id: totrans-695
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢番图方程（DEs）
- en: See [Diophantine](diophantine.html#diophantine-docs)
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[丢番图方程](diophantine.html#diophantine-docs)
- en: Inequalities
  id: totrans-697
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不等式
- en: See [Inequality Solvers](inequalities.html#inequality-docs)
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[不等式求解器](inequalities.html#inequality-docs)
- en: Ordinary Differential equations (ODEs)
  id: totrans-699
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 普通微分方程（ODEs）
- en: See [ODE](ode.html#ode-docs).
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[ODE（常微分方程）](ode.html#ode-docs)。
- en: Partial Differential Equations (PDEs)
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏微分方程（PDEs）
- en: See [PDE](pde.html#pde-docs).
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[PDE（偏微分方程）](pde.html#pde-docs)。
