["```py\nclass scipy.spatial.HalfspaceIntersection(halfspaces, interior_point, incremental=False, qhull_options=None)\n```", "```py\n>>> from scipy.spatial import HalfspaceIntersection\n>>> import numpy as np\n>>> halfspaces = np.array([[-1, 0., 0.],\n...                        [0., -1., 0.],\n...                        [2., 1., -4.],\n...                        [-0.5, 1., -2.]])\n>>> feasible_point = np.array([0.5, 0.5])\n>>> hs = HalfspaceIntersection(halfspaces, feasible_point) \n```", "```py\n>>> import matplotlib.pyplot as plt\n>>> fig = plt.figure()\n>>> ax = fig.add_subplot(1, 1, 1, aspect='equal')\n>>> xlim, ylim = (-1, 3), (-1, 3)\n>>> ax.set_xlim(xlim)\n>>> ax.set_ylim(ylim)\n>>> x = np.linspace(-1, 3, 100)\n>>> symbols = ['-', '+', 'x', '*']\n>>> signs = [0, 0, -1, -1]\n>>> fmt = {\"color\": None, \"edgecolor\": \"b\", \"alpha\": 0.5}\n>>> for h, sym, sign in zip(halfspaces, symbols, signs):\n...     hlist = h.tolist()\n...     fmt[\"hatch\"] = sym\n...     if h[1]== 0:\n...         ax.axvline(-h[2]/h[0], label='{}x+{}y+{}=0'.format(*hlist))\n...         xi = np.linspace(xlim[sign], -h[2]/h[0], 100)\n...         ax.fill_between(xi, ylim[0], ylim[1], **fmt)\n...     else:\n...         ax.plot(x, (-h[2]-h[0]*x)/h[1], label='{}x+{}y+{}=0'.format(*hlist))\n...         ax.fill_between(x, (-h[2]-h[0]*x)/h[1], ylim[sign], **fmt)\n>>> x, y = zip(*hs.intersections)\n>>> ax.plot(x, y, 'o', markersize=8) \n```", "```py\n>>> from scipy.optimize import linprog\n>>> from matplotlib.patches import Circle\n>>> norm_vector = np.reshape(np.linalg.norm(halfspaces[:, :-1], axis=1),\n...     (halfspaces.shape[0], 1))\n>>> c = np.zeros((halfspaces.shape[1],))\n>>> c[-1] = -1\n>>> A = np.hstack((halfspaces[:, :-1], norm_vector))\n>>> b = - halfspaces[:, -1:]\n>>> res = linprog(c, A_ub=A, b_ub=b, bounds=(None, None))\n>>> x = res.x[:-1]\n>>> y = res.x[-1]\n>>> circle = Circle(x, radius=y, alpha=0.3)\n>>> ax.add_patch(circle)\n>>> plt.legend(bbox_to_anchor=(1.6, 1.0))\n>>> plt.show() \n```"]