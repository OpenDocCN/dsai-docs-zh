- en: Introducing the Domains of the poly module
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 poly 模块的域
- en: Original text：[https://docs.sympy.org/latest/modules/polys/domainsintro.html](https://docs.sympy.org/latest/modules/polys/domainsintro.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/modules/polys/domainsintro.html](https://docs.sympy.org/latest/modules/polys/domainsintro.html)
- en: This page introduces the idea of the “domains” that are used in SymPy’s [`sympy.polys`](reference.html#module-sympy.polys
    "sympy.polys") module. The emphasis is on introducing how to use the domains directly
    and on understanding how they are used internally as part of the [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") class. This is a relatively advanced topic so for
    a more introductory understanding of the [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") class and the [`sympy.polys`](reference.html#module-sympy.polys
    "sympy.polys") module it is recommended to read [Basic functionality of the module](basics.html#polys-basics)
    instead. The reference documentation for the domain classes is in [Reference docs
    for the Poly Domains](domainsref.html#polys-domainsref). Internal functions that
    make use of the domains are documented in [Internals of the Polynomial Manipulation
    Module](internals.html#polys-internals).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 此页面介绍了 SymPy 的 [`sympy.polys`](reference.html#module-sympy.polys "sympy.polys")
    模块中使用的“域”的概念。重点是直接介绍如何使用这些域以及理解它们如何作为 [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") 类的内部部分使用。这是一个相对高级的主题，因此建议阅读 [模块的基本功能](basics.html#polys-basics)
    以获取更简介的对 [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    类和 [`sympy.polys`](reference.html#module-sympy.polys "sympy.polys") 模块的理解。有关域类的参考文档在
    [Poly Domains 的参考文档](domainsref.html#polys-domainsref) 中。利用这些域的内部功能在 [多项式操作模块的内部](internals.html#polys-internals)
    中有所记录。
- en: What are the domains?
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域是什么？
- en: 'For most users the domains are only really noticeable in the printed output
    of a [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly"):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数用户来说，域只在打印输出[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")时才真正显著：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We see here that one [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    has domain [ZZ](domainsref.html#zz) representing the integers and the other has
    domain [QQ](domainsref.html#qq) representing the rationals. These indicate the
    “domain” from which the coefficients of the polynomial are drawn.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里看到一个 [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    具有域 [ZZ](domainsref.html#zz)，代表整数，另一个具有域 [QQ](domainsref.html#qq)，代表有理数。这些指示了多项式系数的“域”来源。
- en: From a high-level the domains represent formal concepts such as the set of integers
    \(\mathbb{Z}\) or rationals \(\mathbb{Q}\). The word “domain” here is a reference
    to the mathematical concept of an [integral domain](https://en.wikipedia.org/wiki/Integral_domain).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从高层次来看，域表示形式概念，如整数集\(\mathbb{Z}\)或有理数\(\mathbb{Q}\)。这里的“域”一词是对数学概念“整环”的引用。
- en: 'Internally the domains correspond to different computational implementations
    and representations of the expressions that the polynomials correspond to. The
    [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    object itself has an internal representation as a `list` of coefficients and a
    [`domain`](reference.html#sympy.polys.polytools.Poly.domain "sympy.polys.polytools.Poly.domain")
    attribute representing the implementation of those coefficients:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，域对应于多项式所对应的不同计算实现和表达方式。[`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") 对象本身有一个内部表示，作为系数的`list`和表示这些系数实现的 [`domain`](reference.html#sympy.polys.polytools.Poly.domain
    "sympy.polys.polytools.Poly.domain") 属性：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here the domain is [QQ](domainsref.html#qq) which represents the implementation
    of the rational numbers in the domain system. The [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") instance itself has a [`Poly.domain`](reference.html#sympy.polys.polytools.Poly.domain
    "sympy.polys.polytools.Poly.domain") attribute [QQ](domainsref.html#qq) and then
    a list of [`PythonMPQ`](domainsref.html#sympy.external.pythonmpq.PythonMPQ "sympy.external.pythonmpq.PythonMPQ")
    coefficients where [`PythonMPQ`](domainsref.html#sympy.external.pythonmpq.PythonMPQ
    "sympy.external.pythonmpq.PythonMPQ") is the class that implements the elements
    of the [QQ](domainsref.html#qq) domain. The list of coefficients `[1, 1/2, 0]`
    gives a standardised low-level representation of the polynomial expression `(1)*x**2
    + (1/2)*x + (0)`.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的域是 [QQ](domainsref.html#qq)，它表示域系统中有理数的实现。[`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") 实例本身具有 [`Poly.domain`](reference.html#sympy.polys.polytools.Poly.domain
    "sympy.polys.polytools.Poly.domain") 属性 [QQ](domainsref.html#qq)，然后是一个 [`PythonMPQ`](domainsref.html#sympy.external.pythonmpq.PythonMPQ
    "sympy.external.pythonmpq.PythonMPQ") 系数列表，其中 [`PythonMPQ`](domainsref.html#sympy.external.pythonmpq.PythonMPQ
    "sympy.external.pythonmpq.PythonMPQ") 是实现 [QQ](domainsref.html#qq) 域元素的类。系数列表
    `[1, 1/2, 0]` 给出了多项式表达式 `(1)*x**2 + (1/2)*x + (0)` 的标准化低级表示。
- en: This page looks at the different domains that are defined in SymPy, how they
    are implemented and how they can be used. It introduces how to use the domains
    and domain elements directly and explains how they are used internally as part
    of [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    objects. This information is more relevant for development in SymPy than it is
    for users of the [`sympy.polys`](reference.html#module-sympy.polys "sympy.polys")
    module.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本页面介绍了在 SymPy 中定义的不同域，它们的实现方式以及如何使用它们。它介绍了如何直接使用域和域元素，并解释了它们作为 [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") 对象的内部使用方式。这些信息对于 SymPy 的开发比对 [`sympy.polys`](reference.html#module-sympy.polys
    "sympy.polys") 模块的用户更相关。
- en: Representing expressions symbolically
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以符号表示表达式
- en: 'There are many different ways that a mathematical expression can be represented
    symbolically. The purpose of the polynomial domains is to provide suitable implementations
    for different classes of expressions. This section considers the basic approaches
    to the symbolic representation of mathematical expressions: “tree”, “dense polynomial”
    and “sparse polynomial”.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数学表达式可以以多种不同的方式符号化表示。多项式域的目的是为不同类别的表达式提供合适的实现。本节考虑了数学表达式符号化表示的基本方法：“树形结构”、“密集多项式”和“稀疏多项式”。
- en: Tree representation
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 树形结构表示
- en: 'The most general representation of symbolic expressions is as a [tree](https://en.wikipedia.org/wiki/Tree_(data_structure))
    and this is the representation used for most ordinary SymPy expressions which
    are instances of [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    (a subclass of [`Basic`](../core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")).
    We can see this representation using the [`srepr()`](../printing.html#sympy.printing.repr.srepr
    "sympy.printing.repr.srepr") function:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 符号表达式的最一般表示形式是作为 [树形结构](https://en.wikipedia.org/wiki/Tree_(data_structure))，这是大多数普通
    SymPy 表达式的表示形式，它们是 [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    的实例（[`Basic`](../core.html#sympy.core.basic.Basic "sympy.core.basic.Basic") 的子类）。我们可以使用
    [`srepr()`](../printing.html#sympy.printing.repr.srepr "sympy.printing.repr.srepr")
    函数来查看这种表示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here the expression `e` is represented as an [`Add`](../core.html#sympy.core.add.Add
    "sympy.core.add.Add") node which has two children `1` and `1/(x**2 + 2)`. The
    child `1` is represented as an [`Integer`](../core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer") and the other child is represented as a [`Pow`](../core.html#sympy.core.power.Pow
    "sympy.core.power.Pow") with base `x**2 + 2` and exponent `1`. Then `x**2 + 2`
    is represented as an [`Add`](../core.html#sympy.core.add.Add "sympy.core.add.Add")
    with children `x**2` and `2` and so on. In this way the expression is represented
    as a tree where the internal nodes are operations like [`Add`](../core.html#sympy.core.add.Add
    "sympy.core.add.Add"), [`Mul`](../core.html#sympy.core.mul.Mul "sympy.core.mul.Mul"),
    [`Pow`](../core.html#sympy.core.power.Pow "sympy.core.power.Pow") and so on and
    the leaf nodes are atomic expression types like [`Integer`](../core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer") and [`Symbol`](../core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol"). See [Advanced Expression Manipulation](../../tutorials/intro-tutorial/manipulation.html#tutorial-manipulation)
    for more about this representation.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，表达式 `e` 被表示为一个 [`Add`](../core.html#sympy.core.add.Add "sympy.core.add.Add")
    节点，它有两个子节点 `1` 和 `1/(x**2 + 2)`。子节点 `1` 被表示为一个 [`Integer`](../core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer")，而另一个子节点被表示为一个 [`Pow`](../core.html#sympy.core.power.Pow
    "sympy.core.power.Pow")，其基数为 `x**2 + 2`，指数为 `1`。然后 `x**2 + 2` 被表示为一个 [`Add`](../core.html#sympy.core.add.Add
    "sympy.core.add.Add")，其子节点为 `x**2` 和 `2`，依此类推。通过这种方式，表达式被表示为一个树，其中内部节点是操作，如 [`Add`](../core.html#sympy.core.add.Add
    "sympy.core.add.Add")、[`Mul`](../core.html#sympy.core.mul.Mul "sympy.core.mul.Mul")、[`Pow`](../core.html#sympy.core.power.Pow
    "sympy.core.power.Pow") 等，而叶节点是原子表达式类型，如 [`Integer`](../core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer") 和 [`Symbol`](../core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol")。更多关于这种表示方法的信息，请参见[高级表达式操作](../../tutorials/intro-tutorial/manipulation.html#tutorial-manipulation)。
- en: 'The tree representation is core to the architecture of [`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") in SymPy. It is a highly flexible representation that
    can represent a very wide range of possible expressions. It can also represent
    equivalent expressions in different ways e.g.:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 树形表示是 SymPy 中 [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    架构的核心。它是一种高度灵活的表示方法，可以表示非常广泛的表达式。它还可以以不同方式表示等价表达式，例如：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'These two expression although equivalent have different tree representations:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个表达式虽然等价，但具有不同的树形表示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Being able to represent the same expression in different ways is both a strength
    and a weakness. It is useful to be able to convert an expression in to different
    forms for different tasks but having non-unique representations makes it hard
    to tell when two expressions are equivalent which is in fact very important for
    many computational algorithms. The most important task is being able to tell when
    an expression is equal to zero which is undecidable in general ([Richardon’s theorem](https://en.wikipedia.org/wiki/Richardson%27s_theorem))
    but is decidable in many important special cases.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 能够以不同方式表示相同的表达式既是一种优势也是一种弱点。能够将表达式转换为不同形式以应对不同的任务是很有用的，但是具有非唯一表示使得很难判断两个表达式是否等价，而这对于许多计算算法来说是非常重要的。最重要的任务是能够判断一个表达式是否等于零，在一般情况下这是不可判定的（参见[理查森定理](https://en.wikipedia.org/wiki/Richardson%27s_theorem)），但在许多重要的特殊情况下是可判定的。
- en: '### DUP representation'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '### DUP 表示'
- en: 'Restricting the set of allowed expressions to special cases allows for much
    more efficient symbolic representations. As we already saw [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") can represent a polynomial as a list of coefficients.
    This means that an expression like `x**4 + x + 1` could be represented simply
    as `[1, 0, 0, 1, 1]`. This list of coefficients representation of a polynomial
    expression is known as the “dense univariate polynomial” (DUP) representation.
    Working within that representation algorithms for multiplication, addition and
    crucially zero-testing can be much more efficient than with the corresponding
    tree representations. We can see this representation from a [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") instance by looking it its `rep.rep` attribute:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 限制允许表达式的特殊情况可以实现更高效的符号表示。正如我们之前看到的[`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")可以将多项式表示为系数列表。这意味着像`x**4 + x + 1`这样的表达式可以简单地表示为`[1,
    0, 0, 1, 1]`。多项式表达式的这种系数列表表示称为“密集单变量多项式”（DUP）表示。在该表示内部，乘法、加法和关键的零测试算法比对应的树形表示要高效得多。我们可以通过查看[`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")实例的`rep.rep`属性来看到这种表示：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the DUP representation it is not possible to represent the same expression
    in different ways. There is no distinction between `x*(x + 1)` and `x**2 + x`
    because both are just `[1, 1, 0]`. This means that comparing two expressions is
    easy: they are equal if and only if all of their coefficients are equal. Zero-testing
    is particularly easy: the polynomial is zero if and only if all coefficients are
    zero (of course we need to have easy zero-testing for the coefficients themselves).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在DUP表示中，不可能用不同的方式表示相同的表达式。`x*(x + 1)`和`x**2 + x`之间没有区别，因为它们都是`[1, 1, 0]`。这意味着比较两个表达式很容易：它们只有在所有系数都相等时才相等。零测试特别简单：多项式仅在所有系数都为零时为零（当然，我们需要对系数本身进行简单的零测试）。
- en: 'We can make functions that operate on the DUP representation much more efficiently
    than functions that operate on the tree representation. Many operations with standard
    sympy expressions are in fact computed by converting to a polynomial representation
    and then performing the calculation. An example is the [`factor()`](reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor") function:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以比树形表示法更有效地创建在DUP表示法上操作的函数。实际上，许多标准sympy表达式的操作实际上是通过转换为多项式表示，然后执行计算来完成的。一个例子是[`factor()`](reference.html#sympy.polys.polytools.factor
    "sympy.polys.polytools.factor")函数：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Internally [`factor()`](reference.html#sympy.polys.polytools.factor "sympy.polys.polytools.factor")
    will convert the expression from the tree representation into the DUP representation
    and then use the function `dup_factor_list`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，[`factor()`](reference.html#sympy.polys.polytools.factor "sympy.polys.polytools.factor")将把表达式从树形表示转换为DUP表示，然后使用函数`dup_factor_list`：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'There are many more examples of functions with `dup_*` names for operating
    on the DUP representation that are documented in [Internals of the Polynomial
    Manipulation Module](internals.html#polys-internals). There are also functions
    with the `dmp_*` prefix for operating on multivariate polynomials.  ### DMP representation'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多以`dup_*`命名的函数用于操作DUP表示，这些函数在[多项式操作模块内部](internals.html#polys-internals)有详细文档。还有以`dmp_*`前缀命名的函数用于操作多元多项式。###
    DMP表示
- en: 'A multivariate polynomial (a polynomial in multiple variables) can be represented
    as a polynomial with coefficients that are themselves polynomials. For example
    `x**2*y + x**2 + x*y + y + 1` can be represented as polynomial in `x` where the
    coefficients are themselves polynomials in `y` i.e.: `(y + 1)*x**2 + (y)*x + (y+1)`.
    Since we can represent a polynomial with a list of coefficients a multivariate
    polynomial can be represented with a list of lists of coefficients:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 多元多项式（多个变量的多项式）可以表示为系数本身是多项式的多项式。例如，`x**2*y + x**2 + x*y + y + 1`可以表示为以`x`为多项式的多项式，其中系数本身是`y`的多项式，即：`(y
    + 1)*x**2 + (y)*x + (y+1)`。由于我们可以用系数列表表示一个多项式，多元多项式可以用系数列表的列表表示：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This list of lists of (lists of…) coefficients representation is known as the
    “dense multivariate polynomial” (DMP) representation.  ### Sparse polynomial representation'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这种列表的（列表的…）系数表示称为“密集多元多项式”（DMP）表示。### 稀疏多项式表示
- en: 'Instead of lists we can use a dict mapping nonzero monomial terms to their
    coefficients. This is known as the “sparse polynomial” representation. We can
    see what this would look like using the [`as_dict()`](reference.html#sympy.polys.polytools.Poly.as_dict
    "sympy.polys.polytools.Poly.as_dict") method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用字典来代替列表，将非零单项式项映射到它们的系数。这被称为“稀疏多项式”表示。我们可以通过[`as_dict()`](reference.html#sympy.polys.polytools.Poly.as_dict
    "sympy.polys.polytools.Poly.as_dict")方法看到它的实现：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The keys of this dict are the exponents of the powers of `x` and the values
    are the coefficients so e.g. `7*x**20` becomes `(20,): 7` in the dict. The key
    is a tuple so that in the multivariate case something like `4*x**2*y**3` can be
    represented as `(2, 3): 4`. The sparse representation can be more efficient as
    it avoids the need to store and manipulate the zero coefficients. With a large
    number of generators (variables) the dense representation becomes particularly
    inefficient and it is better to use the sparse representation:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '此字典的键是`x`的幂的指数，值是系数，因此例如`7*x**20`在字典中变为`(20,): 7`。键是一个元组，因此在多变量情况下，如`4*x**2*y**3`可以表示为`(2,
    3): 4`。稀疏表示可以更高效，因为它避免了存储和操作零系数的需求。在具有大量生成器（变量）的情况下，稠密表示尤其低效，最好使用稀疏表示：'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The dict representation shown in the last output maps from the monomial which
    is represented as a tuple of powers (`(1, 1, 1, ...)` i.e. `x0**1 * x1**1, ...`)
    to the coefficient `1`. Compared to the [DMP representation](#dmp-representation)
    we have a much more flattened data structure: it is a `dict` with only one key
    and value. Algorithms for working with sparse representations would likely be
    much more efficient than dense algorithms for this particular example polynomial.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个输出中显示的字典表示将单项式（表示为幂的元组，如`(1, 1, 1, ...)`即`x0**1 * x1**1, ...`）映射到系数`1`。与[DMP表示](#dmp-representation)相比，我们拥有一个更为扁平化的数据结构：它是一个只有一个键和值的`dict`。对于处理稀疏表示的算法，可能比这个特定例子中的密集算法更为高效。
- en: SymPy’s polynomial module has implementations of polynomial expressions based
    on both the dense and sparse representations. There are also other implementations
    of different special classes of expressions that can be used as the coefficients
    of those polynomials. The rest of this page discusses what those representations
    are and how to use them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy的多项式模块实现了基于密集和稀疏表示的多项式表达式。还有其他实现不同特殊类别表达式的实现，可以作为这些多项式的系数。本页的其余部分将讨论这些表示形式及其使用方法。
- en: Basic usage of domains
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域的基本用法
- en: 'Several domains are predefined and ready to be used such as [ZZ](domainsref.html#zz)
    and [QQ](domainsref.html#qq) which represent the ring of integers \(\mathbb{Z}\)
    and the field of rationals \(\mathbb{Q}\). The [`Domain`](domainsref.html#sympy.polys.domains.domain.Domain
    "sympy.polys.domains.domain.Domain") object is used to construct elements which
    can then be used in ordinary arithmetic operations.:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 几个域已经预定义并可以直接使用，例如[ZZ](domainsref.html#zz)和[QQ](domainsref.html#qq)，它们分别代表整数环\(\mathbb{Z}\)和有理数域\(\mathbb{Q}\)。[`Domain`](domainsref.html#sympy.polys.domains.domain.Domain
    "sympy.polys.domains.domain.Domain")对象用于构造元素，这些元素可以用于普通的算术运算。
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The basic operations `+`, `-`, and `*` for addition, subtraction and multiplication
    will work for the elements of any domain and will produce new domain elements.
    Division with `/` (Python’s “true division” operator) is not possible for all
    domains and should not be used with domain elements unless the domain is known
    to be a field. For example dividing two elements of [ZZ](domainsref.html#zz) might
    give a `float` which is not an element of [ZZ](domainsref.html#zz):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何域的元素，基本运算`+`、`-`和`*`（加法、减法和乘法）都能工作并生成新的域元素。使用`/`（Python的“真除法”运算符）进行除法不一定适用于所有域元素，除非已知该域是一个域。例如，两个[ZZ](domainsref.html#zz)中的元素相除可能会得到一个不是[ZZ](domainsref.html#zz)元素的`float`：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The behaviour of `/` for non-fields can also differ for different implementations
    of the ground types of the domain. For example with `SYMPY_GROUND_TYPES=flint`
    dividing two elements of [ZZ](domainsref.html#zz) will raise an error rather than
    return a float:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非域的情况，`/`的行为在不同的域的基础类型的不同实现中也可能不同。例如，使用`SYMPY_GROUND_TYPES=flint`，在[ZZ](domainsref.html#zz)中除法运算会引发错误，而不是返回浮点数：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Most domains representing non-field rings allow floor and modulo division (remainder)
    with Python’s floor division `//` and modulo division `%` operators. For example
    with [ZZ](domainsref.html#zz):'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数表示非域环的域允许使用Python的地板除法`//`和模除运算`%`。例如，使用[ZZ](domainsref.html#zz)：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The [QQ](domainsref.html#qq) domain represents the field of rational numbers
    and does allow division:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[QQ](domainsref.html#qq)域表示有理数的域并允许除法：'
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In general code that is expected to work with elements of an arbitrary domain
    should not use the division operators `/`, `//` and `%`. Only the operators `+`,
    `-`, `*` and `**` (with nonnegative integer exponent) should be assumed to work
    with arbitrary domain elements. All other operations should be accessed as functions
    from the [`Domain`](domainsref.html#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")
    object:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，预计将与任意域中的元素一起使用的代码不应使用除法运算符`/`，`//`和`%`。只有运算符`+`，`-`，`*`和`**`（带非负整数指数）应假定可用于任意域元素。所有其他操作应作为[`Domain`](domainsref.html#sympy.polys.domains.domain.Domain
    "sympy.polys.domains.domain.Domain")对象的函数访问：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The [`exquo()`](domainsref.html#sympy.polys.domains.domain.Domain.exquo "sympy.polys.domains.domain.Domain.exquo")
    function is used to compute an exact quotient. This is the analogue of `a / b`
    but where the division is expected to be exact (with no remainder) or an error
    will be raised:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[`exquo()`](domainsref.html#sympy.polys.domains.domain.Domain.exquo "sympy.polys.domains.domain.Domain.exquo")函数用于计算精确商。这类似于`a
    / b`，但预计除法是精确的（没有余数），否则将引发错误：'
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The exact methods and attributes of the domain elements are not guaranteed
    in general beyond the basic arithmetic operations. It should not be presumed that
    e.g. [ZZ](domainsref.html#zz) will always be of type `int`. If `gmpy` or `gmpy2`
    is installed then the `mpz` or `mpq` types are used instead for [ZZ](domainsref.html#zz)
    and [QQ](domainsref.html#qq):'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，不能保证域元素的确切方法和属性超出基本算术运算。不应假定例如[ZZ](domainsref.html#zz)总是类型为`int`。如果安装了`gmpy`或`gmpy2`，则使用`mpz`或`mpq`类型而不是[ZZ](domainsref.html#zz)和[QQ](domainsref.html#qq)的纯Python实现：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `mpz` type is faster than Python’s standard `int` type for operations with
    large integers although for smaller integers the difference is not so significant.
    The `mpq` type representing rational numbers is implemented in C rather than Python
    and is many times faster than the pure Python implementation of [QQ](domainsref.html#qq)
    that is used when gmpy is not installed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`mpz`类型在大整数操作中比Python标准`int`类型更快，尽管对于较小整数，差异不那么显著。代表有理数的`mpq`类型在C中实现，而不是Python，并且比未安装gmpy时使用的[QQ](domainsref.html#qq)的纯Python实现快几倍。'
- en: 'In general the Python type used for the elements of a domain can be checked
    from the [`dtype`](domainsref.html#sympy.polys.domains.domain.Domain.dtype "sympy.polys.domains.domain.Domain.dtype")
    attribute of the domain. When gmpy is installed the dtype for [ZZ](domainsref.html#zz)
    is \(mpz\) which is not an actual type and can not be used with \(isinstance\).
    For this reason the [`of_type()`](domainsref.html#sympy.polys.domains.domain.Domain.of_type
    "sympy.polys.domains.domain.Domain.of_type") method can be used to check if an
    object is an element of [`dtype`](domainsref.html#sympy.polys.domains.domain.Domain.dtype
    "sympy.polys.domains.domain.Domain.dtype").:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以从域的[`dtype`](domainsref.html#sympy.polys.domains.domain.Domain.dtype "sympy.polys.domains.domain.Domain.dtype")属性检查元素的Python类型。安装gmpy时，[ZZ](domainsref.html#zz)的dtype为\(mpz\)，这不是实际类型，不能与\(isinstance\)一起使用。因此，可以使用[`of_type()`](domainsref.html#sympy.polys.domains.domain.Domain.of_type
    "sympy.polys.domains.domain.Domain.of_type")方法检查对象是否为[`dtype`](domainsref.html#sympy.polys.domains.domain.Domain.dtype
    "sympy.polys.domains.domain.Domain.dtype")的元素：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Domain elements vs sympy expressions
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 域元素与sympy表达式
- en: 'Note that domain elements are not of the same type as ordinary sympy expressions
    which are subclasses of [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    such as [`Integer`](../core.html#sympy.core.numbers.Integer "sympy.core.numbers.Integer").
    Ordinary sympy expressions are created with the [`sympify()`](../core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") function.:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，域元素与普通sympy表达式不是相同类型，后者是[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")的子类，如[`Integer`](../core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer")。普通sympy表达式通过[`sympify()`](../core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify")函数创建：
- en: '[PRE20]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'It is important when working with the domains not to mix sympy expressions
    with domain elements even though it will sometimes work in simple cases. Each
    domain object has the methods [`to_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.to_sympy
    "sympy.polys.domains.domain.Domain.to_sympy") and [`from_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.from_sympy
    "sympy.polys.domains.domain.Domain.from_sympy") for converting back and forth
    between sympy expressions and domain elements:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用域时，重要的是不要将 sympy 表达式与域元素混合使用，即使在简单情况下有时可能会有效。每个域对象都有方法 [`to_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.to_sympy
    "sympy.polys.domains.domain.Domain.to_sympy") 和 [`from_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.from_sympy
    "sympy.polys.domains.domain.Domain.from_sympy") 用于在 sympy 表达式和域元素之间进行转换：
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Any particular domain will only be able to represent some sympy expressions
    so conversion will fail if the expression can not be represented in the domain:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 任何特定的域只能表示一些 sympy 表达式，因此如果表达式不能在域中表示，则转换将失败：
- en: '[PRE22]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We have already seen that in some cases we can use the domain object itself
    as a constructor e.g. `QQ(2)`. This will generally work provided the arguments
    given are valid for the [`dtype`](domainsref.html#sympy.polys.domains.domain.Domain.dtype
    "sympy.polys.domains.domain.Domain.dtype") of the domain. Although it is convenient
    to use this in interactive sessions and in demonstrations it is generally better
    to use the [`from_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.from_sympy
    "sympy.polys.domains.domain.Domain.from_sympy") method for constructing domain
    elements from sympy expressions (or from objects that can be sympified to sympy
    expressions).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，在某些情况下，我们可以使用域对象本身作为构造函数，例如 `QQ(2)`。只要给定的参数对于域的 [`dtype`](domainsref.html#sympy.polys.domains.domain.Domain.dtype
    "sympy.polys.domains.domain.Domain.dtype") 是有效的，通常这样做是有效的。尽管在交互式会话和演示中使用这种方法很方便，但通常最好使用
    [`from_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.from_sympy
    "sympy.polys.domains.domain.Domain.from_sympy") 方法从 sympy 表达式（或可以 sympify 为 sympy
    表达式的对象）构造域元素。
- en: It is important not to mix domain elements with other Python types such as `int`,
    `float`, as well as standard sympy [`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") expressions. When working in a domain, care should be
    taken as some Python operations will do this implicitly. for example the `sum`
    function will use the regular `int` value of zero so that `sum([a, b])` is effectively
    evaluated as `(0 + a) + b` where `0` is of type `int`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在域中工作时，重要的是不要将域元素与其他 Python 类型（如 `int`、`float`）以及标准的 sympy [`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") 表达式混合使用。需要注意的是，某些 Python 操作将会在不经意间执行此操作。例如，`sum` 函数将使用常规的
    `int` 值零，因此 `sum([a, b])` 实际上会被计算为 `(0 + a) + b`，其中 `0` 的类型是 `int`。
- en: 'Every domain is at least a ring if not a field and as such is guaranteed to
    have two elements in particular corresponding to \(1\) and \(0\). The domain object
    provides domain elements for these as the attributes [`one`](domainsref.html#sympy.polys.domains.domain.Domain.one
    "sympy.polys.domains.domain.Domain.one") and [`zero`](domainsref.html#sympy.polys.domains.domain.Domain.zero
    "sympy.polys.domains.domain.Domain.zero"). These are useful for something like
    Python’s `sum` function which allows to provide an alternative object as the “zero”:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 每个域至少是一个环，如果不是一个域，那么它保证具有两个特定元素，分别对应于 \(1\) 和 \(0\)。域对象提供这些作为属性的域元素 [`one`](domainsref.html#sympy.polys.domains.domain.Domain.one
    "sympy.polys.domains.domain.Domain.one") 和 [`zero`](domainsref.html#sympy.polys.domains.domain.Domain.zero
    "sympy.polys.domains.domain.Domain.zero")。这些对于像 Python 的 `sum` 函数非常有用，该函数允许提供一个替代对象作为“零”：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A standard pattern then for performing calculations in a domain is:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在域中执行计算的标准模式如下：
- en: Start with sympy [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    instances representing expressions.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 sympy [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr") 实例开始，表示表达式。
- en: Choose an appropriate domain that can represent the expressions.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个能够表示表达式的适当域。
- en: Convert all expressions to domain elements using [`from_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.from_sympy
    "sympy.polys.domains.domain.Domain.from_sympy").
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [`from_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.from_sympy
    "sympy.polys.domains.domain.Domain.from_sympy") 将所有表达式转换为域元素。
- en: Perform the calculation with the domain elements.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用域元素执行计算。
- en: Convert back to [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    with [`to_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.to_sympy
    "sympy.polys.domains.domain.Domain.to_sympy").
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [`to_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.to_sympy
    "sympy.polys.domains.domain.Domain.to_sympy") 将转换回 [`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")。
- en: 'Here is an implementation of the `sum` function that illustrates these steps
    and sums some integers but performs the calculation using the domain elements
    rather than standard sympy expressions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`sum`函数的实现示例，说明了这些步骤并对一些整数求和，但是使用了域元素而不是标准的sympy表达式进行计算：
- en: '[PRE24]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Gaussian integers and Gaussian rationals
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高斯整数和高斯有理数
- en: 'The two example domains that we have seen so far are [ZZ](domainsref.html#zz)
    and [QQ](domainsref.html#qq) representing the integers and the rationals respectively.
    There are other simple domains such as [ZZ_I](domainsref.html#zz-i) and [QQ_I](domainsref.html#qq-i)
    representing the [Gaussian integers](https://en.wikipedia.org/wiki/Gaussian_integer)
    and [Gaussian rationals](https://en.wikipedia.org/wiki/Gaussian_rational). The
    Gaussian integers are numbers of the form \(a\sqrt{-1} + b\) where \(a\) and \(b\)
    are integers. The Gaussian rationals are defined similarly except that \(a\) and
    \(b\) can be rationals. We can use the Gaussian domains like:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们见过的两个示例域是 [ZZ](domainsref.html#zz) 和 [QQ](domainsref.html#qq)，分别表示整数和有理数。还有其他简单的域，如
    [ZZ_I](domainsref.html#zz-i) 和 [QQ_I](domainsref.html#qq-i)，分别表示[高斯整数](https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%95%B0)和[高斯有理数](https://zh.wikipedia.org/wiki/%E9%AB%98%E6%96%AF%E6%95%B0%E6%9D%A1)。高斯整数是形如
    \(a\sqrt{-1} + b\) 的数，其中 \(a\) 和 \(b\) 是整数。高斯有理数类似地定义，不同之处在于 \(a\) 和 \(b\) 可以是有理数。我们可以像这样使用高斯域：
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note the contrast with the way this calculation works in the tree representation
    where [`expand()`](../core.html#sympy.core.function.expand "sympy.core.function.expand")
    is needed to get the reduced form:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意与树形表示中计算方式的对比，需要使用 [`expand()`](../core.html#sympy.core.function.expand "sympy.core.function.expand")
    来获得简化形式：
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The [ZZ_I](domainsref.html#zz-i) and [QQ_I](domainsref.html#qq-i) domains are
    implemented by the classes [`GaussianIntegerRing`](domainsref.html#sympy.polys.domains.gaussiandomains.GaussianIntegerRing
    "sympy.polys.domains.gaussiandomains.GaussianIntegerRing") and [`GaussianRationalField`](domainsref.html#sympy.polys.domains.gaussiandomains.GaussianRationalField
    "sympy.polys.domains.gaussiandomains.GaussianRationalField") and their elements
    by [`GaussianInteger`](domainsref.html#sympy.polys.domains.gaussiandomains.GaussianInteger
    "sympy.polys.domains.gaussiandomains.GaussianInteger") and [`GaussianRational`](domainsref.html#sympy.polys.domains.gaussiandomains.GaussianRational
    "sympy.polys.domains.gaussiandomains.GaussianRational") respectively. The internal
    representation for an element of [ZZ_I](domainsref.html#zz-i) or [QQ_I](domainsref.html#qq-i)
    is simply as a pair `(a, b)` of elements of [ZZ](domainsref.html#zz) or [QQ](domainsref.html#qq)
    respectively. The domain [ZZ_I](domainsref.html#zz-i) is a ring with similar properties
    to [ZZ](domainsref.html#zz) whereas [QQ_I](domainsref.html#qq-i) is a field much
    like [QQ](domainsref.html#qq):'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[ZZ_I](domainsref.html#zz-i) 和 [QQ_I](domainsref.html#qq-i) 域由类 [`GaussianIntegerRing`](domainsref.html#sympy.polys.domains.gaussiandomains.GaussianIntegerRing
    "sympy.polys.domains.gaussiandomains.GaussianIntegerRing") 和 [`GaussianRationalField`](domainsref.html#sympy.polys.domains.gaussiandomains.GaussianRationalField
    "sympy.polys.domains.gaussiandomains.GaussianRationalField") 实现，它们的元素分别由 [`GaussianInteger`](domainsref.html#sympy.polys.domains.gaussiandomains.GaussianInteger
    "sympy.polys.domains.gaussiandomains.GaussianInteger") 和 [`GaussianRational`](domainsref.html#sympy.polys.domains.gaussiandomains.GaussianRational
    "sympy.polys.domains.gaussiandomains.GaussianRational") 表示。在 [ZZ_I](domainsref.html#zz-i)
    或 [QQ_I](domainsref.html#qq-i) 的内部表示中，一个元素简单地是 `(a, b)`，其中 `a` 和 `b` 分别是 [ZZ](domainsref.html#zz)
    或 [QQ](domainsref.html#qq) 的元素。域 [ZZ_I](domainsref.html#zz-i) 是一个与 [ZZ](domainsref.html#zz)
    类似属性的环，而 [QQ_I](domainsref.html#qq-i) 则像 [QQ](domainsref.html#qq) 一样是一个域：'
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Since [QQ_I](domainsref.html#qq-i) is a field division by nonzero elements
    is always possible whereas in [ZZ_I](domainsref.html#zz-i) we have the important
    concept of the greatest common divisor (GCD):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 [QQ_I](domainsref.html#qq-i) 是一个域，非零元素总是可以进行除法，而在 [ZZ_I](domainsref.html#zz-i)
    中我们有最大公约数（GCD）的重要概念：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Finite fields
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有限域
- en: 'So far we have seen the domains [ZZ](domainsref.html#zz), [QQ](domainsref.html#qq),
    [ZZ_I](domainsref.html#zz-i), and [QQ_I](domainsref.html#qq-i). There are also
    domains representing the [Finite fields](https://en.wikipedia.org/wiki/Finite_field)
    although the implementation of these is incomplete. A finite field [GF(p)](domainsref.html#gf-p)
    of *prime* order can be constructed with `FF` or `GF`. A domain for the finite
    field of prime order \(p\) can be constructed with [GF(p)](domainsref.html#gf-p):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到了域 [ZZ](domainsref.html#zz), [QQ](domainsref.html#qq), [ZZ_I](domainsref.html#zz-i)
    和 [QQ_I](domainsref.html#qq-i)。还有代表 [有限域](https://zh.wikipedia.org/wiki/有限域) 的领域，尽管这些的实现尚不完整。可以用
    `FF` 或 `GF` 构建一个素数阶有限域 [GF(p)](domainsref.html#gf-p)。可以用 [GF(p)](domainsref.html#gf-p)
    构建一个素数阶有限域 \(p\) 的领域：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: There is also `FF` as an alias for `GF` (standing for “finite field” and “Galois
    field” respectively). These are equivalent and both `FF(n)` and `GF(n)` will create
    a domain which is an instance of [`FiniteField`](domainsref.html#sympy.polys.domains.FiniteField
    "sympy.polys.domains.FiniteField"). The associated domain elements will be instances
    of [`PythonFiniteField`](domainsref.html#sympy.polys.domains.PythonFiniteField
    "sympy.polys.domains.PythonFiniteField") or [`GMPYFiniteField`](domainsref.html#sympy.polys.domains.GMPYFiniteField
    "sympy.polys.domains.GMPYFiniteField") depending on whether or not `gmpy` is installed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`FF` 也是 `GF` 的别名（分别代表“有限域”和“伽罗瓦域”）。它们是等效的，`FF(n)` 和 `GF(n)` 都将创建一个领域，该领域是 [`FiniteField`](domainsref.html#sympy.polys.domains.FiniteField
    "sympy.polys.domains.FiniteField") 的实例。关联的领域元素将是 [`PythonFiniteField`](domainsref.html#sympy.polys.domains.PythonFiniteField
    "sympy.polys.domains.PythonFiniteField") 或 [`GMPYFiniteField`](domainsref.html#sympy.polys.domains.GMPYFiniteField
    "sympy.polys.domains.GMPYFiniteField") 的实例，具体取决于是否安装了 `gmpy`。'
- en: 'Finite fields of order \(p^n\) where \(n \ne 1\) are not implemented. It is
    possible to use e.g. `GF(6)` or `GF(9)` but the resulting domain is *not* a field.
    It is just the integers modulo `6` or `9` and therefore has zero divisors and
    non-invertible elements:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 有限阶域 \(p^n\) （其中 \(n \ne 1\)）尚未实现。可以使用例如 `GF(6)` 或 `GF(9)`，但得到的领域*不*是一个域。它只是模
    `6` 或 `9` 的整数集，因此具有零除数和非可逆元素：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: It would be good to have a proper implementation of prime-power order finite
    fields but this is not yet available in SymPy (contributions welcome!).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 很高兴看到对素数幂次有限域的适当实现，但目前在 SymPy 中尚不可用（欢迎贡献！）。
- en: Real and complex fields
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实数域和复数域
- en: 'The fields [RR](domainsref.html#rr) and [CC](domainsref.html#cc) are intended
    mathematically to correspond to the [reals](https://en.wikipedia.org/wiki/Real_number)
    and the [complex numbers](https://en.wikipedia.org/wiki/Complex_number), \(\mathbb{R}\)
    and \(\mathbb{C}\) respectively. The implementation of these uses floating point
    arithmetic. In practice this means that these are the domains that are used to
    represent expressions containing floats. Elements of [RR](domainsref.html#rr)
    are instances of the class [`RealElement`](domainsref.html#sympy.polys.domains.mpelements.RealElement
    "sympy.polys.domains.mpelements.RealElement") and have an `mpf` tuple which is
    used to represent a float in `mpmath`. Elements of [CC](domainsref.html#cc) are
    instances of [`ComplexElement`](domainsref.html#sympy.polys.domains.mpelements.ComplexElement
    "sympy.polys.domains.mpelements.ComplexElement") and have an `mpc` tuple which
    is a pair of `mpf` tuples representing the real and imaginary parts. See the [mpmath
    docs](https://mpmath.org/doc/current/technical.html#representation-of-numbers)
    for more about how floating point numbers are represented:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 域 [RR](domainsref.html#rr) 和 [CC](domainsref.html#cc) 在数学上分别对应于 [实数](https://zh.wikipedia.org/wiki/实数)
    和 [复数](https://zh.wikipedia.org/wiki/复数)，\(\mathbb{R}\) 和 \(\mathbb{C}\)。这些的实现使用浮点数运算。在实践中，这意味着这些领域用于表示包含浮点数的表达式。域
    [RR](domainsref.html#rr) 的元素是 [`RealElement`](domainsref.html#sympy.polys.domains.mpelements.RealElement
    "sympy.polys.domains.mpelements.RealElement") 类的实例，并具有用于表示 `mpmath` 中浮点数的 `mpf`
    元组。域 [CC](domainsref.html#cc) 的元素是 [`ComplexElement`](domainsref.html#sympy.polys.domains.mpelements.ComplexElement
    "sympy.polys.domains.mpelements.ComplexElement") 类的实例，并具有表示实部和虚部的 `mpf` 元组对。有关浮点数的表示方式，请参阅
    [mpmath 文档](https://mpmath.org/doc/current/technical.html#representation-of-numbers)：
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The use of approximate floating point arithmetic in these domains comes with
    all of the usual pitfalls. Many algorithms in the [`sympy.polys`](reference.html#module-sympy.polys
    "sympy.polys") module are fundamentally designed for exact arithmetic making the
    use of these domains potentially problematic:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些域中使用近似浮点算术会带来所有通常的问题。[`sympy.polys`](reference.html#module-sympy.polys "sympy.polys")模块中的许多算法基本上是为精确算术而设计的，因此使用这些域可能会有问题：
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since these are implemented using `mpmath` which is a multiprecision library
    it is possible to create different domains with different working precisions.
    The default domains [RR](domainsref.html#rr) and [CC](domainsref.html#cc) use
    53 binary digits of precision much like standard [double precision](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)
    floating point which corresponds to approximately 15 decimal digits:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是使用`mpmath`（一个多精度库）实现的，因此可以使用不同的工作精度创建不同的域。默认域[RR](domainsref.html#rr)和[CC](domainsref.html#cc)使用53位二进制精度，类似于标准的[双精度](https://en.wikipedia.org/wiki/Double-precision_floating-point_format)浮点数，对应于大约15位十进制数字：
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'There is however a bug in the implementation of this so that actually a global
    precision setting is used by all [`RealElement`](domainsref.html#sympy.polys.domains.mpelements.RealElement
    "sympy.polys.domains.mpelements.RealElement"). This means that just creating `RR100`
    above has altered the global precision and we will need to restore it in the doctest
    here:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这里的实现存在一个bug，实际上所有[`RealElement`](domainsref.html#sympy.polys.domains.mpelements.RealElement
    "sympy.polys.domains.mpelements.RealElement")都使用了全局精度设置。这意味着刚刚创建的`RR100`已经改变了全局精度，我们需要在这里的doctest中恢复它：
- en: '[PRE34]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: (Obviously that should be fixed!)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: （显然，这应该被修复！）
- en: Algebraic number fields
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代数数域
- en: An [algebraic extension](https://en.wikipedia.org/wiki/Algebraic_extension)
    of the rationals \(\mathbb{Q}\) is known as an [algebraic number field](https://en.wikipedia.org/wiki/Algebraic_number_field)
    and these are implemented in sympy as [QQ<a>](domainsref.html#qq-a). The natural
    syntax for these would be something like `QQ(sqrt(2))` however `QQ()` is already
    overloaded as the constructor for elements of [QQ](domainsref.html#qq). These
    domains are instead created using the [`algebraic_field()`](domainsref.html#sympy.polys.domains.domain.Domain.algebraic_field
    "sympy.polys.domains.domain.Domain.algebraic_field") method e.g. `QQ.algebraic_field(sqrt(2))`.
    The resulting domain will be an instance of [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") with elements that are instances of [`ANP`](domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP").
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[有理数](https://en.wikipedia.org/wiki/有理数的代数扩张)的[代数扩张](https://en.wikipedia.org/wiki/Algebraic_number_field)称为[代数数域](https://en.wikipedia.org/wiki/Algebraic_number_field)，在sympy中实现为[QQ<a>](domainsref.html#qq-a)。这些的自然语法应该类似于`QQ(sqrt(2))`，但是`QQ()`已经被重载为[QQ](domainsref.html#qq)元素的构造函数。这些域可以使用[`algebraic_field()`](domainsref.html#sympy.polys.domains.domain.Domain.algebraic_field
    "sympy.polys.domains.domain.Domain.algebraic_field")方法创建，例如`QQ.algebraic_field(sqrt(2))`。所得到的域将是[`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField")的一个实例，其元素为[`ANP`](domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP")的实例。'
- en: 'The printing support for these is less developed but we can use [`to_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.to_sympy
    "sympy.polys.domains.domain.Domain.to_sympy") to take advantage of the corresponding
    [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr") printing support:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些的打印支持较少，但我们可以使用[`to_sympy()`](domainsref.html#sympy.polys.domains.domain.Domain.to_sympy
    "sympy.polys.domains.domain.Domain.to_sympy")来利用对应的[`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")打印支持：
- en: '[PRE35]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The raw printed display immediately shows the internal representation of the
    elements as [`ANP`](domainsref.html#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")
    instances. The field \(\mathbb{Q}(\sqrt{2})\) consists of numbers of the form
    \(a\sqrt{2}+b\) where \(a\) and \(b\) are rational numbers. Consequently every
    number in this field can be represented as a pair `(a, b)` of elements of [QQ](domainsref.html#qq).
    The domain element stores these two in a list and also stores a list representation
    of the *minimal polynomial* for the extension element \(\sqrt{2}\). There is a
    sympy function [`minpoly()`](numberfields.html#sympy.polys.numberfields.minpoly.minpoly
    "sympy.polys.numberfields.minpoly.minpoly") that can compute the minimal polynomial
    of any algebraic expression over the rationals:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 原始打印显示立即显示了元素的内部表示，作为[`ANP`](domainsref.html#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")实例。域\(\mathbb{Q}(\sqrt{2})\)由形如\(a\sqrt{2}+b\)的数构成，其中\(a\)和\(b\)是有理数。因此，这个域中的每个数可以表示为一对`(a,
    b)`，它们是[QQ](domainsref.html#qq)元素的元素。域元素将这两个元素存储在列表中，并且还存储扩展元素\(\sqrt{2}\)的*最小多项式*的列表表示。有一个sympy函数[`minpoly()`](numberfields.html#sympy.polys.numberfields.minpoly.minpoly
    "sympy.polys.numberfields.minpoly.minpoly")可以计算有理数上任意代数表达式的最小多项式：
- en: '[PRE36]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the dense polynomial representation as a list of coefficients this polynomial
    is represented as `[1, 0, -2]` as seen in the [`ANP`](domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP") display for the elements of `QQ<sqrt(2)>` above.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在作为系数列表的稠密多项式表示中，该多项式如上所示为`[1, 0, -2]`，如[`ANP`](domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP")中`QQ<sqrt(2)>`元素的显示。
- en: 'It is also possible to create an algebraic number field with multiple generators
    such as \(\mathbb{Q}(\sqrt{2},\sqrt{3})\):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以创建具有多个生成元的代数数域，例如\(\mathbb{Q}(\sqrt{2},\sqrt{3})\)：
- en: '[PRE37]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Here the algebraic extension \(\mathbb{Q}(\sqrt{2},\sqrt{3})\) is converted
    to the (isomorphic) \(\mathbb{Q}(\sqrt{2}+\sqrt{3})\) with a single generator
    \(\sqrt{2}+\sqrt{3}\). It is always possible to find a single generator like this
    due to the [primitive element theorem](https://en.wikipedia.org/wiki/Primitive_element_theorem).
    There is a sympy function [`primitive_element()`](numberfields.html#sympy.polys.numberfields.subfield.primitive_element
    "sympy.polys.numberfields.subfield.primitive_element") that can compute the minimal
    polynomial for a primitive element of an extension:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的代数扩展\(\mathbb{Q}(\sqrt{2},\sqrt{3})\)被转换为（同构的）\(\mathbb{Q}(\sqrt{2}+\sqrt{3})\)，具有单个生成元\(\sqrt{2}+\sqrt{3}\)。由于[原始元定理](https://en.wikipedia.org/wiki/Primitive_element_theorem)，总是可以找到类似这样的单一生成元。有一个sympy函数[`primitive_element()`](numberfields.html#sympy.polys.numberfields.subfield.primitive_element
    "sympy.polys.numberfields.subfield.primitive_element")，可以计算扩展的原始元的最小多项式：
- en: '[PRE38]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The minimal polynomial `x**4 - 10*x**2 + 1` has the dense list representation
    `[1, 0, -10, 0, 1]` as seen in the [`ANP`](domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP") output above. What the primitive element theorem
    means is that all algebraic number fields can be represented as an extension of
    the rationals by a single generator with some minimal polynomial. Calculations
    over the algebraic number field only need to take advantage of the minimal polynomial
    and that makes it possible to compute all arithmetic operations and also to carry
    out higher level operations like factorisation of polynomials.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 最小多项式`x**4 - 10*x**2 + 1`具有密集列表表示`[1, 0, -10, 0, 1]`，如上述[`ANP`](domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP")输出。原始元定理的含义是，所有代数数域都可以表示为有某个最小多项式的有理数扩展。在代数数域上的计算只需利用最小多项式，这使得可以计算所有算术操作，还可以进行如多项式因式分解等更高级别的操作。
- en: Polynomial ring domains
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项式环域
- en: 'There are also domains implemented to represent a polynomial ring like [K[x]](domainsref.html#k-x)
    which is the domain of polynomials in the generator `x` with coefficients over
    another domain `K`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式环也实现了表示像[K[x]](domainsref.html#k-x)这样的环，其中`K`域中的系数是生成元`x`的多项式：
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'All the operations discussed before will work with elements of a polynomial
    ring:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所有前述讨论的操作都适用于多项式环的元素：
- en: '[PRE40]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The internal representation of elements of `K[x]` is different from the way
    that ordinary sympy ([`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr"))
    expressions are represented. The [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    representation of any expression is as a tree e.g.:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`K[x]`的元素的内部表示不同于普通sympy（[`Expr`](../core.html#sympy.core.expr.Expr)）表达式的表示方式。任何表达式的[`Expr`](../core.html#sympy.core.expr.Expr)表示都是作为一个树，例如：'
- en: '[PRE41]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here the expression is a tree where the top node is an [`Add`](../core.html#sympy.core.add.Add
    "sympy.core.add.Add") and its children nodes are [`Pow`](../core.html#sympy.core.power.Pow
    "sympy.core.power.Pow") etc. This tree representation makes it possible to represent
    equivalent expressions in different ways e.g.:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这里表达式是一个树，顶部节点是[`Add`](../core.html#sympy.core.add.Add)，其子节点是[`Pow`](../core.html#sympy.core.power.Pow)等。这种树形表示使得可以以不同的方式表示等价表达式，例如：
- en: '[PRE42]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'By contrast the domain `ZZ[x]` represents only polynomials and does so by simply
    storing the non-zero coefficients of the expanded polynomial (the “sparse” polynomial
    representation). In particular elements of `ZZ[x]` are represented as a Python
    `dict`. Their type is [`PolyElement`](domainsref.html#sympy.polys.rings.PolyElement
    "sympy.polys.rings.PolyElement") which is a subclass of `dict`. Converting to
    a normal dict shows the internal representation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 对比之下，域`ZZ[x]`仅表示多项式，并通过简单地存储展开多项式的非零系数来实现（“稀疏”多项式表示）。特别地，`ZZ[x]`的元素被表示为Python
    `dict`。它们的类型是[`PolyElement`](domainsref.html#sympy.polys.rings.PolyElement)，它是`dict`的一个子类。将其转换为普通的`dict`显示内部表示：
- en: '[PRE43]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This internal form makes it impossible to represent unexpanded multiplications
    so any multiplication of elements of `ZZ[x]` will always be expanded:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种内部形式使得无法表示未展开的乘法，因此`ZZ[x]`元素的任何乘法都将被展开：
- en: '[PRE44]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'These same considerations apply to powers:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这些相同的考虑也适用于幂次：
- en: '[PRE45]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We can also construct multivariate polynomial rings:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以构造多变量多项式环：
- en: '[PRE46]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It is also possible to construct nested polynomial rings (although it is less
    efficient). The ring `K[x][y]` is formally equivalent to `K[x,y]` although their
    implementations in sympy are different:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以构造嵌套的多项式环（尽管效率较低）。环`K[x][y]`在形式上等价于`K[x,y]`，尽管它们在sympy中的实现不同：
- en: '[PRE47]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Here the coefficients like `x**2` are instances of [`PolyElement`](domainsref.html#sympy.polys.rings.PolyElement
    "sympy.polys.rings.PolyElement") as well so this is a `dict` where the values
    are also dicts. The full representation is more like:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这里像`x**2`这样的系数也是[`PolyElement`](domainsref.html#sympy.polys.rings.PolyElement)的实例，因此这是一个`dict`，其中值也是`dict`。完整的表示更像是：
- en: '[PRE48]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The multivariate ring domain `ZZ[x,y]` has a more efficient representation
    as a single flattened `dict`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 多变量环域`ZZ[x,y]`作为一个单一扁平化的`dict`有更高效的表示：
- en: '[PRE49]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: The difference in efficiency between these representations grows as the number
    of generators increases i.e. `ZZ[x,y,z,t,...]` vs `ZZ[x][y][z][t]...`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表示方式之间的效率差异随生成器数量的增加而增大，即`ZZ[x,y,z,t,...]`与`ZZ[x][y][z][t]...`。
- en: Old (dense) polynomial rings
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 旧（密集）多项式环
- en: 'In the last section we saw that the domain representation of a polynomial ring
    like [K[x]](domainsref.html#k-x) uses a sparse representation of a polynomial
    as a dict mapping monomial exponents to coefficients. There is also an older version
    of [K[x]](domainsref.html#k-x) that uses the dense [DMP representation](#dmp-representation).
    We can create these two versions of [K[x]](domainsref.html#k-x) using [`poly_ring()`](domainsref.html#sympy.polys.domains.domain.Domain.poly_ring
    "sympy.polys.domains.domain.Domain.poly_ring") and [`old_poly_ring()`](domainsref.html#sympy.polys.domains.domain.Domain.old_poly_ring
    "sympy.polys.domains.domain.Domain.old_poly_ring") where the syntax `K[x]` is
    equivalent to `K.poly_ring(x)`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到多项式环如[K[x]](domainsref.html#k-x)的域表示使用了将单项式指数映射到系数的稀疏多项式表示。还有一个使用密集[DMP表示](#dmp-representation)的[K[x]](domainsref.html#k-x)的旧版本。我们可以使用[`poly_ring()`](domainsref.html#sympy.polys.domains.domain.Domain.poly_ring)和[`old_poly_ring()`](domainsref.html#sympy.polys.domains.domain.Domain.old_poly_ring)创建这两个版本的[K[x]](domainsref.html#k-x)，其中语法`K[x]`等同于`K.poly_ring(x)`：
- en: '[PRE50]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The internal representation of the old polynomial ring domain is the [`DMP`](domainsref.html#sympy.polys.polyclasses.DMP
    "sympy.polys.polyclasses.DMP") representation as a list of (lists of) coefficients:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 旧多项式环域的内部表示是[`DMP`](domainsref.html#sympy.polys.polyclasses.DMP)表示，作为（列表的）系数：
- en: '[PRE51]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The most notable use of the [`DMP`](domainsref.html#sympy.polys.polyclasses.DMP
    "sympy.polys.polyclasses.DMP") representation of polynomials is as the internal
    representation used by [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    (this is discussed later in this page of the docs).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式的[`DMP`](domainsref.html#sympy.polys.polyclasses.DMP "sympy.polys.polyclasses.DMP")表示法最显著的用途是作为[`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")内部表示（本文档后面会进一步讨论）。
- en: PolyRing vs PolynomialRing
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PolyRing vs PolynomialRing
- en: 'You might just want to perform calculations in some particular polynomial ring
    without being concerned with implementing something that works for arbitrary domains.
    In that case you can construct the ring more directly with the [`ring()`](domainsref.html#sympy.polys.rings.ring
    "sympy.polys.rings.ring") function:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能只是想在某个特定多项式环中执行计算，而不用担心为任意域实现某些功能。在这种情况下，你可以直接使用[`ring()`](domainsref.html#sympy.polys.rings.ring
    "sympy.polys.rings.ring")函数构造环：
- en: '[PRE52]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The object `K` here represents the ring and is an instance of [`PolyRing`](domainsref.html#sympy.polys.rings.PolyRing
    "sympy.polys.rings.PolyRing") but is not a **polys domain** (it is not an instance
    of a subclass of [`Domain`](domainsref.html#sympy.polys.domains.domain.Domain
    "sympy.polys.domains.domain.Domain") so it can not be used with [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")). In this way the implementation of polynomial rings
    that is used in the domain system can be used independently of the domain system.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的对象`K`表示环，并且是[`PolyRing`](domainsref.html#sympy.polys.rings.PolyRing "sympy.polys.rings.PolyRing")的一个实例，但不是**多项式域**（不是[`Domain`](domainsref.html#sympy.polys.domains.domain.Domain
    "sympy.polys.domains.domain.Domain")子类的实例，因此不能与[`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")一起使用）。这样，多项式环的实现可以独立于域系统使用。
- en: 'The purpose of the domain system is to provide a unified interface for working
    with and converting between different representations of expressions. To make
    the [`PolyRing`](domainsref.html#sympy.polys.rings.PolyRing "sympy.polys.rings.PolyRing")
    implementation usable in that context the [`PolynomialRing`](domainsref.html#sympy.polys.domains.PolynomialRing
    "sympy.polys.domains.PolynomialRing") class is a wrapper around the [`PolyRing`](domainsref.html#sympy.polys.rings.PolyRing
    "sympy.polys.rings.PolyRing") class that provides the interface expected in the
    domain system. That makes this implementation of polynomial rings usable as part
    of the broader codebase that is designed to work with expressions from different
    domains. The domain for polynomial rings is a distinct object from the ring returned
    by [`ring()`](domainsref.html#sympy.polys.rings.ring "sympy.polys.rings.ring")
    although both have the same elements:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 域系统的目的是提供一个统一的接口，用于处理和转换表达式的不同表示形式。为了使[`PolyRing`](domainsref.html#sympy.polys.rings.PolyRing
    "sympy.polys.rings.PolyRing")实现在这一背景下可用，[`PolynomialRing`](domainsref.html#sympy.polys.domains.PolynomialRing
    "sympy.polys.domains.PolynomialRing")类是对[`PolyRing`](domainsref.html#sympy.polys.rings.PolyRing
    "sympy.polys.rings.PolyRing")类的包装，提供了域系统期望的接口。这使得多项式环的此实现可用作设计用于处理来自不同域的表达式的更广泛代码库的一部分。多项式环的域是与由[`ring()`](domainsref.html#sympy.polys.rings.ring
    "sympy.polys.rings.ring")返回的环不同的对象，尽管它们都具有相同的元素：
- en: '[PRE53]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Rational function fields
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有理函数域
- en: 'Some domains are classified as fields and others are not. The principal difference
    between a field and a non-field domain is that in a field it is always possible
    to divide any element by any nonzero element. It is usually possible to convert
    any domain to a field that contains that domain with the [`get_field()`](domainsref.html#sympy.polys.domains.domain.Domain.get_field
    "sympy.polys.domains.domain.Domain.get_field") method:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 有些域被分类为域，而其他则不是。域与非域域之间的主要区别在于，在域中，总是可以用任何非零元素除以任何元素。通常可以通过[`get_field()`](domainsref.html#sympy.polys.domains.domain.Domain.get_field
    "sympy.polys.domains.domain.Domain.get_field")方法将任何域转换为包含该域的域：
- en: '[PRE54]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This introduces a new kind of domain [K(x)](domainsref.html#id11) representing
    a rational function field in the generator `x` over another domain `K`. It is
    not possible to construct the domain `QQ(x)` with the `()` syntax so the easiest
    ways to create it are using the domain methods [`frac_field()`](domainsref.html#sympy.polys.domains.domain.Domain.frac_field
    "sympy.polys.domains.domain.Domain.frac_field") (`QQ.frac_field(x)`) or [`get_field()`](domainsref.html#sympy.polys.domains.domain.Domain.get_field
    "sympy.polys.domains.domain.Domain.get_field") (`QQ[x].get_field()`). The [`frac_field()`](domainsref.html#sympy.polys.domains.domain.Domain.frac_field
    "sympy.polys.domains.domain.Domain.frac_field") method is the more direct approach.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这引入了一个新的域类型 [K(x)](domainsref.html#id11)，表示在另一个域 `K` 上生成器 `x` 的有理函数域。不可能使用 `()`
    语法构造域 `QQ(x)`，因此创建它的最简单方法是使用域方法 [`frac_field()`](domainsref.html#sympy.polys.domains.domain.Domain.frac_field
    "sympy.polys.domains.domain.Domain.frac_field") (`QQ.frac_field(x)`) 或 [`get_field()`](domainsref.html#sympy.polys.domains.domain.Domain.get_field
    "sympy.polys.domains.domain.Domain.get_field") (`QQ[x].get_field()`)。[`frac_field()`](domainsref.html#sympy.polys.domains.domain.Domain.frac_field
    "sympy.polys.domains.domain.Domain.frac_field") 方法是更直接的方法。
- en: 'The rational function field [K(x)](domainsref.html#id11) is an instance of
    [`RationalField`](domainsref.html#sympy.polys.domains.RationalField "sympy.polys.domains.RationalField").
    This domain represents functions of the form \(p(x) / q(x)\) for polynomials \(p\)
    and \(q\). The domain elements are represented as a pair of polynomials in [K[x]](domainsref.html#k-x):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 有理函数域 [K(x)](domainsref.html#id11) 是 [`RationalField`](domainsref.html#sympy.polys.domains.RationalField
    "sympy.polys.domains.RationalField") 的一个实例。该域表示形式为 \(p(x) / q(x)\) 的函数，其中 \(p\)
    和 \(q\) 是多项式。域元素表示为 [K[x]](domainsref.html#k-x) 中的一对多项式：
- en: '[PRE55]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Cancellation between the numerator and denominator is automatic in this field:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个域中分子和分母之间的约分是自动进行的：
- en: '[PRE56]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Computing this cancellation can be slow which makes rational function fields
    potentially slower than polynomial rings or algebraic fields.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 计算这种约分可能会很慢，这使得有理函数域可能比多项式环或代数域慢。
- en: 'Just like in the case of polynomial rings there is both a new (sparse) and
    old (dense) version of fraction fields:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 就像多项式环的情况一样，有分数域既有新（稀疏）版本也有旧（稠密）版本。
- en: '[PRE57]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Also just like in the case of polynomials rings the implementation of rational
    function fields can be used independently of the domain system:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 就像多项式环的情况一样，有理函数域的实现可以独立于域系统使用：
- en: '[PRE58]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Here `K` is an instance of [`FracField`](domainsref.html#sympy.polys.fields.FracField
    "sympy.polys.fields.FracField") rather than [`RationalField`](domainsref.html#sympy.polys.domains.RationalField
    "sympy.polys.domains.RationalField") as it would be for the domain `ZZ(x,y)`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `K` 是 [`FracField`](domainsref.html#sympy.polys.fields.FracField "sympy.polys.fields.FracField")
    的一个实例，而不是 [`RationalField`](domainsref.html#sympy.polys.domains.RationalField
    "sympy.polys.domains.RationalField")，后者适用于域 `ZZ(x,y)`。
- en: Expression domain
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表达式域
- en: 'The final domain to consider is the “expression domain” which is known as [EX](domainsref.html#ex).
    Expressions that can not be represented using the other domains can be always
    represented using the expression domain. An element of [EX](domainsref.html#ex)
    is actually just a wrapper around a [`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr") instance:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要考虑的域是“表达式域”，也称为 [EX](domainsref.html#ex)。使用其他域无法表示的表达式始终可以使用表达式域表示。[EX](domainsref.html#ex)
    的元素实际上只是 [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr") 实例的包装器：
- en: '[PRE59]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: For other domains the domain representation of expressions is usually more efficient
    than the tree representation used by [`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr"). In [EX](domainsref.html#ex) the internal representation
    is [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr") so it is
    clearly not more efficient. The purpose of the [EX](domainsref.html#ex) domain
    is to be able to wrap up arbitrary expressions in an interface that is consistent
    with the other domains. The [EX](domainsref.html#ex) domain is used as a fallback
    when an appropriate domain can not be found. Although this does not offer any
    particular efficiency it does allow the algorithms that are implemented to work
    over arbitrary domains to be usable when working with expressions that do not
    have an appropriate domain representation.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他域，表达式的域表示通常比由[`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")使用的树表示更有效。在[EX](domainsref.html#ex)中，内部表示是[`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")，因此显然不是更有效。[EX](domainsref.html#ex)域的目的是能够用与其他域一致的接口包装任意表达式。当找不到合适的域表示时，[EX](domainsref.html#ex)域作为备用使用。尽管这并未提供特定的效率，但允许实现的算法在处理没有适当域表示的表达式时仍可用。
- en: Choosing a domain
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一个域
- en: 'In the workflow described above the idea is to start with some sympy expressions,
    choose a domain and convert all the expressions into that domain in order to perform
    some calculation. The obvious question that arises is how to choose an appropriate
    domain to represent some sympy expressions. For this there is a function [`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain") which takes a list of expressions
    and will choose a domain and convert all of the expressions to that domain:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述描述的工作流程中，思路是从一些sympy表达式开始，选择一个域，并将所有表达式转换为该域，以便执行一些计算。显然产生的问题是如何选择适当的域来表示一些sympy表达式。为此，有一个函数[`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain")，它接受一个表达式列表，并将选择一个域并将所有表达式转换为该域：
- en: '[PRE60]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: In this example we see that the two integers `3` and `2` can be represented
    in the domain [ZZ](domainsref.html#zz). The expressions have been converted to
    elements of that domain which in this case means the `int` type rather than instances
    of [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr"). It is not
    necessary to explicitly create [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    instances when the inputs can be sympified so e.g. `construct_domain([3, 2])`
    would give the same output as above.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到两个整数`3`和`2`可以在域[ZZ](domainsref.html#zz)中表示。这些表达式已被转换为该域的元素，在这种情况下意味着`int`类型而不是[`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")的实例。当输入可以被sympify时，不需要显式创建[`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr")实例，因此例如`construct_domain([3, 2])`将给出与上述相同的输出。
- en: 'Given more complicated inputs [`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain") will choose more complicated domains:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 给定更复杂的输入，[`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain")将选择更复杂的域：
- en: '[PRE61]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: If any noninteger rational numbers are found in the inputs then the ground domain
    will be [QQ](domainsref.html#qq) rather than [ZZ](domainsref.html#zz). If any
    symbol is found in the inputs then a [`PolynomialRing`](domainsref.html#sympy.polys.domains.PolynomialRing
    "sympy.polys.domains.PolynomialRing") will be created. A multivariate polynomial
    ring such as `QQ[x,y]` can also be created if there are multiple symbols in the
    inputs. If any symbols appear in the denominators then a [`RationalField`](domainsref.html#sympy.polys.domains.RationalField
    "sympy.polys.domains.RationalField") like `QQ(x)` will be created instead.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在输入中发现任何非整数有理数，则基础域将是[QQ](domainsref.html#qq)而不是[ZZ](domainsref.html#zz)。如果输入中发现任何符号，则将创建一个[`PolynomialRing`](domainsref.html#sympy.polys.domains.PolynomialRing
    "sympy.polys.domains.PolynomialRing")。如果输入中有多个符号，则还可以创建一个多变量多项式环如`QQ[x,y]`。如果分母中出现任何符号，则将创建一个[`RationalField`](domainsref.html#sympy.polys.domains.RationalField
    "sympy.polys.domains.RationalField")，例如`QQ(x)`。
- en: 'Some of the domains above are fields and others are (non-field) rings. In some
    contexts it is necessary to have a field domain so that division is possible and
    for this [`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain") has an option `field=True` which will
    force the construction of a field domain even if the expressions can all be represented
    in a non-field ring:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 上述一些领域是域，其他则是（非域）环。在某些情境下，需要一个域领域，以便进行除法操作，为此[`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain") 提供了一个`field=True`选项，即使表达式可以在非域环中表示，也将强制构造一个域领域：
- en: '[PRE62]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'By default [`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain") will not construct an algebraic extension
    field and will instead use the [EX](domainsref.html#ex) domain ([`ExpressionDomain`](domainsref.html#sympy.polys.domains.ExpressionDomain
    "sympy.polys.domains.ExpressionDomain")). The keyword argument `extension=True`
    can be used to construct an [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") if the inputs are irrational but algebraic:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，[`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain") 不会构造代数扩展域，而是使用[EX](domainsref.html#ex)域（[`ExpressionDomain`](domainsref.html#sympy.polys.domains.ExpressionDomain
    "sympy.polys.domains.ExpressionDomain")）。关键字参数 `extension=True` 可用于构造一个[`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField")，如果输入是无理但代数的。
- en: '[PRE63]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When there are algebraically independent transcendentals in the inputs a [`PolynomialRing`](domainsref.html#sympy.polys.domains.PolynomialRing
    "sympy.polys.domains.PolynomialRing") or [`RationalField`](domainsref.html#sympy.polys.domains.RationalField
    "sympy.polys.domains.RationalField") will be constructed treating those transcendentals
    as generators:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入中存在代数独立的超越元素时，将构造一个[`PolynomialRing`](domainsref.html#sympy.polys.domains.PolynomialRing
    "sympy.polys.domains.PolynomialRing")或[`RationalField`](domainsref.html#sympy.polys.domains.RationalField
    "sympy.polys.domains.RationalField")，将这些超越元素视为生成器：
- en: '[PRE64]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'However if there is a possibility that the inputs are not algebraically independent
    then the domain will be [EX](domainsref.html#ex):'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果存在输入不是代数独立的可能性，则该领域将是[EX](domainsref.html#ex)：
- en: '[PRE65]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here `sin(x)` and `cos(x)` are not algebraically independent since `sin(x)**2
    + cos(x)**2 = 1`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这里 `sin(x)` 和 `cos(x)` 并不是代数独立的，因为 `sin(x)**2 + cos(x)**2 = 1`。
- en: Converting elements between different domains
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同领域之间转换元素
- en: 'It is often useful to combine calculations performed over different domains.
    However just as it is important to avoid mixing domain elements with normal sympy
    expressions and other Python types it is also important to avoid mixing elements
    from different domains. The [`convert_from()`](domainsref.html#sympy.polys.domains.domain.Domain.convert_from
    "sympy.polys.domains.domain.Domain.convert_from") method is used to convert elements
    from one domain into elements of another domain:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同领域中进行的计算通常是有用的。然而，重要的是避免将领域元素与普通的sympy表达式和其他Python类型混合，同样重要的是避免将来自不同领域的元素混合。[`convert_from()`](domainsref.html#sympy.polys.domains.domain.Domain.convert_from
    "sympy.polys.domains.domain.Domain.convert_from") 方法用于将一个领域的元素转换为另一个领域的元素：
- en: '[PRE66]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The [`convert()`](domainsref.html#sympy.polys.domains.domain.Domain.convert
    "sympy.polys.domains.domain.Domain.convert") method can be called without specifying
    the source domain as the second argument e.g.:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 可以调用[`convert()`](domainsref.html#sympy.polys.domains.domain.Domain.convert
    "sympy.polys.domains.domain.Domain.convert") 方法，而不需要指定源领域作为第二个参数，例如：
- en: '[PRE67]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This works because [`convert()`](domainsref.html#sympy.polys.domains.domain.Domain.convert
    "sympy.polys.domains.domain.Domain.convert") can check the type of `ZZ(2)` and
    can try to work out what domain ([ZZ](domainsref.html#zz)) it is an element of.
    Certain domains like [ZZ](domainsref.html#zz) and [QQ](domainsref.html#qq) are
    treated as special cases to make this work. Elements of more complicated domains
    are instances of subclasses of [`DomainElement`](domainsref.html#sympy.polys.domains.domainelement.DomainElement
    "sympy.polys.domains.domainelement.DomainElement") which has a [`parent()`](domainsref.html#sympy.polys.domains.domainelement.DomainElement.parent
    "sympy.polys.domains.domainelement.DomainElement.parent") method that can identify
    the domain that the element belongs to. For example in the polynomial ring `ZZ[x]`
    we have:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 [`convert()`](domainsref.html#sympy.polys.domains.domain.Domain.convert
    "sympy.polys.domains.domain.Domain.convert") 可以检查 `ZZ(2)` 的类型，并尝试确定它是哪个域 ([ZZ](domainsref.html#zz))
    的元素。像 [ZZ](domainsref.html#zz) 和 [QQ](domainsref.html#qq) 这样的某些域被视为特殊情况，以使其工作。更复杂域的元素是
    [`DomainElement`](domainsref.html#sympy.polys.domains.domainelement.DomainElement
    "sympy.polys.domains.domainelement.DomainElement") 的子类实例，该类具有 [`parent()`](domainsref.html#sympy.polys.domains.domainelement.DomainElement.parent
    "sympy.polys.domains.domainelement.DomainElement.parent") 方法，可以识别元素所属的域。例如在多项式环
    `ZZ[x]` 中我们有：
- en: '[PRE68]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'It is more efficient though to call [`convert_from()`](domainsref.html#sympy.polys.domains.domain.Domain.convert_from
    "sympy.polys.domains.domain.Domain.convert_from") with the source domain specified
    as the second argument:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 不过，通过将源域指定为第二个参数调用 [`convert_from()`](domainsref.html#sympy.polys.domains.domain.Domain.convert_from
    "sympy.polys.domains.domain.Domain.convert_from") 更为高效：
- en: '[PRE69]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Unifying domains
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统一域
- en: When we want to combine elements from two different domains and perform mixed
    calculations with them we need to
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要结合来自两个不同域的元素，并对它们进行混合计算时，我们需要
- en: Choose a new domain that can represent all elements of both.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个能表示两者所有元素的新域。
- en: Convert all elements to the new domain.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有元素转换到新域。
- en: Perform the calculation in the new domain.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新域中执行计算。
- en: 'The key question arising from point 1\. is how to choose a domain that can
    represent the elements of both domains. For this there is the [`unify()`](domainsref.html#sympy.polys.domains.domain.Domain.unify
    "sympy.polys.domains.domain.Domain.unify") method:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 从第 1 点中产生的关键问题是如何选择一个能够表示两个域元素的域。为此，有 [`unify()`](domainsref.html#sympy.polys.domains.domain.Domain.unify
    "sympy.polys.domains.domain.Domain.unify") 方法：
- en: '[PRE70]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The [`unify()`](domainsref.html#sympy.polys.domains.domain.Domain.unify "sympy.polys.domains.domain.Domain.unify")
    method will find a domain that encompasses both domains so in this example `ZZ.unify(QQ)`
    gives [QQ](domainsref.html#qq) because every element of [ZZ](domainsref.html#zz)
    can be represented as an element of [QQ](domainsref.html#qq). This means that
    all inputs (`x1` and `y2`) can be converted to the elements of the common domain
    `K3` (as `x3` and `y3`). Once in the common domain we can safely use arithmetic
    operations like `+`. In this example one domain is a superset of the other and
    we see that `K1.unify(K2) == K2` so it is not actually necessary to convert `y2`.
    In general though `K1.unify(K2)` can give a new domain that is not equal to either
    `K1` or `K2`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[`unify()`](domainsref.html#sympy.polys.domains.domain.Domain.unify "sympy.polys.domains.domain.Domain.unify")
    方法将找到一个包含两个域的公共域，在这个例子中 `ZZ.unify(QQ)` 得到的是 [QQ](domainsref.html#qq)，因为 [ZZ](domainsref.html#zz)
    的每个元素都可以表示为 [QQ](domainsref.html#qq) 的元素。这意味着所有的输入 (`x1` 和 `y2`) 都可以转换为公共域 `K3`
    中的元素（作为 `x3` 和 `y3`）。一旦在公共域中，我们可以安全地使用像 `+` 这样的算术操作。在这个例子中，一个域是另一个域的超集，我们看到 `K1.unify(K2)
    == K2`，所以实际上不需要转换 `y2`。总的来说，然而 `K1.unify(K2)` 可以给出一个既不等于 `K1` 也不等于 `K2` 的新域。'
- en: 'The [`unify()`](domainsref.html#sympy.polys.domains.domain.Domain.unify "sympy.polys.domains.domain.Domain.unify")
    method understands how to combine different polynomial ring domains and how to
    unify the base domain:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[`unify()`](domainsref.html#sympy.polys.domains.domain.Domain.unify "sympy.polys.domains.domain.Domain.unify")
    方法理解如何组合不同的多项式环域以及如何统一基础域：'
- en: '[PRE71]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'It is also possible to unify algebraic fields and rational function fields
    as well:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同样可以统一代数域和有理函数域：
- en: '[PRE72]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Internals of a Poly
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项式内部
- en: 'We are now in a position to understand how the [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") class works internally. This is the public interface
    of [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly"):'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以理解 [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    类在内部如何工作。这是 [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    的公共接口：
- en: '[PRE73]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'This is the internal implementation of [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly"):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")的内部实现：
- en: '[PRE74]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The internal representation of a [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") instance is an instance of [`DMP`](domainsref.html#sympy.polys.polyclasses.DMP
    "sympy.polys.polyclasses.DMP") which is the class used for domain elements in
    the old polynomial ring domain [`old_poly_ring()`](domainsref.html#sympy.polys.domains.domain.Domain.old_poly_ring
    "sympy.polys.domains.domain.Domain.old_poly_ring"). This represents the polynomial
    as a list of coefficients which are themselves elements of a domain and keeps
    a reference to their domain ([ZZ](domainsref.html#zz) in this example).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")实例的内部表示是一个[`DMP`](domainsref.html#sympy.polys.polyclasses.DMP
    "sympy.polys.polyclasses.DMP")的实例，它是旧多项式环域[`old_poly_ring()`](domainsref.html#sympy.polys.domains.domain.Domain.old_poly_ring
    "sympy.polys.domains.domain.Domain.old_poly_ring")中用于域元素的类。它将多项式表示为系数列表，这些系数本身是域的元素，并保持对它们域的引用（在本例中是[ZZ](domainsref.html#zz)）。'
- en: Choosing a domain for a Poly
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择一个Poly的域。
- en: 'If the domain is not specified for the [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") constructor then it is inferred using [`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain"). Arguments like `field=True` are passed
    along to [`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain"):'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有为[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")构造器指定域，则会使用[`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain")推断。像`field=True`这样的参数会传递给[`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain")：
- en: '[PRE75]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It is also possible to use the extension argument to specify generators of
    an extension even if no extension is required to represent the coefficients although
    this does not work when using [`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain") directly. A list of extension elements
    will be passed to [`primitive_element()`](numberfields.html#sympy.polys.numberfields.subfield.primitive_element
    "sympy.polys.numberfields.subfield.primitive_element") to create an appropriate
    [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField "sympy.polys.domains.AlgebraicField")
    domain:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用扩展参数来指定扩展的生成器，即使不需要扩展来表示系数，尽管直接使用[`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain")时无法使用。扩展元素列表将传递给[`primitive_element()`](numberfields.html#sympy.polys.numberfields.subfield.primitive_element
    "sympy.polys.numberfields.subfield.primitive_element")以创建适当的[`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField")域：
- en: '[PRE76]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: (Perhaps [`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain") should do the same as [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") here…)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: （或许[`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain")在这里应该像[`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")一样做…）
- en: Choosing generators
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择生成器。
- en: 'If there are symbols other than the generators then a polynomial ring or rational
    function field domain will be created. The domain used for the coefficients in
    this case is the sparse (“new”) polynomial ring:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 如果除了生成器之外还有其他符号，则会创建多项式环或有理函数域域。在这种情况下，系数使用的域是稀疏（“new”）多项式环：
- en: '[PRE77]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: What we have here is a strange hybrid of dense and sparse implementations. The
    [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    instance considers itself to be an univariate polynomial in the generator `x`
    but with coefficients from the domain `ZZ[y,z]`. The internal representation of
    the [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    is a list of coefficients in the “dense univariate polynomial” (DUP) format. However
    each coefficient is implemented as a sparse polynomial in `y` and `z`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有一种稠密和稀疏实现的奇怪混合体。[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")实例将自己视为生成器`x`的单变量多项式，但系数来自域`ZZ[y,z]`。[`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")的内部表示是“稠密单变量多项式”（DUP）格式的系数列表。然而，每个系数都是在`y`和`z`中稀疏多项式的实现。
- en: 'If we make `x`, `y` and `z` all be generators for the [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") then we get a fully dense DMP list of lists of lists
    representation:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`x`、`y`和`z`都作为[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")的生成器，则得到完全密集的DMP列表表示：
- en: '[PRE78]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'On the other hand we can make a [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") with a fully sparse representation by choosing a
    generator that is not in the expression at all:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，我们可以通过选择一个表达式中根本不存在的生成器，为[`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")创建完全稀疏的表示：
- en: '[PRE79]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If no generators are provided to the [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") constructor then it will attempt to choose generators
    so that the expression is polynomial in those. In the common case that the expression
    is a polynomial expression in some symbols then those symbols will be taken as
    generators. However other non-symbol expressions can also be taken as generators:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未向[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")构造函数提供生成器，则将尝试选择生成器，使表达式在这些生成器上是多项式的。在表达式是一些符号的多项式表达式的常见情况下，这些符号将被视为生成器。然而，其他非符号表达式也可以被视为生成器：
- en: '[PRE80]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Algebraically dependent generators
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代数相关的生成器。
- en: 'Taking `exp(x)` or `pi` as generators for a [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly") or for its polynomial ring domain is mathematically
    valid because these objects are transcendental and so the ring extension containing
    them is isomorphic to a polynomial ring. Since `x` and `exp(x)` are algebraically
    independent it is also valid to use both as generators for the same [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly"). However some other combinations of generators are
    invalid such as `x` and `sqrt(x)` or `sin(x)` and `cos(x)`. These examples are
    invalid because the generators are not algebraically independent (e.g. `sqrt(x)**2
    = x` and `sin(x)**2 + cos(x)**2 = 1`). The implementation is not able to detect
    these algebraic relationships though:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 将`exp(x)`或`pi`作为[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")或其多项式环域的生成器是数学上有效的，因为这些对象是超越的，所以包含它们的环扩展同构于多项式环。由于`x`和`exp(x)`是代数无关的，因此也可以同时将它们作为同一个[`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly")的生成器使用。然而，一些其他的生成器组合是无效的，比如`x`和`sqrt(x)`或`sin(x)`和`cos(x)`。这些例子是无效的，因为生成器不是代数无关的（例如`sqrt(x)**2
    = x`和`sin(x)**2 + cos(x)**2 = 1`）。尽管如此，该实现无法检测这些代数关系：
- en: '[PRE81]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Calculations with a [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    such as this are unreliable because zero-testing will not work properly in this
    implementation:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像这样的[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")进行计算是不可靠的，因为在这种实现中零测试将无法正常工作：
- en: '[PRE82]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This aspect of [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    could be improved by:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式改进[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")的这一方面：
- en: Expanding the domain system with new domains that can represent more classes
    of algebraic extension.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过引入能够表示更多代数扩展类的新域来扩展域系统。
- en: Improving the detection of algebraic dependencies in [`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain").
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[`construct_domain()`](reference.html#sympy.polys.constructor.construct_domain
    "sympy.polys.constructor.construct_domain")中改进代数依赖的检测。
- en: Improving the automatic selection of generators.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改进生成器的自动选择。
- en: 'Examples of the above are that it would be useful to have a domain that can
    represent more general algebraic extensions ([`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") is only for extensions of [QQ](domainsref.html#qq)).
    Improving the detection of algebraic dependencies is harder but at least common
    cases like `sin(x)` and `cos(x)` could be handled. When choosing generators it
    should be possible to recognise that `sqrt(x)` can be the only generator for `x
    + sqrt(x)`:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例表明，拥有一个能够表示更一般的代数扩展的域将非常有用（[`代数域`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") 仅适用于[QQ](domainsref.html#qq)的扩展）。改进代数依赖的检测更加困难，但至少可以处理像`sin(x)`和`cos(x)`这样的常见情况。在选择生成器时，应能够认识到`sqrt(x)`可以是`x
    + sqrt(x)`的唯一生成器：
- en: '[PRE83]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
