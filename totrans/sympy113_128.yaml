- en: Basic Implementation details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/vector/basics.html](https://docs.sympy.org/latest/modules/vector/basics.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Coordinate Systems and Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, [`sympy.vector`](index.html#module-sympy.vector "sympy.vector") is
    able to deal with the Cartesian (also called rectangular), spherical and other
    curvilinear coordinate systems.
  prefs: []
  type: TYPE_NORMAL
- en: A 3D Cartesian coordinate system can be initialized in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector") as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The string parameter to the constructor denotes the name assigned to the system,
    and will primarily be used for printing purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Once a coordinate system (in essence, a `CoordSys3D` instance) has been defined,
    we can access the orthonormal unit vectors (i.e. the \(\mathbf{\hat{i}}\), \(\mathbf{\hat{j}}\)
    and \(\mathbf{\hat{k}}\) vectors) and coordinate variables/base scalars (i.e.
    the \(\mathbf{x}\), \(\mathbf{y}\) and \(\mathbf{z}\) variables) corresponding
    to it. We will talk about coordinate variables in the later sections.
  prefs: []
  type: TYPE_NORMAL
- en: The basis vectors for the \(X\), \(Y\) and \(Z\) axes can be accessed using
    the `i`, `j` and `k` properties respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As seen above, the basis vectors are all instances of a class called `BaseVector`.
  prefs: []
  type: TYPE_NORMAL
- en: When a `BaseVector` is multiplied by a scalar (essentially any SymPy `Expr`),
    we get a `VectorMul` - the product of a base vector and a scalar.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Addition of `VectorMul` and `BaseVectors` gives rise to formation of `VectorAdd`
    - except for special cases, ofcourse.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: What about a zero vector? It can be accessed using the `zero` attribute assigned
    to class `Vector`. Since the notion of a zero vector remains the same regardless
    of the coordinate system in consideration, we use `Vector.zero` wherever such
    a quantity is required.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All the classes shown above - `BaseVector`, `VectorMul`, `VectorAdd` and `VectorZero`
    are subclasses of `Vector`.
  prefs: []
  type: TYPE_NORMAL
- en: You should never have to instantiate objects of any of the subclasses of `Vector`.
    Using the `BaseVector` instances assigned to a `CoordSys3D` instance and (if needed)
    `Vector.zero` as building blocks, any sort of vectorial expression can be constructed
    with the basic mathematical operators `+`, `-`, `*`. and `/`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the elementary mathematical operations, the vector operations
    of `dot` and `cross` can also be performed on `Vector`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `&` and `^` operators have been overloaded for the `dot` and `cross` methods
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: However, this is not the recommended way of performing these operations. Using
    the original methods makes the code clearer and easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these operations, it is also possible to compute the outer products
    of `Vector` instances in [`sympy.vector`](index.html#module-sympy.vector "sympy.vector").
    More on that in a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: SymPy operations on Vectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SymPy operations of `simplify`, `trigsimp`, `diff`, and `factor` work on
    `Vector` objects, with the standard SymPy API.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the methods work on the measure numbers(The coefficients of the
    basis vectors) present in the provided vectorial expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`Integral` also works with `Vector` instances, similar to `Derivative`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, every coordinate system corresponds to a unique origin
    point. Points, in general, have been implemented in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector") in the form of the `Point` class.
  prefs: []
  type: TYPE_NORMAL
- en: To access the origin of system, use the `origin` property of the `CoordSys3D`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can instantiate new points in space using the `locate_new` method of `Point`.
    The arguments include the name(string) of the new `Point`, and its position vector
    with respect to the ‘parent’ `Point`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Like `Vector`, a user never has to expressly instantiate an object of `Point`.
    This is because any location in space (albeit relative) can be pointed at by using
    the `origin` of a `CoordSys3D` as the reference, and then using `locate_new` on
    it and subsequent `Point` instances.
  prefs: []
  type: TYPE_NORMAL
- en: The position vector of a `Point` with respect to another `Point` can be computed
    using the `position_wrt` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, it is possible to obtain the \(X\), \(Y\) and \(Z\) coordinates
    of a `Point` with respect to a `CoordSys3D` in the form of a tuple. This is done
    using the `express_coordinates` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Dyadics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A dyadic, or dyadic tensor, is a second-order tensor formed by the juxtaposition
    of pairs of vectors. Therefore, the outer products of vectors give rise to the
    formation of dyadics. Dyadic tensors have been implemented in [`sympy.vector`](index.html#module-sympy.vector
    "sympy.vector") in the `Dyadic` class.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, you never have to instantiate objects of `Dyadic`. The outer products
    of vectors can be computed using the `outer` method of `Vector`. The `|` operator
    has been overloaded for `outer`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similar to `Vector`, `Dyadic` also has subsequent subclasses like `BaseDyadic`,
    `DyadicMul`, `DyadicAdd`. As with `Vector`, a zero dyadic can be accessed from
    `Dyadic.zero`.
  prefs: []
  type: TYPE_NORMAL
- en: All basic mathematical operations work with `Dyadic` too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`dot` and `cross` also work among `Dyadic` instances as well as between a `Dyadic`
    and `Vector` (and also vice versa) - as per the respective mathematical definitions.
    As with `Vector`, `&` and `^` have been overloaded for `dot` and `cross`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
