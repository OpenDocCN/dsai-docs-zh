["```py\nscipy.integrate.solve_ivp(fun, t_span, y0, method='RK45', t_eval=None, dense_output=False, events=None, vectorized=False, args=None, **options)\n```", "```py\ndy / dt = f(t, y)\ny(t0) = y0 \n```", "```py\n>>> import numpy as np\n>>> from scipy.integrate import solve_ivp\n>>> def exponential_decay(t, y): return -0.5 * y\n>>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8])\n>>> print(sol.t)\n[ 0\\.          0.11487653  1.26364188  3.06061781  4.81611105  6.57445806\n 8.33328988 10\\.        ]\n>>> print(sol.y)\n[[2\\.         1.88836035 1.06327177 0.43319312 0.18017253 0.07483045\n 0.03107158 0.01350781]\n [4\\.         3.7767207  2.12654355 0.86638624 0.36034507 0.14966091\n 0.06214316 0.02701561]\n [8\\.         7.5534414  4.25308709 1.73277247 0.72069014 0.29932181\n 0.12428631 0.05403123]] \n```", "```py\n>>> sol = solve_ivp(exponential_decay, [0, 10], [2, 4, 8],\n...                 t_eval=[0, 1, 2, 4, 10])\n>>> print(sol.t)\n[ 0  1  2  4 10]\n>>> print(sol.y)\n[[2\\.         1.21305369 0.73534021 0.27066736 0.01350938]\n [4\\.         2.42610739 1.47068043 0.54133472 0.02701876]\n [8\\.         4.85221478 2.94136085 1.08266944 0.05403753]] \n```", "```py\n>>> def upward_cannon(t, y): return [y[1], -0.5]\n>>> def hit_ground(t, y): return y[0]\n>>> hit_ground.terminal = True\n>>> hit_ground.direction = -1\n>>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10], events=hit_ground)\n>>> print(sol.t_events)\n[array([40.])]\n>>> print(sol.t)\n[0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\n 1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01] \n```", "```py\n>>> def apex(t, y): return y[1]\n>>> sol = solve_ivp(upward_cannon, [0, 100], [0, 10],\n...                 events=(hit_ground, apex), dense_output=True)\n>>> print(sol.t_events)\n[array([40.]), array([20.])]\n>>> print(sol.t)\n[0.00000000e+00 9.99900010e-05 1.09989001e-03 1.10988901e-02\n 1.11088891e-01 1.11098890e+00 1.11099890e+01 4.00000000e+01]\n>>> print(sol.sol(sol.t_events[1][0]))\n[100\\.   0.]\n>>> print(sol.y_events)\n[array([[-5.68434189e-14, -1.00000000e+01]]),\n array([[1.00000000e+02, 1.77635684e-15]])] \n```", "```py\n>>> def lotkavolterra(t, z, a, b, c, d):\n...     x, y = z\n...     return [a*x - b*x*y, -c*y + d*x*y]\n... \n```", "```py\n>>> sol = solve_ivp(lotkavolterra, [0, 15], [10, 5], args=(1.5, 1, 3, 1),\n...                 dense_output=True) \n```", "```py\n>>> t = np.linspace(0, 15, 300)\n>>> z = sol.sol(t)\n>>> import matplotlib.pyplot as plt\n>>> plt.plot(t, z.T)\n>>> plt.xlabel('t')\n>>> plt.legend(['x', 'y'], shadow=True)\n>>> plt.title('Lotka-Volterra System')\n>>> plt.show() \n```", "```py\n>>> A = np.array([[-0.25 + 0.14j, 0, 0.33 + 0.44j],\n...               [0.25 + 0.58j, -0.2 + 0.14j, 0],\n...               [0, 0.2 + 0.4j, -0.1 + 0.97j]]) \n```", "```py\n>>> def deriv_vec(t, y):\n...     return A @ y\n>>> result = solve_ivp(deriv_vec, [0, 25],\n...                    np.array([10 + 0j, 20 + 0j, 30 + 0j]),\n...                    t_eval=np.linspace(0, 25, 101))\n>>> print(result.y[:, 0])\n[10.+0.j 20.+0.j 30.+0.j]\n>>> print(result.y[:, -1])\n[18.46291039+45.25653651j 10.01569306+36.23293216j\n -4.98662741+80.07360388j] \n```", "```py\n>>> def deriv_mat(t, y):\n...     return (A @ y.reshape(3, 3)).flatten()\n>>> y0 = np.array([[2 + 0j, 3 + 0j, 4 + 0j],\n...                [5 + 0j, 6 + 0j, 7 + 0j],\n...                [9 + 0j, 34 + 0j, 78 + 0j]]) \n```", "```py\n>>> result = solve_ivp(deriv_mat, [0, 25], y0.flatten(),\n...                    t_eval=np.linspace(0, 25, 101))\n>>> print(result.y[:, 0].reshape(3, 3))\n[[ 2.+0.j  3.+0.j  4.+0.j]\n [ 5.+0.j  6.+0.j  7.+0.j]\n [ 9.+0.j 34.+0.j 78.+0.j]]\n>>> print(result.y[:, -1].reshape(3, 3))\n[[  5.67451179 +12.07938445j  17.2888073  +31.03278837j\n 37.83405768 +63.25138759j]\n [  3.39949503 +11.82123994j  21.32530996 +44.88668871j\n 53.17531184+103.80400411j]\n [ -2.26105874 +22.19277664j -15.1255713  +70.19616341j\n -38.34616845+153.29039931j]] \n```"]