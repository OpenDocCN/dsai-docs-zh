["```py\n// The header should be located at numpy/numpy/core/src/common/_cpu_dispatch.h\n/**NOTE\n ** C definitions prefixed with \"NPY_HAVE_\" represent\n ** the required optimizations.\n **\n ** C definitions prefixed with 'NPY__CPU_TARGET_' are protected and\n ** shouldn't be used by any NumPy C sources.\n */\n/******* baseline features *******/\n/** SSE **/\n#define NPY_HAVE_SSE 1\n#include  <xmmintrin.h>\n/** SSE2 **/\n#define NPY_HAVE_SSE2 1\n#include  <emmintrin.h>\n/** SSE3 **/\n#define NPY_HAVE_SSE3 1\n#include  <pmmintrin.h>\n\n/******* dispatch-able features *******/\n#ifdef NPY__CPU_TARGET_SSSE3\n  /** SSSE3 **/\n  #define NPY_HAVE_SSSE3 1\n  #include  <tmmintrin.h>\n#endif\n#ifdef NPY__CPU_TARGET_SSE41\n  /** SSE41 **/\n  #define NPY_HAVE_SSE41 1\n  #include  <smmintrin.h>\n#endif \n```", "```py\n/*@targets avx2 avx512f vsx2 vsx3 asimd asimdhp */\n// C code \n```", "```py\n    /*\n     * this definition is used by NumPy utilities as suffixes for the\n     * exported symbols\n     */\n    #define NPY__CPU_TARGET_CURRENT AVX512F\n    /*\n     * The following definitions enable\n     * definitions of the dispatch-able features that are defined within the main\n     * configuration header. These are definitions for the implied features.\n     */\n    #define NPY__CPU_TARGET_SSE\n    #define NPY__CPU_TARGET_SSE2\n    #define NPY__CPU_TARGET_SSE3\n    #define NPY__CPU_TARGET_SSSE3\n    #define NPY__CPU_TARGET_SSE41\n    #define NPY__CPU_TARGET_POPCNT\n    #define NPY__CPU_TARGET_SSE42\n    #define NPY__CPU_TARGET_AVX\n    #define NPY__CPU_TARGET_F16C\n    #define NPY__CPU_TARGET_FMA3\n    #define NPY__CPU_TARGET_AVX2\n    #define NPY__CPU_TARGET_AVX512F\n    // our dispatch-able source\n    #include  \"/the/absuolate/path/of/hello.dispatch.c\" \n    ```", "```py\n    // hello.dispatch.c\n    /*@targets baseline sse42 avx512f */\n    #include  <stdio.h>\n    #include  \"numpy/utils.h\" // NPY_CAT, NPY_TOSTR\n\n    #ifndef NPY__CPU_TARGET_CURRENT\n      // wrapping the dispatch-able source only happens to the additional optimizations\n      // but if the keyword 'baseline' provided within the configuration statements,\n      // the infrastructure will add extra compiling for the dispatch-able source by\n      // passing it as-is to the compiler without any changes.\n      #define CURRENT_TARGET(X) X\n      #define NPY__CPU_TARGET_CURRENT baseline // for printing only\n    #else\n      // since we reach to this point, that's mean we're dealing with\n      // the additional optimizations, so it could be SSE42 or AVX512F\n      #define CURRENT_TARGET(X) NPY_CAT(NPY_CAT(X, _), NPY__CPU_TARGET_CURRENT)\n    #endif\n    // Macro 'CURRENT_TARGET' adding the current target as suffux to the exported symbols,\n    // to avoid linking duplications, NumPy already has a macro called\n    // 'NPY_CPU_DISPATCH_CURFX' similar to it, located at\n    // numpy/numpy/core/src/common/npy_cpu_dispatch.h\n    // NOTE: we tend to not adding suffixes to the baseline exported symbols\n    void  CURRENT_TARGET(simd_whoami)(const  char  *extra_info)\n    {\n      printf(\"I'm \"  NPY_TOSTR(NPY__CPU_TARGET_CURRENT)  \", %s\\n\",  extra_info);\n    } \n    ```", "```py\n    #ifndef NPY__CPU_DISPATCH_EXPAND_\n      // To expand the macro calls in this header\n      #define NPY__CPU_DISPATCH_EXPAND_(X) X\n    #endif\n    // Undefining the following macros, due to the possibility of including config headers\n    // multiple times within the same source and since each config header represents\n    // different required optimizations according to the specified configuration\n    // statements in the dispatch-able source that derived from it.\n    #undef NPY__CPU_DISPATCH_BASELINE_CALL\n    #undef NPY__CPU_DISPATCH_CALL\n    // nothing strange here, just a normal preprocessor callback\n    // enabled only if 'baseline' specified within the configuration statements\n    #define NPY__CPU_DISPATCH_BASELINE_CALL(CB, ...) \\\n     NPY__CPU_DISPATCH_EXPAND_(CB(__VA_ARGS__))\n    // 'NPY__CPU_DISPATCH_CALL' is an abstract macro is used for dispatching\n    // the required optimizations that specified within the configuration statements.\n    //\n    // @param CHK, Expected a macro that can be used to detect CPU features\n    // in runtime, which takes a CPU feature name without string quotes and\n    // returns the testing result in a shape of boolean value.\n    // NumPy already has macro called \"NPY_CPU_HAVE\", which fits this requirement.\n    //\n    // @param CB, a callback macro that expected to be called multiple times depending\n    // on the required optimizations, the callback should receive the following arguments:\n    //  1- The pending calls of @param CHK filled up with the required CPU features,\n    //     that need to be tested first in runtime before executing call belong to\n    //     the compiled object.\n    //  2- The required optimization name, same as in 'NPY__CPU_TARGET_CURRENT'\n    //  3- Extra arguments in the macro itself\n    //\n    // By default the callback calls are sorted depending on the highest interest\n    // unless the policy \"$keep_sort\" was in place within the configuration statements\n    // see \"Dive into the CPU dispatcher\" for more clarification.\n    #define NPY__CPU_DISPATCH_CALL(CHK, CB, ...) \\\n     NPY__CPU_DISPATCH_EXPAND_(CB((CHK(AVX512F)), AVX512F, __VA_ARGS__)) \\\n     NPY__CPU_DISPATCH_EXPAND_(CB((CHK(SSE)&&CHK(SSE2)&&CHK(SSE3)&&CHK(SSSE3)&&CHK(SSE41)), SSE41, __VA_ARGS__)) \n    ```", "```py\n    // NOTE: The following macros are only defined for demonstration purposes only.\n    // NumPy already has a collections of macros located at\n    // numpy/numpy/core/src/common/npy_cpu_dispatch.h, that covers all dispatching\n    // and declarations scenarios.\n\n    #include  \"numpy/npy_cpu_features.h\" // NPY_CPU_HAVE\n    #include  \"numpy/utils.h\" // NPY_CAT, NPY_EXPAND\n\n    // An example for setting a macro that calls all the exported symbols at once\n    // after checking if they're supported by the running machine.\n    #define DISPATCH_CALL_ALL(FN, ARGS) \\\n     NPY__CPU_DISPATCH_CALL(NPY_CPU_HAVE, DISPATCH_CALL_ALL_CB, FN, ARGS) \\\n     NPY__CPU_DISPATCH_BASELINE_CALL(DISPATCH_CALL_BASELINE_ALL_CB, FN, ARGS)\n    // The preprocessor callbacks.\n    // The same suffixes as we define it in the dispatch-able source.\n    #define DISPATCH_CALL_ALL_CB(CHECK, TARGET_NAME, FN, ARGS) \\\n     if (CHECK) { NPY_CAT(NPY_CAT(FN, _), TARGET_NAME) ARGS; }\n    #define DISPATCH_CALL_BASELINE_ALL_CB(FN, ARGS) \\\n     FN NPY_EXPAND(ARGS);\n\n    // An example for setting a macro that calls the exported symbols of highest\n    // interest optimization, after checking if they're supported by the running machine.\n    #define DISPATCH_CALL_HIGH(FN, ARGS) \\\n     if (0) {} \\\n     NPY__CPU_DISPATCH_CALL(NPY_CPU_HAVE, DISPATCH_CALL_HIGH_CB, FN, ARGS) \\\n     NPY__CPU_DISPATCH_BASELINE_CALL(DISPATCH_CALL_BASELINE_HIGH_CB, FN, ARGS)\n    // The preprocessor callbacks\n    // The same suffixes as we define it in the dispatch-able source.\n    #define DISPATCH_CALL_HIGH_CB(CHECK, TARGET_NAME, FN, ARGS) \\\n     else if (CHECK) { NPY_CAT(NPY_CAT(FN, _), TARGET_NAME) ARGS; }\n    #define DISPATCH_CALL_BASELINE_HIGH_CB(FN, ARGS) \\\n     else { FN NPY_EXPAND(ARGS); }\n\n    // NumPy has a macro called 'NPY_CPU_DISPATCH_DECLARE' can be used\n    // for forward declarations any kind of prototypes based on\n    // 'NPY__CPU_DISPATCH_CALL' and 'NPY__CPU_DISPATCH_BASELINE_CALL'.\n    // However in this example, we just handle it manually.\n    void  simd_whoami(const  char  *extra_info);\n    void  simd_whoami_AVX512F(const  char  *extra_info);\n    void  simd_whoami_SSE41(const  char  *extra_info);\n\n    void  trigger_me(void)\n    {\n      // bring the auto-generated config header\n      // which contains config macros 'NPY__CPU_DISPATCH_CALL' and\n      // 'NPY__CPU_DISPATCH_BASELINE_CALL'.\n      // it is highly recommended to include the config header before executing\n      // the dispatching macros in case if there's another header in the scope.\n      #include  \"hello.dispatch.h\"\n      DISPATCH_CALL_ALL(simd_whoami,  (\"all\"))\n      DISPATCH_CALL_HIGH(simd_whoami,  (\"the highest interest\"))\n      // An example of including multiple config headers in the same source\n      // #include \"hello2.dispatch.h\"\n      // DISPATCH_CALL_HIGH(another_function, (\"the highest interest\"))\n    } \n    ```", "```py\n// The header should be located at numpy/numpy/core/src/common/_cpu_dispatch.h\n/**NOTE\n ** C definitions prefixed with \"NPY_HAVE_\" represent\n ** the required optimizations.\n **\n ** C definitions prefixed with 'NPY__CPU_TARGET_' are protected and\n ** shouldn't be used by any NumPy C sources.\n */\n/******* baseline features *******/\n/** SSE **/\n#define NPY_HAVE_SSE 1\n#include  <xmmintrin.h>\n/** SSE2 **/\n#define NPY_HAVE_SSE2 1\n#include  <emmintrin.h>\n/** SSE3 **/\n#define NPY_HAVE_SSE3 1\n#include  <pmmintrin.h>\n\n/******* dispatch-able features *******/\n#ifdef NPY__CPU_TARGET_SSSE3\n  /** SSSE3 **/\n  #define NPY_HAVE_SSSE3 1\n  #include  <tmmintrin.h>\n#endif\n#ifdef NPY__CPU_TARGET_SSE41\n  /** SSE41 **/\n  #define NPY_HAVE_SSE41 1\n  #include  <smmintrin.h>\n#endif \n```", "```py\n/*@targets avx2 avx512f vsx2 vsx3 asimd asimdhp */\n// C code \n```", "```py\n    /*\n     * this definition is used by NumPy utilities as suffixes for the\n     * exported symbols\n     */\n    #define NPY__CPU_TARGET_CURRENT AVX512F\n    /*\n     * The following definitions enable\n     * definitions of the dispatch-able features that are defined within the main\n     * configuration header. These are definitions for the implied features.\n     */\n    #define NPY__CPU_TARGET_SSE\n    #define NPY__CPU_TARGET_SSE2\n    #define NPY__CPU_TARGET_SSE3\n    #define NPY__CPU_TARGET_SSSE3\n    #define NPY__CPU_TARGET_SSE41\n    #define NPY__CPU_TARGET_POPCNT\n    #define NPY__CPU_TARGET_SSE42\n    #define NPY__CPU_TARGET_AVX\n    #define NPY__CPU_TARGET_F16C\n    #define NPY__CPU_TARGET_FMA3\n    #define NPY__CPU_TARGET_AVX2\n    #define NPY__CPU_TARGET_AVX512F\n    // our dispatch-able source\n    #include  \"/the/absuolate/path/of/hello.dispatch.c\" \n    ```", "```py\n    // hello.dispatch.c\n    /*@targets baseline sse42 avx512f */\n    #include  <stdio.h>\n    #include  \"numpy/utils.h\" // NPY_CAT, NPY_TOSTR\n\n    #ifndef NPY__CPU_TARGET_CURRENT\n      // wrapping the dispatch-able source only happens to the additional optimizations\n      // but if the keyword 'baseline' provided within the configuration statements,\n      // the infrastructure will add extra compiling for the dispatch-able source by\n      // passing it as-is to the compiler without any changes.\n      #define CURRENT_TARGET(X) X\n      #define NPY__CPU_TARGET_CURRENT baseline // for printing only\n    #else\n      // since we reach to this point, that's mean we're dealing with\n      // the additional optimizations, so it could be SSE42 or AVX512F\n      #define CURRENT_TARGET(X) NPY_CAT(NPY_CAT(X, _), NPY__CPU_TARGET_CURRENT)\n    #endif\n    // Macro 'CURRENT_TARGET' adding the current target as suffux to the exported symbols,\n    // to avoid linking duplications, NumPy already has a macro called\n    // 'NPY_CPU_DISPATCH_CURFX' similar to it, located at\n    // numpy/numpy/core/src/common/npy_cpu_dispatch.h\n    // NOTE: we tend to not adding suffixes to the baseline exported symbols\n    void  CURRENT_TARGET(simd_whoami)(const  char  *extra_info)\n    {\n      printf(\"I'm \"  NPY_TOSTR(NPY__CPU_TARGET_CURRENT)  \", %s\\n\",  extra_info);\n    } \n    ```", "```py\n    #ifndef NPY__CPU_DISPATCH_EXPAND_\n      // To expand the macro calls in this header\n      #define NPY__CPU_DISPATCH_EXPAND_(X) X\n    #endif\n    // Undefining the following macros, due to the possibility of including config headers\n    // multiple times within the same source and since each config header represents\n    // different required optimizations according to the specified configuration\n    // statements in the dispatch-able source that derived from it.\n    #undef NPY__CPU_DISPATCH_BASELINE_CALL\n    #undef NPY__CPU_DISPATCH_CALL\n    // nothing strange here, just a normal preprocessor callback\n    // enabled only if 'baseline' specified within the configuration statements\n    #define NPY__CPU_DISPATCH_BASELINE_CALL(CB, ...) \\\n     NPY__CPU_DISPATCH_EXPAND_(CB(__VA_ARGS__))\n    // 'NPY__CPU_DISPATCH_CALL' is an abstract macro is used for dispatching\n    // the required optimizations that specified within the configuration statements.\n    //\n    // @param CHK, Expected a macro that can be used to detect CPU features\n    // in runtime, which takes a CPU feature name without string quotes and\n    // returns the testing result in a shape of boolean value.\n    // NumPy already has macro called \"NPY_CPU_HAVE\", which fits this requirement.\n    //\n    // @param CB, a callback macro that expected to be called multiple times depending\n    // on the required optimizations, the callback should receive the following arguments:\n    //  1- The pending calls of @param CHK filled up with the required CPU features,\n    //     that need to be tested first in runtime before executing call belong to\n    //     the compiled object.\n    //  2- The required optimization name, same as in 'NPY__CPU_TARGET_CURRENT'\n    //  3- Extra arguments in the macro itself\n    //\n    // By default the callback calls are sorted depending on the highest interest\n    // unless the policy \"$keep_sort\" was in place within the configuration statements\n    // see \"Dive into the CPU dispatcher\" for more clarification.\n    #define NPY__CPU_DISPATCH_CALL(CHK, CB, ...) \\\n     NPY__CPU_DISPATCH_EXPAND_(CB((CHK(AVX512F)), AVX512F, __VA_ARGS__)) \\\n     NPY__CPU_DISPATCH_EXPAND_(CB((CHK(SSE)&&CHK(SSE2)&&CHK(SSE3)&&CHK(SSSE3)&&CHK(SSE41)), SSE41, __VA_ARGS__)) \n    ```", "```py\n    // NOTE: The following macros are only defined for demonstration purposes only.\n    // NumPy already has a collections of macros located at\n    // numpy/numpy/core/src/common/npy_cpu_dispatch.h, that covers all dispatching\n    // and declarations scenarios.\n\n    #include  \"numpy/npy_cpu_features.h\" // NPY_CPU_HAVE\n    #include  \"numpy/utils.h\" // NPY_CAT, NPY_EXPAND\n\n    // An example for setting a macro that calls all the exported symbols at once\n    // after checking if they're supported by the running machine.\n    #define DISPATCH_CALL_ALL(FN, ARGS) \\\n     NPY__CPU_DISPATCH_CALL(NPY_CPU_HAVE, DISPATCH_CALL_ALL_CB, FN, ARGS) \\\n     NPY__CPU_DISPATCH_BASELINE_CALL(DISPATCH_CALL_BASELINE_ALL_CB, FN, ARGS)\n    // The preprocessor callbacks.\n    // The same suffixes as we define it in the dispatch-able source.\n    #define DISPATCH_CALL_ALL_CB(CHECK, TARGET_NAME, FN, ARGS) \\\n     if (CHECK) { NPY_CAT(NPY_CAT(FN, _), TARGET_NAME) ARGS; }\n    #define DISPATCH_CALL_BASELINE_ALL_CB(FN, ARGS) \\\n     FN NPY_EXPAND(ARGS);\n\n    // An example for setting a macro that calls the exported symbols of highest\n    // interest optimization, after checking if they're supported by the running machine.\n    #define DISPATCH_CALL_HIGH(FN, ARGS) \\\n     if (0) {} \\\n     NPY__CPU_DISPATCH_CALL(NPY_CPU_HAVE, DISPATCH_CALL_HIGH_CB, FN, ARGS) \\\n     NPY__CPU_DISPATCH_BASELINE_CALL(DISPATCH_CALL_BASELINE_HIGH_CB, FN, ARGS)\n    // The preprocessor callbacks\n    // The same suffixes as we define it in the dispatch-able source.\n    #define DISPATCH_CALL_HIGH_CB(CHECK, TARGET_NAME, FN, ARGS) \\\n     else if (CHECK) { NPY_CAT(NPY_CAT(FN, _), TARGET_NAME) ARGS; }\n    #define DISPATCH_CALL_BASELINE_HIGH_CB(FN, ARGS) \\\n     else { FN NPY_EXPAND(ARGS); }\n\n    // NumPy has a macro called 'NPY_CPU_DISPATCH_DECLARE' can be used\n    // for forward declarations any kind of prototypes based on\n    // 'NPY__CPU_DISPATCH_CALL' and 'NPY__CPU_DISPATCH_BASELINE_CALL'.\n    // However in this example, we just handle it manually.\n    void  simd_whoami(const  char  *extra_info);\n    void  simd_whoami_AVX512F(const  char  *extra_info);\n    void  simd_whoami_SSE41(const  char  *extra_info);\n\n    void  trigger_me(void)\n    {\n      // bring the auto-generated config header\n      // which contains config macros 'NPY__CPU_DISPATCH_CALL' and\n      // 'NPY__CPU_DISPATCH_BASELINE_CALL'.\n      // it is highly recommended to include the config header before executing\n      // the dispatching macros in case if there's another header in the scope.\n      #include  \"hello.dispatch.h\"\n      DISPATCH_CALL_ALL(simd_whoami,  (\"all\"))\n      DISPATCH_CALL_HIGH(simd_whoami,  (\"the highest interest\"))\n      // An example of including multiple config headers in the same source\n      // #include \"hello2.dispatch.h\"\n      // DISPATCH_CALL_HIGH(another_function, (\"the highest interest\"))\n    } \n    ```"]