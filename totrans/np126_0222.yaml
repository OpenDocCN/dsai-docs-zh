- en: numpy.choose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.choose.html](https://numpy.org/doc/1.26/reference/generated/numpy.choose.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Construct an array from an index array and a list of arrays to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, if confused or uncertain, definitely look at the Examples - in
    its full generality, this function is less simple than it might seem from the
    following code description (below ndi = `numpy.lib.index_tricks`):'
  prefs: []
  type: TYPE_NORMAL
- en: '`np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'But this omits some subtleties. Here is a fully general summary:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an “index” array (*a*) of integers and a sequence of `n` arrays (*choices*),
    *a* and each choice array are first broadcast, as necessary, to arrays of a common
    shape; calling these *Ba* and *Bchoices[i], i = 0,…,n-1* we have that, necessarily,
    `Ba.shape == Bchoices[i].shape` for each `i`. Then, a new array with shape `Ba.shape`
    is created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: if `mode='raise'` (the default), then, first of all, each element of `a` (and
    thus `Ba`) must be in the range `[0, n-1]`; now, suppose that `i` (in that range)
    is the value at the `(j0, j1, ..., jm)` position in `Ba` - then the value at the
    same position in the new array is the value in `Bchoices[i]` at that same position;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if `mode='wrap'`, values in *a* (and thus *Ba*) may be any (signed) integer;
    modular arithmetic is used to map integers outside the range *[0, n-1]* back into
    that range; and then the new array is constructed as above;
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if `mode='clip'`, values in *a* (and thus `Ba`) may be any (signed) integer;
    negative integers are mapped to 0; values greater than `n-1` are mapped to `n-1`;
    and then the new array is constructed as above.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**int array'
  prefs: []
  type: TYPE_NORMAL
- en: This array must contain integers in `[0, n-1]`, where `n` is the number of choices,
    unless `mode=wrap` or `mode=clip`, in which cases any integers are permissible.
  prefs: []
  type: TYPE_NORMAL
- en: '**choices**sequence of arrays'
  prefs: []
  type: TYPE_NORMAL
- en: Choice arrays. *a* and all of the choices must be broadcastable to the same
    shape. If *choices* is itself an array (not recommended), then its outermost dimension
    (i.e., the one corresponding to `choices.shape[0]`) is taken as defining the “sequence”.
  prefs: []
  type: TYPE_NORMAL
- en: '**out**array, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If provided, the result will be inserted into this array. It should be of the
    appropriate shape and dtype. Note that *out* is always buffered if `mode='raise'`;
    use other modes for better performance.
  prefs: []
  type: TYPE_NORMAL
- en: '**mode**{‘raise’ (default), ‘wrap’, ‘clip’}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifies how indices outside `[0, n-1]` will be treated:'
  prefs: []
  type: TYPE_NORMAL
- en: '‘raise’ : an exception is raised'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘wrap’ : value becomes value mod `n`'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '‘clip’ : values < 0 are mapped to 0, values > n-1 are mapped to n-1'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**merged_array**array'
  prefs: []
  type: TYPE_NORMAL
- en: The merged result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ValueError: shape mismatch'
  prefs: []
  type: TYPE_NORMAL
- en: If *a* and each choice array are not all broadcastable to the same shape.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ndarray.choose`](numpy.ndarray.choose.html#numpy.ndarray.choose "numpy.ndarray.choose")'
  prefs: []
  type: TYPE_NORMAL
- en: equivalent method
  prefs: []
  type: TYPE_NORMAL
- en: '[`numpy.take_along_axis`](numpy.take_along_axis.html#numpy.take_along_axis
    "numpy.take_along_axis")'
  prefs: []
  type: TYPE_NORMAL
- en: Preferable if *choices* is an array
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: To reduce the chance of misinterpretation, even though the following “abuse”
    is nominally supported, *choices* should neither be, nor be thought of as, a single
    array, i.e., the outermost sequence-like container should be either a list or
    a tuple.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple examples illustrating how choose broadcasts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
