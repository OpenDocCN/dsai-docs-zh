- en: numpy.linalg.eig
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.linalg.eig.html](https://numpy.org/doc/1.26/reference/generated/numpy.linalg.eig.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compute the eigenvalues and right eigenvectors of a square array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**(…, M, M) array'
  prefs: []
  type: TYPE_NORMAL
- en: Matrices for which the eigenvalues and right eigenvectors will be computed
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A namedtuple with the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**eigenvalues**(…, M) array'
  prefs: []
  type: TYPE_NORMAL
- en: The eigenvalues, each repeated according to its multiplicity. The eigenvalues
    are not necessarily ordered. The resulting array will be of complex type, unless
    the imaginary part is zero in which case it will be cast to a real type. When
    *a* is real the resulting eigenvalues will be real (0 imaginary part) or occur
    in conjugate pairs
  prefs: []
  type: TYPE_NORMAL
- en: '**eigenvectors**(…, M, M) array'
  prefs: []
  type: TYPE_NORMAL
- en: The normalized (unit “length”) eigenvectors, such that the column `eigenvectors[:,i]`
    is the eigenvector corresponding to the eigenvalue `eigenvalues[i]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: LinAlgError
  prefs: []
  type: TYPE_NORMAL
- en: If the eigenvalue computation does not converge.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`eigvals`](numpy.linalg.eigvals.html#numpy.linalg.eigvals "numpy.linalg.eigvals")'
  prefs: []
  type: TYPE_NORMAL
- en: eigenvalues of a non-symmetric array.
  prefs: []
  type: TYPE_NORMAL
- en: '[`eigh`](numpy.linalg.eigh.html#numpy.linalg.eigh "numpy.linalg.eigh")'
  prefs: []
  type: TYPE_NORMAL
- en: eigenvalues and eigenvectors of a real symmetric or complex Hermitian (conjugate
    symmetric) array.
  prefs: []
  type: TYPE_NORMAL
- en: '[`eigvalsh`](numpy.linalg.eigvalsh.html#numpy.linalg.eigvalsh "numpy.linalg.eigvalsh")'
  prefs: []
  type: TYPE_NORMAL
- en: eigenvalues of a real symmetric or complex Hermitian (conjugate symmetric) array.
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.linalg.eig`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig
    "(in SciPy v1.11.2)")'
  prefs: []
  type: TYPE_NORMAL
- en: Similar function in SciPy that also solves the generalized eigenvalue problem.
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.linalg.schur`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.schur.html#scipy.linalg.schur
    "(in SciPy v1.11.2)")'
  prefs: []
  type: TYPE_NORMAL
- en: Best choice for unitary and other non-Hermitian normal matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.8.0.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting rules apply, see the [`numpy.linalg`](../routines.linalg.html#module-numpy.linalg
    "numpy.linalg") documentation for details.
  prefs: []
  type: TYPE_NORMAL
- en: This is implemented using the `_geev` LAPACK routines which compute the eigenvalues
    and eigenvectors of general square arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The number *w* is an eigenvalue of *a* if there exists a vector *v* such that
    `a @ v = w * v`. Thus, the arrays *a*, *eigenvalues*, and *eigenvectors* satisfy
    the equations `a @ eigenvectors[:,i] = eigenvalues[i] * eigenvalues[:,i]` for
    \(i \in \{0,...,M-1\}\).
  prefs: []
  type: TYPE_NORMAL
- en: The array *eigenvectors* may not be of maximum rank, that is, some of the columns
    may be linearly dependent, although round-off error may obscure that fact. If
    the eigenvalues are all different, then theoretically the eigenvectors are linearly
    independent and *a* can be diagonalized by a similarity transformation using *eigenvectors*,
    i.e, `inv(eigenvectors) @ a @ eigenvectors` is diagonal.
  prefs: []
  type: TYPE_NORMAL
- en: For non-Hermitian normal matrices the SciPy function [`scipy.linalg.schur`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.schur.html#scipy.linalg.schur
    "(in SciPy v1.11.2)") is preferred because the matrix *eigenvectors* is guaranteed
    to be unitary, which is not the case when using [`eig`](#numpy.linalg.eig "numpy.linalg.eig").
    The Schur factorization produces an upper triangular matrix rather than a diagonal
    matrix, but for normal matrices only the diagonal of the upper triangular matrix
    is needed, the rest is roundoff error.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is emphasized that *eigenvectors* consists of the *right* (as in
    right-hand side) eigenvectors of *a*. A vector *y* satisfying `y.T @ a = z * y.T`
    for some number *z* is called a *left* eigenvector of *a*, and, in general, the
    left and right eigenvectors of a matrix are not necessarily the (perhaps conjugate)
    transposes of each other.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL, Academic
    Press, Inc., 1980, Various pp.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: (Almost) trivial example with real eigenvalues and eigenvectors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Real matrix possessing complex eigenvalues and eigenvectors; note that the eigenvalues
    are complex conjugates of each other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Complex-valued matrix with real eigenvalues (but complex-valued eigenvectors);
    note that `a.conj().T == a`, i.e., *a* is Hermitian.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Be careful about round-off error!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
