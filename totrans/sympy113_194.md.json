["```py\nclass sympy.physics.mechanics.pathway.LinearPathway(*attachments)\n```", "```py\nP           Q\no<--- F --->o\n|           |\n|<--l(t)--->| \n```", "```py\n>>> from sympy.physics.mechanics import LinearPathway \n```", "```py\n>>> from sympy.physics.mechanics import Point\n>>> pA, pB = Point('pA'), Point('pB')\n>>> linear_pathway = LinearPathway(pA, pB)\n>>> linear_pathway\nLinearPathway(pA, pB) \n```", "```py\n>>> from sympy.physics.mechanics import ReferenceFrame\n>>> from sympy.physics.vector import dynamicsymbols\n>>> N = ReferenceFrame('N')\n>>> q = dynamicsymbols('q')\n>>> pB.set_pos(pA, q*N.x)\n>>> pB.pos_from(pA)\nq(t)*N.x \n```", "```py\n>>> linear_pathway.length\nsqrt(q(t)**2) \n```", "```py\n>>> linear_pathway.extension_velocity\nsqrt(q(t)**2)*Derivative(q(t), t)/q(t) \n```", "```py\nproperty extension_velocity\n```", "```py\nproperty length\n```", "```py\nto_loads(force)\n```", "```py\n>>> from sympy.physics.mechanics import (LinearPathway, Point,\n...     ReferenceFrame)\n>>> from sympy.physics.vector import dynamicsymbols\n>>> q = dynamicsymbols('q')\n>>> N = ReferenceFrame('N')\n>>> pA, pB = Point('pA'), Point('pB')\n>>> pB.set_pos(pA, q*N.x)\n>>> linear_pathway = LinearPathway(pA, pB) \n```", "```py\n>>> from sympy import symbols\n>>> F = symbols('F')\n>>> linear_pathway.to_loads(F)\n[(pA, - F*q(t)/sqrt(q(t)**2)*N.x), (pB, F*q(t)/sqrt(q(t)**2)*N.x)] \n```", "```py\nclass sympy.physics.mechanics.pathway.ObstacleSetPathway(*attachments)\n```", "```py\n>>> from sympy.physics.mechanics import ObstacleSetPathway, Point\n>>> pA, pB, pC, pD = Point('pA'), Point('pB'), Point('pC'), Point('pD')\n>>> obstacle_set_pathway = ObstacleSetPathway(pA, pB, pC, pD)\n>>> obstacle_set_pathway\nObstacleSetPathway(pA, pB, pC, pD) \n```", "```py\n>>> from sympy import cos, sin\n>>> from sympy.physics.mechanics import ReferenceFrame\n>>> from sympy.physics.vector import dynamicsymbols\n>>> N = ReferenceFrame('N')\n>>> q = dynamicsymbols('q')\n>>> pO = Point('pO')\n>>> pA.set_pos(pO, N.y)\n>>> pB.set_pos(pO, -N.x)\n>>> pC.set_pos(pA, cos(q) * N.x - (sin(q) + 1) * N.y)\n>>> pD.set_pos(pA, sin(q) * N.x + (cos(q) - 1) * N.y)\n>>> pB.pos_from(pA)\n- N.x - N.y\n>>> pC.pos_from(pA)\ncos(q(t))*N.x + (-sin(q(t)) - 1)*N.y\n>>> pD.pos_from(pA)\nsin(q(t))*N.x + (cos(q(t)) - 1)*N.y \n```", "```py\n>>> obstacle_set_pathway.length.simplify()\nsqrt(2)*(sqrt(cos(q(t)) + 1) + 2) \n```", "```py\n>>> obstacle_set_pathway.extension_velocity.simplify()\n-sqrt(2)*sin(q(t))*Derivative(q(t), t)/(2*sqrt(cos(q(t)) + 1)) \n```", "```py\nproperty attachments\n```", "```py\nproperty extension_velocity\n```", "```py\nproperty length\n```", "```py\nto_loads(force)\n```", "```py\n>>> from sympy.physics.mechanics import (ObstacleSetPathway, Point,\n...     ReferenceFrame)\n>>> from sympy.physics.vector import dynamicsymbols\n>>> q = dynamicsymbols('q')\n>>> N = ReferenceFrame('N')\n>>> N = ReferenceFrame('N')\n>>> A = N.orientnew('A', 'axis', (0, N.x))\n>>> B = A.orientnew('B', 'axis', (q, N.z))\n>>> pO = Point('pO')\n>>> pA, pB, pC, pD = Point('pA'), Point('pB'), Point('pC'), Point('pD')\n>>> pA.set_pos(pO, A.x)\n>>> pB.set_pos(pO, -A.y)\n>>> pC.set_pos(pO, B.y)\n>>> pD.set_pos(pO, B.x)\n>>> obstacle_set_pathway = ObstacleSetPathway(pA, pB, pC, pD) \n```", "```py\n>>> from sympy import Symbol\n>>> F = Symbol('F')\n>>> obstacle_set_pathway.to_loads(F)\n[(pA, sqrt(2)*F/2*A.x + sqrt(2)*F/2*A.y),\n (pB, - sqrt(2)*F/2*A.x - sqrt(2)*F/2*A.y),\n (pB, - F/sqrt(2*cos(q(t)) + 2)*A.y - F/sqrt(2*cos(q(t)) + 2)*B.y),\n (pC, F/sqrt(2*cos(q(t)) + 2)*A.y + F/sqrt(2*cos(q(t)) + 2)*B.y),\n (pC, - sqrt(2)*F/2*B.x + sqrt(2)*F/2*B.y),\n (pD, sqrt(2)*F/2*B.x - sqrt(2)*F/2*B.y)] \n```", "```py\nclass sympy.physics.mechanics.pathway.PathwayBase(*attachments)\n```", "```py\nproperty attachments\n```", "```py\nabstract property extension_velocity\n```", "```py\nabstract property length\n```", "```py\nabstract to_loads(force)\n```", "```py\nclass sympy.physics.mechanics.pathway.WrappingPathway(attachment_1, attachment_2, geometry)\n```", "```py\nP           Q\no<--- F --->o\n|           |\n|<--l(t)--->| \n```", "```py\n>>> from sympy.physics.mechanics import WrappingPathway \n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.mechanics import Point, ReferenceFrame, WrappingCylinder\n>>> r = symbols('r')\n>>> N = ReferenceFrame('N')\n>>> pA, pB, pO = Point('pA'), Point('pB'), Point('pO')\n>>> cylinder = WrappingCylinder(r, pO, N.x)\n>>> wrapping_pathway = WrappingPathway(pA, pB, cylinder)\n>>> wrapping_pathway\nWrappingPathway(pA, pB, geometry=WrappingCylinder(radius=r, point=pO,\n axis=N.x)) \n```", "```py\nproperty extension_velocity\n```", "```py\nproperty geometry\n```", "```py\nproperty length\n```", "```py\nto_loads(force)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.mechanics import (Point, ReferenceFrame,\n...     WrappingCylinder)\n>>> N = ReferenceFrame('N')\n>>> r = symbols('r', positive=True)\n>>> pO = Point('pO')\n>>> cylinder = WrappingCylinder(r, pO, N.z) \n```", "```py\n>>> from sympy import cos, sin\n>>> from sympy.physics.mechanics import WrappingPathway, dynamicsymbols\n>>> q = dynamicsymbols('q')\n>>> pA = Point('pA')\n>>> pB = Point('pB')\n>>> pA.set_pos(pO, r*N.x)\n>>> pB.set_pos(pO, r*(cos(q)*N.x + sin(q)*N.y))\n>>> pB.pos_from(pA)\n(r*cos(q(t)) - r)*N.x + r*sin(q(t))*N.y\n>>> pathway = WrappingPathway(pA, pB, cylinder) \n```", "```py\n>>> F = symbols('F')\n>>> loads = pathway.to_loads(F)\n>>> [load.__class__(load.location, load.vector.simplify()) for load in loads]\n[(pA, F*N.y), (pB, F*sin(q(t))*N.x - F*cos(q(t))*N.y),\n (pO, - F*sin(q(t))*N.x + F*(cos(q(t)) - 1)*N.y)] \n```"]