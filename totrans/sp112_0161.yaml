- en: scipy.interpolate.BarycentricInterpolator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.interpolate.BarycentricInterpolator.html#scipy.interpolate.BarycentricInterpolator](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.interpolate.BarycentricInterpolator.html#scipy.interpolate.BarycentricInterpolator)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Interpolating polynomial for a set of points.
  prefs: []
  type: TYPE_NORMAL
- en: Constructs a polynomial that passes through a given set of points. Allows evaluation
    of the polynomial and all its derivatives, efficient changing of the y-values
    to be interpolated, and updating by adding more x- and y-values.
  prefs: []
  type: TYPE_NORMAL
- en: For reasons of numerical stability, this function does not compute the coefficients
    of the polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: The values *yi* need to be provided before the function is evaluated, but none
    of the preprocessing depends on them, so rapid updates are possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**xi**array_like, shape (npoints, )'
  prefs: []
  type: TYPE_NORMAL
- en: 1-D array of x coordinates of the points the polynomial should pass through
  prefs: []
  type: TYPE_NORMAL
- en: '**yi**array_like, shape (…, npoints, …), optional'
  prefs: []
  type: TYPE_NORMAL
- en: N-D array of y coordinates of the points the polynomial should pass through.
    If None, the y values will be supplied later via the *set_y* method. The length
    of *yi* along the interpolation axis must be equal to the length of *xi*. Use
    the `axis` parameter to select correct axis.
  prefs: []
  type: TYPE_NORMAL
- en: '**axis**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Axis in the yi array corresponding to the x-coordinate values. Defaults to `axis=0`.
  prefs: []
  type: TYPE_NORMAL
- en: '**wi**array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The barycentric weights for the chosen interpolation points *xi*. If absent
    or None, the weights will be computed from *xi* (default). This allows for the
    reuse of the weights *wi* if several interpolants are being calculated using the
    same nodes *xi*, without re-computation.
  prefs: []
  type: TYPE_NORMAL
- en: '**random_state**{None, int, [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)"), [`numpy.random.RandomState`](https://numpy.org/devdocs/reference/random/legacy.html#numpy.random.RandomState
    "(in NumPy v2.0.dev0)")}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *seed* is None (or *np.random*), the [`numpy.random.RandomState`](https://numpy.org/devdocs/reference/random/legacy.html#numpy.random.RandomState
    "(in NumPy v2.0.dev0)") singleton is used. If *seed* is an int, a new `RandomState`
    instance is used, seeded with *seed*. If *seed* is already a `Generator` or `RandomState`
    instance then that instance is used.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This class uses a “barycentric interpolation” method that treats the problem
    as a special case of rational function interpolation. This algorithm is quite
    stable, numerically, but even in a world of exact computation, unless the x coordinates
    are chosen very carefully - Chebyshev zeros (e.g., cos(i*pi/n)) are a good choice
    - polynomial interpolation itself is a very ill-conditioned process due to the
    Runge phenomenon.
  prefs: []
  type: TYPE_NORMAL
- en: Based on Berrut and Trefethen 2004, “Barycentric Lagrange Interpolation”.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'To produce a quintic barycentric interpolant approximating the function \(\sin
    x\), and its first four derivatives, using six randomly-spaced nodes in \((0,
    \frac{\pi}{2})\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-interpolate-BarycentricInterpolator-1.png](../Images/f01cf0c8dad044e32829f9107ce7be02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype**'
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| [`__call__`](scipy.interpolate.BarycentricInterpolator.__call__.html#scipy.interpolate.BarycentricInterpolator.__call__
    "scipy.interpolate.BarycentricInterpolator.__call__")(x) | Evaluate the interpolating
    polynomial at the points x |'
  prefs: []
  type: TYPE_TB
- en: '| [`add_xi`](scipy.interpolate.BarycentricInterpolator.add_xi.html#scipy.interpolate.BarycentricInterpolator.add_xi
    "scipy.interpolate.BarycentricInterpolator.add_xi")(xi[, yi]) | Add more x values
    to the set to be interpolated |'
  prefs: []
  type: TYPE_TB
- en: '| [`derivative`](scipy.interpolate.BarycentricInterpolator.derivative.html#scipy.interpolate.BarycentricInterpolator.derivative
    "scipy.interpolate.BarycentricInterpolator.derivative")(x[, der]) | Evaluate a
    single derivative of the polynomial at the point x. |'
  prefs: []
  type: TYPE_TB
- en: '| [`derivatives`](scipy.interpolate.BarycentricInterpolator.derivatives.html#scipy.interpolate.BarycentricInterpolator.derivatives
    "scipy.interpolate.BarycentricInterpolator.derivatives")(x[, der]) | Evaluate
    several derivatives of the polynomial at the point *x* |'
  prefs: []
  type: TYPE_TB
- en: '| [`set_yi`](scipy.interpolate.BarycentricInterpolator.set_yi.html#scipy.interpolate.BarycentricInterpolator.set_yi
    "scipy.interpolate.BarycentricInterpolator.set_yi")(yi[, axis]) | Update the y
    values to be interpolated |'
  prefs: []
  type: TYPE_TB
