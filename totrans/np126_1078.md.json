["```py\ntype PyDataMem_Handler\n```", "```py\ntypedef  struct  {\n  char  name[127];  /* multiple of 64 to keep the struct aligned */\n  uint8_t  version;  /* currently 1 */\n  PyDataMemAllocator  allocator;\n}  PyDataMem_Handler; \n```", "```py\n/* The declaration of free differs from PyMemAllocatorEx */\ntypedef  struct  {\n  void  *ctx;\n  void*  (*malloc)  (void  *ctx,  size_t  size);\n  void*  (*calloc)  (void  *ctx,  size_t  nelem,  size_t  elsize);\n  void*  (*realloc)  (void  *ctx,  void  *ptr,  size_t  new_size);\n  void  (*free)  (void  *ctx,  void  *ptr,  size_t  size);\n}  PyDataMemAllocator; \n```", "```py\n*PyDataMem_SetHandler( *handler)\n```", "```py\n*PyDataMem_GetHandler()\n```", "```py\nvoid PyDataMem_EventHookFunc(void *inp, void *outp, size_t size, void *user_data);\n```", "```py\n*PyDataMem_SetEventHook( *newhook, void *user_data, void **old_data)\n```", "```py\nresult  =  PyDataMem_NEW(size)  ->  (*hook)(NULL,  result,  size,  user_data)\nPyDataMem_FREE(ptr)  ->  (*hook)(ptr,  NULL,  0,  user_data)\nresult  =  PyDataMem_RENEW(ptr,  size)  ->  (*hook)(ptr,  result,  size,  user_data) \n```", "```py\n/* define a PyCapsule_Destructor, using the correct deallocator for buff */\nvoid  free_wrap(void  *capsule){\n  void  *  obj  =  PyCapsule_GetPointer(capsule,  PyCapsule_GetName(capsule));\n  free(obj);\n};\n\n/* then inside the function that creates arr from buff */\n...\narr  =  PyArray_NewFromDescr(...  buf,  ...);\nif  (arr  ==  NULL)  {\n  return  NULL;\n}\ncapsule  =  PyCapsule_New(buf,  \"my_wrapped_buffer\",\n  (PyCapsule_Destructor)&free_wrap);\nif  (PyArray_SetBaseObject(arr,  capsule)  ==  -1)  {\n  Py_DECREF(arr);\n  return  NULL;\n}\n... \n```", "```py\n\"\"\"\n The goal of this example is to show how to trace memory\n from an application that has NumPy and non-NumPy sections.\n We only select the sections using NumPy related calls.\n\"\"\"\n\nimport tracemalloc\nimport numpy as np\n\n# Flag to determine if we select NumPy domain\nuse_np_domain = True\n\nnx = 300\nny = 500\n\n# Start to trace memory\ntracemalloc.start()\n\n# Section 1\n# ---------\n\n# NumPy related call\na = np.zeros((nx,ny))\n\n# non-NumPy related call\nb = [i**2 for i in range(nx*ny)]\n\nsnapshot1 = tracemalloc.take_snapshot()\n# We filter the snapshot to only select NumPy related calls\nnp_domain = np.lib.tracemalloc_domain\ndom_filter = tracemalloc.DomainFilter(inclusive=use_np_domain,\n                                      domain=np_domain)\nsnapshot1 = snapshot1.filter_traces([dom_filter])\ntop_stats1 = snapshot1.statistics('traceback')\n\nprint(\"================ SNAPSHOT 1 =================\")\nfor stat in top_stats1:\n    print(f\"{stat.count} memory blocks: {stat.size  /  1024:.1f} KiB\")\n    print(stat.traceback.format()[-1])\n\n# Clear traces of memory blocks allocated by Python\n# before moving to the next section.\ntracemalloc.clear_traces()\n\n# Section 2\n#----------\n\n# We are only using NumPy\nc = np.sum(a*a)\n\nsnapshot2 = tracemalloc.take_snapshot()\ntop_stats2 = snapshot2.statistics('traceback')\n\nprint()\nprint(\"================ SNAPSHOT 2 =================\")\nfor stat in top_stats2:\n    print(f\"{stat.count} memory blocks: {stat.size  /  1024:.1f} KiB\")\n    print(stat.traceback.format()[-1])\n\ntracemalloc.stop()\n\nprint()\nprint(\"============================================\")\nprint(\"\\nTracing Status : \", tracemalloc.is_tracing())\n\ntry:\n    print(\"\\nTrying to Take Snapshot After Tracing is Stopped.\")\n    snap = tracemalloc.take_snapshot()\nexcept Exception as e:\n    print(\"Exception : \", e) \n```", "```py\ntype PyDataMem_Handler\n```", "```py\ntypedef  struct  {\n  char  name[127];  /* multiple of 64 to keep the struct aligned */\n  uint8_t  version;  /* currently 1 */\n  PyDataMemAllocator  allocator;\n}  PyDataMem_Handler; \n```", "```py\n/* The declaration of free differs from PyMemAllocatorEx */\ntypedef  struct  {\n  void  *ctx;\n  void*  (*malloc)  (void  *ctx,  size_t  size);\n  void*  (*calloc)  (void  *ctx,  size_t  nelem,  size_t  elsize);\n  void*  (*realloc)  (void  *ctx,  void  *ptr,  size_t  new_size);\n  void  (*free)  (void  *ctx,  void  *ptr,  size_t  size);\n}  PyDataMemAllocator; \n```", "```py\n*PyDataMem_SetHandler( *handler)\n```", "```py\n*PyDataMem_GetHandler()\n```", "```py\nvoid PyDataMem_EventHookFunc(void *inp, void *outp, size_t size, void *user_data);\n```", "```py\n*PyDataMem_SetEventHook( *newhook, void *user_data, void **old_data)\n```", "```py\nresult  =  PyDataMem_NEW(size)  ->  (*hook)(NULL,  result,  size,  user_data)\nPyDataMem_FREE(ptr)  ->  (*hook)(ptr,  NULL,  0,  user_data)\nresult  =  PyDataMem_RENEW(ptr,  size)  ->  (*hook)(ptr,  result,  size,  user_data) \n```", "```py\n/* define a PyCapsule_Destructor, using the correct deallocator for buff */\nvoid  free_wrap(void  *capsule){\n  void  *  obj  =  PyCapsule_GetPointer(capsule,  PyCapsule_GetName(capsule));\n  free(obj);\n};\n\n/* then inside the function that creates arr from buff */\n...\narr  =  PyArray_NewFromDescr(...  buf,  ...);\nif  (arr  ==  NULL)  {\n  return  NULL;\n}\ncapsule  =  PyCapsule_New(buf,  \"my_wrapped_buffer\",\n  (PyCapsule_Destructor)&free_wrap);\nif  (PyArray_SetBaseObject(arr,  capsule)  ==  -1)  {\n  Py_DECREF(arr);\n  return  NULL;\n}\n... \n```", "```py\n\"\"\"\n The goal of this example is to show how to trace memory\n from an application that has NumPy and non-NumPy sections.\n We only select the sections using NumPy related calls.\n\"\"\"\n\nimport tracemalloc\nimport numpy as np\n\n# Flag to determine if we select NumPy domain\nuse_np_domain = True\n\nnx = 300\nny = 500\n\n# Start to trace memory\ntracemalloc.start()\n\n# Section 1\n# ---------\n\n# NumPy related call\na = np.zeros((nx,ny))\n\n# non-NumPy related call\nb = [i**2 for i in range(nx*ny)]\n\nsnapshot1 = tracemalloc.take_snapshot()\n# We filter the snapshot to only select NumPy related calls\nnp_domain = np.lib.tracemalloc_domain\ndom_filter = tracemalloc.DomainFilter(inclusive=use_np_domain,\n                                      domain=np_domain)\nsnapshot1 = snapshot1.filter_traces([dom_filter])\ntop_stats1 = snapshot1.statistics('traceback')\n\nprint(\"================ SNAPSHOT 1 =================\")\nfor stat in top_stats1:\n    print(f\"{stat.count} memory blocks: {stat.size  /  1024:.1f} KiB\")\n    print(stat.traceback.format()[-1])\n\n# Clear traces of memory blocks allocated by Python\n# before moving to the next section.\ntracemalloc.clear_traces()\n\n# Section 2\n#----------\n\n# We are only using NumPy\nc = np.sum(a*a)\n\nsnapshot2 = tracemalloc.take_snapshot()\ntop_stats2 = snapshot2.statistics('traceback')\n\nprint()\nprint(\"================ SNAPSHOT 2 =================\")\nfor stat in top_stats2:\n    print(f\"{stat.count} memory blocks: {stat.size  /  1024:.1f} KiB\")\n    print(stat.traceback.format()[-1])\n\ntracemalloc.stop()\n\nprint()\nprint(\"============================================\")\nprint(\"\\nTracing Status : \", tracemalloc.is_tracing())\n\ntry:\n    print(\"\\nTrying to Take Snapshot After Tracing is Stopped.\")\n    snap = tracemalloc.take_snapshot()\nexcept Exception as e:\n    print(\"Exception : \", e) \n```"]