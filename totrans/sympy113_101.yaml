- en: Numerical Evaluation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/evalf.html](https://docs.sympy.org/latest/modules/evalf.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Basics'
  prefs: []
  type: TYPE_NORMAL
- en: Exact SymPy expressions can be converted to floating-point approximations (decimal
    numbers) using either the `.evalf()` method or the `N()` function. `N(expr, <args>)`
    is equivalent to `sympify(expr).evalf(<args>)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, numerical evaluation is performed to an accuracy of 15 decimal
    digits. You can optionally pass a desired accuracy (which should be a positive
    integer) as an argument to `evalf` or `N`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Complex numbers are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the expression contains symbols or for some other reason cannot be evaluated
    numerically, calling `.evalf()` or `N()` returns the original expression, or in
    some cases a partially evaluated expression. For example, when the expression
    is a polynomial in expanded form, the coefficients are evaluated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the standard Python functions `float()`, `complex()` to convert
    SymPy expressions to regular Python numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If these functions are used, failure to evaluate the expression to an explicit
    number (for example if the expression contains symbols) will raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is essentially no upper precision limit. The following command, for example,
    computes the first 100,000 digits of π/e:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows digits 999,951 through 1,000,000 of pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: High-precision calculations can be slow. It is recommended (but entirely optional)
    to install gmpy ([https://github.com/aleaxit/gmpy](https://github.com/aleaxit/gmpy)),
    which will significantly speed up computations such as the one above.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Floating-point numbers in SymPy are instances of the class `Float`. A `Float`
    can be created with a custom precision as second argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As the last example shows, some Python floats are only accurate to about 15
    digits as inputs, while others (those that have a denominator that is a power
    of 2, like 0.125 = 1/8) are exact. To create a `Float` from a high-precision decimal
    number, it is better to pass a string, `Rational`, or `evalf` a `Rational`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The precision of a number determines 1) the precision to use when performing
    arithmetic with the number, and 2) the number of digits to display when printing
    the number. When two numbers with different precision are used together in an
    arithmetic operation, the higher of the precisions is used for the result. The
    product of 0.1 +/- 0.001 and 3.1415 +/- 0.0001 has an uncertainty of about 0.003
    and yet 5 digits of precision are shown.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So the displayed precision should not be used as a model of error propagation
    or significance arithmetic; rather, this scheme is employed to ensure stability
    of numerical algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: '`N` and `evalf` can be used to change the precision of existing floating-point
    numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Accuracy and error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the input to `N` or `evalf` is a complicated expression, numerical error
    propagation becomes a concern. As an example, consider the 100’th Fibonacci number
    and the excellent (but not exact) approximation \(\varphi^{100} / \sqrt{5}\) where
    \(\varphi\) is the golden ratio. With ordinary floating-point arithmetic, subtracting
    these numbers from each other erroneously results in a complete cancellation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`N` and `evalf` keep track of errors and automatically increase the precision
    used internally in order to obtain a correct result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, numerical evaluation cannot tell an expression that is exactly
    zero apart from one that is merely very small. The working precision is therefore
    capped, by default to around 100 digits. If we try with the 1000’th Fibonacci
    number, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The lack of digits in the returned number indicates that `N` failed to achieve
    full accuracy. The result indicates that the magnitude of the expression is something
    less than 10^84, but that is not a particularly good answer. To force a higher
    working precision, the `maxn` keyword argument can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, `maxn` can be set very high (thousands of digits), but be aware that
    this may cause significant slowdown in extreme cases. Alternatively, the `strict=True`
    option can be set to force an exception instead of silently returning a value
    with less than the requested accuracy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we add a term so that the Fibonacci approximation becomes exact (the full
    form of Binet’s formula), we get an expression that is exactly zero, but `N` does
    not know this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In situations where such cancellations are known to occur, the `chop` options
    is useful. This basically replaces very small numbers in the real or imaginary
    portions of a number with exact zeros:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In situations where you wish to remove meaningless digits, re-evaluation or
    the use of the `round` method are useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are dealing with a numeric expression that contains no floats, it can
    be evaluated to arbitrary precision. To round the result relative to a given decimal,
    the round method is useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Sums and integrals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sums (in particular, infinite series) and integrals can be used like regular
    closed-form expressions, and support arbitrary-precision evaluation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the tanh-sinh quadrature algorithm is used to evaluate integrals.
    This algorithm is very efficient and robust for smooth integrands (and even integrals
    with endpoint singularities), but may struggle with integrals that are highly
    oscillatory or have mid-interval discontinuities. In many cases, `evalf`/`N` will
    correctly estimate the error. With the following integral, the result is accurate
    but only good to four digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It is better to split this integral into two pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar example is the following oscillatory integral:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be dealt with much more efficiently by telling `evalf` or `N` to use
    an oscillatory quadrature algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Oscillatory quadrature requires an integrand containing a factor cos(ax+b)
    or sin(ax+b). Note that many other oscillatory integrals can be transformed to
    this form with a change of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Infinite series use direct summation if the series converges quickly enough.
    Otherwise, extrapolation methods (generally the Euler-Maclaurin formula but also
    Richardson extrapolation) are used to speed up convergence. This allows high-precision
    evaluation of slowly convergent series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The Euler-Maclaurin formula is also used for finite series, allowing them to
    be approximated quickly without evaluating all terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that `evalf` makes some assumptions that are not always optimal. For fine-tuned
    control over numerical summation, it might be worthwhile to manually use the method
    `Sum.euler_maclaurin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Special optimizations are used for rational hypergeometric series (where the
    term is a product of polynomials, powers, factorials, binomial coefficients and
    the like). `N`/`evalf` sum series of this type very rapidly to high precision.
    For example, this Ramanujan formula for pi can be summed to 10,000 digits in a
    fraction of a second with a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Numerical simplification
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The function `nsimplify` attempts to find a formula that is numerically equal
    to the given input. This feature can be used to guess an exact formula for an
    approximate floating-point input, or to guess a simpler formula for a complicated
    symbolic input. The algorithm used by `nsimplify` is capable of identifying simple
    fractions, simple algebraic expressions, linear combinations of given constants,
    and certain elementary functional transformations of any of the preceding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, `nsimplify` can be passed a list of constants to include (e.g.
    pi) and a minimum numerical tolerance. Here are some elementary examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are several more advanced examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
