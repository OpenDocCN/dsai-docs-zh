["```py\n>>> from sympy.abc import x, y\n>>> a = x - y\n>>> print(a)\nx - y \n```", "```py\n>>> (x + 1)**2 == x**2 + 2*x + 1\nFalse\n>>> (x + 1)**2 == (x + 1)**2\nTrue \n```", "```py\n>>> from sympy import simplify, cos, sin, expand\n>>> simplify((x + 1)**2 - (x**2 + 2*x + 1))\n0\n>>> eq = sin(2*x) - 2*sin(x)*cos(x)\n>>> simplify(eq)\n0\n>>> expand(eq, trig=True)\n0 \n```", "```py\n>>> from sympy import Symbol\n>>> a = Symbol('a')  # Symbol, `a`, stored as variable \"a\"\n>>> b = a + 1        # an expression involving `a` stored as variable \"b\"\n>>> print(b)\na + 1\n>>> a = 4            # \"a\" now points to literal integer 4, not Symbol('a')\n>>> print(a)\n4\n>>> print(b)          # \"b\" is still pointing at the expression involving `a`\na + 1 \n```", "```py\n>>> from sympy import var\n>>> r, t, d = var('rate time short_life')\n>>> d = r*t\n>>> print(d)\nrate*time\n>>> r = 80\n>>> t = 2\n>>> print(d)        # We haven't changed d, only r and t\nrate*time\n>>> d = r*t\n>>> print(d)        # Now d is using the current values of r and t\n160 \n```", "```py\n>>> c, d = var('c d')\n>>> print(c)\nc\n>>> print(d)\nd\n>>> def ctimesd():\n...  \"\"\"\n...     This function returns whatever c is times whatever d is.\n...     \"\"\"\n...     return c*d\n...\n>>> ctimesd()\nc*d\n>>> c = 2\n>>> print(c)\n2\n>>> ctimesd()\n2*d \n```", "```py\n>>> def a():\n...     return b()\n...\n>>> def b():\n...     return a()\n...\n>>> a() \nTraceback (most recent call last):\n File \"...\", line ..., in ...\n compileflags, 1) in test.globs\n File \"<...>\", line 1, in <module>\n a()\n File \"<...>\", line 2, in a\n return b()\n File \"<...>\", line 2, in b\n return a()\n File \"<...>\", line 2, in a\n return b()\n...\nRuntimeError: maximum recursion depth exceeded \n```", "```py\n>>> import sympy\n>>> z**2  # z is not defined yet \nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nNameError: name 'z' is not defined\n>>> sympy.var('z')  # This is the easiest way to define z as a standard symbol\nz\n>>> z**2\nz**2 \n```", "```py\n>>> from __future__ import division\n>>> from sympy import *\n>>> x, y, z, t = symbols('x y z t')\n>>> k, m, n = symbols('k m n', integer=True)\n>>> f, g, h = symbols('f g h', cls=Function) \n```", "```py\n>>> from sympy.abc import w\n>>> w\nw\n>>> import sympy\n>>> dir(sympy.abc)  \n['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',\n'P', 'Q', 'R', 'S', 'Symbol', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n'__builtins__', '__doc__', '__file__', '__name__', '__package__', '_greek',\n'_latin', 'a', 'alpha', 'b', 'beta', 'c', 'chi', 'd', 'delta', 'e',\n'epsilon', 'eta', 'f', 'g', 'gamma', 'h', 'i', 'iota', 'j', 'k', 'kappa',\n'l', 'm', 'mu', 'n', 'nu', 'o', 'omega', 'omicron', 'p', 'phi', 'pi',\n'psi', 'q', 'r', 'rho', 's', 'sigma', 't', 'tau', 'theta', 'u', 'upsilon',\n'v', 'w', 'x', 'xi', 'y', 'z', 'zeta'] \n```", "```py\n>>> cos(pi)  # cos and pi are a built-in sympy names.\n-1\n>>> pi = 3   # Notice that there is no warning for overriding pi.\n>>> cos(pi)\ncos(3)\n>>> def cos(x):  # No warning for overriding built-in functions either.\n...     return 5*x\n...\n>>> cos(pi)\n15\n>>> from sympy import cos  # reimport to restore normal behavior \n```", "```py\n>>> import sympy\n>>> dir(sympy)  \n# A big list of all default sympy names and functions follows.\n# Ignore everything that starts and ends with __. \n```", "```py\n>>> from sympy import Function\n>>> f = Function('f')\n>>> x = Symbol('x')\n>>> f(x)\nf(x) \n```", "```py\n>>> f1 = Function('f1')\n>>> f2 = Function('f2')('x')\n>>> f1\nf1\n>>> f2\nf2(x)\n>>> f1(1)\nf1(1)\n>>> f2(1)\nTraceback (most recent call last):\n...\nTypeError: 'f2' object is not callable\n>>> f2.subs(x, 1)\nf2(1) \n```", "```py\n>>> 6.2  # Python float. Notice the floating point accuracy problems.\n6.2000000000000002\n>>> type(6.2)  # <type 'float'> in Python 2.x,  <class 'float'> in Py3k\n<... 'float'>\n>>> S(6.2)  # SymPy Float has no such problems because of arbitrary precision.\n6.20000000000000\n>>> type(S(6.2))\n<class 'sympy.core.numbers.Float'> \n```", "```py\n>>> x**(1/2)  # evaluates to x**0 or x**0.5\nx**0.5\n>>> x**(S(1)/2)  # sympyify one of the ints\nsqrt(x)\n>>> x**Rational(1, 2)  # use the Rational class\nsqrt(x) \n```", "```py\n>>> sqrt(x) == x**Rational(1, 2)\nTrue \n```", "```py\n>>> x**(2*x/3)\nx**(2*x/3) \n```", "```py\n>>> x = Symbol('x')\n>>> print(solve(7*x -22, x))\n[22/7]\n>>> 22/7  # If we just copy and paste we get int 3 or a float\n3.142857142857143\n>>> # One solution is to just assign the expression to a variable\n>>> # if we need to use it again.\n>>> a = solve(7*x - 22, x)[0]\n>>> a\n22/7 \n```", "```py\n>>> S(\"22/7\")\n22/7 \n```", "```py\n> >>> from __future__ import division\n> \n> >>> 1/2   # With division imported it evaluates to a python float\n> \n> 0.5\n> \n> >>> 1//2  # You can still achieve integer division with //\n> \n> 0 \n> ```", "```py\n> >>> x**(1/2)\n> \n> x**0.5 \n> ```", "```py\n>>> Rational(2, x)\nTraceback (most recent call last):\n...\nTypeError: invalid input: x\n>>> 2/x\n2/x \n```", "```py\n> >>> Float(100)\n> \n> 100.000000000000\n> \n> >>> Float('100', 5)\n> \n> 100.00 \n> ```", "```py\n> >>> Float(100, '')\n> \n> 100.\n> \n> >>> Float('12.34')\n> \n> 12.3400000000000\n> \n> >>> Float('12.34', '')\n> \n> 12.34 \n> ```", "```py\n> >>> s, r = [Float(j, 3) for j in ('0.25', Rational(1, 7))]\n> \n> >>> for f in [s, r]:\n> \n> ...     print(f)\n> \n> 0.250\n> \n> 0.143 \n> ```", "```py\n> >>> s.n(20)\n> \n> 0.25000000000000000000\n> \n> >>> r.n(20)\n> \n> 0.14285278320312500000 \n> ```", "```py\n>>> Float('0.1', 10) + Float('0.1', 3)\n0.2000061035 \n```", "```py\n>>> big = 12345678901234567890\n>>> big_trig_identity = big*cos(x)**2 + big*sin(x)**2 - big*1\n>>> abs(big_trig_identity.subs(x, .1).n(2)) > 1000\nTrue \n```", "```py\n> >>> big_trig_identity.n(2, {x: 0.1})\n> \n> -0.e-91 \n> ```", "```py\n> >>> big_trig_identity.subs(x, S('1/10')).n(2)\n> \n> 0.e-91 \n> ```", "```py\n> >>> big_trig_identity.simplify()\n> \n> 0 \n> ```", "```py\ndef main():\n    var('x y a b')\n    expr = 3*x + 4*y\n    print('original =', expr)\n    expr_modified = expr.subs({x: a, y: b})\n    print('modified =', expr_modified)\n\nif __name__ == \"__main__\":\n    main() \n```", "```py\noriginal = 3*x + 4*y\nmodified = 3*a + 4*b \n```", "```py\n>>> 2x\nTraceback (most recent call last):\n...\nSyntaxError: invalid syntax\n>>> 2*x\n2*x\n>>> (x + 1)^2  # This is not power.  Use ** instead.\nTraceback (most recent call last):\n...\nTypeError: unsupported operand type(s) for ^: 'Add' and 'int'\n>>> (x + 1)**2\n(x + 1)**2\n>>> pprint(3 - x**(2*x)/(x + 1))\n 2*x\n x\n- ----- + 3\n x + 1 \n```", "```py\n>>> (y + sqrt(x)).find(Wild('w')**S.Half)\n{sqrt(x)}\n>>> (y + 1/sqrt(x)).find(Wild('w')**-S.Half)\n{1/sqrt(x)} \n```", "```py\n>>> sq = lambda s: s.is_Pow and s.exp.is_Rational and s.exp.q == 2\n>>> (y + sqrt(x)**3).find(sq)\n{x**(3/2)} \n```", "```py\n>>> a = [x, 1]  # A simple list of two items\n>>> a\n[x, 1]\n>>> a[0]  # This is the first item\nx\n>>> a[0] = 2  # You can change values of lists after they have been created\n>>> print(a)\n[2, 1]\n>>> print(solve(x**2 + 2*x - 1, x)) # Some functions return lists\n[-1 + sqrt(2), -sqrt(2) - 1] \n```", "```py\n>>> d = {'a': 1, 'b': 2}  # A dictionary.\n>>> d\n{'a': 1, 'b': 2}\n>>> d['a']  # How to access items in a dict\n1\n>>> roots((x - 1)**2*(x - 2), x)  # Some functions return dicts\n{1: 2, 2: 1}\n>>> # Some SymPy functions return dictionaries.  For example,\n>>> # roots returns a dictionary of root:multiplicity items.\n>>> roots((x - 5)**2*(x + 3), x)\n{-3: 1, 5: 2}\n>>> # This means that the root -3 occurs once and the root 5 occurs twice. \n```", "```py\n> >>> t = (1, 2, x)  # Tuples are like lists\n> \n> >>> t\n> \n> (1, 2, x)\n> \n> >>> t[0]\n> \n> 1\n> \n> >>> t[0] = 4  # Except you cannot change them after they have been created\n> \n> Traceback (most recent call last):\n> \n>   File \"<console>\", line 1, in <module>\n> \n> TypeError: 'tuple' object does not support item assignment \n> ```", "```py\n> >>> (x,)\n> \n> (x,) \n> ```", "```py\n> >>> (x)\n> \n> x \n> ```", "```py\n> >>> integrate(x**2, (x, 0, 1))\n> \n> 1/3\n> \n> >>> integrate(x**2, [x, 0, 1])\n> \n> 1/3 \n> ```", "```py\n> >>> sqrt(x**2)\n> \n> sqrt(x**2) \n> ```", "```py\n> >>> x = Symbol('x', positive=True) \n> ```", "```py\n> >>> sqrt(x**2)\n> \n> x \n> ```", "```py\n> >>> pprint(powsimp(x**n*x**m*y**n*y**m))\n> \n>  m + n\n> \n> (x*y) \n> ```", "```py\n> >>> pprint(powsimp(x**n*x**m*y**n*y**m, combine='all'))\n> \n>  m + n\n> \n> (x*y) \n> ```", "```py\n> >>> pprint(powsimp(x**n*x**m*y**n*y**m, combine='exp'))\n> \n>  m + n  m + n\n> \n> x     *y \n> ```", "```py\n> >>> pprint(powsimp(x**n*x**m*y**n*y**m, combine='base'))\n> \n>  m      n\n> \n> (x*y) *(x*y) \n> ```", "```py\nIn [1]: help(powsimp)  # help() works everywhere\n\nIn [2]: # But in ipython, you can also use ?, which is better because it\nIn [3]: # it gives you more information\nIn [4]: powsimp? \n```", "```py\nsympy.simplify.simplify.powsimp(expr, deep=False, combine='all', force=False, measure=<function count_ops>)\n```", "```py\n a   a          a                          2x      x\nx * y  =>  (x*y)   as well as things like 2   =>  4 \n```", "```py\n a   b      (a + b)\nx * x  =>  x \n```", "```py\n>>> from sympy import powsimp, exp, log, symbols\n>>> from sympy.abc import x, y, z, n\n>>> powsimp(x**y*x**z*y**z, combine='all')\nx**(y + z)*y**z\n>>> powsimp(x**y*x**z*y**z, combine='exp')\nx**(y + z)*y**z\n>>> powsimp(x**y*x**z*y**z, combine='base', force=True)\nx**y*(x*y)**z \n```", "```py\n>>> powsimp(x**z*x**y*n**z*n**y, combine='all', force=True)\n(n*x)**(y + z)\n>>> powsimp(x**z*x**y*n**z*n**y, combine='exp')\nn**(y + z)*x**(y + z)\n>>> powsimp(x**z*x**y*n**z*n**y, combine='base', force=True)\n(n*x)**y*(n*x)**z \n```", "```py\n>>> x, y = symbols('x y', positive=True)\n>>> powsimp(log(exp(x)*exp(y)))\nlog(exp(x)*exp(y))\n>>> powsimp(log(exp(x)*exp(y)), deep=True)\nx + y \n```", "```py\n>>> from sympy import sqrt\n>>> x, y = symbols('x y') \n```", "```py\n>>> a=sqrt(x*sqrt(y))\n>>> a*a**3 == a**4\nTrue \n```", "```py\n>>> a**4 # auto expands to a Mul, no longer a Pow\nx**2*y\n>>> _*a # so Mul doesn't combine them\nx**2*y*sqrt(x*sqrt(y))\n>>> powsimp(_) # but powsimp will\n(x*sqrt(y))**(5/2)\n>>> powsimp(x*y*a) # but won't when doing so would violate assumptions\nx*y*sqrt(x*sqrt(y)) \n```"]