["```py\nimport numpy as np\nimport numba as nb\n\nfrom numpy.random import PCG64\nfrom timeit import timeit\n\nbit_gen = PCG64()\nnext_d = bit_gen.cffi.next_double\nstate_addr = bit_gen.cffi.state_address\n\ndef normals(n, state):\n    out = np.empty(n)\n    for i in range((n + 1) // 2):\n        x1 = 2.0 * next_d(state) - 1.0\n        x2 = 2.0 * next_d(state) - 1.0\n        r2 = x1 * x1 + x2 * x2\n        while r2 >= 1.0 or r2 == 0.0:\n            x1 = 2.0 * next_d(state) - 1.0\n            x2 = 2.0 * next_d(state) - 1.0\n            r2 = x1 * x1 + x2 * x2\n        f = np.sqrt(-2.0 * np.log(r2) / r2)\n        out[2 * i] = f * x1\n        if 2 * i + 1 < n:\n            out[2 * i + 1] = f * x2\n    return out\n\n# Compile using Numba\nnormalsj = nb.jit(normals, nopython=True)\n# Must use state address not state with numba\nn = 10000\n\ndef numbacall():\n    return normalsj(n, state_addr)\n\nrg = np.random.Generator(PCG64())\n\ndef numpycall():\n    return rg.normal(size=n)\n\n# Check that the functions work\nr1 = numbacall()\nr2 = numpycall()\nassert r1.shape == (n,)\nassert r1.shape == r2.shape\n\nt1 = timeit(numbacall, number=1000)\nprint(f'{t1:.2f} secs for {n} PCG64 (Numba/PCG64) gaussian randoms')\nt2 = timeit(numpycall, number=1000)\nprint(f'{t2:.2f} secs for {n} PCG64 (NumPy/PCG64) gaussian randoms') \n```", "```py\n#!/usr/bin/env python3\n#cython: language_level=3\n\"\"\"\nThis file shows how the to use a BitGenerator to create a distribution.\n\"\"\"\nimport numpy as np\ncimport numpy as np\ncimport cython\nfrom cpython.pycapsule cimport PyCapsule_IsValid, PyCapsule_GetPointer\nfrom libc.stdint cimport uint16_t, uint64_t\nfrom numpy.random cimport bitgen_t\nfrom numpy.random import PCG64\nfrom numpy.random.c_distributions cimport (\n      random_standard_uniform_fill, random_standard_uniform_fill_f)\n\n@cython.boundscheck(False)\n@cython.wraparound(False)\ndef uniforms(Py_ssize_t n):\n  \"\"\"\n Create an array of `n` uniformly distributed doubles.\n A 'real' distribution would want to process the values into\n some non-uniform distribution\n \"\"\"\n    cdef Py_ssize_t i\n    cdef bitgen_t *rng\n    cdef const char *capsule_name = \"BitGenerator\"\n    cdef double[::1] random_values\n\n    x = PCG64()\n    capsule = x.capsule\n    # Optional check that the capsule if from a BitGenerator\n    if not PyCapsule_IsValid(capsule, capsule_name):\n        raise ValueError(\"Invalid pointer to anon_func_state\")\n    # Cast the pointer\n    rng = <bitgen_t *> PyCapsule_GetPointer(capsule, capsule_name)\n    random_values = np.empty(n, dtype='float64')\n    with x.lock, nogil:\n        for i in range(n):\n            # Call the function\n            random_values[i] = rng.next_double(rng.state)\n    randoms = np.asarray(random_values)\n\n    return randoms \n```", "```py\n@cython.boundscheck(False)\n@cython.wraparound(False)\ndef uint10_uniforms(Py_ssize_t n):\n  \"\"\"Uniform 10 bit integers stored as 16-bit unsigned integers\"\"\"\n    cdef Py_ssize_t i\n    cdef bitgen_t *rng\n    cdef const char *capsule_name = \"BitGenerator\"\n    cdef uint16_t[::1] random_values\n    cdef int bits_remaining\n    cdef int width = 10\n    cdef uint64_t buff, mask = 0x3FF\n\n    x = PCG64()\n    capsule = x.capsule\n    if not PyCapsule_IsValid(capsule, capsule_name):\n        raise ValueError(\"Invalid pointer to anon_func_state\")\n    rng = <bitgen_t *> PyCapsule_GetPointer(capsule, capsule_name)\n    random_values = np.empty(n, dtype='uint16')\n    # Best practice is to release GIL and acquire the lock\n    bits_remaining = 0\n    with x.lock, nogil:\n        for i in range(n):\n            if bits_remaining < width:\n                buff = rng.next_uint64(rng.state)\n            random_values[i] = buff & mask\n            buff >>= width\n\n    randoms = np.asarray(random_values)\n    return randoms \n```", "```py\ndef uniforms_ex(bit_generator, Py_ssize_t n, dtype=np.float64):\n  \"\"\"\n Create an array of `n` uniformly distributed doubles via a \"fill\" function.\n\n A 'real' distribution would want to process the values into\n some non-uniform distribution\n\n Parameters\n ----------\n bit_generator: BitGenerator instance\n n: int\n Output vector length\n dtype: {str, dtype}, optional\n Desired dtype, either 'd' (or 'float64') or 'f' (or 'float32'). The\n default dtype value is 'd'\n \"\"\"\n    cdef Py_ssize_t i\n    cdef bitgen_t *rng\n    cdef const char *capsule_name = \"BitGenerator\"\n    cdef np.ndarray randoms\n\n    capsule = bit_generator.capsule\n    # Optional check that the capsule if from a BitGenerator\n    if not PyCapsule_IsValid(capsule, capsule_name):\n        raise ValueError(\"Invalid pointer to anon_func_state\")\n    # Cast the pointer\n    rng = <bitgen_t *> PyCapsule_GetPointer(capsule, capsule_name)\n\n    _dtype = np.dtype(dtype)\n    randoms = np.empty(n, dtype=_dtype)\n    if _dtype == np.float32:\n        with bit_generator.lock:\n            random_standard_uniform_fill_f(rng, n, <float*>np.PyArray_DATA(randoms))\n    elif _dtype == np.float64:\n        with bit_generator.lock:\n            random_standard_uniform_fill(rng, n, <double*>np.PyArray_DATA(randoms))\n    else:\n        raise TypeError('Unsupported dtype %r for random' % _dtype)\n    return randoms \n```", "```py\n\"\"\"\nUse cffi to access any of the underlying C functions from distributions.h\n\"\"\"\nimport os\nimport numpy as np\nimport cffi\nfrom .parse import parse_distributions_h\nffi = cffi.FFI()\n\ninc_dir = os.path.join(np.get_include(), 'numpy')\n\n# Basic numpy types\nffi.cdef('''\n typedef intptr_t npy_intp;\n typedef unsigned char npy_bool;\n\n''')\n\nparse_distributions_h(ffi, inc_dir) \n```", "```py\n # Compare the distributions.h random_standard_normal_fill to\n# Generator.standard_random\nbit_gen = np.random.PCG64()\nrng = np.random.Generator(bit_gen)\nstate = bit_gen.state\n\ninterface = rng.bit_generator.cffi\nn = 100\nvals_cffi = ffi.new('double[%d]' % n)\nlib.random_standard_normal_fill(interface.bit_generator, n, vals_cffi)\n\n# reset the state\nbit_gen.state = state\n\nvals = rng.standard_normal(n)\n\nfor i in range(n):\n    assert vals[i] == vals_cffi[i] \n```", "```py\ntypedef  struct  bitgen  {\n  void  *state;\n  uint64_t  (*next_uint64)(void  *st);\n  uint32_t  (*next_uint32)(void  *st);\n  double  (*next_double)(void  *st);\n  uint64_t  (*next_raw)(void  *st);\n}  bitgen_t; \n```", "```py\nbitgen_state->next_uint64(bitgen_state->state) \n```", "```py\nimport numpy as np\nimport numba as nb\n\nfrom numpy.random import PCG64\nfrom timeit import timeit\n\nbit_gen = PCG64()\nnext_d = bit_gen.cffi.next_double\nstate_addr = bit_gen.cffi.state_address\n\ndef normals(n, state):\n    out = np.empty(n)\n    for i in range((n + 1) // 2):\n        x1 = 2.0 * next_d(state) - 1.0\n        x2 = 2.0 * next_d(state) - 1.0\n        r2 = x1 * x1 + x2 * x2\n        while r2 >= 1.0 or r2 == 0.0:\n            x1 = 2.0 * next_d(state) - 1.0\n            x2 = 2.0 * next_d(state) - 1.0\n            r2 = x1 * x1 + x2 * x2\n        f = np.sqrt(-2.0 * np.log(r2) / r2)\n        out[2 * i] = f * x1\n        if 2 * i + 1 < n:\n            out[2 * i + 1] = f * x2\n    return out\n\n# Compile using Numba\nnormalsj = nb.jit(normals, nopython=True)\n# Must use state address not state with numba\nn = 10000\n\ndef numbacall():\n    return normalsj(n, state_addr)\n\nrg = np.random.Generator(PCG64())\n\ndef numpycall():\n    return rg.normal(size=n)\n\n# Check that the functions work\nr1 = numbacall()\nr2 = numpycall()\nassert r1.shape == (n,)\nassert r1.shape == r2.shape\n\nt1 = timeit(numbacall, number=1000)\nprint(f'{t1:.2f} secs for {n} PCG64 (Numba/PCG64) gaussian randoms')\nt2 = timeit(numpycall, number=1000)\nprint(f'{t2:.2f} secs for {n} PCG64 (NumPy/PCG64) gaussian randoms') \n```", "```py\n#!/usr/bin/env python3\n#cython: language_level=3\n\"\"\"\nThis file shows how the to use a BitGenerator to create a distribution.\n\"\"\"\nimport numpy as np\ncimport numpy as np\ncimport cython\nfrom cpython.pycapsule cimport PyCapsule_IsValid, PyCapsule_GetPointer\nfrom libc.stdint cimport uint16_t, uint64_t\nfrom numpy.random cimport bitgen_t\nfrom numpy.random import PCG64\nfrom numpy.random.c_distributions cimport (\n      random_standard_uniform_fill, random_standard_uniform_fill_f)\n\n@cython.boundscheck(False)\n@cython.wraparound(False)\ndef uniforms(Py_ssize_t n):\n  \"\"\"\n Create an array of `n` uniformly distributed doubles.\n A 'real' distribution would want to process the values into\n some non-uniform distribution\n \"\"\"\n    cdef Py_ssize_t i\n    cdef bitgen_t *rng\n    cdef const char *capsule_name = \"BitGenerator\"\n    cdef double[::1] random_values\n\n    x = PCG64()\n    capsule = x.capsule\n    # Optional check that the capsule if from a BitGenerator\n    if not PyCapsule_IsValid(capsule, capsule_name):\n        raise ValueError(\"Invalid pointer to anon_func_state\")\n    # Cast the pointer\n    rng = <bitgen_t *> PyCapsule_GetPointer(capsule, capsule_name)\n    random_values = np.empty(n, dtype='float64')\n    with x.lock, nogil:\n        for i in range(n):\n            # Call the function\n            random_values[i] = rng.next_double(rng.state)\n    randoms = np.asarray(random_values)\n\n    return randoms \n```", "```py\n@cython.boundscheck(False)\n@cython.wraparound(False)\ndef uint10_uniforms(Py_ssize_t n):\n  \"\"\"Uniform 10 bit integers stored as 16-bit unsigned integers\"\"\"\n    cdef Py_ssize_t i\n    cdef bitgen_t *rng\n    cdef const char *capsule_name = \"BitGenerator\"\n    cdef uint16_t[::1] random_values\n    cdef int bits_remaining\n    cdef int width = 10\n    cdef uint64_t buff, mask = 0x3FF\n\n    x = PCG64()\n    capsule = x.capsule\n    if not PyCapsule_IsValid(capsule, capsule_name):\n        raise ValueError(\"Invalid pointer to anon_func_state\")\n    rng = <bitgen_t *> PyCapsule_GetPointer(capsule, capsule_name)\n    random_values = np.empty(n, dtype='uint16')\n    # Best practice is to release GIL and acquire the lock\n    bits_remaining = 0\n    with x.lock, nogil:\n        for i in range(n):\n            if bits_remaining < width:\n                buff = rng.next_uint64(rng.state)\n            random_values[i] = buff & mask\n            buff >>= width\n\n    randoms = np.asarray(random_values)\n    return randoms \n```", "```py\ndef uniforms_ex(bit_generator, Py_ssize_t n, dtype=np.float64):\n  \"\"\"\n Create an array of `n` uniformly distributed doubles via a \"fill\" function.\n\n A 'real' distribution would want to process the values into\n some non-uniform distribution\n\n Parameters\n ----------\n bit_generator: BitGenerator instance\n n: int\n Output vector length\n dtype: {str, dtype}, optional\n Desired dtype, either 'd' (or 'float64') or 'f' (or 'float32'). The\n default dtype value is 'd'\n \"\"\"\n    cdef Py_ssize_t i\n    cdef bitgen_t *rng\n    cdef const char *capsule_name = \"BitGenerator\"\n    cdef np.ndarray randoms\n\n    capsule = bit_generator.capsule\n    # Optional check that the capsule if from a BitGenerator\n    if not PyCapsule_IsValid(capsule, capsule_name):\n        raise ValueError(\"Invalid pointer to anon_func_state\")\n    # Cast the pointer\n    rng = <bitgen_t *> PyCapsule_GetPointer(capsule, capsule_name)\n\n    _dtype = np.dtype(dtype)\n    randoms = np.empty(n, dtype=_dtype)\n    if _dtype == np.float32:\n        with bit_generator.lock:\n            random_standard_uniform_fill_f(rng, n, <float*>np.PyArray_DATA(randoms))\n    elif _dtype == np.float64:\n        with bit_generator.lock:\n            random_standard_uniform_fill(rng, n, <double*>np.PyArray_DATA(randoms))\n    else:\n        raise TypeError('Unsupported dtype %r for random' % _dtype)\n    return randoms \n```", "```py\n\"\"\"\nUse cffi to access any of the underlying C functions from distributions.h\n\"\"\"\nimport os\nimport numpy as np\nimport cffi\nfrom .parse import parse_distributions_h\nffi = cffi.FFI()\n\ninc_dir = os.path.join(np.get_include(), 'numpy')\n\n# Basic numpy types\nffi.cdef('''\n typedef intptr_t npy_intp;\n typedef unsigned char npy_bool;\n\n''')\n\nparse_distributions_h(ffi, inc_dir) \n```", "```py\n # Compare the distributions.h random_standard_normal_fill to\n# Generator.standard_random\nbit_gen = np.random.PCG64()\nrng = np.random.Generator(bit_gen)\nstate = bit_gen.state\n\ninterface = rng.bit_generator.cffi\nn = 100\nvals_cffi = ffi.new('double[%d]' % n)\nlib.random_standard_normal_fill(interface.bit_generator, n, vals_cffi)\n\n# reset the state\nbit_gen.state = state\n\nvals = rng.standard_normal(n)\n\nfor i in range(n):\n    assert vals[i] == vals_cffi[i] \n```", "```py\ntypedef  struct  bitgen  {\n  void  *state;\n  uint64_t  (*next_uint64)(void  *st);\n  uint32_t  (*next_uint32)(void  *st);\n  double  (*next_double)(void  *st);\n  uint64_t  (*next_raw)(void  *st);\n}  bitgen_t; \n```", "```py\nbitgen_state->next_uint64(bitgen_state->state) \n```"]