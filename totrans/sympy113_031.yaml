- en: Solve an Ordinary Differential Equation (ODE) Algebraically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/guides/solving/solve-ode.html](https://docs.sympy.org/latest/guides/solving/solve-ode.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Use SymPy to solve an ordinary differential equation (ODE) algebraically. For
    example, solving \(y''(x) + 9y(x)=0 \) yields \( y(x)=C_{1} \sin(3x)+ C_{2} \cos(3x)\).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatives to Consider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To numerically solve a system of ODEs, use a [SciPy ODE solver](https://docs.scipy.org/doc/scipy/reference/integrate.html#solving-initial-value-problems-for-ode-systems)
    such as `solve_ivp`. You can also use SymPy to create and then [`lambdify()`](../../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify") an ODE to be solved numerically using SciPy’s
    as `solve_ivp` as described below in [Numerically Solve an ODE in SciPy](#numerically-solve-an-ode-in-scipy).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solve an Ordinary Differential Equation (ODE)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here is an example of solving the above ordinary differential equation algebraically
    using [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve").
    You can then use [`checkodesol()`](../../modules/solvers/ode.html#sympy.solvers.ode.checkodesol
    "sympy.solvers.ode.checkodesol") to verify that the solution is correct.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The output of [`checkodesol()`](../../modules/solvers/ode.html#sympy.solvers.ode.checkodesol
    "sympy.solvers.ode.checkodesol") is a tuple where the first item, a boolean, tells
    whether substituting the solution into the ODE results in `0`, indicating the
    solution is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Guidance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Defining Derivatives
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are many ways to express derivatives of functions. For an undefined function,
    both [`Derivative`](../../modules/core.html#sympy.core.function.Derivative "sympy.core.function.Derivative")
    and [`diff()`](../../modules/core.html#sympy.core.function.diff "sympy.core.function.diff")
    represent the undefined derivative. Thus, all of the following `ypp` (“y prime
    prime”) represent \(y''''\), the second derivative with respect to \(x\) of a
    function \(y(x)\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We recommend specifying the function to be solved for, as the second argument
    to [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve").
    Note that it must be a function rather than a variable (symbol). SymPy will give
    an error if you specify a variable (\(x\)) rather than a function (\(f(x)\)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, you must specify the argument of the function: \(y(x)\), not just
    \(y\).'
  prefs: []
  type: TYPE_NORMAL
- en: Options to Define an ODE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can define the function to be solved for in two ways. The subsequent syntax
    for specifying initial conditions depends on your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: Define a Function Without Including Its Independent Variable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can define a function without including its independent variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that you supply the functions to be solved for as a list as the second
    argument of [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), here `[f(x), g(x)]`.
  prefs: []
  type: TYPE_NORMAL
- en: Specify Initial Conditions or Boundary Conditions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If your differential equation(s) have initial or boundary conditions, specify
    them with the [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") optional argument `ics`. Initial and boundary conditions
    are treated the same way (even though the argument is called `ics`). It should
    be given in the form of `{f(x0): y0, f(x).diff(x).subs(x, x1): y1}` and so on
    where, for example, the value of \(f(x)\) at \(x = x_{0}\) is \(y_{0}\). For power
    series solutions, if no initial conditions are specified \(f(0)\) is assumed to
    be \(C_{0}\) and the power series solution is calculated about \(0\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of setting the initial values for functions, namely namely
    \(f(0) = 1\) and \(g(2) = 3\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of setting the initial value for the derivative of a function,
    namely \(f''(1) = 2\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Option 2: Define a Function of an Independent Variable'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may prefer to specify a function (for example \(y\)) of its independent
    variable (for example \(t\)), so that `y` represents `y(t)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Using this convention, the second argument of [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), `y`, represents `y(t)`, so SymPy recognizes it as
    a valid function to solve for.
  prefs: []
  type: TYPE_NORMAL
- en: Specify Initial Conditions or Boundary Conditions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Using that syntax, you specify initialor boundary conditions by substituting
    in values of the independent variable using [`subs()`](../../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs") because the function \(y\) already has its independent
    variable as an argument \(t\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Beware Copying and Pasting Results
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If you choose to define a function of an independent variable, note that copying
    a result and pasting it into subsequent code may cause an error because `x` is
    already defined as `y(t)`, so if you paste in `y(t)` it is interpreted as `y(t)(t)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So remember to exclude the independent variable call `(t)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Use the Solution Result
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike other solving functions, [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") returns an [`Equality`](../../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality") (equation) formatted as, for example, `Eq(y(x),
    C1*sin(3*x) + C2*cos(3*x))` which is equivalent to the mathematical notation \(y(x)
    = C_1 \sin(3x) + C_2 \cos(3x)\).
  prefs: []
  type: TYPE_NORMAL
- en: Extract the Result for One Solution and Function
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can extract the result from an [`Equality`](../../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality") using the right-hand side property [`rhs`](../../modules/core.html#sympy.core.relational.Relational.rhs
    "sympy.core.relational.Relational.rhs"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Some ODEs Cannot Be Solved Explicitly, Only Implicitly
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The above ODE can be solved explicitly, specifically \(y(x)\) can be expressed
    in terms of functions of \(x\). However, some ODEs cannot be solved explicitly,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This gives no direct expression for \(f(x)\). Instead, [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") expresses a solution as \(g(f(x))\) where \(g\) is
    [`Ei`](../../modules/functions/special.html#sympy.functions.special.error_functions.Ei
    "sympy.functions.special.error_functions.Ei"), the classical exponential integral
    function. `Ei` does not have a known closed-form inverse, so a solution cannot
    be explicitly expressed as \(f(x)\) equaling a function of \(x\). Instead, `dsolve`
    returns an [implicit solution](https://en.wikipedia.org/wiki/Implicit_function).
  prefs: []
  type: TYPE_NORMAL
- en: When `dsolve` returns an implicit solution, extracting the right-hand side of
    the returned equality will not give an explicitly expression for the function
    to be solved for, here \(f(x)\). So before extracting an expression for the function
    to be solved for, check that `dsolve` was able to solve for the function explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Extract the Result for Multiple Function-Solution Pairs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are solving a system of equations with multiple unknown functions, the
    form of the output of [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") depends on whether there is one or multiple solutions.
  prefs: []
  type: TYPE_NORMAL
- en: If There is One Solution Set
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'If there is only one solution set to a system of equations with multiple unknown
    functions, [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") will return a non-nested list containing an equality.
    You can extract the solution expression using a single loop or comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If There are Multiple Solution Sets
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If there are multiple solution sets to a system of equations with multiple unknown
    functions, [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") will return a nested list of equalities, the outer
    list representing each solution and the inner list representing each function.
    While you can extract results by specifying the index of each function, we recommend
    an approach which is robust with respect to function ordering. The following converts
    each solution into a dictionary so you can easily extract the result for the desired
    function. It uses standard Python techniques such as loops or comprehensions,
    in a nested fashion.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Work With Arbitrary Constants
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can manipulate arbitrary constants such as `C1`, `C2`, and `C3`, which
    are generated automatically by [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), by creating them as symbols. For example, if you
    want to assign values to arbitrary constants, you can create them as symbols and
    then substitute in their values using [`subs()`](../../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Numerically Solve an ODE in SciPy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common workflow which leverages [SciPy’s](https://docs.scipy.org/doc/scipy/index.html)
    fast numerical ODE solving is
  prefs: []
  type: TYPE_NORMAL
- en: set up an ODE in SymPy
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: convert it to a numerical function using [`lambdify()`](../../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify")
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: solve the initial value problem by [numerically integrating the ODE using SciPy’s
    `solve_ivp`](https://docs.scipy.org/doc/scipy/reference/integrate.html#solving-initial-value-problems-for-ode-systems).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is an [example from the field of chemical kinetics](https://www.sympy.org/scipy-2017-codegen-tutorial/notebooks/25-chemical-kinetics-intro.html)
    where the nonlinear ordinary differential equations take this form:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split} r_f = & k_f y_0(t)^2 y_1(t) \\ r_b = & k_b y_2(t)^2 \\ \frac{d
    y_0(t)}{dt} = & 2(r_b - r_f) \\ \frac{d y_1(t)}{dt} = & r_b - r_f \\ \frac{d y_2(t)}{dt}
    = & 2(r_f - r_b) \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\vec{y}(t) = \begin{bmatrix} y_0(t) \\ y_1(t) \\ y_2(t) \end{bmatrix}
    \end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: ([`png`](../../_downloads/283e3d4dc325ad83368162cd075bcb83/solve-ode-1.png),
    [`hires.png`](../../_downloads/da2287c494dfc71aef8da50395b3d20d/solve-ode-1.hires.png),
    [`pdf`](../../_downloads/95feb1999af91b22f624aa3ce3c6b1c4/solve-ode-1.pdf))
  prefs: []
  type: TYPE_NORMAL
- en: '![../../_images/solve-ode-1.png](../Images/78505417a69f1215297a3dfb220dec94.png)'
  prefs: []
  type: TYPE_IMG
- en: SciPy’s `solve_ivp` returns a result containing `y` (numerical function result,
    here, concentration) values for each of the three chemical species, corresponding
    to the time points `t_eval`.
  prefs: []
  type: TYPE_NORMAL
- en: Ordinary Differential Equation Solving Hints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Return Unevaluated Integrals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") attempts to evaluate the integrals it produces to
    solve your ordinary differential equation. You can disable evaluation of the integrals
    by using [Hint Functions](../../modules/solvers/ode.html#hints) ending with `_Integral`,
    for example `separable_Integral`. This is useful because [`integrate()`](../../modules/core.html#sympy.core.expr.Expr.integrate
    "sympy.core.expr.Expr.integrate") is an expensive routine. SymPy may hang (appear
    to never complete the operation) because of a difficult or impossible integral,
    so using an `_Integral` hint will at least return an (unintegrated) result, which
    you can then consider. The simplest way to disable integration is with the `all_Integral`
    hint because you do not need to know which hint to supply: for any hint with a
    corresponding `_Integral` hint, `all_Integral` only returns the `_Integral` hint.'
  prefs: []
  type: TYPE_NORMAL
- en: Select a Specific Solver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may wish to select a specific solver using a hint for a couple of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: 'educational purposes: for example if you are learning about a specific method
    to solve ODEs and want to get a result that exactly matches that method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'form of the result: sometimes an ODE can be solved by many different solvers,
    and they can return different results. They will be mathematically equivalent,
    though the arbitrary constants may not be. [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve") by default tries to use the “best” solvers first,
    which are most likely to return the most usable output, but it is not a perfect
    heuristic. For example, the “best” solver may produce a result with an integral
    that SymPy cannot solve, but another solver may produce a different integral that
    SymPy can solve. So if the solution isn’t in a form you like, you can try other
    hints to check whether they give a preferable result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not All Equations Can Be Solved
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Equations With No Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all differential equations can be solved, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Equations With No Closed-Form Solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted above, [Some ODEs Cannot Be Solved Explicitly, Only Implicitly](#some-odes-cannot-be-solved-explicitly-only-implicitly).
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, some systems of differential equations have no closed-form solution because
    they are chaotic, for example the [Lorenz system](https://en.wikipedia.org/wiki/Lorenz_system#Overview)
    or a double pendulum described by these two differential equations (simplified
    from [ScienceWorld](https://scienceworld.wolfram.com/physics/DoublePendulum.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: \[ 2 \theta_1''(t) + \theta_2''(t) \cos(\theta_1-\theta_2) + \theta_2'^2(t)
    \sin(\theta_1 - \theta_2) + 2g \sin(\theta_1) = 0 \]\[ \theta_2''(t) + \theta_1''(t)
    \cos(\theta_1-\theta_2) - \theta_1'^2(t) \sin(\theta_1 - \theta_2) + g \sin(\theta_2)
    = 0 \]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: For such cases, you can solve the equations numerically as mentioned in [Alternatives
    to Consider](#alternatives-to-consider).
  prefs: []
  type: TYPE_NORMAL
- en: Report a Bug
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you find a bug with [`dsolve()`](../../modules/solvers/ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve"), please post the problem on the [SymPy mailing list](https://groups.google.com/g/sympy).
    Until the issue is resolved, you can use a different method listed in [Alternatives
    to Consider](#alternatives-to-consider).
  prefs: []
  type: TYPE_NORMAL
