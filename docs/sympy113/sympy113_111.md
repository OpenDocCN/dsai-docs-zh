# 矩阵（线性代数）

> 原文链接：[https://docs.sympy.org/latest/modules/matrices/matrices.html](https://docs.sympy.org/latest/modules/matrices/matrices.html)

## 创建矩阵

线性代数模块旨在尽可能简单。首先，我们导入并声明我们的第一个`Matrix`对象：

```py
>>> from sympy.interactive.printing import init_printing
>>> init_printing(use_unicode=False)
>>> from sympy.matrices import Matrix, eye, zeros, ones, diag, GramSchmidt
>>> M = Matrix([[1,0,0], [0,0,0]]); M
[1  0  0]
[       ]
[0  0  0]
>>> Matrix([M, (0, 0, -1)])
[1  0  0 ]
[        ]
[0  0  0 ]
[        ]
[0  0  -1]
>>> Matrix([[1, 2, 3]])
[1 2 3]
>>> Matrix([1, 2, 3])
[1]
[ ]
[2]
[ ]
[3] 
```

除了从适当大小的列表和/或矩阵创建矩阵外，SymPy还支持更高级的矩阵创建方法，包括使用单个值列表和尺寸输入：

```py
>>> Matrix(2, 3, [1, 2, 3, 4, 5, 6])
[1  2  3]
[       ]
[4  5  6] 
```

更有趣（和有用）的是能够使用一个二变量函数（或`lambda`）来创建矩阵。这里我们创建一个指示函数，在对角线上为1，然后用它来生成单位矩阵：

```py
>>> def f(i,j):
...     if i == j:
...         return 1
...     else:
...         return 0
...
>>> Matrix(4, 4, f)
[1  0  0  0]
[          ]
[0  1  0  0]
[          ]
[0  0  1  0]
[          ]
[0  0  0  1] 
```

最后让我们使用`lambda`来创建一个一行矩阵，其中偶排列的条目为1：

```py
>>> Matrix(3, 4, lambda i,j: 1 - (i+j) % 2)
[1  0  1  0]
[          ]
[0  1  0  1]
[          ]
[1  0  1  0] 
```

也有几个快速构建矩阵的特殊构造函数：`eye`是单位矩阵，`zeros`和`ones`分别是全零和全一矩阵，`diag`用于将矩阵或元素放置在对角线上：

```py
>>> eye(4)
[1  0  0  0]
[          ]
[0  1  0  0]
[          ]
[0  0  1  0]
[          ]
[0  0  0  1]
>>> zeros(2)
[0  0]
[    ]
[0  0]
>>> zeros(2, 5)
[0  0  0  0  0]
[             ]
[0  0  0  0  0]
>>> ones(3)
[1  1  1]
[       ]
[1  1  1]
[       ]
[1  1  1]
>>> ones(1, 3)
[1  1  1]
>>> diag(1, Matrix([[1, 2], [3, 4]]))
[1  0  0]
[       ]
[0  1  2]
[       ]
[0  3  4] 
```

## 基本操作

在学习如何处理矩阵时，让我们选择一个其条目容易辨认的例子。有一点很有用的是，虽然矩阵是二维的，但存储不是，因此可以（尽管应谨慎）像访问一维列表一样访问条目。

```py
>>> M = Matrix(2, 3, [1, 2, 3, 4, 5, 6])
>>> M[4]
5 
```

现在，更标准的条目访问是一对索引，它们将始终返回矩阵对应行和列的值：

```py
>>> M[1, 2]
6
>>> M[0, 0]
1
>>> M[1, 1]
5 
```

由于这是Python，我们也能够切片子矩阵；切片始终返回一个矩阵，即使维度是1 x 1：

```py
>>> M[0:2, 0:2]
[1  2]
[    ]
[4  5]
>>> M[2:2, 2]
[]
>>> M[:, 2]
[3]
[ ]
[6]
>>> M[:1, 2]
[3] 
```

在上述第二个例子中，请注意切片2:2会得到一个空范围。还要注意（符合Python的从0开始索引），第一行/列是0。

除非它们在一个切片中，否则无法访问不存在的行或列：

```py
>>> M[:, 10] # the 10-th column (not there)
Traceback (most recent call last):
...
IndexError: Index out of range: a[[0, 10]]
>>> M[:, 10:11] # the 10-th column (if there)
[]
>>> M[:, :10] # all columns up to the 10-th
[1  2  3]
[       ]
[4  5  6] 
```

切片一个空矩阵可以工作，只要你在没有大小的坐标上使用一个切片：

```py
>>> Matrix(0, 3, [])[:, 1]
[] 
```

切片会返回被切片对象的副本，因此一个对象的修改不会影响另一个对象：

```py
>>> M2 = M[:, :]
>>> M2[0, 0] = 100
>>> M[0, 0] == 100
False 
```

注意，改变`M2`并没有改变`M`。由于我们可以切片，我们也可以分配条目：

```py
>>> M = Matrix(([1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]))
>>> M
[1   2   3   4 ]
[              ]
[5   6   7   8 ]
[              ]
[9   10  11  12]
[              ]
[13  14  15  16]
>>> M[2,2] = M[0,3] = 0
>>> M
[1   2   3   0 ]
[              ]
[5   6   7   8 ]
[              ]
[9   10  0   12]
[              ]
[13  14  15  16] 
```

以及分配切片：

```py
>>> M = Matrix(([1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]))
>>> M[2:,2:] = Matrix(2,2,lambda i,j: 0)
>>> M
[1   2   3  4]
[            ]
[5   6   7  8]
[            ]
[9   10  0  0]
[            ]
[13  14  0  0] 
```

支持所有标准算术运算：

```py
>>> M = Matrix(([1,2,3],[4,5,6],[7,8,9]))
>>> M - M
[0  0  0]
[       ]
[0  0  0]
[       ]
[0  0  0]
>>> M + M
[2   4   6 ]
[          ]
[8   10  12]
[          ]
[14  16  18]
>>> M * M
[30   36   42 ]
[             ]
[66   81   96 ]
[             ]
[102  126  150]
>>> M2 = Matrix(3,1,[1,5,0])
>>> M*M2
[11]
[  ]
[29]
[  ]
[47]
>>> M**2
[30   36   42 ]
[             ]
[66   81   96 ]
[             ]
[102  126  150] 
```

以及一些有用的向量操作：

```py
>>> M.row_del(0)
>>> M
[4  5  6]
[       ]
[7  8  9]
>>> M.col_del(1)
>>> M
[4  6]
[    ]
[7  9]
>>> v1 = Matrix([1,2,3])
>>> v2 = Matrix([4,5,6])
>>> v3 = v1.cross(v2)
>>> v1.dot(v2)
32
>>> v2.dot(v3)
0
>>> v1.dot(v3)
0 
```

回忆一下，`row_del()`和`col_del()`操作不会返回值 - 它们只是改变矩阵对象。我们也可以将合适大小的矩阵‘’粘合‘’在一起：

```py
>>> M1 = eye(3)
>>> M2 = zeros(3, 4)
>>> M1.row_join(M2)
[1  0  0  0  0  0  0]
[                   ]
[0  1  0  0  0  0  0]
[                   ]
[0  0  1  0  0  0  0]
>>> M3 = zeros(4, 3)
>>> M1.col_join(M3)
[1  0  0]
[       ]
[0  1  0]
[       ]
[0  0  1]
[       ]
[0  0  0]
[       ]
[0  0  0]
[       ]
[0  0  0]
[       ]
[0  0  0] 
```

## 操作条目

我们不限于在两个矩阵之间进行乘法：

```py
>>> M = eye(3)
>>> 2*M
[2  0  0]
[       ]
[0  2  0]
[       ]
[0  0  2]
>>> 3*M
[3  0  0]
[       ]
[0  3  0]
[       ]
[0  0  3] 
```

但是我们也可以使用`applyfunc()`对我们的矩阵条目应用函数。这里我们将声明一个函数，使任何输入数加倍。然后我们将它应用于3x3单位矩阵：

```py
>>> f = lambda x: 2*x
>>> eye(3).applyfunc(f)
[2  0  0]
[       ]
[0  2  0]
[       ]
[0  0  2] 
```

如果您想从矩阵中提取一个公因数，可以通过将`gcd`应用于矩阵的数据来实现：

```py
>>> from sympy.abc import x, y
>>> from sympy import gcd
>>> m = Matrix([[x, y], [1, x*y]]).inv('ADJ'); m
[  x*y       -y    ]
[--------  --------]
[ 2         2      ]
[x *y - y  x *y - y]
[                  ]
[  -1         x    ]
[--------  --------]
[ 2         2      ]
[x *y - y  x *y - y]
>>> gcd(tuple(_))
 1
--------
 2
x *y - y
>>> m/_
[x*y  -y]
[       ]
[-1   x ] 
```

另一个有用的整体矩阵应用函数是替换函数。让我们声明一个带有符号条目的矩阵，然后替换一个值。记住，我们可以替换任何东西 - 即使是另一个符号！：

```py
>>> from sympy import Symbol
>>> x = Symbol('x')
>>> M = eye(3) * x
>>> M
[x  0  0]
[       ]
[0  x  0]
[       ]
[0  0  x]
>>> M.subs(x, 4)
[4  0  0]
[       ]
[0  4  0]
[       ]
[0  0  4]
>>> y = Symbol('y')
>>> M.subs(x, y)
[y  0  0]
[       ]
[0  y  0]
[       ]
[0  0  y] 
```

## 线性代数

现在我们已经了解了基本内容，让我们看看实际矩阵可以做些什么。当然，首先想到的是行列式：

```py
>>> M = Matrix(( [1, 2, 3], [3, 6, 2], [2, 0, 1] ))
>>> M.det()
-28
>>> M2 = eye(3)
>>> M2.det()
1
>>> M3 = Matrix(( [1, 0, 0], [1, 0, 0], [1, 0, 0] ))
>>> M3.det()
0 
```

另一个常见的操作是求逆：在SymPy中，默认情况下（对于稠密矩阵）通过高斯消元来计算，但我们也可以指定通过LU分解来完成：

```py
>>> M2.inv()
[1  0  0]
[       ]
[0  1  0]
[       ]
[0  0  1]
>>> M2.inv(method="LU")
[1  0  0]
[       ]
[0  1  0]
[       ]
[0  0  1]
>>> M.inv(method="LU")
[-3/14  1/14  1/2 ]
[                 ]
[-1/28  5/28  -1/4]
[                 ]
[ 3/7   -1/7   0  ]
>>> M * M.inv(method="LU")
[1  0  0]
[       ]
[0  1  0]
[       ]
[0  0  1] 
```

我们可以进行QR分解，这对解决系统很方便：

```py
>>> A = Matrix([[1,1,1],[1,1,3],[2,3,4]])
>>> Q, R = A.QRdecomposition()
>>> Q
[  ___     ___      ___ ]
[\/ 6   -\/ 3    -\/ 2  ]
[-----  -------  -------]
[  6       3        2   ]
[                       ]
[  ___     ___      ___ ]
[\/ 6   -\/ 3     \/ 2  ]
[-----  -------   ----- ]
[  6       3        2   ]
[                       ]
[  ___     ___          ]
[\/ 6    \/ 3           ]
[-----   -----      0   ]
[  3       3            ]
>>> R
[           ___         ]
[  ___  4*\/ 6       ___]
[\/ 6   -------  2*\/ 6 ]
[          3            ]
[                       ]
[          ___          ]
[        \/ 3           ]
[  0     -----      0   ]
[          3            ]
[                       ]
[                   ___ ]
[  0       0      \/ 2  ]
>>> Q*R
[1  1  1]
[       ]
[1  1  3]
[       ]
[2  3  4] 
```

除了`solver.py`文件中的求解器外，我们还可以通过将b向量传递给矩阵A的LUsolve函数来解Ax=b系统。在这里，我们稍作弊处理，选择A和x然后相乘以获得b。然后我们可以解出x并检查它是否正确：

```py
>>> A = Matrix([ [2, 3, 5], [3, 6, 2], [8, 3, 6] ])
>>> x = Matrix(3,1,[3,7,5])
>>> b = A*x
>>> soln = A.LUsolve(b)
>>> soln
[3]
[ ]
[7]
[ ]
[5] 
```

还有一个很好的Gram-Schmidt正交化器，它将采用一组向量，并相对于另一个向量组进行正交化。有一个可选参数指定输出是否应该归一化，默认为`False`。让我们拿一些向量并对其进行正交化 - 一个归一化，一个未归一化：

```py
>>> L = [Matrix([2,3,5]), Matrix([3,6,2]), Matrix([8,3,6])]
>>> out1 = GramSchmidt(L)
>>> out2 = GramSchmidt(L, True) 
```

让我们看看这些向量：

```py
>>> for i in out1:
...     print(i)
...
Matrix([[2], [3], [5]])
Matrix([[23/19], [63/19], [-47/19]])
Matrix([[1692/353], [-1551/706], [-423/706]])
>>> for i in out2:
...      print(i)
...
Matrix([[sqrt(38)/19], [3*sqrt(38)/38], [5*sqrt(38)/38]])
Matrix([[23*sqrt(6707)/6707], [63*sqrt(6707)/6707], [-47*sqrt(6707)/6707]])
Matrix([[12*sqrt(706)/353], [-11*sqrt(706)/706], [-3*sqrt(706)/706]]) 
```

我们可以用dot()检查它们的正交性，并用norm()检查它们的正常性：

```py
>>> out1[0].dot(out1[1])
0
>>> out1[0].dot(out1[2])
0
>>> out1[1].dot(out1[2])
0
>>> out2[0].norm()
1
>>> out2[1].norm()
1
>>> out2[2].norm()
1 
```

因此，模块中可以做的事情相当多，包括特征值、特征向量、零空间计算、余因子展开工具等等。从这里开始，可能想要查看`matrices.py`文件以获取所有功能。

## 参考

### 矩阵基类

矩阵类是从各种基类的功能中构建的。每个`Matrix`的方法和属性都在这些基类之一上实现。另见[Dense Matrices](dense.html)，以及[Sparse Matrices](sparse.html)。

```py
class sympy.matrices.matrixbase.MatrixBase
```

所有常见的矩阵操作，包括基本算术、形状和特殊矩阵如`zeros`和`eye`。

```py
property C
```

按元素共轭

```py
property D
```

返回狄拉克共轭（如果`self.rows == 4`）。

示例

```py
>>> from sympy import Matrix, I, eye
>>> m = Matrix((0, 1 + I, 2, 3))
>>> m.D
Matrix([[0, 1 - I, -2, -3]])
>>> m = (eye(4) + I*eye(4))
>>> m[0, 3] = 2
>>> m.D
Matrix([
[1 - I,     0,      0,      0],
[    0, 1 - I,      0,      0],
[    0,     0, -1 + I,      0],
[    2,     0,      0, -1 + I]]) 
```

如果矩阵不具有4行，则会引发AttributeError，因为这个属性仅对具有4行的矩阵定义。

```py
>>> Matrix(eye(2)).D
Traceback (most recent call last):
...
AttributeError: Matrix has no attribute D. 
```

另见

[`sympy.matrices.matrixbase.MatrixBase.conjugate`](#sympy.matrices.matrixbase.MatrixBase.conjugate "sympy.matrices.matrixbase.MatrixBase.conjugate")

按元素共轭

[`sympy.matrices.matrixbase.MatrixBase.H`](#sympy.matrices.matrixbase.MatrixBase.H "sympy.matrices.matrixbase.MatrixBase.H")

Hermite共轭

```py
property H
```

返回Hermite共轭。

示例

```py
>>> from sympy import Matrix, I
>>> m = Matrix((0, 1 + I, 2, 3))
>>> m
Matrix([
[    0],
[1 + I],
[    2],
[    3]])
>>> m.H
Matrix([[0, 1 - I, 2, 3]]) 
```

另见

[`conjugate`](#sympy.matrices.matrixbase.MatrixBase.conjugate "sympy.matrices.matrixbase.MatrixBase.conjugate")

按元素共轭

[`sympy.matrices.matrixbase.MatrixBase.D`](#sympy.matrices.matrixbase.MatrixBase.D "sympy.matrices.matrixbase.MatrixBase.D")

狄拉克共轭

```py
LDLdecomposition(hermitian=True)
```

返回矩阵 A 的 LDL 分解 (L, D)，使得当 hermitian 标志为 True 时，L * D * L.H == A，或者当 hermitian 为 False 时，L * D * L.T == A。此方法消除了使用平方根。此外，确保 L 的所有对角线条目都为 1。如果 hermitian 为 True，则 A 必须是 Hermitian 正定矩阵；否则为对称矩阵。

示例

```py
>>> from sympy import Matrix, eye
>>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))
>>> L, D = A.LDLdecomposition()
>>> L
Matrix([
[   1,   0, 0],
[ 3/5,   1, 0],
[-1/5, 1/3, 1]])
>>> D
Matrix([
[25, 0, 0],
[ 0, 9, 0],
[ 0, 0, 9]])
>>> L * D * L.T * A.inv() == eye(A.rows)
True 
```

矩阵可以具有复数条目：

```py
>>> from sympy import I
>>> A = Matrix(((9, 3*I), (-3*I, 5)))
>>> L, D = A.LDLdecomposition()
>>> L
Matrix([
[   1, 0],
[-I/3, 1]])
>>> D
Matrix([
[9, 0],
[0, 4]])
>>> L*D*L.H == A
True 
```

请参阅

[`sympy.matrices.dense.DenseMatrix.cholesky`](dense.html#sympy.matrices.dense.DenseMatrix.cholesky "sympy.matrices.dense.DenseMatrix.cholesky")，[`sympy.matrices.matrixbase.MatrixBase.LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition "sympy.matrices.matrixbase.MatrixBase.LUdecomposition")，[`QRdecomposition`](#sympy.matrices.matrixbase.MatrixBase.QRdecomposition "sympy.matrices.matrixbase.MatrixBase.QRdecomposition")

```py
LDLsolve(rhs)
```

使用 LDL 分解解决 `Ax = B`，适用于一般的方阵和非奇异矩阵。

对于行数大于列数的非方阵，返回最小二乘解决方案。

示例

```py
>>> from sympy import Matrix, eye
>>> A = eye(2)*2
>>> B = Matrix([[1, 2], [3, 4]])
>>> A.LDLsolve(B) == B/2
True 
```

请参阅

[`sympy.matrices.dense.DenseMatrix.LDLdecomposition`](dense.html#sympy.matrices.dense.DenseMatrix.LDLdecomposition "sympy.matrices.dense.DenseMatrix.LDLdecomposition")，[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve "sympy.matrices.dense.DenseMatrix.lower_triangular_solve")，[`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve "sympy.matrices.dense.DenseMatrix.upper_triangular_solve")，[`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve")，[`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve "sympy.matrices.matrixbase.MatrixBase.cholesky_solve")，[`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve "sympy.matrices.matrixbase.MatrixBase.diagonal_solve")，[`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve")，[`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve "sympy.matrices.matrixbase.MatrixBase.QRsolve")，[`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve "sympy.matrices.matrixbase.MatrixBase.pinv_solve")，[`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve "sympy.matrices.matrixbase.MatrixBase.cramer_solve")

```py
LUdecomposition(iszerofunc=<function _iszero>, simpfunc=None, rankcheck=False)
```

返回 (L, U, perm)，其中 L 是单位对角线的下三角矩阵，U 是上三角矩阵，perm 是行交换索引对的列表。如果 A 是原始矩阵，则 `A = (L*U).permuteBkwd(perm)`，并且行置换矩阵 P 使得 \(P A = L U\) 可以通过 `P = eye(A.rows).permuteFwd(perm)` 计算。

参见 LUCombined 的文档以获取关键字参数 rankcheck、iszerofunc 和 simpfunc 的详细信息。

参数：

**rankcheck**：bool，可选项

> 确定此函数是否应检测矩阵的秩缺陷，并应引发`ValueError`。

**iszerofunc**：函数，可选

> 确定给定表达式是否为零的函数。
> 
> 此函数应为可调用函数，接受一个 SymPy 表达式并返回一个三值布尔值 `True`、`False` 或 `None`。
> 
> 它在枢轴搜索算法内部使用。有关枢轴搜索算法的更多信息，请参阅注释部分。

**simpfunc**：函数或 None，可选

> 简化输入的函数。
> 
> 如果指定为函数，则此函数应为可调用函数，接受一个 SymPy 表达式并返回另一个在代数上等价的 SymPy 表达式。
> 
> 如果为 `None`，表示枢轴搜索算法不应尝试简化任何候选枢轴。
> 
> 它在枢轴搜索算法内部使用。有关枢轴搜索算法的更多信息，请参阅注释部分。

示例

```py
>>> from sympy import Matrix
>>> a = Matrix([[4, 3], [6, 3]])
>>> L, U, _ = a.LUdecomposition()
>>> L
Matrix([
[  1, 0],
[3/2, 1]])
>>> U
Matrix([
[4,    3],
[0, -3/2]]) 
```

另请参阅

[`sympy.matrices.dense.DenseMatrix.cholesky`](dense.html#sympy.matrices.dense.DenseMatrix.cholesky "sympy.matrices.dense.DenseMatrix.cholesky"), [`sympy.matrices.dense.DenseMatrix.LDLdecomposition`](dense.html#sympy.matrices.dense.DenseMatrix.LDLdecomposition "sympy.matrices.dense.DenseMatrix.LDLdecomposition"), [`QRdecomposition`](#sympy.matrices.matrixbase.MatrixBase.QRdecomposition "sympy.matrices.matrixbase.MatrixBase.QRdecomposition"), [`LUdecomposition_Simple`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition_Simple "sympy.matrices.matrixbase.MatrixBase.LUdecomposition_Simple"), [`LUdecompositionFF`](#sympy.matrices.matrixbase.MatrixBase.LUdecompositionFF "sympy.matrices.matrixbase.MatrixBase.LUdecompositionFF"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve")

```py
LUdecompositionFF()
```

计算无分数 LU 分解。

返回四个矩阵 P, L, D, U，使得 PA = L D**-1 U。如果矩阵的元素属于某个整数域 I，则 L, D 和 U 的所有元素都保证属于 I。

另请参阅

[`sympy.matrices.matrixbase.MatrixBase.LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition "sympy.matrices.matrixbase.MatrixBase.LUdecomposition"), [`LUdecomposition_Simple`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition_Simple "sympy.matrices.matrixbase.MatrixBase.LUdecomposition_Simple"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve")

参考资料

[[R609](#id1)]

W. Zhou & D.J. Jeffrey，“无分数矩阵因子：LU 和 QR 因子的新形式”。中国计算机学科前沿，第 2 卷，第 1 期，页码 67-80，2008 年。

```py
LUdecomposition_Simple(iszerofunc=<function _iszero>, simpfunc=None, rankcheck=False)
```

计算矩阵的 PLU 分解。

参数：

**rankcheck**：布尔值，可选

> 确定此函数是否应检测矩阵的秩缺陷，并应引发`ValueError`。

**iszerofunc**：函数，可选

> 确定给定表达式是否为零的函数。
> 
> 该函数应为可调用函数，接受一个SymPy表达式并返回一个三值布尔值`True`，`False`或`None`。
> 
> 它是由枢轴搜索算法内部使用的。有关枢轴搜索算法的更多信息，请参见注释部分。

**simpfunc**：函数或None，可选

> 一个简化输入的函数。
> 
> 如果指定为函数，则此函数应为可调用函数，接受一个SymPy表达式并返回另一个代数上等效的SymPy表达式。
> 
> 如果为`None`，表示枢轴搜索算法不应尝试简化任何候选枢轴。
> 
> 它是由枢轴搜索算法内部使用的。有关枢轴搜索算法的更多信息，请参见注释部分。

返回：

**(lu, row_swaps)**：（矩阵，列表）

> 如果原始矩阵是一个\(m, n\)矩阵：
> 
> *lu*是一个\(m, n\)矩阵，其中包含压缩形式的分解结果。请参阅注释部分以查看矩阵如何压缩。
> 
> *row_swaps*是一个\(m\)元素列表，其中每个元素都是一对行交换的索引。
> 
> `A = (L*U).permute_backward(perm)`，并且根据公式`P A = L U`可以通过`P=eye(A.row).permute_forward(perm)`计算行置换矩阵\(P\)。

引发：

**ValueError**

> 在计算过程中发现矩阵在`rankcheck=True`条件下排名不足时引发。

注释

关于PLU分解：

PLU分解是LU分解的一般化，可以扩展为秩不足的矩阵。

这可以进一步推广到非方阵，这是SymPy正在使用的符号。

PLU分解是将\(m, n\)矩阵\(A\)分解为\(P A = L U\)的形式，其中

+   \(L\)是一个\(m, m\)下三角矩阵，具有单位对角线

    条目。

+   \(U\)是一个\(m, n\)上三角矩阵。

+   \(P\)是一个\(m, m\)置换矩阵。

因此，对于方阵，分解将如下所示：

\[\begin{split}L = \begin{bmatrix} 1 & 0 & 0 & \cdots & 0 \\ L_{1, 0} & 1 & 0 & \cdots & 0 \\ L_{2, 0} & L_{2, 1} & 1 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \cdots & 1 \end{bmatrix}\end{split}\]\[\begin{split}U = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots & U_{0, n-1} \\ 0 & U_{1, 1} & U_{1, 2} & \cdots & U_{1, n-1} \\ 0 & 0 & U_{2, 2} & \cdots & U_{2, n-1} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & 0 & \cdots & U_{n-1, n-1} \end{bmatrix}\end{split}\]

对于行数大于列数的矩阵，分解将如下所示：

\[\begin{split}L = \begin{bmatrix} 1 & 0 & 0 & \cdots & 0 & 0 & \cdots & 0 \\ L_{1, 0} & 1 & 0 & \cdots & 0 & 0 & \cdots & 0 \\ L_{2, 0} & L_{2, 1} & 1 & \cdots & 0 & 0 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\ L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \cdots & 1 & 0 & \cdots & 0 \\ L_{n, 0} & L_{n, 1} & L_{n, 2} & \cdots & L_{n, n-1} & 1 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots & \vdots & \ddots & \vdots \\ L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \cdots & L_{m-1, n-1} & 0 & \cdots & 1 \\ \end{bmatrix}\end{split}\]\[\begin{split}U = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots & U_{0, n-1} \\ 0 & U_{1, 1} & U_{1, 2} & \cdots & U_{1, n-1} \\ 0 & 0 & U_{2, 2} & \cdots & U_{2, n-1} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & 0 & \cdots & U_{n-1, n-1} \\ 0 & 0 & 0 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ 0 & 0 & 0 & \cdots & 0 \end{bmatrix}\end{split}\]

最后，对于列数多于行数的矩阵，分解如下所示：

\[\begin{split}L = \begin{bmatrix} 1 & 0 & 0 & \cdots & 0 \\ L_{1, 0} & 1 & 0 & \cdots & 0 \\ L_{2, 0} & L_{2, 1} & 1 & \cdots & 0 \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \cdots & 1 \end{bmatrix}\end{split}\]\[\begin{split}U = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots & U_{0, m-1} & \cdots & U_{0, n-1} \\ 0 & U_{1, 1} & U_{1, 2} & \cdots & U_{1, m-1} & \cdots & U_{1, n-1} \\ 0 & 0 & U_{2, 2} & \cdots & U_{2, m-1} & \cdots & U_{2, n-1} \\ \vdots & \vdots & \vdots & \ddots & \vdots & \cdots & \vdots \\ 0 & 0 & 0 & \cdots & U_{m-1, m-1} & \cdots & U_{m-1, n-1} \\ \end{bmatrix}\end{split}\]

关于压缩的LU存储：

分解的结果通常以压缩形式存储，而不是单独返回 \(L\) 和 \(U\) 矩阵。

可能不太直观，但因效率高而在许多数值库中常用。

对于这种特定方法，存储矩阵定义如下：

+   \(L\) 的次对角线元素存储在次对角线中。

    \(LU\) 的部分，即当 \(i > j\) 时，\(LU_{i, j} = L_{i, j}\)。

+   \(L\) 的对角线元素全部为1，不

    明确存储。

+   \(U\) 存储在 \(LU\) 的上三角部分中，即

    当 \(i <= j\) 时，\(LU_{i, j} = U_{i, j}\)。

+   对于 \(m > n\) 的情况，\(L\) 矩阵的右侧为

    不太容易存储。

+   对于 \(m < n\) 的情况，\(U\) 矩阵的下侧为

    容易存储。

因此，对于方阵，压缩输出矩阵如下：

\[\begin{split}LU = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots & U_{0, n-1} \\ L_{1, 0} & U_{1, 1} & U_{1, 2} & \cdots & U_{1, n-1} \\ L_{2, 0} & L_{2, 1} & U_{2, 2} & \cdots & U_{2, n-1} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \cdots & U_{n-1, n-1} \end{bmatrix}\end{split}\]

对于行数多于列数的矩阵，压缩输出矩阵如下：

\[\begin{split}LU = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots & U_{0, n-1} \\ L_{1, 0} & U_{1, 1} & U_{1, 2} & \cdots & U_{1, n-1} \\ L_{2, 0} & L_{2, 1} & U_{2, 2} & \cdots & U_{2, n-1} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ L_{n-1, 0} & L_{n-1, 1} & L_{n-1, 2} & \cdots & U_{n-1, n-1} \\ \vdots & \vdots & \vdots & \ddots & \vdots \\ L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \cdots & L_{m-1, n-1} \\ \end{bmatrix}\end{split}\]

对于列数多于行数的矩阵，压缩输出矩阵如下：

\[\begin{split}LU = \begin{bmatrix} U_{0, 0} & U_{0, 1} & U_{0, 2} & \cdots & U_{0, m-1} & \cdots & U_{0, n-1} \\ L_{1, 0} & U_{1, 1} & U_{1, 2} & \cdots & U_{1, m-1} & \cdots & U_{1, n-1} \\ L_{2, 0} & L_{2, 1} & U_{2, 2} & \cdots & U_{2, m-1} & \cdots & U_{2, n-1} \\ \vdots & \vdots & \vdots & \ddots & \vdots & \cdots & \vdots \\ L_{m-1, 0} & L_{m-1, 1} & L_{m-1, 2} & \cdots & U_{m-1, m-1} & \cdots & U_{m-1, n-1} \\ \end{bmatrix}\end{split}\]

关于主元搜索算法：

当矩阵包含符号条目时，主元搜索算法与每个条目可归类为零或非零的情况不同。该算法通过其左上角条目与主元位置重合的子矩阵逐列搜索。如果存在，主元是当前搜索列中第一个保证为非零的`iszerofunc()`候选。如果没有这样的候选存在，则每个候选主元（如果`simpfunc`不为None）会被简化。搜索会重复进行，不过在第二次搜索中，如果`iszerofunc()`无法保证其为非零，则候选可能是主元。在第二次搜索中，主元是第一个保证为非零的`iszerofunc()`候选。如果没有这样的候选存在，则主元是第一个`iszerofunc()`返回None的候选。如果没有这样的候选存在，则在右侧的下一列中重复搜索。主元搜索算法与`rref()`中的算法不同，后者依赖于`_find_reasonable_pivot()`。未来版本的`LUdecomposition_simple()`可能会使用`_find_reasonable_pivot()`。

另见

[`sympy.matrices.matrixbase.MatrixBase.LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition "sympy.matrices.matrixbase.MatrixBase.LUdecomposition"), [`LUdecompositionFF`](#sympy.matrices.matrixbase.MatrixBase.LUdecompositionFF "sympy.matrices.matrixbase.MatrixBase.LUdecompositionFF"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve")

```py
LUsolve(rhs, iszerofunc=<function _iszero>)
```

解线性系统`Ax = rhs`，其中`A = M`。

这适用于符号矩阵，对于实数或复数矩阵，请使用`mpmath.lu_solve`或`mpmath.qr_solve`。

另见

[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition "sympy.matrices.matrixbase.MatrixBase.LUdecomposition"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve "sympy.matrices.matrixbase.MatrixBase.cramer_solve")

```py
QRdecomposition()
```

返回一个 QR 分解。

解释

QR 分解是一种形式为 \(A = Q R\) 的分解，其中

+   \(Q\) 是一个列正交矩阵。

+   \(R\) 是一个上三角（梯形）矩阵。

一个列正交矩阵满足 \(\mathbb{I} = Q^H Q\)，而一个完全正交矩阵满足关系 \(\mathbb{I} = Q Q^H = Q^H Q\)，其中 \(I\) 是与之匹配维度的单位矩阵。

对于非方阵或秩不足的矩阵，返回一个列正交矩阵就足够了，因为增广可能会引入冗余计算。另一个优点是，通过计算 \(Q\) 的列数，可以轻松检查矩阵的秩。

如果要增广结果以返回完全正交分解，应使用以下程序。

+   增广 \(Q\) 矩阵，增加与其他每列正交的列，并使其为方阵。

+   用零行增广 \(R\) 矩阵，使其与原始矩阵具有相同的形状。

过程将在示例部分进行说明。

示例

完全秩矩阵示例：

```py
>>> from sympy import Matrix
>>> A = Matrix([[12, -51, 4], [6, 167, -68], [-4, 24, -41]])
>>> Q, R = A.QRdecomposition()
>>> Q
Matrix([
[ 6/7, -69/175, -58/175],
[ 3/7, 158/175,   6/175],
[-2/7,    6/35,  -33/35]])
>>> R
Matrix([
[14,  21, -14],
[ 0, 175, -70],
[ 0,   0,  35]]) 
```

如果矩阵是方阵且满秩，\(Q\) 矩阵在两个方向上都成为正交的，无需增广。

```py
>>> Q * Q.H
Matrix([
[1, 0, 0],
[0, 1, 0],
[0, 0, 1]])
>>> Q.H * Q
Matrix([
[1, 0, 0],
[0, 1, 0],
[0, 0, 1]]) 
```

```py
>>> A == Q*R
True 
```

一个秩缺陷矩阵示例：

```py
>>> A = Matrix([[12, -51, 0], [6, 167, 0], [-4, 24, 0]])
>>> Q, R = A.QRdecomposition()
>>> Q
Matrix([
[ 6/7, -69/175],
[ 3/7, 158/175],
[-2/7,    6/35]])
>>> R
Matrix([
[14,  21, 0],
[ 0, 175, 0]]) 
```

QR 分解可能返回一个矩阵 \(Q\) 是矩形的情况。在这种情况下，正交条件可能满足为 \(\mathbb{I} = Q.H*Q\)，但不是在反向乘积 \(\mathbb{I} = Q * Q.H\)。

```py
>>> Q.H * Q
Matrix([
[1, 0],
[0, 1]])
>>> Q * Q.H
Matrix([
[27261/30625,   348/30625, -1914/6125],
[  348/30625, 30589/30625,   198/6125],
[ -1914/6125,    198/6125,   136/1225]]) 
```

如果要增广结果以获得完全正交分解，应该用另一个正交列增广 \(Q\)。

您可以附加一个单位矩阵，并且可以运行Gram-Schmidt过程使它们作为正交基增广。

```py
>>> Q_aug = Q.row_join(Matrix.eye(3))
>>> Q_aug = Q_aug.QRdecomposition()[0]
>>> Q_aug
Matrix([
[ 6/7, -69/175, 58/175],
[ 3/7, 158/175, -6/175],
[-2/7,    6/35,  33/35]])
>>> Q_aug.H * Q_aug
Matrix([
[1, 0, 0],
[0, 1, 0],
[0, 0, 1]])
>>> Q_aug * Q_aug.H
Matrix([
[1, 0, 0],
[0, 1, 0],
[0, 0, 1]]) 
```

将 \(R\) 矩阵用零行增广是直接的。

```py
>>> R_aug = R.col_join(Matrix([[0, 0, 0]]))
>>> R_aug
Matrix([
[14,  21, 0],
[ 0, 175, 0],
[ 0,   0, 0]])
>>> Q_aug * R_aug == A
True 
```

零矩阵示例：

```py
>>> from sympy import Matrix
>>> A = Matrix.zeros(3, 4)
>>> Q, R = A.QRdecomposition() 
```

它们可能返回具有零行和列的矩阵。

```py
>>> Q
Matrix(3, 0, [])
>>> R
Matrix(0, 4, [])
>>> Q*R
Matrix([
[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]]) 
```

与上述相同的增广规则，\(Q\)可以用单位矩阵的列增广，\(R\)可以用零矩阵的行增广。

```py
>>> Q_aug = Q.row_join(Matrix.eye(3))
>>> R_aug = R.col_join(Matrix.zeros(3, 4))
>>> Q_aug * Q_aug.T
Matrix([
[1, 0, 0],
[0, 1, 0],
[0, 0, 1]])
>>> R_aug
Matrix([
[0, 0, 0, 0],
[0, 0, 0, 0],
[0, 0, 0, 0]])
>>> Q_aug * R_aug == A
True 
```

参见

[`sympy.matrices.dense.DenseMatrix.cholesky`](dense.html#sympy.matrices.dense.DenseMatrix.cholesky "sympy.matrices.dense.DenseMatrix.cholesky"), [`sympy.matrices.dense.DenseMatrix.LDLdecomposition`](dense.html#sympy.matrices.dense.DenseMatrix.LDLdecomposition "sympy.matrices.dense.DenseMatrix.LDLdecomposition"), [`sympy.matrices.matrixbase.MatrixBase.LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition "sympy.matrices.matrixbase.MatrixBase.LUdecomposition"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve "sympy.matrices.matrixbase.MatrixBase.QRsolve")

```py
QRsolve(b)
```

解线性系统 `Ax = b`。

`M` 是矩阵 `A`，方法的参数是向量 `b`。该方法返回解向量 `x`。如果 `b` 是矩阵，则对每列 `b` 解决系统，并返回与 `b` 相同形状的矩阵。

该方法比LUsolve方法慢（大约慢2倍），但对于浮点运算更稳定。然而，LUsolve通常使用精确算术，因此您不需要使用QRsolve。

这主要用于教育目的和符号矩阵，对于实数（或复数）矩阵，请使用mpmath.qr_solve。

参见

[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`QRdecomposition`](#sympy.matrices.matrixbase.MatrixBase.QRdecomposition "sympy.matrices.matrixbase.MatrixBase.QRdecomposition"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve "sympy.matrices.matrixbase.MatrixBase.cramer_solve")

```py
property T
```

矩阵转置

```py
__abs__()
```

返回一个新的矩阵，其元素为逐元素的绝对值。

```py
__add__(other)
```

返回self + other，如果形状不匹配则引发ShapeError。

```py
__getitem__(key)
```

实现`__getitem__`应接受整数，其中矩阵被索引为一个平坦列表，元组(i,j)中返回(i,j)条目，切片，或混合元组(a,b)，其中a和b是任意的切片和整数组合。

```py
__len__()
```

返回`self`的元素数量。

主要实现是bool(Matrix()) == False。

```py
__mul__(other)
```

返回self * other，其中other是一个标量或兼容尺寸的矩阵。

示例

```py
>>> from sympy import Matrix
>>> A = Matrix([[1, 2, 3], [4, 5, 6]])
>>> 2*A == A*2 == Matrix([[2, 4, 6], [8, 10, 12]])
True
>>> B = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> A*B
Matrix([
[30, 36, 42],
[66, 81, 96]])
>>> B*A
Traceback (most recent call last):
...
ShapeError: Matrices size mismatch.
>>> 
```

参见

[`matrix_multiply_elementwise`](#sympy.matrices.dense.matrix_multiply_elementwise "sympy.matrices.dense.matrix_multiply_elementwise")

```py
__pow__(exp)
```

返回self的exp标量或符号。

```py
__weakref__
```

对对象的弱引用列表

```py
add(b)
```

返回self + b。

```py
adjoint()
```

共轭转置或Hermitian共轭。

```py
adjugate(method='berkowitz')
```

返回一个矩阵的伴随或经典伴随，即余子式矩阵的转置。

[https://en.wikipedia.org/wiki/Adjugate](https://en.wikipedia.org/wiki/Adjugate)

参数：

**method** : 字符串，可选

> 用于计算余子式的方法，可以是“bareiss”，“berkowitz”，“bird”，“laplace”或“lu”。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix([[1, 2], [3, 4]])
>>> M.adjugate()
Matrix([
[ 4, -2],
[-3,  1]]) 
```

参见

[`cofactor_matrix`](#sympy.matrices.matrixbase.MatrixBase.cofactor_matrix "sympy.matrices.matrixbase.MatrixBase.cofactor_matrix"), [`sympy.matrices.matrixbase.MatrixBase.transpose`](#sympy.matrices.matrixbase.MatrixBase.transpose "sympy.matrices.matrixbase.MatrixBase.transpose")

```py
analytic_func(f, x)
```

计算f(A)，其中A是一个方阵，f是一个解析函数。

参数：

**f** : 表达式

> 解析函数

**x** : 符号

> f的参数

示例

```py
>>> from sympy import Symbol, Matrix, S, log 
```

```py
>>> x = Symbol('x')
>>> m = Matrix([[S(5)/4, S(3)/4], [S(3)/4, S(5)/4]])
>>> f = log(x)
>>> m.analytic_func(f, x)
Matrix([
[     0, log(2)],
[log(2),      0]]) 
```

```py
applyfunc(f)
```

对矩阵的每个元素应用一个函数。

示例

```py
>>> from sympy import Matrix
>>> m = Matrix(2, 2, lambda i, j: i*2+j)
>>> m
Matrix([
[0, 1],
[2, 3]])
>>> m.applyfunc(lambda i: 2*i)
Matrix([
[0, 2],
[4, 6]]) 
```

```py
as_real_imag(deep=True, **hints)
```

返回一个包含矩阵的(实部，虚部)的元组。

```py
atoms(*types)
```

返回形成当前对象的原子。

示例

```py
>>> from sympy.abc import x, y
>>> from sympy import Matrix
>>> Matrix([[x]])
Matrix([[x]])
>>> _.atoms()
{x}
>>> Matrix([[x, y], [y, x]])
Matrix([
[x, y],
[y, x]])
>>> _.atoms()
{x, y} 
```

```py
berkowitz_det()
```

使用Berkowitz方法计算行列式。

参见

[`det`](#sympy.matrices.matrixbase.MatrixBase.det "sympy.matrices.matrixbase.MatrixBase.det")

```py
berkowitz_eigenvals(**flags)
```

使用Berkowitz方法计算矩阵的特征值。

```py
berkowitz_minors()
```

使用Berkowitz方法计算主要子式。

```py
bidiagonal_decomposition(upper=True)
```

返回\((U,B,V.H)\)，其中

\[A = UBV^{H}\]

其中\(A\)是输入矩阵，\(B\)是其双对角形式

注意：对于符号矩阵，双对角化计算可能会挂起。

参数：

**upper** : bool。是否进行上双对角化或下双对角化。

> 对于上三角矩阵为True，下三角矩阵为False。

参考文献

[[R610](#id2)]

算法5.4.2，《Golub和Van Loan的矩阵计算》，第4版

[[R611](#id3)]

复杂矩阵双对角化，[https://github.com/vslobody/Householder-Bidiagonalization](https://github.com/vslobody/Householder-Bidiagonalization)

```py
bidiagonalize(upper=True)
```

返回\(B\)，输入矩阵的双对角形式。

注意：对于符号矩阵，双对角化计算可能会挂起。

参数：

**upper** : bool。是否进行上双对角化或下双对角化。

> 对于上三角矩阵为True，下三角矩阵为False。

参考文献

[[R612](#id4)]

算法5.4.2，《Golub和Van Loan的矩阵计算》，第4版

[[R613](#id5)]

复杂矩阵双对角化：[https://github.com/vslobody/Householder-Bidiagonalization](https://github.com/vslobody/Householder-Bidiagonalization)

```py
charpoly(x='lambda', simplify=<function _simplify>)
```

计算特征多项式det(x*I - M)，其中I是单位矩阵。

返回PurePoly，因此使用不同的变量对于`x`不会影响比较或多项式：

参数：

**x**：字符串，可选

> “lambda”变量的名称，默认为“lambda”。

**simplify**：函数，可选

> 用于计算所计算的特征多项式的简化函数。默认为`simplify`。

示例

```py
>>> from sympy import Matrix
>>> from sympy.abc import x, y
>>> M = Matrix([[1, 3], [2, 0]])
>>> M.charpoly()
PurePoly(lambda**2 - lambda - 6, lambda, domain='ZZ')
>>> M.charpoly(x) == M.charpoly(y)
True
>>> M.charpoly(x) == M.charpoly(y)
True 
```

指定`x`是可选的；默认使用名为`lambda`的符号（在美化打印Unicode时看起来很好）：

```py
>>> M.charpoly().as_expr()
lambda**2 - lambda - 6 
```

如果`x`与现有符号冲突，则将下划线添加到名称前使其唯一：

```py
>>> M = Matrix([[1, 2], [x, 0]])
>>> M.charpoly(x).as_expr()
_x**2 - _x - 2*x 
```

无论是否传递符号，由于生成器可能与传递的符号不同，可以使用gen属性获取：

```py
>>> M.charpoly(x).gen
_x
>>> M.charpoly(x).gen == x
False 
```

笔记

Samuelson-Berkowitz算法用于高效计算特征多项式，且不进行任何除法操作。因此可以计算任何没有零除数的交换环上的特征多项式。

如果行列式det(x*I - M)可以轻松找到，如上三角或下三角矩阵的情况，则不使用Samuelson-Berkowitz算法，而是使用特征值来计算特征多项式。

另请参阅

[`det`](#sympy.matrices.matrixbase.MatrixBase.det "sympy.matrices.matrixbase.MatrixBase.det")

```py
cholesky(hermitian=True)
```

返回矩阵A的Cholesky类型分解L，使得当hermitian标志为True时，L * L.H == A，或者当hermitian为False时，L * L.T == A。

如果hermitian为True，则A必须是Hermitian正定矩阵；如果为False，则A必须是对称矩阵。

示例

```py
>>> from sympy import Matrix
>>> A = Matrix(((25, 15, -5), (15, 18, 0), (-5, 0, 11)))
>>> A.cholesky()
Matrix([
[ 5, 0, 0],
[ 3, 3, 0],
[-1, 1, 3]])
>>> A.cholesky() * A.cholesky().T
Matrix([
[25, 15, -5],
[15, 18,  0],
[-5,  0, 11]]) 
```

矩阵可以具有复数条目：

```py
>>> from sympy import I
>>> A = Matrix(((9, 3*I), (-3*I, 5)))
>>> A.cholesky()
Matrix([
[ 3, 0],
[-I, 2]])
>>> A.cholesky() * A.cholesky().H
Matrix([
[   9, 3*I],
[-3*I,   5]]) 
```

当矩阵不是正定时，非Hermitian Cholesky类型分解可能会有用。

```py
>>> A = Matrix([[1, 2], [2, 1]])
>>> L = A.cholesky(hermitian=False)
>>> L
Matrix([
[1,         0],
[2, sqrt(3)*I]])
>>> L*L.T == A
True 
```

另请参阅

[`sympy.matrices.dense.DenseMatrix.LDLdecomposition`](dense.html#sympy.matrices.dense.DenseMatrix.LDLdecomposition "sympy.matrices.dense.DenseMatrix.LDLdecomposition")，[`sympy.matrices.matrixbase.MatrixBase.LUdecomposition`](#sympy.matrices.matrixbase.MatrixBase.LUdecomposition "sympy.matrices.matrixbase.MatrixBase.LUdecomposition")，[`QRdecomposition`](#sympy.matrices.matrixbase.MatrixBase.QRdecomposition "sympy.matrices.matrixbase.MatrixBase.QRdecomposition")

```py
cholesky_solve(rhs)
```

使用Cholesky分解解决`Ax = B`，适用于一般的方阵非奇异矩阵。对于行数大于列数的非方阵，返回最小二乘解。

另请参阅

[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve "sympy.matrices.matrixbase.MatrixBase.cramer_solve")

```py
cofactor(i, j, method='berkowitz')
```

计算一个元素的余子式。

参数：

**方法**：字符串，可选

> 用于查找余子式的方法，可以是“bareiss”、“berkowitz”、“bird”、“laplace”或“lu”。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix([[1, 2], [3, 4]])
>>> M.cofactor(0, 1)
-3 
```

参见

[`cofactor_matrix`](#sympy.matrices.matrixbase.MatrixBase.cofactor_matrix "sympy.matrices.matrixbase.MatrixBase.cofactor_matrix"), [`minor`](#sympy.matrices.matrixbase.MatrixBase.minor "sympy.matrices.matrixbase.MatrixBase.minor"), [`minor_submatrix`](#sympy.matrices.matrixbase.MatrixBase.minor_submatrix "sympy.matrices.matrixbase.MatrixBase.minor_submatrix")

```py
cofactor_matrix(method='berkowitz')
```

返回包含每个元素的余子式的矩阵。

参数：

**方法**：字符串，可选

> 用于查找余子式的方法，可以是“bareiss”、“berkowitz”、“bird”、“laplace”或“lu”。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix([[1, 2], [3, 4]])
>>> M.cofactor_matrix()
Matrix([
[ 4, -3],
[-2,  1]]) 
```

参见

[`cofactor`](#sympy.matrices.matrixbase.MatrixBase.cofactor "sympy.matrices.matrixbase.MatrixBase.cofactor"), [`minor`](#sympy.matrices.matrixbase.MatrixBase.minor "sympy.matrices.matrixbase.MatrixBase.minor"), [`minor_submatrix`](#sympy.matrices.matrixbase.MatrixBase.minor_submatrix "sympy.matrices.matrixbase.MatrixBase.minor_submatrix")

```py
col(j)
```

列元素选择器。

示例

```py
>>> from sympy import eye
>>> eye(2).col(0)
Matrix([
[1],
[0]]) 
```

参见

[`row`](#sympy.matrices.matrixbase.MatrixBase.row "sympy.matrices.matrixbase.MatrixBase.row"), [`col_del`](#sympy.matrices.matrixbase.MatrixBase.col_del "sympy.matrices.matrixbase.MatrixBase.col_del"), [`col_join`](#sympy.matrices.matrixbase.MatrixBase.col_join "sympy.matrices.matrixbase.MatrixBase.col_join"), [`col_insert`](#sympy.matrices.matrixbase.MatrixBase.col_insert "sympy.matrices.matrixbase.MatrixBase.col_insert")

```py
col_del(col)
```

删除指定的列。

```py
col_insert(pos, other)
```

在给定的列位置插入一个或多个列。

示例

```py
>>> from sympy import zeros, ones
>>> M = zeros(3)
>>> V = ones(3, 1)
>>> M.col_insert(1, V)
Matrix([
[0, 1, 0, 0],
[0, 1, 0, 0],
[0, 1, 0, 0]]) 
```

参见

[`col`](#sympy.matrices.matrixbase.MatrixBase.col "sympy.matrices.matrixbase.MatrixBase.col"), [`row_insert`](#sympy.matrices.matrixbase.MatrixBase.row_insert "sympy.matrices.matrixbase.MatrixBase.row_insert")

```py
col_join(other)
```

沿着自身的最后一行和其他的第一行连接两个矩阵。

示例

```py
>>> from sympy import zeros, ones
>>> M = zeros(3)
>>> V = ones(1, 3)
>>> M.col_join(V)
Matrix([
[0, 0, 0],
[0, 0, 0],
[0, 0, 0],
[1, 1, 1]]) 
```

另请参阅

[`col`](#sympy.matrices.matrixbase.MatrixBase.col "sympy.matrices.matrixbase.MatrixBase.col"), [`row_join`](#sympy.matrices.matrixbase.MatrixBase.row_join "sympy.matrices.matrixbase.MatrixBase.row_join")

```py
columnspace(simplify=False)
```

返回向量列表（矩阵对象），这些向量跨越了`M`的列空间

示例

```py
>>> from sympy import Matrix
>>> M = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])
>>> M
Matrix([
[ 1,  3, 0],
[-2, -6, 0],
[ 3,  9, 6]])
>>> M.columnspace()
[Matrix([
[ 1],
[-2],
[ 3]]), Matrix([
[0],
[0],
[6]])] 
```

另请参阅

[`nullspace`](#sympy.matrices.matrixbase.MatrixBase.nullspace "sympy.matrices.matrixbase.MatrixBase.nullspace"), [`rowspace`](#sympy.matrices.matrixbase.MatrixBase.rowspace "sympy.matrices.matrixbase.MatrixBase.rowspace")

```py
classmethod companion(poly)
```

返回多项式的伴随矩阵。

示例

```py
>>> from sympy import Matrix, Poly, Symbol, symbols
>>> x = Symbol('x')
>>> c0, c1, c2, c3, c4 = symbols('c0:5')
>>> p = Poly(c0 + c1*x + c2*x**2 + c3*x**3 + c4*x**4 + x**5, x)
>>> Matrix.companion(p)
Matrix([
[0, 0, 0, 0, -c0],
[1, 0, 0, 0, -c1],
[0, 1, 0, 0, -c2],
[0, 0, 1, 0, -c3],
[0, 0, 0, 1, -c4]]) 
```

```py
condition_number()
```

返回矩阵的条件数。

这是最大奇异值除以最小奇异值

示例

```py
>>> from sympy import Matrix, S
>>> A = Matrix([[1, 0, 0], [0, 10, 0], [0, 0, S.One/10]])
>>> A.condition_number()
100 
```

另请参阅

[`singular_values`](#sympy.matrices.matrixbase.MatrixBase.singular_values "sympy.matrices.matrixbase.MatrixBase.singular_values")

```py
conjugate()
```

返回按元素共轭。

示例

```py
>>> from sympy import SparseMatrix, I
>>> a = SparseMatrix(((1, 2 + I), (3, 4), (I, -I)))
>>> a
Matrix([
[1, 2 + I],
[3,     4],
[I,    -I]])
>>> a.C
Matrix([
[ 1, 2 - I],
[ 3,     4],
[-I,     I]]) 
```

另请参阅

[`transpose`](#sympy.matrices.matrixbase.MatrixBase.transpose "sympy.matrices.matrixbase.MatrixBase.transpose")

矩阵转置

[`H`](#sympy.matrices.matrixbase.MatrixBase.H "sympy.matrices.matrixbase.MatrixBase.H")

Hermite 共轭

[`sympy.matrices.matrixbase.MatrixBase.D`](#sympy.matrices.matrixbase.MatrixBase.D "sympy.matrices.matrixbase.MatrixBase.D")

狄拉克共轭

```py
connected_components()
```

当将方阵视为加权图时，返回图的连接顶点列表。

示例

```py
>>> from sympy import Matrix
>>> A = Matrix([
...     [66, 0, 0, 68, 0, 0, 0, 0, 67],
...     [0, 55, 0, 0, 0, 0, 54, 53, 0],
...     [0, 0, 0, 0, 1, 2, 0, 0, 0],
...     [86, 0, 0, 88, 0, 0, 0, 0, 87],
...     [0, 0, 10, 0, 11, 12, 0, 0, 0],
...     [0, 0, 20, 0, 21, 22, 0, 0, 0],
...     [0, 45, 0, 0, 0, 0, 44, 43, 0],
...     [0, 35, 0, 0, 0, 0, 34, 33, 0],
...     [76, 0, 0, 78, 0, 0, 0, 0, 77]])
>>> A.connected_components()
[[0, 3, 8], [1, 6, 7], [2, 4, 5]] 
```

注意事项

即使矩阵的任何符号元素在数学上可能是不确定的为零，这仅考虑矩阵的结构方面，因此它们被认为是非零的。

```py
connected_components_decomposition()
```

仅使用置换将方阵分解为分块对角形式。

返回：

**P, B** : 置换矩阵, 分块对角矩阵

> *P* 是用于类似变换的置换矩阵，就像解释中所述。而 *B* 是置换结果的分块对角矩阵。
> 
> 如果您想从 BlockDiagMatrix 中获取对角块，请参见 [`get_diag_blocks()`](expressions.html#sympy.matrices.expressions.blockmatrix.BlockDiagMatrix.get_diag_blocks "sympy.matrices.expressions.blockmatrix.BlockDiagMatrix.get_diag_blocks")。

解释

分解为 \(A = P^{-1} B P\) 的形式，其中 \(P\) 是置换矩阵，\(B\) 是分块对角矩阵。

示例

```py
>>> from sympy import Matrix, pprint
>>> A = Matrix([
...     [66, 0, 0, 68, 0, 0, 0, 0, 67],
...     [0, 55, 0, 0, 0, 0, 54, 53, 0],
...     [0, 0, 0, 0, 1, 2, 0, 0, 0],
...     [86, 0, 0, 88, 0, 0, 0, 0, 87],
...     [0, 0, 10, 0, 11, 12, 0, 0, 0],
...     [0, 0, 20, 0, 21, 22, 0, 0, 0],
...     [0, 45, 0, 0, 0, 0, 44, 43, 0],
...     [0, 35, 0, 0, 0, 0, 34, 33, 0],
...     [76, 0, 0, 78, 0, 0, 0, 0, 77]]) 
```

```py
>>> P, B = A.connected_components_decomposition()
>>> pprint(P)
PermutationMatrix((1 3)(2 8 5 7 4 6))
>>> pprint(B)
[[66  68  67]                            ]
[[          ]                            ]
[[86  88  87]       0             0      ]
[[          ]                            ]
[[76  78  77]                            ]
[                                        ]
[              [55  54  53]              ]
[              [          ]              ]
[     0        [45  44  43]       0      ]
[              [          ]              ]
[              [35  34  33]              ]
[                                        ]
[                            [0   1   2 ]]
[                            [          ]]
[     0             0        [10  11  12]]
[                            [          ]]
[                            [20  21  22]] 
```

```py
>>> P = P.as_explicit()
>>> B = B.as_explicit()
>>> P.T*B*P == A
True 
```

注意事项

当将矩阵视为加权图时，此问题对应于查找图的连通分量。

```py
copy()
```

返回矩阵的副本。

示例

```py
>>> from sympy import Matrix
>>> A = Matrix(2, 2, [1, 2, 3, 4])
>>> A.copy()
Matrix([
[1, 2],
[3, 4]]) 
```

```py
cramer_solve(rhs, det_method='laplace')
```

使用克莱姆法则解线性方程组。

该方法与其他方法相比相对低效。然而，它只使用单个除法，假设提供了无除法的行列式方法。这对于最小化符号解线性系统中的除零情况很有帮助。

参数：

**M** : 矩阵

> 表示方程左侧的矩阵。

**rhs** : 矩阵

> 表示方程右侧的矩阵。

**det_method** : 字符串或可调用对象

> 用于计算矩阵行列式的方法。默认为`'laplace'`。如果传递了可调用对象，它应该接受一个参数，即矩阵，并返回矩阵的行列式。

返回：

**x** : 矩阵

> 满足 `Ax = B` 的矩阵。将具有与矩阵A列数相同的行数，与矩阵B相同的列数。

示例

```py
>>> from sympy import Matrix
>>> A = Matrix([[0, -6, 1], [0, -6, -1], [-5, -2, 3]])
>>> B = Matrix([[-30, -9], [-18, -27], [-26, 46]])
>>> x = A.cramer_solve(B)
>>> x
Matrix([
[ 0, -5],
[ 4,  3],
[-6,  9]]) 
```

参考

[[R614](#id6)]

[https://en.wikipedia.org/wiki/Cramer%27s_rule#Explicit_formulas_for_small_systems](https://en.wikipedia.org/wiki/Cramer%27s_rule#Explicit_formulas_for_small_systems)

```py
cross(b)
```

返回`self`和`b`的叉乘，放宽了兼容维度的条件：如果每个都有3个元素，则返回与`self`相同类型和形状的矩阵。如果`b`与`self`具有相同的形状，则交叉乘积的常见恒等式（如 \(a \times b = - b \times a\)）将成立。

参数：

**b** : 3x1 或 1x3 矩阵

另请参阅

[`dot`](#sympy.matrices.matrixbase.MatrixBase.dot "sympy.matrices.matrixbase.MatrixBase.dot"), [`hat`](#sympy.matrices.matrixbase.MatrixBase.hat "sympy.matrices.matrixbase.MatrixBase.hat"), [`vee`](#sympy.matrices.matrixbase.MatrixBase.vee "sympy.matrices.matrixbase.MatrixBase.vee"), [`multiply`](#sympy.matrices.matrixbase.MatrixBase.multiply "sympy.matrices.matrixbase.MatrixBase.multiply"), [`multiply_elementwise`](#sympy.matrices.matrixbase.MatrixBase.multiply_elementwise "sympy.matrices.matrixbase.MatrixBase.multiply_elementwise")

```py
det(method='bareiss', iszerofunc=None)
```

如果`M`是一个具体的矩阵对象，则计算矩阵的行列式；否则，如果`M`是`MatrixSymbol`或其他表达式，则返回表达式`Determinant(M)`。

参数：

**method** : 字符串，可选

> 指定用于计算矩阵行列式的算法。
> 
> 如果矩阵最多是3x3，则使用硬编码的公式，并忽略指定的方法。否则，默认为`'bareiss'`。
> 
> 此外，如果矩阵是上三角或下三角矩阵，则通过对角元素的简单乘法计算行列式，并忽略指定的方法。
> 
> 如果设置为`'domain-ge'`，则通过使用DomainMatrix将使用高斯消元法。
> 
> 如果设置为`'bareiss'`，将使用Bareiss分式自由算法。
> 
> 如果设置为`'berkowitz'`，将使用Berkowitz算法。
> 
> 如果设置为`'bird'`，将使用Bird算法 [[R615]](#r615)。
> 
> 如果设置为`'laplace'`，将使用拉普拉斯算法。
> 
> 否则，如果设置为`'lu'`，将使用LU分解。
> 
> 注意
> 
> 为了向后兼容，旧版键如“bareis”和“det_lu”仍然可以用于指示相应的方法。现在，键名对大小写不敏感。然而，建议使用精确的键来指定方法。

**iszerofunc**：FunctionType或None，可选

> 如果设置为`None`，则在方法设置为`'bareiss'`时，默认为`_iszero`，在方法设置为`'lu'`时，默认为`_is_zero_after_expand_mul`。
> 
> 如果格式为接受单个符号参数并返回`True`（如果测试为零）和`False`（如果测试为非零）以及`None`（如果无法判断）的函数，则还可以接受任何用户指定的零测试函数。

返回：

**det**：基本

> 行列式结果。

引发：

**ValueError**

> 如果给定了未识别的键用于`method`或`iszerofunc`。

**非方阵矩阵错误**

> 如果尝试从非方阵计算行列式。

示例

```py
>>> from sympy import Matrix, eye, det
>>> I3 = eye(3)
>>> det(I3)
1
>>> M = Matrix([[1, 2], [3, 4]])
>>> det(M)
-2
>>> det(M) == M.det()
True
>>> M.det(method="domain-ge")
-2 
```

参考资料

[R615]（[1](#id7)，[2](#id8)）

Bird, R. S.（2011）。用于计算行列式的简单无除法算法。Inf. Process. Lett.，111（21），1072-1074。doi: 10.1016/j.ipl.2011.08.006

```py
det_LU_decomposition()
```

使用LU分解计算矩阵行列式。

请注意，如果LU分解本身失败，则此方法将失败。特别地，如果矩阵没有逆矩阵，则此方法将失败。

TODO：为稀疏矩阵（SFF）实现算法，[http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps](http://www.eecis.udel.edu/~saunders/papers/sffge/it5.ps)。

另请参见

[`det`](#sympy.matrices.matrixbase.MatrixBase.det "sympy.matrices.matrixbase.MatrixBase.det"), [`berkowitz_det`](#sympy.matrices.matrixbase.MatrixBase.berkowitz_det "sympy.matrices.matrixbase.MatrixBase.berkowitz_det")

```py
classmethod diag(*args, strict=False, unpack=True, rows=None, cols=None, **kwargs)
```

返回具有指定对角线的矩阵。如果传递了矩阵，则创建一个块对角矩阵（即矩阵的“直和”）。

Kwargs

结果矩阵的行；如果

未给出。

结果矩阵的列；如果

未给出。

cls：生成矩阵的类

unpack：bool值，当为True（默认值）时，解包单个序列而不是将其解释为矩阵。

strict：bool值，当为False（默认值）时，允许矩阵具有可变长度的行。

示例

```py
>>> from sympy import Matrix
>>> Matrix.diag(1, 2, 3)
Matrix([
[1, 0, 0],
[0, 2, 0],
[0, 0, 3]]) 
```

当前默认为解包单个序列。如果不需要这样做，请设置`unpack=False`，并将其解释为矩阵。

```py
>>> Matrix.diag([1, 2, 3]) == Matrix.diag(1, 2, 3)
True 
```

当传递多个元素时，每个元素都被解释为要放置在对角线上的内容。列表将被转换为矩阵。对角线的填充始终从前一项的右下角继续：这将创建一个块对角矩阵，无论矩阵是否为方阵。

```py
>>> col = [1, 2, 3]
>>> row = [[4, 5]]
>>> Matrix.diag(col, row)
Matrix([
[1, 0, 0],
[2, 0, 0],
[3, 0, 0],
[0, 4, 5]]) 
```

当`unpack`为False时，列表内的元素不必全部长度相同。将`strict`设置为True将为以下内容引发ValueError：

```py
>>> Matrix.diag([[1, 2, 3], [4, 5], [6]], unpack=False)
Matrix([
[1, 2, 3],
[4, 5, 0],
[6, 0, 0]]) 
```

返回的矩阵类型可以通过`cls`关键字设置。

```py
>>> from sympy import ImmutableMatrix
>>> from sympy.utilities.misc import func_name
>>> func_name(Matrix.diag(1, cls=ImmutableMatrix))
'ImmutableDenseMatrix' 
```

零维矩阵可以用来定位填充的起始位置在任意行或列的开始处：

```py
>>> from sympy import ones
>>> r2 = ones(0, 2)
>>> Matrix.diag(r2, 1, 2)
Matrix([
[0, 0, 1, 0],
[0, 0, 0, 2]]) 
```

另请参阅

[`eye`](#sympy.matrices.matrixbase.MatrixBase.eye "sympy.matrices.matrixbase.MatrixBase.eye"), [`diagonal`](#sympy.matrices.matrixbase.MatrixBase.diagonal "sympy.matrices.matrixbase.MatrixBase.diagonal"), [`dense.diag`](#sympy.matrices.dense.diag "sympy.matrices.dense.diag"), [`expressions.blockmatrix.BlockMatrix`](expressions.html#sympy.matrices.expressions.blockmatrix.BlockMatrix "sympy.matrices.expressions.blockmatrix.BlockMatrix"), [`sparsetools.banded`](sparsetools.html#sympy.matrices.sparsetools.banded "sympy.matrices.sparsetools.banded")

```py
diagonal(k=0)
```

返回self的第k条对角线。主对角线对应于\(k=0\)；上下对角线对应于\(k > 0\)和\(k < 0\)，分别按\(i + j\)增加的顺序返回，从\(i + j = |k|\)开始。

示例

```py
>>> from sympy import Matrix
>>> m = Matrix(3, 3, lambda i, j: j - i); m
Matrix([
[ 0,  1, 2],
[-1,  0, 1],
[-2, -1, 0]])
>>> _.diagonal()
Matrix([[0, 0, 0]])
>>> m.diagonal(1)
Matrix([[1, 1]])
>>> m.diagonal(-2)
Matrix([[-2]]) 
```

即使对角线作为矩阵返回，也可以使用单个索引进行元素检索：

```py
>>> Matrix.diag(1, 2, 3).diagonal()[1]  # instead of [0, 1]
2 
```

另请参阅

[`diag`](#sympy.matrices.matrixbase.MatrixBase.diag "sympy.matrices.matrixbase.MatrixBase.diag")

```py
diagonal_solve(rhs)
```

高效地解决 `Ax = B`，其中A是一个对角线矩阵，具有非零对角线条目。

示例

```py
>>> from sympy import Matrix, eye
>>> A = eye(2)*2
>>> B = Matrix([[1, 2], [3, 4]])
>>> A.diagonal_solve(B) == B/2
True 
```

另请参阅

[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve "sympy.matrices.matrixbase.MatrixBase.cramer_solve")

```py
diagonalize(reals_only=False, sort=False, normalize=False)
```

返回(P, D)，其中D为对角线矩阵，而且

> D = P^-1 * M * P

其中M是当前矩阵。

参数：

**reals_only** : bool。是否在需要复数时抛出错误

> 对角化。 (默认：False)

**sort** : bool。对沿对角线的特征值进行排序。 (默认：False)

**normalize** : bool。如果为True，则归一化P的列。 (默认：False)

示例

```py
>>> from sympy import Matrix
>>> M = Matrix(3, 3, [1, 2, 0, 0, 3, 0, 2, -4, 2])
>>> M
Matrix([
[1,  2, 0],
[0,  3, 0],
[2, -4, 2]])
>>> (P, D) = M.diagonalize()
>>> D
Matrix([
[1, 0, 0],
[0, 2, 0],
[0, 0, 3]])
>>> P
Matrix([
[-1, 0, -1],
[ 0, 0, -1],
[ 2, 1,  2]])
>>> P.inv() * M * P
Matrix([
[1, 0, 0],
[0, 2, 0],
[0, 0, 3]]) 
```

另请参阅

[`sympy.matrices.matrixbase.MatrixBase.is_diagonal`](#sympy.matrices.matrixbase.MatrixBase.is_diagonal "sympy.matrices.matrixbase.MatrixBase.is_diagonal")，[`is_diagonalizable`](#sympy.matrices.matrixbase.MatrixBase.is_diagonalizable "sympy.matrices.matrixbase.MatrixBase.is_diagonalizable")

```py
diff(*args, evaluate=True, **kwargs)
```

计算矩阵每个元素的导数。

示例

```py
>>> from sympy import Matrix
>>> from sympy.abc import x, y
>>> M = Matrix([[x, y], [1, 0]])
>>> M.diff(x)
Matrix([
[1, 0],
[0, 0]]) 
```

另请参阅

[`integrate`](#sympy.matrices.matrixbase.MatrixBase.integrate "sympy.matrices.matrixbase.MatrixBase.integrate")，[`limit`](#sympy.matrices.matrixbase.MatrixBase.limit "sympy.matrices.matrixbase.MatrixBase.limit")

```py
dot(b, hermitian=None, conjugate_convention=None)
```

返回两个长度相等的向量的点积或内积。这里`self`必须是大小为1 x n或n x 1的`Matrix`，而`b`必须是大小为1 x n、n x 1的矩阵或长度为n的列表/元组。返回一个标量。

默认情况下，`dot`不会共轭`self`或`b`，即使存在复数条目。设置`hermitian=True`（以及可选的`conjugate_convention`）以计算共轭内积。

可能的关键字参数包括`hermitian`和`conjugate_convention`。

如果`conjugate_convention`为`"left"`、`"math"`或`"maths"`，则使用第一个向量`self`的共轭。如果指定`"right"`或`"physics"`，则使用第二个向量`b`的共轭。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> v = Matrix([1, 1, 1])
>>> M.row(0).dot(v)
6
>>> M.col(0).dot(v)
12
>>> v = [3, 2, 1]
>>> M.row(0).dot(v)
10 
```

```py
>>> from sympy import I
>>> q = Matrix([1*I, 1*I, 1*I])
>>> q.dot(q, hermitian=False)
-3 
```

```py
>>> q.dot(q, hermitian=True)
3 
```

```py
>>> q1 = Matrix([1, 1, 1*I])
>>> q.dot(q1, hermitian=True, conjugate_convention="maths")
1 - 2*I
>>> q.dot(q1, hermitian=True, conjugate_convention="physics")
1 + 2*I 
```

另请参阅

[`cross`](#sympy.matrices.matrixbase.MatrixBase.cross "sympy.matrices.matrixbase.MatrixBase.cross")，[`multiply`](#sympy.matrices.matrixbase.MatrixBase.multiply "sympy.matrices.matrixbase.MatrixBase.multiply")，[`multiply_elementwise`](#sympy.matrices.matrixbase.MatrixBase.multiply_elementwise "sympy.matrices.matrixbase.MatrixBase.multiply_elementwise")

```py
dual()
```

返回矩阵的对偶。

矩阵的对偶是：

`(1/2)*levicivita(i, j, k, l)*M(k, l)` 对指数\(k\)和\(l\)求和

由于levicivita方法对任意索引的成对交换都是反对称的，对称矩阵的对偶是零矩阵。严格来说，此处定义的对偶假定‘矩阵’\(M\)是一个逆变反对称的二阶张量，因此对偶是一个协变的二阶张量。

```py
echelon_form(iszerofunc=<function _iszero>, simplify=False, with_pivots=False)
```

返回一个与`M`等价的行阶梯形式的矩阵。注意矩阵的阶梯形式*不是*唯一的，但是行空间和零空间等属性是保持不变的。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix([[1, 2], [3, 4]])
>>> M.echelon_form()
Matrix([
[1,  2],
[0, -2]]) 
```

```py
eigenvals(error_when_incomplete=True, **flags)
```

计算矩阵的特征值。

参数：

**在不完全时引发错误**：布尔型，可选

> 如果设置为`True`，则如果没有计算所有特征值，则会引发错误。这是由于`roots`未返回完整的特征值列表引起的。

**简化**：布尔型或函数，可选

> 如果设置为`True`，则尝试在每个例程中通过应用默认的简化方法返回表达式的最简形式。
> 
> 如果设置为`False`，则会跳过此特定例程中的简化以节省计算资源。
> 
> 如果传递一个函数，则尝试将特定函数应用为简化方法。

**有理数**：布尔型，可选

> 如果设置为`True`，则在计算之前，每个浮点数将被替换为有理数。它可以解决`roots`例程在浮点数上运行不良的一些问题。

**multiple**：bool，可选项

> 如果设置为`True`，结果将以列表形式返回。
> 
> 如果设置为`False`，结果将以字典形式返回。

返回：

**eigs**：列表或字典

> 矩阵的特征值。返回格式将由`multiple`键指定。

引发：

**MatrixError**

> 如果计算的根数不足。

**NonSquareMatrixError**

> 如果尝试从非方阵计算特征值。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix(3, 3, [0, 1, 1, 1, 0, 0, 1, 1, 1])
>>> M.eigenvals()
{-1: 1, 0: 1, 2: 1} 
```

注意

矩阵\(A\)的特征值可以通过解决矩阵方程\(\det(A - \lambda I) = 0\)来计算。

对于大于\(4, 4\)形状的矩阵，由于Abel-Ruffini定理，无法总是返回特征值的根式解。

如果未找到特征值的根式解，则可能以[`sympy.polys.rootoftools.ComplexRootOf`](../polys/reference.html#sympy.polys.rootoftools.ComplexRootOf "sympy.polys.rootoftools.ComplexRootOf")的形式返回特征值。

另请参阅

[`MatrixBase.charpoly`](#sympy.matrices.matrixbase.MatrixBase.charpoly "sympy.matrices.matrixbase.MatrixBase.charpoly")，[`eigenvects`](#sympy.matrices.matrixbase.MatrixBase.eigenvects "sympy.matrices.matrixbase.MatrixBase.eigenvects")

```py
eigenvects(error_when_incomplete=True, iszerofunc=<function _iszero>, **flags)
```

计算矩阵的特征向量。

参数：

**error_when_incomplete**：bool，可选项

> 当没有计算出所有特征值时会引发错误。这是由于`roots`没有返回完整的特征值列表造成的。

**iszerofunc**：函数，可选项

> 指定在`rref`中使用的零测试函数。
> 
> 默认值为`_iszero`，它使用SymPy的简单且快速的默认假设处理程序。
> 
> 如果格式化为接受单一符号参数并返回`True`（如果被测试为零）、`False`（如果被测试为非零）、`None`（如果无法判断）的函数，则还可以接受任何用户指定的零测试函数。

**simplify**：bool或函数，可选项

> 如果设置为`True`，将使用`as_content_primitive()`来整理归一化产生的副作用。
> 
> 它还将被`nullspace`例程使用。

**chop**：bool或正数，可选项

> 如果矩阵包含任何浮点数，它们将会被更改为有理数进行计算，但答案将在使用`evalf`进行评估后返回。`chop`标志传递给`evalf`。当`chop=True`时，将使用默认精度；数字将被解释为所需的精度级别。

返回：

**ret**：[(eigenval，multiplicity，eigenspace)，…]

> 包含通过`eigenvals`和`nullspace`获得的数据元组的不整齐列表。
> 
> `eigenspace`是一个包含每个特征值的`eigenvector`的列表。
> 
> `eigenvector`是一个以`Matrix`形式表示的向量。例如，长度为3的向量返回为`Matrix([a_1, a_2, a_3])`。

引发：

**NotImplementedError**

> 无法计算零空间时。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix(3, 3, [0, 1, 1, 1, 0, 0, 1, 1, 1])
>>> M.eigenvects()
[(-1, 1, [Matrix([
[-1],
[ 1],
[ 0]])]), (0, 1, [Matrix([
[ 0],
[-1],
[ 1]])]), (2, 1, [Matrix([
[2/3],
[1/3],
[  1]])])] 
```

另请参阅

[`eigenvals`](#sympy.matrices.matrixbase.MatrixBase.eigenvals "sympy.matrices.matrixbase.MatrixBase.eigenvals"), [`MatrixBase.nullspace`](#sympy.matrices.matrixbase.MatrixBase.nullspace "sympy.matrices.matrixbase.MatrixBase.nullspace")

```py
elementary_col_op(op='n->kn', col=None, k=None, col1=None, col2=None)
```

执行基本列操作\(op\)。

\(op\) 可以是以下之一

> +   `"n->kn"`（第 n 列变为 k*n）
> +   
> +   `"n<->m"`（交换第 n 列和第 m 列）
> +   
> +   `"n->n+km"`（第 n 列变为第 n 列 + k*第 m 列）

参数：

**op**：字符串；基本行操作

**col**：应用列操作的列

**k**：应用于列操作的倍数

**col1**：列交换的一列

**col2**：交换列或列操作中的第二列“m”的第二列

> “n->n+km”

```py
elementary_row_op(op='n->kn', row=None, k=None, row1=None, row2=None)
```

执行基本行操作\(op\)。

\(op\) 可以是以下之一

> +   `"n->kn"`（第 n 行变为 k*n）
> +   
> +   `"n<->m"`（交换第 n 行和第 m 行）
> +   
> +   `"n->n+km"`（第 n 行变为第 n 行 + k*第 m 行）

参数：

**op**：字符串；基本行操作

**row**：应用行操作的行

**k**：在行操作中应用的倍数

**row1**：行交换的一行

**row2**：交换行或行操作中的第二行“m”的第二行

> “n->n+km”

```py
evalf(n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False)
```

对 self 的每个元素应用 evalf()。

```py
exp()
```

返回一个方阵的指数。

示例

```py
>>> from sympy import Symbol, Matrix 
```

```py
>>> t = Symbol('t')
>>> m = Matrix([[0, 1], [-1, 0]]) * t
>>> m.exp()
Matrix([
[    exp(I*t)/2 + exp(-I*t)/2, -I*exp(I*t)/2 + I*exp(-I*t)/2],
[I*exp(I*t)/2 - I*exp(-I*t)/2,      exp(I*t)/2 + exp(-I*t)/2]]) 
```

```py
expand(deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints)
```

对矩阵的每个条目应用 core.function.expand。

示例

```py
>>> from sympy.abc import x
>>> from sympy import Matrix
>>> Matrix(1, 1, [x*(x+1)])
Matrix([[x*(x + 1)]])
>>> _.expand()
Matrix([[x**2 + x]]) 
```

```py
extract(rowsList, colsList)
```

通过指定行和列的列表返回子矩阵。可以给出负索引。所有索引必须在\(-n \le i < n\)范围内，其中\(n\)是行数或列数。

示例

```py
>>> from sympy import Matrix
>>> m = Matrix(4, 3, range(12))
>>> m
Matrix([
[0,  1,  2],
[3,  4,  5],
[6,  7,  8],
[9, 10, 11]])
>>> m.extract([0, 1, 3], [0, 1])
Matrix([
[0,  1],
[3,  4],
[9, 10]]) 
```

行或列可以重复：

```py
>>> m.extract([0, 0, 1], [-1])
Matrix([
[2],
[2],
[5]]) 
```

可以通过使用范围来提供索引来获取每个其他行：

```py
>>> m.extract(range(0, m.rows, 2), [-1])
Matrix([
[2],
[8]]) 
```

RowsList或colsList也可以是布尔列表，此时将选择对应于True值的行或列：

```py
>>> m.extract([0, 1, 2, 3], [True, False, True])
Matrix([
[0,  2],
[3,  5],
[6,  8],
[9, 11]]) 
```

```py
classmethod eye(rows, cols=None, **kwargs)
```

返回单位矩阵。

参数：

**rows**：矩阵的行

**cols**：矩阵的列数（如果为None，则cols=rows）

Kwargs

cls：返回矩阵的类

```py
flat()
```

返回矩阵中所有元素的扁平列表。

示例

```py
>>> from sympy import Matrix
>>> m = Matrix([[0, 2], [3, 4]])
>>> m.flat()
[0, 2, 3, 4] 
```

另请参阅

[`tolist`](#sympy.matrices.matrixbase.MatrixBase.tolist "sympy.matrices.matrixbase.MatrixBase.tolist"), [`values`](#sympy.matrices.matrixbase.MatrixBase.values "sympy.matrices.matrixbase.MatrixBase.values")

```py
property free_symbols
```

返回矩阵中的自由符号。

示例

```py
>>> from sympy.abc import x
>>> from sympy import Matrix
>>> Matrix([[x], [1]]).free_symbols
{x} 
```

```py
classmethod from_dok(rows, cols, dok)
```

从键的字典创建矩阵。

示例

```py
>>> from sympy import Matrix
>>> d = {(0, 0): 1, (1, 2): 3, (2, 1): 4}
>>> Matrix.from_dok(3, 3, d)
Matrix([
[1, 0, 0],
[0, 0, 3],
[0, 4, 0]]) 
```

```py
gauss_jordan_solve(B, freevar=False)
```

使用高斯约旦消元解决`Ax = B`。

可能存在零个、一个或无限多个解。如果存在一个解，将返回该解。如果存在无限多个解，将以参数方式返回。如果不存在解，则会抛出 ValueError。

参数：

**B**：矩阵

> 要解决的方程的右手边。必须与矩阵 A 具有相同的行数。

**freevar**：布尔值，可选

> 当设置为\(True\)时，将返回解（列矩阵）中自由变量的索引，对于不定系统（例如 A 的列数多于行数），其中可能存在无限解，涉及自由变量的任意值。默认\(False\)。

返回：

**x**：矩阵

> 将满足 `Ax = B` 的矩阵。将具有与矩阵 A 的列数相同的行数，以及与矩阵 B 相同的列数。

**params**：矩阵

> 如果系统欠定（例如 A 的列数多于行数），则可能存在无穷解，其中任意参数被返回为参数矩阵。

**free_var_index**：列表，可选

> 如果系统欠定（例如 A 的列数多于行数），则可能存在无穷解，其中自由变量的索引在解决方案中返回（列矩阵），如果标志 \(freevar\) 被设置为 \(True\)。

示例

```py
>>> from sympy import Matrix
>>> A = Matrix([[1, 2, 1, 1], [1, 2, 2, -1], [2, 4, 0, 6]])
>>> B = Matrix([7, 12, 4])
>>> sol, params = A.gauss_jordan_solve(B)
>>> sol
Matrix([
[-2*tau0 - 3*tau1 + 2],
[                 tau0],
[           2*tau1 + 5],
[                 tau1]])
>>> params
Matrix([
[tau0],
[tau1]])
>>> taus_zeroes = { tau:0 for tau in params }
>>> sol_unique = sol.xreplace(taus_zeroes)
>>> sol_unique
 Matrix([
[2],
[0],
[5],
[0]]) 
```

```py
>>> A = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 10]])
>>> B = Matrix([3, 6, 9])
>>> sol, params = A.gauss_jordan_solve(B)
>>> sol
Matrix([
[-1],
[ 2],
[ 0]])
>>> params
Matrix(0, 1, []) 
```

```py
>>> A = Matrix([[2, -7], [-1, 4]])
>>> B = Matrix([[-21, 3], [12, -2]])
>>> sol, params = A.gauss_jordan_solve(B)
>>> sol
Matrix([
[0, -2],
[3, -1]])
>>> params
Matrix(0, 2, []) 
```

```py
>>> from sympy import Matrix
>>> A = Matrix([[1, 2, 1, 1], [1, 2, 2, -1], [2, 4, 0, 6]])
>>> B = Matrix([7, 12, 4])
>>> sol, params, freevars = A.gauss_jordan_solve(B, freevar=True)
>>> sol
Matrix([
[-2*tau0 - 3*tau1 + 2],
[                 tau0],
[           2*tau1 + 5],
[                 tau1]])
>>> params
Matrix([
[tau0],
[tau1]])
>>> freevars
[1, 3] 
```

另请参阅

[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv`](#sympy.matrices.matrixbase.MatrixBase.pinv "sympy.matrices.matrixbase.MatrixBase.pinv")

参考

[[R616](#id9)]

[https://en.wikipedia.org/wiki/Gaussian_elimination](https://en.wikipedia.org/wiki/Gaussian_elimination)

```py
get_diag_blocks()
```

获得方阵主对角线上的平方子矩阵。

对于求逆符号矩阵或解耦可能通过具有块对角结构的系统线性方程组很有用。

示例

```py
>>> from sympy import Matrix
>>> from sympy.abc import x, y, z
>>> A = Matrix([[1, 3, 0, 0], [y, z*z, 0, 0], [0, 0, x, 0], [0, 0, 0, 0]])
>>> a1, a2, a3 = A.get_diag_blocks()
>>> a1
Matrix([
[1,    3],
[y, z**2]])
>>> a2
Matrix([[x]])
>>> a3
Matrix([[0]]) 
```

```py
has(*patterns)
```

测试是否有任何子表达式与任何模式匹配。

示例

```py
>>> from sympy import Matrix, SparseMatrix, Float
>>> from sympy.abc import x, y
>>> A = Matrix(((1, x), (0.2, 3)))
>>> B = SparseMatrix(((1, x), (0.2, 3)))
>>> A.has(x)
True
>>> A.has(y)
False
>>> A.has(Float)
True
>>> B.has(x)
True
>>> B.has(y)
False
>>> B.has(Float)
True 
```

```py
hat()
```

返回代表叉乘的反对称矩阵，以便 `self.hat() * b` 等同于 `self.cross(b)`。

示例

调用 `hat` 创建一个从 3x1 矩阵到 skew-symmetric 3x3 矩阵的斜对称矩阵：

```py
>>> from sympy import Matrix
>>> a = Matrix([1, 2, 3])
>>> a.hat()
Matrix([
[ 0, -3,  2],
[ 3,  0, -1],
[-2,  1,  0]]) 
```

将其与另一个 3x1 矩阵相乘可计算叉乘：

```py
>>> b = Matrix([3, 2, 1])
>>> a.hat() * b
Matrix([
[-4],
[ 8],
[-4]]) 
```

这相当于调用 `cross` 方法：

```py
>>> a.cross(b)
Matrix([
[-4],
[ 8],
[-4]]) 
```

另请参阅

[`dot`](#sympy.matrices.matrixbase.MatrixBase.dot "sympy.matrices.matrixbase.MatrixBase.dot"), [`cross`](#sympy.matrices.matrixbase.MatrixBase.cross "sympy.matrices.matrixbase.MatrixBase.cross"), [`vee`](#sympy.matrices.matrixbase.MatrixBase.vee "sympy.matrices.matrixbase.MatrixBase.vee"), [`multiply`](#sympy.matrices.matrixbase.MatrixBase.multiply "sympy.matrices.matrixbase.MatrixBase.multiply"), [`multiply_elementwise`](#sympy.matrices.matrixbase.MatrixBase.multiply_elementwise "sympy.matrices.matrixbase.MatrixBase.multiply_elementwise")

```py
classmethod hstack(*args)
```

返回通过水平连接 args 形成的矩阵（即通过反复应用 row_join）。

示例

```py
>>> from sympy import Matrix, eye
>>> Matrix.hstack(eye(2), 2*eye(2))
Matrix([
[1, 0, 2, 0],
[0, 1, 0, 2]]) 
```

```py
integrate(*args, **kwargs)
```

对矩阵的每个元素进行积分。`args`将传递给`integrate`函数。

示例

```py
>>> from sympy import Matrix
>>> from sympy.abc import x, y
>>> M = Matrix([[x, y], [1, 0]])
>>> M.integrate((x, ))
Matrix([
[x**2/2, x*y],
[     x,   0]])
>>> M.integrate((x, 0, 2))
Matrix([
[2, 2*y],
[2,   0]]) 
```

参见

[`limit`](#sympy.matrices.matrixbase.MatrixBase.limit "sympy.matrices.matrixbase.MatrixBase.limit"), [`diff`](#sympy.matrices.matrixbase.MatrixBase.diff "sympy.matrices.matrixbase.MatrixBase.diff")

```py
inv(method=None, iszerofunc=<function _iszero>, try_block_diag=False)
```

使用指定的方法返回矩阵的逆。如果找到合适的域，则默认为 DM，否则为密集矩阵的 GE，稀疏矩阵的 LDL。

参数：

**method**：（‘DM’, ‘DMNC’, ‘GE’, ‘LU’, ‘ADJ’, ‘CH’, ‘LDL’, ‘QR’）

**iszerofunc**：函数，可选

> 零测试函数的使用。

**try_block_diag**：布尔值，可选

> 如果为真，则将尝试使用`get_diag_blocks()`方法形成块对角矩阵，分别求逆，然后重构完整的逆矩阵。

引发：

**ValueError**

> 如果矩阵的行列式为零。

示例

```py
>>> from sympy import SparseMatrix, Matrix
>>> A = SparseMatrix([
... [ 2, -1,  0],
... [-1,  2, -1],
... [ 0,  0,  2]])
>>> A.inv('CH')
Matrix([
[2/3, 1/3, 1/6],
[1/3, 2/3, 1/3],
[  0,   0, 1/2]])
>>> A.inv(method='LDL') # use of 'method=' is optional
Matrix([
[2/3, 1/3, 1/6],
[1/3, 2/3, 1/3],
[  0,   0, 1/2]])
>>> A * _
Matrix([
[1, 0, 0],
[0, 1, 0],
[0, 0, 1]])
>>> A = Matrix(A)
>>> A.inv('CH')
Matrix([
[2/3, 1/3, 1/6],
[1/3, 2/3, 1/3],
[  0,   0, 1/2]])
>>> A.inv('ADJ') == A.inv('GE') == A.inv('LU') == A.inv('CH') == A.inv('LDL') == A.inv('QR')
True 
```

注意事项

根据`method`关键字调用适当的方法：

> DM …. 使用 DomainMatrix `inv_den` 方法 DMNC …. 使用 DomainMatrix `inv_den` 方法且不进行消去 GE …. inverse_GE(); 对于密集矩阵的默认选择 LU …. inverse_LU() ADJ … inverse_ADJ() CH … inverse_CH() LDL … inverse_LDL(); 对于稀疏矩阵的默认选择 QR … inverse_QR()

注意，GE 和 LU 方法可能需要在求逆之前对矩阵进行简化，以便在枢轴过程中正确检测零元素。在困难情况下，可以通过设置`iszerofunc`参数为一个函数来提供自定义零元素检测功能，该函数应返回其参数是否为零。ADJ 程序计算行列式并使用其检测奇异矩阵的能力，除了在对角线上测试零元素外。

参见

[`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"), [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"), [`inverse_LU`](#sympy.matrices.matrixbase.MatrixBase.inverse_LU "sympy.matrices.matrixbase.MatrixBase.inverse_LU"), [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"), [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")

```py
inverse_ADJ(iszerofunc=<function _iszero>)
```

计算使用伴随矩阵和行列式的逆矩阵。

参见

[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"), [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"), [`inverse_LU`](#sympy.matrices.matrixbase.MatrixBase.inverse_LU "sympy.matrices.matrixbase.MatrixBase.inverse_LU"), [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"), [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")

```py
inverse_BLOCK(iszerofunc=<function _iszero>)
```

使用块状逆矩阵计算法。

另见

[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"), [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"), [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"), [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"), [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")

```py
inverse_CH(iszerofunc=<function _iszero>)
```

使用Cholesky分解计算逆矩阵。

另见

[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"), [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"), [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"), [`inverse_LU`](#sympy.matrices.matrixbase.MatrixBase.inverse_LU "sympy.matrices.matrixbase.MatrixBase.inverse_LU"), [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")

```py
inverse_GE(iszerofunc=<function _iszero>)
```

使用高斯消元法计算逆矩阵。

另见

[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"), [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"), [`inverse_LU`](#sympy.matrices.matrixbase.MatrixBase.inverse_LU "sympy.matrices.matrixbase.MatrixBase.inverse_LU"), [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"), [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")

```py
inverse_LDL(iszerofunc=<function _iszero>)
```

使用LDL分解计算逆矩阵。

另见

[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"), [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"), [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"), [`inverse_LU`](#sympy.matrices.matrixbase.MatrixBase.inverse_LU "sympy.matrices.matrixbase.MatrixBase.inverse_LU"), [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH")

```py
inverse_LU(iszerofunc=<function _iszero>)
```

使用 LU 分解计算逆矩阵。

另请参阅

[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"), [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"), [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"), [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"), [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")

```py
inverse_QR(iszerofunc=<function _iszero>)
```

使用 QR 分解计算逆矩阵。

另请参阅

[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"), [`inverse_ADJ`](#sympy.matrices.matrixbase.MatrixBase.inverse_ADJ "sympy.matrices.matrixbase.MatrixBase.inverse_ADJ"), [`inverse_GE`](#sympy.matrices.matrixbase.MatrixBase.inverse_GE "sympy.matrices.matrixbase.MatrixBase.inverse_GE"), [`inverse_CH`](#sympy.matrices.matrixbase.MatrixBase.inverse_CH "sympy.matrices.matrixbase.MatrixBase.inverse_CH"), [`inverse_LDL`](#sympy.matrices.matrixbase.MatrixBase.inverse_LDL "sympy.matrices.matrixbase.MatrixBase.inverse_LDL")

```py
classmethod irregular(ntop, *matrices, **kwargs)
```

返回一个由给定矩阵填充的矩阵，这些矩阵按从左到右，从上到下的顺序列出，它们必须完全填充矩阵。

示例

```py
>>> from sympy import ones, Matrix
>>> Matrix.irregular(3, ones(2,1), ones(3,3)*2, ones(2,2)*3,
...   ones(1,1)*4, ones(2,2)*5, ones(1,2)*6, ones(1,2)*7)
Matrix([
 [1, 2, 2, 2, 3, 3],
 [1, 2, 2, 2, 3, 3],
 [4, 2, 2, 2, 5, 5],
 [6, 6, 7, 7, 5, 5]]) 
```

```py
is_anti_symmetric(simplify=True)
```

检查矩阵 M 是否为反对称矩阵，即，M 是一个所有 M[i, j] == -M[j, i] 的方阵。

当 `simplify=True`（默认情况下），在测试是否为零之前，求和 M[i, j] + M[j, i] 会被简化。默认情况下，使用 SymPy 的简化函数。若要使用自定义函数，请将 simplify 设置为接受单个参数并返回简化表达式的函数。若要跳过简化，请将 simplify 设置为 False，但请注意，尽管这样会更快，但可能会导致错误的负面结果。

示例

```py
>>> from sympy import Matrix, symbols
>>> m = Matrix(2, 2, [0, 1, -1, 0])
>>> m
Matrix([
[ 0, 1],
[-1, 0]])
>>> m.is_anti_symmetric()
True
>>> x, y = symbols('x y')
>>> m = Matrix(2, 3, [0, 0, x, -y, 0, 0])
>>> m
Matrix([
[ 0, 0, x],
[-y, 0, 0]])
>>> m.is_anti_symmetric()
False 
```

```py
>>> from sympy.abc import x, y
>>> m = Matrix(3, 3, [0, x**2 + 2*x + 1, y,
...                   -(x + 1)**2, 0, x*y,
...                   -y, -x*y, 0]) 
```

默认情况下会对矩阵元素进行简化，因此即使两个应相等且相反的元素未通过相等性测试，该矩阵仍会报告为反对称：

```py
>>> m[0, 1] == -m[1, 0]
False
>>> m.is_anti_symmetric()
True 
```

如果用于已经简化的矩阵的情况下 `simplify=False`，这将加快速度。在此例中，我们看到不经过简化的矩阵并不显示为反对称：

```py
>>> print(m.is_anti_symmetric(simplify=False))
None 
```

但是，如果矩阵已经扩展，则会出现反对称化的情况，并且在 `is_anti_symmetric` 程序中不需要简化：

```py
>>> m = m.expand()
>>> m.is_anti_symmetric(simplify=False)
True 
```

```py
is_diagonal()
```

检查矩阵是否为对角矩阵，即除了主对角线外的条目都为零。

示例

```py
>>> from sympy import Matrix, diag
>>> m = Matrix(2, 2, [1, 0, 0, 2])
>>> m
Matrix([
[1, 0],
[0, 2]])
>>> m.is_diagonal()
True 
```

```py
>>> m = Matrix(2, 2, [1, 1, 0, 2])
>>> m
Matrix([
[1, 1],
[0, 2]])
>>> m.is_diagonal()
False 
```

```py
>>> m = diag(1, 2, 3)
>>> m
Matrix([
[1, 0, 0],
[0, 2, 0],
[0, 0, 3]])
>>> m.is_diagonal()
True 
```

另请参阅

[`is_lower`](#sympy.matrices.matrixbase.MatrixBase.is_lower "sympy.matrices.matrixbase.MatrixBase.is_lower")，[`is_upper`](#sympy.matrices.matrixbase.MatrixBase.is_upper "sympy.matrices.matrixbase.MatrixBase.is_upper")，[`sympy.matrices.matrixbase.MatrixBase.is_diagonalizable`](#sympy.matrices.matrixbase.MatrixBase.is_diagonalizable "sympy.matrices.matrixbase.MatrixBase.is_diagonalizable")，[`diagonalize`](#sympy.matrices.matrixbase.MatrixBase.diagonalize "sympy.matrices.matrixbase.MatrixBase.diagonalize")

```py
is_diagonalizable(reals_only=False, **kwargs)
```

如果矩阵可对角化，则返回 `True`。

参数：

**reals_only** : bool, 可选

> 如果 `True`，则测试矩阵是否可对角化为仅包含实数的对角线。
> 
> 如果 `False`，则测试矩阵是否可以对角化，即使使用可能不是实数的数字。

示例

对角化矩阵示例：

```py
>>> from sympy import Matrix
>>> M = Matrix([[1, 2, 0], [0, 3, 0], [2, -4, 2]])
>>> M.is_diagonalizable()
True 
```

非对角化矩阵示例：

```py
>>> M = Matrix([[0, 1], [0, 0]])
>>> M.is_diagonalizable()
False 
```

以非实数条目为基础对角化的矩阵示例：

```py
>>> M = Matrix([[0, 1], [-1, 0]])
>>> M.is_diagonalizable(reals_only=False)
True
>>> M.is_diagonalizable(reals_only=True)
False 
```

另请参阅

[`sympy.matrices.matrixbase.MatrixBase.is_diagonal`](#sympy.matrices.matrixbase.MatrixBase.is_diagonal "sympy.matrices.matrixbase.MatrixBase.is_diagonal")，[`diagonalize`](#sympy.matrices.matrixbase.MatrixBase.diagonalize "sympy.matrices.matrixbase.MatrixBase.diagonalize")

```py
property is_echelon
```

如果矩阵处于梯形形式，则返回 \(True\)。即，所有零行都位于底部，并且每行中的主导非零元素下方都是零。

```py
property is_hermitian
```

检查矩阵是否是埃尔米特矩阵。

在埃尔米特矩阵中，元素 \(i,j\) 是元素 \(j,i\) 的复共轭。

示例

```py
>>> from sympy import Matrix
>>> from sympy import I
>>> from sympy.abc import x
>>> a = Matrix([[1, I], [-I, 1]])
>>> a
Matrix([
[ 1, I],
[-I, 1]])
>>> a.is_hermitian
True
>>> a[0, 0] = 2*I
>>> a.is_hermitian
False
>>> a[0, 0] = x
>>> a.is_hermitian
>>> a[0, 1] = a[1, 0]*I
>>> a.is_hermitian
False 
```

```py
property is_indefinite
```

确定矩阵的定性。

解释

对于一个方阵 \(A\)，如果：

+   对于所有非零实向量 \(x\)，如果 \(x^T A x > 0\)，则矩阵是正定的。

+   对于所有非零实向量 \(x\)，如果 \(x^T A x \geq 0\)，则矩阵是半正定的。

+   对于所有非零实向量 \(x\)，如果 \(x^T A x < 0\)，则矩阵是负定的。

+   对于所有非零实向量 \(x\)，如果 \(x^T A x \leq 0\)，则矩阵是负半定的。

+   如果存在非零实向量 \(x, y\) 使得 \(x^T A x > 0 > y^T A y\)，则矩阵是不定的。

对于一个复方阵 \(A\)，如果：

+   对于所有非零复向量 \(x\)，如果 \(\text{re}(x^H A x) > 0\)，则矩阵是正定的。

+   对于所有非零复向量 \(x\)，如果 \(\text{re}(x^H A x) \geq 0\)，则矩阵是半正定的。

+   对于所有非零复向量 \(x\)，如果 \(\text{re}(x^H A x) < 0\)，则矩阵是负定的。

+   对于所有非零复向量 \(x\)，如果 \(\text{re}(x^H A x) \leq 0\)，则矩阵是负半定的。

+   如果存在非零复向量 \(x, y\) 使得 \(\text{re}(x^H A x) > 0 > \text{re}(y^H A y)\)，则矩阵是不定的。

矩阵不需要是对称或埃尔米特矩阵才能是正定的。

+   对于实非对称矩阵，当且仅当 \(\frac{A + A^T}{2}\) 正定时，它才是正定的。

+   复杂非厄米矩阵仅当 \(\frac{A + A^H}{2}\) 正定时才是正定的。

并且此扩展可以适用于上述所有定义。

然而，对于复杂情况，你可以将 \(\text{re}(x^H A x) > 0\) 的定义限制为 \(x^H A x > 0\) 并要求矩阵是厄米的。但是我们不会为计算呈现此限制，因为你可以独立检查 `M.is_hermitian` 并使用相同的程序。

例子

对称正定矩阵的示例：

```py
>>> from sympy import Matrix, symbols
>>> from sympy.plotting import plot3d
>>> a, b = symbols('a b')
>>> x = Matrix([a, b]) 
```

```py
>>> A = Matrix([[1, 0], [0, 1]])
>>> A.is_positive_definite
True
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/fe5156c3aec16ecd262cdc3ed2267d84/matrices-1.png), [`hires.png`](../../_downloads/e3193d497eaf6c8abcce4958dd4a5a24/matrices-1.hires.png), [`pdf`](../../_downloads/dac00acb10450bde21ecfc4fd9c34817/matrices-1.pdf))

![../../_images/matrices-1.png](../Images/4916da1c0432aff2f10026acd2887d36.png)

对称正半定矩阵的示例：

```py
>>> A = Matrix([[1, -1], [-1, 1]])
>>> A.is_positive_definite
False
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/0d8e9f24fa36bf1b5ba81e15343cc16a/matrices-2.png), [`hires.png`](../../_downloads/730039e192f59c01d9e2f23c5d862e93/matrices-2.hires.png), [`pdf`](../../_downloads/704bfe351153d402a4a0a831ece25675/matrices-2.pdf))

![../../_images/matrices-2.png](../Images/eace542660423182e10c6bddd5c97383.png)

对称负定矩阵的示例：

```py
>>> A = Matrix([[-1, 0], [0, -1]])
>>> A.is_negative_definite
True
>>> A.is_negative_semidefinite
True
>>> A.is_indefinite
False 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/3d9c323c5b29e6c0f5213d15bc6d4340/matrices-3.png), [`hires.png`](../../_downloads/7eab27e4b46ecd5ee93685f96489c057/matrices-3.hires.png), [`pdf`](../../_downloads/e0563f4c3c89c72192ce76efd2e6fe6b/matrices-3.pdf))

![../../_images/matrices-3.png](../Images/a2e8d23abdcb48721361ad1d1e406dba.png)

对称不定矩阵的示例：

```py
>>> A = Matrix([[1, 2], [2, -1]])
>>> A.is_indefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/35a507f5bfd4c8404dc5c74a12c6cf40/matrices-4.png), [`hires.png`](../../_downloads/67c6b9a24ce06a94da0bcf2ee46feb48/matrices-4.hires.png), [`pdf`](../../_downloads/2667a5fcc739d282a7512f6b7b39071a/matrices-4.pdf))

![../../_images/matrices-4.png](../Images/0c3951d2c3aa78848405c4aa739f7f33.png)

非对称正定矩阵的示例。

```py
>>> A = Matrix([[1, 2], [-2, 1]])
>>> A.is_positive_definite
True
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/4a265f8dd3b8c7410c3383172e12a130/matrices-5.png), [`hires.png`](../../_downloads/8bcf06e266cbe0b4c7b278c72b30131b/matrices-5.hires.png), [`pdf`](../../_downloads/e51f495094ca971c2da007d95d7c6aff/matrices-5.pdf))

![../../_images/matrices-5.png](../Images/573fb2b43a50a3a209b2853a0d0f457f.png)

注意事项

尽管有些人将正定矩阵的定义简化为只适用于对称或厄米矩阵，但这种限制是不正确的，因为它不能从定义 \(x^T A x > 0\) 或 \(\text{re}(x^H A x) > 0\) 对所有正定矩阵进行分类。

例如，以上示例中提供的 `Matrix([[1, 2], [-2, 1]])` 是一个非对称的实正定矩阵的示例。

然而，因为以下公式成立；

\[\text{re}(x^H A x) > 0 \iff \text{re}(x^H \frac{A + A^H}{2} x) > 0\]

我们可以通过将矩阵转换为\(\frac{A + A^T}{2}\)或\(\frac{A + A^H}{2}\)（保证总是实对称或复合埃尔米特），对所有可能或可能不对称或埃尔米特的正定矩阵进行分类，并且我们可以推迟大部分研究到对称或埃尔米特正定矩阵。

但对于乔列斯基分解的存在是一个不同的问题。因为即使非对称或非埃尔米特矩阵可能是正定的，乔列斯基或LDL分解也不存在，因为这些分解要求矩阵是对称或埃尔米特的。

参考文献

[[R617](#id10)]

[https://zh.wikipedia.org/wiki/矩阵的定性#特征值](https://zh.wikipedia.org/wiki/矩阵的定性#特征值)

[[R618](#id11)]

[https://mathworld.wolfram.com/正定矩阵.html](https://mathworld.wolfram.com/正定矩阵.html)

[[R619](#id12)]

约翰逊，C. R. “正定矩阵。” 美国数学月刊 77，259-264，1970年。

```py
property is_lower
```

检查矩阵是否为下三角矩阵。即使矩阵不是方阵，也可能返回True。

示例

```py
>>> from sympy import Matrix
>>> m = Matrix(2, 2, [1, 0, 0, 1])
>>> m
Matrix([
[1, 0],
[0, 1]])
>>> m.is_lower
True 
```

```py
>>> m = Matrix(4, 3, [0, 0, 0, 2, 0, 0, 1, 4, 0, 6, 6, 5])
>>> m
Matrix([
[0, 0, 0],
[2, 0, 0],
[1, 4, 0],
[6, 6, 5]])
>>> m.is_lower
True 
```

```py
>>> from sympy.abc import x, y
>>> m = Matrix(2, 2, [x**2 + y, y**2 + x, 0, x + y])
>>> m
Matrix([
[x**2 + y, x + y**2],
[       0,    x + y]])
>>> m.is_lower
False 
```

参见

[`is_upper`](#sympy.matrices.matrixbase.MatrixBase.is_upper "sympy.matrices.matrixbase.MatrixBase.is_upper")，[`is_diagonal`](#sympy.matrices.matrixbase.MatrixBase.is_diagonal "sympy.matrices.matrixbase.MatrixBase.is_diagonal")，[`is_lower_hessenberg`](#sympy.matrices.matrixbase.MatrixBase.is_lower_hessenberg "sympy.matrices.matrixbase.MatrixBase.is_lower_hessenberg")

```py
property is_lower_hessenberg
```

检查矩阵是否处于下赫森伯格形式。

下三角赫森伯格矩阵在第一个超对角线上方的条目为零。

示例

```py
>>> from sympy import Matrix
>>> a = Matrix([[1, 2, 0, 0], [5, 2, 3, 0], [3, 4, 3, 7], [5, 6, 1, 1]])
>>> a
Matrix([
[1, 2, 0, 0],
[5, 2, 3, 0],
[3, 4, 3, 7],
[5, 6, 1, 1]])
>>> a.is_lower_hessenberg
True 
```

参见

[`is_upper_hessenberg`](#sympy.matrices.matrixbase.MatrixBase.is_upper_hessenberg "sympy.matrices.matrixbase.MatrixBase.is_upper_hessenberg")，[`is_lower`](#sympy.matrices.matrixbase.MatrixBase.is_lower "sympy.matrices.matrixbase.MatrixBase.is_lower")

```py
property is_negative_definite
```

查找矩阵的定性。

解释

实方形矩阵\(A\)是：

+   如果对于所有非零实向量\(x\)，\(x^T A x > 0\)，则为正定矩阵。

+   如果对于所有非零实向量\(x\)，\(x^T A x \geq 0\)，则为正半定矩阵。

+   如果对于所有非零实向量\(x\)，\(x^T A x < 0\)，则为负定矩阵。

+   如果对于所有非零实向量\(x\)，\(x^T A x \leq 0\)，则为负半定矩阵。

+   如果存在非零实向量\(x, y\)，使得\(x^T A x > 0 > y^T A y\)，则为不定矩阵。

复正方形矩阵\(A\)是：

+   如果对于所有非零复向量\(x\)，\(\text{re}(x^H A x) > 0\)，则为正定矩阵。

+   如果对于所有非零复向量\(x\)，\(\text{re}(x^H A x) \geq 0\)，则为正半定矩阵。

+   如果对于所有非零复向量\(x\)，\(\text{re}(x^H A x) < 0\)，则为负定矩阵。

+   如果对于所有非零复向量\(x\)，\(\text{re}(x^H A x) \leq 0\)，则为负半定矩阵。

+   如果存在非零复向量\(x, y\)，使得\(\text{re}(x^H A x) > 0 > \text{re}(y^H A y)\)，则为不定矩阵。

一个矩阵不需要是对称或厄米的才能是正定的。

+   一个实非对称矩阵仅当 \(\frac{A + A^T}{2}\) 是正定的时候，它才是正定的。

+   如果一个复杂的非厄米矩阵仅当 \(\frac{A + A^H}{2}\) 是正定的时候，它才是正定的。

这个扩展可以适用于上述所有定义。

然而，对于复杂情况，您可以将 \(\text{re}(x^H A x) > 0\) 的定义限制为 \(x^H A x > 0\) 并要求矩阵是厄米的。但我们在计算中不提出这种限制，因为您可以独立检查 `M.is_hermitian` 并使用相同的程序。

例子

对称正定矩阵的一个例子：

```py
>>> from sympy import Matrix, symbols
>>> from sympy.plotting import plot3d
>>> a, b = symbols('a b')
>>> x = Matrix([a, b]) 
```

```py
>>> A = Matrix([[1, 0], [0, 1]])
>>> A.is_positive_definite
True
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/132de99a13621a85ce57f12e7c04ed8e/matrices-6.png), [`hires.png`](../../_downloads/a2eb0f47e21015de38f03325bc45d081/matrices-6.hires.png), [`pdf`](../../_downloads/7d4a2d083d96719b05ab2f759c57874a/matrices-6.pdf))

![../../_images/matrices-6.png](../Images/e3e37bc482ba649b41eaa312a2ca73bc.png)

对称正半定矩阵的一个例子：

```py
>>> A = Matrix([[1, -1], [-1, 1]])
>>> A.is_positive_definite
False
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/14ee938ea3b9e6af5895013e42d338ce/matrices-7.png), [`hires.png`](../../_downloads/e2e6cafac8b61828e6a1912c3c55dd0c/matrices-7.hires.png), [`pdf`](../../_downloads/d3453595eb36f834c2ad86d18546535c/matrices-7.pdf))

![../../_images/matrices-7.png](../Images/f1c7f91183deb00fff6155ccca67f992.png)

对称负定矩阵的一个例子：

```py
>>> A = Matrix([[-1, 0], [0, -1]])
>>> A.is_negative_definite
True
>>> A.is_negative_semidefinite
True
>>> A.is_indefinite
False 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/347ab36cb1c742d31da5ef1f8a907628/matrices-8.png), [`hires.png`](../../_downloads/919dab888d297c58417045d3a17721b1/matrices-8.hires.png), [`pdf`](../../_downloads/39dc203c3bf6e7485368c7a401448a6f/matrices-8.pdf))

![../../_images/matrices-8.png](../Images/ea7ac06d6d54ce5f0cc5dd9d35f55fe4.png)

对称不定矩阵的一个例子：

```py
>>> A = Matrix([[1, 2], [2, -1]])
>>> A.is_indefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/9c4403b24b7e7ac8a78acf73bc276a73/matrices-9.png), [`hires.png`](../../_downloads/c7985b2873decf2d383070ffcf33d531/matrices-9.hires.png), [`pdf`](../../_downloads/c1adee8d5f4e9aedd715240ee2abc6e5/matrices-9.pdf))

![../../_images/matrices-9.png](../Images/c2ce2cbce3b0f2c463386a3f9d96c979.png)

非对称正定矩阵的一个例子。

```py
>>> A = Matrix([[1, 2], [-2, 1]])
>>> A.is_positive_definite
True
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/3a5dd7bfe62a7142115c721b3d2532b1/matrices-10.png), [`hires.png`](../../_downloads/299d8f654b66b02a5d111bcf88c758bb/matrices-10.hires.png), [`pdf`](../../_downloads/0130acc9674ca6615e762dac32f6f525/matrices-10.pdf))

![../../_images/matrices-10.png](../Images/89e881190be3747982da2c7dd4548bc4.png)

注意

尽管有些人将正定矩阵的定义仅限于对称或厄米矩阵，但这种限制是不正确的，因为它不能从定义 \(x^T A x > 0\) 或 \(\text{re}(x^H A x) > 0\) 中分类所有正定矩阵的实例。

例如，在上面的例子中，`Matrix([[1, 2], [-2, 1]])` 是一个实正定矩阵的例子，它不是对称的。

然而，由于以下公式成立；

\[\text{re}(x^H A x) > 0 \iff \text{re}(x^H \frac{A + A^H}{2} x) > 0\]

我们可以通过将矩阵转换为 \(\frac{A + A^T}{2}\) 或 \(\frac{A + A^H}{2}\)（这总是保证是实对称或复厄米的）来分类可能是对称或厄米的正定矩阵，并且我们可以将大部分研究延迟到对称或厄米正定矩阵。

但对于Cholesky分解的存在性来说，问题则不同。因为即使非对称或非厄米矩阵可能是正定的，Cholesky或LDL分解也不存在，因为这些分解要求矩阵是对称或厄米的。

参考文献

[[R620](#id13)]

[https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues](https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues)

[[R621](#id14)]

[https://mathworld.wolfram.com/PositiveDefiniteMatrix.html](https://mathworld.wolfram.com/PositiveDefiniteMatrix.html)

[[R622](#id15)]

Johnson, C. R. “正定矩阵.” 美国数学月刊 77, 259-264 1970.

```py
property is_negative_semidefinite
```

发现矩阵的确定性。

解释

一个实方阵 \(A\) 是：

+   正定矩阵，若对所有非零实向量 \(x\) 满足 \(x^T A x > 0\)。

+   正半定矩阵，若对所有非零实向量 \(x\) 满足 \(x^T A x \geq 0\)。

+   负定矩阵，若对所有非零实向量 \(x\) 满足 \(x^T A x < 0\)。

+   负半定矩阵，若对所有非零实向量 \(x\) 满足 \(x^T A x \leq 0\)。

+   不定矩阵，若存在非零实向量 \(x, y\) 满足 \(x^T A x > 0 > y^T A y\)。

一个复方阵 \(A\) 是：

+   正定矩阵，若对所有非零复向量 \(x\) 满足 \(\text{re}(x^H A x) > 0\)。

+   正半定矩阵，若对所有非零复向量 \(x\) 满足 \(\text{re}(x^H A x) \geq 0\)。

+   负定矩阵，若对所有非零复向量 \(x\) 满足 \(\text{re}(x^H A x) < 0\)。

+   负半定矩阵，若对所有非零复向量 \(x\) 满足 \(\text{re}(x^H A x) \leq 0\)。

+   不定矩阵，若存在非零复向量 \(x, y\) 满足 \(\text{re}(x^H A x) > 0 > \text{re}(y^H A y)\)。

矩阵不必是对称或厄米的即可是正定的。

+   当且仅当 \(\frac{A + A^T}{2}\) 是正定时，实非对称矩阵才是正定的。

+   一个复非厄米矩阵当且仅当 \(\frac{A + A^H}{2}\) 是正定时才是正定的。

此扩展可以适用于上述所有定义。

然而，对于复数情况，可以将 \(\text{re}(x^H A x) > 0\) 的定义限制为 \(x^H A x > 0\)，并要求矩阵是厄米的。但为了计算的目的，我们不要求此限制，因为您可以独立检查 `M.is_hermitian` 并使用相同的过程。

示例

一个对称正定矩阵的例子：

```py
>>> from sympy import Matrix, symbols
>>> from sympy.plotting import plot3d
>>> a, b = symbols('a b')
>>> x = Matrix([a, b]) 
```

```py
>>> A = Matrix([[1, 0], [0, 1]])
>>> A.is_positive_definite
True
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

（[`png`](../../_downloads/7789b56ac7f1ecb8f132831353486f26/matrices-11.png), [`hires.png`](../../_downloads/bd32fb3bd291f29fd3137fcce0d15fba/matrices-11.hires.png), [`pdf`](../../_downloads/a892d8f10080acfce9914123b164dd0e/matrices-11.pdf))

![../../_images/matrices-11.png](../Images/f0b00383f3e3821a088dd7f854a9d51a.png)

对称正半定矩阵的一个例子：

```py
>>> A = Matrix([[1, -1], [-1, 1]])
>>> A.is_positive_definite
False
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

（[`png`](../../_downloads/6d56e28a06b250f7ba102de07fed6d6f/matrices-12.png), [`hires.png`](../../_downloads/ed888e4265c5faf635cbe40c22e16539/matrices-12.hires.png), [`pdf`](../../_downloads/83ec70596dcaacc88e256e7679fafcee/matrices-12.pdf))

![../../_images/matrices-12.png](../Images/cd89d1a5a769dd84ee9321b2e1141d40.png)

对称负定矩阵的一个例子：

```py
>>> A = Matrix([[-1, 0], [0, -1]])
>>> A.is_negative_definite
True
>>> A.is_negative_semidefinite
True
>>> A.is_indefinite
False 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

（[`png`](../../_downloads/dbd9a90e8e71af21e1e35032242095d3/matrices-13.png), [`hires.png`](../../_downloads/fc93659fba99871dd8fd641221131ce9/matrices-13.hires.png), [`pdf`](../../_downloads/5b83bd080155a6f59e2eeb633bda5ab4/matrices-13.pdf))

![../../_images/matrices-13.png](../Images/f7cce89123ed5036039773d1cae4e8c7.png)

对称不定矩阵的一个例子：

```py
>>> A = Matrix([[1, 2], [2, -1]])
>>> A.is_indefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

（[`png`](../../_downloads/251852deca26bc9cec31a1c7865e5c72/matrices-14.png), [`hires.png`](../../_downloads/cca6bd30da9f73edc2d5a1f91c3b5655/matrices-14.hires.png), [`pdf`](../../_downloads/d1eadb36634e8e0276f3d1752e83893e/matrices-14.pdf))

![../../_images/matrices-14.png](../Images/3a5275c6f56ee964a0372f9939c9921b.png)

非对称正定矩阵的一个例子。

```py
>>> A = Matrix([[1, 2], [-2, 1]])
>>> A.is_positive_definite
True
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

（[`png`](../../_downloads/4cc3043ea26261353c303c0fcd504cfd/matrices-15.png), [`hires.png`](../../_downloads/77d479f1f001a25cb32034b27787a123/matrices-15.hires.png), [`pdf`](../../_downloads/8c3e8789c867600d80b2cce11272d81e/matrices-15.pdf))

![../../_images/matrices-15.png](../Images/bf9e1cf9cde16bc5ad36d1b8de2c49dc.png)

注释

尽管有些人认为对称或厄米矩阵的正定矩阵定义是微不足道的，但这种限制并不正确，因为它不能将所有正定矩阵实例从定义 \(x^T A x > 0\) 或 \(\text{re}(x^H A x) > 0\) 分类出来。

例如，上述示例中给出的 `Matrix([[1, 2], [-2, 1]])` 是一个实正定矩阵的例子，它不是对称的。

但是，由于以下公式成立；

\[\text{re}(x^H A x) > 0 \iff \text{re}(x^H \frac{A + A^H}{2} x) > 0\]

我们可以通过将矩阵转换为 \(\frac{A + A^T}{2}\) 或 \(\frac{A + A^H}{2}\)（这两者保证总是实对称或复共轭厄米）来分类所有可能对称或厄米正定矩阵，并且我们可以推迟大部分研究到对称或厄米正定矩阵。

但是，对于乔列斯基分解的存在性是一个不同的问题。因为即使非对称或非厄米矩阵可能是正定的，乔列斯基或LDL分解并不存在，因为这些分解要求矩阵是对称或厄米的。

参考文献

[[R623](#id16)]

[https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues](https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues)

[[R624](#id17)]

[https://mathworld.wolfram.com/PositiveDefiniteMatrix.html](https://mathworld.wolfram.com/PositiveDefiniteMatrix.html)

[[R625](#id18)]

约翰逊，C. R. “正定矩阵。” 美国数学月刊 77, 259-264 1970。

```py
is_nilpotent()
```

检查矩阵是否幂零。

矩阵 B 如果存在整数 k，使得 B**k 是零矩阵，则 B 是幂零矩阵。

示例

```py
>>> from sympy import Matrix
>>> a = Matrix([[0, 0, 0], [1, 0, 0], [1, 1, 0]])
>>> a.is_nilpotent()
True 
```

```py
>>> a = Matrix([[1, 0, 1], [1, 0, 0], [1, 1, 0]])
>>> a.is_nilpotent()
False 
```

```py
property is_positive_definite
```

查找矩阵的确定性。

解释

实方阵 \(A\) 如果满足以下条件：

+   对于所有非零实向量 \(x\)，正定矩阵是满足 \(x^T A x > 0\) 的矩阵 \(A\)。

+   对于所有非零实向量 \(x\)，正半定矩阵是满足 \(x^T A x \geq 0\) 的矩阵 \(A\)。

+   对于所有非零实向量 \(x\)，负定矩阵是满足 \(x^T A x < 0\) 的矩阵 \(A\)。

+   对于所有非零实向量 \(x\)，负半定矩阵是满足 \(x^T A x \leq 0\) 的矩阵 \(A\)。

+   如果存在非零实向量 \(x, y\) 使得 \(x^T A x > 0 > y^T A y\)，则矩阵是不定的。

复方阵 \(A\) 如果满足以下条件：

+   对于所有非零复向量 \(x\)，正定矩阵是满足 \(\text{re}(x^H A x) > 0\) 的矩阵 \(A\)。

+   对于所有非零复向量 \(x\)，正半定矩阵是满足 \(\text{re}(x^H A x) \geq 0\) 的矩阵 \(A\)。

+   对于所有非零复向量 \(x\)，负定矩阵是满足 \(\text{re}(x^H A x) < 0\) 的矩阵 \(A\)。

+   对于所有非零复向量 \(x\)，负半定矩阵是满足 \(\text{re}(x^H A x) \leq 0\) 的矩阵 \(A\)。

+   如果存在非零复向量 \(x, y\) 使得 \(\text{re}(x^H A x) > 0 > \text{re}(y^H A y)\)，则矩阵是不定的。

矩阵不必对称或共轭转置来满足正定性。

+   如果且仅当 \(\frac{A + A^T}{2}\) 正定时，非对称实矩阵才是正定的。

+   对于非共轭转置的复数矩阵，仅当 \(\frac{A + A^H}{2}\) 正定时，才是正定的。

并且此扩展可以应用于上述所有定义。

但是对于复数情况，您可以将 \(\text{re}(x^H A x) > 0\) 的定义限制为 \(x^H A x > 0\) 并要求矩阵是共轭转置。但我们不会在计算中提供此限制，因为您可以独立检查 `M.is_hermitian` 并使用相同的过程。

示例

对称正定矩阵的一个例子：

```py
>>> from sympy import Matrix, symbols
>>> from sympy.plotting import plot3d
>>> a, b = symbols('a b')
>>> x = Matrix([a, b]) 
```

```py
>>> A = Matrix([[1, 0], [0, 1]])
>>> A.is_positive_definite
True
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/0dc2c97c9c4fdc58b568a8a82eecead9/matrices-16.png), [`hires.png`](../../_downloads/361100ec1d7f7c1e6d509ce98456c903/matrices-16.hires.png), [`pdf`](../../_downloads/a11367bb58b03bf09a75c9657b4e223a/matrices-16.pdf))

![../../_images/matrices-16.png](../Images/8cff7b3e21a09b5d944ae915f9f2536c.png)

对称正半定矩阵的一个例子：

```py
>>> A = Matrix([[1, -1], [-1, 1]])
>>> A.is_positive_definite
False
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/5df3cd64357fb04b6b8af3d537bbeea6/matrices-17.png), [`hires.png`](../../_downloads/88578b4906705f857b924f96cb792ebf/matrices-17.hires.png), [`pdf`](../../_downloads/3cd14c510b41514f1496a3155ea8cf2d/matrices-17.pdf))

![../../_images/matrices-17.png](../Images/6fb35371b52ed5ec21e66b267775fe48.png)

对称负定矩阵的一个例子：

```py
>>> A = Matrix([[-1, 0], [0, -1]])
>>> A.is_negative_definite
True
>>> A.is_negative_semidefinite
True
>>> A.is_indefinite
False 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/6edcb9da8f09d47584e8ca5d5958a6f2/matrices-18.png), [`hires.png`](../../_downloads/ad9035d1270a7bc56250873e2d009d7d/matrices-18.hires.png), [`pdf`](../../_downloads/464f047ba3ef7f04429a4eb163a6a2de/matrices-18.pdf))

![../../_images/matrices-18.png](../Images/cf5858762e3eca3b88980be57e718a77.png)

对称不定矩阵的一个例子：

```py
>>> A = Matrix([[1, 2], [2, -1]])
>>> A.is_indefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/810de00eed457e63dc8a9c10a5a70437/matrices-19.png), [`hires.png`](../../_downloads/e5039d4c4155d188b38e3ea1be7a5f16/matrices-19.hires.png), [`pdf`](../../_downloads/7eed1bf07a4dacbb97d209dac2614e9a/matrices-19.pdf))

![../../_images/matrices-19.png](../Images/25aa285909f375aba65a1f48b24f4b85.png)

非对称正定矩阵的一个例子。

```py
>>> A = Matrix([[1, 2], [-2, 1]])
>>> A.is_positive_definite
True
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/d62811c8b8bdef23f805382bf088c1d8/matrices-20.png), [`hires.png`](../../_downloads/2b230450d75dde35aa23b644a0a50913/matrices-20.hires.png), [`pdf`](../../_downloads/a6ba697f4fd41244d4a03ae13c871d77/matrices-20.pdf))

![../../_images/matrices-20.png](../Images/f98ccfbaa53b4e480c40018ef6d6fe32.png)

注释

尽管有些人会将正定矩阵的定义仅限于对称或厄米特矩阵，但这种限制并不正确，因为它未能从定义 \(x^T A x > 0\) 或 \(\text{re}(x^H A x) > 0\) 中分类所有的正定矩阵实例。

例如，在上述例子中展示的 `Matrix([[1, 2], [-2, 1]])` 是一个非对称的实正定矩阵的例子。

然而，由于以下公式成立；

\[\text{re}(x^H A x) > 0 \iff \text{re}(x^H \frac{A + A^H}{2} x) > 0\]

我们可以通过将矩阵转换为 \(\frac{A + A^T}{2}\) 或 \(\frac{A + A^H}{2}\)（这总是保证是实对称或复厄米）来分类所有正定矩阵，可以将大部分研究推迟到对称或厄米正定矩阵。

但是对于 Cholesky 分解的存在性是一个不同的问题。因为即使非对称或非厄米矩阵可能是正定的，Cholesky 或 LDL 分解也不存在，因为这些分解要求矩阵是对称或厄米的。

参考文献

[[R626](#id19)]

[https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AE%9A%E4%B9%89#%E8%87%AA%E5%B7%B1%E5%80%BC](https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AE%9A%E4%B9%89#%E8%87%AA%E5%B7%B1%E5%80%BC)

[[R627](#id20)]

[https://mathworld.wolfram.com/PositiveDefiniteMatrix.html](https://mathworld.wolfram.com/PositiveDefiniteMatrix.html)

[[R628](#id21)]

Johnson, C. R. “Positive Definite Matrices.” Amer. Math. Monthly 77, 259-264 1970.

```py
property is_positive_semidefinite
```

发现矩阵的定性。

解释

一个实方阵 \(A\) 是：

+   如果对所有非零实向量 \(x\)，有 \(x^T A x > 0\)，则 \(A\) 是正定矩阵。

+   如果对所有非零实向量 \(x\)，有 \(x^T A x \geq 0\)，则 \(A\) 是正半定矩阵。

+   对于所有非零实向量 \( x \)，如果 \( x^T A x < 0 \)，则矩阵 \( A \) 是负定的。

+   对于所有非零实向量 \( x \)，如果 \( x^T A x \leq 0 \)，则矩阵是负半定的。

+   如果存在非零实向量 \( x, y \)，使得 \( x^T A x > 0 > y^T A y \)，则矩阵是不定的。

一个复方阵 \( A \) 是：

+   对于所有非零复向量 \( x \)，如果 \(\text{re}(x^H A x) > 0\)，则矩阵是正定的。

+   对于所有非零复向量 \( x \)，如果 \(\text{re}(x^H A x) \geq 0\)，则矩阵是正半定的。

+   对于所有非零复向量 \( x \)，如果 \(\text{re}(x^H A x) < 0\)，则矩阵是负定的。

+   对于所有非零复向量 \( x \)，如果 \(\text{re}(x^H A x) \leq 0\)，则矩阵是负半定的。

+   如果存在非零复向量 \( x, y \)，使得 \(\text{re}(x^H A x) > 0 > \text{re}(y^H A y)\)，则矩阵是不定的。

矩阵不需要对称或厄米才能是正定的。

+   对于实非对称矩阵 \( A \)，如果且仅如果 \(\frac{A + A^T}{2}\) 是正定的，它才是正定的。

+   对于复非厄米矩阵，如果且仅如果 \(\frac{A + A^H}{2}\) 是正定的，那么它是正定的。

并且这种扩展可以适用于上述所有定义。

然而，对于复杂情况，你可以将 \(\text{re}(x^H A x) > 0\) 的定义限制为 \( x^H A x > 0 \)，并要求矩阵是厄米的。但我们不在计算中呈现这个限制，因为你可以独立检查 `M.is_hermitian`，并使用相同的过程。

例子

对称正定矩阵的一个例子：

```py
>>> from sympy import Matrix, symbols
>>> from sympy.plotting import plot3d
>>> a, b = symbols('a b')
>>> x = Matrix([a, b]) 
```

```py
>>> A = Matrix([[1, 0], [0, 1]])
>>> A.is_positive_definite
True
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/a54e5f627e2fbeb748a3b6654ee84418/matrices-21.png), [`hires.png`](../../_downloads/dbe9baa7d9333de30fb4cea03b67ec3d/matrices-21.hires.png), [`pdf`](../../_downloads/81a780d815116a5eb737d2d484c44444/matrices-21.pdf))

![../../_images/matrices-21.png](../Images/ea638cc2f8cc1baa48ca62fd12aa13ba.png)

对称正半定矩阵的一个例子：

```py
>>> A = Matrix([[1, -1], [-1, 1]])
>>> A.is_positive_definite
False
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/a9eea951634fc73dd49d645042a057b8/matrices-22.png), [`hires.png`](../../_downloads/aa5c0855ea65d398b77ff5e7a3e00ed3/matrices-22.hires.png), [`pdf`](../../_downloads/2608cc95ac952e335ca0ce8cea458c1b/matrices-22.pdf))

![../../_images/matrices-22.png](../Images/aff0a4a98884800ef8d2b11ceb564495.png)

对称负定矩阵的一个例子：

```py
>>> A = Matrix([[-1, 0], [0, -1]])
>>> A.is_negative_definite
True
>>> A.is_negative_semidefinite
True
>>> A.is_indefinite
False 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/a2678f0a9d385fd10516366388c9905c/matrices-23.png), [`hires.png`](../../_downloads/c51edc0a53a63ae2c958e1c0f4e1d442/matrices-23.hires.png), [`pdf`](../../_downloads/eb990a3106294a2a2f898aea0b429ab7/matrices-23.pdf))

![../../_images/matrices-23.png](../Images/a2e58072329e79632c886ffb77d128ae.png)

对称不定矩阵的一个例子：

```py
>>> A = Matrix([[1, 2], [2, -1]])
>>> A.is_indefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/13c22e4deb4a471b56ed749423dc83e1/matrices-24.png), [`hires.png`](../../_downloads/4b5e4b16bd34ce73ca3612c694f2a681/matrices-24.hires.png), [`pdf`](../../_downloads/16c046e4f150f3aca5fb6bd438b952ce/matrices-24.pdf))

![../../_images/matrices-24.png](../Images/e621f10a0ccbac1b5a42c926d26b68c9.png)

一个非对称的正定矩阵的例子。

```py
>>> A = Matrix([[1, 2], [-2, 1]])
>>> A.is_positive_definite
True
>>> A.is_positive_semidefinite
True 
```

```py
>>> p = plot3d((x.T*A*x)[0, 0], (a, -1, 1), (b, -1, 1)) 
```

([`png`](../../_downloads/6646c86340831efe70e679a2146a3502/matrices-25.png), [`hires.png`](../../_downloads/50aad3e85d81cacfd247df6c24f46bdd/matrices-25.hires.png), [`pdf`](../../_downloads/16f8dba9abaa041f16c4636d6e41a0ac/matrices-25.pdf))

![../../_images/matrices-25.png](../Images/82d5a5d9d3cd69e45727541b041ba778.png)

注意事项

尽管有些人将正定矩阵的定义仅限于对称或埃尔米特矩阵，这种限制是不正确的，因为它不能从定义\(x^T A x > 0\)或\(\text{re}(x^H A x) > 0\)对所有正定矩阵的实例进行分类。

例如，上述示例中呈现的`Matrix([[1, 2], [-2, 1]])`是一个非对称的实正定矩阵的示例。

然而，因为以下公式成立；

\[\text{re}(x^H A x) > 0 \iff \text{re}(x^H \frac{A + A^H}{2} x) > 0\]

我们可以通过将矩阵转换为\(\frac{A + A^T}{2}\)或\(\frac{A + A^H}{2}\)（保证始终为实对称或复共轭埃尔米特）来分类所有可能或不可能为对称或埃尔米特正定矩阵，并且我们可以将大部分研究推迟到对称或埃尔米特正定矩阵。

但是，对于乔列斯基分解的存在性，这是一个不同的问题。因为即使非对称或非埃尔米特矩阵可能是正定的，乔列斯基或LDL分解也不存在，因为这些分解需要矩阵是对称或埃尔米特的。

参考文献

[[R629](#id22)]

[https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues](https://en.wikipedia.org/wiki/Definiteness_of_a_matrix#Eigenvalues)

[[R630](#id23)]

[https://mathworld.wolfram.com/PositiveDefiniteMatrix.html](https://mathworld.wolfram.com/PositiveDefiniteMatrix.html)

[[R631](#id24)]

Johnson, C. R. “Positive Definite Matrices.” Amer. Math. Monthly 77, 259-264 1970.

```py
property is_square
```

检查矩阵是否为方阵。

如果行数等于列数，则矩阵是方阵。根据定义，空矩阵是方阵，因为行数和列数都为零。

示例

```py
>>> from sympy import Matrix
>>> a = Matrix([[1, 2, 3], [4, 5, 6]])
>>> b = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> c = Matrix([])
>>> a.is_square
False
>>> b.is_square
True
>>> c.is_square
True 
```

```py
property is_strongly_diagonally_dominant
```

测试矩阵是否在行上强对角占优。

解释

若\(A\)是一个\(n, n\)矩阵，则在行上强对角占优。

\[\left|A_{i, i}\right| > \sum_{j = 0, j \neq i}^{n-1} \left|A_{i, j}\right| \quad {\text{for all }} i \in \{ 0, ..., n-1 \}\]

示例

```py
>>> from sympy import Matrix
>>> A = Matrix([[3, -2, 1], [1, -3, 2], [-1, 2, 4]])
>>> A.is_strongly_diagonally_dominant
False 
```

```py
>>> A = Matrix([[-2, 2, 1], [1, 3, 2], [1, -2, 0]])
>>> A.is_strongly_diagonally_dominant
False 
```

```py
>>> A = Matrix([[-4, 2, 1], [1, 6, 2], [1, -2, 5]])
>>> A.is_strongly_diagonally_dominant
True 
```

注意事项

如果要测试矩阵是否列对角占优，则可以在转置矩阵后应用该测试。

```py
is_symbolic()
```

检查是否有任何元素包含符号。

示例

```py
>>> from sympy import Matrix
>>> from sympy.abc import x, y
>>> M = Matrix([[x, y], [1, 0]])
>>> M.is_symbolic()
True 
```

```py
is_symmetric(simplify=True)
```

检查矩阵是否对称矩阵，即方阵且等于其转置。

默认情况下，在测试对称性之前会进行简化。可以使用'simplify=False'跳过这一步；虽然可以加快速度，但可能会导致假阴性。

示例

```py
>>> from sympy import Matrix
>>> m = Matrix(2, 2, [0, 1, 1, 2])
>>> m
Matrix([
[0, 1],
[1, 2]])
>>> m.is_symmetric()
True 
```

```py
>>> m = Matrix(2, 2, [0, 1, 2, 0])
>>> m
Matrix([
[0, 1],
[2, 0]])
>>> m.is_symmetric()
False 
```

```py
>>> m = Matrix(2, 3, [0, 0, 0, 0, 0, 0])
>>> m
Matrix([
[0, 0, 0],
[0, 0, 0]])
>>> m.is_symmetric()
False 
```

```py
>>> from sympy.abc import x, y
>>> m = Matrix(3, 3, [1, x**2 + 2*x + 1, y, (x + 1)**2, 2, 0, y, 0, 3])
>>> m
Matrix([
[         1, x**2 + 2*x + 1, y],
[(x + 1)**2,              2, 0],
[         y,              0, 3]])
>>> m.is_symmetric()
True 
```

如果矩阵已经简化，则可以通过使用'simplify=False'来加速is_symmetric()测试。

```py
>>> bool(m.is_symmetric(simplify=False))
False
>>> m1 = m.expand()
>>> m1.is_symmetric(simplify=False)
True 
```

```py
property is_upper
```

检查矩阵是否为上三角矩阵。 即使矩阵不是方阵，也可以返回 True。

示例

```py
>>> from sympy import Matrix
>>> m = Matrix(2, 2, [1, 0, 0, 1])
>>> m
Matrix([
[1, 0],
[0, 1]])
>>> m.is_upper
True 
```

```py
>>> m = Matrix(4, 3, [5, 1, 9, 0, 4, 6, 0, 0, 5, 0, 0, 0])
>>> m
Matrix([
[5, 1, 9],
[0, 4, 6],
[0, 0, 5],
[0, 0, 0]])
>>> m.is_upper
True 
```

```py
>>> m = Matrix(2, 3, [4, 2, 5, 6, 1, 1])
>>> m
Matrix([
[4, 2, 5],
[6, 1, 1]])
>>> m.is_upper
False 
```

另请参阅

[`is_lower`](#sympy.matrices.matrixbase.MatrixBase.is_lower "sympy.matrices.matrixbase.MatrixBase.is_lower"), [`is_diagonal`](#sympy.matrices.matrixbase.MatrixBase.is_diagonal "sympy.matrices.matrixbase.MatrixBase.is_diagonal"), [`is_upper_hessenberg`](#sympy.matrices.matrixbase.MatrixBase.is_upper_hessenberg "sympy.matrices.matrixbase.MatrixBase.is_upper_hessenberg")

```py
property is_upper_hessenberg
```

检查矩阵是否为上 Hessenberg 形式。

上 Hessenberg 矩阵在第一个次对角线以下有零条目。

示例

```py
>>> from sympy import Matrix
>>> a = Matrix([[1, 4, 2, 3], [3, 4, 1, 7], [0, 2, 3, 4], [0, 0, 1, 3]])
>>> a
Matrix([
[1, 4, 2, 3],
[3, 4, 1, 7],
[0, 2, 3, 4],
[0, 0, 1, 3]])
>>> a.is_upper_hessenberg
True 
```

另请参阅

[`is_lower_hessenberg`](#sympy.matrices.matrixbase.MatrixBase.is_lower_hessenberg "sympy.matrices.matrixbase.MatrixBase.is_lower_hessenberg"), [`is_upper`](#sympy.matrices.matrixbase.MatrixBase.is_upper "sympy.matrices.matrixbase.MatrixBase.is_upper")

```py
property is_weakly_diagonally_dominant
```

检验矩阵是否行弱对角线占优。

说明

一个 \(n, n\) 矩阵 \(A\) 如果满足行弱对角线占优条件，则为行弱对角线占优。

\[\left|A_{i, i}\right| \ge \sum_{j = 0, j \neq i}^{n-1} \left|A_{i, j}\right| \quad {\text{对于所有 }} i \in \{ 0, ..., n-1 \}\]

示例

```py
>>> from sympy import Matrix
>>> A = Matrix([[3, -2, 1], [1, -3, 2], [-1, 2, 4]])
>>> A.is_weakly_diagonally_dominant
True 
```

```py
>>> A = Matrix([[-2, 2, 1], [1, 3, 2], [1, -2, 0]])
>>> A.is_weakly_diagonally_dominant
False 
```

```py
>>> A = Matrix([[-4, 2, 1], [1, 6, 2], [1, -2, 5]])
>>> A.is_weakly_diagonally_dominant
True 
```

注意

如果您想测试一个矩阵是否是列对角占优的，可以在转置矩阵后应用测试。

```py
property is_zero_matrix
```

检查矩阵是否为零矩阵。

如果每个元素都是零，则矩阵为零。 即使矩阵不是方阵，也可以认为是零矩阵。 空矩阵由虚假真理原则为零。 对于可能是零的矩阵（例如包含符号的矩阵），这将为 None

示例

```py
>>> from sympy import Matrix, zeros
>>> from sympy.abc import x
>>> a = Matrix([[0, 0], [0, 0]])
>>> b = zeros(3, 4)
>>> c = Matrix([[0, 1], [0, 0]])
>>> d = Matrix([])
>>> e = Matrix([[x, 0], [0, 0]])
>>> a.is_zero_matrix
True
>>> b.is_zero_matrix
True
>>> c.is_zero_matrix
False
>>> d.is_zero_matrix
True
>>> e.is_zero_matrix 
```

```py
iter_items()
```

遍历非零项的索引和值。

示例

```py
>>> from sympy import Matrix
>>> m = Matrix([[0, 1], [2, 3]])
>>> list(m.iter_items())
[((0, 1), 1), ((1, 0), 2), ((1, 1), 3)] 
```

另请参阅

[`iter_values`](#sympy.matrices.matrixbase.MatrixBase.iter_values "sympy.matrices.matrixbase.MatrixBase.iter_values"), [`todok`](#sympy.matrices.matrixbase.MatrixBase.todok "sympy.matrices.matrixbase.MatrixBase.todok")

```py
iter_values()
```

遍历自身非零值。

示例

```py
>>> from sympy import Matrix
>>> m = Matrix([[0, 1], [2, 3]])
>>> list(m.iter_values())
[1, 2, 3] 
```

另请参阅

[`values`](#sympy.matrices.matrixbase.MatrixBase.values "sympy.matrices.matrixbase.MatrixBase.values")

```py
jacobian(X)
```

计算雅可比矩阵（向量值函数的导数）。

参数：

**``self``**：表示函数 f_i(x_1, ..., x_n) 的表达式向量。

**X**：按顺序排列的 x_i 集合，可以是列表或矩阵

**``self`` 和 X 可以以任意顺序为行或列矩阵**

**（即，jacobian() 应始终可用）。**

示例

```py
>>> from sympy import sin, cos, Matrix
>>> from sympy.abc import rho, phi
>>> X = Matrix([rho*cos(phi), rho*sin(phi), rho**2])
>>> Y = Matrix([rho, phi])
>>> X.jacobian(Y)
Matrix([
[cos(phi), -rho*sin(phi)],
[sin(phi),  rho*cos(phi)],
[   2*rho,             0]])
>>> X = Matrix([rho*cos(phi), rho*sin(phi)])
>>> X.jacobian(Y)
Matrix([
[cos(phi), -rho*sin(phi)],
[sin(phi),  rho*cos(phi)]]) 
```

另请参阅

[`hessian`](#sympy.matrices.dense.hessian "sympy.matrices.dense.hessian"), [`wronskian`](#sympy.matrices.dense.wronskian "sympy.matrices.dense.wronskian")

```py
classmethod jordan_block(size=None, eigenvalue=None, *, band='upper', **kwargs)
```

返回一个 Jordan 块

参数：

**大小**：整数，可选

> 指定 Jordan 块矩阵的形状。

**特征值**：数或符号

> 指定矩阵的主对角线的值。
> 
> 注意
> 
> 关键字 `eigenval` 也被指定为该关键字的别名，但不建议使用。
> 
> 我们可能在后续版本中弃用该别名。

**带宽**：‘上’或‘下’，可选

> 指定非对角线上的位置以放置 \(1\)。

**cls** : Matrix, optional

> 指定输出形式的矩阵类。
> 
> 如果未指定，则将在执行方法的类类型返回。

返回：

矩阵

> 约旦块矩阵。

引发：

**ValueError**：数值错误

> 如果矩阵大小规格给定的参数不足，或者没有给出特征值。

示例

创建默认的约旦块：

```py
>>> from sympy import Matrix
>>> from sympy.abc import x
>>> Matrix.jordan_block(4, x)
Matrix([
[x, 1, 0, 0],
[0, x, 1, 0],
[0, 0, x, 1],
[0, 0, 0, x]]) 
```

创建具有关键字参数的备选约旦块矩阵，其中 \(1\) 在对角线以下：

```py
>>> Matrix.jordan_block(4, x, band='lower')
Matrix([
[x, 0, 0, 0],
[1, x, 0, 0],
[0, 1, x, 0],
[0, 0, 1, x]]) 
```

使用关键字参数创建约旦块矩阵

```py
>>> Matrix.jordan_block(size=4, eigenvalue=x)
Matrix([
[x, 1, 0, 0],
[0, x, 1, 0],
[0, 0, x, 1],
[0, 0, 0, x]]) 
```

参考文献

[[R632](#id25)]

[https://en.wikipedia.org/wiki/Jordan_matrix](https://en.wikipedia.org/wiki/Jordan_matrix)

```py
jordan_form(calc_transform=True, **kwargs)
```

返回 \((P, J)\)，其中 \(J\) 是约旦块矩阵，\(P\) 是使得 \(M = P J P^{-1}\) 的矩阵。

参数：

**calc_transform** : bool

> 如果为`False`，则仅返回 \(J\)。

**chop** : bool

> 在计算特征值和特征向量时，所有矩阵都转换为精确类型。因此，可能存在近似误差。如果 `chop==True`，则这些错误将被截断。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix([[ 6,  5, -2, -3], [-3, -1,  3,  3], [ 2,  1, -2, -3], [-1,  1,  5,  5]])
>>> P, J = M.jordan_form()
>>> J
Matrix([
[2, 1, 0, 0],
[0, 2, 0, 0],
[0, 0, 2, 1],
[0, 0, 0, 2]]) 
```

另见

[`jordan_block`](#sympy.matrices.matrixbase.MatrixBase.jordan_block "sympy.matrices.matrixbase.MatrixBase.jordan_block")

```py
key2bounds(keys)
```

将具有潜在混合键类型（整数和切片）的键转换为范围的元组，并在任何索引超出`self`范围时引发错误。

另见

[`key2ij`](#sympy.matrices.matrixbase.MatrixBase.key2ij "sympy.matrices.matrixbase.MatrixBase.key2ij")

```py
key2ij(key)
```

将键转换为规范形式，将整数或可索引项转换为`self`范围内的有效整数，或不改变切片。

另见

[`key2bounds`](#sympy.matrices.matrixbase.MatrixBase.key2bounds "sympy.matrices.matrixbase.MatrixBase.key2bounds")

```py
left_eigenvects(**flags)
```

返回左特征向量和特征值。

此函数返回左特征向量的三元组列表（特征值，重数，基）。选项与 eigenvects() 相同，即 `**flags` 参数直接传递给 eigenvects()。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix([[0, 1, 1], [1, 0, 0], [1, 1, 1]])
>>> M.eigenvects()
[(-1, 1, [Matrix([
[-1],
[ 1],
[ 0]])]), (0, 1, [Matrix([
[ 0],
[-1],
[ 1]])]), (2, 1, [Matrix([
[2/3],
[1/3],
[  1]])])]
>>> M.left_eigenvects()
[(-1, 1, [Matrix([[-2, 1, 1]])]), (0, 1, [Matrix([[-1, -1, 1]])]), (2,
1, [Matrix([[1, 1, 1]])])] 
```

```py
limit(*args)
```

计算矩阵中每个元素的极限。`args` 将传递给 `limit` 函数。

示例

```py
>>> from sympy import Matrix
>>> from sympy.abc import x, y
>>> M = Matrix([[x, y], [1, 0]])
>>> M.limit(x, 2)
Matrix([
[2, y],
[1, 0]]) 
```

另见

[`integrate`](#sympy.matrices.matrixbase.MatrixBase.integrate "sympy.matrices.matrixbase.MatrixBase.integrate"), [`diff`](#sympy.matrices.matrixbase.MatrixBase.diff "sympy.matrices.matrixbase.MatrixBase.diff")

```py
log(simplify=<function cancel>)
```

返回方阵的对数。

参数：

**simplify** : function, bool

> 用于简化结果的函数。
> 
> 默认为`cancel`，对于减少符号矩阵的取倒和求逆的表达式增长有效。

示例

```py
>>> from sympy import S, Matrix 
```

正定矩阵的示例：

```py
>>> m = Matrix([[1, 1], [0, 1]])
>>> m.log()
Matrix([
[0, 1],
[0, 0]]) 
```

```py
>>> m = Matrix([[S(5)/4, S(3)/4], [S(3)/4, S(5)/4]])
>>> m.log()
Matrix([
[     0, log(2)],
[log(2),      0]]) 
```

非正定矩阵示例：

```py
>>> m = Matrix([[S(3)/4, S(5)/4], [S(5)/4, S(3)/4]])
>>> m.log()
Matrix([
[         I*pi/2, log(2) - I*pi/2],
[log(2) - I*pi/2,          I*pi/2]]) 
```

```py
>>> m = Matrix(
...     [[0, 0, 0, 1],
...      [0, 0, 1, 0],
...      [0, 1, 0, 0],
...      [1, 0, 0, 0]])
>>> m.log()
Matrix([
[ I*pi/2,       0,       0, -I*pi/2],
[      0,  I*pi/2, -I*pi/2,       0],
[      0, -I*pi/2,  I*pi/2,       0],
[-I*pi/2,       0,       0,  I*pi/2]]) 
```

```py
lower_triangular(k=0)
```

返回矩阵的第 k 条对角线及其下元素。如果未指定 k，则简单返回矩阵的下三角部分。

示例

```py
>>> from sympy import ones
>>> A = ones(4)
>>> A.lower_triangular()
Matrix([
[1, 0, 0, 0],
[1, 1, 0, 0],
[1, 1, 1, 0],
[1, 1, 1, 1]]) 
```

```py
>>> A.lower_triangular(-2)
Matrix([
[0, 0, 0, 0],
[0, 0, 0, 0],
[1, 0, 0, 0],
[1, 1, 0, 0]]) 
```

```py
>>> A.lower_triangular(1)
Matrix([
[1, 1, 0, 0],
[1, 1, 1, 0],
[1, 1, 1, 1],
[1, 1, 1, 1]]) 
```

```py
lower_triangular_solve(rhs)
```

解决 `Ax = B`，其中 A 是下三角矩阵。

另见

[`upper_triangular_solve`](#sympy.matrices.matrixbase.MatrixBase.upper_triangular_solve "sympy.matrices.matrixbase.MatrixBase.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve "sympy.matrices.matrixbase.MatrixBase.cramer_solve")

```py
minor(i, j, method='berkowitz')
```

返回矩阵M的(i,j)次小项。即返回通过从M中删除第i行和第j列而获得的矩阵的行列式。

参数：

**i, j** : 整数

> 获取子矩阵时排除的行和列。

**method** : 字符串，可选

> 用于查找子矩阵行列式的方法，可以是“bareiss”、“berkowitz”、“bird”、“laplace”或“lu”。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> M.minor(1, 1)
-12 
```

另见

[`minor_submatrix`](#sympy.matrices.matrixbase.MatrixBase.minor_submatrix "sympy.matrices.matrixbase.MatrixBase.minor_submatrix"), [`cofactor`](#sympy.matrices.matrixbase.MatrixBase.cofactor "sympy.matrices.matrixbase.MatrixBase.cofactor"), [`det`](#sympy.matrices.matrixbase.MatrixBase.det "sympy.matrices.matrixbase.MatrixBase.det")

```py
minor_submatrix(i, j)
```

返回通过从M中删除第i行和第j列获得的子矩阵（支持Pythonic负索引）。

参数：

**i, j** : 整数

> 获取子矩阵时排除的行和列。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> M.minor_submatrix(1, 1)
Matrix([
[1, 3],
[7, 9]]) 
```

另见

[`minor`](#sympy.matrices.matrixbase.MatrixBase.minor "sympy.matrices.matrixbase.MatrixBase.minor"), [`cofactor`](#sympy.matrices.matrixbase.MatrixBase.cofactor "sympy.matrices.matrixbase.MatrixBase.cofactor")

```py
multiply(other, dotprodsimp=None)
```

与__mul__()相同，但具有可选的简化。

参数：

**dotprodsimp** : 布尔值，可选

> 指定是否在矩阵乘法过程中使用中间项的代数化简来控制表达式膨胀，从而加快计算速度。默认为关闭。

```py
multiply_elementwise(other)
```

返回矩阵A和B的Hadamard乘积（逐元素乘积）。

示例

```py
>>> from sympy import Matrix
>>> A = Matrix([[0, 1, 2], [3, 4, 5]])
>>> B = Matrix([[1, 10, 100], [100, 10, 1]])
>>> A.multiply_elementwise(B)
Matrix([
[  0, 10, 200],
[300, 40,   5]]) 
```

另见

[`sympy.matrices.matrixbase.MatrixBase.cross`](#sympy.matrices.matrixbase.MatrixBase.cross "sympy.matrices.matrixbase.MatrixBase.cross"), [`sympy.matrices.matrixbase.MatrixBase.dot`](#sympy.matrices.matrixbase.MatrixBase.dot "sympy.matrices.matrixbase.MatrixBase.dot"), [`multiply`](#sympy.matrices.matrixbase.MatrixBase.multiply "sympy.matrices.matrixbase.MatrixBase.multiply")

```py
n(*args, **kwargs)
```

对self的每个元素应用evalf()。

```py
norm(ord=None)
```

返回矩阵或向量的范数。

在最简单的情况下，这是向量的几何大小。其他规范可以通过ord参数指定。

| ord | 矩阵的规范 | 向量的规范 |
| --- | --- | --- |
| None | 弗罗贝尼乌斯范数 | 2-范数 |
| ‘fro’ | 弗罗贝尼乌斯范数 |

+   不存在

|

| inf | 最大行和 | max(abs(x)) |
| --- | --- | --- |
| -inf | – | min(abs(x)) |
| 1 | 最大列和 | 如下 |
| -1 | – | 如下 |
| 2 | 2-范数（最大奇异值） | 如下 |
| -2 | 最小奇异值 | 如下 |
| other |

+   不存在

| sum(abs(x)**ord)**(1./ord) |
| --- |

示例

```py
>>> from sympy import Matrix, Symbol, trigsimp, cos, sin, oo
>>> x = Symbol('x', real=True)
>>> v = Matrix([cos(x), sin(x)])
>>> trigsimp( v.norm() )
1
>>> v.norm(10)
(sin(x)**10 + cos(x)**10)**(1/10)
>>> A = Matrix([[1, 1], [1, 1]])
>>> A.norm(1) # maximum sum of absolute values of A is 2
2
>>> A.norm(2) # Spectral norm (max of |Ax|/|x| under 2-vector-norm)
2
>>> A.norm(-2) # Inverse spectral norm (smallest singular value)
0
>>> A.norm() # Frobenius Norm
2
>>> A.norm(oo) # Infinity Norm
2
>>> Matrix([1, -2]).norm(oo)
2
>>> Matrix([-1, 2]).norm(-oo)
1 
```

另见

[`normalized`](#sympy.matrices.matrixbase.MatrixBase.normalized "sympy.matrices.matrixbase.MatrixBase.normalized")

```py
normalized(iszerofunc=<function _iszero>)
```

返回`self`的归一化版本。

参数：

**iszerofunc** : 函数，可选

> 一个函数，用于确定`self`是否为零向量。默认的`_iszero`测试每个元素是否完全为零。

返回：

矩阵

> `self`的归一化向量形式。它与单位向量具有相同长度。然而，对于模为0的向量将返回零向量。

引发：

**ShapeError**

> 如果矩阵不是向量形式。

另见

[`norm`](#sympy.matrices.matrixbase.MatrixBase.norm "sympy.matrices.matrixbase.MatrixBase.norm")

```py
nullspace(simplify=False, iszerofunc=<function _iszero>)
```

返回矩阵的零空间生成的向量列表（Matrix对象）。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])
>>> M
Matrix([
[ 1,  3, 0],
[-2, -6, 0],
[ 3,  9, 6]])
>>> M.nullspace()
[Matrix([
[-3],
[ 1],
[ 0]])] 
```

另见

[`columnspace`](#sympy.matrices.matrixbase.MatrixBase.columnspace "sympy.matrices.matrixbase.MatrixBase.columnspace"), [`rowspace`](#sympy.matrices.matrixbase.MatrixBase.rowspace "sympy.matrices.matrixbase.MatrixBase.rowspace")

```py
classmethod ones(rows, cols=None, **kwargs)
```

返回一个全为1的矩阵。

参数：

**rows** : 矩阵的行

**cols** : 矩阵的列（如果为None，则cols=rows）

关键字参数

cls：返回矩阵的类

```py
classmethod orthogonalize(*vecs, **kwargs)
```

对提供的`vecs`应用Gram-Schmidt正交化过程。

参数：

**vecs**

> 要正交化的向量

**normalize** : bool

> 如果为`True`，则返回标准正交基。

**rankcheck** : bool

> 如果`True`，则在遇到线性相关向量时计算不会停止。
> 
> 如果`False`，则在发现任何零或线性相关向量时会引发`ValueError`。

返回：

列表

> 正交（或标准正交）基向量列表。

示例

```py
>>> from sympy import I, Matrix
>>> v = [Matrix([1, I]), Matrix([1, -I])]
>>> Matrix.orthogonalize(*v)
[Matrix([
[1],
[I]]), Matrix([
[ 1],
[-I]])] 
```

另见

[`MatrixBase.QR分解`](#sympy.matrices.matrixbase.MatrixBase.QRdecomposition "sympy.matrices.matrixbase.MatrixBase.QRdecomposition")

参考文献

[[R633](#id26)]

[https://zh.wikipedia.org/wiki/格拉姆-施密特正交化过程](https://zh.wikipedia.org/wiki/格拉姆-施密特正交化过程)

```py
per()
```

返回矩阵的永久值。与行列式不同，永久值对于方阵和非方阵都有定义。

对于一个m x n矩阵，其中m小于等于n，它被定义为大小不超过m的排列s上[1, 2, ... n]的乘积的和，从i = 1到m的M[i, s[i]]。取转置不会影响永久值。

对于方阵而言，这与行列式的置换定义相同，但不考虑置换的符号。使用此定义计算永久效率低下，因此这里使用了莱瑟公式。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
>>> M.per()
450
>>> M = Matrix([1, 5, 7])
>>> M.per()
13 
```

参考

[[R634](#id27)]

弗兰克·本教授的笔记：[https://math.berkeley.edu/~bernd/ban275.pdf](https://math.berkeley.edu/~bernd/ban275.pdf)

[[R635](#id28)]

永久的维基百科文章：[https://en.wikipedia.org/wiki/Permanent_%28mathematics%29](https://en.wikipedia.org/wiki/Permanent_%28mathematics%29)

[[R636](#id29)]

[https://reference.wolfram.com/language/ref/Permanent.html](https://reference.wolfram.com/language/ref/Permanent.html)

[[R637](#id30)]

矩阵的永久：[https://arxiv.org/pdf/0904.3251.pdf](https://arxiv.org/pdf/0904.3251.pdf)

```py
permute(perm, orientation='rows', direction='forward')
```

通过给定的交换列表置换矩阵的行或列。

参数：

**perm** : 置换、列表或列表的列表

> 置换的表示。
> 
> 如果是 `Permutation`，直接与矩阵大小有关地进行一些调整使用。
> 
> 如果指定为列表的列表（例如 `[[0, 1], [0, 2]]`），则通过应用循环积的乘积形成置换。如何应用循环积的方向在下文描述。
> 
> 如果指定为列表形式，则列表应表示一个置换的数组形式（例如 `[1, 2, 0]`），该列表会形成交换函数 \(0 \mapsto 1, 1 \mapsto 2, 2\mapsto 0\)。

**orientation** : ‘rows’, ‘cols’

> 控制标志，决定是置换行还是列。

**direction** : ‘forward’, ‘backward’

> 控制标志，决定是先从列表的起始处还是末尾处应用置换。
> 
> 例如，如果置换规范是 `[[0, 1], [0, 2]]`，
> 
> 如果标志设置为 `'forward'`，循环将形成为 \(0 \mapsto 2, 2 \mapsto 1, 1 \mapsto 0\)。
> 
> 如果标志设置为 `'backward'`，循环将形成为 \(0 \mapsto 1, 1 \mapsto 2, 2 \mapsto 0\)。
> 
> 如果参数 `perm` 不是列表的列表形式，则此标志不起作用。

示例

```py
>>> from sympy import eye
>>> M = eye(3)
>>> M.permute([[0, 1], [0, 2]], orientation='rows', direction='forward')
Matrix([
[0, 0, 1],
[1, 0, 0],
[0, 1, 0]]) 
```

```py
>>> from sympy import eye
>>> M = eye(3)
>>> M.permute([[0, 1], [0, 2]], orientation='rows', direction='backward')
Matrix([
[0, 1, 0],
[0, 0, 1],
[1, 0, 0]]) 
```

注释

如果一个双射函数 \(\sigma : \mathbb{N}_0 \rightarrow \mathbb{N}_0\) 表示置换。

如果矩阵 \(A\) 是待置换的矩阵，表示为向量的水平或垂直堆叠：

\[\begin{split}A = \begin{bmatrix} a_0 \\ a_1 \\ \vdots \\ a_{n-1} \end{bmatrix} = \begin{bmatrix} \alpha_0 & \alpha_1 & \cdots & \alpha_{n-1} \end{bmatrix}\end{split}\]

如果矩阵 \(B\) 是结果，则矩阵行的置换定义如下：

\[\begin{split}B := \begin{bmatrix} a_{\sigma(0)} \\ a_{\sigma(1)} \\ \vdots \\ a_{\sigma(n-1)} \end{bmatrix}\end{split}\]

并且矩阵列的置换定义为：

\[B := \begin{bmatrix} \alpha_{\sigma(0)} & \alpha_{\sigma(1)} & \cdots & \alpha_{\sigma(n-1)} \end{bmatrix}\]

```py
permuteBkwd(perm)
```

通过给定置换的逆置换矩阵的行。

```py
permuteFwd(perm)
```

使用给定的排列置换矩阵的行。

```py
permute_cols(swaps, direction='forward')
```

`self.permute(swaps, orientation='cols', direction=direction)`的别名

另请参阅

[`permute`](#sympy.matrices.matrixbase.MatrixBase.permute "sympy.matrices.matrixbase.MatrixBase.permute")

```py
permute_rows(swaps, direction='forward')
```

`self.permute(swaps, orientation='rows', direction=direction)`的别名

另请参阅

[`permute`](#sympy.matrices.matrixbase.MatrixBase.permute "sympy.matrices.matrixbase.MatrixBase.permute")

```py
pinv(method='RD')
```

计算矩阵的Moore-Penrose伪逆。

对于任何矩阵，Moore-Penrose伪逆都存在且唯一。如果矩阵可逆，则伪逆与逆矩阵相同。

参数：

**method**：字符串，可选

> 指定计算伪逆的方法。
> 
> 如果为`'RD'`，将使用秩分解。
> 
> 如果为`'ED'`，将使用对角化。

示例

通过秩分解计算伪逆：

```py
>>> from sympy import Matrix
>>> A = Matrix([[1, 2, 3], [4, 5, 6]])
>>> A.pinv()
Matrix([
[-17/18,  4/9],
[  -1/9,  1/9],
[ 13/18, -2/9]]) 
```

通过对角化计算伪逆：

```py
>>> B = A.pinv(method='ED')
>>> B.simplify()
>>> B
Matrix([
[-17/18,  4/9],
[  -1/9,  1/9],
[ 13/18, -2/9]]) 
```

另请参阅

[`inv`](#sympy.matrices.matrixbase.MatrixBase.inv "sympy.matrices.matrixbase.MatrixBase.inv"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve "sympy.matrices.matrixbase.MatrixBase.pinv_solve")

参考文献

[[R638](#id31)]

[https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse](https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse)

```py
pinv_solve(B, arbitrary_matrix=None)
```

使用Moore-Penrose伪逆解决`Ax = B`。

可能存在零、一或无限解。如果存在一解，则返回该解。如果存在无限解，则基于任意矩阵的值返回一个解。如果不存在解，则返回最小二乘解。

参数：

**B**：矩阵

> 要解的方程的右手边。必须具有与矩阵A相同的行数。

**arbitrary_matrix**：矩阵

> 如果系统欠定（例如A的列数多于行数），可能存在无限解，即任意矩阵。此参数可以设置为特定矩阵，用于此目的；如果设置，其形状必须与x相同，行数与矩阵A的列数相同，列数与矩阵B相同。如果设置为None，则将使用包含以`wn_m`形式的虚拟符号的适当矩阵，其中n和m分别是每个符号的行和列位置。

返回：

**x**：矩阵

> 将满足`Ax = B`的矩阵。将具有与矩阵A的列数相同的行数，并且与矩阵B具有相同的列数。

示例

```py
>>> from sympy import Matrix
>>> A = Matrix([[1, 2, 3], [4, 5, 6]])
>>> B = Matrix([7, 8])
>>> A.pinv_solve(B)
Matrix([
[ _w0_0/6 - _w1_0/3 + _w2_0/6 - 55/18],
[-_w0_0/3 + 2*_w1_0/3 - _w2_0/3 + 1/9],
[ _w0_0/6 - _w1_0/3 + _w2_0/6 + 59/18]])
>>> A.pinv_solve(B, arbitrary_matrix=Matrix([0, 0, 0]))
Matrix([
[-55/18],
[   1/9],
[ 59/18]]) 
```

注：

这可能返回精确解或最小二乘解。要确定哪种解，请检查`A * A.pinv() * B == B`。如果精确解存在，则为True；如果仅存在最小二乘解，则为False。请注意，该方程的左侧可能需要简化才能正确与右侧比较。

另请参阅

[`sympy.matrices.dense.DenseMatrix.lower_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.lower_triangular_solve "sympy.matrices.dense.DenseMatrix.lower_triangular_solve"), [`sympy.matrices.dense.DenseMatrix.upper_triangular_solve`](dense.html#sympy.matrices.dense.DenseMatrix.upper_triangular_solve "sympy.matrices.dense.DenseMatrix.upper_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv`](#sympy.matrices.matrixbase.MatrixBase.pinv "sympy.matrices.matrixbase.MatrixBase.pinv")

参考文献

[[R639](#id32)]

[https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse#Obtaining_all_solutions_of_a_linear_system](https://en.wikipedia.org/wiki/Moore-Penrose_pseudoinverse#Obtaining_all_solutions_of_a_linear_system)

```py
pow(exp, method=None)
```

返回自我**exp 标量或符号。

参数：

**方法** ：乘法，mulsimp，乔丹，卡莱

> 如果乘以，则使用递归返回指数。如果乔丹，则使用乔丹形式的指数。如果cayley，则使用Cayley-Hamilton定理进行指数计算。如果mulsimp，则使用递归与dotprodsimp进行指数计算。这指定是否在朴素矩阵幂中使用中间项代数简化以控制表达式膨胀，从而加快计算速度。如果为None，则启发式地决定使用哪种方法。

```py
print_nonzero(symb='X')
```

显示非零条目的位置，以便快速查找形状。

示例

```py
>>> from sympy import Matrix, eye
>>> m = Matrix(2, 3, lambda i, j: i*3+j)
>>> m
Matrix([
[0, 1, 2],
[3, 4, 5]])
>>> m.print_nonzero()
[ XX]
[XXX]
>>> m = eye(4)
>>> m.print_nonzero("x")
[x   ]
[ x  ]
[  x ]
[   x] 
```

```py
project(v)
```

返回 `self` 在包含 `v` 的线上的投影。

示例

```py
>>> from sympy import Matrix, S, sqrt
>>> V = Matrix([sqrt(3)/2, S.Half])
>>> x = Matrix([[1, 0]])
>>> V.project(x)
Matrix([[sqrt(3)/2, 0]])
>>> V.project(-x)
Matrix([[sqrt(3)/2, 0]]) 
```

```py
rank(iszerofunc=<function _iszero>, simplify=False)
```

返回矩阵的秩。

示例

```py
>>> from sympy import Matrix
>>> from sympy.abc import x
>>> m = Matrix([[1, 2], [x, 1 - 1/x]])
>>> m.rank()
2
>>> n = Matrix(3, 3, range(1, 10))
>>> n.rank()
2 
```

```py
rank_decomposition(iszerofunc=<function _iszero>, simplify=False)
```

返回一对矩阵（\(C\)，\(F\)），它们具有相同的秩，使得 \(A = C F\)。

参数：

**iszerofunc** ：函数，可选

> 用于检测元素是否可以作为枢轴的函数。默认情况下使用`lambda x: x.is_zero`。

**简化** ：布尔或函数，可选

> 用于在寻找枢轴时简化元素的函数。默认情况下使用SymPy的`simplify`。

返回：

**(C, F)** ：矩阵

> \(C\) 和 \(F\) 是秩与 \(A\) 相同的全秩矩阵，它们的乘积给出 \(A\)。
> 
> 有关附加数学细节，请参见注释。

示例

```py
>>> from sympy import Matrix
>>> A = Matrix([
...     [1, 3, 1, 4],
...     [2, 7, 3, 9],
...     [1, 5, 3, 1],
...     [1, 2, 0, 8]
... ])
>>> C, F = A.rank_decomposition()
>>> C
Matrix([
[1, 3, 4],
[2, 7, 9],
[1, 5, 1],
[1, 2, 8]])
>>> F
Matrix([
[1, 0, -2, 0],
[0, 1,  1, 0],
[0, 0,  0, 1]])
>>> C * F == A
True 
```

注释

获得 \(F\)，\(A\) 的RREF，相当于创建一个产品

\[E_n E_{n-1} ... E_1 A = F\]

其中 \(E_n, E_{n-1}, \dots, E_1\) 是消元矩阵或等效于每个行约简步骤的排列矩阵。

相同消元矩阵的逆矩阵给出 \(C\)：

\[C = \left(E_n E_{n-1} \dots E_1\right)^{-1}\]

不需要实际计算逆矩阵：\(C\)的列与\(F\)的主元列的列索引相同。

另见

[`sympy.matrices.matrixbase.MatrixBase.rref`](#sympy.matrices.matrixbase.MatrixBase.rref "sympy.matrices.matrixbase.MatrixBase.rref")

参考文献

[[R640](#id33)]

[https://en.wikipedia.org/wiki/Rank_factorization](https://en.wikipedia.org/wiki/Rank_factorization)

[[R641](#id34)]

Piziak, R.; Odell, P. L. (1999年6月1日). “矩阵的满秩分解”. 数学杂志. 72 (3): 193\. doi:10.2307/2690882

```py
refine(assumptions=True)
```

对矩阵的每个元素应用精化。

示例

```py
>>> from sympy import Symbol, Matrix, Abs, sqrt, Q
>>> x = Symbol('x')
>>> Matrix([[Abs(x)**2, sqrt(x**2)],[sqrt(x**2), Abs(x)**2]])
Matrix([
[ Abs(x)**2, sqrt(x**2)],
[sqrt(x**2),  Abs(x)**2]])
>>> _.refine(Q.real(x))
Matrix([
[  x**2, Abs(x)],
[Abs(x),   x**2]]) 
```

```py
replace(F, G, map=False, simultaneous=True, exact=None)
```

用函数G替换矩阵条目中的函数F。

示例

```py
>>> from sympy import symbols, Function, Matrix
>>> F, G = symbols('F, G', cls=Function)
>>> M = Matrix(2, 2, lambda i, j: F(i+j)) ; M
Matrix([
[F(0), F(1)],
[F(1), F(2)]])
>>> N = M.replace(F,G)
>>> N
Matrix([
[G(0), G(1)],
[G(1), G(2)]]) 
```

```py
reshape(rows, cols)
```

重塑矩阵。元素总数必须保持不变。

示例

```py
>>> from sympy import Matrix
>>> m = Matrix(2, 3, lambda i, j: 1)
>>> m
Matrix([
[1, 1, 1],
[1, 1, 1]])
>>> m.reshape(1, 6)
Matrix([[1, 1, 1, 1, 1, 1]])
>>> m.reshape(3, 2)
Matrix([
[1, 1],
[1, 1],
[1, 1]]) 
```

```py
rmultiply(other, dotprodsimp=None)
```

与__rmul__()相同，但具有可选的简化。

参数：

**dotprodsimp**：bool，可选

> 指定在矩阵乘法期间是否使用中间项代数化简来控制表达式膨胀，从而加快计算速度。默认关闭。

```py
rot90(k=1)
```

将矩阵逆时针旋转90度

参数：

**k**：整数

> 指定矩阵顺时针旋转的次数（正数时为顺时针，负数时为逆时针）。

示例

```py
>>> from sympy import Matrix, symbols
>>> A = Matrix(2, 2, symbols('a:d'))
>>> A
Matrix([
[a, b],
[c, d]]) 
```

将矩阵顺时针旋转一次：

```py
>>> A.rot90(1)
Matrix([
[c, a],
[d, b]]) 
```

将矩阵逆时针旋转两次：

```py
>>> A.rot90(-2)
Matrix([
[d, c],
[b, a]]) 
```

```py
row(i)
```

行选择器。

示例

```py
>>> from sympy import eye
>>> eye(2).row(0)
Matrix([[1, 0]]) 
```

另见

[`col`](#sympy.matrices.matrixbase.MatrixBase.col "sympy.matrices.matrixbase.MatrixBase.col"), [`row_del`](#sympy.matrices.matrixbase.MatrixBase.row_del "sympy.matrices.matrixbase.MatrixBase.row_del"), [`row_join`](#sympy.matrices.matrixbase.MatrixBase.row_join "sympy.matrices.matrixbase.MatrixBase.row_join"), [`row_insert`](#sympy.matrices.matrixbase.MatrixBase.row_insert "sympy.matrices.matrixbase.MatrixBase.row_insert")

```py
row_del(row)
```

删除指定行。

```py
row_insert(pos, other)
```

在给定的行位置插入一行或多行。

示例

```py
>>> from sympy import zeros, ones
>>> M = zeros(3)
>>> V = ones(1, 3)
>>> M.row_insert(1, V)
Matrix([
[0, 0, 0],
[1, 1, 1],
[0, 0, 0],
[0, 0, 0]]) 
```

另见

[`row`](#sympy.matrices.matrixbase.MatrixBase.row "sympy.matrices.matrixbase.MatrixBase.row"), [`col_insert`](#sympy.matrices.matrixbase.MatrixBase.col_insert "sympy.matrices.matrixbase.MatrixBase.col_insert")

```py
row_join(other)
```

连接两个矩阵，沿着self的最后一列和rhs的第一列

示例

```py
>>> from sympy import zeros, ones
>>> M = zeros(3)
>>> V = ones(3, 1)
>>> M.row_join(V)
Matrix([
[0, 0, 0, 1],
[0, 0, 0, 1],
[0, 0, 0, 1]]) 
```

另见

[`row`](#sympy.matrices.matrixbase.MatrixBase.row "sympy.matrices.matrixbase.MatrixBase.row"), [`col_join`](#sympy.matrices.matrixbase.MatrixBase.col_join "sympy.matrices.matrixbase.MatrixBase.col_join")

```py
rowspace(simplify=False)
```

返回一个生成矩阵行空间的向量列表。

示例

```py
>>> from sympy import Matrix
>>> M = Matrix(3, 3, [1, 3, 0, -2, -6, 0, 3, 9, 6])
>>> M
Matrix([
[ 1,  3, 0],
[-2, -6, 0],
[ 3,  9, 6]])
>>> M.rowspace()
[Matrix([[1, 3, 0]]), Matrix([[0, 0, 6]])] 
```

```py
rref(iszerofunc=<function _iszero>, simplify=False, pivots=True, normalize_last=True)
```

返回矩阵的行阶梯形式和主元变量的索引。

参数：

**iszerofunc**：函数

> 用于检测元素是否可以作为主元的函数。默认使用`lambda x: x.is_zero`。

**simplify**：函数

> 用于在查找主元时简化元素的函数。默认使用SymPy的`simplify`。

**pivots**：是或否

> 如果为`True`，则返回一个元组，其中包含行减少矩阵和一个主轴列的元组。如果为`False`，则仅返回行减少矩阵。

**normalize_last**：是或否

> 如果为`True`，直到所有每个主轴上下的条目都被归零之前，没有主轴被标准化为\(1\)。这意味着行减少算法在最后一步之前是无分数的。如果为`False`，则使用简单的行减少过程，在使用行操作将主轴上下归零之前，将每个主轴标准化为\(1\)。

例子

```py
>>> from sympy import Matrix
>>> from sympy.abc import x
>>> m = Matrix([[1, 2], [x, 1 - 1/x]])
>>> m.rref()
(Matrix([
[1, 0],
[0, 1]]), (0, 1))
>>> rref_matrix, rref_pivots = m.rref()
>>> rref_matrix
Matrix([
[1, 0],
[0, 1]])
>>> rref_pivots
(0, 1) 
```

`iszerofunc`可以在具有浮点值的矩阵中纠正舍入误差。在以下示例中，调用`rref()`会导致浮点错误，错误地行减少矩阵。`iszerofunc= lambda x: abs(x) < 1e-9`将足够小的数字设置为零，从而避免此错误。

```py
>>> m = Matrix([[0.9, -0.1, -0.2, 0], [-0.8, 0.9, -0.4, 0], [-0.1, -0.8, 0.6, 0]])
>>> m.rref()
(Matrix([
[1, 0, 0, 0],
[0, 1, 0, 0],
[0, 0, 1, 0]]), (0, 1, 2))
>>> m.rref(iszerofunc=lambda x:abs(x)<1e-9)
(Matrix([
[1, 0, -0.301369863013699, 0],
[0, 1, -0.712328767123288, 0],
[0, 0,         0,          0]]), (0, 1)) 
```

注意事项

`normalize_last=True`的默认值可以显著加快行减少的速度，特别是在具有符号的矩阵上。然而，如果你依赖于行减少算法留下矩阵的形式条目，请设置`normalize_last=False`。

```py
rref_rhs(rhs)
```

返回矩阵的简化行阶梯形式，显示减少步骤后的右手边矩阵。`rhs`必须与`self`具有相同的行数。

例子

```py
>>> from sympy import Matrix, symbols
>>> r1, r2 = symbols('r1 r2')
>>> Matrix([[1, 1], [2, 1]]).rref_rhs(Matrix([r1, r2]))
(Matrix([
[1, 0],
[0, 1]]), Matrix([
[ -r1 + r2],
[2*r1 - r2]])) 
```

```py
property shape
```

矩阵的形状（维度）作为2元组（行数，列数）。

例子

```py
>>> from sympy import zeros
>>> M = zeros(2, 3)
>>> M.shape
(2, 3)
>>> M.rows
2
>>> M.cols
3 
```

```py
simplify(**kwargs)
```

将矩阵的每个元素应用简化。

例子

```py
>>> from sympy.abc import x, y
>>> from sympy import SparseMatrix, sin, cos
>>> SparseMatrix(1, 1, [x*sin(y)**2 + x*cos(y)**2])
Matrix([[x*sin(y)**2 + x*cos(y)**2]])
>>> _.simplify()
Matrix([[x]]) 
```

```py
singular_value_decomposition()
```

返回一个压缩的奇异值分解。

解释

奇异值分解是形式为\(A = U \Sigma V^H\)的分解，其中

+   \(U, V\)是列正交矩阵。

+   \(\Sigma\) 是一个对角矩阵，主对角线上包含矩阵A的奇异值。

一个列正交矩阵满足\(\mathbb{I} = U^H U\)，而一个完整的正交矩阵满足关系\(\mathbb{I} = U U^H = U^H U\)，其中\(\mathbb{I}\)是具有相同维度的单位矩阵。

对于不是方阵或秩不足的矩阵，返回一个列正交矩阵就足够了，因为扩展它们可能会引入冗余计算。在压缩的奇异值分解中，我们只返回列正交矩阵，因为这个原因。

如果你想要扩展结果以返回一个完整的正交分解，你应该使用以下步骤。

+   用与每个其他列正交的列扩展\(U, V\)矩阵，并使其变成方阵。

+   用零行扩展\(\Sigma\)矩阵，使其形状与原矩阵相同。

过程将在示例部分说明。

例子

我们首先取一个满秩矩阵：

```py
>>> from sympy import Matrix
>>> A = Matrix([[1, 2],[2,1]])
>>> U, S, V = A.singular_value_decomposition()
>>> U
Matrix([
[ sqrt(2)/2, sqrt(2)/2],
[-sqrt(2)/2, sqrt(2)/2]])
>>> S
Matrix([
[1, 0],
[0, 3]])
>>> V
Matrix([
[-sqrt(2)/2, sqrt(2)/2],
[ sqrt(2)/2, sqrt(2)/2]]) 
```

如果一个矩阵是方阵且满秩，那么U，V在两个方向上都是正交的。

```py
>>> U * U.H
Matrix([
[1, 0],
[0, 1]])
>>> U.H * U
Matrix([
[1, 0],
[0, 1]]) 
```

```py
>>> V * V.H
Matrix([
[1, 0],
[0, 1]])
>>> V.H * V
Matrix([
[1, 0],
[0, 1]])
>>> A == U * S * V.H
True 
```

```py
>>> C = Matrix([
...         [1, 0, 0, 0, 2],
...         [0, 0, 3, 0, 0],
...         [0, 0, 0, 0, 0],
...         [0, 2, 0, 0, 0],
...     ])
>>> U, S, V = C.singular_value_decomposition() 
```

```py
>>> V.H * V
Matrix([
[1, 0, 0],
[0, 1, 0],
[0, 0, 1]])
>>> V * V.H
Matrix([
[1/5, 0, 0, 0, 2/5],
[  0, 1, 0, 0,   0],
[  0, 0, 1, 0,   0],
[  0, 0, 0, 0,   0],
[2/5, 0, 0, 0, 4/5]]) 
```

如果你想要扩展结果为一个完整的正交分解，你应该用另一个正交列扩展\(V\)。

可以向每个其他列附加一个任意的标准基，这些基是线性独立的，并且你可以运行Gram-Schmidt过程使它们增强为正交基。

```py
>>> V_aug = V.row_join(Matrix([[0,0,0,0,1],
... [0,0,0,1,0]]).H)
>>> V_aug = V_aug.QRdecomposition()[0]
>>> V_aug
Matrix([
[0,   sqrt(5)/5, 0, -2*sqrt(5)/5, 0],
[1,           0, 0,            0, 0],
[0,           0, 1,            0, 0],
[0,           0, 0,            0, 1],
[0, 2*sqrt(5)/5, 0,    sqrt(5)/5, 0]])
>>> V_aug.H * V_aug
Matrix([
[1, 0, 0, 0, 0],
[0, 1, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 1, 0],
[0, 0, 0, 0, 1]])
>>> V_aug * V_aug.H
Matrix([
[1, 0, 0, 0, 0],
[0, 1, 0, 0, 0],
[0, 0, 1, 0, 0],
[0, 0, 0, 1, 0],
[0, 0, 0, 0, 1]]) 
```

同样地，我们扩展U

```py
>>> U_aug = U.row_join(Matrix([0,0,1,0]))
>>> U_aug = U_aug.QRdecomposition()[0]
>>> U_aug
Matrix([
[0, 1, 0, 0],
[0, 0, 1, 0],
[0, 0, 0, 1],
[1, 0, 0, 0]]) 
```

```py
>>> U_aug.H * U_aug
Matrix([
[1, 0, 0, 0],
[0, 1, 0, 0],
[0, 0, 1, 0],
[0, 0, 0, 1]])
>>> U_aug * U_aug.H
Matrix([
[1, 0, 0, 0],
[0, 1, 0, 0],
[0, 0, 1, 0],
[0, 0, 0, 1]]) 
```

我们向 S 添加了 2 列零和一行

```py
>>> S_aug = S.col_join(Matrix([[0,0,0]]))
>>> S_aug = S_aug.row_join(Matrix([[0,0,0,0],
... [0,0,0,0]]).H)
>>> S_aug
Matrix([
[2,       0, 0, 0, 0],
[0, sqrt(5), 0, 0, 0],
[0,       0, 3, 0, 0],
[0,       0, 0, 0, 0]]) 
```

```py
>>> U_aug * S_aug * V_aug.H == C
True 
```

```py
singular_values()
```

计算矩阵的奇异值

示例

```py
>>> from sympy import Matrix, Symbol
>>> x = Symbol('x', real=True)
>>> M = Matrix([[0, 1, 0], [0, x, 0], [-1, 0, 0]])
>>> M.singular_values()
[sqrt(x**2 + 1), 1, 0] 
```

另请参阅

[`condition_number`](#sympy.matrices.matrixbase.MatrixBase.condition_number "sympy.matrices.matrixbase.MatrixBase.condition_number")

```py
solve(rhs, method='GJ')
```

解决存在唯一解的线性方程。

参数：

**rhs** ：矩阵

> 表示线性方程右侧的向量。

**method** ：字符串，可选

> 如果设为 `'GJ'` 或 `'GE'`，将使用高斯-约当消元法，该方法已在 `gauss_jordan_solve` 程序中实现。
> 
> 如果设为 `'LU'`，将使用 `LUsolve` 程序。
> 
> 如果设为 `'QR'`，将使用 `QRsolve` 程序。
> 
> 如果设为 `'PINV'`，将使用 `pinv_solve` 程序。
> 
> 如果设为 `'CRAMER'`，将使用 `cramer_solve` 程序。
> 
> 它还支持特殊线性系统的可用方法
> 
> 对于正定系统：
> 
> 如果设为 `'CH'`，将使用 `cholesky_solve` 程序。
> 
> 如果设为 `'LDL'`，将使用 `LDLsolve` 程序。
> 
> 要使用不同的方法并通过求逆计算解决方案，请使用 .inv() 文档字符串中定义的方法。

返回：

**solutions** ：矩阵

> 表示解决方案的向量。

引发：

**ValueError**

> 如果不存在唯一解，则会引发 `ValueError`。
> 
> 如果 `M` 不是方阵，则建议将引发 `ValueError` 并建议使用不同的解决系统程序。

```py
solve_least_squares(rhs, method='CH')
```

返回数据的最小二乘拟合。

参数：

**rhs** ：矩阵

> 表示线性方程右侧的向量。

**method** ：字符串或布尔值，可选

> 如果设为 `'CH'`，将使用 `cholesky_solve` 程序。
> 
> 如果设为 `'LDL'`，将使用 `LDLsolve` 程序。
> 
> 如果设为 `'QR'`，将使用 `QRsolve` 程序。
> 
> 如果设为 `'PINV'`，将使用 `pinv_solve` 程序。
> 
> 否则，将使用 `M` 的共轭来创建传递给 `solve` 的方程组，同时还将使用 `method` 定义的提示。

返回：

**solutions** ：矩阵

> 表示解决方案的向量。

示例

```py
>>> from sympy import Matrix, ones
>>> A = Matrix([1, 2, 3])
>>> B = Matrix([2, 3, 4])
>>> S = Matrix(A.row_join(B))
>>> S
Matrix([
[1, 2],
[2, 3],
[3, 4]]) 
```

如果 S 的每行表示 Ax + By 的系数，而 x 和 y 分别为 [2, 3]，则 S*xy 为：

```py
>>> r = S*Matrix([2, 3]); r
Matrix([
[ 8],
[13],
[18]]) 
```

但让我们在中间值上加 1，然后求解 xy 的最小二乘值：

```py
>>> xy = S.solve_least_squares(Matrix([8, 14, 18])); xy
Matrix([
[ 5/3],
[10/3]]) 
```

错误由 S*xy - r 给出：

```py
>>> S*xy - r
Matrix([
[1/3],
[1/3],
[1/3]])
>>> _.norm().n(2)
0.58 
```

如果使用不同的 xy，则范数会更高：

```py
>>> xy += ones(2, 1)/10
>>> (S*xy - r).norm().n(2)
1.5 
```

```py
strongly_connected_components()
```

返回将方阵视为加权图时的强连通顶点列表。

示例

```py
>>> from sympy import Matrix
>>> A = Matrix([
...     [44, 0, 0, 0, 43, 0, 45, 0, 0],
...     [0, 66, 62, 61, 0, 68, 0, 60, 67],
...     [0, 0, 22, 21, 0, 0, 0, 20, 0],
...     [0, 0, 12, 11, 0, 0, 0, 10, 0],
...     [34, 0, 0, 0, 33, 0, 35, 0, 0],
...     [0, 86, 82, 81, 0, 88, 0, 80, 87],
...     [54, 0, 0, 0, 53, 0, 55, 0, 0],
...     [0, 0, 2, 1, 0, 0, 0, 0, 0],
...     [0, 76, 72, 71, 0, 78, 0, 70, 77]])
>>> A.strongly_connected_components()
[[0, 4, 6], [2, 3, 7], [1, 5, 8]] 
```

```py
strongly_connected_components_decomposition(lower=True)
```

将方阵分解为仅使用置换的块三角形式。

参数：

**lower** ：布尔值

> 当 `True` 时，使 \(B\) 成为下块三角形。否则，使 \(B\) 成为上块三角形。

返回：

**P, B** ：置换矩阵，块矩阵

> *P* 是类似于解释中相似变换的置换矩阵。而 *B* 是置换结果的块三角形矩阵。

解释

分解的形式为 \(A = P^{-1} B P\)，其中 \(P\) 是置换矩阵，\(B\) 是块对角线矩阵。

示例

```py
>>> from sympy import Matrix, pprint
>>> A = Matrix([
...     [44, 0, 0, 0, 43, 0, 45, 0, 0],
...     [0, 66, 62, 61, 0, 68, 0, 60, 67],
...     [0, 0, 22, 21, 0, 0, 0, 20, 0],
...     [0, 0, 12, 11, 0, 0, 0, 10, 0],
...     [34, 0, 0, 0, 33, 0, 35, 0, 0],
...     [0, 86, 82, 81, 0, 88, 0, 80, 87],
...     [54, 0, 0, 0, 53, 0, 55, 0, 0],
...     [0, 0, 2, 1, 0, 0, 0, 0, 0],
...     [0, 76, 72, 71, 0, 78, 0, 70, 77]]) 
```

一个下三角分解：

```py
>>> P, B = A.strongly_connected_components_decomposition()
>>> pprint(P)
PermutationMatrix((8)(1 4 3 2 6)(5 7))
>>> pprint(B)
[[44  43  45]   [0  0  0]     [0  0  0]  ]
[[          ]   [       ]     [       ]  ]
[[34  33  35]   [0  0  0]     [0  0  0]  ]
[[          ]   [       ]     [       ]  ]
[[54  53  55]   [0  0  0]     [0  0  0]  ]
[                                        ]
[ [0  0  0]    [22  21  20]   [0  0  0]  ]
[ [       ]    [          ]   [       ]  ]
[ [0  0  0]    [12  11  10]   [0  0  0]  ]
[ [       ]    [          ]   [       ]  ]
[ [0  0  0]    [2   1   0 ]   [0  0  0]  ]
[                                        ]
[ [0  0  0]    [62  61  60]  [66  68  67]]
[ [       ]    [          ]  [          ]]
[ [0  0  0]    [82  81  80]  [86  88  87]]
[ [       ]    [          ]  [          ]]
[ [0  0  0]    [72  71  70]  [76  78  77]] 
```

```py
>>> P = P.as_explicit()
>>> B = B.as_explicit()
>>> P.T * B * P == A
True 
```

一个上块三角形分解：

```py
>>> P, B = A.strongly_connected_components_decomposition(lower=False)
>>> pprint(P)
PermutationMatrix((0 1 5 7 4 3 2 8 6))
>>> pprint(B)
[[66  68  67]  [62  61  60]   [0  0  0]  ]
[[          ]  [          ]   [       ]  ]
[[86  88  87]  [82  81  80]   [0  0  0]  ]
[[          ]  [          ]   [       ]  ]
[[76  78  77]  [72  71  70]   [0  0  0]  ]
[                                        ]
[ [0  0  0]    [22  21  20]   [0  0  0]  ]
[ [       ]    [          ]   [       ]  ]
[ [0  0  0]    [12  11  10]   [0  0  0]  ]
[ [       ]    [          ]   [       ]  ]
[ [0  0  0]    [2   1   0 ]   [0  0  0]  ]
[                                        ]
[ [0  0  0]     [0  0  0]    [44  43  45]]
[ [       ]     [       ]    [          ]]
[ [0  0  0]     [0  0  0]    [34  33  35]]
[ [       ]     [       ]    [          ]]
[ [0  0  0]     [0  0  0]    [54  53  55]] 
```

```py
>>> P = P.as_explicit()
>>> B = B.as_explicit()
>>> P.T * B * P == A
True 
```

```py
subs(*args, **kwargs)
```

返回应用到每个条目的子项后的新矩阵。

例子

```py
>>> from sympy.abc import x, y
>>> from sympy import SparseMatrix, Matrix
>>> SparseMatrix(1, 1, [x])
Matrix([[x]])
>>> _.subs(x, y)
Matrix([[y]])
>>> Matrix(_).subs(y, x)
Matrix([[x]]) 
```

```py
table(printer, rowstart='[', rowend=']', rowsep='\n', colsep=', ', align='right')
```

矩阵的表格形式的字符串。

`printer` 是用于元素的打印机（通常类似于 StrPrinter()）。

`rowstart` 是用于开始每一行的字符串（默认为‘[’）。

`rowend` 是用于结束每一行的字符串（默认为‘]’）。

`rowsep` 是用于分隔行的字符串（默认为换行符）。

`colsep` 是用于分隔列的字符串（默认为‘, ’）。

`align` 定义了元素的对齐方式。必须是‘left’、‘right’或‘center’之一。您还可以使用‘<’、‘>’和‘^’分别表示相同的意思。

这由矩阵的字符串打印机使用。

例子

```py
>>> from sympy import Matrix, StrPrinter
>>> M = Matrix([[1, 2], [-33, 4]])
>>> printer = StrPrinter()
>>> M.table(printer)
'[  1, 2]\n[-33, 4]'
>>> print(M.table(printer))
[  1, 2]
[-33, 4]
>>> print(M.table(printer, rowsep=',\n'))
[  1, 2],
[-33, 4]
>>> print('[%s]' % M.table(printer, rowsep=',\n'))
[[  1, 2],
[-33, 4]]
>>> print(M.table(printer, colsep=' '))
[  1 2]
[-33 4]
>>> print(M.table(printer, align='center'))
[ 1 , 2]
[-33, 4]
>>> print(M.table(printer, rowstart='{', rowend='}'))
{  1, 2}
{-33, 4} 
```

```py
todod()
```

返回包含矩阵非零元素的字典字典形式的矩阵。

例子

```py
>>> from sympy import Matrix
>>> A = Matrix([[0, 1],[0, 3]])
>>> A
Matrix([
[0, 1],
[0, 3]])
>>> A.todod()
{0: {1: 1}, 1: {1: 3}} 
```

```py
todok()
```

返回以键为字典的矩阵。

例子

```py
>>> from sympy import Matrix
>>> M = Matrix.eye(3)
>>> M.todok()
{(0, 0): 1, (1, 1): 1, (2, 2): 1} 
```

```py
tolist()
```

返回嵌套的 Python 列表形式的矩阵。

例子

```py
>>> from sympy import Matrix, ones
>>> m = Matrix(3, 3, range(9))
>>> m
Matrix([
[0, 1, 2],
[3, 4, 5],
[6, 7, 8]])
>>> m.tolist()
[[0, 1, 2], [3, 4, 5], [6, 7, 8]]
>>> ones(3, 0).tolist()
[[], [], []] 
```

当没有行时，将无法确定原始矩阵有多少列：

```py
>>> ones(0, 3).tolist()
[] 
```

```py
trace()
```

返回方阵的迹，即对角元素的和。

例子

```py
>>> from sympy import Matrix
>>> A = Matrix(2, 2, [1, 2, 3, 4])
>>> A.trace()
5 
```

```py
transpose()
```

返回矩阵的转置。

例子

```py
>>> from sympy import Matrix
>>> A = Matrix(2, 2, [1, 2, 3, 4])
>>> A.transpose()
Matrix([
[1, 3],
[2, 4]]) 
```

```py
>>> from sympy import Matrix, I
>>> m=Matrix(((1, 2+I), (3, 4)))
>>> m
Matrix([
[1, 2 + I],
[3,     4]])
>>> m.transpose()
Matrix([
[    1, 3],
[2 + I, 4]])
>>> m.T == m.transpose()
True 
```

另请参阅

[`conjugate`](#sympy.matrices.matrixbase.MatrixBase.conjugate "sympy.matrices.matrixbase.MatrixBase.conjugate")

按元素共轭

```py
upper_hessenberg_decomposition()
```

将矩阵转换为 Hessenberg 矩阵 H。

返回2个矩阵 H、P，使得 \(P H P^{T} = A\)，其中 H 是上 Hessenberg 矩阵，P 是正交矩阵

例子

```py
>>> from sympy import Matrix
>>> A = Matrix([
...     [1,2,3],
...     [-3,5,6],
...     [4,-8,9],
... ])
>>> H, P = A.upper_hessenberg_decomposition()
>>> H
Matrix([
[1,    6/5,    17/5],
[5, 213/25, -134/25],
[0, 216/25,  137/25]])
>>> P
Matrix([
[1,    0,   0],
[0, -3/5, 4/5],
[0,  4/5, 3/5]])
>>> P * H * P.H == A
True 
```

参考

```py
upper_triangular(k=0)
```

返回矩阵第 k 条对角线及其以上的元素。如果未指定 k，则简单返回矩阵的上三角部分。

例子

```py
>>> from sympy import ones
>>> A = ones(4)
>>> A.upper_triangular()
Matrix([
[1, 1, 1, 1],
[0, 1, 1, 1],
[0, 0, 1, 1],
[0, 0, 0, 1]]) 
```

```py
>>> A.upper_triangular(2)
Matrix([
[0, 0, 1, 1],
[0, 0, 0, 1],
[0, 0, 0, 0],
[0, 0, 0, 0]]) 
```

```py
>>> A.upper_triangular(-1)
Matrix([
[1, 1, 1, 1],
[1, 1, 1, 1],
[0, 1, 1, 1],
[0, 0, 1, 1]]) 
```

```py
upper_triangular_solve(rhs)
```

解决 `Ax = B`，其中 A 是上三角矩阵。

另请参阅

[`lower_triangular_solve`](#sympy.matrices.matrixbase.MatrixBase.lower_triangular_solve "sympy.matrices.matrixbase.MatrixBase.lower_triangular_solve"), [`gauss_jordan_solve`](#sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve "sympy.matrices.matrixbase.MatrixBase.gauss_jordan_solve"), [`cholesky_solve`](#sympy.matrices.matrixbase.MatrixBase.cholesky_solve "sympy.matrices.matrixbase.MatrixBase.cholesky_solve"), [`diagonal_solve`](#sympy.matrices.matrixbase.MatrixBase.diagonal_solve "sympy.matrices.matrixbase.MatrixBase.diagonal_solve"), [`LDLsolve`](#sympy.matrices.matrixbase.MatrixBase.LDLsolve "sympy.matrices.matrixbase.MatrixBase.LDLsolve"), [`LUsolve`](#sympy.matrices.matrixbase.MatrixBase.LUsolve "sympy.matrices.matrixbase.MatrixBase.LUsolve"), [`QRsolve`](#sympy.matrices.matrixbase.MatrixBase.QRsolve "sympy.matrices.matrixbase.MatrixBase.QRsolve"), [`pinv_solve`](#sympy.matrices.matrixbase.MatrixBase.pinv_solve "sympy.matrices.matrixbase.MatrixBase.pinv_solve"), [`cramer_solve`](#sympy.matrices.matrixbase.MatrixBase.cramer_solve "sympy.matrices.matrixbase.MatrixBase.cramer_solve")

```py
values()
```

返回 self 的非零值。

例子

```py
>>> from sympy import Matrix
>>> m = Matrix([[0, 1], [2, 3]])
>>> m.values()
[1, 2, 3] 
```

另请参阅

[`iter_values`](#sympy.matrices.matrixbase.MatrixBase.iter_values "sympy.matrices.matrixbase.MatrixBase.iter_values"), [`tolist`](#sympy.matrices.matrixbase.MatrixBase.tolist "sympy.matrices.matrixbase.MatrixBase.tolist"), [`flat`](#sympy.matrices.matrixbase.MatrixBase.flat "sympy.matrices.matrixbase.MatrixBase.flat")

```py
vec()
```

返回通过堆叠列将矩阵转换为单列矩阵

示例

```py
>>> from sympy import Matrix
>>> m=Matrix([[1, 3], [2, 4]])
>>> m
Matrix([
[1, 3],
[2, 4]])
>>> m.vec()
Matrix([
[1],
[2],
[3],
[4]]) 
```

另请参阅

[`vech`](#sympy.matrices.matrixbase.MatrixBase.vech "sympy.matrices.matrixbase.MatrixBase.vech")

```py
vech(diagonal=True, check_symmetry=True)
```

将矩阵重新形状为列向量，通过堆叠下三角中的元素。

参数：

**diagonal** : bool, optional

> 如果为 `True`，则包含对角元素。

**check_symmetry** : bool, optional

> 如果为 `True`，则检查矩阵是否对称。

示例

```py
>>> from sympy import Matrix
>>> m=Matrix([[1, 2], [2, 3]])
>>> m
Matrix([
[1, 2],
[2, 3]])
>>> m.vech()
Matrix([
[1],
[2],
[3]])
>>> m.vech(diagonal=False)
Matrix([[2]]) 
```

注意事项

这对于对称矩阵应该有效，并且 `vech` 可以用比 `vec` 更小的尺寸表示向量形式的对称矩阵。

另请参阅

[`vec`](#sympy.matrices.matrixbase.MatrixBase.vec "sympy.matrices.matrixbase.MatrixBase.vec")

```py
vee()
```

从表示叉乘的反对称矩阵中返回一个3x1向量，以便 `self * b` 等价于 `self.vee().cross(b)`。

示例

调用 `vee` 可以从反对称矩阵创建向量：

```py
>>> from sympy import Matrix
>>> A = Matrix([[0, -3, 2], [3, 0, -1], [-2, 1, 0]])
>>> a = A.vee()
>>> a
Matrix([
[1],
[2],
[3]]) 
```

计算原矩阵与向量的矩阵乘积相当于叉乘：

```py
>>> b = Matrix([3, 2, 1])
>>> A * b
Matrix([
[-4],
[ 8],
[-4]]) 
```

```py
>>> a.cross(b)
Matrix([
[-4],
[ 8],
[-4]]) 
```

`vee` 也可用于检索角速度表达式。定义旋转矩阵：

```py
>>> from sympy import rot_ccw_axis3, trigsimp
>>> from sympy.physics.mechanics import dynamicsymbols
>>> theta = dynamicsymbols('theta')
>>> R = rot_ccw_axis3(theta)
>>> R
Matrix([
[cos(theta(t)), -sin(theta(t)), 0],
[sin(theta(t)),  cos(theta(t)), 0],
[            0,              0, 1]]) 
```

我们可以检索角速度：

```py
>>> Omega = R.T * R.diff()
>>> Omega = trigsimp(Omega)
>>> Omega.vee()
Matrix([
[                      0],
[                      0],
[Derivative(theta(t), t)]]) 
```

另请参阅

[`dot`](#sympy.matrices.matrixbase.MatrixBase.dot "sympy.matrices.matrixbase.MatrixBase.dot"), [`cross`](#sympy.matrices.matrixbase.MatrixBase.cross "sympy.matrices.matrixbase.MatrixBase.cross"), [`hat`](#sympy.matrices.matrixbase.MatrixBase.hat "sympy.matrices.matrixbase.MatrixBase.hat"), [`multiply`](#sympy.matrices.matrixbase.MatrixBase.multiply "sympy.matrices.matrixbase.MatrixBase.multiply"), [`multiply_elementwise`](#sympy.matrices.matrixbase.MatrixBase.multiply_elementwise "sympy.matrices.matrixbase.MatrixBase.multiply_elementwise")

```py
classmethod vstack(*args)
```

返回通过垂直连接参数形成的矩阵（即重复应用 col_join）。

示例

```py
>>> from sympy import Matrix, eye
>>> Matrix.vstack(eye(2), 2*eye(2))
Matrix([
[1, 0],
[0, 1],
[2, 0],
[0, 2]]) 
```

```py
classmethod wilkinson(n, **kwargs)
```

返回大小为 2*n + 1 的两个平方 Wilkinson 矩阵 \(W_{2n + 1}^-, W_{2n + 1}^+ =\) Wilkinson(n)

示例

```py
>>> from sympy import Matrix
>>> wminus, wplus = Matrix.wilkinson(3)
>>> wminus
Matrix([
[-3,  1,  0, 0, 0, 0, 0],
[ 1, -2,  1, 0, 0, 0, 0],
[ 0,  1, -1, 1, 0, 0, 0],
[ 0,  0,  1, 0, 1, 0, 0],
[ 0,  0,  0, 1, 1, 1, 0],
[ 0,  0,  0, 0, 1, 2, 1],
[ 0,  0,  0, 0, 0, 1, 3]])
>>> wplus
Matrix([
[3, 1, 0, 0, 0, 0, 0],
[1, 2, 1, 0, 0, 0, 0],
[0, 1, 1, 1, 0, 0, 0],
[0, 0, 1, 0, 1, 0, 0],
[0, 0, 0, 1, 1, 1, 0],
[0, 0, 0, 0, 1, 2, 1],
[0, 0, 0, 0, 0, 1, 3]]) 
```

参考文献

[[R642](#id36)]

[https://blogs.mathworks.com/cleve/2013/04/15/wilkinsons-matrices-2/](https://blogs.mathworks.com/cleve/2013/04/15/wilkinsons-matrices-2/)

[[R643](#id37)]

1.  1.  Wilkinson，The Algebraic Eigenvalue Problem，Claredon Press，Oxford，1965，662页。

```py
xreplace(rule)
```

返回应用于每个条目的 xreplace 后的新矩阵。

示例

```py
>>> from sympy.abc import x, y
>>> from sympy import SparseMatrix, Matrix
>>> SparseMatrix(1, 1, [x])
Matrix([[x]])
>>> _.xreplace({x: y})
Matrix([[y]])
>>> Matrix(_).xreplace({y: x})
Matrix([[x]]) 
```

```py
classmethod zeros(rows, cols=None, **kwargs)
```

返回一个零矩阵。

参数：

**rows** : 矩阵的行数

**cols** : 矩阵的列数（如果为 None，则 cols=rows）

Kwargs

cls：返回矩阵的类

### 矩阵异常

```py
class sympy.matrices.matrixbase.MatrixError
```

```py
class sympy.matrices.matrixbase.ShapeError
```

错误的矩阵形状

```py
class sympy.matrices.matrixbase.NonSquareMatrixError
```

### 矩阵函数

```py
sympy.matrices.dense.matrix_multiply_elementwise(A, B)
```

返回矩阵 A 和 B 的Hadamard积（逐元素乘积）

```py
>>> from sympy import Matrix, matrix_multiply_elementwise
>>> A = Matrix([[0, 1, 2], [3, 4, 5]])
>>> B = Matrix([[1, 10, 100], [100, 10, 1]])
>>> matrix_multiply_elementwise(A, B)
Matrix([
[  0, 10, 200],
[300, 40,   5]]) 
```

另请参阅

[`sympy.matrices.matrixbase.MatrixBase.__mul__`](#sympy.matrices.matrixbase.MatrixBase.__mul__ "sympy.matrices.matrixbase.MatrixBase.__mul__")

```py
sympy.matrices.dense.zeros(*args, **kwargs)
```

返回一个具有`rows`行和`cols`列的零矩阵；如果省略`cols`，则返回一个方阵。

参见

[`ones`](#sympy.matrices.dense.ones "sympy.matrices.dense.ones"), [`eye`](#sympy.matrices.dense.eye "sympy.matrices.dense.eye"), [`diag`](#sympy.matrices.dense.diag "sympy.matrices.dense.diag")

```py
sympy.matrices.dense.ones(*args, **kwargs)
```

返回一个具有`rows`行和`cols`列的全为1的矩阵；如果省略`cols`，则返回一个方阵。

参见

[`zeros`](#sympy.matrices.dense.zeros "sympy.matrices.dense.zeros"), [`eye`](#sympy.matrices.dense.eye "sympy.matrices.dense.eye"), [`diag`](#sympy.matrices.dense.diag "sympy.matrices.dense.diag")

```py
sympy.matrices.dense.eye(*args, **kwargs)
```

创建n x n的方阵单位矩阵

参见

[`diag`](#sympy.matrices.dense.diag "sympy.matrices.dense.diag"), [`zeros`](#sympy.matrices.dense.zeros "sympy.matrices.dense.zeros"), [`ones`](#sympy.matrices.dense.ones "sympy.matrices.dense.ones")

```py
sympy.matrices.dense.diag(*values, strict=True, unpack=False, **kwargs)
```

返回一个将提供的值放置在对角线上的矩阵。如果包括非方阵，则将产生一个分块对角矩阵。

示例

这个版本的diag是对Matrix.diag的一个轻量级封装，不同之处在于它将所有列表视为矩阵 - 即使只给出一个列表也是如此。如果不希望这样做，请在列表前面加上\(*\)或设置\(unpack=True\)。

```py
>>> from sympy import diag 
```

```py
>>> diag([1, 2, 3], unpack=True)  # = diag(1,2,3) or diag(*[1,2,3])
Matrix([
[1, 0, 0],
[0, 2, 0],
[0, 0, 3]]) 
```

```py
>>> diag([1, 2, 3])  # a column vector
Matrix([
[1],
[2],
[3]]) 
```

参见

[`matrixbase.MatrixBase.eye`](#sympy.matrices.matrixbase.MatrixBase.eye "sympy.matrices.matrixbase.MatrixBase.eye"), [`matrixbase.MatrixBase.diagonal`](#sympy.matrices.matrixbase.MatrixBase.diagonal "sympy.matrices.matrixbase.MatrixBase.diagonal"), [`expressions.blockmatrix.BlockMatrix`](expressions.html#sympy.matrices.expressions.blockmatrix.BlockMatrix "sympy.matrices.expressions.blockmatrix.BlockMatrix")

```py
sympy.matrices.dense.jordan_cell(eigenval, n)
```

创建一个Jordan块：

示例

```py
>>> from sympy import jordan_cell
>>> from sympy.abc import x
>>> jordan_cell(x, 4)
Matrix([
[x, 1, 0, 0],
[0, x, 1, 0],
[0, 0, x, 1],
[0, 0, 0, x]]) 
```

```py
sympy.matrices.dense.hessian(f, varlist, constraints=())
```

计算函数f关于参数varlist的Hessian矩阵，varlist可以作为一个序列或行/列向量给出。可选地给出约束条件列表。

示例

```py
>>> from sympy import Function, hessian, pprint
>>> from sympy.abc import x, y
>>> f = Function('f')(x, y)
>>> g1 = Function('g')(x, y)
>>> g2 = x**2 + 3*y
>>> pprint(hessian(f, (x, y), [g1, g2]))
[                   d               d            ]
[     0        0    --(g(x, y))     --(g(x, y))  ]
[                   dx              dy           ]
[                                                ]
[     0        0        2*x              3       ]
[                                                ]
[                     2               2          ]
[d                   d               d           ]
[--(g(x, y))  2*x   ---(f(x, y))   -----(f(x, y))]
[dx                   2            dy dx         ]
[                   dx                           ]
[                                                ]
[                     2               2          ]
[d                   d               d           ]
[--(g(x, y))   3   -----(f(x, y))   ---(f(x, y)) ]
[dy                dy dx              2          ]
[                                   dy           ] 
```

参见

[`sympy.matrices.matrixbase.MatrixBase.jacobian`](#sympy.matrices.matrixbase.MatrixBase.jacobian "sympy.matrices.matrixbase.MatrixBase.jacobian"), [`wronskian`](#sympy.matrices.dense.wronskian "sympy.matrices.dense.wronskian")

参考文献

[[R644](#id38)]

[https://zh.wikipedia.org/wiki/海森矩阵](https://en.wikipedia.org/wiki/Hessian_matrix)

```py
sympy.matrices.dense.GramSchmidt(vlist, orthonormal=False)
```

对一组向量应用Gram-Schmidt过程。

参数：

**vlist**：矩阵列表

> 要进行正交化的向量。

**orthonormal**：布尔值，可选

> 如果为真，则返回一个正交归一基。

返回：

**vlist**：矩阵列表

> 正交化向量

注意事项

这个例程主要是从`Matrix.orthogonalize`复制过来的，除了一些不同之处，当线性相关向量被发现时，这个例程总是会引发错误，而关键字`normalize`在这个函数中被命名为`orthonormal`。

参见

[`matrixbase.MatrixBase.orthogonalize`](#sympy.matrices.matrixbase.MatrixBase.orthogonalize "sympy.matrices.matrixbase.MatrixBase.orthogonalize")

参考文献

[[R645](#id39)]

[https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process](https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process)

```py
sympy.matrices.dense.wronskian(functions, var, method='bareiss')
```

计算空函数组 [] 的 Wronskian

```py
 | f1       f2        ...   fn      |
                 | f1'      f2'       ...   fn'     |
                 |  .        .        .      .      |
W(f1, ..., fn) = |  .        .         .     .      |
                 |  .        .          .    .      |
                 |  (n)      (n)            (n)     |
                 | D   (f1) D   (f2)  ...  D   (fn) | 
```

参见：[https://en.wikipedia.org/wiki/Wronskian](https://en.wikipedia.org/wiki/Wronskian)

另请参阅

[`sympy.matrices.matrixbase.MatrixBase.jacobian`](#sympy.matrices.matrixbase.MatrixBase.jacobian "sympy.matrices.matrixbase.MatrixBase.jacobian"), [`hessian`](#sympy.matrices.dense.hessian "sympy.matrices.dense.hessian")

```py
sympy.matrices.dense.casoratian(seqs, n, zero=True)
```

给定阶数为 'k' 的线性差分算子 L 和齐次方程 Ly = 0，我们希望计算 L 的核，即一组 'k' 个序列：a(n), b(n), … z(n)。

L 的解线性独立当且仅当它们的 Casoratian，表示为 C(a, b, …, z)，在 n = 0 时不为零。

Casoratian 是由 k x k 行列式定义的：

```py
+  a(n)     b(n)     . . . z(n)     +
|  a(n+1)   b(n+1)   . . . z(n+1)   |
|    .         .     .        .     |
|    .         .       .      .     |
|    .         .         .    .     |
+  a(n+k-1) b(n+k-1) . . . z(n+k-1) + 
```

在 rsolve_hyper() 中非常有用，用于将递归的生成集合中的线性相关解因子化并返回一个基础：

```py
>>> from sympy import Symbol, casoratian, factorial
>>> n = Symbol('n', integer=True) 
```

指数和阶乘是线性独立的：

```py
>>> casoratian([2**n, factorial(n)], n) != 0
True 
```

```py
sympy.matrices.dense.randMatrix(r, c=None, min=0, max=99, seed=None, symmetric=False, percent=100, prng=None)
```

创建尺寸为 `r` x `c` 的随机矩阵。如果省略 `c`，则矩阵将是方阵。如果 `symmetric` 为 True，则矩阵必须是方阵。如果 `percent` 小于 100，则只有大约给定百分比的元素将非零。

用于生成矩阵的伪随机数生成器的选择方式如下。

+   如果提供了 `prng`，它将用作随机数生成器。它应该是 `random.Random` 的实例，或者至少具有相同签名的 `randint` 和 `shuffle` 方法。

+   如果未提供 `prng` 但提供了 `seed`，则将创建具有给定 `seed` 的新 `random.Random`；

+   否则，将使用默认种子创建一个新的 `random.Random`。

示例

```py
>>> from sympy import randMatrix
>>> randMatrix(3) 
[25, 45, 27]
[44, 54,  9]
[23, 96, 46]
>>> randMatrix(3, 2) 
[87, 29]
[23, 37]
[90, 26]
>>> randMatrix(3, 3, 0, 2) 
[0, 2, 0]
[2, 0, 1]
[0, 0, 1]
>>> randMatrix(3, symmetric=True) 
[85, 26, 29]
[26, 71, 43]
[29, 43, 57]
>>> A = randMatrix(3, seed=1)
>>> B = randMatrix(3, seed=2)
>>> A == B
False
>>> A == randMatrix(3, seed=1)
True
>>> randMatrix(3, symmetric=True, percent=50) 
[77, 70,  0],
[70,  0,  0],
[ 0,  0, 88] 
```

### 旋转矩阵

```py
sympy.matrices.dense.rot_givens(i, j, theta, dim=3)
```

返回一个 Givens 旋转矩阵，一个在由两个坐标轴张成的平面上的旋转。

参数：

**i** : 整数，范围在 `0` 到 `dim - 1` 之间

> 指代第一个轴

**j** : 整数，范围在 `0` 到 `dim - 1` 之间

> 指代第二个轴

**dim** : 大于 1 的整数

> 维数的数量。默认为 3。

说明

Givens 旋转对应于将旋转矩阵推广到任意维数，由以下给出：

\[\begin{split}G(i, j, \theta) = \begin{bmatrix} 1 & \cdots & 0 & \cdots & 0 & \cdots & 0 \\ \vdots & \ddots & \vdots & & \vdots & & \vdots \\ 0 & \cdots & c & \cdots & -s & \cdots & 0 \\ \vdots & & \vdots & \ddots & \vdots & & \vdots \\ 0 & \cdots & s & \cdots & c & \cdots & 0 \\ \vdots & & \vdots & & \vdots & \ddots & \vdots \\ 0 & \cdots & 0 & \cdots & 0 & \cdots & 1 \end{bmatrix}\end{split}\]

其中 \(c = \cos(\theta)\) 和 \(s = \sin(\theta)\) 出现在第 `i` 行和第 `j` 列的交点处。

对于固定的 `i > j`，Givens 矩阵的非零元素由以下给出：

+   \(g_{kk} = 1\) 对于 \(k \ne i,\,j\)

+   \(g_{kk} = c\) 对于 \(k = i,\,j\)

+   \(g_{ji} = -g_{ij} = -s\)

例子

```py
>>> from sympy import pi, rot_givens 
```

绕第三轴（z轴）逆时针旋转 π/3 (60度)：

```py
>>> rot_givens(1, 0, pi/3)
Matrix([
[      1/2, -sqrt(3)/2, 0],
[sqrt(3)/2,        1/2, 0],
[        0,          0, 1]]) 
```

如果我们绕 π/2 (90度) 旋转：

```py
>>> rot_givens(1, 0, pi/2)
Matrix([
[0, -1, 0],
[1,  0, 0],
[0,  0, 1]]) 
```

这可以推广到任意维度：

```py
>>> rot_givens(1, 0, pi/2, dim=4)
Matrix([
[0, -1, 0, 0],
[1,  0, 0, 0],
[0,  0, 1, 0],
[0,  0, 0, 1]]) 
```

参见

[`rot_axis1`](#sympy.matrices.dense.rot_axis1 "sympy.matrices.dense.rot_axis1")

返回一个绕第一轴（顺时针绕x轴）旋转 theta 弧度的旋转矩阵

[`rot_axis2`](#sympy.matrices.dense.rot_axis2 "sympy.matrices.dense.rot_axis2")

返回一个绕第二轴（顺时针绕y轴）旋转 theta 弧度的旋转矩阵

[`rot_axis3`](#sympy.matrices.dense.rot_axis3 "sympy.matrices.dense.rot_axis3")

返回一个绕第三轴（顺时针绕z轴）旋转 theta 弧度的旋转矩阵

[`rot_ccw_axis1`](#sympy.matrices.dense.rot_ccw_axis1 "sympy.matrices.dense.rot_ccw_axis1")

返回一个绕第一轴（逆时针绕x轴）旋转 theta 弧度的旋转矩阵

[`rot_ccw_axis2`](#sympy.matrices.dense.rot_ccw_axis2 "sympy.matrices.dense.rot_ccw_axis2")

返回一个绕第二轴（逆时针绕y轴）旋转 theta 弧度的旋转矩阵

[`rot_ccw_axis3`](#sympy.matrices.dense.rot_ccw_axis3 "sympy.matrices.dense.rot_ccw_axis3")

返回一个绕第三轴（逆时针绕z轴）旋转 theta 弧度的旋转矩阵

参考文献

[[R646](#id40)]

[https://en.wikipedia.org/wiki/Givens_rotation](https://en.wikipedia.org/wiki/Givens_rotation)

```py
sympy.matrices.dense.rot_axis1(theta)
```

返回一个绕第一轴（顺时针绕x轴）旋转 theta 弧度的旋转矩阵

解释

对于右手坐标系，这对应于绕 \(x\)-轴的顺时针旋转，如下：

\[\begin{split}R = \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos(\theta) & \sin(\theta) \\ 0 & -\sin(\theta) & \cos(\theta) \end{bmatrix}\end{split}\]

例子

```py
>>> from sympy import pi, rot_axis1 
```

绕 π/3 (60度) 旋转：

```py
>>> theta = pi/3
>>> rot_axis1(theta)
Matrix([
[1,          0,         0],
[0,        1/2, sqrt(3)/2],
[0, -sqrt(3)/2,       1/2]]) 
```

如果我们绕 π/2 (90度) 旋转：

```py
>>> rot_axis1(pi/2)
Matrix([
[1,  0, 0],
[0,  0, 1],
[0, -1, 0]]) 
```

参见

[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")

返回一个 Givens 旋转矩阵（任意维度的广义旋转）

[`rot_ccw_axis1`](#sympy.matrices.dense.rot_ccw_axis1 "sympy.matrices.dense.rot_ccw_axis1")

返回一个绕第一轴（逆时针绕x轴）旋转 theta 弧度的旋转矩阵

[`rot_axis2`](#sympy.matrices.dense.rot_axis2 "sympy.matrices.dense.rot_axis2")

返回一个绕第二轴（顺时针绕y轴）旋转 theta 弧度的旋转矩阵

[`rot_axis3`](#sympy.matrices.dense.rot_axis3 "sympy.matrices.dense.rot_axis3")

返回一个绕第三轴（顺时针绕z轴）旋转 theta 弧度的旋转矩阵

```py
sympy.matrices.dense.rot_axis2(theta)
```

返回一个绕第二轴（顺时针绕y轴）旋转 theta 弧度的旋转矩阵

解释

对于右手坐标系，这对应于绕 \(y\)-轴的顺时针旋转，如下：

\[\begin{split}R = \begin{bmatrix} \cos(\theta) & 0 & -\sin(\theta) \\ 0 & 1 & 0 \\ \sin(\theta) & 0 & \cos(\theta) \end{bmatrix}\end{split}\]

示例

```py
>>> from sympy import pi, rot_axis2 
```

旋转π/3（60度）：

```py
>>> theta = pi/3
>>> rot_axis2(theta)
Matrix([
[      1/2, 0, -sqrt(3)/2],
[        0, 1,          0],
[sqrt(3)/2, 0,        1/2]]) 
```

如果我们旋转π/2（90度）：

```py
>>> rot_axis2(pi/2)
Matrix([
[0, 0, -1],
[0, 1,  0],
[1, 0,  0]]) 
```

另见

[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")

返回一个 Givens 旋转矩阵（任意维度的广义旋转）

[`rot_ccw_axis2`](#sympy.matrices.dense.rot_ccw_axis2 "sympy.matrices.dense.rot_ccw_axis2")

返回一个绕着2轴（顺时针绕y轴）旋转θ（弧度）的旋转矩阵

[`rot_axis1`](#sympy.matrices.dense.rot_axis1 "sympy.matrices.dense.rot_axis1")

返回一个绕着1轴（逆时针绕x轴）旋转θ（弧度）的旋转矩阵

[`rot_axis3`](#sympy.matrices.dense.rot_axis3 "sympy.matrices.dense.rot_axis3")

返回一个绕着3轴（逆时针绕z轴）旋转θ（弧度）的旋转矩阵

```py
sympy.matrices.dense.rot_axis3(theta)
```

返回一个绕着3轴旋转θ（弧度）的旋转矩阵。

解释

对于右手坐标系，这对应于绕 \(z\)-轴顺时针旋转，如下所示：

\[\begin{split}R = \begin{bmatrix} \cos(\theta) & \sin(\theta) & 0 \\ -\sin(\theta) & \cos(\theta) & 0 \\ 0 & 0 & 1 \end{bmatrix}\end{split}\]

示例

```py
>>> from sympy import pi, rot_axis3 
```

旋转π/3（60度）：

```py
>>> theta = pi/3
>>> rot_axis3(theta)
Matrix([
[       1/2, sqrt(3)/2, 0],
[-sqrt(3)/2,       1/2, 0],
[         0,         0, 1]]) 
```

如果我们旋转π/2（90度）：

```py
>>> rot_axis3(pi/2)
Matrix([
[ 0, 1, 0],
[-1, 0, 0],
[ 0, 0, 1]]) 
```

另见

[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")

返回一个 Givens 旋转矩阵（任意维度的广义旋转）

[`rot_ccw_axis3`](#sympy.matrices.dense.rot_ccw_axis3 "sympy.matrices.dense.rot_ccw_axis3")

返回一个绕着3轴（逆时针绕z轴）旋转θ（弧度）的旋转矩阵

[`rot_axis1`](#sympy.matrices.dense.rot_axis1 "sympy.matrices.dense.rot_axis1")

返回一个绕着1轴（顺时针绕x轴）旋转θ（弧度）的旋转矩阵

[`rot_axis2`](#sympy.matrices.dense.rot_axis2 "sympy.matrices.dense.rot_axis2")

返回一个绕着2轴（顺时针绕y轴）旋转θ（弧度）的旋转矩阵

```py
sympy.matrices.dense.rot_ccw_axis1(theta)
```

返回一个绕着1轴旋转θ（弧度）的旋转矩阵。

解释

对于右手坐标系，这对应于绕 \(x\)-轴逆时针旋转，如下所示：

\[\begin{split}R = \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos(\theta) & -\sin(\theta) \\ 0 & \sin(\theta) & \cos(\theta) \end{bmatrix}\end{split}\]

示例

```py
>>> from sympy import pi, rot_ccw_axis1 
```

旋转π/3（60度）：

```py
>>> theta = pi/3
>>> rot_ccw_axis1(theta)
Matrix([
[1,         0,          0],
[0,       1/2, -sqrt(3)/2],
[0, sqrt(3)/2,        1/2]]) 
```

如果我们旋转π/2（90度）：

```py
>>> rot_ccw_axis1(pi/2)
Matrix([
[1, 0,  0],
[0, 0, -1],
[0, 1,  0]]) 
```

另见

[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")

返回一个 Givens 旋转矩阵（任意维度的广义旋转）

[`rot_axis1`](#sympy.matrices.dense.rot_axis1 "sympy.matrices.dense.rot_axis1")

返回一个绕着1轴（顺时针绕x轴）旋转θ（弧度）的旋转矩阵

[`rot_ccw_axis2`](#sympy.matrices.dense.rot_ccw_axis2 "sympy.matrices.dense.rot_ccw_axis2")

返回绕2轴（顺时针绕y轴）旋转θ（弧度）的旋转矩阵。

[`rot_ccw_axis3`](#sympy.matrices.dense.rot_ccw_axis3 "sympy.matrices.dense.rot_ccw_axis3")

返回绕3轴（顺时针绕z轴）旋转θ（弧度）的旋转矩阵。

```py
sympy.matrices.dense.rot_ccw_axis2(theta)
```

返回绕2轴旋转θ（弧度）的旋转矩阵。

解释

对于右手坐标系，这对应于绕\(y\)-轴的逆时针旋转，表示为：

\[\begin{split}R = \begin{bmatrix} \cos(\theta) & 0 & \sin(\theta) \\ 0 & 1 & 0 \\ -\sin(\theta) & 0 & \cos(\theta) \end{bmatrix}\end{split}\]

示例

```py
>>> from sympy import pi, rot_ccw_axis2 
```

旋转π/3（60度）：

```py
>>> theta = pi/3
>>> rot_ccw_axis2(theta)
Matrix([
[       1/2, 0, sqrt(3)/2],
[         0, 1,         0],
[-sqrt(3)/2, 0,       1/2]]) 
```

如果我们旋转π/2（90度）：

```py
>>> rot_ccw_axis2(pi/2)
Matrix([
[ 0,  0,  1],
[ 0,  1,  0],
[-1,  0,  0]]) 
```

参见

[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")

返回Givens旋转矩阵（任意维度的广义旋转）

[`rot_axis2`](#sympy.matrices.dense.rot_axis2 "sympy.matrices.dense.rot_axis2")

返回绕2轴（顺时针绕y轴）旋转θ（弧度）的旋转矩阵。

[`rot_ccw_axis1`](#sympy.matrices.dense.rot_ccw_axis1 "sympy.matrices.dense.rot_ccw_axis1")

返回绕1轴（顺时针绕x轴）旋转θ（弧度）的旋转矩阵。

[`rot_ccw_axis3`](#sympy.matrices.dense.rot_ccw_axis3 "sympy.matrices.dense.rot_ccw_axis3")

返回绕3轴（顺时针绕z轴）旋转θ（弧度）的旋转矩阵。

```py
sympy.matrices.dense.rot_ccw_axis3(theta)
```

返回绕3轴（顺时针绕z轴）旋转θ（弧度）的旋转矩阵。

解释

对于右手坐标系，这对应于绕\(z\)-轴的逆时针旋转，表示为：

\[\begin{split}R = \begin{bmatrix} \cos(\theta) & -\sin(\theta) & 0 \\ \sin(\theta) & \cos(\theta) & 0 \\ 0 & 0 & 1 \end{bmatrix}\end{split}\]

示例

```py
>>> from sympy import pi, rot_ccw_axis3 
```

旋转π/3（60度）：

```py
>>> theta = pi/3
>>> rot_ccw_axis3(theta)
Matrix([
[      1/2, -sqrt(3)/2, 0],
[sqrt(3)/2,        1/2, 0],
[        0,          0, 1]]) 
```

如果我们旋转π/2（90度）：

```py
>>> rot_ccw_axis3(pi/2)
Matrix([
[0, -1, 0],
[1,  0, 0],
[0,  0, 1]]) 
```

参见

[`rot_givens`](#sympy.matrices.dense.rot_givens "sympy.matrices.dense.rot_givens")

返回Givens旋转矩阵（任意维度的广义旋转）

[`rot_axis3`](#sympy.matrices.dense.rot_axis3 "sympy.matrices.dense.rot_axis3")

返回绕3轴（逆时针绕z轴）旋转θ（弧度）的旋转矩阵。

[`rot_ccw_axis1`](#sympy.matrices.dense.rot_ccw_axis1 "sympy.matrices.dense.rot_ccw_axis1")

返回绕1轴（顺时针绕x轴）旋转θ（弧度）的旋转矩阵。

[`rot_ccw_axis2`](#sympy.matrices.dense.rot_ccw_axis2 "sympy.matrices.dense.rot_ccw_axis2")

返回绕2轴（顺时针绕y轴）旋转θ（弧度）的旋转矩阵。

### NumPy实用函数

```py
sympy.matrices.dense.list2numpy(l, dtype=<class 'object'>)
```

将SymPy表达式的Python列表转换为NumPy数组。

参见

[`matrix2numpy`](#sympy.matrices.dense.matrix2numpy "sympy.matrices.dense.matrix2numpy")

```py
sympy.matrices.dense.matrix2numpy(m, dtype=<class 'object'>)
```

将SymPy的矩阵转换为NumPy数组。

另请参阅

[`list2numpy`](#sympy.matrices.dense.list2numpy "sympy.matrices.dense.list2numpy")

```py
sympy.matrices.dense.symarray(prefix, shape, **kwargs)
```

创建一个符号的numpy ndarray（作为对象数组）。

创建的符号命名为`prefix_i1_i2_`… 因此，如果您希望您的符号对于不同的输出数组是唯一的，请提供一个非空前缀，因为SymPy中具有相同名称的符号是相同的对象。

参数：

**prefix** : 字符串

> 附加到每个符号名称前面的前缀。

**shape** : 整数或元组

> 创建的数组的形状。如果是整数，则数组是一维的；对于多于一个维度，形状必须是一个元组。

****kwargs** : 字典

> 传递给Symbol的关键字参数

示例

这些doctest需要numpy。

```py
>>> from sympy import symarray
>>> symarray('', 3)
[_0 _1 _2] 
```

如果您希望多个symarray包含不同的符号，*必须*提供唯一的前缀：

```py
>>> a = symarray('', 3)
>>> b = symarray('', 3)
>>> a[0] == b[0]
True
>>> a = symarray('a', 3)
>>> b = symarray('b', 3)
>>> a[0] == b[0]
False 
```

使用前缀创建symarrays：

```py
>>> symarray('a', 3)
[a_0 a_1 a_2] 
```

对于多于一个维度，形状必须以元组形式给出：

```py
>>> symarray('a', (2, 3))
[[a_0_0 a_0_1 a_0_2]
 [a_1_0 a_1_1 a_1_2]]
>>> symarray('a', (2, 3, 2))
[[[a_0_0_0 a_0_0_1]
 [a_0_1_0 a_0_1_1]
 [a_0_2_0 a_0_2_1]]

 [[a_1_0_0 a_1_0_1]
 [a_1_1_0 a_1_1_1]
 [a_1_2_0 a_1_2_1]]] 
```

用于设置基础符号假设的关键字参数：

```py
>>> [s.is_real for s in symarray('a', 2, real=True)]
[True, True] 
```

```py
sympy.matrices.matrixbase.a2idx(j, n=None)
```

在进行正数验证后返回n的整数。
