- en: Permutation Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html](https://docs.sympy.org/latest/modules/combinatorics/perm_groups.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The class defining a Permutation group.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`PermutationGroup([p1, p2, ..., pn])` returns the permutation group generated
    by the list of permutations. This group can be supplied to Polyhedron if one desires
    to decorate the elements to which the indices of the permutation refer.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The permutations corresponding to motion of the front, right and bottom face
    of a \(2 \times 2\) Rubik’s cube are defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'These are passed as permutations to PermutationGroup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The group can be supplied to a Polyhedron in order to track the objects being
    moved. An example involving the \(2 \times 2\) Rubik’s cube is given there, but
    here is a simple demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Or one can make a permutation as a product of selected permutations and apply
    them to an iterable directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.combinatorics.polyhedron.Polyhedron`](polyhedron.html#sympy.combinatorics.polyhedron.Polyhedron
    "sympy.combinatorics.polyhedron.Polyhedron"), [`sympy.combinatorics.permutations.Permutation`](permutations.html#sympy.combinatorics.permutations.Permutation
    "sympy.combinatorics.permutations.Permutation")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R62](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: Holt, D., Eick, B., O’Brien, E. “Handbook of Computational Group Theory”
  prefs: []
  type: TYPE_NORMAL
- en: '[[R63](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: Seress, A. “Permutation Group Algorithms”
  prefs: []
  type: TYPE_NORMAL
- en: '[[R64](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Schreier_vector](https://en.wikipedia.org/wiki/Schreier_vector)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R65](#id9)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Nielsen_transformation#Product_replacement_algorithm](https://en.wikipedia.org/wiki/Nielsen_transformation#Product_replacement_algorithm)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R66](#id10)]'
  prefs: []
  type: TYPE_NORMAL
- en: Frank Celler, Charles R.Leedham-Green, Scott H.Murray, Alice C.Niemeyer, and
    E.A.O’Brien. “Generating Random Elements of a Finite Group”
  prefs: []
  type: TYPE_NORMAL
- en: '[[R67](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Block_%28permutation_group_theory%29](https://en.wikipedia.org/wiki/Block_%28permutation_group_theory%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R68](#id12)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://algorithmist.com/wiki/Union_find](https://algorithmist.com/wiki/Union_find)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R69](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Multiply_transitive_group#Multiply_transitive_groups](https://en.wikipedia.org/wiki/Multiply_transitive_group#Multiply_transitive_groups)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R70](#id14)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Center_%28group_theory%29](https://en.wikipedia.org/wiki/Center_%28group_theory%29)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if *i* is contained in PermutationGroup.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Return the direct product of two permutation groups as a permutation group.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'This implementation realizes the direct product by shifting the index set for
    the generators of the second group: so if we have `G` acting on `n1` points and
    `H` acting on `n2` points, `G*H` acts on `n1 + n2` points.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The default constructor. Accepts Cycle and Permutation forms. Removes duplicates
    unless `dups` keyword is `False`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: list of weak references to the object
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Return the representative of Hg from the transversal that would be computed
    by `self.coset_transversal(H)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Subroutine to test if there is only one cyclic group for the order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: A test using monte-carlo algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**eps** : float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The criterion for the incorrect `False` return.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**perms** : list[Permutation], optional'
  prefs: []
  type: TYPE_NORMAL
- en: If explicitly given, it tests over the given candidates for testing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If `None`, it randomly computes `N_eps` and chooses `N_eps` sample of the permutation
    from the group.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`_check_cycles_alt_sym`](util.html#sympy.combinatorics.util._check_cycles_alt_sym
    "sympy.combinatorics.util._check_cycles_alt_sym")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: A naive test using the group order.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For an abelian p-group, return the subgroup consisting of all elements of order
    p (and the identity)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Initialize random generators for the product replacement algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The implementation uses a modification of the original product replacement algorithm
    due to Leedham-Green, as described in [1], pp. 69-71; also, see [2], pp. 27-29
    for a detailed theoretical analysis of the original product replacement algorithm,
    and [4].
  prefs: []
  type: TYPE_NORMAL
- en: The product replacement algorithm is used for producing random, uniformly distributed
    elements of a group \(G\) with a set of generators \(S\). For the initialization
    `_random_pr_init`, a list `R` of \(\max\{r, |S|\}\) group generators is created
    as the attribute `G._random_gens`, repeating elements of \(S\) if necessary, and
    the identity element of \(G\) is appended to `R` - we shall refer to this last
    element as the accumulator. Then the function `random_pr()` is called `n` times,
    randomizing the list `R` while preserving the generation of \(G\) by `R`. The
    function `random_pr()` itself takes two random elements `g, h` among all elements
    of `R` but the accumulator and replaces `g` with a randomly chosen element from
    \(\{gh, g(~h), hg, (~h)g\}\). Then the accumulator is multiplied by whatever `g`
    was replaced by. The new value of the accumulator is then returned by `random_pr()`.
  prefs: []
  type: TYPE_NORMAL
- en: The elements returned will eventually (for `n` large enough) become uniformly
    distributed across \(G\) ([5]). For practical purposes however, the values `n
    = 50, r = 11` are suggested in [1].
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'THIS FUNCTION HAS SIDE EFFECTS: it changes the attribute self._random_gens'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`random_pr`](#sympy.combinatorics.perm_groups.PermutationGroup.random_pr "sympy.combinatorics.perm_groups.PermutationGroup.random_pr")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Return a p-Sylow subgroup of a symmetric or an alternating group.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm for this is hinted at in [1], Chapter 4, Exercise 4.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Sym(n) with n = p^i, the idea is as follows. Partition the interval [0..n-1]
    into p equal parts, each of length p^(i-1): [0..p^(i-1)-1], [p^(i-1)..2*p^(i-1)-1]…[(p-1)*p^(i-1)..p^i-1].
    Find a p-Sylow subgroup of Sym(p^(i-1)) (treated as a subgroup of `self`) acting
    on each of the parts. Call the subgroups P_1, P_2…P_p. The generators for the
    subgroups P_2…P_p can be obtained from those of P_1 by applying a “shifting” permutation
    to them, that is, a permutation mapping [0..p^(i-1)-1] to the second part (the
    other parts are obtained by using the shift multiple times). The union of this
    permutation and the generators of P_1 is a p-Sylow subgroup of `self`.'
  prefs: []
  type: TYPE_NORMAL
- en: For n not equal to a power of p, partition [0..n-1] in accordance with how n
    would be written in base p. E.g. for p=2 and n=11, 11 = 2^3 + 2^2 + 1 so the partition
    is [[0..7], [8..9], {10}]. To generate a p-Sylow subgroup, take the union of the
    generators for each of the parts. For the above example, {(0 1), (0 2)(1 3), (0
    4), (1 5)(2 7)} from the first part, {(8 9)} from the second part and nothing
    from the third. This gives 4 generators in total, and the subgroup they generate
    is p-Sylow.
  prefs: []
  type: TYPE_NORMAL
- en: Alternating groups are treated the same except when p=2\. In this case, (0 1)(s
    s+1) should be added for an appropriate s (the start of a part) for each part
    in the partitions.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sylow_subgroup`](#sympy.combinatorics.perm_groups.PermutationGroup.sylow_subgroup
    "sympy.combinatorics.perm_groups.PermutationGroup.sylow_subgroup"), [`is_alt_sym`](#sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym
    "sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Merges two classes in a union-find data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Used in the implementation of Atkinson’s algorithm as suggested in [1], pp.
    83-87\. The class merging process uses union by rank as an optimization. ([7])
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives, `parents`,
    the list of class sizes, `ranks`, and the list of elements that are not representatives,
    `not_rep`, are changed due to class merging.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minimal_block`](#sympy.combinatorics.perm_groups.PermutationGroup.minimal_block
    "sympy.combinatorics.perm_groups.PermutationGroup.minimal_block"), [`_union_find_rep`](#sympy.combinatorics.perm_groups.PermutationGroup._union_find_rep
    "sympy.combinatorics.perm_groups.PermutationGroup._union_find_rep")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R71](#id20)]'
  prefs: []
  type: TYPE_NORMAL
- en: Holt, D., Eick, B., O’Brien, E. “Handbook of computational group theory”
  prefs: []
  type: TYPE_NORMAL
- en: '[[R77](#id21)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://algorithmist.com/wiki/Union_find](https://algorithmist.com/wiki/Union_find)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Find representative of a class in a union-find data structure.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Used in the implementation of Atkinson’s algorithm as suggested in [1], pp.
    83-87\. After the representative of the class to which `num` belongs is found,
    path compression is performed as an optimization ([7]).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'THIS FUNCTION HAS SIDE EFFECTS: the list of class representatives, `parents`,
    is altered due to path compression.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minimal_block`](#sympy.combinatorics.perm_groups.PermutationGroup.minimal_block
    "sympy.combinatorics.perm_groups.PermutationGroup.minimal_block"), [`_union_find_merge`](#sympy.combinatorics.perm_groups.PermutationGroup._union_find_merge
    "sympy.combinatorics.perm_groups.PermutationGroup._union_find_merge")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R73](#id22)]'
  prefs: []
  type: TYPE_NORMAL
- en: Holt, D., Eick, B., O’Brien, E. “Handbook of computational group theory”
  prefs: []
  type: TYPE_NORMAL
- en: '[[R79](#id23)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://algorithmist.com/wiki/Union_find](https://algorithmist.com/wiki/Union_find)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of relators `rels` in generators [PRE22] by `phi` so that given
    a finite presentation <gens_k | rels_k> of `K` on a subset of `gens_h` <gens_h
    | rels_k + rels> is a finite presentation of `H`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`H` should be generated by the union of `K.generators` and `z` (a single generator),
    and `H.stabilizer(alpha) == K`; `phi` is a canonical injection from a free group
    into a permutation group containing `H`.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is described in [1], Chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`strong_presentation`](#sympy.combinatorics.perm_groups.PermutationGroup.strong_presentation
    "sympy.combinatorics.perm_groups.PermutationGroup.strong_presentation"), [`presentation`](#sympy.combinatorics.perm_groups.PermutationGroup.presentation
    "sympy.combinatorics.perm_groups.PermutationGroup.presentation"), [`stabilizer`](#sympy.combinatorics.perm_groups.PermutationGroup.stabilizer
    "sympy.combinatorics.perm_groups.PermutationGroup.stabilizer")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Returns the abelian invariants for the given group. Let `G` be a nontrivial
    finite abelian group. Then G is isomorphic to the direct product of finitely many
    nontrivial cyclic groups of prime-power order.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The prime-powers that occur as the orders of the factors are uniquely determined
    by G. More precisely, the primes that occur in the orders of the factors in any
    such decomposition of `G` are exactly the primes that divide `|G|` and for any
    such prime `p`, if the orders of the factors that are p-groups in one such decomposition
    of `G` are `p^{t_1} >= p^{t_2} >= ... p^{t_r}`, then the orders of the factors
    that are p-groups in any such decomposition of `G` are `p^{t_1} >= p^{t_2} >=
    ... p^{t_r}`.
  prefs: []
  type: TYPE_NORMAL
- en: The uniquely determined integers `p^{t_1} >= p^{t_2} >= ... p^{t_r}`, taken
    for all primes that divide `|G|` are called the invariants of the nontrivial group
    `G` as suggested in ([14], p. 542).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: We adopt the convention that the invariants of a trivial group are [].
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Return a base from the Schreier-Sims algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: For a permutation group \(G\), a base is a sequence of points \(B = (b_1, b_2,
    \dots, b_k)\) such that no element of \(G\) apart from the identity fixes all
    the points in \(B\). The concepts of a base and strong generating set and their
    applications are discussed in depth in [1], pp. 87-89 and [2], pp. 55-57.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative way to think of \(B\) is that it gives the indices of the stabilizer
    cosets that contain more than the identity permutation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`strong_gens`](#sympy.combinatorics.perm_groups.PermutationGroup.strong_gens
    "sympy.combinatorics.perm_groups.PermutationGroup.strong_gens"), [`basic_transversals`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals"), [`basic_orbits`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits"), [`basic_stabilizers`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Swap two consecutive base points in base and strong generating set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**base, strong_gens**'
  prefs: []
  type: TYPE_NORMAL
- en: The base and strong generating set.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**pos**'
  prefs: []
  type: TYPE_NORMAL
- en: The position at which swapping is performed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**randomized**'
  prefs: []
  type: TYPE_NORMAL
- en: A switch between randomized and deterministic version.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**transversals**'
  prefs: []
  type: TYPE_NORMAL
- en: The transversals for the basic orbits, if known.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**basic_orbits**'
  prefs: []
  type: TYPE_NORMAL
- en: The basic orbits, if known.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**strong_gens_distr**'
  prefs: []
  type: TYPE_NORMAL
- en: The strong generators distributed by basic stabilizers, if known.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: (base, strong_gens)
  prefs: []
  type: TYPE_NORMAL
- en: '`base` is the new base, and `strong_gens` is a generating set relative to it.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If a base for a group \(G\) is given by \((b_1, b_2, \dots, b_k)\), this function
    returns a base \((b_1, b_2, \dots, b_{i+1}, b_i, \dots, b_k)\), where \(i\) is
    given by `pos`, and a strong generating set relative to that base. The original
    base and strong generating set are not modified.
  prefs: []
  type: TYPE_NORMAL
- en: The randomized version (default) is of Las Vegas type.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: check that base, gens is a BSGS
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'The deterministic version of the algorithm is discussed in [1], pp. 102-103;
    the randomized version is discussed in [1], p.103, and [2], p.98\. It is of Las
    Vegas type. Notice that [1] contains a mistake in the pseudocode and discussion
    of BASESWAP: on line 3 of the pseudocode, \(|\beta_{i+1}^{\left\langle T\right\rangle}|\)
    should be replaced by \(|\beta_{i}^{\left\langle T\right\rangle}|\), and the same
    for the discussion of the algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`schreier_sims`](#sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims
    "sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Return the basic orbits relative to a base and strong generating set.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If \((b_1, b_2, \dots, b_k)\) is a base for a group \(G\), and \(G^{(i)} = G_{b_1,
    b_2, \dots, b_{i-1}}\) is the `i`-th basic stabilizer (so that \(G^{(1)} = G\)),
    the `i`-th basic orbit relative to this base is the orbit of \(b_i\) under \(G^{(i)}\).
    See [1], pp. 87-89 for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`base`](#sympy.combinatorics.perm_groups.PermutationGroup.base "sympy.combinatorics.perm_groups.PermutationGroup.base"),
    [`strong_gens`](#sympy.combinatorics.perm_groups.PermutationGroup.strong_gens
    "sympy.combinatorics.perm_groups.PermutationGroup.strong_gens"), [`basic_transversals`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals"), [`basic_stabilizers`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Return a chain of stabilizers relative to a base and strong generating set.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The `i`-th basic stabilizer \(G^{(i)}\) relative to a base \((b_1, b_2, \dots,
    b_k)\) is \(G_{b_1, b_2, \dots, b_{i-1}}\). For more information, see [1], pp.
    87-89.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`base`](#sympy.combinatorics.perm_groups.PermutationGroup.base "sympy.combinatorics.perm_groups.PermutationGroup.base"),
    [`strong_gens`](#sympy.combinatorics.perm_groups.PermutationGroup.strong_gens
    "sympy.combinatorics.perm_groups.PermutationGroup.strong_gens"), [`basic_orbits`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits"), [`basic_transversals`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Return basic transversals relative to a base and strong generating set.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The basic transversals are transversals of the basic orbits. They are provided
    as a list of dictionaries, each dictionary having keys - the elements of one of
    the basic orbits, and values - the corresponding transversal elements. See [1],
    pp. 87-89 for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`strong_gens`](#sympy.combinatorics.perm_groups.PermutationGroup.strong_gens
    "sympy.combinatorics.perm_groups.PermutationGroup.strong_gens"), [`base`](#sympy.combinatorics.perm_groups.PermutationGroup.base
    "sympy.combinatorics.perm_groups.PermutationGroup.base"), [`basic_orbits`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits"), [`basic_stabilizers`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Return the center of a permutation group.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The center for a group \(G\) is defined as \(Z(G) = \{z\in G | \forall g\in
    G, zg = gz \}\), the set of elements of \(G\) that commute with all elements of
    \(G\). It is equal to the centralizer of \(G\) inside \(G\), and is naturally
    a subgroup of \(G\) ([9]).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This is a naive implementation that is a straightforward application of `.centralizer()`
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`centralizer`](#sympy.combinatorics.perm_groups.PermutationGroup.centralizer
    "sympy.combinatorics.perm_groups.PermutationGroup.centralizer")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Return the centralizer of a group/set/element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**other**'
  prefs: []
  type: TYPE_NORMAL
- en: a permutation group/list of permutations/single permutation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The centralizer of a set of permutations `S` inside a group `G` is the set
    of elements of `G` that commute with all elements of `S`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Usually, `S` is a subset of `G`, but if `G` is a proper subgroup of the full
    symmetric group, we allow for `S` to have elements outside `G`.
  prefs: []
  type: TYPE_NORMAL
- en: It is naturally a subgroup of `G`; the centralizer of a permutation group is
    equal to the centralizer of any set of generators for that group, since any element
    commuting with the generators commutes with any product of the generators.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is an application of `.subgroup_search()` with tests using
    a specific base for the group `G`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`subgroup_search`](#sympy.combinatorics.perm_groups.PermutationGroup.subgroup_search
    "sympy.combinatorics.perm_groups.PermutationGroup.subgroup_search")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Return the commutator of two subgroups.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: For a permutation group `K` and subgroups `G`, `H`, the commutator of `G` and
    `H` is defined as the group generated by all the commutators \([g, h] = hgh^{-1}g^{-1}\)
    for `g` in `G` and `h` in `H`. It is naturally a subgroup of `K` ([1], p.27).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The commutator of two subgroups \(H, G\) is equal to the normal closure of the
    commutators of all the generators, i.e. \(hgh^{-1}g^{-1}\) for \(h\) a generator
    of \(H\) and \(g\) a generator of \(G\) ([1], p.28)
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`derived_subgroup`](#sympy.combinatorics.perm_groups.PermutationGroup.derived_subgroup
    "sympy.combinatorics.perm_groups.PermutationGroup.derived_subgroup")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Return the composition series for a group as a list of permutation groups.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The composition series for a group \(G\) is defined as a subnormal series \(G
    = H_0 > H_1 > H_2 \ldots\) A composition series is a subnormal series such that
    each factor group \(H(i+1) / H(i)\) is simple. A subnormal series is a composition
    series only if it is of maximum length.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm works as follows: Starting with the derived series the idea is
    to fill the gap between \(G = der[i]\) and \(H = der[i+1]\) for each \(i\) independently.
    Since, all subgroups of the abelian group \(G/H\) are normal so, first step is
    to take the generators \(g\) of \(G\) and add them to generators of \(H\) one
    by one.'
  prefs: []
  type: TYPE_NORMAL
- en: The factor groups formed are not simple in general. Each group is obtained from
    the previous one by adding one generator \(g\), if the previous group is denoted
    by \(H\) then the next group \(K\) is generated by \(g\) and \(H\). The factor
    group \(K/H\) is cyclic and it’s order is \(K.order()//G.order()\). The series
    is then extended between \(K\) and \(H\) by groups generated by powers of \(g\)
    and \(H\). The series formed is then prepended to the already existing series.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Return the conjugacy class of an element in the group.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The conjugacy class of an element `g` in a group `G` is the set of elements
    `x` in `G` that are conjugate with `g`, i.e. for which
  prefs: []
  type: TYPE_NORMAL
- en: '`g = xax^{-1}`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: for some `a` in `G`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that conjugacy is an equivalence relation, and therefore that conjugacy
    classes are partitions of `G`. For a list of all the conjugacy classes of the
    group, use the conjugacy_classes() method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a permutation group, each conjugacy class corresponds to a particular \(cycle
    structure'': for example, in ``S_3`\), the conjugacy classes are:'
  prefs: []
  type: TYPE_NORMAL
- en: the identity class, `{()}`
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: all transpositions, `{(1 2), (1 3), (2 3)}`
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: all 3-cycles, `{(1 2 3), (1 3 2)}`
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This procedure computes the conjugacy class directly by finding the orbit of
    the element under conjugation in G. This algorithm is only feasible for permutation
    groups of relatively small order, but is like the orbit() function itself in that
    respect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Return the conjugacy classes of the group.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: As described in the documentation for the .conjugacy_class() function, conjugacy
    is an equivalence relation on a group G which partitions the set of elements.
    This method returns a list of all these conjugacy classes of G.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Test if permutation `g` belong to self, `G`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If `g` is an element of `G` it can be written as a product of factors drawn
    from the cosets of `G`’s stabilizers. To see if `g` is one of the actual generators
    defining the group use `G.has(g)`.
  prefs: []
  type: TYPE_NORMAL
- en: If `strict` is not `True`, `g` will be resized, if necessary, to match the size
    of permutations in `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If strict is False, a permutation will be resized, if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To test if a given permutation is present in the group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`coset_factor`](#sympy.combinatorics.perm_groups.PermutationGroup.coset_factor
    "sympy.combinatorics.perm_groups.PermutationGroup.coset_factor"), [`sympy.core.basic.Basic.has`](../core.html#sympy.core.basic.Basic.has
    "sympy.core.basic.Basic.has"), [`__contains__`](#sympy.combinatorics.perm_groups.PermutationGroup.__contains__
    "sympy.combinatorics.perm_groups.PermutationGroup.__contains__")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Return `G`’s (self’s) coset factorization of `g`
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If `g` is an element of `G` then it can be written as the product of permutations
    drawn from the Schreier-Sims coset decomposition,
  prefs: []
  type: TYPE_NORMAL
- en: 'The permutations returned in `f` are those for which the product gives `g`:
    `g = f[n]*...f[1]*f[0]` where `n = len(B)` and `B = G.base`. f[i] is one of the
    permutations in `self._basic_orbits[i]`.'
  prefs: []
  type: TYPE_NORMAL
- en: If factor_index==True, returns a tuple `[b[0],..,b[n]]`, where `b[i]` belongs
    to `self._basic_orbits[i]`
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Define g:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that it is an element of G:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, it can be written as a product of factors (up to 3) drawn from u. See
    below that a factor from u1 and u2 and the Identity permutation have been used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If g is not an element of G then [] is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.combinatorics.util._strip`](util.html#sympy.combinatorics.util._strip
    "sympy.combinatorics.util._strip")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: rank using Schreier-Sims representation.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The coset rank of `g` is the ordering number in which it appears in the lexicographic
    listing according to the coset decomposition
  prefs: []
  type: TYPE_NORMAL
- en: The ordering is the same as in G.generate(method=’coset’). If `g` does not belong
    to the group it returns None.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`coset_factor`](#sympy.combinatorics.perm_groups.PermutationGroup.coset_factor
    "sympy.combinatorics.perm_groups.PermutationGroup.coset_factor")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Return the standardised (right) coset table of self in H as a list of lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Return a transversal of the right cosets of self by its subgroup H using the
    second method described in [1], Subsection 4.6.7
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: unrank using Schreier-Sims representation
  prefs: []
  type: TYPE_NORMAL
- en: coset_unrank is the inverse operation of coset_rank if 0 <= rank < order; otherwise
    it returns None.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Returns the size of the permutations in the group.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The number of permutations comprising the group is given by `len(group)`; the
    number of permutations that can be generated by the group is given by `group.order()`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`order`](#sympy.combinatorics.perm_groups.PermutationGroup.order "sympy.combinatorics.perm_groups.PermutationGroup.order")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Return the derived series for the group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of permutation groups containing the members of the derived
  prefs: []
  type: TYPE_NORMAL
- en: series in the order \(G = G_0, G_1, G_2, \ldots\).
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The derived series for a group \(G\) is defined as \(G = G_0 > G_1 > G_2 > \ldots\)
    where \(G_i = [G_{i-1}, G_{i-1}]\), i.e. \(G_i\) is the derived subgroup of \(G_{i-1}\),
    for \(i\in\mathbb{N}\). When we have \(G_k = G_{k-1}\) for some \(k\in\mathbb{N}\),
    the series terminates.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`derived_subgroup`](#sympy.combinatorics.perm_groups.PermutationGroup.derived_subgroup
    "sympy.combinatorics.perm_groups.PermutationGroup.derived_subgroup")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Compute the derived subgroup.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The derived subgroup, or commutator subgroup is the subgroup generated by all
    commutators \([g, h] = hgh^{-1}g^{-1}\) for \(g, h\in G\) ; it is equal to the
    normal closure of the set of commutators of the generators ([1], p.28, [11]).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`derived_series`](#sympy.combinatorics.perm_groups.PermutationGroup.derived_series
    "sympy.combinatorics.perm_groups.PermutationGroup.derived_series")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Returns all the elements of the permutation group as a list
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if PermutationGroup generated by elements in the group are same
    i.e they represent the same PermutationGroup.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Return iterator to generate the elements of the group.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Iteration is done with one of these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: If `af = True` it yields the array form of the permutations
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The permutation group given in the tetrahedron object is also true groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'Also the group generated by the permutations in the tetrahedron pgroup – even
    the first two – is a proper group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Yield group elements using Dimino’s algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: If `af == True` it yields the array form of the permutations.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R75](#id24)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Implementation of Various Algorithms for Permutation Groups in the Computer
    Algebra System: AXIOM, N.J. Doye, M.Sc. Thesis'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Yield group elements using the Schreier-Sims representation in coset_rank order
  prefs: []
  type: TYPE_NORMAL
- en: If `af = True` it yields the array form of the permutations
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of strong generators \([s1, \dots, sn]\) s.t \(g = sn \times \dots
    \times s1\). If `original=True`, make the list contain only the original group
    generators
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Returns the generators of the group.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Return the identity element of the permutation group.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Returns the index of a permutation group.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Test if the group is Abelian.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Monte Carlo test for the symmetric/alternating group for degrees >= 8.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, it is one-sided Monte Carlo with the answer True (i.e., G
    is symmetric/alternating) guaranteed to be correct, and the answer False being
    incorrect with probability eps.
  prefs: []
  type: TYPE_NORMAL
- en: For degree < 8, the order of the group is checked so the test is deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm itself uses some nontrivial results from group theory and number
    theory: 1) If a transitive group `G` of degree `n` contains an element with a
    cycle of length `n/2 < p < n-2` for `p` a prime, `G` is the symmetric or alternating
    group ([1], pp. 81-82) 2) The proportion of elements in the symmetric/alternating
    group having the property described in 1) is approximately \(\log(2)/\log(n)\)
    ([1], p.82; [2], pp. 226-227). The helper function `_check_cycles_alt_sym` is
    used to go over the cycles in a permutation and look for ones satisfying 1).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`_check_cycles_alt_sym`](util.html#sympy.combinatorics.util._check_cycles_alt_sym
    "sympy.combinatorics.util._check_cycles_alt_sym")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if the group is alternating.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This uses a naive test involving the computation of the full group order. If
    you need more quicker taxonomy for large groups, you can use [`PermutationGroup.is_alt_sym()`](#sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym
    "sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym"). However, [`PermutationGroup.is_alt_sym()`](#sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym
    "sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym") may not be accurate
    and is not able to distinguish between an alternating group and a symmetric group.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_alt_sym`](#sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym
    "sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if the group is Cyclic.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: If the order of a group \(n\) can be factored into the distinct primes \(p_1,
    p_2, \dots , p_s\) and if
  prefs: []
  type: TYPE_NORMAL
- en: '\[\forall i, j \in \{1, 2, \dots, s \}: p_i \not \equiv 1 \pmod {p_j}\]'
  prefs: []
  type: TYPE_NORMAL
- en: holds true, there is only one group of the order \(n\) which is a cyclic group
    [[R76]](#r76). This is a generalization of the lemma that the group of order \(15,
    35, \dots\) are cyclic.
  prefs: []
  type: TYPE_NORMAL
- en: And also, these additional lemmas can be used to test if a group is cyclic if
    the order of the group is already found.
  prefs: []
  type: TYPE_NORMAL
- en: If the group is abelian and the order of the group is square-free, the group
    is cyclic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the order of the group is less than \(6\) and is not \(4\), the group is
    cyclic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the order of the group is prime, the group is cyclic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[R76] ([1](#id25),[2](#id26))'
  prefs: []
  type: TYPE_NORMAL
- en: '1978: John S. Rose: A Course on Group Theory, Introduction to Finite Group
    Theory: 1.4'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if the group is dihedral.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[Di1](#id27)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://math.stackexchange.com/questions/827230/given-a-cayley-table-is-there-an-algorithm-to-determine-if-it-is-a-dihedral-gro/827273#827273](https://math.stackexchange.com/questions/827230/given-a-cayley-table-is-there-an-algorithm-to-determine-if-it-is-a-dihedral-gro/827273#827273)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[Di2](#id28)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kconrad.math.uconn.edu/blurbs/grouptheory/dihedral.pdf](https://kconrad.math.uconn.edu/blurbs/grouptheory/dihedral.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[Di3](#id29)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://kconrad.math.uconn.edu/blurbs/grouptheory/dihedral2.pdf](https://kconrad.math.uconn.edu/blurbs/grouptheory/dihedral2.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[Di4](#id30)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Dihedral_group](https://en.wikipedia.org/wiki/Dihedral_group)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if the group is elementary abelian. An elementary abelian group
    is a finite abelian group, where every nontrivial element has order \(p\), where
    \(p\) is a prime.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Test if the group is nilpotent.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A group \(G\) is nilpotent if it has a central series of finite length. Alternatively,
    \(G\) is nilpotent if its lower central series terminates with the trivial group.
    Every nilpotent group is also solvable ([1], p.29, [12]).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`lower_central_series`](#sympy.combinatorics.perm_groups.PermutationGroup.lower_central_series
    "sympy.combinatorics.perm_groups.PermutationGroup.lower_central_series"), [`is_solvable`](#sympy.combinatorics.perm_groups.PermutationGroup.is_solvable
    "sympy.combinatorics.perm_groups.PermutationGroup.is_solvable")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Test if `G=self` is a normal subgroup of `gr`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: G is normal in gr if for each g2 in G, g1 in gr, `g = g1*g2*g1**-1` belongs
    to G It is sufficient to check this for each g1 in gr.generators and g2 in G.generators.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if the group is perfect. A group is perfect if it equals to its
    derived subgroup.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if a group is polycyclic. A group is polycyclic if it has a subnormal
    series with cyclic factors. For finite groups, this is the same as if the group
    is solvable.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Test if a group is primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A permutation group `G` acting on a set `S` is called primitive if `S` contains
    no nontrivial block under the action of `G` (a block is nontrivial if its cardinality
    is more than `1`).
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is described in [1], p.83, and uses the function minimal_block
    to search for blocks of the form \(\{0, k\}\) for `k` ranging over representatives
    for the orbits of \(G_0\), the stabilizer of `0`. This algorithm has complexity
    \(O(n^2)\) where `n` is the degree of the group, and will perform badly if \(G_0\)
    is small.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two implementations offered: one finds \(G_0\) deterministically
    using the function `stabilizer`, and the other (default) produces random elements
    of \(G_0\) using `random_stab`, hoping that they generate a subgroup of \(G_0\)
    with not too many more orbits than \(G_0\) (this is suggested in [1], p.83). Behavior
    is changed by the `randomized` flag.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minimal_block`](#sympy.combinatorics.perm_groups.PermutationGroup.minimal_block
    "sympy.combinatorics.perm_groups.PermutationGroup.minimal_block"), [`random_stab`](#sympy.combinatorics.perm_groups.PermutationGroup.random_stab
    "sympy.combinatorics.perm_groups.PermutationGroup.random_stab")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Test if the group is solvable.
  prefs: []
  type: TYPE_NORMAL
- en: '`G` is solvable if its derived series terminates with the trivial group ([1],
    p.29).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_nilpotent`](#sympy.combinatorics.perm_groups.PermutationGroup.is_nilpotent
    "sympy.combinatorics.perm_groups.PermutationGroup.is_nilpotent"), [`derived_series`](#sympy.combinatorics.perm_groups.PermutationGroup.derived_series
    "sympy.combinatorics.perm_groups.PermutationGroup.derived_series")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if all elements of `self` belong to `G`.
  prefs: []
  type: TYPE_NORMAL
- en: If `strict` is `False` then if `self`’s degree is smaller than `G`’s, the elements
    will be resized to have the same degree.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Testing is strict by default: the degree of each group must be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'To ignore the size, set `strict` to `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Return `True` if the group is symmetric.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This uses a naive test involving the computation of the full group order. If
    you need more quicker taxonomy for large groups, you can use [`PermutationGroup.is_alt_sym()`](#sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym
    "sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym"). However, [`PermutationGroup.is_alt_sym()`](#sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym
    "sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym") may not be accurate
    and is not able to distinguish between an alternating group and a symmetric group.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_alt_sym`](#sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym
    "sympy.combinatorics.perm_groups.PermutationGroup.is_alt_sym")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Test if the group is transitive.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A group is transitive if it has a single orbit.
  prefs: []
  type: TYPE_NORMAL
- en: If `strict` is `False` the group is transitive if it has a single orbit of length
    different from 1.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Test if the group is the trivial group.
  prefs: []
  type: TYPE_NORMAL
- en: This is true if the group contains only the identity permutation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Return the lower central series for the group.
  prefs: []
  type: TYPE_NORMAL
- en: The lower central series for a group \(G\) is the series \(G = G_0 > G_1 > G_2
    > \ldots\) where \(G_k = [G, G_{k-1}]\), i.e. every term after the first is equal
    to the commutator of \(G\) and the previous term in \(G1\) ([1], p.29).
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of permutation groups in the order \(G = G_0, G_1, G_2, \ldots\)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`commutator`](#sympy.combinatorics.perm_groups.PermutationGroup.commutator
    "sympy.combinatorics.perm_groups.PermutationGroup.commutator"), [`derived_series`](#sympy.combinatorics.perm_groups.PermutationGroup.derived_series
    "sympy.combinatorics.perm_groups.PermutationGroup.derived_series")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiply `n` randomly selected permutations from pgroup together, starting
    with the identity permutation. If `n` is a list of integers, those integers will
    be used to select the permutations and they will be applied in L to R order: make_perm((A,
    B, C)) will give CBA(I) where I is the identity permutation.'
  prefs: []
  type: TYPE_NORMAL
- en: '`seed` is used to set the seed for the random selection of permutations from
    pgroup. If this is a list of integers, the corresponding permutations from pgroup
    will be selected in the order give. This is mainly used for testing purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`random`](#sympy.combinatorics.perm_groups.PermutationGroup.random "sympy.combinatorics.perm_groups.PermutationGroup.random")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Maximum proper divisor of the degree of a permutation group.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this is the degree divided by its minimal proper divisor (larger
    than `1`, if one exists). As it is guaranteed to be prime, the `sieve` from `sympy.ntheory`
    is used. This function is also used as an optimization tool for the functions
    `minimal_block` and `_union_find_merge`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minimal_block`](#sympy.combinatorics.perm_groups.PermutationGroup.minimal_block
    "sympy.combinatorics.perm_groups.PermutationGroup.minimal_block"), [`_union_find_merge`](#sympy.combinatorics.perm_groups.PermutationGroup._union_find_merge
    "sympy.combinatorics.perm_groups.PermutationGroup._union_find_merge")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: For a transitive group, finds the block system generated by `points`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If a group `G` acts on a set `S`, a nonempty subset `B` of `S` is called a block
    under the action of `G` if for all `g` in `G` we have `gB = B` (`g` fixes `B`)
    or `gB` and `B` have no common points (`g` moves `B` entirely). ([1], p.23; [6]).
  prefs: []
  type: TYPE_NORMAL
- en: The distinct translates `gB` of a block `B` for `g` in `G` partition the set
    `S` and this set of translates is known as a block system. Moreover, we obviously
    have that all blocks in the partition have the same size, hence the block size
    divides `|S|` ([1], p.23). A `G`-congruence is an equivalence relation `~` on
    the set `S` such that `a ~ b` implies `g(a) ~ g(b)` for all `g` in `G`. For a
    transitive group, the equivalence classes of a `G`-congruence and the blocks of
    a block system are the same thing ([1], p.23).
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm below checks the group for transitivity, and then finds the `G`-congruence
    generated by the pairs `(p_0, p_1), (p_0, p_2), ..., (p_0,p_{k-1})` which is the
    same as finding the maximal block system (i.e., the one with minimum block size)
    such that `p_0, ..., p_{k-1}` are in the same block ([1], p.83).
  prefs: []
  type: TYPE_NORMAL
- en: It is an implementation of Atkinson’s algorithm, as suggested in [1], and manipulates
    an equivalence relation on the set `S` using a union-find data structure. The
    running time is just above \(O(|points||S|)\). ([1], pp. 83-87; [7]).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`_union_find_rep`](#sympy.combinatorics.perm_groups.PermutationGroup._union_find_rep
    "sympy.combinatorics.perm_groups.PermutationGroup._union_find_rep"), [`_union_find_merge`](#sympy.combinatorics.perm_groups.PermutationGroup._union_find_merge
    "sympy.combinatorics.perm_groups.PermutationGroup._union_find_merge"), [`is_transitive`](#sympy.combinatorics.perm_groups.PermutationGroup.is_transitive
    "sympy.combinatorics.perm_groups.PermutationGroup.is_transitive"), [`is_primitive`](#sympy.combinatorics.perm_groups.PermutationGroup.is_primitive
    "sympy.combinatorics.perm_groups.PermutationGroup.is_primitive")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: For a transitive group, return the list of all minimal block systems. If a group
    is intransitive, return \(False\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`minimal_block`](#sympy.combinatorics.perm_groups.PermutationGroup.minimal_block
    "sympy.combinatorics.perm_groups.PermutationGroup.minimal_block"), [`is_transitive`](#sympy.combinatorics.perm_groups.PermutationGroup.is_transitive
    "sympy.combinatorics.perm_groups.PermutationGroup.is_transitive"), [`is_primitive`](#sympy.combinatorics.perm_groups.PermutationGroup.is_primitive
    "sympy.combinatorics.perm_groups.PermutationGroup.is_primitive")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Return the normal closure of a subgroup/set of permutations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**other**'
  prefs: []
  type: TYPE_NORMAL
- en: a subgroup/list of permutations/single permutation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**k**'
  prefs: []
  type: TYPE_NORMAL
- en: an implementation-specific parameter that determines the number of conjugates
    that are adjoined to `other` at once
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If `S` is a subset of a group `G`, the normal closure of `A` in `G` is defined
    as the intersection of all normal subgroups of `G` that contain `A` ([1], p.14).
    Alternatively, it is the group generated by the conjugates `x^{-1}yx` for `x`
    a generator of `G` and `y` a generator of the subgroup `\left\langle S\right\rangle`
    generated by `S` (for some chosen generating set for `\left\langle S\right\rangle`)
    ([1], p.73).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is described in [1], pp. 73-74; it makes use of the generation
    of random elements for permutation groups by the product replacement algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`commutator`](#sympy.combinatorics.perm_groups.PermutationGroup.commutator
    "sympy.combinatorics.perm_groups.PermutationGroup.commutator"), [`derived_subgroup`](#sympy.combinatorics.perm_groups.PermutationGroup.derived_subgroup
    "sympy.combinatorics.perm_groups.PermutationGroup.derived_subgroup"), [`random_pr`](#sympy.combinatorics.perm_groups.PermutationGroup.random_pr
    "sympy.combinatorics.perm_groups.PermutationGroup.random_pr")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Compute the orbit of alpha \(\{g(\alpha) | g \in G\}\) as a set.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The time complexity of the algorithm used here is \(O(|Orb|*r)\) where \(|Orb|\)
    is the size of the orbit and `r` is the number of generators of the group. For
    a more detailed analysis, see [1], p.78, [2], pp. 19-21. Here alpha can be a single
    point, or a list of points.
  prefs: []
  type: TYPE_NORMAL
- en: 'If alpha is a single point, the ordinary orbit is computed. if alpha is a list
    of points, there are three available options:'
  prefs: []
  type: TYPE_NORMAL
- en: ‘union’ - computes the union of the orbits of the points in the list ‘tuples’
    - computes the orbit of the list interpreted as an ordered tuple under the group
    action ( i.e., g((1,2,3)) = (g(1), g(2), g(3)) ) ‘sets’ - computes the orbit of
    the list interpreted as a sets
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`orbit_transversal`](#sympy.combinatorics.perm_groups.PermutationGroup.orbit_transversal
    "sympy.combinatorics.perm_groups.PermutationGroup.orbit_transversal")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Return a group element which sends `alpha` to `beta`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: If `beta` is not in the orbit of `alpha`, the function returns `False`. This
    implementation makes use of the schreier vector. For a proof of correctness, see
    [1], p.80
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`schreier_vector`](#sympy.combinatorics.perm_groups.PermutationGroup.schreier_vector
    "sympy.combinatorics.perm_groups.PermutationGroup.schreier_vector")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Computes a transversal for the orbit of `alpha` as a set.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: For a permutation group \(G\), a transversal for the orbit \(Orb = \{g(\alpha)
    | g \in G\}\) is a set \(\{g_\beta | g_\beta(\alpha) = \beta\}\) for \(\beta \in
    Orb\). Note that there may be more than one possible transversal. If `pairs` is
    set to `True`, it returns the list of pairs \((\beta, g_\beta)\). For a proof
    of correctness, see [1], p.79
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`orbit`](#sympy.combinatorics.perm_groups.PermutationGroup.orbit "sympy.combinatorics.perm_groups.PermutationGroup.orbit")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Return the orbits of `self`, ordered according to lowest element in each orbit.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the order of the group: the number of permutations that can be generated
    from elements of the group.'
  prefs: []
  type: TYPE_NORMAL
- en: The number of permutations comprising the group is given by `len(group)`; the
    length of each permutation in the group is given by `group.size`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`degree`](#sympy.combinatorics.perm_groups.PermutationGroup.degree "sympy.combinatorics.perm_groups.PermutationGroup.degree")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Return the pointwise stabilizer for a set of points.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: For a permutation group \(G\) and a set of points \(\{p_1, p_2,\ldots, p_k\}\),
    the pointwise stabilizer of \(p_1, p_2, \ldots, p_k\) is defined as \(G_{p_1,\ldots,
    p_k} = \{g\in G | g(p_i) = p_i \forall i\in\{1, 2,\ldots,k\}\}\) ([1],p20). It
    is a subgroup of \(G\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: When incremental == True, rather than the obvious implementation using successive
    calls to `.stabilizer()`, this uses the incremental Schreier-Sims algorithm to
    obtain a base with starting segment - the given points.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`stabilizer`](#sympy.combinatorics.perm_groups.PermutationGroup.stabilizer
    "sympy.combinatorics.perm_groups.PermutationGroup.stabilizer"), [`schreier_sims_incremental`](#sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_incremental
    "sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_incremental")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Return the PolycyclicGroup instance with below parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'pc_sequence : Polycyclic sequence is formed by collecting all the missing generators
    between the adjacent groups in the derived series of given permutation group.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'pc_series : Polycyclic series is formed by adding all the missing generators
    of `der[i+1]` in `der[i]`, where `der` represents the derived series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'relative_order : A list, computed by the ratio of adjacent groups in pc_series.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Return an \(FpGroup\) presentation of the group.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is described in [1], Chapter 6.1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Return a random group element
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Return a random group element using product replacement.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: For the details of the product replacement algorithm, see `_random_pr_init`
    In `random_pr` the actual ‘product replacement’ is performed. Notice that if the
    attribute `_random_gens` is empty, it needs to be initialized by `_random_pr_init`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`_random_pr_init`](#sympy.combinatorics.perm_groups.PermutationGroup._random_pr_init
    "sympy.combinatorics.perm_groups.PermutationGroup._random_pr_init")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: Random element from the stabilizer of `alpha`.
  prefs: []
  type: TYPE_NORMAL
- en: The schreier vector for `alpha` is an optional argument used for speeding up
    repeated calls. The algorithm is described in [1], p.81
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`random_pr`](#sympy.combinatorics.perm_groups.PermutationGroup.random_pr "sympy.combinatorics.perm_groups.PermutationGroup.random_pr"),
    [`orbit_rep`](#sympy.combinatorics.perm_groups.PermutationGroup.orbit_rep "sympy.combinatorics.perm_groups.PermutationGroup.orbit_rep")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Schreier-Sims algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: It computes the generators of the chain of stabilizers \(G > G_{b_1} > .. >
    G_{b1,..,b_r} > 1\) in which \(G_{b_1,..,b_i}\) stabilizes \(b_1,..,b_i\), and
    the corresponding `s` cosets. An element of the group can be written as the product
    \(h_1*..*h_s\).
  prefs: []
  type: TYPE_NORMAL
- en: We use the incremental Schreier-Sims algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Extend a sequence of points and generating set to a base and strong generating
    set.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**base**'
  prefs: []
  type: TYPE_NORMAL
- en: The sequence of points to be extended to a base. Optional parameter with default
    value `[]`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**gens**'
  prefs: []
  type: TYPE_NORMAL
- en: The generating set to be extended to a strong generating set relative to the
    base obtained. Optional parameter with default value `self.generators`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**slp_dict**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If \(True\), return a dictionary \({g: gens}\) for each strong generator \(g\)
    where \(gens\) is a list of strong generators coming before \(g\) in \(strong_gens\),
    such that the product of the elements of \(gens\) is equal to \(g\).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: (base, strong_gens)
  prefs: []
  type: TYPE_NORMAL
- en: '`base` is the base obtained, and `strong_gens` is the strong generating set
    relative to it. The original parameters `base`, `gens` remain unchanged.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This version of the Schreier-Sims algorithm runs in polynomial time. There are
    certain assumptions in the implementation - if the trivial group is provided,
    `base` and `gens` are returned immediately, as any sequence of points is a base
    for the trivial group. If the identity is present in the generators `gens`, it
    is removed as it is a redundant generator. The implementation is described in
    [1], pp. 90-93.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`schreier_sims`](#sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims
    "sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims"), [`schreier_sims_random`](#sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_random
    "sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims_random")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Randomized Schreier-Sims algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**base**'
  prefs: []
  type: TYPE_NORMAL
- en: The sequence to be extended to a base.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**gens**'
  prefs: []
  type: TYPE_NORMAL
- en: The generating set to be extended to a strong generating set.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**consec_succ**'
  prefs: []
  type: TYPE_NORMAL
- en: The parameter defining the probability of a wrong answer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**_random_prec**'
  prefs: []
  type: TYPE_NORMAL
- en: An internal parameter used for testing purposes.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: (base, strong_gens)
  prefs: []
  type: TYPE_NORMAL
- en: '`base` is the base and `strong_gens` is the strong generating set relative
    to it.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The randomized Schreier-Sims algorithm takes the sequence `base` and the generating
    set `gens`, and extends `base` to a base, and `gens` to a strong generating set
    relative to that base with probability of a wrong answer at most \(2^{-consec\_succ}\),
    provided the random generators are sufficiently random.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is described in detail in [1], pp. 97-98\. It extends the orbits
    `orbs` and the permutation groups `stabs` to basic orbits and basic stabilizers
    for the base and strong generating set produced in the end. The idea of the extension
    process is to “sift” random group elements through the stabilizer chain and amend
    the stabilizers/orbits along the way when a sift is not successful. The helper
    function `_strip` is used to attempt to decompose a random group element according
    to the current state of the stabilizer chain and report whether the element was
    fully decomposed (successful sift) or not (unsuccessful sift). In the latter case,
    the level at which the sift failed is reported and used to amend `stabs`, `base`,
    `gens` and `orbs` accordingly. The halting condition is for `consec_succ` consecutive
    successful sifts to pass. This makes sure that the current `base` and `gens` form
    a BSGS with probability at least \(1 - 1/\text{consec\_succ}\).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`schreier_sims`](#sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims
    "sympy.combinatorics.perm_groups.PermutationGroup.schreier_sims")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Computes the schreier vector for `alpha`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The Schreier vector efficiently stores information about the orbit of `alpha`.
    It can later be used to quickly obtain elements of the group that send `alpha`
    to a particular element in the orbit. Notice that the Schreier vector depends
    on the order in which the group generators are listed. For a definition, see [3].
    Since list indices start from zero, we adopt the convention to use “None” instead
    of 0 to signify that an element does not belong to the orbit. For the algorithm
    and its correctness, see [2], pp.78-80.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`orbit`](#sympy.combinatorics.perm_groups.PermutationGroup.orbit "sympy.combinatorics.perm_groups.PermutationGroup.orbit")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Return the stabilizer subgroup of `alpha`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The stabilizer of \(\alpha\) is the group \(G_\alpha = \{g \in G | g(\alpha)
    = \alpha\}\). For a proof of correctness, see [1], p.79.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`orbit`](#sympy.combinatorics.perm_groups.PermutationGroup.orbit "sympy.combinatorics.perm_groups.PermutationGroup.orbit")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: Return a strong generating set from the Schreier-Sims algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A generating set \(S = \{g_1, g_2, \dots, g_t\}\) for a permutation group \(G\)
    is a strong generating set relative to the sequence of points (referred to as
    a “base”) \((b_1, b_2, \dots, b_k)\) if, for \(1 \leq i \leq k\) we have that
    the intersection of the pointwise stabilizer \(G^{(i+1)} := G_{b_1, b_2, \dots,
    b_i}\) with \(S\) generates the pointwise stabilizer \(G^{(i+1)}\). The concepts
    of a base and strong generating set and their applications are discussed in depth
    in [1], pp. 87-89 and [2], pp. 55-57.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`base`](#sympy.combinatorics.perm_groups.PermutationGroup.base "sympy.combinatorics.perm_groups.PermutationGroup.base"),
    [`basic_transversals`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_transversals"), [`basic_orbits`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_orbits"), [`basic_stabilizers`](#sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers
    "sympy.combinatorics.perm_groups.PermutationGroup.basic_stabilizers")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Return a strong finite presentation of group. The generators of the returned
    group are in the same order as the strong generators of group.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is based on Sims’ Verify algorithm described in [1], Chapter 6.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`presentation`](#sympy.combinatorics.perm_groups.PermutationGroup.presentation
    "sympy.combinatorics.perm_groups.PermutationGroup.presentation"), [`_verify`](#sympy.combinatorics.perm_groups.PermutationGroup._verify
    "sympy.combinatorics.perm_groups.PermutationGroup._verify")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Return the subgroup generated by \(gens\) which is a list of elements of the
    group
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Find the subgroup of all elements satisfying the property `prop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**prop**'
  prefs: []
  type: TYPE_NORMAL
- en: The property to be used. Has to be callable on group elements and always return
    `True` or `False`. It is assumed that all group elements satisfying `prop` indeed
    form a subgroup.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**base**'
  prefs: []
  type: TYPE_NORMAL
- en: A base for the supergroup.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**strong_gens**'
  prefs: []
  type: TYPE_NORMAL
- en: A strong generating set for the supergroup.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**tests**'
  prefs: []
  type: TYPE_NORMAL
- en: A list of callables of length equal to the length of `base`. These are used
    to rule out group elements by partial base images, so that `tests[l](g)` returns
    False if the element `g` is known not to satisfy prop base on where g sends the
    first `l + 1` base points.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**init_subgroup**'
  prefs: []
  type: TYPE_NORMAL
- en: if a subgroup of the sought group is known in advance, it can be passed to the
    function as this parameter.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: res
  prefs: []
  type: TYPE_NORMAL
- en: The subgroup of all elements satisfying `prop`. The generating set for this
    group is guaranteed to be a strong generating set relative to the base `base`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This is done by a depth-first search with respect to base images that uses several
    tests to prune the search tree.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This function is extremely lengthy and complicated and will require some careful
    attention. The implementation is described in [1], pp. 114-117, and the comments
    for the code here follow the lines of the pseudocode in the book for clarity.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity is exponential in general, since the search process by itself
    visits all members of the supergroup. However, there are a lot of tests which
    are used to prune the search tree, and users can define their own tests via the
    `tests` parameter, so in practice, and for some computations, it’s not terrible.
  prefs: []
  type: TYPE_NORMAL
- en: A crucial part in the procedure is the frequent base change performed (this
    is line 11 in the pseudocode) in order to obtain a new basic stabilizer. The book
    mentiones that this can be done by using `.baseswap(...)`, however the current
    implementation uses a more straightforward way to find the next basic stabilizer
    - calling the function `.stabilizer(...)` on the previous basic stabilizer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Return a p-Sylow subgroup of the group.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm is described in [1], Chapter 4, Section 7
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Compute the degree of transitivity of the group.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A permutation group \(G\) acting on \(\Omega = \{0, 1, \dots, n-1\}\) is `k`-fold
    transitive, if, for any \(k\) points \((a_1, a_2, \dots, a_k) \in \Omega\) and
    any \(k\) points \((b_1, b_2, \dots, b_k) \in \Omega\) there exists \(g \in G\)
    such that \(g(a_1) = b_1, g(a_2) = b_2, \dots, g(a_k) = b_k\) The degree of transitivity
    of \(G\) is the maximum `k` such that \(G\) is `k`-fold transitive. ([8])
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_transitive`](#sympy.combinatorics.perm_groups.PermutationGroup.is_transitive
    "sympy.combinatorics.perm_groups.PermutationGroup.is_transitive"), [`orbit`](#sympy.combinatorics.perm_groups.PermutationGroup.orbit
    "sympy.combinatorics.perm_groups.PermutationGroup.orbit")'
  prefs: []
  type: TYPE_NORMAL
