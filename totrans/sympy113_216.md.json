["```py\nsympy.physics.quantum.represent.enumerate_states(*args, **options)\n```", "```py\n>>> from sympy.physics.quantum.cartesian import XBra, XKet\n>>> from sympy.physics.quantum.represent import enumerate_states\n>>> test = XKet('foo')\n>>> enumerate_states(test, 1, 3)\n[|foo_1>, |foo_2>, |foo_3>]\n>>> test2 = XBra('bar')\n>>> enumerate_states(test2, [4, 5, 10])\n[<bar_4|, <bar_5|, <bar_10|] \n```", "```py\nsympy.physics.quantum.represent.get_basis(expr, *, basis=None, replace_none=True, **options)\n```", "```py\n>>> from sympy.physics.quantum.represent import get_basis\n>>> from sympy.physics.quantum.cartesian import XOp, XKet, PxOp, PxKet\n>>> x = XKet()\n>>> X = XOp()\n>>> get_basis(x)\n|x>\n>>> get_basis(X)\n|x>\n>>> get_basis(x, basis=PxOp())\n|px>\n>>> get_basis(x, basis=PxKet)\n|px> \n```", "```py\nsympy.physics.quantum.represent.integrate_result(orig_expr, result, **options)\n```", "```py\n>>> from sympy import symbols, DiracDelta\n>>> from sympy.physics.quantum.represent import integrate_result\n>>> from sympy.physics.quantum.cartesian import XOp, XKet\n>>> x_ket = XKet()\n>>> X_op = XOp()\n>>> x, x_1, x_2 = symbols('x, x_1, x_2')\n>>> integrate_result(X_op*x_ket, x*DiracDelta(x-x_1)*DiracDelta(x_1-x_2))\nx*DiracDelta(x - x_1)*DiracDelta(x_1 - x_2)\n>>> integrate_result(X_op*x_ket, x*DiracDelta(x-x_1)*DiracDelta(x_1-x_2),\n...     unities=[1])\nx*DiracDelta(x - x_2) \n```", "```py\nsympy.physics.quantum.represent.rep_expectation(expr, **options)\n```", "```py\n>>> from sympy.physics.quantum.cartesian import XOp, PxOp, PxKet\n>>> from sympy.physics.quantum.represent import rep_expectation\n>>> rep_expectation(XOp())\nx_1*DiracDelta(x_1 - x_2)\n>>> rep_expectation(XOp(), basis=PxOp())\n<px_2|*X*|px_1>\n>>> rep_expectation(XOp(), basis=PxKet())\n<px_2|*X*|px_1> \n```", "```py\nsympy.physics.quantum.represent.rep_innerproduct(expr, **options)\n```", "```py\n>>> from sympy.physics.quantum.represent import rep_innerproduct\n>>> from sympy.physics.quantum.cartesian import XOp, XKet, PxOp, PxKet\n>>> rep_innerproduct(XKet())\nDiracDelta(x - x_1)\n>>> rep_innerproduct(XKet(), basis=PxOp())\nsqrt(2)*exp(-I*px_1*x/hbar)/(2*sqrt(hbar)*sqrt(pi))\n>>> rep_innerproduct(PxKet(), basis=XOp())\nsqrt(2)*exp(I*px*x_1/hbar)/(2*sqrt(hbar)*sqrt(pi)) \n```", "```py\nsympy.physics.quantum.represent.represent(expr, **options)\n```", "```py\ndef _represent_FooBasis(self, e, basis, **options) \n```", "```py\n>>> from sympy.physics.quantum import Operator, represent, Ket\n>>> from sympy import Matrix \n```", "```py\n>>> class SzUpKet(Ket):\n...     def _represent_SzOp(self, basis, **options):\n...         return Matrix([1,0])\n...\n>>> class SzOp(Operator):\n...     pass\n...\n>>> sz = SzOp('Sz')\n>>> up = SzUpKet('up')\n>>> represent(up, basis=sz)\nMatrix([\n[1],\n[0]]) \n```", "```py\n>>> from sympy.physics.quantum.cartesian import XOp, XKet, XBra\n>>> X = XOp()\n>>> x = XKet()\n>>> y = XBra('y')\n>>> represent(X*x)\nx*DiracDelta(x - x_2)\n>>> represent(X*x*y)\nx*DiracDelta(x - x_3)*DiracDelta(x_1 - y) \n```"]