# 数论

> 原文链接：[https://docs.sympy.org/latest/modules/ntheory.html](https://docs.sympy.org/latest/modules/ntheory.html)

## Ntheory 类参考

```py
class sympy.ntheory.generate.Sieve(sieve_interval=1000000)
```

质数列表，实现为动态增长的埃拉托斯特尼筛。当请求涉及尚未筛选的奇数时，筛网自动扩展至该数。实现细节限制了质数数量为 `2^32-1`。

示例

```py
>>> from sympy import sieve
>>> sieve._reset() # this line for doctest only
>>> 25 in sieve
False
>>> sieve._list
array('L', [2, 3, 5, 7, 11, 13, 17, 19, 23]) 
```

```py
extend(n)
```

扩展筛以涵盖所有小于等于 n 的质数。

示例

```py
>>> from sympy import sieve
>>> sieve._reset() # this line for doctest only
>>> sieve.extend(30)
>>> sieve[10] == 29
True 
```

```py
extend_to_no(i)
```

扩展以包括第 i 个质数。

参数：

**i**：整数

示例

```py
>>> from sympy import sieve
>>> sieve._reset() # this line for doctest only
>>> sieve.extend_to_no(9)
>>> sieve._list
array('L', [2, 3, 5, 7, 11, 13, 17, 19, 23]) 
```

注意事项

如果列表过短，会增加 50%，因此它很可能比请求的要长。

```py
mobiusrange(a, b)
```

生成范围 [a, b) 内的所有莫比乌斯函数数。

参数：

**a**：整数

> 范围内的第一个数字

**b**：整数

> 超出范围的第一个数字

示例

```py
>>> from sympy import sieve
>>> print([i for i in sieve.mobiusrange(7, 18)])
[-1, 0, 0, 1, -1, 0, -1, 1, 1, 0, -1] 
```

```py
primerange(a, b=None)
```

生成范围 [2, a) 或 [a, b) 内的所有质数。

示例

```py
>>> from sympy import sieve, prime 
```

小于 19 的所有质数：

```py
>>> print([i for i in sieve.primerange(19)])
[2, 3, 5, 7, 11, 13, 17] 
```

大于等于 7 且小于 19 的所有质数：

```py
>>> print([i for i in sieve.primerange(7, 19)])
[7, 11, 13, 17] 
```

通过第 10 个质数的所有质数

```py
>>> list(sieve.primerange(prime(10) + 1))
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29] 
```

```py
search(n)
```

返回界定 n 的质数的索引 i, j。

如果 n 是质数，则 i == j。

虽然 n 可以是一个表达式，但如果 ceiling 不能将其转换为整数，则会引发一个 n 错误。

示例

```py
>>> from sympy import sieve
>>> sieve.search(25)
(9, 10)
>>> sieve.search(23)
(9, 9) 
```

```py
totientrange(a, b)
```

生成范围 [a, b) 内的所有欧拉函数数。

示例

```py
>>> from sympy import sieve
>>> print([i for i in sieve.totientrange(7, 18)])
[6, 4, 6, 4, 10, 4, 12, 6, 8, 8, 16] 
```

## Ntheory 函数参考

```py
sympy.ntheory.generate.prime(nth)
```

返回第 n 个质数，质数索引为 prime(1) = 2, prime(2) = 3，等等… 第 n 个质数大约是 \(n\log(n)\)。

对于 x 的对数积分是小于等于 x 的质数数的一个相当不错的近似值，即 li(x) ~ pi(x) 实际上，对于我们关心的数字（ x<1e11 ），li(x) - pi(x) < 50000

此外，可以安全地假设对于此函数可以评估的数字，li(x) > pi(x)。

在这里，我们使用二分查找找到最小的整数 m，使得 li(m) > n。现在 pi(m-1) < li(m-1) <= n，

我们使用 `primepi` 函数找到 pi(m - 1)。

从 m 开始，我们必须找到 n - pi(m-1) 更多的质数。

对于此实现可以处理的输入，我们最多需要测试约 10**5 个数的素性以获得答案。

示例

```py
>>> from sympy import prime
>>> prime(10)
29
>>> prime(1)
2
>>> prime(100000)
1299709 
```

另请参阅

[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")

测试 n 是否为质数

[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")

在给定范围内生成所有质数

[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")

返回小于或等于 n 的质数的数量

参考资料

[[R648](#id1)]

[https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29](https://en.wikipedia.org/wiki/Prime_number_theorem#Table_of_.CF.80.28x.29.2C_x_.2F_log_x.2C_and_li.28x.29)

[[R649](#id2)]

[https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number](https://en.wikipedia.org/wiki/Prime_number_theorem#Approximations_for_the_nth_prime_number)

[[R650](#id3)]

[https://en.wikipedia.org/wiki/Skewes%27_number](https://en.wikipedia.org/wiki/Skewes%27_number)

```py
sympy.ntheory.generate.primepi(n)
```

表示质数计数函数pi(n) = 小于或等于n的质数的数量。

自版本1.13开始不推荐使用：`primepi`函数已弃用。请改用[`sympy.functions.combinatorial.numbers.primepi`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primepi "sympy.functions.combinatorial.numbers.primepi")。有关更多信息，请参阅其文档。有关详细信息，请参阅[从ntheory移动到functions的符号函数](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。

算法描述：

在筛法中，我们移除所有质数p的倍数，除了p本身。

让phi(i,j)为从小于或等于j的质数中筛除后剩余的2 <= k <= i的整数数量。显然，pi(n) = phi(n, sqrt(n))

如果j不是一个质数，phi(i,j) = phi(i, j - 1)

如果j是一个质数，我们删除所有最小质因数为j的数（除了j本身）。

让\(x= j \times a\)为这样一个数，其中\(2 \le a \le i / j\)。现在，在从质数\(\le j - 1\)中筛选后，a必须保留（因为x，因此a没有质因数\(\le j - 1\)）。显然，有phi(i / j, j - 1)个这样的a在从质数\(\le j - 1\)中筛选后保留。

如果a是小于等于j-1的质数，\(x= j \times a\) 的最小质因数为a，并且已经被移除（通过筛法从a中）。因此，我们不需要再次移除它。（注意：这样的x有pi(j-1)个）

因此，将被移除的x的数量为：phi(i / j, j - 1) - phi(j - 1, j - 1)（注意pi(j - 1) = phi(j - 1, j - 1)）

\(\Rightarrow\) phi(i,j) = phi(i, j - 1) - phi(i / j, j - 1) + phi(j - 1, j - 1)

因此，使用以下递归并实现dp：

phi(a, b) = phi(a, b - 1)，如果b不是质数phi(a, b) = phi(a, b-1)-phi(a / b, b-1) + phi(b-1, b-1)，如果b是质数

显然a总是形式为floor(n / k)，最多可以取\(2\sqrt{n}\)个值。维护两个数组arr1，arr2，arr1[i] = phi(i, j)，arr2[i] = phi(n // i, j)

最后的答案是arr2[1]

示例

```py
>>> from sympy import primepi, prime, prevprime, isprime
>>> primepi(25)
9 
```

因此，小于或等于25的有9个质数。25是质数吗？

```py
>>> isprime(25)
False 
```

不是。因此，小于25的第一个质数必须是第9个质数：

```py
>>> prevprime(25) == prime(9)
True 
```

参见

[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")

测试n是否为质数

[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")

在给定范围内生成所有的质数

[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")

返回第n个质数

```py
sympy.ntheory.generate.nextprime(n, ith=1)
```

返回大于n的第ith个质数。

参数：

**n** : 整数

**ith** : 正整数

返回：

**int** : 返回大于n的第ith个质数

异常：

**ValueError**

> 如果`ith <= 0`。如果`n`或`ith`不是整数。

注意

潜在的质数位于6*j +/- 1。这个性质在搜索中被使用。

```py
>>> from sympy import nextprime
>>> [(i, nextprime(i)) for i in range(10, 15)]
[(10, 11), (11, 13), (12, 13), (13, 17), (14, 17)]
>>> nextprime(2, ith=2) # the 2nd prime after 2
5 
```

参见

[`prevprime`](#sympy.ntheory.generate.prevprime "sympy.ntheory.generate.prevprime")

返回小于 n 的最大素数

[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")

生成给定范围内的所有素数

```py
sympy.ntheory.generate.prevprime(n)
```

返回小于 n 的最大素数。

注释

潜在的素数位于 6*j +/- 1。这个性质在搜索时使用。

```py
>>> from sympy import prevprime
>>> [(i, prevprime(i)) for i in range(10, 15)]
[(10, 7), (11, 7), (12, 11), (13, 11), (14, 13)] 
```

另请参阅

[`nextprime`](#sympy.ntheory.generate.nextprime "sympy.ntheory.generate.nextprime")

返回大于 n 的第 i 个素数

[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")

生成给定范围内的所有素数

```py
sympy.ntheory.generate.primerange(a, b=None)
```

生成范围为 [2, a) 或 [a, b) 的所有素数列表。

如果默认筛选器中存在范围，则将从那里返回值；否则将返回值但不会修改筛选器。

示例

```py
>>> from sympy import primerange, prime 
```

小于 19 的所有素数：

```py
>>> list(primerange(19))
[2, 3, 5, 7, 11, 13, 17] 
```

大于或等于 7 且小于 19 的所有素数：

```py
>>> list(primerange(7, 19))
[7, 11, 13, 17] 
```

所有小于第 10 个素数的素数

```py
>>> list(primerange(prime(10) + 1))
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29] 
```

筛法方法 primerange 通常更快，但由于筛选器存储值，内存占用更多。可以使用名为 sieve 的默认筛选器实例：

```py
>>> from sympy import sieve
>>> list(sieve.primerange(1, 30))
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29] 
```

注释

一些关于素数出现频率的著名猜想是 [1]：

+   孪生素数：尽管经常不是，以下将给出两个素数

    无限次数：

    primerange(6*n - 1, 6*n + 2)

+   勒让德定理：以下始终至少产生一个素数

    primerange(n**2, (n+1)**2+1)

+   贝特朗定理（已证明）：在范围内总是有一个素数

    primerange(n, 2*n)

+   布洛卡德定理：在给定范围内至少有四个素数

    primerange(prime(n)**2, prime(n+1)**2)

素数之间的平均间隔是 log(n) [2]；素数之间的间隔可以任意大，因为合数序列可以任意大，例如序列 n! + 2, n! + 3 … n! + n 中的数字都是合数。

另请参阅

[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")

返回第 n 个素数

[`nextprime`](#sympy.ntheory.generate.nextprime "sympy.ntheory.generate.nextprime")

返回大于 n 的第 i 个素数

[`prevprime`](#sympy.ntheory.generate.prevprime "sympy.ntheory.generate.prevprime")

返回小于 n 的最大素数

[`randprime`](#sympy.ntheory.generate.randprime "sympy.ntheory.generate.randprime")

返回给定范围内的随机素数

[`primorial`](#sympy.ntheory.generate.primorial "sympy.ntheory.generate.primorial")

基于条件返回素数的乘积

[`Sieve.primerange`](#sympy.ntheory.generate.Sieve.primerange "sympy.ntheory.generate.Sieve.primerange")

返回从已计算的素数范围或扩展筛选器以包含所请求范围的范围。

参考文献

[[R651](#id4)]

[https://en.wikipedia.org/wiki/Prime_number](https://en.wikipedia.org/wiki/Prime_number)

[[R652](#id5)]

[https://primes.utm.edu/notes/gaps.html](https://primes.utm.edu/notes/gaps.html)

```py
sympy.ntheory.generate.randprime(a, b)
```

返回在区间 [a, b) 中的随机素数。

贝特朗定理确保 randprime(a, 2*a) 对于 a > 1 总是成功。

请注意，由于实现困难，选择的素数不是均匀随机的。例如，在范围 [112, 128) 中有两个素数 `113` 和 `127`，但 `randprime(112, 128)` 以 15/17 的概率返回 `127`。

示例

```py
>>> from sympy import randprime, isprime
>>> randprime(1, 30) 
13
>>> isprime(randprime(1, 30))
True 
```

另请参阅

[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")

在给定范围内生成所有素数

参考资料

[[R653](#id6)]

[https://zh.wikipedia.org/wiki/贝特朗假设](https://zh.wikipedia.org/wiki/贝特朗假设)

```py
sympy.ntheory.generate.primorial(n, nth=True)
```

返回前 n 个素数的乘积（默认）或小于等于 n 的素数（当 `nth=False` 时）。

示例

```py
>>> from sympy.ntheory.generate import primorial, primerange
>>> from sympy import factorint, Mul, primefactors, sqrt
>>> primorial(4) # the first 4 primes are 2, 3, 5, 7
210
>>> primorial(4, nth=False) # primes <= 4 are 2 and 3
6
>>> primorial(1)
2
>>> primorial(1, nth=False)
1
>>> primorial(sqrt(101), nth=False)
210 
```

人们可以认为素数是无限的，因为如果你取一组素数并将它们相乘（例如，素数阶乘），然后加或减 1，结果不能被任何原始因子之一整除，因此这个素数的乘积必须被除以1或多个新的素数。

在这种情况下，数本身是一个新的素数：

```py
>>> factorint(primorial(4) + 1)
{211: 1} 
```

在这种情况下，两个新的素数是因子：

```py
>>> factorint(primorial(4) - 1)
{11: 1, 19: 1} 
```

这里，乘在一起的素数比这些素数更大或更小：

```py
>>> p = list(primerange(10, 20))
>>> sorted(set(primefactors(Mul(*p) + 1)).difference(set(p)))
[2, 5, 31, 149] 
```

另请参阅

[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")

在给定范围内生成所有素数

```py
sympy.ntheory.generate.cycle_length(f, x0, nmax=None, values=False)
```

对于给定的迭代序列，返回一个生成器，提供迭代周期的长度（lambda）和循环开始之前的项的长度（mu）；如果 `values` 为 True，则将返回序列的项。序列以值 `x0` 开始。

注意：可能会返回多于第一个 lambda + mu 项，这是使用布伦特方法进行循环检测的成本；然而，通常比使用弗洛伊德方法确定的正确结束点计算的项要少。

```py
>>> from sympy.ntheory.generate import cycle_length 
```

这将产生 i <– func(i) 的连续值：

```py
>>> def gen(func, i):
...     while 1:
...         yield i
...         i = func(i)
... 
```

函数定义如下：

```py
>>> func = lambda i: (i**2 + 1) % 51 
```

并给定种子 4 和计算的 mu 和 lambda 项：

```py
>>> next(cycle_length(func, 4))
(6, 3) 
```

我们可以看到输出的含义：

```py
>>> iter = cycle_length(func, 4, values=True)
>>> list(iter)
[4, 17, 35, 2, 5, 26, 14, 44, 50, 2, 5, 26, 14] 
```

第一个 3 之后有 6 个重复值。

如果怀疑一个序列的长度比你希望的长，可以使用 `nmax` 提前退出（mu 将返回为 None）：

```py
>>> next(cycle_length(func, 4, nmax = 4))
(4, None)
>>> list(cycle_length(func, 4, nmax = 4, values=True))
[4, 17, 35, 2] 
```

代码修改自：

[https://zh.wikipedia.org/wiki/循环检测](https://zh.wikipedia.org/wiki/循环检测)。

```py
sympy.ntheory.generate.composite(nth)
```

返回第 n 个复合数，其中复合数索引为 composite(1) = 4，composite(2) = 6，等等……

示例

```py
>>> from sympy import composite
>>> composite(36)
52
>>> composite(1)
4
>>> composite(17737)
20000 
```

另请参阅

[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")

测试 n 是否为素数

[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")

在给定范围内生成所有素数

[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")

返回小于或等于 n 的素数的数量

[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")

返回第 n 个素数

[`compositepi`](#sympy.ntheory.generate.compositepi "sympy.ntheory.generate.compositepi")

返回小于或等于 `n` 的正复合数的数量

```py
sympy.ntheory.generate.compositepi(n)
```

返回小于或等于 `n` 的正复合数的数量。第一个正复合数是 `4`，即 `compositepi(4) = 1`。

示例

```py
>>> from sympy import compositepi
>>> compositepi(25)
15
>>> compositepi(1000)
831 
```

另见

[`sympy.ntheory.primetest.isprime`](#sympy.ntheory.primetest.isprime "sympy.ntheory.primetest.isprime")

测试 `n` 是否为素数

[`primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")

在给定范围内生成所有素数

[`prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")

返回第 `n` 个质数

[`primepi`](#sympy.ntheory.generate.primepi "sympy.ntheory.generate.primepi")

返回小于或等于 `n` 的素数的数量

[`composite`](#sympy.ntheory.generate.composite "sympy.ntheory.generate.composite")

返回第 `n` 个复合数

```py
sympy.ntheory.factor_.smoothness(n)
```

返回 `n` 的 B-平滑和 B-幂平滑值。

`n` 的平滑性是 `n` 的最大素因子；幂平滑性是最大除数升至其重数。

示例

```py
>>> from sympy.ntheory.factor_ import smoothness
>>> smoothness(2**7*3**2)
(3, 128)
>>> smoothness(2**4*13)
(13, 16)
>>> smoothness(2)
(2, 2) 
```

另见

[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`smoothness_p`](#sympy.ntheory.factor_.smoothness_p "sympy.ntheory.factor_.smoothness_p")

```py
sympy.ntheory.factor_.smoothness_p(n, m=-1, power=0, visual=None)
```

返回列表 `[m, (p, (M, sm(p + m), psm(p + m)))…]` 其中：

1.  `p**M` 是 `n` 的基数 `p` 除数

1.  `sm(p + m)` 是 `p + m` 的平滑性（默认情况下 `m = -1`）

1.  `psm(p + m)` 是 `p + m` 的幂平滑性

列表按平滑性（默认）或按幂平滑性（如果 `power=1`）排序。

左侧（`m = -1`）或右侧（`m = 1`）的平滑性决定了从 `p +/- 1` 类型的因式方法获得的结果。

```py
>>> from sympy.ntheory.factor_ import smoothness_p, factorint
>>> smoothness_p(10431, m=1)
(1, [(3, (2, 2, 4)), (19, (1, 5, 5)), (61, (1, 31, 31))])
>>> smoothness_p(10431)
(-1, [(3, (2, 2, 2)), (19, (1, 3, 9)), (61, (1, 5, 5))])
>>> smoothness_p(10431, power=1)
(-1, [(3, (2, 2, 2)), (61, (1, 5, 5)), (19, (1, 3, 9))]) 
```

如果 `visual=True`，则返回带注释的字符串：

```py
>>> print(smoothness_p(21477639576571, visual=1))
p**i=4410317**1 has p-1 B=1787, B-pow=1787
p**i=4869863**1 has p-1 B=2434931, B-pow=2434931 
```

该字符串也可以直接从因数分解字典生成，反之亦然：

```py
>>> factorint(17*9)
{3: 2, 17: 1}
>>> smoothness_p(_)
'p**i=3**2 has p-1 B=2, B-pow=2\np**i=17**1 has p-1 B=2, B-pow=16'
>>> smoothness_p(_)
{3: 2, 17: 1} 
```

输出逻辑的表格如下：

> |  | 可视化 |
> | --- | --- |
> | 输入 | 真 | 假 | 其他 |
> | --- | --- | --- | --- |
> | dict | str | tuple | str |
> | str | str | tuple | dict |
> | tuple | str | tuple | str |
> | n | str | tuple | tuple |
> | mul | str | tuple | tuple |

另见

[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`smoothness`](#sympy.ntheory.factor_.smoothness "sympy.ntheory.factor_.smoothness")

```py
sympy.ntheory.factor_.multiplicity(p, n)
```

找到最大整数 `m`，使得 `p**m` 可整除 `n`。

示例

```py
>>> from sympy import multiplicity, Rational
>>> [multiplicity(5, n) for n in [8, 5, 25, 125, 250]]
[0, 1, 2, 3, 3]
>>> multiplicity(3, Rational(1, 9))
-2 
```

注意：在检查大阶乘中数字的重复性时，最有效的方法是将其作为未评估的阶乘发送或直接调用 `multiplicity_in_factorial`：

```py
>>> from sympy.ntheory import multiplicity_in_factorial
>>> from sympy import factorial
>>> p = factorial(25)
>>> n = 2**100
>>> nfac = factorial(n, evaluate=False)
>>> multiplicity(p, nfac)
52818775009509558395695966887
>>> _ == multiplicity_in_factorial(p, n)
True 
```

另见

[`trailing`](core.html#sympy.core.intfunc.trailing "sympy.core.intfunc.trailing")

```py
sympy.ntheory.factor_.perfect_power(n, candidates=None, big=True, factor=True)
```

返回 `(b, e)`，使得若 `n` 是具有 `e > 1` 的唯一完全幂，则 `n` == `b**e`，否则返回 `False`（例如 `1` 不是完全幂）。如果 `n` 不是有理数，则引发 `ValueError`。

默认情况下，基数将递归分解并收集指数，因此寻找最大可能的 `e`。如果 `big=False` 则选择最小可能的 `e`（因此是素数）。

如果`factor=True`，则尝试同时因式分解`n`，因为找到一个因子表明`n`的唯一可能根。这是默认值，因为在搜索完美幂的过程中只会测试几个小因子。

使用`candidates`主要是为了内部使用；如果提供，则如果`n`不能写成其中一个候选数的幂，则返回False，并且不会尝试因式分解（超出测试因子2）。

示例

```py
>>> from sympy import perfect_power, Rational
>>> perfect_power(16)
(2, 4)
>>> perfect_power(16, big=False)
(4, 2) 
```

负数只能有奇数完全幂：

```py
>>> perfect_power(-4)
False
>>> perfect_power(-8)
(-2, 3) 
```

有理数也被识别：

```py
>>> perfect_power(Rational(1, 2)**3)
(1/2, 3)
>>> perfect_power(Rational(-3, 2)**3)
(-3/2, 3) 
```

注释

要知道一个整数是否是2的完全幂，使用

```py
>>> is2pow = lambda n: bool(n and not n & (n - 1))
>>> [(i, is2pow(i)) for i in range(5)]
[(0, False), (1, True), (2, True), (3, False), (4, True)] 
```

不需要提供`candidates`。提供时，假定它们是整数。第一个大于计算的最大可能指数的候选数将为该程序的常规信号。

```py
>>> perfect_power(3**8, [9])
False
>>> perfect_power(3**8, [2, 4, 8])
(3, 8)
>>> perfect_power(3**8, [4, 8], big=False)
(9, 4) 
```

参见

[`sympy.core.intfunc.integer_nthroot`](core.html#sympy.core.intfunc.integer_nthroot "sympy.core.intfunc.integer_nthroot")，[`sympy.ntheory.primetest.is_square`](#sympy.ntheory.primetest.is_square "sympy.ntheory.primetest.is_square")

```py
sympy.ntheory.factor_.pollard_rho(n, s=2, a=1, retries=5, seed=1234, max_steps=None, F=None)
```

使用波拉德ρ方法尝试提取`n`的非平凡因子。返回的因子可能是复合数。如果找不到因子，则返回`None`。

算法使用生成器函数生成x的伪随机值，并用F(x)替换x。如果未提供F，则使用函数x**2 + `a`。提供给F(x)的第一个值是`s`。如果失败（如果`retries` > 0），将提供新的`a`和`s`；如果提供了F，则将忽略`a`。

这些函数生成的数字序列通常会引导到某个数字，然后循环回到该数字并开始重复序列，例如1, 2, 3, 4, 5, 3, 4, 5 – 这种引导和循环看起来有点像希腊字母ρ，因此得名‘rho’。

对于给定的函数，可能会得到非常不同的主循环值，因此允许重试是个好主意：

```py
>>> from sympy.ntheory.generate import cycle_length
>>> n = 16843009
>>> F = lambda x:(2048*pow(x, 2, n) + 32767) % n
>>> for s in range(5):
...     print('loop length = %4i; leader length = %3i' % next(cycle_length(F, s)))
...
loop length = 2489; leader length =  43
loop length =   78; leader length = 121
loop length = 1482; leader length = 100
loop length = 1482; leader length = 286
loop length = 1482; leader length = 101 
```

这是一个明确的例子，其中有一个三元素引导到一个序列的3个数字（11, 14, 4），然后重复：

```py
>>> x=2
>>> for i in range(9):
...     print(x)
...     x=(x**2+12)%17
...
2
16
13
11
14
4
11
14
4
>>> next(cycle_length(lambda x: (x**2+12)%17, 2))
(3, 3)
>>> list(cycle_length(lambda x: (x**2+12)%17, 2, values=True))
[2, 16, 13, 11, 14, 4] 
```

不是检查所有生成的值与n的差异的替代品，仅检查第k和2*k个数字，例如第一个和第二个，第二个和第四个，第三个和第六个，直到检测到循环已遍历。在rho找到因子或报告失败之前，循环可能会有数千个步骤长。如果指定了`max_steps`，则在指定的步数后取消迭代并失败。

示例

```py
>>> from sympy import pollard_rho
>>> n=16843009
>>> F=lambda x:(2048*pow(x,2,n) + 32767) % n
>>> pollard_rho(n, F=F)
257 
```

使用默认设置和糟糕的`a`值和无重试：

```py
>>> pollard_rho(n, a=n-2, retries=0) 
```

如果重试> 0，则当为a生成新值时，问题可能会得到纠正：

```py
>>> pollard_rho(n, a=n-2, retries=1)
257 
```

参考

[[R654](#id7)]

Richard Crandall & Carl Pomerance（2005年），《素数：计算视角》，Springer，第二版，229-231

```py
sympy.ntheory.factor_.pollard_pm1(n, B=10, a=2, retries=0, seed=1234)
```

使用波拉德p-1方法尝试提取`n`的非平凡因子。返回一个除数（可能是复合数）或`None`。

`a` 的值是在测试 gcd(a**M - 1, n) 中使用的基数。默认值为 2\. 如果 `retries` > 0，则在第一次尝试未找到因子后，将随机生成一个新的 `a`（使用 `seed`），并重复该过程。

注意：M 的值是 lcm(1..B) = reduce(ilcm, range(2, B + 1))。

寻找具有比 `B` 小的幂平滑度的偶数旁边的因子。选择更大的 B 增加找到较大因子的可能性，但需要更长时间。无论是否找到 n 的因子取决于 `a` 和略小于因子 p 的偶数的幂平滑度（因此称为 p - 1）。

尽管有关什么构成一个好的 `a` 的讨论，有些描述很难解释。在下面引用的模块化数学网站中指出，如果 gcd(a**M - 1, n) = N，则对于 N 的每个素数幂除数，a**M % q**r 等于 1。但请考虑以下情况：

```py
>>> from sympy.ntheory.factor_ import smoothness_p, pollard_pm1
>>> n=257*1009
>>> smoothness_p(n)
(-1, [(257, (1, 2, 256)), (1009, (1, 7, 16))]) 
```

因此，我们应该（并且可以）找到一个具有 B=16 的根：

```py
>>> pollard_pm1(n, B=16, a=3)
1009 
```

如果我们尝试将 B 增加到 256，我们发现它不起作用：

```py
>>> pollard_pm1(n, B=256)
>>> 
```

但是，如果 `a` 的值改变，我们发现只有 257 的倍数有效，例如：

```py
>>> pollard_pm1(n, B=256, a=257)
1009 
```

检查不同的 `a` 值表明所有未能成功的值都具有不等于 `n` 而等于其中一个因子的 gcd 值：

```py
>>> from sympy import ilcm, igcd, factorint, Pow
>>> M = 1
>>> for i in range(2, 256):
...     M = ilcm(M, i)
...
>>> set([igcd(pow(a, M, n) - 1, n) for a in range(2, 256) if
...      igcd(pow(a, M, n) - 1, n) != n])
{1009} 
```

但是，对于 n 的每个除数，aM % d 是否都等于 1？

```py
>>> aM = pow(255, M, n)
>>> [(d, aM%Pow(*d.args)) for d in factorint(n, visual=True).args]
[(257**1, 1), (1009**1, 1)] 
```

不，只有其中一个。因此，也许原则是，在给定 B 值的情况下，可以找到一个根，只要：

1.  p - 1 值旁边的幂平滑度不超过 B

1.  对于每个 n 的除数，a**M % p != 1。

通过尝试多个 `a` 可能会有一个能够产生一个因子。

例子

使用默认平滑界限，这个数字无法破解：

```py
>>> from sympy.ntheory import pollard_pm1
>>> pollard_pm1(21477639576571) 
```

增加平滑界限有助于：

```py
>>> pollard_pm1(21477639576571, B=2000)
4410317 
```

查看该数字的因子的平滑度时，我们发现：

```py
>>> from sympy.ntheory.factor_ import smoothness_p, factorint
>>> print(smoothness_p(21477639576571, visual=1))
p**i=4410317**1 has p-1 B=1787, B-pow=1787
p**i=4869863**1 has p-1 B=2434931, B-pow=2434931 
```

p - 1 的因子化的除数的 B 和 B-pow 是相同的，因为这些因子化有一个非常大的素因子：

```py
>>> factorint(4410317 - 1)
{2: 2, 617: 1, 1787: 1}
>>> factorint(4869863-1)
{2: 1, 2434931: 1} 
```

注意，直到 B 达到 B-pow 值为 1787，该数字才能被破解；

```py
>>> pollard_pm1(21477639576571, B=1786)
>>> pollard_pm1(21477639576571, B=1787)
4410317 
```

B 值与除数旁边的数字的因子有关，而不是除数本身。最坏的情况是，旁边的数字 p 有一个大的素数除数或者是一个完美的幂。如果这些条件适用，则幂平滑度将约为 p/2 或 p。更现实的情况是，旁边将有一个大的素数因子需要一个大约 p/2 的 B 值。尽管可能已经在这个级别搜索了素数，但 p/2 是 p - 1 的一个因子，我们不知道。下面的模块化数学引用表示，在 10**15 到 15**15 + 10**4 范围内的数的 15% 是 10**6 平滑的，因此在该范围内 B=10**6 的失败率为 85%。从 10**8 到 10**8 + 10**3，百分比几乎颠倒了…但在该范围内，简单的试除法非常快。

参考文献

[[R655](#id8)]

Richard Crandall & Carl Pomerance (2005), “Prime Numbers: A Computational Perspective”, Springer, 第二版, 236-238

[[R656](#id9)]

[https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html](https://web.archive.org/web/20150716201437/http://modular.math.washington.edu/edu/2007/spring/ent/ent-html/node81.html)

[[R657](#id10)]

[https://www.cs.toronto.edu/~yuvalf/Factorization.pdf](https://www.cs.toronto.edu/~yuvalf/Factorization.pdf)

```py
sympy.ntheory.factor_.factorint(n, limit=None, use_trial=True, use_rho=True, use_pm1=True, use_ecm=True, verbose=False, visual=None, multiple=False)
```

给定正整数`n`，`factorint(n)`返回一个字典，其中包含`n`的素因子作为键和它们的重数作为值。例如：

```py
>>> from sympy.ntheory import factorint
>>> factorint(2000)    # 2000 = (2**4) * (5**3)
{2: 4, 5: 3}
>>> factorint(65537)   # This number is prime
{65537: 1} 
```

对于小于2的输入，`factorint`的行为如下：

> +   `factorint(1)`返回空因式分解`{}`
> +   
> +   `factorint(0)`返回`{0:1}`
> +   
> +   `factorint(-n)`将`-1:1`添加到因子中，然后因式分解`n`

部分因式分解：

如果指定了`limit`（>3），则在执行试除法达到（包括）限制（或进行相应数量的rho/p-1步骤）后停止搜索。如果有一个大数，并且只想找到小因子（如果有的话），这是很有用的。注意，设置限制并不阻止较大的因子提前被发现；它仅仅意味着最大因子可能是复合的。由于检查完全幂的成本相对较低，因此无论限制设置如何，都会执行此检查。

例如，此数字有两个小因子和一个难以轻易分解的巨大半素数因子：

```py
>>> from sympy.ntheory import isprime
>>> a = 1407633717262338957430697921446883
>>> f = factorint(a, limit=10000)
>>> f == {991: 1, int(202916782076162456022877024859): 1, 7: 1}
True
>>> isprime(max(f))
False 
```

此数有一个小因子和一个基数大于限制的剩余完全幂：

```py
>>> factorint(3*101**7, limit=5)
{3: 1, 101: 7} 
```

因子列表：

如果设置了`multiple`为`True`，则返回包含素因子及其重数的列表。

```py
>>> factorint(24, multiple=True)
[2, 2, 2, 3] 
```

视觉因式分解：

如果`visual`设置为`True`，则会返回整数的视觉因式分解。例如：

```py
>>> from sympy import pprint
>>> pprint(factorint(4200, visual=True))
 3  1  2  1
2 *3 *5 *7 
```

注意，这是通过在Mul和Pow中使用evaluate=False标志实现的。如果您对evaluate=False的表达式进行其他操作，它可能会计算。因此，如果您希望执行因式分解后的操作，请仅在可视化时使用visual选项，并且在visual=False时使用正常的字典返回。

您可以通过将它们发送回`factorint`轻松地在这两种形式之间切换。

```py
>>> from sympy import Mul
>>> regular = factorint(1764); regular
{2: 2, 3: 2, 7: 2}
>>> pprint(factorint(regular))
 2  2  2
2 *3 *7 
```

```py
>>> visual = factorint(1764, visual=True); pprint(visual)
 2  2  2
2 *3 *7
>>> print(factorint(visual))
{2: 2, 3: 2, 7: 2} 
```

如果您希望发送一个部分因式分解形式的数字，可以使用字典或未评估的表达式进行发送：

```py
>>> factorint(factorint({4: 2, 12: 3})) # twice to toggle to dict form
{2: 10, 3: 3}
>>> factorint(Mul(4, 12, evaluate=False))
{2: 4, 3: 1} 
```

输出逻辑表格如下：

> |  |  |
> | --- | --- |
> | Input | True | False | other |
> | --- | --- | --- | --- |
> | dict | mul | dict | mul |
> | n | mul | dict | dict |
> | mul | mul | dict | dict |

注意事项

算法：

该函数在多个算法之间切换。试除法快速找到小因子（约1-5位数字的顺序），如果给定足够时间，它会找到所有大因子。波拉德·罗和p-1算法用于提前找到大因子；它们通常在几秒钟内找到大约10位数字的因子：

```py
>>> factors = factorint(12345678910111213141516)
>>> for base, exp in sorted(factors.items()):
...     print('%s  %s' % (base, exp))
...
2 2
2507191691 1
1231026625769 1 
```

以上任何方法均可选择性地使用以下布尔参数禁用：

> +   `use_trial`：切换使用试除法
> +   
> +   `use_rho`：切换使用波拉德·罗方法
> +   
> +   `use_pm1`：切换使用Pollard的p-1方法

`factorint` 还定期检查剩余部分是否为质数或完全幂，并在这些情况下停止。

对于未评估的阶乘，它使用Legendre的公式（定理）。

如果 `verbose` 设置为 `True`，则会打印详细进度。

另请参见

[`smoothness`](#sympy.ntheory.factor_.smoothness "sympy.ntheory.factor_.smoothness"), [`smoothness_p`](#sympy.ntheory.factor_.smoothness_p "sympy.ntheory.factor_.smoothness_p"), [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors")

```py
sympy.ntheory.factor_.factorrat(rat, limit=None, use_trial=True, use_rho=True, use_pm1=True, verbose=False, visual=None, multiple=False)
```

给定有理数 `r`，`factorrat(r)` 返回一个包含 `r` 的质因子为键和它们相应重数为值的字典。例如：

```py
>>> from sympy import factorrat, S
>>> factorrat(S(8)/9)    # 8/9 = (2**3) * (3**-2)
{2: 3, 3: -2}
>>> factorrat(S(-1)/987)    # -1/789 = -1 * (3**-1) * (7**-1) * (47**-1)
{-1: 1, 3: -1, 7: -1, 47: -1} 
```

请参阅 `factorint` 的文档字符串，了解以下关键字的详细说明和示例：

> +   `limit`：执行试除的整数限制
> +   
> +   `use_trial`：切换使用试除法
> +   
> +   `use_rho`：切换使用Pollard的rho方法
> +   
> +   `use_pm1`：切换使用Pollard的p-1方法
> +   
> +   `verbose`：切换详细打印进度
> +   
> +   `multiple`：切换返回因子列表或字典
> +   
> +   `visual`：切换输出的乘积形式

```py
sympy.ntheory.factor_.primefactors(n, limit=None, verbose=False, **kwargs)
```

返回n的质因子的排序列表，忽略重复性和任何如果限制太低而残留的复合因子的完全因子分解。与 `factorint()` 不同，`primefactors()` 不返回-1或0。

参数：

**n**：整数

**limit, verbose, **kwargs：**

> 要传递给 `factorint` 的额外关键字参数。由于 `kwargs` 是1.13版本中的新内容，因此保留 `limit` 和 `verbose` 以确保兼容性。

返回：

**list(int)**：整数 n 的质数列表

示例

```py
>>> from sympy.ntheory import primefactors, factorint, isprime
>>> primefactors(6)
[2, 3]
>>> primefactors(-5)
[5] 
```

```py
>>> sorted(factorint(123456).items())
[(2, 6), (3, 1), (643, 1)]
>>> primefactors(123456)
[2, 3, 643] 
```

```py
>>> sorted(factorint(10000000001, limit=200).items())
[(101, 1), (99009901, 1)]
>>> isprime(99009901)
False
>>> primefactors(10000000001, limit=300)
[101] 
```

另请参见

[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors")

```py
sympy.ntheory.factor_.divisors(n, generator=False, proper=False)
```

默认情况下，返回从1到n排序的n的所有除数。如果 `generator` 设置为 `True`，则返回一个无序生成器。

如果有许多质因子（计算重复因子），则 n 的除数数量可能会很大。如果只需要因子的数量，请使用 `divisor_count(n)`。

示例

```py
>>> from sympy import divisors, divisor_count
>>> divisors(24)
[1, 2, 3, 4, 6, 8, 12, 24]
>>> divisor_count(24)
8 
```

```py
>>> list(divisors(120, generator=True))
[1, 2, 4, 8, 3, 6, 12, 24, 5, 10, 20, 40, 15, 30, 60, 120] 
```

注释

这是稍作修改的Tim Peters版本，参考自：[https://stackoverflow.com/questions/1010381/python-factorization](https://stackoverflow.com/questions/1010381/python-factorization)

另请参见

[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"), [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")

```py
sympy.ntheory.factor_.proper_divisors(n, generator=False)
```

默认情况下，返回除n以外的n的所有除数。如果 `generator` 设置为 `True`，则返回一个无序生成器。

示例

```py
>>> from sympy import proper_divisors, proper_divisor_count
>>> proper_divisors(24)
[1, 2, 3, 4, 6, 8, 12]
>>> proper_divisor_count(24)
7
>>> list(proper_divisors(120, generator=True))
[1, 2, 4, 8, 3, 6, 12, 24, 5, 10, 20, 40, 15, 30, 60] 
```

另请参见

[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"), [`proper_divisor_count`](#sympy.ntheory.factor_.proper_divisor_count "sympy.ntheory.factor_.proper_divisor_count")

```py
sympy.ntheory.factor_.divisor_count(n, modulus=1, proper=False)
```

返回 `n` 的除数的数量。如果 `modulus` 不为 1，则仅计算可被 `modulus` 整除的除数。如果 `proper` 为 `True`，则 `n` 的除数将不被计算。

示例

```py
>>> from sympy import divisor_count
>>> divisor_count(6)
4
>>> divisor_count(6, 2)
2
>>> divisor_count(6, proper=True)
3 
```

另见

[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"), [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient"), [`proper_divisor_count`](#sympy.ntheory.factor_.proper_divisor_count "sympy.ntheory.factor_.proper_divisor_count")

```py
sympy.ntheory.factor_.proper_divisor_count(n, modulus=1)
```

返回 `n` 的真除数的数量。

示例

```py
>>> from sympy import proper_divisor_count
>>> proper_divisor_count(6)
3
>>> proper_divisor_count(6, modulus=2)
1 
```

另见

[`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"), [`proper_divisors`](#sympy.ntheory.factor_.proper_divisors "sympy.ntheory.factor_.proper_divisors"), [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")

```py
sympy.ntheory.factor_.udivisors(n, generator=False)
```

默认情况下，返回排序后的 n 的所有单位除数。如果 `generator` 为 `True`，则返回一个无序生成器。

如果存在许多质因数，则 `n` 的单位除数数量可能非常大。如果只需单位除数的数量，请使用 `udivisor_count(n)`。

示例

```py
>>> from sympy.ntheory.factor_ import udivisors, udivisor_count
>>> udivisors(15)
[1, 3, 5, 15]
>>> udivisor_count(15)
4 
```

```py
>>> sorted(udivisors(120, generator=True))
[1, 3, 5, 8, 15, 24, 40, 120] 
```

另见

[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"), [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"), [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"), [`udivisor_count`](#sympy.ntheory.factor_.udivisor_count "sympy.ntheory.factor_.udivisor_count")

参考文献

[[R658](#id11)]

[https://en.wikipedia.org/wiki/Unitary_divisor](https://en.wikipedia.org/wiki/Unitary_divisor)

[[R659](#id12)]

[https://mathworld.wolfram.com/UnitaryDivisor.html](https://mathworld.wolfram.com/UnitaryDivisor.html)

```py
sympy.ntheory.factor_.udivisor_count(n)
```

返回 `n` 的单位除数的数量。

参数：

**n**：整数

示例

```py
>>> from sympy.ntheory.factor_ import udivisor_count
>>> udivisor_count(120)
8 
```

另见

[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"), [`udivisors`](#sympy.ntheory.factor_.udivisors "sympy.ntheory.factor_.udivisors"), [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"), [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")

参考文献

[[R660](#id13)]

[https://mathworld.wolfram.com/UnitaryDivisorFunction.html](https://mathworld.wolfram.com/UnitaryDivisorFunction.html)

```py
sympy.ntheory.factor_.antidivisors(n, generator=False)
```

默认情况下，返回排序后的 n 的所有反除数。

n 的反除数[[R661]](#r661)是不以最大可能边界除 n 的数。如果 generator 为 True，则返回无序生成器。

示例

```py
>>> from sympy.ntheory.factor_ import antidivisors
>>> antidivisors(24)
[7, 16] 
```

```py
>>> sorted(antidivisors(128, generator=True))
[3, 5, 15, 17, 51, 85] 
```

另见

[`primefactors`](#sympy.ntheory.factor_.primefactors "sympy.ntheory.factor_.primefactors"), [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"), [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"), [`antidivisor_count`](#sympy.ntheory.factor_.antidivisor_count "sympy.ntheory.factor_.antidivisor_count")

参考文献

[R661] ([1](#id14),[2](#id15))

定义见[https://oeis.org/A066272/a066272a.html](https://oeis.org/A066272/a066272a.html)

```py
sympy.ntheory.factor_.antidivisor_count(n)
```

返回 `n` 的反除数数目[[R662]](#r662)。

参数：

**n**：整数

示例

```py
>>> from sympy.ntheory.factor_ import antidivisor_count
>>> antidivisor_count(13)
4
>>> antidivisor_count(27)
5 
```

另见

[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"), [`antidivisors`](#sympy.ntheory.factor_.antidivisors "sympy.ntheory.factor_.antidivisors"), [`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"), [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")

参考文献

[R662] ([1](#id16),[2](#id17))

公式来自[https://oeis.org/A066272](https://oeis.org/A066272)

```py
sympy.ntheory.factor_.totient(n)
```

计算欧拉 totient 函数 phi(n)

自 1.13 版本起不推荐使用：`totient` 函数已被弃用。请使用[`sympy.functions.combinatorial.numbers.totient`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.totient "sympy.functions.combinatorial.numbers.totient")。更多信息请参见其文档。详细信息请参见[将 ntheory 中的符号函数重定位到 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。

`totient(n)` 或 \(\phi(n)\) 是小于等于 n 的与 n 互质的正整数的数量。

参数：

**n**：整数

示例

```py
>>> from sympy.functions.combinatorial.numbers import totient
>>> totient(1)
1
>>> totient(25)
20
>>> totient(45) == totient(5)*totient(9)
True 
```

另见

[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")

参考文献

[[R663](#id18)]

[https://en.wikipedia.org/wiki/Euler%27s_totient_function](https://en.wikipedia.org/wiki/Euler%27s_totient_function)

[[R664](#id19)]

[https://mathworld.wolfram.com/TotientFunction.html](https://mathworld.wolfram.com/TotientFunction.html)

```py
sympy.ntheory.factor_.reduced_totient(n)
```

计算 Carmichael 减少的欧拉 totient 函数 lambda(n)

自 1.13 版本起不推荐使用：`reduced_totient` 函数已被弃用。请使用[`sympy.functions.combinatorial.numbers.reduced_totient`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.reduced_totient "sympy.functions.combinatorial.numbers.reduced_totient")。更多信息请参见其文档。详细信息请参见[将 ntheory 中的符号函数重定位到 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。

`reduced_totient(n)` 或 \(\lambda(n)\) 是最小的m > 0，使得对于所有与n互质的k，都有 \(k^m \equiv 1 \mod n\)。

示例

```py
>>> from sympy.functions.combinatorial.numbers import reduced_totient
>>> reduced_totient(1)
1
>>> reduced_totient(8)
2
>>> reduced_totient(30)
4 
```

另见

[`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")

参考

[[R665](#id20)]

[https://en.wikipedia.org/wiki/Carmichael_function](https://en.wikipedia.org/wiki/Carmichael_function)

[[R666](#id21)]

[https://mathworld.wolfram.com/CarmichaelFunction.html](https://mathworld.wolfram.com/CarmichaelFunction.html)

```py
sympy.ntheory.factor_.divisor_sigma(n, k=1)
```

计算正整数n的除数函数 \(\sigma_k(n)\)

自版本1.13起不推荐使用：函数`divisor_sigma`已不推荐使用。请使用[`sympy.functions.combinatorial.numbers.divisor_sigma`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.divisor_sigma "sympy.functions.combinatorial.numbers.divisor_sigma")。有关详细信息，请参阅其文档。有关详细信息，请参见[将符号函数从ntheory移至函数](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。

`divisor_sigma(n, k)` 等于 `sum([x**k for x in divisors(n)])`

如果n的素因数分解为：

\[n = \prod_{i=1}^\omega p_i^{m_i},\]

则

\[\sigma_k(n) = \prod_{i=1}^\omega (1+p_i^k+p_i^{2k}+\cdots + p_i^{m_ik}).\]

参数：

**n**：整数

**k**：整数，可选

> 和的除数的幂
> 
> 对于k = 0, 1：`divisor_sigma(n, 0)` 等于 `divisor_count(n)`，`divisor_sigma(n, 1)` 等于 `sum(divisors(n))`
> 
> 默认情况下，k为1。

示例

```py
>>> from sympy.functions.combinatorial.numbers import divisor_sigma
>>> divisor_sigma(18, 0)
6
>>> divisor_sigma(39, 1)
56
>>> divisor_sigma(12, 2)
210
>>> divisor_sigma(37)
38 
```

另见

[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count")，[`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient")，[`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors")，[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint")

参考

[[R667](#id22)]

[https://en.wikipedia.org/wiki/Divisor_function](https://en.wikipedia.org/wiki/Divisor_function)

```py
sympy.ntheory.factor_.udivisor_sigma(n, k=1)
```

计算正整数n的单位除数函数 \(\sigma_k^*(n)\)

自版本1.13起不推荐使用：函数`udivisor_sigma`已不推荐使用。请使用[`sympy.functions.combinatorial.numbers.udivisor_sigma`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.udivisor_sigma "sympy.functions.combinatorial.numbers.udivisor_sigma")。有关详细信息，请参阅其文档。有关详细信息，请参见[将符号函数从ntheory移至函数](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。

`udivisor_sigma(n, k)` 等于 `sum([x**k for x in udivisors(n)])`

如果n的素因数分解为：

\[n = \prod_{i=1}^\omega p_i^{m_i},\]

则

\[\sigma_k^*(n) = \prod_{i=1}^\omega (1+ p_i^{m_ik}).\]

参数：

**k**：和的除数的幂

> 对于k = 0, 1：`udivisor_sigma(n, 0)` 等于 `udivisor_count(n)`，`udivisor_sigma(n, 1)` 等于 `sum(udivisors(n))`
> 
> 默认情况下，k为1。

示例

```py
>>> from sympy.functions.combinatorial.numbers import udivisor_sigma
>>> udivisor_sigma(18, 0)
4
>>> udivisor_sigma(74, 1)
114
>>> udivisor_sigma(36, 3)
47450
>>> udivisor_sigma(111)
152 
```

另见

[`divisor_count`](#sympy.ntheory.factor_.divisor_count "sympy.ntheory.factor_.divisor_count"), [`totient`](#sympy.ntheory.factor_.totient "sympy.ntheory.factor_.totient"), [`divisors`](#sympy.ntheory.factor_.divisors "sympy.ntheory.factor_.divisors"), [`udivisors`](#sympy.ntheory.factor_.udivisors "sympy.ntheory.factor_.udivisors"), [`udivisor_count`](#sympy.ntheory.factor_.udivisor_count "sympy.ntheory.factor_.udivisor_count"), [`divisor_sigma`](#sympy.ntheory.factor_.divisor_sigma "sympy.ntheory.factor_.divisor_sigma"), [`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint")

参考

[[R668](#id23)]

[https://mathworld.wolfram.com/UnitaryDivisorFunction.html](https://mathworld.wolfram.com/UnitaryDivisorFunction.html)

```py
sympy.ntheory.factor_.core(n, t=2)
```

计算正整数n的`core_t(n)` = `core(n, t)`

`core_2(n)`等于n的无平方数部分

如果n的质因数分解为：

\[n = \prod_{i=1}^\omega p_i^{m_i},\]

则

\[core_t(n) = \prod_{i=1}^\omega p_i^{m_i \mod t}.\]

参数：

**n**：整数

**t**：整数

> `core(n, t)`计算n的第t个无幂次方部分
> 
> `core(n, 2)`是n的无平方数部分，`core(n, 3)`是n的无立方数部分
> 
> t的默认值为2。

例子

```py
>>> from sympy.ntheory.factor_ import core
>>> core(24, 2)
6
>>> core(9424, 3)
1178
>>> core(379238)
379238
>>> core(15**11, 10)
15 
```

参见

[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint"), [`sympy.solvers.diophantine.diophantine.square_factor`](solvers/diophantine.html#sympy.solvers.diophantine.diophantine.square_factor "sympy.solvers.diophantine.diophantine.square_factor")

参考

[[R669](#id24)]

[https://en.wikipedia.org/wiki/Square-free_integer#Squarefree_core](https://en.wikipedia.org/wiki/Square-free_integer#Squarefree_core)

```py
sympy.ntheory.factor_.digits(n, b=10, digits=None)
```

返回n在b进制下的数字列表。列表中的第一个元素是b（如果n为负，则为-b）。

参数：

**n：整数**

> 要返回其数字的数字。

**b：整数**

> 计算数字的基数。

**digits：整数（或所有数字为None）**

> 要返回的数字位数（如有必要，用零填充）。

例子

```py
>>> from sympy.ntheory.digits import digits
>>> digits(35)
[10, 3, 5] 
```

如果数字为负，则负号将放置在基数上（即返回列表中的第一个元素）：

```py
>>> digits(-35)
[-10, 3, 5] 
```

可以选择除10以外（且大于1）的基数`b`：

```py
>>> digits(27, b=2)
[2, 1, 1, 0, 1, 1] 
```

如果需要确定特定位数的数字，请使用`digits`关键字：

```py
>>> digits(35, digits=4)
[10, 0, 0, 3, 5] 
```

参见

[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"), [`count_digits`](#sympy.ntheory.digits.count_digits "sympy.ntheory.digits.count_digits")

```py
sympy.ntheory.factor_.primenu(n)
```

计算正整数n的不同质因子的数量。

自版本1.13起已弃用：`primenu`函数已弃用。请使用[`sympy.functions.combinatorial.numbers.primenu`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primenu "sympy.functions.combinatorial.numbers.primenu")。有关详细信息，请参见其文档。有关详细信息，请参阅[从ntheory移动符号函数到函数](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。

如果 n 的素因数分解是：

\[n = \prod_{i=1}^k p_i^{m_i},\]

如果 `primenu(n)` 或者 \(\nu(n)\) 是：

\[\nu(n) = k.\]

例子

```py
>>> from sympy.functions.combinatorial.numbers import primenu
>>> primenu(1)
0
>>> primenu(30)
3 
```

参见

[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint")

参考文献

[[R670](#id25)]

[https://mathworld.wolfram.com/PrimeFactor.html](https://mathworld.wolfram.com/PrimeFactor.html)

```py
sympy.ntheory.factor_.primeomega(n)
```

计算一个正整数 n 的素因数的个数（包括重数）。

自版本 1.13 起已弃用：`primeomega` 函数已弃用。使用 [`sympy.functions.combinatorial.numbers.primeomega`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primeomega "sympy.functions.combinatorial.numbers.primeomega") 替代。更多信息请参见其文档。详情请见 [将符号函数从 ntheory 移至 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。

如果 n 的素因数分解是：

\[n = \prod_{i=1}^k p_i^{m_i},\]

如果 `primeomega(n)` 或者 \(\Omega(n)\) 是：

\[\Omega(n) = \sum_{i=1}^k m_i.\]

例子

```py
>>> from sympy.functions.combinatorial.numbers import primeomega
>>> primeomega(1)
0
>>> primeomega(20)
3 
```

参见

[`factorint`](#sympy.ntheory.factor_.factorint "sympy.ntheory.factor_.factorint")

参考文献

[[R671](#id26)]

[https://mathworld.wolfram.com/PrimeFactor.html](https://mathworld.wolfram.com/PrimeFactor.html)

```py
sympy.ntheory.factor_.mersenne_prime_exponent(nth)
```

返回第 n 个 Mersenne prime 的指数 `i`（形式为 \(2^i - 1\))。

例子

```py
>>> from sympy.ntheory.factor_ import mersenne_prime_exponent
>>> mersenne_prime_exponent(1)
2
>>> mersenne_prime_exponent(20)
4423 
```

```py
sympy.ntheory.factor_.is_perfect(n)
```

返回 True 如果 `n` 是一个 perfect number，否则返回 False。

一个 perfect number 等于其正的真因数之和。

例子

```py
>>> from sympy.functions.combinatorial.numbers import divisor_sigma
>>> from sympy.ntheory.factor_ import is_perfect, divisors
>>> is_perfect(20)
False
>>> is_perfect(6)
True
>>> 6 == divisor_sigma(6) - 6 == sum(divisors(6)[:-1])
True 
```

参考文献

[[R672](#id27)]

[https://mathworld.wolfram.com/PerfectNumber.html](https://mathworld.wolfram.com/PerfectNumber.html)

[[R673](#id28)]

[https://en.wikipedia.org/wiki/Perfect_number](https://en.wikipedia.org/wiki/Perfect_number)

```py
sympy.ntheory.factor_.abundance(n)
```

返回一个数的正因数之和与该数之差。

例子

```py
>>> from sympy.ntheory import abundance, is_perfect, is_abundant
>>> abundance(6)
0
>>> is_perfect(6)
True
>>> abundance(10)
-2
>>> is_abundant(10)
False 
```

```py
sympy.ntheory.factor_.is_abundant(n)
```

返回 True 如果 `n` 是一个 abundant number，否则返回 False。

一个 abundant number 是小于其正因数之和的数。

例子

```py
>>> from sympy.ntheory.factor_ import is_abundant
>>> is_abundant(20)
True
>>> is_abundant(15)
False 
```

参考文献

[[R674](#id29)]

[https://mathworld.wolfram.com/AbundantNumber.html](https://mathworld.wolfram.com/AbundantNumber.html)

```py
sympy.ntheory.factor_.is_deficient(n)
```

返回 True 如果 `n` 是一个 deficient number，否则返回 False。

一个 deficient number 是大于其正因数之和的数。

例子

```py
>>> from sympy.ntheory.factor_ import is_deficient
>>> is_deficient(20)
False
>>> is_deficient(15)
True 
```

参考文献

[[R675](#id30)]

[https://mathworld.wolfram.com/DeficientNumber.html](https://mathworld.wolfram.com/DeficientNumber.html)

```py
sympy.ntheory.factor_.is_amicable(m, n)
```

返回 True 如果数字 \(m\) 和 \(n\) 是“amicable”，否则返回 False。

Amicable numbers 是两个不同的相关数，其各自的真因数之和相等。

例子

```py
>>> from sympy.functions.combinatorial.numbers import divisor_sigma
>>> from sympy.ntheory.factor_ import is_amicable
>>> is_amicable(220, 284)
True
>>> divisor_sigma(220) == divisor_sigma(284)
True 
```

参考文献

[[R676](#id31)]

[https://en.wikipedia.org/wiki/Amicable_numbers](https://en.wikipedia.org/wiki/Amicable_numbers)

```py
sympy.ntheory.factor_.is_carmichael(n)
```

返回 True 如果数字 \(n\) 是 Carmichael number，否则返回 False。

参数：

**n** : 整数

参考文献

[[R677](#id32)]

[https://en.wikipedia.org/wiki/Carmichael_number](https://en.wikipedia.org/wiki/Carmichael_number)

[[R678](#id33)]

[https://oeis.org/A002997](https://oeis.org/A002997)

```py
sympy.ntheory.factor_.find_carmichael_numbers_in_range(x, y)
```

返回在范围内的 Carmichael 数的列表。

另请参阅

[`is_carmichael`](#sympy.ntheory.factor_.is_carmichael "sympy.ntheory.factor_.is_carmichael")

```py
sympy.ntheory.factor_.find_first_n_carmichaels(n)
```

返回前 `n` 个 Carmichael 数。

参数：

**n**：整数

另请参阅

[`is_carmichael`](#sympy.ntheory.factor_.is_carmichael "sympy.ntheory.factor_.is_carmichael")

```py
sympy.ntheory.modular.symmetric_residue(a, m)
```

返回模 `m` 内的剩余部分，使其在模的一半范围内。

```py
>>> from sympy.ntheory.modular import symmetric_residue
>>> symmetric_residue(1, 6)
1
>>> symmetric_residue(4, 6)
-2 
```

```py
sympy.ntheory.modular.crt(m, v, symmetric=False, check=True)
```

中国剩余定理。

在 `m` 中的模数被假设为两两互质。然后输出是一个整数 `f`，使得对于 `v` 和 `m` 中的每对，都有 `f = v_i mod m_i`。如果 `symmetric` 为 False，则返回一个正整数，否则 |f| 小于或等于模数的 LCM，因此 `f` 可能为负数。

如果模数不互质，则在发现结果不正确时将返回正确结果。如果没有解决方案，则结果将为 `None`。

如果已知模数是互质的，则可以将关键字 `check` 设置为 False。

示例

例如，考虑一组剩余 `U = [49, 76, 65]` 和一组模数 `M = [99, 97, 95]`。那么我们有：

```py
>>> from sympy.ntheory.modular import crt

>>> crt([99, 97, 95], [49, 76, 65])
(639985, 912285) 
```

这是正确的结果，因为：

```py
>>> [639985 % m for m in [99, 97, 95]]
[49, 76, 65] 
```

如果模数不互质，如果使用 `check=False`，则可能会得到不正确的结果：

```py
>>> crt([12, 6, 17], [3, 4, 2], check=False)
(954, 1224)
>>> [954 % m for m in [12, 6, 17]]
[6, 0, 2]
>>> crt([12, 6, 17], [3, 4, 2]) is None
True
>>> crt([3, 6], [2, 5])
(5, 6) 
```

注意：相对于 `crt`，`gf_crt` 的参数顺序被颠倒了，`solve_congruence` 接受剩余，模数对。

程序员注意：与检查所有模数对不共享 GCD（O(n**2) 测试）或者分解所有模数然后看是否有共同因子的方法不同，这里执行的操作是检查结果是否给出了指定的剩余部分 - 这是一个 O(n) 操作。

另请参阅

[`solve_congruence`](#sympy.ntheory.modular.solve_congruence "sympy.ntheory.modular.solve_congruence")

[`sympy.polys.galoistools.gf_crt`](polys/internals.html#sympy.polys.galoistools.gf_crt "sympy.polys.galoistools.gf_crt")

低级 Chinese Remainder Theorem 运行在这个例程中使用。

```py
sympy.ntheory.modular.crt1(m)
```

多个应用的 Chinese Remainder Theorem 的第一部分。

示例

```py
>>> from sympy.ntheory.modular import crt, crt1, crt2
>>> m = [99, 97, 95]
>>> v = [49, 76, 65] 
```

以下两个代码具有相同的结果。

```py
>>> crt(m, v)
(639985, 912285) 
```

```py
>>> mm, e, s = crt1(m)
>>> crt2(m, v, mm, e, s)
(639985, 912285) 
```

但是，当我们希望固定 `m` 并计算多个 `v` 时，速度更快，即以下情况：

```py
>>> mm, e, s = crt1(m)
>>> vs = [[52, 21, 37], [19, 46, 76]]
>>> for v in vs:
...     print(crt2(m, v, mm, e, s))
(397042, 912285)
(803206, 912285) 
```

另请参阅

[`sympy.polys.galoistools.gf_crt1`](polys/internals.html#sympy.polys.galoistools.gf_crt1 "sympy.polys.galoistools.gf_crt1")

低级 Chinese Remainder Theorem 运行在这个例程中使用。

[`sympy.ntheory.modular.crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt"), [`sympy.ntheory.modular.crt2`](#sympy.ntheory.modular.crt2 "sympy.ntheory.modular.crt2")

```py
sympy.ntheory.modular.crt2(m, v, mm, e, s, symmetric=False)
```

多个应用的 Chinese Remainder Theorem 的第二部分。

参见 `crt1` 以获取用法。

示例

```py
>>> from sympy.ntheory.modular import crt1, crt2
>>> mm, e, s = crt1([18, 42, 6])
>>> crt2([18, 42, 6], [0, 0, 0], mm, e, s)
(0, 4536) 
```

另请参阅

[`sympy.polys.galoistools.gf_crt2`](polys/internals.html#sympy.polys.galoistools.gf_crt2 "sympy.polys.galoistools.gf_crt2")

低级 Chinese Remainder Theorem 运行在这个例程中使用。

[`sympy.ntheory.modular.crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt"), [`sympy.ntheory.modular.crt1`](#sympy.ntheory.modular.crt1 "sympy.ntheory.modular.crt1")

```py
sympy.ntheory.modular.solve_congruence(*remainder_modulus_pairs, **hint)
```

计算整数`n`，当它被分别除以`mi`时，余数为`ai`，其中`ai`和`mi`作为此函数的一对给定：((a1, m1), (a2, m2), ...)。如果没有解决方案，则返回None。否则返回`n`及其模数。

`mi`值不需要互质。如果已知模数不互质，则可以将提示`check`设置为False（默认为True），并且将跳过通过crt()（在模数互质时有效）寻找更快解决方案的检查。

如果提示`symmetric`为True（默认为False），则`n`的值将在模数的1/2范围内，可能为负。

示例

```py
>>> from sympy.ntheory.modular import solve_congruence 
```

数字是2模3、3模5和2模7的数字？

```py
>>> solve_congruence((2, 3), (3, 5), (2, 7))
(23, 105)
>>> [23 % m for m in [3, 5, 7]]
[2, 3, 2] 
```

如果您更喜欢将所有余数放在一个列表中，将所有模数放在另一个列表中，则可以像这样发送参数：

```py
>>> solve_congruence(*zip((2, 3, 2), (3, 5, 7)))
(23, 105) 
```

模数不需要互质；在这种情况下可能存在或不存在解决方案：

```py
>>> solve_congruence((2, 3), (4, 6)) is None
True 
```

```py
>>> solve_congruence((2, 3), (5, 6))
(5, 6) 
```

对称标志将使结果在模数的1/2范围内：

```py
>>> solve_congruence((2, 3), (5, 6), symmetric=True)
(-1, 6) 
```

另请参阅

[`crt`](#sympy.ntheory.modular.crt "sympy.ntheory.modular.crt")

实现中国余数定理的高级程序

```py
sympy.ntheory.multinomial.binomial_coefficients(n)
```

返回包含对`{(k1,k2) : C_kn}`的字典，其中`C_kn`为二项式系数且`n=k1+k2`。

示例

```py
>>> from sympy.ntheory import binomial_coefficients
>>> binomial_coefficients(9)
{(0, 9): 1, (1, 8): 9, (2, 7): 36, (3, 6): 84,
 (4, 5): 126, (5, 4): 126, (6, 3): 84, (7, 2): 36, (8, 1): 9, (9, 0): 1} 
```

另请参阅

[`二项式系数列表`](#sympy.ntheory.multinomial.binomial_coefficients_list "sympy.ntheory.multinomial.binomial_coefficients_list")，[`多项式系数`](#sympy.ntheory.multinomial.multinomial_coefficients "sympy.ntheory.multinomial.multinomial_coefficients")

```py
sympy.ntheory.multinomial.binomial_coefficients_list(n)
```

返回帕斯卡三角形的行作为二项式系数的列表。

示例

```py
>>> from sympy.ntheory import binomial_coefficients_list
>>> binomial_coefficients_list(9)
[1, 9, 36, 84, 126, 126, 84, 36, 9, 1] 
```

另请参阅

[`二项式系数`](#sympy.ntheory.multinomial.binomial_coefficients "sympy.ntheory.multinomial.binomial_coefficients")，[`多项式系数`](#sympy.ntheory.multinomial.multinomial_coefficients "sympy.ntheory.multinomial.multinomial_coefficients")

```py
sympy.ntheory.multinomial.multinomial_coefficients(m, n)
```

返回包含对`{(k1,k2,..,km) : C_kn}`的字典，其中`C_kn`为多项式系数，使得`n=k1+k2+..+km`。

示例

```py
>>> from sympy.ntheory import multinomial_coefficients
>>> multinomial_coefficients(2, 5) # indirect doctest
{(0, 5): 1, (1, 4): 5, (2, 3): 10, (3, 2): 10, (4, 1): 5, (5, 0): 1} 
```

注释

该算法基于以下结果：

\[\binom{n}{k_1, \ldots, k_m} = \frac{k_1 + 1}{n - k_1} \sum_{i=2}^m \binom{n}{k_1 + 1, \ldots, k_i - 1, \ldots}\]

由Yann Laigle-Chapuy贡献的代码，经作者许可复制。

另请参阅

[`二项式系数列表`](#sympy.ntheory.multinomial.binomial_coefficients_list "sympy.ntheory.multinomial.binomial_coefficients_list")，[`二项式系数`](#sympy.ntheory.multinomial.binomial_coefficients "sympy.ntheory.multinomial.binomial_coefficients")

```py
sympy.ntheory.multinomial.multinomial_coefficients_iterator(m, n, _tuple=<class 'tuple'>)
```

多项式系数迭代器

通过利用从`multinomial_coefficients(n, n)`获取的单项式元组`t`去除零时的系数与后者的系数相同，因此，后者的系数预先计算以节省内存和时间。

```py
>>> from sympy.ntheory.multinomial import multinomial_coefficients
>>> m53, m33 = multinomial_coefficients(5,3), multinomial_coefficients(3,3)
>>> m53[(0,0,0,1,2)] == m53[(0,0,1,0,2)] == m53[(1,0,2,0,0)] == m33[(0,1,2)]
True 
```

示例

```py
>>> from sympy.ntheory.multinomial import multinomial_coefficients_iterator
>>> it = multinomial_coefficients_iterator(20,3)
>>> next(it)
((3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), 1) 
```

```py
sympy.ntheory.partitions_.npartitions(n, verbose=False)
```

计算分割函数P(n)，即将n写为正整数和的方式数。

自版本 1.13 起弃用：`npartitions` 函数已弃用。请使用 [`sympy.functions.combinatorial.numbers.partition`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.partition "sympy.functions.combinatorial.numbers.partition")。有关更多信息，请参阅其文档。详细信息请参见 [将符号函数从 ntheory 移至 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。

使用 Hardy-Ramanujan-Rademacher 公式计算 P(n) [[R679]](#r679)。

该实现的正确性已通过 \(10^{10}\) 的测试。

示例

```py
>>> from sympy.functions.combinatorial.numbers import partition
>>> partition(25)
1958 
```

参考文献

[R679] ([1](#id34),[2](#id35))

[https://mathworld.wolfram.com/PartitionFunctionP.html](https://mathworld.wolfram.com/PartitionFunctionP.html)

```py
sympy.ntheory.primetest.is_fermat_pseudoprime(n, a)
```

如果 `n` 是素数或是与 `a` 互质且满足模算术同余关系的奇合数，则返回 True：

\[a^{n-1} \equiv 1 \pmod{n}\]

（其中 mod 指的是模运算）。

参数：

**n**：整数

> `n` 是正整数。

**a**：整数

> `a` 是正整数。`a` 和 `n` 应该互质。

返回：

**bool**：如果 `n` 是素数，则总是返回 `True`。

> 返回称为 Fermat 伪素数的合数。

示例

```py
>>> from sympy.ntheory.primetest import is_fermat_pseudoprime
>>> from sympy.ntheory.factor_ import isprime
>>> for n in range(1, 1000):
...     if is_fermat_pseudoprime(n, 2) and not isprime(n):
...         print(n)
341
561
645 
```

参考文献

[[R680](#id36)]

[https://en.wikipedia.org/wiki/Fermat_pseudoprime](https://en.wikipedia.org/wiki/Fermat_pseudoprime)

```py
sympy.ntheory.primetest.is_euler_pseudoprime(n, a)
```

如果 `n` 是素数或是与 `a` 互质且满足模算术同余关系的奇合数，则返回 True：

\[a^{(n-1)/2} \equiv \pm 1 \pmod{n}\]

（其中 mod 指的是模运算）。

参数：

**n**：整数

> `n` 是正整数。

**a**：整数

> `a` 是正整数。`a` 和 `n` 应该互质。

返回：

**bool**：如果 `n` 是素数，则总是返回 `True`。

> 返回称为 Euler 伪素数的合数。

示例

```py
>>> from sympy.ntheory.primetest import is_euler_pseudoprime
>>> from sympy.ntheory.factor_ import isprime
>>> for n in range(1, 1000):
...     if is_euler_pseudoprime(n, 2) and not isprime(n):
...         print(n)
341
561 
```

参考文献

[[R681](#id37)]

[https://en.wikipedia.org/wiki/Euler_pseudoprime](https://en.wikipedia.org/wiki/Euler_pseudoprime)

```py
sympy.ntheory.primetest.is_euler_jacobi_pseudoprime(n, a)
```

如果 `n` 是素数或是与 `a` 互质且满足模算术同余关系的奇合数，则返回 True：

\[a^{(n-1)/2} \equiv \left(\frac{a}{n}\right) \pmod{n}\]

（其中 mod 指的是模运算）。

参数：

**n**：整数

> `n` 是正整数。

**a**：整数

> `a` 是正整数。`a` 和 `n` 应该互质。

返回：

**bool**：如果 `n` 是素数，则总是返回 `True`。

> 返回称为 Euler-Jacobi 伪素数的合数。

示例

```py
>>> from sympy.ntheory.primetest import is_euler_jacobi_pseudoprime
>>> from sympy.ntheory.factor_ import isprime
>>> for n in range(1, 1000):
...     if is_euler_jacobi_pseudoprime(n, 2) and not isprime(n):
...         print(n)
561 
```

参考文献

[[R682](#id38)]

[https://en.wikipedia.org/wiki/Euler%E2%80%93Jacobi_pseudoprime](https://en.wikipedia.org/wiki/Euler%E2%80%93Jacobi_pseudoprime)

```py
sympy.ntheory.primetest.is_square(n, prep=True)
```

如果 n == a * a 则返回 True，否则返回 False。如果怀疑 n *不* 是一个平方数，则这是确认其不是的快速方法。

示例

```py
>>> from sympy.ntheory.primetest import is_square
>>> is_square(25)
True
>>> is_square(2)
False 
```

另请参阅

[`sympy.core.intfunc.isqrt`](core.html#sympy.core.intfunc.isqrt "sympy.core.intfunc.isqrt")

参考文献

[[R683](#id39)]

[https://mersenneforum.org/showpost.php?p=110896](https://mersenneforum.org/showpost.php?p=110896)

```py
sympy.ntheory.primetest.mr(n, bases)
```

对 n 执行 Miller-Rabin 强伪素数测试，使用给定的基数/见证者列表。

示例

```py
>>> from sympy.ntheory.primetest import mr
>>> mr(1373651, [2, 3])
False
>>> mr(479001599, [31, 73])
True 
```

References

[[R684](#id40)]

Richard Crandall & Carl Pomerance (2005), “Prime Numbers: A Computational Perspective”, Springer, 2nd edition, 135-138

一个阈值列表及其所需的基数见这里：[https://zh.wikipedia.org/wiki/Miller%E2%80%93Rabin%E8%B4%A8%E6%80%A7%E6%80%A7%E6%A3%80%E6%B5%8B#确定性变体](https://zh.wikipedia.org/wiki/Miller%E2%80%93Rabin%E8%B4%A8%E6%80%A7%E6%80%A7%E6%A3%80%E6%B5%8B#确定性变体)

```py
sympy.ntheory.primetest.is_lucas_prp(n)
```

标准 Lucas 复合性测试，使用 Selfridge 参数。如果 n 明确是复合数，则返回 False；如果 n 是 Lucas 可能质数，则返回 True。

这通常与米勒-拉宾测试结合使用。

示例

```py
>>> from sympy.ntheory.primetest import isprime, is_lucas_prp
>>> for i in range(10000):
...     if is_lucas_prp(i) and not isprime(i):
...         print(i)
323
377
1159
1829
3827
5459
5777
9071
9179 
```

References

[[R685](#id41)]

Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6) [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)

[[R686](#id42)]

OEIS A217120: Lucas 伪素数 [https://oeis.org/A217120](https://oeis.org/A217120)

[[R687](#id43)]

[https://zh.wikipedia.org/wiki/%E8%8E%B1%E5%8D%A1%E6%96%AF%E8%99%9A%E7%B4%A0%E5%88%86%E6%9E%90](https://zh.wikipedia.org/wiki/%E8%8E%B1%E5%8D%A1%E6%96%AF%E8%99%9A%E7%B4%A0%E5%88%86%E6%9E%90)

```py
sympy.ntheory.primetest.is_strong_lucas_prp(n)
```

强 Lucas 复合性测试，使用 Selfridge 参数。如果 n 明确是复合数，则返回 False；如果 n 是强 Lucas 可能质数，则返回 True。

这通常与米勒-拉宾测试结合使用，特别是与 M-R 基数 2 结合创建强 BPSW 测试时。

示例

```py
>>> from sympy.ntheory.primetest import isprime, is_strong_lucas_prp
>>> for i in range(20000):
...     if is_strong_lucas_prp(i) and not isprime(i):
...        print(i)
5459
5777
10877
16109
18971 
```

References

[[R688](#id44)]

Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6) [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)

[[R689](#id45)]

OEIS A217255: 强 Lucas 伪素数 [https://oeis.org/A217255](https://oeis.org/A217255)

[[R690](#id46)]

[https://zh.wikipedia.org/wiki/%E8%8E%B1%E5%8D%A1%E6%96%AF%E8%99%9A%E7%B4%A0%E5%88%86%E6%9E%90](https://zh.wikipedia.org/wiki/%E8%8E%B1%E5%8D%A1%E6%96%AF%E8%99%9A%E7%B4%A0%E5%88%86%E6%9E%90)

[[R691](#id47)]

[https://zh.wikipedia.org/wiki/Baillie-PSW%E8%B4%A8%E6%95%B0%E6%B5%8B%E8%AF%95](https://zh.wikipedia.org/wiki/Baillie-PSW%E8%B4%A8%E6%95%B0%E6%B5%8B%E8%AF%95)

```py
sympy.ntheory.primetest.is_extra_strong_lucas_prp(n)
```

额外强 Lucas 复合性测试。如果 n 明确是复合数，则返回 False；如果 n 是“额外强” Lucas 可能质数，则返回 True。

使用 P = 3，Q = 1 选择参数，然后递增 P 直到 (D|n) == -1\. 测试本身如 [[R692]](#r692) 中所定义，出自 Mo 和 Jones 的预印本。参数选择和测试与 OEIS A217719、Perl 的 Math::Prime::Util 以及维基百科上的 Lucas 伪素数页面相同。

它比强测试快 20-50%。

由于选择了不同的参数，强Lucas伪素数和额外强Lucas伪素数之间没有关系。特别地，一个不是另一个的子集。

示例

```py
>>> from sympy.ntheory.primetest import isprime, is_extra_strong_lucas_prp
>>> for i in range(20000):
...     if is_extra_strong_lucas_prp(i) and not isprime(i):
...        print(i)
989
3239
5777
10877 
```

参考文献

[R692] ([1](#id48),[2](#id49))

Jon Grantham，Frobenius伪素数，Math. Comp. Vol 70, Number 234 (2001)，pp. 873-891，[https://doi.org/10.1090%2FS0025-5718-00-01197-2](https://doi.org/10.1090%2FS0025-5718-00-01197-2)

[[R693](#id50)]

OEIS A217719：额外强Lucas伪素数 [https://oeis.org/A217719](https://oeis.org/A217719)

[[R694](#id51)]

[https://zh.wikipedia.org/wiki/Lucas伪素数](https://zh.wikipedia.org/wiki/Lucas伪素数)

```py
sympy.ntheory.primetest.proth_test(n)
```

测试Proth数\(n = k2^m + 1\)是否为素数，其中k是正奇数且\(2^m > k\)。

参数：

**n**：整数

> `n`是Proth数

返回：

**bool**：如果为`True`，则`n`是Proth素数

抛出异常：

**数值错误**

> 如果`n`不是Proth数。

示例

```py
>>> from sympy.ntheory.primetest import proth_test
>>> proth_test(41)
True
>>> proth_test(57)
False 
```

参考文献

[[R695](#id52)]

[https://zh.wikipedia.org/wiki/Proth素数](https://zh.wikipedia.org/wiki/Proth素数)

```py
sympy.ntheory.primetest.is_mersenne_prime(n)
```

如果`n`是梅森素数则返回True，否则返回False。

梅森素数是形如\(2^i - 1\)的素数。

示例

```py
>>> from sympy.ntheory.factor_ import is_mersenne_prime
>>> is_mersenne_prime(6)
False
>>> is_mersenne_prime(127)
True 
```

参考文献

[[R696](#id53)]

[https://mathworld.wolfram.com/MersennePrime.html](https://mathworld.wolfram.com/MersennePrime.html)

```py
sympy.ntheory.primetest.isprime(n)
```

测试n是否为素数（True）或不是素数（False）。对于n < 2^64，答案是确定的；较大的n值可能实际上是伪素数。

负数（例如 -2）不被认为是素数。

第一步是寻找显著因子，如果找到则可以快速返回。接下来，如果筛选器足够大，则在筛选器上使用二分搜索。对于小数字，使用已知在其范围内没有反例的基数进行确定性Miller-Rabin测试。最后，如果数字大于2^64，则执行强BPSW测试。虽然这是一个可能的素数测试，我们相信存在反例，但目前没有已知的反例。

示例

```py
>>> from sympy.ntheory import isprime
>>> isprime(13)
True
>>> isprime(15)
False 
```

注意

此程序仅适用于整数输入，不适用于可能代表数字的数值表达式。浮点数也会被拒绝，因为它们代表有限精度的数字。虽然允许7.0表示整数很诱人，但如果允许这样做可能会“悄悄地”传递错误：

```py
>>> from sympy import Float, S
>>> int(1e3) == 1e3 == 10**3
True
>>> int(1e23) == 1e23
True
>>> int(1e23) == 10**23
False 
```

```py
>>> near_int = 1 + S(1)/10**19
>>> near_int == int(near_int)
False
>>> n = Float(near_int, 10)  # truncated by precision
>>> n % 1 == 0
True
>>> n = Float(near_int, 20)
>>> n % 1 == 0
False 
```

参见

[`sympy.ntheory.generate.primerange`](#sympy.ntheory.generate.primerange "sympy.ntheory.generate.primerange")

在给定范围内生成所有素数

[`sympy.functions.combinatorial.numbers.primepi`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.primepi "sympy.functions.combinatorial.numbers.primepi")

返回小于或等于n的素数数量

[`sympy.ntheory.generate.prime`](#sympy.ntheory.generate.prime "sympy.ntheory.generate.prime")

返回第n个素数

参考文献

[[R697](#id54)]

[https://zh.wikipedia.org/wiki/强伪素数](https://zh.wikipedia.org/wiki/强伪素数)

[[R698](#id55)]

Robert Baillie, Samuel S. Wagstaff, Lucas Pseudoprimes, Math. Comp. Vol 35, Number 152 (1980), pp. 1391-1417, [https://doi.org/10.1090%2FS0025-5718-1980-0583518-6](https://doi.org/10.1090%2FS0025-5718-1980-0583518-6) [http://mpqs.free.fr/LucasPseudoprimes.pdf](http://mpqs.free.fr/LucasPseudoprimes.pdf)

[[R699](#id56)]

[https://en.wikipedia.org/wiki/Baillie-PSW_primality_test](https://en.wikipedia.org/wiki/Baillie-PSW_primality_test)

```py
sympy.ntheory.primetest.is_gaussian_prime(num)
```

测试 num 是否为高斯素数。

参考文献

[[R700](#id57)]

[https://oeis.org/wiki/Gaussian_primes](https://oeis.org/wiki/Gaussian_primes)

```py
sympy.ntheory.residue_ntheory.n_order(a, n)
```

返回 `a` 模 `n` 的阶数。

参数：

**a**：整数

**n**：整数，n > 1。`a` 和 `n` 应该是相对素的。

返回：

**整数**：`a` 模 `n` 的阶数

引发：

**数值错误**

> 如果 \(n \le 1\) 或 \(\gcd(a, n) \neq 1\)。如果 `a` 或 `n` 不是整数。

解释

`a` 模 `n` 的阶数是最小的整数 `k`，使得 \(a^k\) 在 `n` 上留下余数。

示例

```py
>>> from sympy.ntheory import n_order
>>> n_order(3, 7)
6
>>> n_order(4, 7)
3 
```

另请参阅

[`is_primitive_root`](#sympy.ntheory.residue_ntheory.is_primitive_root "sympy.ntheory.residue_ntheory.is_primitive_root")

当 `a` 模 `n` 的阶数等于 `totient(n)` 时，我们说 `a` 是 `n` 的原根。

```py
sympy.ntheory.residue_ntheory.is_primitive_root(a, p)
```

如果 `a` 是 `p` 的原根，则返回 True。

参数：

**a**：整数

**p**：整数，`p` > 1。`a` 和 `p` 应该是相对素的。

返回：

**布尔**：如果为 True，则 `a` 是 `p` 的原根。

引发：

**数值错误**

> 如果 \(p \le 1\) 或 \(\gcd(a, p) \neq 1\)。如果 `a` 或 `p` 不是整数。

解释

如果 \(\gcd(a, p) = 1\) 并且 \(\phi(p)\) 是最小的正数，`a` 被称为 `p` 的原根。

> \(a^{\phi(p)} \equiv 1 \pmod{p}\)。

其中 \(\phi(p)\) 是欧拉函数。

只有对于 \(p = 2, 4, q^e, 2q^e\)（`q` 是奇素数），`p` 的原根才存在。因此，如果不是这样的 `p`，则返回 False。要确定原根，我们需要知道 `q-1` 的素因子分解。这种确定的难度取决于这种复杂性。

示例

```py
>>> from sympy.functions.combinatorial.numbers import totient
>>> from sympy.ntheory import is_primitive_root, n_order
>>> is_primitive_root(3, 10)
True
>>> is_primitive_root(9, 10)
False
>>> n_order(3, 10) == totient(10)
True
>>> n_order(9, 10) == totient(10)
False 
```

另请参阅

[`primitive_root`](#sympy.ntheory.residue_ntheory.primitive_root "sympy.ntheory.residue_ntheory.primitive_root")

```py
sympy.ntheory.residue_ntheory.primitive_root(p, smallest=True)
```

返回 `p` 的一个原根或 None。

参数：

**p**：整数，p > 1

**最小**：如果为 True，则返回最小的原根，否则返回 None。

返回：

int | None：

> 如果存在原根，则返回 `p` 的原根。否则，返回 None。

引发：

**数值错误**

> 如果 \(p \le 1\) 或 `p` 不是整数。

解释

有关原根定义，请参阅 `is_primitive_root` 的解释。

对于`p`的原始根仅适用于\(p = 2, 4, q^e, 2q^e\)（`q`是奇质数）。现在，如果我们知道`q`的原始根，我们可以计算\(q^e\)的原始根，如果我们知道\(q^e\)的原始根，我们可以计算\(2q^e\)的原始根。当不需要找到最小的原始根时，这个性质可以用来获取快速的原始根。另一方面，当我们想要最小的原始根时，我们会天真地确定是否是原始根。

示例

```py
>>> from sympy.ntheory.residue_ntheory import primitive_root
>>> primitive_root(19)
2
>>> primitive_root(21) is None
True
>>> primitive_root(50, smallest=False)
27 
```

另请参阅

[`is_primitive_root`](#sympy.ntheory.residue_ntheory.is_primitive_root "sympy.ntheory.residue_ntheory.is_primitive_root")

引用

[[R701](#id58)]

1.  Stein“初等数论”（2011年），第44页

[[R702](#id59)]

1.  Hackman“初等数论”（2009年），第C章

```py
sympy.ntheory.residue_ntheory.sqrt_mod(a, p, all_roots=False)
```

查找`x**2 = a mod p`的根。

参数：

**a** ：整数

**p** ：正整数

**all_roots** ：如果为True则返回根列表或None

注：

如果没有根则返回None；否则返回的根小于或等于`p // 2`；一般来说不是最小的。仅当它是唯一的根时返回`p // 2`。

仅在预期所有根都适合内存时使用`all_roots`；否则使用`sqrt_mod_iter`。

示例

```py
>>> from sympy.ntheory import sqrt_mod
>>> sqrt_mod(11, 43)
21
>>> sqrt_mod(17, 32, True)
[7, 9, 23, 25] 
```

```py
sympy.ntheory.residue_ntheory.sqrt_mod_iter(a, p, domain=<class 'int'>)
```

迭代解决`x**2 = a mod p`。

参数：

**a** ：整数

**p** ：正整数

**domain** ：整数域，`int`，`ZZ` 或 `Integer`

示例

```py
>>> from sympy.ntheory.residue_ntheory import sqrt_mod_iter
>>> list(sqrt_mod_iter(11, 43))
[21, 22] 
```

另请参阅

[`sqrt_mod`](#sympy.ntheory.residue_ntheory.sqrt_mod "sympy.ntheory.residue_ntheory.sqrt_mod")

具有相同功能，但要求排序列表或仅有一个解。

```py
sympy.ntheory.residue_ntheory.quadratic_residues(p) → list[int]
```

返回二次剩余的列表。

示例

```py
>>> from sympy.ntheory.residue_ntheory import quadratic_residues
>>> quadratic_residues(7)
[0, 1, 2, 4] 
```

```py
sympy.ntheory.residue_ntheory.nthroot_mod(a, n, p, all_roots=False)
```

找到`x**n = a mod p`的解决方案。

参数：

**a** ：整数

**n** ：正整数

**p** ：正整数

**all_roots** ：如果为False，则返回最小的根，否则返回根列表

返回：

list[int] | int | None：

> 解决`x**n = a mod p`。输出类型表如下：
> 
> | all_roots | has roots | Returns |
> | --- | --- | --- |
> | True | Yes | list[int] |
> | True | No | [] |
> | False | Yes | int |
> | False | No | None |

引发：

**ValueError**

> 如果`a`，`n`或`p`不是整数。如果`n`或`p`不是正数。

示例

```py
>>> from sympy.ntheory.residue_ntheory import nthroot_mod
>>> nthroot_mod(11, 4, 19)
8
>>> nthroot_mod(11, 4, 19, True)
[8, 11]
>>> nthroot_mod(68, 3, 109)
23 
```

引用

[[R703](#id60)]

1.  Hackman“初等数论”（2009年），第76页

```py
sympy.ntheory.residue_ntheory.is_nthpow_residue(a, n, m)
```

如果`x**n == a (mod m)`有解则返回True。

引用

[[R704](#id61)]

1.  Hackman“初等数论”（2009年），第76页

```py
sympy.ntheory.residue_ntheory.is_quad_residue(a, p)
```

如果`a`（mod `p`）在`p`的平方集中，则返回True，即a % p在set([i**2 % p for i in range(p)])中。

参数：

**a** ：整数

**p** ：正整数

返回：

**bool** ：如果为True，则`x**2 == a (mod p)`有解。

引发：

**ValueError**

> 如果`a`，`p`不是整数。如果`p`不是正数。

示例

```py
>>> from sympy.ntheory import is_quad_residue
>>> is_quad_residue(21, 100)
True 
```

实际上，`pow(39, 2, 100)`将是21。

```py
>>> is_quad_residue(21, 120)
False 
```

即，对于任何整数`x`，`pow(x, 2, 120)`不是21。

如果`p`是奇质数，则使用迭代方法进行确定：

```py
>>> from sympy.ntheory import is_quad_residue
>>> sorted(set([i**2 % 7 for i in range(7)]))
[0, 1, 2, 4]
>>> [j for j in range(7) if is_quad_residue(j, 7)]
[0, 1, 2, 4] 
```

另请参阅

[`legendre_symbol`](#sympy.ntheory.residue_ntheory.legendre_symbol "sympy.ntheory.residue_ntheory.legendre_symbol"), [`jacobi_symbol`](#sympy.ntheory.residue_ntheory.jacobi_symbol "sympy.ntheory.residue_ntheory.jacobi_symbol"), [`sqrt_mod`](#sympy.ntheory.residue_ntheory.sqrt_mod "sympy.ntheory.residue_ntheory.sqrt_mod")

```py
sympy.ntheory.residue_ntheory.legendre_symbol(a, p)
```

返回勒让德符号 \((a / p)\)。

自版本 1.13 起已弃用：`legendre_symbol` 函数已弃用。请使用 [`sympy.functions.combinatorial.numbers.legendre_symbol`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.legendre_symbol "sympy.functions.combinatorial.numbers.legendre_symbol") 替代。更多信息请参阅其文档。参见 [将符号函数从 ntheory 迁移到 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions) 以获取详细信息。

对于整数 `a` 和奇素数 `p`，勒让德符号定义为

\[\begin{split}\genfrac(){}{}{a}{p} = \begin{cases} 0 & \text{如果 } p \text{ 整除 } a\\ 1 & \text{如果 } a \text{ 是模 } p \text{ 的二次剩余}\\ -1 & \text{如果 } a \text{ 是模 } p \text{ 的二次非剩余} \end{cases}\end{split}\]

参数：

**a** : 整数

**p** : 奇素数

示例

```py
>>> from sympy.functions.combinatorial.numbers import legendre_symbol
>>> [legendre_symbol(i, 7) for i in range(7)]
[0, 1, 1, -1, 1, -1, -1]
>>> sorted(set([i**2 % 7 for i in range(7)]))
[0, 1, 2, 4] 
```

参见

[`is_quad_residue`](#sympy.ntheory.residue_ntheory.is_quad_residue "sympy.ntheory.residue_ntheory.is_quad_residue"), [`jacobi_symbol`](#sympy.ntheory.residue_ntheory.jacobi_symbol "sympy.ntheory.residue_ntheory.jacobi_symbol")

```py
sympy.ntheory.residue_ntheory.jacobi_symbol(m, n)
```

返回雅可比符号 \((m / n)\)。

自版本 1.13 起已弃用：`jacobi_symbol` 函数已弃用。请使用 [`sympy.functions.combinatorial.numbers.jacobi_symbol`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.jacobi_symbol "sympy.functions.combinatorial.numbers.jacobi_symbol") 替代。更多信息请参阅其文档。参见 [将符号函数从 ntheory 迁移到 functions](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions) 以获取详细信息。

对于任意整数 `m` 和任意正奇整数 `n`，雅可比符号定义为 `n` 的素因子对应的勒让德符号的乘积：

\[\genfrac(){}{}{m}{n} = \genfrac(){}{}{m}{p^{1}}^{\alpha_1} \genfrac(){}{}{m}{p^{2}}^{\alpha_2} ... \genfrac(){}{}{m}{p^{k}}^{\alpha_k} \text{ 其中 } n = p_1^{\alpha_1} p_2^{\alpha_2} ... p_k^{\alpha_k}\]

像勒让德符号一样，如果雅可比符号 \(\genfrac(){}{}{m}{n} = -1\)，则 `m` 是模 `n` 的二次非剩余。

但与勒让德符号不同的是，如果雅可比符号 \(\genfrac(){}{}{m}{n} = 1\)，则 `m` 可能是模 `n` 的二次剩余，也可能不是。

参数：

**m** : 整数

**n** : 奇正整数

示例

```py
>>> from sympy.functions.combinatorial.numbers import jacobi_symbol, legendre_symbol
>>> from sympy import S
>>> jacobi_symbol(45, 77)
-1
>>> jacobi_symbol(60, 121)
1 
```

`jacobi_symbol` 和 `legendre_symbol` 之间的关系可以如下所示：

```py
>>> L = legendre_symbol
>>> S(45).factors()
{3: 2, 5: 1}
>>> jacobi_symbol(7, 45) == L(7, 3)**2 * L(7, 5)**1
True 
```

参见

[`is_quad_residue`](#sympy.ntheory.residue_ntheory.is_quad_residue "sympy.ntheory.residue_ntheory.is_quad_residue")，[`legendre_symbol`](#sympy.ntheory.residue_ntheory.legendre_symbol "sympy.ntheory.residue_ntheory.legendre_symbol")

```py
sympy.ntheory.residue_ntheory.mobius(n)
```

Möbius 函数将自然数映射到{-1, 0, 1}

自版本1.13起不推荐使用`mobius`函数。请使用[`sympy.functions.combinatorial.numbers.mobius`](functions/combinatorial.html#sympy.functions.combinatorial.numbers.mobius "sympy.functions.combinatorial.numbers.mobius")。有关详细信息，请参阅其文档。有关详细信息，请参阅[从ntheory移动符号函数](../explanation/active-deprecations.html#deprecated-ntheory-symbolic-functions)。

定义如下：

1.  如果\(n = 1\)，则为\(1\)。

1.  如果\(n\)有一个平方素因子，则为\(0\)。

1.  如果\(n\)是具有\(k\)个素因子的无平方正整数，则为\((-1)^k\)。

它是数论和组合数学中的重要乘性函数。在数学级数、代数数论以及物理学中（费米子算子与 Möbius 函数模型有着非常具体的实现）有应用。

参数：

**n** : 正整数

示例

```py
>>> from sympy.functions.combinatorial.numbers import mobius
>>> mobius(13*7)
1
>>> mobius(1)
1
>>> mobius(13*7*5)
-1
>>> mobius(13**2)
0 
```

参考文献

[[R705](#id62)]

[https://en.wikipedia.org/wiki/M%C3%B6bius_function](https://en.wikipedia.org/wiki/M%C3%B6bius_function)

[[R706](#id63)]

Thomas Koshy 的《Elementary Number Theory with Applications》

```py
sympy.ntheory.residue_ntheory.discrete_log(n, a, b, order=None, prime_order=None)
```

计算`a`以模`n`为底的离散对数。

这是一个递归函数，用于将复合阶循环群中的离散对数问题简化为素数阶循环群中的问题。

它根据问题使用不同的算法（子群阶大小，是否为素数阶）：

> +   试乘法
> +   
> +   Baby-step giant-step算法
> +   
> +   波拉德Rho算法
> +   
> +   指数演算法
> +   
> +   Pohlig-Hellman

示例

```py
>>> from sympy.ntheory import discrete_log
>>> discrete_log(41, 15, 7)
3 
```

参考文献

[[R707](#id64)]

[https://mathworld.wolfram.com/DiscreteLogarithm.html](https://mathworld.wolfram.com/DiscreteLogarithm.html)

[[R708](#id65)]

“应用密码学手册”，Menezes, A. J., Van, O. P. C., & Vanstone, S. A. (1997).

```py
sympy.ntheory.residue_ntheory.quadratic_congruence(a, b, c, n)
```

找到满足\(a x^2 + b x + c \equiv 0 \pmod{n}\)的解。

参数：

**a** : int

**b** : int

**c** : int

**n** : int

> 正整数。

返回：

list[int]：

> 解的排序列表。如果没有解，则为`[]`。

示例

```py
>>> from sympy.ntheory.residue_ntheory import quadratic_congruence
>>> quadratic_congruence(2, 5, 3, 7) # 2x^2 + 5x + 3 = 0 (mod 7)
[2, 6]
>>> quadratic_congruence(8, 6, 4, 15) # No solution
[] 
```

参见

[`polynomial_congruence`](#sympy.ntheory.residue_ntheory.polynomial_congruence "sympy.ntheory.residue_ntheory.polynomial_congruence")

解多项式同余方程

```py
sympy.ntheory.residue_ntheory.polynomial_congruence(expr, m)
```

解多项式同余方程模m。

参数：

**expr** : 整数系数多项式

**m** : 正整数

示例

```py
>>> from sympy.ntheory import polynomial_congruence
>>> from sympy.abc import x
>>> expr = x**6 - 2*x**5 -35
>>> polynomial_congruence(expr, 6125)
[3257] 
```

参见

[`sympy.polys.galoistools.gf_csolve`](polys/internals.html#sympy.polys.galoistools.gf_csolve "sympy.polys.galoistools.gf_csolve")

低级解决例程由该例程使用

```py
sympy.ntheory.residue_ntheory.binomial_mod(n, m, k)
```

计算`binomial(n, m) % k`。

参数：

**n** : 整数

**m** : 整数

**k** : 正整数

解释

使用 Lucas 定理的一般化与 Granville 的 [R709](#r709)（由中国剩余定理）提供的素数幂的余数计算时间为 O(log^2(n) + q^4*log(n)log(p) + q^4*p*log^3(p))。

例子

```py
>>> from sympy.ntheory.residue_ntheory import binomial_mod
>>> binomial_mod(10, 2, 6)  # binomial(10, 2) = 45
3
>>> binomial_mod(17, 9, 10)  # binomial(17, 9) = 24310
0 
```

参考文献

[R709] ([1](#id66),[2](#id67))

模素数幂的二项式系数，Andrew Granville，可用：[https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf](https://web.archive.org/web/20170202003812/http://www.dms.umontreal.ca/~andrew/PDF/BinCoeff.pdf)

```py
sympy.ntheory.continued_fraction.continued_fraction(a) → list
```

返回有理数或二次无理数的连分数表示。

例子

```py
>>> from sympy.ntheory.continued_fraction import continued_fraction
>>> from sympy import sqrt
>>> continued_fraction((1 + 2*sqrt(3))/5)
[0, 1, [8, 3, 34, 3]] 
```

另见

[`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic "sympy.ntheory.continued_fraction.continued_fraction_periodic"), [`continued_fraction_reduce`](#sympy.ntheory.continued_fraction.continued_fraction_reduce "sympy.ntheory.continued_fraction.continued_fraction_reduce"), [`continued_fraction_convergents`](#sympy.ntheory.continued_fraction.continued_fraction_convergents "sympy.ntheory.continued_fraction.continued_fraction_convergents")

```py
sympy.ntheory.continued_fraction.continued_fraction_convergents(cf)
```

返回一个连分数（CF）的收敛数迭代器。

参数应该是以下两种形式之一：- 部分商的列表，最后一个元素可能是重复的部分商列表，例如由 continued_fraction 和 continued_fraction_periodic 返回的形式。- 返回连分数的连续部分商的可迭代对象，例如由 continued_fraction_iterator 返回的形式。

在计算收敛分数时，连分数不必严格处于规范形式（全为整数，除了第一个为正数）。分数和负数元素可能存在于展开中。

例子

```py
>>> from sympy.core import pi
>>> from sympy import S
>>> from sympy.ntheory.continued_fraction import             continued_fraction_convergents, continued_fraction_iterator 
```

```py
>>> list(continued_fraction_convergents([0, 2, 1, 2]))
[0, 1/2, 1/3, 3/8] 
```

```py
>>> list(continued_fraction_convergents([1, S('1/2'), -7, S('1/4')]))
[1, 3, 19/5, 7] 
```

```py
>>> it = continued_fraction_convergents(continued_fraction_iterator(pi))
>>> for n in range(7):
...     print(next(it))
3
22/7
333/106
355/113
103993/33102
104348/33215
208341/66317 
```

```py
>>> it = continued_fraction_convergents([1, [1, 2]])  # sqrt(3)
>>> for n in range(7):
...     print(next(it))
1
2
5/3
7/4
19/11
26/15
71/41 
```

另见

[`continued_fraction_iterator`](#sympy.ntheory.continued_fraction.continued_fraction_iterator "sympy.ntheory.continued_fraction.continued_fraction_iterator"), [`continued_fraction`](#sympy.ntheory.continued_fraction.continued_fraction "sympy.ntheory.continued_fraction.continued_fraction"), [`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic "sympy.ntheory.continued_fraction.continued_fraction_periodic")

```py
sympy.ntheory.continued_fraction.continued_fraction_iterator(x)
```

返回 x 的连分数展开作为迭代器。

例子

```py
>>> from sympy import Rational, pi
>>> from sympy.ntheory.continued_fraction import continued_fraction_iterator 
```

```py
>>> list(continued_fraction_iterator(Rational(3, 8)))
[0, 2, 1, 2]
>>> list(continued_fraction_iterator(Rational(-3, 8)))
[-1, 1, 1, 1, 2] 
```

```py
>>> for i, v in enumerate(continued_fraction_iterator(pi)):
...     if i > 7:
...         break
...     print(v)
3
7
15
1
292
1
1
1 
```

参考文献

[[R710](#id68)]

[https://zh.wikipedia.org/wiki/连分数](https://zh.wikipedia.org/wiki/连分数)

```py
sympy.ntheory.continued_fraction.continued_fraction_periodic(p, q, d=0, s=1) → list
```

找到二次无理数的周期连分数展开。

计算有理数或二次无理数的连分数展开，即 \(\frac{p + s\sqrt{d}}{q}\)，其中 \(p\)，\(q \ne 0\)，\(d \ge 0\) 为整数。

作为整数列表返回连分数表示（规范形式），对于二次无理数，可选地以表示重复数字的整数列表结束。

参数：

**p** : int

> 数字的有理数部分

**q**：整数

> 数字的分母

**d**：整数，可选

> 数字的分母

**s**：整数，可选

> 无理部分的系数

示例

```py
>>> from sympy.ntheory.continued_fraction import continued_fraction_periodic
>>> continued_fraction_periodic(3, 2, 7)
[2, [1, 4, 1, 1]] 
```

黄金分割率具有最简单的连分数展开：

```py
>>> continued_fraction_periodic(1, 2, 5)
[[1]] 
```

如果鉴别器为零或完全平方数，则该数字将是有理数：

```py
>>> continued_fraction_periodic(4, 3, 0)
[1, 3]
>>> continued_fraction_periodic(4, 3, 49)
[3, 1, 2] 
```

另见

[`continued_fraction_iterator`](#sympy.ntheory.continued_fraction.continued_fraction_iterator "sympy.ntheory.continued_fraction.continued_fraction_iterator"), [`continued_fraction_reduce`](#sympy.ntheory.continued_fraction.continued_fraction_reduce "sympy.ntheory.continued_fraction.continued_fraction_reduce")

参考文献

[[R711](#id69)]

[https://zh.wikipedia.org/wiki/周期连分数](https://zh.wikipedia.org/wiki/周期连分数)

[[R712](#id70)]

K. Rosen. Elementary Number theory and its applications. Addison-Wesley, 3 Sub edition, pages 379-381, January 1992.

```py
sympy.ntheory.continued_fraction.continued_fraction_reduce(cf)
```

将一个连分数化简为有理数或二次无理数。

从其终止或周期连分数展开计算有理或二次无理数。连分数展开（cf）应被视为提供展开项的终止迭代器。对于终止连分数，这相当于`list(continued_fraction_convergents(cf))[-1]`，只是效率稍高。如果展开部分重复，迭代器应返回重复项的列表作为最后一个元素。这是由continued_fraction_periodic返回的格式。

对于二次无理数，如果分数处于规范形式（除第一个外所有项均为正），则返回找到的最大解，通常是所需解。

示例

```py
>>> from sympy.ntheory.continued_fraction import continued_fraction_reduce
>>> continued_fraction_reduce([1, 2, 3, 4, 5])
225/157
>>> continued_fraction_reduce([-2, 1, 9, 7, 1, 2])
-256/233
>>> continued_fraction_reduce([2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8]).n(10)
2.718281835
>>> continued_fraction_reduce([1, 4, 2, [3, 1]])
(sqrt(21) + 287)/238
>>> continued_fraction_reduce([[1]])
(1 + sqrt(5))/2
>>> from sympy.ntheory.continued_fraction import continued_fraction_periodic
>>> continued_fraction_reduce(continued_fraction_periodic(8, 5, 13))
(sqrt(13) + 8)/5 
```

另见

[`continued_fraction_periodic`](#sympy.ntheory.continued_fraction.continued_fraction_periodic "sympy.ntheory.continued_fraction.continued_fraction_periodic")

```py
sympy.ntheory.digits.count_digits(n, b=10)
```

返回一个字典，其键是数字`n`在给定基数`b`中的数字，键表示数字出现在数字中的位置，值表示该数字出现的次数。

示例

```py
>>> from sympy.ntheory import count_digits 
```

```py
>>> count_digits(1111339)
{1: 4, 3: 2, 9: 1} 
```

返回的数字始终以十进制表示，但数字本身可以以Python理解的任何格式输入；如果数字的基数与10不同，也可以给出数字的基数：

```py
>>> n = 0xFA; n
250
>>> count_digits(_)
{0: 1, 2: 1, 5: 1}
>>> count_digits(n, 16)
{10: 1, 15: 1} 
```

默认情况下，字典将对任何未出现在数字中的数字返回0。例如，`77!`中出现7次的数字有哪些：

```py
>>> from sympy import factorial
>>> c77 = count_digits(factorial(77))
>>> [i for i in range(10) if c77[i] == 7]
[1, 3, 7, 9] 
```

另见

[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"), [`digits`](#sympy.ntheory.digits.digits "sympy.ntheory.digits.digits")

```py
sympy.ntheory.digits.digits(n, b=10, digits=None)
```

返回`n`在基数`b`中的数字列表。列表中的第一个元素是`b`（如果`n`为负，则为`-b`）。

参数：

**n：整数**

> 返回数字的位数。

**b：整数**

> 计算数字的基数。

**digits：整数（或所有数字的None）**

> 要返回的数字位数（如有必要，用零填充）。

示例

```py
>>> from sympy.ntheory.digits import digits
>>> digits(35)
[10, 3, 5] 
```

如果数字为负，则负号将放在基数上（即返回列表中的第一个元素）：

```py
>>> digits(-35)
[-10, 3, 5] 
```

可以选择除了 10（大于 1 的）以外的基数 `b`：

```py
>>> digits(27, b=2)
[2, 1, 1, 0, 1, 1] 
```

如果需要某个特定数量的数字，请使用 `digits` 关键字：

```py
>>> digits(35, digits=4)
[10, 0, 0, 3, 5] 
```

另请参阅

[`sympy.core.intfunc.num_digits`](core.html#sympy.core.intfunc.num_digits "sympy.core.intfunc.num_digits"), [`count_digits`](#sympy.ntheory.digits.count_digits "sympy.ntheory.digits.count_digits")

```py
sympy.ntheory.digits.is_palindromic(n, b=10)
```

如果在给定的基数 `b` 中从左到右或从右到左读取 `n` 时相同，则返回 True。

示例

```py
>>> from sympy.ntheory import is_palindromic 
```

```py
>>> all(is_palindromic(i) for i in (-11, 1, 22, 121))
True 
```

第二个参数允许您在其他基数中测试数字。例如，88 在十进制中是回文的，但在八进制中不是：

```py
>>> is_palindromic(88, 8)
False 
```

另一方面，一个数字在八进制中可能是回文的，但在十进制中不是：

```py
>>> 0o121, is_palindromic(0o121)
(81, False) 
```

或者在两个基础上是回文的：

```py
>>> oct(121), is_palindromic(121, 8) and is_palindromic(121)
('0o171', True) 
```

```py
sympy.ntheory.egyptian_fraction.egyptian_fraction(r, algorithm='Greedy')
```

返回所述有理数 \(r\) 的埃及分数展开的分母列表[[R713]](#r713)。

参数：

**r**：有理数或（p，q）

> 正有理数 `p/q`。

**algorithm**：{“贪婪”，“Graham Jewett”，“Takenouchi”，“Golomb”}，可选

> 指定要使用的算法（默认为“贪婪”）。

示例

```py
>>> from sympy import Rational
>>> from sympy.ntheory.egyptian_fraction import egyptian_fraction
>>> egyptian_fraction(Rational(3, 7))
[3, 11, 231]
>>> egyptian_fraction((3, 7), "Graham Jewett")
[7, 8, 9, 56, 57, 72, 3192]
>>> egyptian_fraction((3, 7), "Takenouchi")
[4, 7, 28]
>>> egyptian_fraction((3, 7), "Golomb")
[3, 15, 35]
>>> egyptian_fraction((11, 5), "Golomb")
[1, 2, 3, 4, 9, 234, 1118, 2580] 
```

注意事项

目前支持以下算法：

1.  贪婪算法

    也称为 Fibonacci-Sylvester 算法[[R714]](#r714)。在每一步中，提取小于目标的最大单位分数，并用余数替换目标。

    它具有一些独特的属性：

    1.  给定最简分数 \(p/q\)，生成最大长度 \(p\) 的展开。即使分子变大，项数也很少超过一把。

    1.  使用最小内存。

    1.  术语可以爆炸（其标准示例为 5/121 和 31/311）。每一步中的分母最多是平方的（双指数增长），通常表现出单指数增长。

1.  Graham Jewett 算法

    根据 Graham 和 Jewett 的结果建议的算法。请注意，这倾向于爆炸：结果展开的长度始终为 `2**(x/gcd(x, y)) - 1`。参见[[R715]](#r715)。

1.  Takenouchi 算法

    由 Takenouchi（1921）建议的算法。与 Graham-Jewett 算法仅在处理重复项时有所不同。参见[[R715]](#r715)。

1.  Golomb 算法

    由 Golumb（1962）提出的方法，使用模算术和逆元。它与 Bleicher（1972）提出的使用连分数的方法产生相同的结果。参见[[R716]](#r716)。

如果给定的有理数大于或等于1，则使用贪婪算法对和谐序列1/1 + 1/2 + 1/3 + …进行求和，直到添加一个以上的单位分数会比给定的数字大。这些分母的列表被添加到从剩余部分使用的请求算法的结果前面。例如，如果r是8/3，使用贪婪算法，我们得到[1, 2, 3, 4, 5, 6, 7, 14, 420]，其中序列的开头[1, 2, 3, 4, 5, 6, 7]是和谐序列的一部分，总和为363/140，剩余31/420，贪婪算法产生[14, 420]。埃及分数(Rational(8, 3),“Golomb”)的结果是[1, 2, 3, 4, 5, 6, 7, 14, 574, 2788, 6460, 11590, 33062, 113820]，等等。

另见

[`sympy.core.numbers.Rational`](core.html#sympy.core.numbers.Rational "sympy.core.numbers.Rational")

参考文献

[R713] ([1](#id71),[2](#id76))

[https://en.wikipedia.org/wiki/Egyptian_fraction](https://en.wikipedia.org/wiki/Egyptian_fraction)

[R714] ([1](#id72),[2](#id77))

[https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions](https://en.wikipedia.org/wiki/Greedy_algorithm_for_Egyptian_fractions)

[R715] ([1](#id73),[2](#id74),[3](#id78))

[https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html](https://www.ics.uci.edu/~eppstein/numth/egypt/conflict.html)

[R716] ([1](#id75),[2](#id79))

[https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf](https://web.archive.org/web/20180413004012/https://ami.ektf.hu/uploads/papers/finalpdf/AMI_42_from129to134.pdf)

```py
sympy.ntheory.bbp_pi.pi_hex_digits(n, prec=14)
```

返回一个包含`prec`（默认为14）个十六进制π的第n位开始的数字的字符串。数字的计数从0开始，小数点不计入，所以当n = 0时，返回的值以3开头；n = 1对应于小数点后的第一个数字（在十六进制中为2）。

参数：

**n**：非负整数

**prec**：非负整数，默认为14

返回：

**str**：返回一个包含`prec`个数字的字符串

> 从π的第n位开始的十六进制。如果`prec` = 0，则返回空字符串。

提升：

**ValueError**

> 如果`n` < 0或`prec` < 0。或`n`或`prec`不是整数。

示例

```py
>>> from sympy.ntheory.bbp_pi import pi_hex_digits
>>> pi_hex_digits(0)
'3243f6a8885a30'
>>> pi_hex_digits(0, 3)
'324' 
```

这些与以下结果一致

```py
>>> import math
>>> hex(int(math.pi * 2**((14-1)*4)))
'0x3243f6a8885a30'
>>> hex(int(math.pi * 2**((3-1)*4)))
'0x324' 
```

参考文献

[[R717](#id80)]

[http://www.numberworld.org/digits/Pi/](http://www.numberworld.org/digits/Pi/)

## ECM函数

`ecm`函数是一个次指数因数分解算法，能够在几秒钟内轻松地因式分解大约35位数的数字。`ecm`的时间复杂度取决于该数的最小真因数。因此，即使数字很大，但其因子相对较小，`ecm`也可以轻松地对其进行因式分解。例如，我们取带有15位数因子的N，如15154262241479，15423094826093，799333555511111，809709509409109，888888877777777，914148152112161。现在N是一个87位数。`ECM`需要大约47秒来因式分解它。

```py
sympy.ntheory.ecm.ecm(n, B1=10000, B2=100000, max_curve=200, seed=1234)
```

使用Lenstra的椭圆曲线方法进行因式分解。

此函数重复调用 `_ecm_one_factor` 来计算n的因子。首先通过试除法去除所有小因子。然后使用 `_ecm_one_factor` 逐个计算一个因子。

参数：

**n** : 待分解的数

**B1** : 第1阶段界限。必须是偶数。

**B2** : 第2阶段界限。必须是偶数。

**max_curve** : 生成的最大曲线数

**seed** : 初始化伪随机生成器

示例

```py
>>> from sympy.ntheory import ecm
>>> ecm(25645121643901801)
{5394769, 4753701529}
>>> ecm(9804659461513846513)
{4641991, 2112166839943} 
```

### 示例

```py
>>> from sympy.ntheory import ecm
>>> ecm(7060005655815754299976961394452809, B1=100000, B2=1000000)
{6988699669998001, 1010203040506070809}
>>> ecm(122921448543883967430908091422761898618349713604256384403202282756086473494959648313841, B1=100000, B2=1000000)
{15154262241479,
15423094826093,
799333555511111,
809709509409109,
888888877777777,
914148152112161} 
```  ## QS函数

qs函数是一种亚指数复杂度的因式分解算法，适用于100位数以内的最快因式分解算法。qs的时间复杂度取决于数的大小，因此如果数包含大因子，则使用qs。因此，在因式分解数时，首先使用ecm获得约15位数的较小因子，然后使用qs获取较大因子。

用于因式分解 \(2709077133180915240135586837960864768806330782747\) 的半素数，其具有两个25位数的因子。qs能在大约248秒内完成对其的因式分解。

```py
sympy.ntheory.qs.qs(N, prime_bound, M, ERROR_TERM=25, seed=1234)
```

使用自初始化二次筛法进行因式分解。在SIQS中，令N为待分解的数，且N不应为完全幂。如果我们找到两个整数使得 `X**2 = Y**2 modN` 且 `X != +-Y modN`，那么 \(gcd(X + Y, N)\) 将显示出N的一个正确因子。为了找到这些整数X和Y，我们试图找到形如 t**2 = u modN 的关系，其中u是小质数的乘积。如果我们有足够多的这些关系，我们可以形成 `(t1*t2...ti)**2 = u1*u2...ui modN`，使右边是一个平方数，因此我们找到了一个关系 `X**2 = Y**2 modN`。

这里进行了几项优化，如使用多项式筛选、快速切换多项式和使用部分关系。部分关系的使用可以使因式分解加速2倍。

参数：

**N** : 待分解的数

**prime_bound** : 质因数基中的质数上限

**M** : 筛选区间

**ERROR_TERM** : 检查平滑性的误差项

**threshold** : 因式分解的额外平滑关系

**seed** : 生成伪质数

示例

```py
>>> from sympy.ntheory import qs
>>> qs(25645121643901801, 2000, 10000)
{5394769, 4753701529}
>>> qs(9804659461513846513, 2000, 10000)
{4641991, 2112166839943} 
```

参考文献

[[R718](#id81)]

[https://pdfs.semanticscholar.org/5c52/8a975c1405bd35c65993abf5a4edb667c1db.pdf](https://pdfs.semanticscholar.org/5c52/8a975c1405bd35c65993abf5a4edb667c1db.pdf)

[[R719](#id82)]

[https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve](https://www.rieselprime.de/ziki/Self-initializing_quadratic_sieve)

### 示例

```py
>>> from sympy.ntheory import qs
>>> qs(5915587277*3267000013, 1000, 10000)
{3267000013, 5915587277} 
```
