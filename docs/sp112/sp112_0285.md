# `scipy.linalg.qr_update`

> 原文：[`docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.qr_update.html#scipy.linalg.qr_update`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.qr_update.html#scipy.linalg.qr_update)

```py
scipy.linalg.qr_update(Q, R, u, v, overwrite_qruv=False, check_finite=True)
```

排名 k 的 QR 更新

如果`A = Q R`是`A`的 QR 分解，则返回`A + u v**T`的 QR 分解（对于实数`A`）或`A + u v**H`的 QR 分解（对于复数`A`）。

参数：

**Q**(M, M) 或 (M, N) 类似数组

QR 分解后的酉/正交矩阵。

**R**(M, N) 或 (N, N) 类似数组

QR 分解后的上三角矩阵。

**u**(M,) 或 (M, k) 类似数组

左侧更新向量

**v**(N,) 或 (N, k) 类似数组

右侧更新向量

**overwrite_qruv** bool，可选

如果为 True，在执行更新时尽可能消耗 Q、R、u 和 v，否则根据需要进行复制。默认为 False。

**check_finite** bool，可选

是否检查输入矩阵仅包含有限数字。禁用可能会提高性能，但如果输入确实包含无穷大或 NaN，可能会导致问题（崩溃、非终止）。默认为 True。

返回：

**Q1** ndarray

更新后的酉/正交因子

**R1** ndarray

更新后的上三角因子

另见

`qr`, `qr_multiply`, `qr_delete`, `qr_insert`

注释

此例程不保证*R1*的对角线条目是实数或正数。

新版本 0.16.0 中新增。

参考文献

[1]

高卢布（G. H.）与范伦（C. F.）·卢恩，《矩阵计算》，第三版（约翰·霍普金斯大学出版社，1996 年）。

[2]

丹尼尔（J. W.）、格拉格（W. B.）、考夫曼（L.）与斯图尔特（G. W.），《重正交化和稳定算法用于更新格拉姆-施密特 QR 分解》，数学与计算 30，772-795 页（1976 年）。

[3]

莱切尔（L.）与格拉格（W. B.），《用于更新 QR 分解的 FORTRAN 子程序》，ACM 数学软件事务 16，369-377 页（1990 年）。

示例

```py
>>> import numpy as np
>>> from scipy import linalg
>>> a = np.array([[  3.,  -2.,  -2.],
...               [  6.,  -9.,  -3.],
...               [ -3.,  10.,   1.],
...               [  6.,  -7.,   4.],
...               [  7.,   8.,  -6.]])
>>> q, r = linalg.qr(a) 
```

鉴于此 QR 分解，执行一个排名 1 的更新。

```py
>>> u = np.array([7., -2., 4., 3., 5.])
>>> v = np.array([1., 3., -5.])
>>> q_up, r_up = linalg.qr_update(q, r, u, v, False)
>>> q_up
array([[ 0.54073807,  0.18645997,  0.81707661, -0.02136616,  0.06902409],  # may vary (signs)
 [ 0.21629523, -0.63257324,  0.06567893,  0.34125904, -0.65749222],
 [ 0.05407381,  0.64757787, -0.12781284, -0.20031219, -0.72198188],
 [ 0.48666426, -0.30466718, -0.27487277, -0.77079214,  0.0256951 ],
 [ 0.64888568,  0.23001   , -0.4859845 ,  0.49883891,  0.20253783]])
>>> r_up
array([[ 18.49324201,  24.11691794, -44.98940746],  # may vary (signs)
 [  0\.        ,  31.95894662, -27.40998201],
 [  0\.        ,   0\.        ,  -9.25451794],
 [  0\.        ,   0\.        ,   0\.        ],
 [  0\.        ,   0\.        ,   0\.        ]]) 
```

更新等效，但比以下更快。

```py
>>> a_up = a + np.outer(u, v)
>>> q_direct, r_direct = linalg.qr(a_up) 
```

检查我们是否有等价结果：

```py
>>> np.allclose(np.dot(q_up, r_up), a_up)
True 
```

而更新后的 Q 仍然是酉的：

```py
>>> np.allclose(np.dot(q_up.T, q_up), np.eye(5))
True 
```

还可以更新经济（减少、薄）分解：

```py
>>> qe, re = linalg.qr(a, mode='economic')
>>> qe_up, re_up = linalg.qr_update(qe, re, u, v, False)
>>> qe_up
array([[ 0.54073807,  0.18645997,  0.81707661],  # may vary (signs)
 [ 0.21629523, -0.63257324,  0.06567893],
 [ 0.05407381,  0.64757787, -0.12781284],
 [ 0.48666426, -0.30466718, -0.27487277],
 [ 0.64888568,  0.23001   , -0.4859845 ]])
>>> re_up
array([[ 18.49324201,  24.11691794, -44.98940746],  # may vary (signs)
 [  0\.        ,  31.95894662, -27.40998201],
 [  0\.        ,   0\.        ,  -9.25451794]])
>>> np.allclose(np.dot(qe_up, re_up), a_up)
True
>>> np.allclose(np.dot(qe_up.T, qe_up), np.eye(3))
True 
```

类似上述，执行一个二阶更新。

```py
>>> u2 = np.array([[ 7., -1,],
...                [-2.,  4.],
...                [ 4.,  2.],
...                [ 3., -6.],
...                [ 5.,  3.]])
>>> v2 = np.array([[ 1., 2.],
...                [ 3., 4.],
...                [-5., 2]])
>>> q_up2, r_up2 = linalg.qr_update(q, r, u2, v2, False)
>>> q_up2
array([[-0.33626508, -0.03477253,  0.61956287, -0.64352987, -0.29618884],  # may vary (signs)
 [-0.50439762,  0.58319694, -0.43010077, -0.33395279,  0.33008064],
 [-0.21016568, -0.63123106,  0.0582249 , -0.13675572,  0.73163206],
 [ 0.12609941,  0.49694436,  0.64590024,  0.31191919,  0.47187344],
 [-0.75659643, -0.11517748,  0.10284903,  0.5986227 , -0.21299983]])
>>> r_up2
array([[-23.79075451, -41.1084062 ,  24.71548348],  # may vary (signs)
 [  0\.        , -33.83931057,  11.02226551],
 [  0\.        ,   0\.        ,  48.91476811],
 [  0\.        ,   0\.        ,   0\.        ],
 [  0\.        ,   0\.        ,   0\.        ]]) 
```

这个更新也是`A + U V**T`的有效 QR 分解。

```py
>>> a_up2 = a + np.dot(u2, v2.T)
>>> np.allclose(a_up2, np.dot(q_up2, r_up2))
True
>>> np.allclose(np.dot(q_up2.T, q_up2), np.eye(5))
True 
```
