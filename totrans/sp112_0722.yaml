- en: Compressed sparse graph routines (scipy.sparse.csgraph)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/sparse.csgraph.html#module-scipy.sparse.csgraph](https://docs.scipy.org/doc/scipy-1.12.0/reference/sparse.csgraph.html#module-scipy.sparse.csgraph)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Fast graph algorithms based on sparse matrix representations.
  prefs: []
  type: TYPE_NORMAL
- en: Contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`connected_components`](generated/scipy.sparse.csgraph.connected_components.html#scipy.sparse.csgraph.connected_components
    "scipy.sparse.csgraph.connected_components")(csgraph[, directed, ...]) | Analyze
    the connected components of a sparse graph |'
  prefs: []
  type: TYPE_TB
- en: '| [`laplacian`](generated/scipy.sparse.csgraph.laplacian.html#scipy.sparse.csgraph.laplacian
    "scipy.sparse.csgraph.laplacian")(csgraph[, normed, return_diag, ...]) | Return
    the Laplacian of a directed graph. |'
  prefs: []
  type: TYPE_TB
- en: '| [`shortest_path`](generated/scipy.sparse.csgraph.shortest_path.html#scipy.sparse.csgraph.shortest_path
    "scipy.sparse.csgraph.shortest_path")(csgraph[, method, directed, ...]) | Perform
    a shortest-path graph search on a positive directed or undirected graph. |'
  prefs: []
  type: TYPE_TB
- en: '| [`dijkstra`](generated/scipy.sparse.csgraph.dijkstra.html#scipy.sparse.csgraph.dijkstra
    "scipy.sparse.csgraph.dijkstra")(csgraph[, directed, indices, ...]) | Dijkstra
    algorithm using Fibonacci Heaps |'
  prefs: []
  type: TYPE_TB
- en: '| [`floyd_warshall`](generated/scipy.sparse.csgraph.floyd_warshall.html#scipy.sparse.csgraph.floyd_warshall
    "scipy.sparse.csgraph.floyd_warshall")(csgraph[, directed, ...]) | Compute the
    shortest path lengths using the Floyd-Warshall algorithm |'
  prefs: []
  type: TYPE_TB
- en: '| [`bellman_ford`](generated/scipy.sparse.csgraph.bellman_ford.html#scipy.sparse.csgraph.bellman_ford
    "scipy.sparse.csgraph.bellman_ford")(csgraph[, directed, indices, ...]) | Compute
    the shortest path lengths using the Bellman-Ford algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`johnson`](generated/scipy.sparse.csgraph.johnson.html#scipy.sparse.csgraph.johnson
    "scipy.sparse.csgraph.johnson")(csgraph[, directed, indices, ...]) | Compute the
    shortest path lengths using Johnson''s algorithm. |'
  prefs: []
  type: TYPE_TB
- en: '| [`breadth_first_order`](generated/scipy.sparse.csgraph.breadth_first_order.html#scipy.sparse.csgraph.breadth_first_order
    "scipy.sparse.csgraph.breadth_first_order")(csgraph, i_start[, ...]) | Return
    a breadth-first ordering starting with specified node. |'
  prefs: []
  type: TYPE_TB
- en: '| [`depth_first_order`](generated/scipy.sparse.csgraph.depth_first_order.html#scipy.sparse.csgraph.depth_first_order
    "scipy.sparse.csgraph.depth_first_order")(csgraph, i_start[, ...]) | Return a
    depth-first ordering starting with specified node. |'
  prefs: []
  type: TYPE_TB
- en: '| [`breadth_first_tree`](generated/scipy.sparse.csgraph.breadth_first_tree.html#scipy.sparse.csgraph.breadth_first_tree
    "scipy.sparse.csgraph.breadth_first_tree")(csgraph, i_start[, directed]) | Return
    the tree generated by a breadth-first search |'
  prefs: []
  type: TYPE_TB
- en: '| [`depth_first_tree`](generated/scipy.sparse.csgraph.depth_first_tree.html#scipy.sparse.csgraph.depth_first_tree
    "scipy.sparse.csgraph.depth_first_tree")(csgraph, i_start[, directed]) | Return
    a tree generated by a depth-first search. |'
  prefs: []
  type: TYPE_TB
- en: '| [`minimum_spanning_tree`](generated/scipy.sparse.csgraph.minimum_spanning_tree.html#scipy.sparse.csgraph.minimum_spanning_tree
    "scipy.sparse.csgraph.minimum_spanning_tree")(csgraph[, overwrite]) | Return a
    minimum spanning tree of an undirected graph |'
  prefs: []
  type: TYPE_TB
- en: '| [`reverse_cuthill_mckee`](generated/scipy.sparse.csgraph.reverse_cuthill_mckee.html#scipy.sparse.csgraph.reverse_cuthill_mckee
    "scipy.sparse.csgraph.reverse_cuthill_mckee")(graph[, symmetric_mode]) | Returns
    the permutation array that orders a sparse CSR or CSC matrix in Reverse-Cuthill
    McKee ordering. |'
  prefs: []
  type: TYPE_TB
- en: '| [`maximum_flow`](generated/scipy.sparse.csgraph.maximum_flow.html#scipy.sparse.csgraph.maximum_flow
    "scipy.sparse.csgraph.maximum_flow")(csgraph, source, sink) | Maximize the flow
    between two vertices in a graph. |'
  prefs: []
  type: TYPE_TB
- en: '| [`maximum_bipartite_matching`](generated/scipy.sparse.csgraph.maximum_bipartite_matching.html#scipy.sparse.csgraph.maximum_bipartite_matching
    "scipy.sparse.csgraph.maximum_bipartite_matching")(graph[, perm_type]) | Returns
    a matching of a bipartite graph whose cardinality is as least that of any given
    matching of the graph. |'
  prefs: []
  type: TYPE_TB
- en: '| [`min_weight_full_bipartite_matching`](generated/scipy.sparse.csgraph.min_weight_full_bipartite_matching.html#scipy.sparse.csgraph.min_weight_full_bipartite_matching
    "scipy.sparse.csgraph.min_weight_full_bipartite_matching")(...[, ...]) | Returns
    the minimum weight full matching of a bipartite graph. |'
  prefs: []
  type: TYPE_TB
- en: '| [`structural_rank`](generated/scipy.sparse.csgraph.structural_rank.html#scipy.sparse.csgraph.structural_rank
    "scipy.sparse.csgraph.structural_rank")(graph) | Compute the structural rank of
    a graph (matrix) with a given sparsity pattern. |'
  prefs: []
  type: TYPE_TB
- en: '| [`NegativeCycleError`](generated/scipy.sparse.csgraph.NegativeCycleError.html#scipy.sparse.csgraph.NegativeCycleError
    "scipy.sparse.csgraph.NegativeCycleError")([message]) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [`construct_dist_matrix`](generated/scipy.sparse.csgraph.construct_dist_matrix.html#scipy.sparse.csgraph.construct_dist_matrix
    "scipy.sparse.csgraph.construct_dist_matrix")(graph, predecessors[, ...]) | Construct
    distance matrix from a predecessor matrix |'
  prefs: []
  type: TYPE_TB
- en: '| [`csgraph_from_dense`](generated/scipy.sparse.csgraph.csgraph_from_dense.html#scipy.sparse.csgraph.csgraph_from_dense
    "scipy.sparse.csgraph.csgraph_from_dense")(graph[, null_value, ...]) | Construct
    a CSR-format sparse graph from a dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`csgraph_from_masked`](generated/scipy.sparse.csgraph.csgraph_from_masked.html#scipy.sparse.csgraph.csgraph_from_masked
    "scipy.sparse.csgraph.csgraph_from_masked")(graph) | Construct a CSR-format graph
    from a masked array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`csgraph_masked_from_dense`](generated/scipy.sparse.csgraph.csgraph_masked_from_dense.html#scipy.sparse.csgraph.csgraph_masked_from_dense
    "scipy.sparse.csgraph.csgraph_masked_from_dense")(graph[, ...]) | Construct a
    masked array graph representation from a dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| [`csgraph_to_dense`](generated/scipy.sparse.csgraph.csgraph_to_dense.html#scipy.sparse.csgraph.csgraph_to_dense
    "scipy.sparse.csgraph.csgraph_to_dense")(csgraph[, null_value]) | Convert a sparse
    graph representation to a dense representation |'
  prefs: []
  type: TYPE_TB
- en: '| [`csgraph_to_masked`](generated/scipy.sparse.csgraph.csgraph_to_masked.html#scipy.sparse.csgraph.csgraph_to_masked
    "scipy.sparse.csgraph.csgraph_to_masked")(csgraph) | Convert a sparse graph representation
    to a masked array representation |'
  prefs: []
  type: TYPE_TB
- en: '| [`reconstruct_path`](generated/scipy.sparse.csgraph.reconstruct_path.html#scipy.sparse.csgraph.reconstruct_path
    "scipy.sparse.csgraph.reconstruct_path")(csgraph, predecessors[, ...]) | Construct
    a tree from a graph and a predecessor list. |'
  prefs: []
  type: TYPE_TB
- en: Graph Representations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This module uses graphs which are stored in a matrix format. A graph with N
    nodes can be represented by an (N x N) adjacency matrix G. If there is a connection
    from node i to node j, then G[i, j] = w, where w is the weight of the connection.
    For nodes i and j which are not connected, the value depends on the representation:'
  prefs: []
  type: TYPE_NORMAL
- en: for dense array representations, non-edges are represented by G[i, j] = 0, infinity,
    or NaN.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for dense masked representations (of type np.ma.MaskedArray), non-edges are
    represented by masked values. This can be useful when graphs with zero-weight
    edges are desired.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: for sparse array representations, non-edges are represented by non-entries in
    the matrix. This sort of sparse representation also allows for edges with zero
    weights.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As a concrete example, imagine that you would like to represent the following
    undirected graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This graph has three nodes, where node 0 and 1 are connected by an edge of
    weight 2, and nodes 0 and 2 are connected by an edge of weight 1. We can construct
    the dense, masked, and sparse representations as follows, keeping in mind that
    an undirected graph is represented by a symmetric matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This becomes more difficult when zero edges are significant. For example, consider
    the situation when we slightly modify the above graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This is identical to the previous graph, except nodes 0 and 2 are connected
    by an edge of zero weight. In this case, the dense representation above leads
    to ambiguities: how can non-edges be represented if zero is a meaningful value?
    In this case, either a masked or sparse representation must be used to eliminate
    the ambiguity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here we have used a utility routine from the csgraph submodule in order to convert
    the dense representation to a sparse representation which can be understood by
    the algorithms in submodule. By viewing the data array, we can see that the zero
    values are explicitly encoded in the graph.
  prefs: []
  type: TYPE_NORMAL
- en: Directed vs. undirected
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Matrices may represent either directed or undirected graphs. This is specified
    throughout the csgraph module by a boolean keyword. Graphs are assumed to be directed
    by default. In a directed graph, traversal from node i to node j can be accomplished
    over the edge G[i, j], but not the edge G[j, i]. Consider the following dense
    graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When `directed=True` we get the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In a non-directed graph, traversal from node i to node j can be accomplished
    over either G[i, j] or G[j, i]. If both edges are not null, and the two have unequal
    weights, then the smaller of the two is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'So for the same graph, when `directed=False` we get the graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that a symmetric matrix will represent an undirected graph, regardless
    of whether the ‘directed’ keyword is set to True or False. In this case, using
    `directed=True` generally leads to more efficient computation.
  prefs: []
  type: TYPE_NORMAL
- en: The routines in this module accept as input either scipy.sparse representations
    (csr, csc, or lil format), masked representations, or dense representations with
    non-edges indicated by zeros, infinities, and NaN entries.
  prefs: []
  type: TYPE_NORMAL
