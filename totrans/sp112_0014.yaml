- en: Statistics (scipy.stats)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/stats.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/stats.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this tutorial, we discuss many, but certainly not all, features of `scipy.stats`.
    The intention here is to provide a user with a working knowledge of this package.
    We refer to the [reference manual](../reference/stats.html#statsrefmanual) for
    further details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: This documentation is work in progress.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Discrete Statistical Distributions](stats/discrete.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Continuous Statistical Distributions](stats/continuous.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Universal Non-Uniform Random Number Sampling in SciPy](stats/sampling.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Resampling and Monte Carlo Methods](stats/resampling.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Random variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two general distribution classes that have been implemented for encapsulating
    [continuous random variables](stats/continuous.html#continuous-random-variables)
    and [discrete random variables](stats/discrete.html#discrete-random-variables).
    Over 80 continuous random variables (RVs) and 10 discrete random variables have
    been implemented using these classes. Besides this, new routines and distributions
    can be easily added by the end user. (If you create one, please contribute it.)
  prefs: []
  type: TYPE_NORMAL
- en: All of the statistics functions are located in the sub-package [`scipy.stats`](../reference/stats.html#module-scipy.stats
    "scipy.stats") and a fairly complete listing of these functions can be obtained
    using `info(stats)`. The list of the random variables available can also be obtained
    from the docstring for the stats sub-package.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the discussion below, we mostly focus on continuous RVs. Nearly everything
    also applies to discrete variables, but we point out some differences here: [Specific
    points for discrete distributions](#discrete-points-label).'
  prefs: []
  type: TYPE_NORMAL
- en: In the code samples below, we assume that the [`scipy.stats`](../reference/stats.html#module-scipy.stats
    "scipy.stats") package is imported as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: and in some cases we assume that individual objects are imported as
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Getting help
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, all distributions are accompanied with help functions. To obtain
    just some basic information, we print the relevant docstring: `print(stats.norm.__doc__)`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the support, i.e., upper and lower bounds of the distribution, call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We can list all methods and properties of the distribution with `dir(norm)`.
    As it turns out, some of the methods are private, although they are not named
    as such (their names do not start with a leading underscore), for example `veccdf`,
    are only available for internal calculation (those methods will give warnings
    when one tries to use them, and will be removed at some point).
  prefs: []
  type: TYPE_NORMAL
- en: To obtain the *real* main methods, we list the methods of the frozen distribution.
    (We explain the meaning of a *frozen* distribution below).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can obtain the list of available distribution through introspection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Common methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main public methods for continuous RVs are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'rvs: Random Variates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'pdf: Probability Density Function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'cdf: Cumulative Distribution Function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'sf: Survival Function (1-CDF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ppf: Percent Point Function (Inverse of CDF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'isf: Inverse Survival Function (Inverse of SF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'stats: Return mean, variance, (Fisher’s) skew, or (Fisher’s) kurtosis'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'moment: non-central moments of the distribution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a normal RV as an example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: To compute the `cdf` at a number of points, we can pass a list or a numpy array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Thus, the basic methods, such as *pdf*, *cdf*, and so on, are vectorized.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other generally useful methods are supported too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To find the median of a distribution, we can use the percent point function
    `ppf`, which is the inverse of the `cdf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To generate a sequence of random variates, use the `size` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Don’t think that `norm.rvs(5)` generates 5 variates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, `5` with no keyword is being interpreted as the first possible keyword
    argument, `loc`, which is the first of a pair of keyword arguments taken by all
    continuous distributions. This brings us to the topic of the next subsection.
  prefs: []
  type: TYPE_NORMAL
- en: Random number generation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Drawing random numbers relies on generators from [`numpy.random`](https://numpy.org/devdocs/reference/random/index.html#module-numpy.random
    "(in NumPy v2.0.dev0)") package. In the examples above, the specific stream of
    random numbers is not reproducible across runs. To achieve reproducibility, you
    can explicitly *seed* a random number generator. In NumPy, a generator is an instance
    of [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)"). Here is the canonical way to create a generator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And fixing the seed can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'Do not use this number or common values such as 0\. Using just a small set
    of seeds to instantiate larger state spaces means that there are some initial
    states that are impossible to reach. This creates some biases if everyone uses
    such values. A good way to get a seed is to use a [`numpy.random.SeedSequence`](https://numpy.org/devdocs/reference/random/bit_generators/generated/numpy.random.SeedSequence.html#numpy.random.SeedSequence
    "(in NumPy v2.0.dev0)"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The *random_state* parameter in distributions accepts an instance of [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)") class, or an integer, which is then used to seed an internal
    `Generator` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For further info, see [NumPy’s documentation](https://numpy.org/doc/stable/reference/random/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about the random number samplers implemented in SciPy, see [non-uniform
    random number sampling tutorial](stats/sampling.html#non-uniform-random-number-sampling)
    and [quasi monte carlo tutorial](#quasi-monte-carlo)
  prefs: []
  type: TYPE_NORMAL
- en: Shifting and scaling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All continuous distributions take `loc` and `scale` as keyword parameters to
    adjust the location and scale of the distribution, e.g., for the standard normal
    distribution, the location is the mean and the scale is the standard deviation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In many cases, the standardized distribution for a random variable `X` is obtained
    through the transformation `(X - loc) / scale`. The default values are `loc =
    0` and `scale = 1`.
  prefs: []
  type: TYPE_NORMAL
- en: Smart use of `loc` and `scale` can help modify the standard distributions in
    many ways. To illustrate the scaling further, the `cdf` of an exponentially distributed
    RV with mean \(1/\lambda\) is given by
  prefs: []
  type: TYPE_NORMAL
- en: \[F(x) = 1 - \exp(-\lambda x)\]
  prefs: []
  type: TYPE_NORMAL
- en: By applying the scaling rule above, it can be seen that by taking `scale  =
    1./lambda` we get the proper scale.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Distributions that take shape parameters may require more than simple application
    of `loc` and/or `scale` to achieve the desired form. For example, the distribution
    of 2-D vector lengths given a constant vector of length \(R\) perturbed by independent
    N(0, \(\sigma^2\)) deviations in each component is rice(\(R/\sigma\), scale= \(\sigma\)).
    The first argument is a shape parameter that needs to be scaled along with \(x\).
  prefs: []
  type: TYPE_NORMAL
- en: 'The uniform distribution is also interesting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, recall from the previous paragraph that we are left with the problem
    of the meaning of `norm.rvs(5)`. As it turns out, calling a distribution like
    this, the first argument, i.e., the 5, gets passed to set the `loc` parameter.
    Let’s see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, to explain the output of the example of the last section: `norm.rvs(5)`
    generates a single normally distributed random variate with mean `loc=5`, because
    of the default `size=1`.'
  prefs: []
  type: TYPE_NORMAL
- en: We recommend that you set `loc` and `scale` parameters explicitly, by passing
    the values as keywords rather than as arguments. Repetition can be minimized when
    calling more than one method of a given RV by using the technique of [Freezing
    a Distribution](#freezing-a-distribution), as explained below.
  prefs: []
  type: TYPE_NORMAL
- en: Shape parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While a general continuous random variable can be shifted and scaled with the
    `loc` and `scale` parameters, some distributions require additional shape parameters.
    For instance, the gamma distribution with density
  prefs: []
  type: TYPE_NORMAL
- en: \[\gamma(x, a) = \frac{\lambda (\lambda x)^{a-1}}{\Gamma(a)} e^{-\lambda x}\;,\]
  prefs: []
  type: TYPE_NORMAL
- en: requires the shape parameter \(a\). Observe that setting \(\lambda\) can be
    obtained by setting the `scale` keyword to \(1/\lambda\).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check the number and name of the shape parameters of the gamma distribution.
    (We know from the above that this should be 1.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, we set the value of the shape variable to 1 to obtain the exponential distribution,
    so that we compare easily whether we get the results we expect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we can also specify shape parameters as keywords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Freezing a distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Passing the `loc` and `scale` keywords time and again can become quite bothersome.
    The concept of *freezing* a RV is used to solve such problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `rv` we no longer have to include the scale or the shape parameters
    anymore. Thus, distributions can be used in one of two ways, either by passing
    all distribution parameters to each method call (such as we did earlier) or by
    freezing the parameters for the instance of the distribution. Let us check this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This is, indeed, what we should get.
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The basic methods `pdf`, and so on, satisfy the usual numpy broadcasting rules.
    For example, we can calculate the critical values for the upper tail of the t
    distribution for different probabilities and degrees of freedom.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the first row contains the critical values for 10 degrees of freedom
    and the second row for 11 degrees of freedom (d.o.f.). Thus, the broadcasting
    rules give the same result of calling `isf` twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If the array with probabilities, i.e., `[0.1, 0.05, 0.01]` and the array of
    degrees of freedom i.e., `[10, 11, 12]`, have the same array shape, then element-wise
    matching is used. As an example, we can obtain the 10% tail for 10 d.o.f., the
    5% tail for 11 d.o.f. and the 1% tail for 12 d.o.f. by calling
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '### Specific points for discrete distributions'
  prefs: []
  type: TYPE_NORMAL
- en: Discrete distributions have mostly the same basic methods as the continuous
    distributions. However `pdf` is replaced by the probability mass function `pmf`,
    no estimation methods, such as fit, are available, and `scale` is not a valid
    keyword parameter. The location parameter, keyword `loc`, can still be used to
    shift the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The computation of the cdf requires some extra attention. In the case of continuous
    distribution, the cumulative distribution function is, in most standard cases,
    strictly monotonic increasing in the bounds (a,b) and has, therefore, a unique
    inverse. The cdf of a discrete distribution, however, is a step function, hence
    the inverse cdf, i.e., the percent point function, requires a different definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For further info, see the docs [here](stats/discrete.html#discrete-ppf).
  prefs: []
  type: TYPE_NORMAL
- en: We can look at the hypergeometric distribution as an example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If we use the cdf at some integer points and then evaluate the ppf at those
    cdf values, we get the initial integers back, for example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use values that are not at the kinks of the cdf step function, we get
    the next higher integer back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Fitting distributions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The main additional methods of the not frozen distribution are related to the
    estimation of distribution parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'fit: maximum likelihood estimation of distribution parameters, including location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: and scale
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'fit_loc_scale: estimation of location and scale when shape parameters are given'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'nnlf: negative log likelihood function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'expect: calculate the expectation of a function against the pdf or pmf'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Performance issues and cautionary remarks'
  prefs: []
  type: TYPE_NORMAL
- en: 'The performance of the individual methods, in terms of speed, varies widely
    by distribution and method. The results of a method are obtained in one of two
    ways: either by explicit calculation, or by a generic algorithm that is independent
    of the specific distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: Explicit calculation, on the one hand, requires that the method is directly
    specified for the given distribution, either through analytic formulas or through
    special functions in `scipy.special` or `numpy.random` for `rvs`. These are usually
    relatively fast calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The generic methods, on the other hand, are used if the distribution does not
    specify any explicit calculation. To define a distribution, only one of pdf or
    cdf is necessary; all other methods can be derived using numeric integration and
    root finding. However, these indirect methods can be *very* slow. As an example,
    `rgh = stats.gausshyper.rvs(0.5, 2, 2, 2, size=100)` creates random variables
    in a very indirect way and takes about 19 seconds for 100 random variables on
    my computer, while one million random variables from the standard normal or from
    the t distribution take just above one second.
  prefs: []
  type: TYPE_NORMAL
- en: Remaining issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The distributions in `scipy.stats` have recently been corrected and improved
    and gained a considerable test suite; however, a few issues remain:'
  prefs: []
  type: TYPE_NORMAL
- en: The distributions have been tested over some range of parameters; however, in
    some corner ranges, a few incorrect results may remain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maximum likelihood estimation in *fit* does not work with default starting
    parameters for all distributions and the user needs to supply good starting parameters.
    Also, for some distribution using a maximum likelihood estimator might inherently
    not be the best choice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building specific distributions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next examples shows how to build your own distributions. Further examples
    show the usage of the distributions and some statistical tests.
  prefs: []
  type: TYPE_NORMAL
- en: Making a continuous distribution, i.e., subclassing `rv_continuous`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Making continuous distributions is fairly simple.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, the `pdf` is now computed automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Be aware of the performance issues mentioned in [Performance issues and cautionary
    remarks](#performance-issues-label). The computation of unspecified common methods
    can become very slow, since only general methods are called, which, by their very
    nature, cannot use any specific information about the distribution. Thus, as a
    cautionary example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'But this is not correct: the integral over this pdf should be 1\. Let’s make
    the integration interval smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This looks better. However, the problem originated from the fact that the pdf
    is not specified in the class definition of the deterministic distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Subclassing `rv_discrete`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following, we use [`stats.rv_discrete`](../reference/generated/scipy.stats.rv_discrete.html#scipy.stats.rv_discrete
    "scipy.stats.rv_discrete") to generate a discrete distribution that has the probabilities
    of the truncated normal for the intervals centered around the integers.
  prefs: []
  type: TYPE_NORMAL
- en: '**General info**'
  prefs: []
  type: TYPE_NORMAL
- en: From the docstring of rv_discrete, `help(stats.rv_discrete)`,
  prefs: []
  type: TYPE_NORMAL
- en: “You can construct an arbitrary discrete rv where P{X=xk} = pk by passing to
    the rv_discrete initialization method (through the values= keyword) a tuple of
    sequences (xk, pk) which describes only those values of X (xk) that occur with
    nonzero probability (pk).”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Next to this, there are some further requirements for this approach to work:'
  prefs: []
  type: TYPE_NORMAL
- en: The keyword *name* is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The support points of the distribution xk have to be integers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of significant digits (decimals) needs to be specified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In fact, if the last two requirements are not satisfied, an exception may be
    raised or the resulting numbers may be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: '**An example**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do the work. First:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, we can subclass `rv_discrete`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have defined the distribution, we have access to all common methods
    of discrete distributions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '**Testing the implementation**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s generate a random sample and compare observed frequencies with the probabilities.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '!["An X-Y histogram plot showing the distribution of random variates. A blue
    trace shows a normal bell curve. A blue bar chart perfectly approximates the curve
    showing the true distribution. A red bar chart representing the sample is well
    described by the blue trace but not exact."](../Images/50524857269cde7853e5d5ee82f3a2dd.png)!["An
    X-Y histogram plot showing the cumulative distribution of random variates. A blue
    trace shows a CDF for a typical normal distribution. A blue bar chart perfectly
    approximates the curve showing the true distribution. A red bar chart representing
    the sample is well described by the blue trace but not exact."](../Images/cc47b822846571e2684255cfe466c42f.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we can test whether our sample was generated by our norm-discrete distribution.
    This also verifies whether the random numbers were generated correctly.
  prefs: []
  type: TYPE_NORMAL
- en: The chisquare test requires that there are a minimum number of observations
    in each bin. We combine the tail bins into larger bins so that they contain enough
    observations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The pvalue in this case is high, so we can be quite confident that our random
    sample was actually generated by the distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Analysing one sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we create some random variables. We set a seed so that in each run we
    get identical results to look at. As an example we take a sample from the Student
    t distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, we set the required shape parameter of the t distribution, which in statistics
    corresponds to the degrees of freedom, to 10\. Using size=1000 means that our
    sample consists of 1000 independently drawn (pseudo) random numbers. Since we
    did not specify the keyword arguments *loc* and *scale*, those are set to their
    default values zero and one.
  prefs: []
  type: TYPE_NORMAL
- en: Descriptive statistics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '*x* is a numpy array, and we have direct access to all array methods, e.g.,'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How do the sample properties compare to their theoretical counterparts?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: [`stats.describe`](../reference/generated/scipy.stats.describe.html#scipy.stats.describe
    "scipy.stats.describe") uses the unbiased estimator for the variance, while np.var
    is the biased estimator.'
  prefs: []
  type: TYPE_NORMAL
- en: For our sample the sample statistics differ a by a small amount from their theoretical
    counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: T-test and KS-test
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can use the t-test to test whether the mean of our sample differs in a statistically
    significant way from the theoretical expectation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The pvalue is 0.7, this means that with an alpha error of, for example, 10%,
    we cannot reject the hypothesis that the sample mean is equal to zero, the expectation
    of the standard t-distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an exercise, we can calculate our ttest also directly without using the
    provided function, which should give us the same answer, and so it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The Kolmogorov-Smirnov test can be used to test the hypothesis that the sample
    comes from the standard t-distribution
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Again, the p-value is high enough that we cannot reject the hypothesis that
    the random sample really is distributed according to the t-distribution. In real
    applications, we don’t know what the underlying distribution is. If we perform
    the Kolmogorov-Smirnov test of our sample against the standard normal distribution,
    then we also cannot reject the hypothesis that our sample was generated by the
    normal distribution given that, in this example, the p-value is almost 40%.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: However, the standard normal distribution has a variance of 1, while our sample
    has a variance of 1.29\. If we standardize our sample and test it against the
    normal distribution, then the p-value is again large enough that we cannot reject
    the hypothesis that the sample came form the normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: The Kolmogorov-Smirnov test assumes that we test against a distribution
    with given parameters, since, in the last case, we estimated mean and variance,
    this assumption is violated and the distribution of the test statistic, on which
    the p-value is based, is not correct.'
  prefs: []
  type: TYPE_NORMAL
- en: Tails of the distribution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, we can check the upper tail of the distribution. We can use the percent
    point function ppf, which is the inverse of the cdf function, to obtain the critical
    values, or, more directly, we can use the inverse of the survival function
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In all three cases, our sample has more weight in the top tail than the underlying
    distribution. We can briefly check a larger sample to see if we get a closer match.
    In this case, the empirical frequency is quite close to the theoretical probability,
    but if we repeat this several times, the fluctuations are still pretty large.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also compare it with the tail of the normal distribution, which has
    less weight in the tails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The chisquare test can be used to test whether for a finite number of bins,
    the observed frequencies differ significantly from the probabilities of the hypothesized
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: We see that the standard normal distribution is clearly rejected, while the
    standard t-distribution cannot be rejected. Since the variance of our sample differs
    from both standard distributions, we can again redo the test taking the estimate
    for scale and location into account.
  prefs: []
  type: TYPE_NORMAL
- en: The fit method of the distributions can be used to estimate the parameters of
    the distribution, and the test is repeated using probabilities of the estimated
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Taking account of the estimated parameters, we can still reject the hypothesis
    that our sample came from a normal distribution (at the 5% level), but again,
    with a p-value of 0.95, we cannot reject the t-distribution.
  prefs: []
  type: TYPE_NORMAL
- en: Special tests for normal distributions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the normal distribution is the most common distribution in statistics,
    there are several additional functions available to test whether a sample could
    have been drawn from a normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we can test if skew and kurtosis of our sample differ significantly
    from those of a normal distribution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: These two tests are combined in the normality test
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In all three tests, the p-values are very low and we can reject the hypothesis
    that the our sample has skew and kurtosis of the normal distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since skew and kurtosis of our sample are based on central moments, we get
    exactly the same results if we test the standardized sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Because normality is rejected so strongly, we can check whether the normaltest
    gives reasonable results for other cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: When testing for normality of a small sample of t-distributed observations and
    a large sample of normal-distributed observations, then in neither case can we
    reject the null hypothesis that the sample comes from a normal distribution. In
    the first case, this is because the test is not powerful enough to distinguish
    a t and a normally distributed random variable in a small sample.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing two samples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following, we are given two samples, which can come either from the same
    or from different distribution, and we want to test whether these samples have
    the same statistical properties.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing means
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Test with sample with identical means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Test with sample with different means:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Kolmogorov-Smirnov test for two samples ks_2samp
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the example, where both samples are drawn from the same distribution, we
    cannot reject the null hypothesis, since the pvalue is high
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: In the second example, with different location, i.e., means, we can reject the
    null hypothesis, since the pvalue is below 1%
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Kernel density estimation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common task in statistics is to estimate the probability density function
    (PDF) of a random variable from a set of data samples. This task is called density
    estimation. The most well-known tool to do this is the histogram. A histogram
    is a useful tool for visualization (mainly because everyone understands it), but
    doesn’t use the available data very efficiently. Kernel density estimation (KDE)
    is a more efficient tool for the same task. The [`gaussian_kde`](../reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde
    "scipy.stats.gaussian_kde") estimator can be used to estimate the PDF of univariate
    as well as multivariate data. It works best if the data is unimodal.
  prefs: []
  type: TYPE_NORMAL
- en: Univariate estimation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We start with a minimal amount of data in order to see how [`gaussian_kde`](../reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde
    "scipy.stats.gaussian_kde") works and what the different options for bandwidth
    selection do. The data sampled from the PDF are shown as blue dashes at the bottom
    of the figure (this is called a rug plot):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/999859b9f1bdb01b50f77fc17168c334.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that there is very little difference between Scott’s Rule and Silverman’s
    Rule, and that the bandwidth selection with a limited amount of data is probably
    a bit too wide. We can define our own bandwidth function to get a less smoothed-out
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/22dada26ab14103a09b802c241471c4a.png)'
  prefs: []
  type: TYPE_IMG
- en: We see that if we set bandwidth to be very narrow, the obtained estimate for
    the probability density function (PDF) is simply the sum of Gaussians around each
    data point.
  prefs: []
  type: TYPE_NORMAL
- en: We now take a more realistic example and look at the difference between the
    two available bandwidth selection rules. Those rules are known to work well for
    (close to) normal distributions, but even for unimodal distributions that are
    quite strongly non-normal they work reasonably well. As a non-normal distribution
    we take a Student’s T distribution with 5 degrees of freedom.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/95c55c39eeb87b0055a47ebcd6fc28db.png)'
  prefs: []
  type: TYPE_IMG
- en: We now take a look at a bimodal distribution with one wider and one narrower
    Gaussian feature. We expect that this will be a more difficult density to approximate,
    due to the different bandwidths required to accurately resolve each feature.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/9c2feee5e554adae99dabb2238559bb6.png)'
  prefs: []
  type: TYPE_IMG
- en: As expected, the KDE is not as close to the true PDF as we would like due to
    the different characteristic size of the two features of the bimodal distribution.
    By halving the default bandwidth (`Scott * 0.5`), we can do somewhat better, while
    using a factor 5 smaller bandwidth than the default doesn’t smooth enough. What
    we really need, though, in this case, is a non-uniform (adaptive) bandwidth.
  prefs: []
  type: TYPE_NORMAL
- en: Multivariate estimation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With [`gaussian_kde`](../reference/generated/scipy.stats.gaussian_kde.html#scipy.stats.gaussian_kde
    "scipy.stats.gaussian_kde") we can perform multivariate, as well as univariate
    estimation. We demonstrate the bivariate case. First, we generate some random
    data with a model in which the two variates are correlated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we apply the KDE to the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we plot the estimated bivariate distribution as a colormap and plot
    the individual data points on top.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '!["An X-Y plot showing a random scattering of points around a 2-D gaussian.
    The distribution has a semi-major axis at 45 degrees with a semi-minor axis about
    half as large. Each point in the plot is highlighted with the outer region in
    red, then yellow, then green, with the center in blue. "](../Images/d07675295fa3a9c5c4716026552854e7.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiscale Graph Correlation (MGC)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With [`multiscale_graphcorr`](../reference/generated/scipy.stats.multiscale_graphcorr.html#scipy.stats.multiscale_graphcorr
    "scipy.stats.multiscale_graphcorr"), we can test for independence on high dimensional
    and nonlinear data. Before we start, let’s import some useful packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use a custom plotting function to plot the data relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s look at some linear data first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The simulation relationship can be plotted below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/70b40b36230d43e18094daaefc5d9455.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can see the test statistic, p-value, and MGC map visualized below.
    The optimal scale is shown on the map as a red “x”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/bf2f505a205c76ed9bf00832fc1145ad.png)'
  prefs: []
  type: TYPE_IMG
- en: It is clear from here, that MGC is able to determine a relationship between
    the input data matrices because the p-value is very low and the MGC test statistic
    is relatively high. The MGC-map indicates a **strongly linear relationship**.
    Intuitively, this is because having more neighbors will help in identifying a
    linear relationship between \(x\) and \(y\). The optimal scale in this case is
    **equivalent to the global scale**, marked by a red spot on the map.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same can be done for nonlinear data sets. The following \(x\) and \(y\)
    arrays are derived from a nonlinear simulation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'The simulation relationship can be plotted below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/12d7e85c2ab600adb6197d6591909048.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, we can see the test statistic, p-value, and MGC map visualized below.
    The optimal scale is shown on the map as a red “x”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/a450e054c3a723a385379175db9c099f.png)'
  prefs: []
  type: TYPE_IMG
- en: It is clear from here, that MGC is able to determine a relationship again because
    the p-value is very low and the MGC test statistic is relatively high. The MGC-map
    indicates a **strongly nonlinear relationship**. The optimal scale in this case
    is **equivalent to the local scale**, marked by a red spot on the map.
  prefs: []
  type: TYPE_NORMAL
- en: '## Quasi-Monte Carlo'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before talking about Quasi-Monte Carlo (QMC), a quick introduction about Monte
    Carlo (MC). MC methods, or MC experiments, are a broad class of computational
    algorithms that rely on repeated random sampling to obtain numerical results.
    The underlying concept is to use randomness to solve problems that might be deterministic
    in principle. They are often used in physical and mathematical problems and are
    most useful when it is difficult or impossible to use other approaches. MC methods
    are mainly used in three problem classes: optimization, numerical integration,
    and generating draws from a probability distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating random numbers with specific properties is a more complex problem
    than it sounds. Simple MC methods are designed to sample points to be independent
    and identically distributed (IID). But generating multiple sets of random points
    can produce radically different results.
  prefs: []
  type: TYPE_NORMAL
- en: '![" "](../Images/c8b0e03b61a94c47004310d063a31309.png)'
  prefs: []
  type: TYPE_IMG
- en: In both cases in the plot above, points are generated randomly without any knowledge
    about previously drawn points. It is clear that some regions of the space are
    left unexplored - which can cause problems in simulations as a particular set
    of points might trigger a totally different behaviour.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great benefit of MC is that it has known convergence properties. Let’s look
    at the mean of the squared sum in 5 dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: \[f(\mathbf{x}) = \left( \sum_{j=1}^{5}x_j \right)^2,\]
  prefs: []
  type: TYPE_NORMAL
- en: with \(x_j \sim \mathcal{U}(0,1)\). It has a known mean value, \(\mu = 5/3+5(5-1)/4\).
    Using MC sampling, we can compute that mean numerically, and the approximation
    error follows a theoretical rate of \(O(n^{-1/2})\).
  prefs: []
  type: TYPE_NORMAL
- en: '![" "](../Images/a796255c383c0c75178d5631e20c4783.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Although the convergence is ensured, practitioners tend to want to have an
    exploration process which is more deterministic. With normal MC, a seed can be
    used to have a repeatable process. But fixing the seed would break the convergence
    property: a given seed could work for a given class of problem and break for another
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: What is commonly done to walk through the space in a deterministic manner, is
    to use a regular grid spanning all parameter dimensions, also called a saturated
    design. Let’s consider the unit-hypercube, with all bounds ranging from 0 to 1\.
    Now, having a distance of 0.1 between points, the number of points required to
    fill the unit interval would be 10\. In a 2-dimensional hypercube the same spacing
    would require 100, and in 3 dimensions 1,000 points. As the number of dimensions
    grows, the number of experiments which is required to fill the space rises exponentially
    as the dimensionality of the space increases. This exponential growth is called
    “the curse of dimensionality”.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/de858c495c1c5ebc0870ec483f7835c5.png)'
  prefs: []
  type: TYPE_IMG
- en: To mitigate this issue, QMC methods have been designed. They are deterministic,
    have a good coverage of the space and some of them can be continued and retain
    good properties. The main difference with MC methods is that the points are not
    IID but they know about previous points. Hence, some methods are also referred
    to as sequences.
  prefs: []
  type: TYPE_NORMAL
- en: '![" "](../Images/adcb64ba701338ef5728a030fa9dd160.png)'
  prefs: []
  type: TYPE_IMG
- en: This figure presents 2 sets of 256 points. The design of the left is a plain
    MC whereas the design of the right is a QMC design using the *Sobol’* method.
    We clearly see that the QMC version is more uniform. The points sample better
    near the boundaries and there are less clusters or gaps.
  prefs: []
  type: TYPE_NORMAL
- en: One way to assess the uniformity is to use a measure called the discrepancy.
    Here the discrepancy of *Sobol’* points is better than crude MC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Coming back to the computation of the mean, QMC methods also have better rates
    of convergence for the error. They can achieve \(O(n^{-1})\) for this function,
    and even better rates on very smooth functions. This figure shows that the *Sobol’*
    method has a rate of \(O(n^{-1})\):'
  prefs: []
  type: TYPE_NORMAL
- en: '![" "](../Images/1d34a8884e12406bf5f80a540235690b.png)'
  prefs: []
  type: TYPE_IMG
- en: We refer to the documentation of [`scipy.stats.qmc`](../reference/stats.qmc.html#module-scipy.stats.qmc
    "scipy.stats.qmc") for more mathematical details.
  prefs: []
  type: TYPE_NORMAL
- en: Calculate the discrepancy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s consider two sets of points. From the figure below, it is clear that the
    design on the left covers more of the space than the design on the right. This
    can be quantified using a [`discrepancy`](../reference/generated/scipy.stats.qmc.discrepancy.html#scipy.stats.qmc.discrepancy
    "scipy.stats.qmc.discrepancy") measure. The lower the discrepancy, the more uniform
    a sample is.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/e11d70f50b9578a2a46e30ec94614d73.png)'
  prefs: []
  type: TYPE_IMG
- en: Using a QMC engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Several QMC samplers/engines are implemented. Here we look at two of the most
    used QMC methods: [`Sobol`](../reference/generated/scipy.stats.qmc.Sobol.html#scipy.stats.qmc.Sobol
    "scipy.stats.qmc.Sobol") and [`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton") sequences.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '![" "](../Images/89ea2a381733ddf2abbdaee679862827.png)'
  prefs: []
  type: TYPE_IMG
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: QMC methods require particular care and the user must read the documentation
    to avoid common pitfalls. *Sobol’* for instance requires a number of points following
    a power of 2\. Also, thinning, burning or other point selection can break the
    properties of the sequence and result in a set of points which would not be better
    than MC.
  prefs: []
  type: TYPE_NORMAL
- en: 'QMC engines are state-aware. Meaning that you can continue the sequence, skip
    some points, or reset it. Let’s take 5 points from [`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton"). And then ask for a second set of 5 points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we reset the sequence. Asking for 5 points leads to the same first 5 points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'And here we advance the sequence to get the same second set of 5 points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default, both [`Sobol`](../reference/generated/scipy.stats.qmc.Sobol.html#scipy.stats.qmc.Sobol
    "scipy.stats.qmc.Sobol") and [`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton") are scrambled. The convergence properties are better,
    and it prevents the appearance of fringes or noticeable patterns of points in
    high dimensions. There should be no practical reason not to use the scrambled
    version.
  prefs: []
  type: TYPE_NORMAL
- en: Making a QMC engine, i.e., subclassing `QMCEngine`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make your own [`QMCEngine`](../reference/generated/scipy.stats.qmc.QMCEngine.html#scipy.stats.qmc.QMCEngine
    "scipy.stats.qmc.QMCEngine"), a few methods have to be defined. Following is an
    example wrapping [`numpy.random.Generator`](https://numpy.org/devdocs/reference/random/generator.html#numpy.random.Generator
    "(in NumPy v2.0.dev0)").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we use it as any other QMC engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Guidelines on using QMC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: QMC has rules! Be sure to read the documentation or you might have no benefit
    over MC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use [`Sobol`](../reference/generated/scipy.stats.qmc.Sobol.html#scipy.stats.qmc.Sobol
    "scipy.stats.qmc.Sobol") if you need **exactly** \(2^m\) points.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Halton`](../reference/generated/scipy.stats.qmc.Halton.html#scipy.stats.qmc.Halton
    "scipy.stats.qmc.Halton") allows to sample, or skip, an arbitrary number of points.
    This is at the cost of a slower rate of convergence than *Sobol’*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never remove the first points of the sequence. It will destroy the properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scrambling is always better.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use LHS based methods, you cannot add points without losing the LHS properties.
    (There are some methods to do so, but this is not implemented.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
