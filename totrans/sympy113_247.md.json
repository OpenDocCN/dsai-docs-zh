["```py\n>>> from sympy.utilities.autowrap import autowrap\n>>> from sympy import symbols, IndexedBase, Idx, Eq\n>>> A, x, y = map(IndexedBase, ['A', 'x', 'y'])\n>>> m, n = symbols('m n', integer=True)\n>>> i = Idx('i', m)\n>>> j = Idx('j', n)\n>>> instruction = Eq(y[i], A[i, j]*x[j]); instruction\nEq(y[i], A[i, j]*x[j]) \n```", "```py\n>>> matvec = autowrap(instruction) \n```", "```py\n>>> M = [[0, 1],\n...      [1, 0]]\n>>> matvec(M, [2, 3])                              \n[ 3\\.  2.] \n```", "```py\n>>> from sympy.utilities.autowrap import autowrap \n```", "```py\n>>> from sympy.abc import x,y\n>>> expr = (x - y)**25\n>>> flat = expr.expand()\n>>> binary_callable = autowrap(flat)\n>>> binary_callable(2, 3)\n-1.0 \n```", "```py\n>>> binary_callable(3, 2)\n0.0\n>>> binary_callable(4, 5), binary_callable(5, 4)\n(-22925376.0, 25165824.0) \n```", "```py\n>>> e = autowrap(expr)\n>>> e(4, 5), e(5, 4)\n(-1.0, 1.0) \n```", "```py\n>>> from sympy.utilities.autowrap import binary_function\n>>> f = binary_function('f', expr)\n>>> 2*f(x, y) + y\ny + 2*f(x, y)\n>>> (2*f(x, y) + y).evalf(2, subs={x: 1, y:2})\n0.e-110 \n```", "```py\nclass sympy.utilities.autowrap.CodeWrapper(generator, filepath=None, flags=[], verbose=False)\n```", "```py\nclass sympy.utilities.autowrap.CythonCodeWrapper(*args, **kwargs)\n```", "```py\ndump_pyx(routines, f, prefix)\n```", "```py\nclass sympy.utilities.autowrap.DummyWrapper(generator, filepath=None, flags=[], verbose=False)\n```", "```py\nclass sympy.utilities.autowrap.F2PyCodeWrapper(*args, **kwargs)\n```", "```py\nclass sympy.utilities.autowrap.UfuncifyCodeWrapper(*args, **kwargs)\n```", "```py\ndump_c(routines, f, prefix, funcname=None)\n```", "```py\nsympy.utilities.autowrap.autowrap(expr, language=None, backend='f2py', tempdir=None, args=None, flags=None, verbose=False, helpers=None, code_gen=None, **kwargs)\n```", "```py\n>>> from sympy.abc import x, y, z\n>>> from sympy.utilities.autowrap import autowrap\n>>> expr = ((x - y + z)**(13)).expand()\n>>> binary_func = autowrap(expr)\n>>> binary_func(1, 4, 2)\n-1.0 \n```", "```py\nsympy.utilities.autowrap.binary_function(symfunc, expr, **kwargs)\n```", "```py\n>>> from sympy.abc import x, y\n>>> from sympy.utilities.autowrap import binary_function\n>>> expr = ((x - y)**(25)).expand()\n>>> f = binary_function('f', expr)\n>>> type(f)\n<class 'sympy.core.function.UndefinedFunction'>\n>>> 2*f(x, y)\n2*f(x, y)\n>>> f(x, y).evalf(2, subs={x: 1, y: 2})\n-1.0 \n```", "```py\nsympy.utilities.autowrap.ufuncify(args, expr, language=None, backend='numpy', tempdir=None, flags=None, verbose=False, helpers=None, **kwargs)\n```", "```py\n>>> from sympy.utilities.autowrap import ufuncify\n>>> from sympy.abc import x, y\n>>> import numpy as np\n>>> f = ufuncify((x, y), y + x**2)\n>>> type(f)\n<class 'numpy.ufunc'>\n>>> f([1, 2, 3], 2)\narray([  3.,   6.,  11.])\n>>> f(np.arange(5), 3)\narray([  3.,   4.,   7.,  12.,  19.]) \n```", "```py\n>>> f_fortran = ufuncify((x, y), y + x**2, backend='f2py')\n>>> f_fortran(1, 2)\narray([ 3.])\n>>> f_fortran(np.array([1, 2, 3]), np.array([1.0, 2.0, 3.0]))\narray([  2.,   6.,  12.])\n>>> f_cython = ufuncify((x, y), y + x**2, backend='Cython')\n>>> f_cython(1, 2)  \nTraceback (most recent call last):\n  ...\nTypeError: Argument '_x' has incorrect type (expected numpy.ndarray, got int)\n>>> f_cython(np.array([1.0]), np.array([2.0]))\narray([ 3.]) \n```"]