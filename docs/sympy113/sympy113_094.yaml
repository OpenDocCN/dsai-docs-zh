- en: Solvers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解算器
- en: Original text：[https://docs.sympy.org/latest/modules/solvers/solvers.html](https://docs.sympy.org/latest/modules/solvers/solvers.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文链接：[https://docs.sympy.org/latest/modules/solvers/solvers.html](https://docs.sympy.org/latest/modules/solvers/solvers.html)
- en: The *solvers* module in SymPy implements methods for solving equations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy中的*solvers*模块实现了解方程的方法。
- en: Note
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: For a beginner-friendly guide focused on solving common types of equations,
    refer to [Solve Equations](../../guides/solving/index.html#solving-guide).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于专注于解决常见类型方程的初学者指南，请参阅[Solve Equations](../../guides/solving/index.html#solving-guide)。
- en: Note
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve") is
    an older more mature general function for solving many types of equations. [`solve()`](#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") has many options and uses different methods internally
    to determine what type of equations you pass it, so if you know what type of equation
    you are dealing with you may want to use the newer [`solveset()`](solveset.html#module-sympy.solvers.solveset
    "sympy.solvers.solveset") which solves univariate equations, [`linsolve()`](solveset.html#sympy.solvers.solveset.linsolve
    "sympy.solvers.solveset.linsolve") which solves system of linear equations, and
    [`nonlinsolve()`](solveset.html#sympy.solvers.solveset.nonlinsolve "sympy.solvers.solveset.nonlinsolve")
    which solves systems of non linear equations.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")是一个更老、更成熟的通用函数，用于解决许多类型的方程。
    [`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")具有许多选项，并且在内部使用不同的方法来确定您传递的方程类型，因此如果您知道正在处理的方程类型，可能希望使用更新的[`solveset()`](solveset.html#module-sympy.solvers.solveset
    "sympy.solvers.solveset")来解决一元方程，[`linsolve()`](solveset.html#sympy.solvers.solveset.linsolve
    "sympy.solvers.solveset.linsolve")来解决线性方程组，以及[`nonlinsolve()`](solveset.html#sympy.solvers.solveset.nonlinsolve
    "sympy.solvers.solveset.nonlinsolve")来解决非线性方程组。'
- en: '## Algebraic equations'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '## 代数方程'
- en: 'Use [`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")
    to solve algebraic equations. We suppose all equations are equaled to 0, so solving
    x**2 == 1 translates into the following code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")来解代数方程。我们假设所有方程都等于0，因此解决
    x**2 == 1 可以转换为以下代码：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first argument for [`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")
    is an equation (equaled to zero) and the second argument is the symbol that we
    want to solve the equation for.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")的第一个参数是一个等于零的方程，第二个参数是我们想要解的符号。'
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Algebraically solves equations and systems of equations.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 代数地解方程和方程组。
- en: 'Parameters:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**f :**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**f：**'
- en: a single Expr or Poly that must be zero
  id: totrans-15
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一的Expr或Poly必须为零
- en: ''
  id: totrans-16
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-17
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an Equality
  id: totrans-18
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个等式
- en: ''
  id: totrans-19
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-20
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a Relational expression
  id: totrans-21
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个关系表达式
- en: ''
  id: totrans-22
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-23
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a Boolean
  id: totrans-24
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个布尔值
- en: ''
  id: totrans-25
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-26
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: iterable of one or more of the above
  id: totrans-27
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以上的一个或多个可迭代对象
- en: '**symbols** : (object(s) to solve for) specified as'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号**：（要解决的对象）指定为'
- en: none given (other non-numeric objects will be used)
  id: totrans-29
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未指定（将使用其他非数字对象）
- en: ''
  id: totrans-30
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-31
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: single symbol
  id: totrans-32
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一符号
- en: ''
  id: totrans-33
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-34
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: denested list of symbols (e.g., `solve(f, x, y)`)
  id: totrans-35
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号的去嵌套列表（例如，`solve(f, x, y)`）
- en: ''
  id: totrans-36
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-37
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ordered iterable of symbols (e.g., `solve(f, [x, y])`)
  id: totrans-38
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号的有序迭代对象（例如，`solve(f, [x, y])`）
- en: '**flags :**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**标志：**'
- en: dict=True (default is False)
  id: totrans-40
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: dict=True（默认为False）
- en: ''
  id: totrans-41
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return list (perhaps empty) of solution mappings.
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回映射解列表（可能为空）。
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: set=True (default is False)
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: set=True（默认为False）
- en: ''
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return list of symbols and set of tuple(s) of solution(s).
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 返回符号列表和解的元组集合。
- en: ''
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: exclude=[] (default)
  id: totrans-48
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: exclude=[]（默认）
- en: ''
  id: totrans-49
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do not try to solve for any of the free symbols in exclude; if expressions are
    given, the free symbols in them will be extracted automatically.
  id: totrans-50
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要尝试解决排除列表中的任何自由符号；如果给出表达式，其中的自由符号将自动提取。
- en: ''
  id: totrans-51
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: check=True (default)
  id: totrans-52
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: check=True（默认）
- en: ''
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If False, do not do any testing of solutions. This can be useful if you want
    to include solutions that make any denominator zero.
  id: totrans-54
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果为False，则不进行任何解的测试。如果要包含使任何分母为零的解，这可能很有用。
- en: ''
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: numerical=True (default)
  id: totrans-56
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: numerical=True（默认）
- en: ''
  id: totrans-57
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do a fast numerical check if *f* has only one symbol.
  id: totrans-58
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果*f*仅有一个符号，进行快速数值检查。
- en: ''
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimal=True (default is False)
  id: totrans-60
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: minimal=True（默认为False）
- en: ''
  id: totrans-61
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A very fast, minimal testing.
  id: totrans-62
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 一种非常快速、最小的测试。
- en: ''
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: warn=True (default is False)
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: warn=True（默认为False）
- en: ''
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show a warning if `checksol()` could not conclude.
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果`checksol()`无法得出结论，则显示警告。
- en: ''
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: simplify=True (default)
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: simplify=True（默认）
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Simplify all but polynomials of order 3 or greater before returning them and
    (if check is not False) use the general simplify function on the solutions and
    the expression obtained when they are substituted into the function which should
    be zero.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在返回它们之前简化所有三阶及以上的多项式，并且（如果检查不为False）在将它们代入应为零的函数时使用通用简化函数对解决方案和表达式进行简化。
- en: ''
  id: totrans-71
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: force=True (default is False)
  id: totrans-72
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: force=True（默认为False）
- en: ''
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make positive all symbols without assumptions regarding sign.
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 使所有没有关于符号的假设的符号为正。
- en: ''
  id: totrans-75
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: rational=True (default)
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: rational=True（默认）
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Recast Floats as Rational; if this option is not used, the system containing
    Floats may fail to solve because of issues with polys. If rational=None, Floats
    will be recast as rationals but the answer will be recast as Floats. If the flag
    is False then nothing will be done to the Floats.
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重置浮点数为有理数；如果不使用此选项，包含浮点数的系统可能因多项式问题而无法解决。如果rational=None，则浮点数将被重置为有理数，但答案将被重置为浮点数。如果标志为False，则不会对浮点数进行任何处理。
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: manual=True (default is False)
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: manual=True（默认为False）
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do not use the polys/matrix method to solve a system of equations, solve them
    one at a time as you might “manually.”
  id: totrans-82
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 不要使用多项式/矩阵方法来解决方程组，按顺序解决它们，就像“手动”一样。
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: implicit=True (default is False)
  id: totrans-84
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: implicit=True（默认为False）
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Allows `solve` to return a solution for a pattern in terms of other functions
    that contain that pattern; this is only needed if the pattern is inside of some
    invertible function like cos, exp, ect.
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 允许`solve`返回模式的解，以其他包含该模式的函数来表示；仅在该模式位于某些可逆函数内部（如cos，exp等）时才需要。
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: particular=True (default is False)
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: particular=True（默认为False）
- en: ''
  id: totrans-89
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instructs `solve` to try to find a particular solution to a linear system with
    as many zeros as possible; this is very expensive.
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 指示`solve`尝试找到线性系统的特定解，其中尽可能多的解为零；这是非常昂贵的。
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: quick=True (default is False; `particular` must be True)
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: quick=True（默认为False；`particular`必须为True）
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Selects a fast heuristic to find a solution with many zeros whereas a value
    of False uses the very slow method guaranteed to find the largest number of zeros
    possible.
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 选择一个快速的启发式方法来找到具有许多零的解，而值为False则使用保证找到尽可能多零的非常缓慢的方法。
- en: ''
  id: totrans-95
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cubics=True (default)
  id: totrans-96
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cubics=True（默认）
- en: ''
  id: totrans-97
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return explicit solutions when cubic expressions are encountered. When False,
    quartics and quintics are disabled, too.
  id: totrans-98
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 遇到立方表达式时返回显式解。当为False时，四次方和五次方也被禁用。
- en: ''
  id: totrans-99
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: quartics=True (default)
  id: totrans-100
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: quartics=True（默认）
- en: ''
  id: totrans-101
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return explicit solutions when quartic expressions are encountered. When False,
    quintics are disabled, too.
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 遇到四次表达式时返回显式解。当为False时，五次方也被禁用。
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: quintics=True (default)
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: quintics=True（默认）
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return explicit solutions (if possible) when quintic expressions are encountered.
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 遇到五次表达式时返回显式解（如果可能）。
- en: Explanation
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 说明
- en: 'Currently supported:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当前支持：
- en: polynomial
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多项式
- en: transcendental
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无穷的
- en: piecewise combinations of the above
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述内容的分段组合
- en: systems of linear and polynomial equations
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线性和多项式方程组
- en: systems containing relational expressions
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含关系表达式的系统
- en: systems implied by undetermined coefficients
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由未定系数暗示的系统
- en: Examples
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: The default output varies according to the input and might be a list (possibly
    empty), a dictionary, a list of dictionaries or tuples, or an expression involving
    relationals. For specifics regarding different forms of output that may appear,
    see [Solve Output by Type](../../explanation/solve_output.html#solve-output).
    Let it suffice here to say that to obtain a uniform output from \(solve\) use
    `dict=True` or `set=True` (see below).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 默认输出根据输入而变化，可能是一个列表（可能为空）、一个字典、一个列表字典或元组，或者是涉及关系的表达式。具体关于可能出现的不同形式的输出，请参见[Solve
    Output by Type](../../explanation/solve_output.html#solve-output)。在这里，可以说为了从`solve`获取统一的输出，使用`dict=True`或`set=True`（见下文）足够了。
- en: '[PRE2]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The expressions that are passed can be Expr, Equality, or Poly classes (or
    lists of the same); a Matrix is considered to be a list of all the elements of
    the matrix:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 传递的表达式可以是Expr、Equality或Poly类（或相同类型的列表）；矩阵被视为包含矩阵所有元素的列表：
- en: '[PRE3]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'If no symbols are indicated to be of interest and the equation is univariate,
    a list of values is returned; otherwise, the keys in a dictionary will indicate
    which (of all the variables used in the expression(s)) variables and solutions
    were found:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指示感兴趣的符号，并且方程式是单变量的，则返回值列表；否则，字典中的键将指示在表达式中找到的哪些（所有变量中使用的变量和解决方案）变量：
- en: '[PRE4]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you pass symbols for which solutions are sought, the output will vary depending
    on the number of symbols you passed, whether you are passing a list of expressions
    or not, and whether a linear system was solved. Uniform output is attained by
    using `dict=True` or `set=True`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你传递寻找解的符号，输出将根据你传递的符号数量、是否传递表达式列表以及是否解决了线性系统而变化。通过使用`dict=True`或`set=True`来获得统一的输出。
- en: '[PRE5]'
  id: totrans-123
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE5]'
- en: ''
  id: totrans-124
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If any equation does not depend on the symbol(s) given, it will be eliminated
    from the equation set and an answer may be given implicitly in terms of variables
    that were not of interest:'
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何方程不依赖于给定的符号，则将从方程组中排除它，并且可能以对不感兴趣的变量隐式给出答案：
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-127
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-129
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you pass all but one of the free symbols, an attempt is made to find a
    single solution based on the method of undetermined coefficients. If it succeeds,
    a dictionary of values is returned. If you want an algebraic solutions for one
    or more of the symbols, pass the expression to be solved in a list:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你传递除一个自由符号外的所有自由符号时，将尝试基于不定系数法找到单个解。如果成功，将返回值的字典。如果要对一个或多个符号的表达式进行代数解，请将其传递给要解决的列表：
- en: '[PRE7]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When there is no solution for any given symbol which will make all expressions
    zero, the empty list is returned (or an empty set in the tuple when `set=True`):'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有任何符号的解使得所有表达式都为零时，将返回空列表（或在`set=True`时返回空集）：
- en: '[PRE8]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When an object other than a Symbol is given as a symbol, it is isolated algebraically
    and an implicit solution may be obtained. This is mostly provided as a convenience
    to save you from replacing the object with a Symbol and solving for that Symbol.
    It will only work if the specified object can be replaced with a Symbol using
    the subs method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果作为符号给出的对象不是符号，则会进行代数隔离，并可能获得隐式解。这主要是为了方便你节省将对象替换为符号并解决该符号的时间。它只在指定对象可以使用`subs`方法替换为符号时才起作用：
- en: '[PRE9]'
  id: totrans-135
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE9]'
- en: ''
  id: totrans-136
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-137
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE10]'
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ''
  id: totrans-140
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To solve for a function within a derivative, use [`dsolve()`](ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve").
  id: totrans-141
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要解决导数中的函数，请使用[`dsolve()`](ode.html#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")。
- en: 'To solve for a symbol implicitly, use implicit=True:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要隐式解符号，请使用implicit=True：
- en: '[PRE12]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'It is possible to solve for anything in an expression that can be replaced
    with a symbol using [`subs`](../core.html#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs"):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以解决表达式中任何可以使用[`subs`](../core.html#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")替换为符号的内容。
- en: '[PRE13]'
  id: totrans-145
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE13]'
- en: ''
  id: totrans-146
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Nothing heroic is done in this implicit solving so you may end up with a symbol
    still in the solution:'
  id: totrans-147
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种隐式求解中没有采取任何英雄主义行为，因此可能最终解中仍然会出现符号：
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-149
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-151
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-153
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you attempt to solve for a number, remember that the number you have obtained
    does not necessarily mean that the value is equivalent to the expression obtained:'
  id: totrans-154
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果尝试解决一个数字，请记住，你获得的数字并不一定意味着该值等同于所获得的表达式：
- en: ''
  id: totrans-155
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-157
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-158
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Additional Examples**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**附加示例**'
- en: '`solve()` with check=True (default) will run through the symbol tags to eliminate
    unwanted solutions. If no assumptions are included, all possible solutions will
    be returned:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`check=True`（默认情况下）的`solve()`将通过符号标签来消除不需要的解。如果不包括任何假设，则将返回所有可能的解：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'By setting the `positive` flag, only one solution will be returned:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置`positive`标志，将只返回一个解：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When the solutions are checked, those that make any denominator zero are automatically
    excluded. If you do not want to exclude such solutions, then use the check=False
    option:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当检查解时，使得任何分母为零的解将自动被排除。如果不想排除这样的解，请使用`check=False`选项：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If `check=False`, then a solution to the numerator being zero is found but
    the value of \(x = 0\) is a spurious solution since \(\sin(x)/x\) has the well
    known limit (without discontinuity) of 1 at \(x = 0\):'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`check=False`，则会找到使得分子为零的解，但是当\(x = 0\)时，\(\sin(x)/x\)具有众所周知的极限（无间断），为1：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the following case, however, the limit exists and is equal to the value
    of \(x = 0\) that is excluded when check=True:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的情况中，限制存在并等于在`check=True`时被排除的\(x = 0\)的值：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '**Solving Relationships**'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决关系**'
- en: 'When one or more expressions passed to `solve` is a relational, a relational
    result is returned (and the `dict` and `set` flags are ignored):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递给`solve`的一个或多个表达式为关系式时，将返回一个关系结果（并且`dict`和`set`标志将被忽略）：
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Although checking of assumptions on symbols in relationals is not done, setting
    assumptions will affect how certain relationals might automatically simplify:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然未对关系中的符号进行检查假设，但设置假设将影响某些关系可能自动简化的方式：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is currently no algorithm in SymPy that allows you to use relationships
    to resolve more than one variable. So the following does not determine that `q
    < 0` (and trying to solve for `r` and `q` will raise an error):'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 目前在SymPy中没有算法允许您使用关系解析多个变量。因此，以下内容不能确定`q < 0`（尝试解析`r`和`q`会引发错误）：
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'You can directly call the routine that `solve` calls when it encounters a relational:
    [`reduce_inequalities()`](inequalities.html#sympy.solvers.inequalities.reduce_inequalities
    "sympy.solvers.inequalities.reduce_inequalities"). It treats Expr like Equality.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以直接调用`solve`遇到关系时调用的例程：[`reduce_inequalities()`](inequalities.html#sympy.solvers.inequalities.reduce_inequalities
    "sympy.solvers.inequalities.reduce_inequalities")。它将Expr视为Equality。
- en: '[PRE25]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If each relationship contains only one symbol of interest, the expressions
    can be processed for multiple symbols:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果每个关系只包含一个感兴趣的符号，则可以为多个符号处理表达式：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'But an error is raised if any relationship has more than one symbol of interest:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果任何关系具有超过一个感兴趣的符号，则会引发错误：
- en: '[PRE27]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Disabling High-Order Explicit Solutions**'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '**禁用高阶显式解决方案**'
- en: 'When solving polynomial expressions, you might not want explicit solutions
    (which can be quite long). If the expression is univariate, `CRootOf` instances
    will be returned instead:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 解决多项式表达式时，您可能不希望获得显式解决方案（这可能会很长）。如果表达式是单变量的，则将返回`CRootOf`实例：
- en: '[PRE28]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If the expression is multivariate, no solution might be returned:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式是多变量的，则可能不会返回任何解决方案：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Sometimes solutions will be obtained even when a flag is False because the
    expression could be factored. In the following example, the equation can be factored
    as the product of a linear and a quadratic factor so explicit solutions (which
    did not require solving a cubic expression) are obtained:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有时即使标志为False，也会获得解决方案，因为可能对表达式进行了因式分解。在以下示例中，方程可以因式分解为线性因子和二次因子的乘积，因此获得了显式解决方案（这不需要解决三次表达式）：
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Solving Equations Involving Radicals**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决涉及根式的方程**'
- en: 'Because of SymPy’s use of the principle root, some solutions to radical equations
    will be missed unless check=False:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SymPy使用主根的原则，某些根式方程的解将被错过，除非check=False：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the above example, there is only a single solution to the equation. Other
    expressions will yield spurious roots which must be checked manually; roots which
    give a negative argument to odd-powered radicals will also need special checking:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，方程只有一个解。其他表达式将产生虚假根，必须手动检查；给奇次幂根提供负参数的根也需要特别检查：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The first solution is negative so `real_root` must be used to see that it satisfies
    the expression:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个解为负数，因此必须使用`real_root`来查看它是否满足表达式：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If the roots of the equation are not real then more care will be necessary
    to find the roots, especially for higher order equations. Consider the following
    expression:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方程的根不是实数，则需要更多的注意找到根，特别是对于高阶方程。考虑以下表达式：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We will construct a known value for this expression at x = 3 by selecting the
    1-th root for each radical:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过选择每个根式的第1个根在x = 3处构造此表达式的已知值：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `solve` function is unable to find any exact roots to this equation:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`solve`函数无法找到此方程的任何精确根：'
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The function `unrad`, however, can be used to get a form of the equation for
    which numerical roots can be found:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`unrad`可以用于获得方程的一种形式，从而可以找到数值根：
- en: '[PRE37]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Although `eq` or `eq1` could have been used to find `xvals`, the solution can
    only be verified with `expr1`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`eq`或`eq1`可以用于查找`xvals`，但只有通过`expr1`才能验证解决方案：
- en: '[PRE38]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`rsolve`](#sympy.solvers.recurr.rsolve "sympy.solvers.recurr.rsolve")'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[`rsolve`](#sympy.solvers.recurr.rsolve "sympy.solvers.recurr.rsolve")'
- en: For solving recurrence relationships
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解决递归关系
- en: '[`dsolve`](ode.html#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[`dsolve`](ode.html#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")'
- en: For solving differential equations
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 用于解决微分方程
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Return a tuple derived from `f = lhs - rhs` that is one of the following: `(0,
    1)`, `(0, 0)`, `(symbol, solution)`, `(n, d)`.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个从`f = lhs - rhs`派生的元组，其中一个是以下之一：`(0, 1)`、`(0, 0)`、`(symbol, solution)`、`(n,
    d)`。
- en: Explanation
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '`(0, 1)` meaning that `f` is independent of the symbols in *symbols* that are
    not in *exclude*.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`(0, 1)`表示`f`与*symbols*中不在*exclude*中的符号无关。'
- en: '`(0, 0)` meaning that there is no solution to the equation amongst the symbols
    given. If the first element of the tuple is not zero, then the function is guaranteed
    to be dependent on a symbol in *symbols*.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`(0, 0)`表示在给定的符号中没有方程的解。如果元组的第一个元素不为零，则函数保证依赖于*symbols*中的符号。'
- en: '`(symbol, solution)` where symbol appears linearly in the numerator of `f`,
    is in *symbols* (if given), and is not in *exclude* (if given). No simplification
    is done to `f` other than a `mul=True` expansion, so the solution will correspond
    strictly to a unique solution.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`(symbol, solution)` 其中符号在 `f` 的分子中线性出现，在 *symbols* 中（如果给定），且不在 *exclude* 中（如果给定）。除了
    `mul=True` 扩展之外，`f` 不对 `f` 进行任何简化，因此解决方案将严格对应于唯一解决方案。'
- en: '`(n, d)` where `n` and `d` are the numerator and denominator of `f` when the
    numerator was not linear in any symbol of interest; `n` will never be a symbol
    unless a solution for that symbol was found (in which case the second element
    is the solution, not the denominator).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`(n, d)` 其中 `n` 和 `d` 是 `f` 的分子和分母，当分子不是任何感兴趣符号的线性时；除非找到该符号的解决方案（在这种情况下，第二个元素是解决方案，而不是分母）。'
- en: Examples
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE40]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`f` is independent of the symbols in *symbols* that are not in *exclude*:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`f` 与 *symbols* 中不在 *exclude* 中的符号无关：'
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The variable `x` appears as a linear variable in each of the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 变量 `x` 在以下每个中作为线性变量出现：
- en: '[PRE42]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When not linear in `x` or `y` then the numerator and denominator are returned:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `x` 或 `y` 中不是线性时，然后返回分子和分母：
- en: '[PRE43]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If the numerator of the expression is a symbol, then `(0, 0)` is returned if
    the solution for that symbol would have set any denominator to 0:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式的分子是一个符号，则如果该符号的解决方案将任何分母设为0，则返回 `(0, 0)`：
- en: '[PRE44]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'But automatic rewriting may cause a symbol in the denominator to appear in
    the numerator so a solution will be returned:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 但是自动重写可能会导致分母中的符号出现在分子中，因此将返回一个解决方案：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Use an unevaluated expression to avoid this:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用未评估的表达式来避免这种情况：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: If `x` is allowed to cancel in the following expression, then it appears to
    be linear in `x`, but this sort of cancellation is not done by `solve_linear`
    so the solution will always satisfy the original expression without causing a
    division by zero error.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许 `x` 在以下表达式中取消，则似乎在 `x` 中是线性的，但 `solve_linear` 不会执行此类取消，因此解决方案将始终满足原始表达式，而不会引发除零错误。
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A list of symbols for which a solution is desired may be given:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 可以给出希望解决方案的符号列表：
- en: '[PRE48]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A list of symbols to ignore may also be given:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以给出一个要忽略的符号列表：
- en: '[PRE49]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: (A solution for `y` is obtained because it is the first variable from the canonically
    sorted list of symbols that had a linear solution.)
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: （因为它是从符号的规范排序列表中第一个具有线性解的变量，所以得到了 `y` 的解。）
- en: '[PRE50]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Solve system of \(N\) linear equations with \(M\) variables, which means both
    under- and overdetermined systems are supported.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 解决具有 \(N\) 个线性方程和 \(M\) 个变量的系统，这意味着支持欠定和过度定系统。
- en: Explanation
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: The possible number of solutions is zero, one, or infinite. Respectively, this
    procedure will return None or a dictionary with solutions. In the case of underdetermined
    systems, all arbitrary parameters are skipped. This may cause a situation in which
    an empty dictionary is returned. In that case, all symbols can be assigned arbitrary
    values.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的解数是零、一或无限。相应地，此过程将返回 None 或一个具有解的字典。在欠定系统的情况下，所有任意参数都将被跳过。这可能导致返回一个空字典的情况。在这种情况下，可以为所有符号分配任意值。
- en: 'Input to this function is a \(N\times M + 1\) matrix, which means it has to
    be in augmented form. If you prefer to enter \(N\) equations and \(M\) unknowns
    then use `solve(Neqs, *Msymbols)` instead. Note: a local copy of the matrix is
    made by this routine so the matrix that is passed will not be modified.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的输入是一个 \(N\times M + 1\) 矩阵，这意味着它必须是增广形式。如果您喜欢输入 \(N\) 个方程和 \(M\) 个未知数，那么请使用
    `solve(Neqs, *Msymbols)`。注意：此例程会制作矩阵的本地副本，因此传递的矩阵不会被修改。
- en: The algorithm used here is fraction-free Gaussian elimination, which results,
    after elimination, in an upper-triangular matrix. Then solutions are found using
    back-substitution. This approach is more efficient and compact than the Gauss-Jordan
    method.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的算法是无分数高斯消元法，在消元后得到一个上三角矩阵。然后使用回代法找到解。这种方法比高斯-约旦方法更有效和更紧凑。
- en: Examples
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE51]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Solve the following system:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 解决以下系统：
- en: '[PRE52]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'A degenerate system returns an empty dictionary:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个退化系统返回一个空字典：
- en: '[PRE54]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Solves the augmented matrix system using `LUsolve` and returns a dictionary
    in which solutions are keyed to the symbols of *syms* as ordered.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `LUsolve` 解决增广矩阵系统，并返回一个字典，其中解按顺序键入为 *syms* 的符号。
- en: Explanation
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: The matrix must be invertible.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵必须可逆。
- en: Examples
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE56]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: See also
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`LUsolve`](../matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve")'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[`LUsolve`](../matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve")'
- en: '[PRE58]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Solve a system of equations in \(k\) parameters that is formed by matching coefficients
    in variables `coeffs` that are on factors dependent on the remaining variables
    (or those given explicitly by `syms`.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 解决一个由匹配`coeffs`变量中的系数形成的包含\(k\)个参数的方程组，这些系数依赖于其余变量（或由`syms`显式给出）。
- en: Explanation
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: The result of this function is a dictionary with symbolic values of those parameters
    with respect to coefficients in \(q\) – empty if there is no solution or coefficients
    do not appear in the equation – else None (if the system was not recognized).
    If there is more than one solution, the solutions are passed as a list. The output
    can be modified using the same semantics as for \(solve\) since the flags that
    are passed are sent directly to \(solve\) so, for example the flag `dict=True`
    will always return a list of solutions as dictionaries.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的结果是一个字典，其中包含关于\(q\)中系数的符号值 - 如果没有解或系数不出现在方程中，则为空 - 否则为None（如果系统未被识别）。如果存在多个解，解将作为列表传递。输出可以使用与`solve`相同的语义进行修改，因为传递的标志直接发送到`solve`，例如标志`dict=True`将始终返回作为字典的解的列表。
- en: This function accepts both Equality and Expr class instances. The solving process
    is most efficient when symbols are specified in addition to parameters to be determined,
    but an attempt to determine them (if absent) will be made. If an expected solution
    is not obtained (and symbols were not specified) try specifying them.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受Equality和Expr类实例。当指定符号以确定要确定的参数时，解决过程最有效，但将尝试确定它们（如果不存在）。如果未获得预期的解决方案（并且未指定符号），请尝试指定它们。
- en: Examples
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE59]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The equation can be nonlinear in the symbols:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 方程可以在符号中是非线性的：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'And the system can be nonlinear in coefficients, too, but if there is only
    a single solution, it will be returned as a dictionary:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 系数在非线性的情况下也可以是非线性的，但如果只有一个解，则将其作为字典返回：
- en: '[PRE62]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Multiple solutions are always returned in a list:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 多个解始终作为列表返回：
- en: '[PRE63]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Using flag `dict=True` (in keeping with semantics in [`solve()`](#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")) will force the result to always be a list with
    any solutions as elements in that list.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标志`dict=True`（符合[`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")中的语义）将强制结果始终为包含任何解的列表。
- en: '[PRE64]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Solve a nonlinear equation system numerically: `nsolve(f, [args,] x0, modules=[''mpmath''],
    **kwargs)`.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 数值解非线性方程组：`nsolve(f, [args,] x0, modules=['mpmath'], **kwargs)`。
- en: Explanation
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: '`f` is a vector function of symbolic expressions representing the system. *args*
    are the variables. If there is only one variable, this argument can be omitted.
    `x0` is a starting vector close to a solution.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '`f`是表示系统的符号表达式的向量函数。*args*是变量。如果只有一个变量，则可以省略此参数。`x0`是接近解的起始向量。'
- en: Use the modules keyword to specify which modules should be used to evaluate
    the function and the Jacobian matrix. Make sure to use a module that supports
    matrices. For more information on the syntax, please see the docstring of `lambdify`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 使用modules关键字指定应用于评估函数和雅可比矩阵的模块。确保使用支持矩阵的模块。有关语法的更多信息，请参阅`lambdify`的文档字符串。
- en: 'If the keyword arguments contain `dict=True` (default is False) `nsolve` will
    return a list (perhaps empty) of solution mappings. This might be especially useful
    if you want to use `nsolve` as a fallback to solve since using the dict argument
    for both methods produces return values of consistent type structure. Please note:
    to keep this consistent with `solve`, the solution will be returned in a list
    even though `nsolve` (currently at least) only finds one solution at a time.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果关键字参数包含`dict=True`（默认为False），`nsolve`将返回一个解映射的列表（可能为空）。如果想要使用`nsolve`作为`solve`的替代解决方案，这可能特别有用，因为对于两种方法都使用dict参数会产生一致类型结构的返回值。请注意：为了保持与`solve`的一致性，即使`nsolve`（目前至少）一次只找到一个解，解也将作为列表返回。
- en: Overdetermined systems are supported.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 支持超定系统。
- en: Examples
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'For one-dimensional functions the syntax is simplified:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一维函数，语法更简单：
- en: '[PRE67]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To solve with higher precision than the default, use the prec argument:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 要以高于默认精度解决，请使用prec参数：
- en: '[PRE68]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'To solve for complex roots of real functions, a nonreal initial point must
    be specified:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决实函数的复根，必须指定非实数的初始点：
- en: '[PRE69]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '`mpmath.findroot` is used and you can find their more extensive documentation,
    especially concerning keyword parameters and available solvers. Note, however,
    that functions which are very steep near the root, the verification of the solution
    may fail. In this case you should use the flag `verify=False` and independently
    verify the solution.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`mpmath.findroot`，您可以找到更详细的文档，特别是关于关键字参数和可用求解器的部分。但请注意，对于在根附近非常陡峭的函数，验证解可能会失败。在这种情况下，您应该使用标志`verify=False`并独立验证解决方案。
- en: '[PRE70]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'One might safely skip the verification if bounds of the root are known and
    a bisection method is used:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 如果根的边界已知且使用二分法，可以安全地跳过验证：
- en: '[PRE71]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Alternatively, a function may be better behaved when the denominator is ignored.
    Since this is not always the case, however, the decision of what function to use
    is left to the discretion of the user.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，当忽略分母时，函数可能行为更佳。然而，并非总是如此，因此使用哪个函数的决定留给用户决定。
- en: '[PRE72]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Checks whether sol is a solution of equation f == 0.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 检查sol是否为方程*f == 0*的解。
- en: Explanation
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: Input can be either a single symbol and corresponding value or a dictionary
    of symbols and values. When given as a dictionary and flag `simplify=True`, the
    values in the dictionary will be simplified. *f* can be a single equation or an
    iterable of equations. A solution must satisfy all equations in *f* to be considered
    valid; if a solution does not satisfy any equation, False is returned; if one
    or more checks are inconclusive (and none are False) then None is returned.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 输入可以是单个符号及其对应值，也可以是符号和值的字典。当作为字典给出且标志`simplify=True`时，字典中的值将被简化。 *f* 可以是单个方程或方程的可迭代对象。解必须满足*f*中的所有方程才被认为是有效的；如果一个解不满足任何方程，则返回False；如果一个或多个检查无法得出结论（且没有False），则返回None。
- en: Examples
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'To check if an expression is zero using `checksol()`, pass it as *f* and send
    an empty dictionary for *symbol*:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`checksol()`检查表达式是否为零，将其作为*f*传递，并为*symbol*发送空字典：
- en: '[PRE75]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: None is returned if `checksol()` could not conclude.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`checksol()`无法得出结论，则返回None。
- en: 'flags:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 标志：
- en: ‘numerical=True (default)’
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: ‘numerical=True（默认）’
- en: do a fast numerical check if `f` has only one symbol.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`f`只有一个符号，则进行快速数值检查。
- en: ‘minimal=True (default is False)’
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: ‘minimal=True（默认为False）’
- en: a very fast, minimal testing.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常快速的、最小化的测试。
- en: ‘warn=True (default is False)’
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: ‘warn=True（默认为False）’
- en: show a warning if checksol() could not conclude.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`checksol()`无法得出结论，则显示警告。
- en: ‘simplify=True (default)’
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: ‘simplify=True（默认）’
- en: simplify solution before substituting into function and simplify the function
    before trying specific simplifications
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在将解代入函数之前简化解，以及在尝试特定简化之前简化函数
- en: ‘force=True (default is False)’
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: ‘force=True（默认为False）’
- en: make positive all symbols without assumptions regarding sign.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 使所有符号为正，不假设符号的符号。
- en: '[PRE76]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Remove radicals with symbolic arguments and return (eq, cov), None, or raise
    an error.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 去除具有符号参数的根并返回`(eq, cov)`，None或引发错误。
- en: Explanation
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: None is returned if there are no radicals to remove.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有根可去除，则返回None。
- en: NotImplementedError is raised if there are radicals and they cannot be removed
    or if the relationship between the original symbols and the change of variable
    needed to rewrite the system as a polynomial cannot be solved.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有根并且无法去除或者无法解决重写系统为多项式所需的原始符号与变量变化关系，则引发NotImplementedError。
- en: 'Otherwise the tuple, `(eq, cov)`, is returned where:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 否则返回元组`(eq, cov)`，其中：
- en: '*eq*, `cov`'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '*eq*, `cov`'
- en: '*eq* is an equation without radicals (in the symbol(s) of interest) whose solutions
    are a superset of the solutions to the original expression. *eq* might be rewritten
    in terms of a new variable; the relationship to the original variables is given
    by `cov` which is a list containing `v` and `v**p - b` where `p` is the power
    needed to clear the radical and `b` is the radical now expressed as a polynomial
    in the symbols of interest. For example, for sqrt(2 - x) the tuple would be `(c,
    c**2 - 2 + x)`. The solutions of *eq* will contain solutions to the original equation
    (if there are any).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '*eq* 是一个没有根的方程（在感兴趣的符号中），其解集是原始表达式的超集。 *eq* 可以用新变量重新表达；与原始变量的关系由`cov`给出，其中包含`v`和`v**p
    - b`的列表，其中`p`是清除根所需的幂，`b`是现在用感兴趣的符号表示的根的多项式。例如，对于sqrt(2 - x)，元组将是`(c, c**2 - 2
    + x)`。 *eq* 的解将包含原方程的解（如果有的话）。'
- en: '*syms*'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '*syms*'
- en: 'An iterable of symbols which, if provided, will limit the focus of radical
    removal: only radicals with one or more of the symbols of interest will be cleared.
    All free symbols are used if *syms* is not set.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 如果提供了一个符号的可迭代对象，则限制根式的集中焦点：只有带有一个或多个感兴趣符号的根式将被清除。如果未设置*syms*，则使用所有自由符号。
- en: '*flags* are used internally for communication during recursive calls. Two options
    are also recognized:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '*flags*在递归调用期间用于内部通信。还识别两个选项：'
- en: '`take`, when defined, is interpreted as a single-argument function that returns
    True if a given Pow should be handled.'
  id: totrans-331
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`take`，如果定义了，则被解释为一个单参数函数，如果给定的Pow应该处理，则返回True。'
- en: 'Radicals can be removed from an expression if:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表达式中有根式，可以将其去除：
- en: All bases of the radicals are the same; a change of variables is done in this
    case.
  id: totrans-333
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有根的底数都相同；在这种情况下进行变量更改。
- en: ''
  id: totrans-334
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-335
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If all radicals appear in one term of the expression.
  id: totrans-336
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式中所有根都出现在一个项中。
- en: ''
  id: totrans-337
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-338
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: There are only four terms with sqrt() factors or there are less than four terms
    having sqrt() factors.
  id: totrans-339
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有四个带有sqrt()因子的项，或者少于四个具有sqrt()因子的项。
- en: ''
  id: totrans-340
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-341
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: There are only two terms with radicals.
  id: totrans-342
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有两个带有根式的项。
- en: Examples
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE77]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Ordinary Differential equations (ODEs)
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 普通微分方程（ODEs）
- en: See [ODE](ode.html#ode-docs).
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[ODE](ode.html#ode-docs)。
- en: Partial Differential Equations (PDEs)
  id: totrans-348
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 偏微分方程（PDEs）
- en: See [PDE](pde.html#pde-docs).
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[PDE](pde.html#pde-docs)。
- en: Deutils (Utilities for solving ODE’s and PDE’s)
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Deutils（用于解决ODE和PDE的实用程序）
- en: '[PRE79]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Returns the order of a given differential equation with respect to func.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 返回给定微分方程关于func的阶数。
- en: This function is implemented recursively.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数采用递归实现。
- en: Examples
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE80]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '## Recurrence Equations'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '## 递归方程'
- en: '[PRE81]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Solve univariate recurrence with rational coefficients.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 解决具有有理系数的一元递归。
- en: 'Given \(k\)-th order linear recurrence \(\operatorname{L} y = f\), or equivalently:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 给定\(k\)阶线性递归\(\operatorname{L} y = f\)，或等效地：
- en: \[a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) + \cdots + a_{0}(n) y(n) = f(n)\]
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: \[a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) + \cdots + a_{0}(n) y(n) = f(n)\]
- en: where \(a_{i}(n)\), for \(i=0, \ldots, k\), are polynomials or rational functions
    in \(n\), and \(f\) is a hypergeometric function or a sum of a fixed number of
    pairwise dissimilar hypergeometric terms in \(n\), finds all solutions or returns
    `None`, if none were found.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(a_{i}(n)\)，对于\(i=0, \ldots, k\)，是关于\(n\)的多项式或有理函数，而\(f\)是超几何函数或在\(n\)上具有固定数量不同超几何项的和，找到所有解或返回`None`，如果没有找到。
- en: 'Initial conditions can be given as a dictionary in two forms:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 初始条件可以作为字典的两种形式给出：
- en: '`{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}`'
  id: totrans-363
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}`'
- en: ''
  id: totrans-364
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-365
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}`'
  id: totrans-366
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}`'
- en: 'or as a list `L` of values:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 或作为值列表`L`：
- en: '`L = [v_0, v_1, ..., v_m]`'
  id: totrans-368
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`L = [v_0, v_1, ..., v_m]`'
- en: where `L[i] = v_i`, for \(i=0, \ldots, m\), maps to \(y(n_i)\).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 其中`L[i] = v_i`，对于\(i=0, \ldots, m\)，映射到\(y(n_i)\)。
- en: Examples
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'Lets consider the following recurrence:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下递归：
- en: \[(n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) + 2 n (n + 1) y(n) = 0\]
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: \[(n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) + 2 n (n + 1) y(n) = 0\]
- en: '[PRE82]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: See also
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`rsolve_poly`](#sympy.solvers.recurr.rsolve_poly "sympy.solvers.recurr.rsolve_poly"),
    [`rsolve_ratio`](#sympy.solvers.recurr.rsolve_ratio "sympy.solvers.recurr.rsolve_ratio"),
    [`rsolve_hyper`](#sympy.solvers.recurr.rsolve_hyper "sympy.solvers.recurr.rsolve_hyper")'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[`rsolve_poly`](#sympy.solvers.recurr.rsolve_poly "sympy.solvers.recurr.rsolve_poly"),
    [`rsolve_ratio`](#sympy.solvers.recurr.rsolve_ratio "sympy.solvers.recurr.rsolve_ratio"),
    [`rsolve_hyper`](#sympy.solvers.recurr.rsolve_hyper "sympy.solvers.recurr.rsolve_hyper")'
- en: '[PRE86]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Given linear recurrence operator \(\operatorname{L}\) of order \(k\) with polynomial
    coefficients and inhomogeneous equation \(\operatorname{L} y = f\), where \(f\)
    is a polynomial, we seek for all polynomial solutions over field \(K\) of characteristic
    zero.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 给定具有多项式系数和非齐次方程\(\operatorname{L} y = f\)的\(k\)阶线性递归运算符\(\operatorname{L}\)，其中\(f\)是一个多项式，在特征为零的域\(K\)上寻找所有多项式解。
- en: 'The algorithm performs two basic steps:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 算法执行两个基本步骤：
- en: Compute degree \(N\) of the general polynomial solution.
  id: totrans-382
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算一般多项式解的度\(N\)。
- en: ''
  id: totrans-383
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-384
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Find all polynomials of degree \(N\) or less of \(\operatorname{L} y = f\).
  id: totrans-385
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到所有\(N\)次或更低次的多项式\(\operatorname{L} y = f\)。
- en: There are two methods for computing the polynomial solutions. If the degree
    bound is relatively small, i.e. it’s smaller than or equal to the order of the
    recurrence, then naive method of undetermined coefficients is being used. This
    gives a system of algebraic equations with \(N+1\) unknowns.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法来计算多项式解。如果度约束相对较小，即小于或等于递归的阶数，则使用未知系数法。这将得到一个带有\(N+1\)未知数的代数方程组。
- en: In the other case, the algorithm performs transformation of the initial equation
    to an equivalent one for which the system of algebraic equations has only \(r\)
    indeterminates. This method is quite sophisticated (in comparison with the naive
    one) and was invented together by Abramov, Bronstein and Petkovsek.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种情况下，算法将初始方程转化为等价的方程，使得代数方程组仅有\(r\)个不定元。这种方法相对于朴素方法更为复杂，并由Abramov、Bronstein和Petkovsek共同发明。
- en: It is possible to generalize the algorithm implemented here to the case of linear
    q-difference and differential equations.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将此处实现的算法推广到线性\(q\)-差分和微分方程的情况。
- en: 'Lets say that we would like to compute \(m\)-th Bernoulli polynomial up to
    a constant. For this we can use \(b(n+1) - b(n) = m n^{m-1}\) recurrence, which
    has solution \(b(n) = B_m + C\). For example:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想计算到常数的第\(m\)个伯努利多项式。为此，我们可以使用\(b(n+1) - b(n) = m n^{m-1}\)的递推关系，其解为\(b(n)
    = B_m + C\)。例如：
- en: '[PRE87]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: References
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R890](#id1)]'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R890](#id1)]'
- en: 'S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial solutions of linear
    operator equations, in: T. Levelt, ed., Proc. ISSAC ‘95, ACM Press, New York,
    1995, 290-296.'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: S. A. Abramov, M. Bronstein 和 M. Petkovsek，关于线性算子方程的多项式解，见：T. Levelt，编，Proc.
    ISSAC ‘95，ACM Press，New York，1995，290-296。
- en: '[[R891](#id2)]'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R891](#id2)]'
- en: M. Petkovsek, Hypergeometric solutions of linear recurrences with polynomial
    coefficients, J. Symbolic Computation, 14 (1992), 243-264.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: M. Petkovsek，具有多项式系数的线性递推的超几何解，J. Symbolic Computation，14 (1992)，243-264。
- en: '[[R892](#id3)]'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R892](#id3)]'
- en: Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Petkovsek, H. S. Wilf, D. Zeilberger，A = B，1996。
- en: '[PRE89]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Given linear recurrence operator \(\operatorname{L}\) of order \(k\) with polynomial
    coefficients and inhomogeneous equation \(\operatorname{L} y = f\), where \(f\)
    is a polynomial, we seek for all rational solutions over field \(K\) of characteristic
    zero.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 给定具有多项式系数的阶为\(k\)的线性递推算子\(\operatorname{L}\)和非齐次方程\(\operatorname{L} y = f\)，其中\(f\)是多项式，我们寻求特征零域\(K\)上所有有理解。
- en: This procedure accepts only polynomials, however if you are interested in solving
    recurrence with rational coefficients then use `rsolve` which will pre-process
    the given equation and run this procedure with polynomial arguments.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程仅接受多项式，但如果您有兴趣解决有理系数的递推，则使用`rsolve`，它将预处理给定的方程并使用多项式参数运行此过程。
- en: 'The algorithm performs two basic steps:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 此算法执行两个基本步骤：
- en: Compute polynomial \(v(n)\) which can be used as universal denominator of any
    rational solution of equation \(\operatorname{L} y = f\).
  id: totrans-403
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算可以作为方程\(\operatorname{L} y = f\)任何有理解的通用分母的多项式\(v(n)\)。
- en: ''
  id: totrans-404
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-405
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Construct new linear difference equation by substitution \(y(n) = u(n)/v(n)\)
    and solve it for \(u(n)\) finding all its polynomial solutions. Return `None`
    if none were found.
  id: totrans-406
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过替换\(y(n) = u(n)/v(n)\)构造新的线性差分方程，并解出\(u(n)\)找到其所有的多项式解。如果找不到任何解，则返回`None`。
- en: The algorithm implemented here is a revised version of the original Abramov’s
    algorithm, developed in 1989\. The new approach is much simpler to implement and
    has better overall efficiency. This method can be easily adapted to the q-difference
    equations case.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 此处实现的算法是原始Abramov算法的修订版，于1989年开发。新方法实现更简单，整体效率更佳。此方法可以轻松地适应\(q\)-差分方程的情况。
- en: Besides finding rational solutions alone, this functions is an important part
    of Hyper algorithm where it is used to find a particular solution for the inhomogeneous
    part of a recurrence.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单独找到有理解外，此函数还是Hyper算法的重要部分，用于寻找递推的非齐次部分的特解。
- en: Examples
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE90]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: See also
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`rsolve_hyper`](#sympy.solvers.recurr.rsolve_hyper "sympy.solvers.recurr.rsolve_hyper")'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '[`rsolve_hyper`](#sympy.solvers.recurr.rsolve_hyper "sympy.solvers.recurr.rsolve_hyper")'
- en: References
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R893](#id4)]'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R893](#id4)]'
- en: 'S. A. Abramov, Rational solutions of linear difference and q-difference equations
    with polynomial coefficients, in: T. Levelt, ed., Proc. ISSAC ‘95, ACM Press,
    New York, 1995, 285-289'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: S. A. Abramov，具有多项式系数的线性差分和\(q\)-差分方程的有理解，见：T. Levelt，编，Proc. ISSAC ‘95，ACM
    Press，New York，1995，285-289。
- en: '[PRE91]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Given linear recurrence operator \(\operatorname{L}\) of order \(k\) with polynomial
    coefficients and inhomogeneous equation \(\operatorname{L} y = f\) we seek for
    all hypergeometric solutions over field \(K\) of characteristic zero.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 给定具有多项式系数的阶为\(k\)的线性递推算子\(\operatorname{L}\)和非齐次方程\(\operatorname{L} y = f\)，我们寻求所有特征零域\(K\)上的超几何解。
- en: The inhomogeneous part can be either hypergeometric or a sum of a fixed number
    of pairwise dissimilar hypergeometric terms.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 不齐次部分可以是超几何的，也可以是一组固定数量的两两不相似超几何项的总和。
- en: 'The algorithm performs three basic steps:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法执行三个基本步骤：
- en: Group together similar hypergeometric terms in the inhomogeneous part of \(\operatorname{L}
    y = f\), and find particular solution using Abramov’s algorithm.
  id: totrans-420
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 \(\operatorname{L} y = f\) 不齐次部分中类似的超几何项分组，并使用 Abramov 算法找到特解。
- en: ''
  id: totrans-421
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-422
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute generating set of \(\operatorname{L}\) and find basis in it, so that
    all solutions are linearly independent.
  id: totrans-423
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算 \(\operatorname{L}\) 的生成集并找到其基础，以便所有解线性无关。
- en: ''
  id: totrans-424
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-425
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Form final solution with the number of arbitrary constants equal to dimension
    of basis of \(\operatorname{L}\).
  id: totrans-426
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用与 \(\operatorname{L}\) 基础维数相等的任意常数形成最终解。
- en: Term \(a(n)\) is hypergeometric if it is annihilated by first order linear difference
    equations with polynomial coefficients or, in simpler words, if consecutive term
    ratio is a rational function.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 a(n) 由具有多项式系数的一阶线性差分方程消灭，或者更简单地说，如果连续项比是有理函数，则其为超几何项。
- en: The output of this procedure is a linear combination of fixed number of hypergeometric
    terms. However the underlying method can generate larger class of solutions -
    D’Alembertian terms.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 此过程的输出是固定数量的超几何项的线性组合。但是，底层方法可以生成更大类别的解 - D’Alembert项。
- en: Note also that this method not only computes the kernel of the inhomogeneous
    equation, but also reduces in to a basis so that solutions generated by this procedure
    are linearly independent
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此方法不仅计算不齐次方程的核，还将其缩减为基础，以便通过此过程生成的解决方案是线性无关的。
- en: Examples
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE92]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: References
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: '[[R894](#id5)]'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R894](#id5)]'
- en: M. Petkovsek, Hypergeometric solutions of linear recurrences with polynomial
    coefficients, J. Symbolic Computation, 14 (1992), 243-264.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: M. Petkovsek，带有多项式系数的线性递推超几何解，J. Symbolic Computation，14 (1992)，243-264。
- en: '[[R895](#id6)]'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[[R895](#id6)]'
- en: Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Petkovsek，H. S. Wilf，D. Zeilberger，A = B，1996。
- en: Systems of Polynomial Equations
  id: totrans-439
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多项式方程组
- en: '[PRE95]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Return a list of solutions for the system of polynomial equations or else None.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 返回多项式方程组的解列表，否则返回 None。
- en: 'Parameters:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**seq: a list/tuple/set**'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '**seq: 列表/元组/集合**'
- en: Listing all the equations that are needed to be solved
  id: totrans-444
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列出需要解决的所有方程
- en: '**gens: generators**'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**gens: 生成器**'
- en: generators of the equations in seq for which we want the solutions
  id: totrans-446
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: seq 的方程的生成器，我们希望得到解的生成器
- en: '**strict: a boolean (default is False)**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**strict: 布尔值（默认为False）**'
- en: if strict is True, NotImplementedError will be raised if the solution is known
    to be incomplete (which can occur if not all solutions are expressible in radicals)
  id: totrans-448
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果 strict 为 True，则在已知解决方案可能不完整时会引发 NotImplementedError（这可能发生在不能用根式表示所有解的情况下）
- en: '**args: Keyword arguments**'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '**args: 关键字参数**'
- en: Special options for solving the equations.
  id: totrans-450
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解方程的特殊选项。
- en: 'Returns:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: List[Tuple]
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: List[Tuple]
- en: a list of tuples with elements being solutions for the symbols in the order
    they were passed as gens
  id: totrans-453
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 元组列表，其中元素为按 gens 传递顺序解决方案的符号
- en: None
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 无
- en: None is returned when the computed basis contains only the ground.
  id: totrans-455
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 当计算的基础仅包含地面时返回 None。
- en: Examples
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE96]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Solve a polynomial system using Gianni-Kalkbrenner algorithm.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Gianni-Kalkbrenner 算法解多项式系统。
- en: The algorithm proceeds by computing one Groebner basis in the ground domain
    and then by iteratively computing polynomial factorizations in appropriately constructed
    algebraic extensions of the ground domain.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法通过在地面域中计算一个Groebner基础，然后通过在地面域的适当构造的代数扩展中迭代地计算多项式因式来进行。
- en: 'Parameters:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**polys: a list/tuple/set**'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '**polys: 列表/元组/集合**'
- en: Listing all the equations that are needed to be solved
  id: totrans-465
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 列出需要解决的所有方程
- en: '**gens: generators**'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '**gens: 生成器**'
- en: generators of the equations in polys for which we want the solutions
  id: totrans-467
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: polys 中我们想要解的方程的生成器
- en: '**args: Keyword arguments**'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**args: 关键字参数**'
- en: Special options for solving the equations
  id: totrans-469
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 解方程的特殊选项
- en: 'Returns:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 返回：
- en: List[Tuple]
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: List[Tuple]
- en: A List of tuples. Solutions for symbols that satisfy the equations listed in
    polys
  id: totrans-472
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 元组列表。满足 polys 中列出方程的符号的解决方案
- en: Examples
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE100]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: References
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 参考文献
- en: 1\. Patrizia Gianni, Teo Mora, Algebraic Solution of System of Polynomial Equations
    using Groebner Bases, AAECC-5 on Applied Algebra, Algebraic Algorithms and Error-Correcting
    Codes, LNCS 356 247–257, 1989
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. Patrizia Gianni，Teo Mora，使用Groebner基础代数解多项式方程组，应用代数，代数算法和纠错编码的AAECC-5，LNCS
    356 247–257，1989
- en: Diophantine Equations (DEs)
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 丢番图方程（DEs）
- en: See [Diophantine](diophantine.html#diophantine-docs)
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[丢番图方程](diophantine.html#diophantine-docs)
- en: Inequalities
  id: totrans-481
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不等式
- en: See [Inequality Solvers](inequalities.html#inequality-docs)
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[不等式求解器](inequalities.html#inequality-docs)
- en: '## Linear Programming (Optimization)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '## 线性规划（优化）'
- en: '[PRE103]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: return maximum of linear equation `f` under linear constraints expressed using
    Ge, Le or Eq.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 返回线性方程`f`在使用Ge、Le或Eq表达的线性约束下的最大值。
- en: All variables are unbounded unless constrained.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量都是未约束的，除非受到约束。
- en: Examples
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE104]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'Negative values for variables are permitted unless explicitly exluding:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的负值是允许的，除非明确排除：
- en: '[PRE105]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'If a non-negative constraint is added for x, there is no possible solution:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为`x`添加了非负约束，则没有可能的解决方案：
- en: '[PRE106]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: See also
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`linprog`](#sympy.solvers.simplex.linprog "sympy.solvers.simplex.linprog"),
    [`lpmin`](#sympy.solvers.simplex.lpmin "sympy.solvers.simplex.lpmin")'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[`linprog`](#sympy.solvers.simplex.linprog "sympy.solvers.simplex.linprog"),
    [`lpmin`](#sympy.solvers.simplex.lpmin "sympy.solvers.simplex.lpmin")'
- en: '[PRE107]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: return minimum of linear equation `f` under linear constraints expressed using
    Ge, Le or Eq.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 返回在使用Ge、Le或Eq表达的线性约束下的线性方程`f`的最小值。
- en: All variables are unbounded unless constrained.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量都是未约束的，除非受到约束。
- en: Examples
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE108]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Negative values for variables are permitted unless explicitly exluding, so
    minimizing `x` for `x <= 3` is an unbounded problem while the following has a
    bounded solution:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 变量的负值是允许的，除非明确排除，因此最小化`x`对于`x <= 3`是一个无约束问题，而以下问题有一个有界解：
- en: '[PRE109]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Without indicating that `x` is nonnegative, there is no minimum for this objective:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指明`x`是非负的，这个目标没有最小值：
- en: '[PRE110]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: See also
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`linprog`](#sympy.solvers.simplex.linprog "sympy.solvers.simplex.linprog"),
    [`lpmax`](#sympy.solvers.simplex.lpmax "sympy.solvers.simplex.lpmax")'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '[`linprog`](#sympy.solvers.simplex.linprog "sympy.solvers.simplex.linprog"),
    [`lpmax`](#sympy.solvers.simplex.lpmax "sympy.solvers.simplex.lpmax")'
- en: '[PRE111]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Return the minimization of `c*x` with the given constraints `A*x <= b` and `A_eq*x
    = b_eq`. Unless bounds are given, variables will have nonnegative values in the
    solution.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 返回在给定约束`A*x <= b`和`A_eq*x = b_eq`下`c*x`的最小化值。除非给出边界，否则变量在解中将具有非负值。
- en: If `A` is not given, then the dimension of the system will be determined by
    the length of `C`.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有给出`A`，那么系统的维度将由`C`的长度确定。
- en: 'By default, all variables will be nonnegative. If `bounds` is given as a single
    tuple, `(lo, hi)`, then all variables will be constrained to be between `lo` and
    `hi`. Use None for a `lo` or `hi` if it is unconstrained in the negative or positive
    direction, respectively, e.g. `(None, 0)` indicates nonpositive values. To set
    individual ranges, pass a list with length equal to the number of columns in `A`,
    each element being a tuple; if only a few variables take on non-default values
    they can be passed as a dictionary with keys giving the corresponding column to
    which the variable is assigned, e.g. `bounds={2: (1, 4)}` would limit the 3rd
    variable to have a value in range `[1, 4]`.'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，所有变量都将是非负的。如果`bounds`作为单个元组`(lo, hi)`给出，则所有变量将被限制在`lo`和`hi`之间。使用None表示`lo`或`hi`在负或正方向上没有约束，例如`(None,
    0)`表示非正值。要设置单个范围，传递一个长度等于`A`列数的列表，每个元素都是一个元组；如果只有少数变量取非默认值，则可以作为字典传递，键给出相应分配变量的列，例如`bounds={2:
    (1, 4)}`将限制第三个变量的值在`[1, 4]`范围内。'
- en: Examples
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE112]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: See also
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[`lpmin`](#sympy.solvers.simplex.lpmin "sympy.solvers.simplex.lpmin"), [`lpmax`](#sympy.solvers.simplex.lpmax
    "sympy.solvers.simplex.lpmax")'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '[`lpmin`](#sympy.solvers.simplex.lpmin "sympy.solvers.simplex.lpmin"), [`lpmax`](#sympy.solvers.simplex.lpmax
    "sympy.solvers.simplex.lpmax")'
