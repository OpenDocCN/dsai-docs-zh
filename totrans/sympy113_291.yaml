- en: Number Fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/polys/numberfields.html](https://docs.sympy.org/latest/modules/polys/numberfields.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Introduction'
  prefs: []
  type: TYPE_NORMAL
- en: Like many other computations in algebraic number theory, the splitting of rational
    primes can be treated by *rational* methods only. This fact is very important
    if computation by automatic computing machinery is considered. Only the knowledge
    of the irreducible polynomial \(f(x)\), a zero of which generates the field in
    question, is needed.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —Olga Taussky, 1953
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Concepts like number fields and algebraic numbers are essential to our understanding
    of algebraic number theory, but to the computer the subject is all about polynomials:
    the ring \(\mathbb{Q}[x]\) reduced modulo irreducible polynomials \(f(x) \in \mathbb{Q}[x]\).
    It thus finds a natural home under the [`polys`](reference.html#module-sympy.polys
    "sympy.polys") module in SymPy.'
  prefs: []
  type: TYPE_NORMAL
- en: Various authors (such as Taussky, Zimmer, Pohst and Zassenhaus, or Cohen) have
    articulated the main goals of computational algebraic number theory in different
    ways, but invariably the list centers around a certain essential set of tasks.
    As a goal for the `numberfields` module in SymPy, we may set the following list,
    based on [[Cohen93]](literature.html#cohen93), Sec. 4.9.3.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a number field \(K = \mathbb{Q}(\theta)\), whose ring of algebraic integers
    is denoted \(\mathbb{Z}_K\), compute:'
  prefs: []
  type: TYPE_NORMAL
- en: an integral basis of \(\mathbb{Z}_K\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the decomposition of rational primes in \(\mathbb{Z}_K\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: \(\mathfrak{p}\)-adic valuations for ideals and elements
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the Galois group of the Galois closure of \(K\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a system of fundamental units of \(K\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the regulator \(R(K)\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the class number
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: the structure of the class group \(Cl(K)\)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: decide whether a given ideal is principal, and if so compute a generator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a foundation, and to support our basic ability to define and work with number
    fields and algebraic numbers, we also set the following problems, following [[Cohen93]](literature.html#cohen93),
    Sec. 4.5.
  prefs: []
  type: TYPE_NORMAL
- en: Given an algebraic number – expressed by radicals and rational operations, or
    even as a special value of a transcendental function – determine its minimal polynomial
    over \(\mathbb{Q}\).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Subfield Problem: Given two number fields \(\mathbb{Q}(\alpha)\), \(\mathbb{Q}(\beta)\)
    via the minimal polynomials for their generators \(\alpha\) and \(\beta\), decide
    whether one field is isomorphic to a subfield of the other, and if so exhibit
    an embedding.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Field Membership Problem: Given two algebraic numbers \(\alpha\), \(\beta\),
    decide whether \(\alpha \in \mathbb{Q}(\beta)\), and if so write \(\alpha = f(\beta)\)
    for some \(f(x) \in \mathbb{Q}[x]\).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Primitive Element Problem: Given several algebraic numbers \(\alpha_1,
    \ldots, \alpha_m\), compute a single algebraic number \(\theta\) such that \(\mathbb{Q}(\alpha_1,
    \ldots, \alpha_m) = \mathbb{Q}(\theta)\).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At present only a subset of the tasks enumerated above is yet supported in SymPy,
    and if you are interested in expanding support, you are encouraged to contribute!
    An excellent source, providing solutions to all the remaining problems (as well
    as those already solved) is [[Cohen93]](literature.html#cohen93).
  prefs: []
  type: TYPE_NORMAL
- en: 'At time of writing, the existing solutions to the above problems are found
    in the following places:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Task | Implementation |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: integral basis
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| [`round_two()`](#sympy.polys.numberfields.basis.round_two "sympy.polys.numberfields.basis.round_two")
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: prime decomposition
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| [`prime_decomp()`](#sympy.polys.numberfields.primes.prime_decomp "sympy.polys.numberfields.primes.prime_decomp")
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: \(\mathfrak{p}\)-adic valuation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| [`prime_valuation()`](#sympy.polys.numberfields.primes.prime_valuation "sympy.polys.numberfields.primes.prime_valuation")
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Galois group
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| [`galois_group()`](#sympy.polys.numberfields.galoisgroups.galois_group "sympy.polys.numberfields.galoisgroups.galois_group")
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: find minimal polynomial
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| [`minimal_polynomial()`](#sympy.polys.numberfields.minpoly.minimal_polynomial
    "sympy.polys.numberfields.minpoly.minimal_polynomial") |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: subfield
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| [`field_isomorphism()`](#sympy.polys.numberfields.subfield.field_isomorphism
    "sympy.polys.numberfields.subfield.field_isomorphism") |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: field membership
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| [`to_number_field()`](#sympy.polys.numberfields.subfield.to_number_field
    "sympy.polys.numberfields.subfield.to_number_field") |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: primitive element
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '| [`primitive_element()`](#sympy.polys.numberfields.subfield.primitive_element
    "sympy.polys.numberfields.subfield.primitive_element") |'
  prefs: []
  type: TYPE_TB
- en: Solving the Main Problems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integral Basis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Zassenhaus’s “Round 2” algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**T** : [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly"),
    [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField "sympy.polys.domains.AlgebraicField")'
  prefs: []
  type: TYPE_NORMAL
- en: Either (1) the irreducible polynomial over [ZZ](domainsref.html#zz) or [QQ](domainsref.html#qq)
    defining the number field, or (2) an [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") representing the number field itself.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**radicals** : dict, optional'
  prefs: []
  type: TYPE_NORMAL
- en: This is a way for any \(p\)-radicals (if computed) to be returned by reference.
    If desired, pass an empty dictionary. If the algorithm reaches the point where
    it computes the nilradical mod \(p\) of the ring of integers \(Z_K\), then an
    \(\mathbb{F}_p\)-basis for this ideal will be stored in this dictionary under
    the key `p`. This can be useful for other algorithms, such as prime decomposition.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pair `(ZK, dK)`, where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ZK` is a [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    representing the maximal order.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`dK` is the discriminant of the field \(K = \mathbb{Q}[x]/(T(x))\).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Carry out Zassenhaus’s “Round 2” algorithm on an irreducible polynomial *T*
    over [ZZ](domainsref.html#zz) or [QQ](domainsref.html#qq). This computes an integral
    basis and the discriminant for the field \(K = \mathbb{Q}[x]/(T(x))\).
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you may pass an [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") instance, in place of the polynomial *T*,
    in which case the algorithm is applied to the minimal polynomial for the field’s
    primitive element.
  prefs: []
  type: TYPE_NORMAL
- en: Ordinarily this function need not be called directly, as one can instead access
    the [`maximal_order()`](domainsref.html#sympy.polys.domains.AlgebraicField.maximal_order
    "sympy.polys.domains.AlgebraicField.maximal_order"), [`integral_basis()`](domainsref.html#sympy.polys.domains.AlgebraicField.integral_basis
    "sympy.polys.domains.AlgebraicField.integral_basis"), and [`discriminant()`](domainsref.html#sympy.polys.domains.AlgebraicField.discriminant
    "sympy.polys.domains.AlgebraicField.discriminant") methods of an [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Working through an AlgebraicField:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The nilradicals mod \(p\) that are sometimes computed during the Round Two
    algorithm may be useful in further calculations. Pass a dictionary under \(radicals\)
    to receive these:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`AlgebraicField.maximal_order`](domainsref.html#sympy.polys.domains.AlgebraicField.maximal_order
    "sympy.polys.domains.AlgebraicField.maximal_order"), [`AlgebraicField.integral_basis`](domainsref.html#sympy.polys.domains.AlgebraicField.integral_basis
    "sympy.polys.domains.AlgebraicField.integral_basis"), [`AlgebraicField.discriminant`](domainsref.html#sympy.polys.domains.AlgebraicField.discriminant
    "sympy.polys.domains.AlgebraicField.discriminant")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R802](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: Cohen, H. *A Course in Computational Algebraic Number Theory.*
  prefs: []
  type: TYPE_NORMAL
- en: Prime Decomposition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Compute the decomposition of rational prime *p* in a number field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**p** : int'
  prefs: []
  type: TYPE_NORMAL
- en: The rational prime whose decomposition is desired.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**T** : [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly"),
    optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Monic irreducible polynomial defining the number field \(K\) in which to factor.
    NOTE: at least one of *T* or *ZK* must be provided.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ZK** : [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule"),
    optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'The maximal order for \(K\), if already known. NOTE: at least one of *T* or
    *ZK* must be provided.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**dK** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The discriminant of the field \(K\), if already known.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**radical** : [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule"),
    optional'
  prefs: []
  type: TYPE_NORMAL
- en: The nilradical mod *p* in the integers of \(K\), if already known.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: List of [`PrimeIdeal`](#sympy.polys.numberfields.primes.PrimeIdeal "sympy.polys.numberfields.primes.PrimeIdeal")
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Ordinarily this should be accessed through the [`primes_above()`](domainsref.html#sympy.polys.domains.AlgebraicField.primes_above
    "sympy.polys.domains.AlgebraicField.primes_above") method of an [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R803](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: Cohen, H. *A Course in Computational Algebraic Number Theory.* (See Algorithm
    6.2.9.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: A prime ideal in a ring of algebraic integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ZK** : [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: The maximal order where this ideal lives.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**p** : int'
  prefs: []
  type: TYPE_NORMAL
- en: The rational prime this ideal divides.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**alpha** : [`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement
    "sympy.polys.numberfields.modules.PowerBasisElement")'
  prefs: []
  type: TYPE_NORMAL
- en: Such that the ideal is equal to `p*ZK + alpha*ZK`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**f** : int'
  prefs: []
  type: TYPE_NORMAL
- en: The inertia degree.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**e** : int, `None`, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The ramification index, if already known. If `None`, we will compute it here.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Convert to a [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    and add to another [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_submodule`](#sympy.polys.numberfields.primes.PrimeIdeal.as_submodule "sympy.polys.numberfields.primes.PrimeIdeal.as_submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Convert to a [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    and multiply by another [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule") or a rational number.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_submodule`](#sympy.polys.numberfields.primes.PrimeIdeal.as_submodule "sympy.polys.numberfields.primes.PrimeIdeal.as_submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Represent this prime ideal as a [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule").
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: Will be equal to `self.p * self.ZK + self.alpha * self.ZK`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The [`PrimeIdeal`](#sympy.polys.numberfields.primes.PrimeIdeal "sympy.polys.numberfields.primes.PrimeIdeal")
    class serves to bundle information about a prime ideal, such as its inertia degree,
    ramification index, and two-generator representation, as well as to offer helpful
    methods like [`valuation()`](#sympy.polys.numberfields.primes.PrimeIdeal.valuation
    "sympy.polys.numberfields.primes.PrimeIdeal.valuation") and [`test_factor()`](#sympy.polys.numberfields.primes.PrimeIdeal.test_factor
    "sympy.polys.numberfields.primes.PrimeIdeal.test_factor").
  prefs: []
  type: TYPE_NORMAL
- en: However, in order to be added and multiplied by other ideals or rational numbers,
    it must first be converted into a [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule"), which is a class that supports
    these operations.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, the user need not perform this conversion deliberately, since
    it is automatically performed by the arithmetic operator methods [`__add__()`](#sympy.polys.numberfields.primes.PrimeIdeal.__add__
    "sympy.polys.numberfields.primes.PrimeIdeal.__add__") and [`__mul__()`](#sympy.polys.numberfields.primes.PrimeIdeal.__mul__
    "sympy.polys.numberfields.primes.PrimeIdeal.__mul__").
  prefs: []
  type: TYPE_NORMAL
- en: Raising a [`PrimeIdeal`](#sympy.polys.numberfields.primes.PrimeIdeal "sympy.polys.numberfields.primes.PrimeIdeal")
    to a non-negative integer power is also supported.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that, on both sides of the equation above, we had a [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule"). In the next equation we recall
    that adding ideals yields their GCD. This time, we need a deliberate conversion
    to [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    on the right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`__add__`](#sympy.polys.numberfields.primes.PrimeIdeal.__add__ "sympy.polys.numberfields.primes.PrimeIdeal.__add__"),
    [`__mul__`](#sympy.polys.numberfields.primes.PrimeIdeal.__mul__ "sympy.polys.numberfields.primes.PrimeIdeal.__mul__")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Say whether the rational prime we divide is inert, i.e. stays prime in our ring
    of integers.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Reduce an [`ANP`](domainsref.html#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")
    to a “small representative” modulo this prime ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**elt** : [`ANP`](domainsref.html#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")'
  prefs: []
  type: TYPE_NORMAL
- en: The element to be reduced.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ANP`](domainsref.html#sympy.polys.polyclasses.ANP "sympy.polys.polyclasses.ANP")'
  prefs: []
  type: TYPE_NORMAL
- en: The reduced element.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`reduce_element`](#sympy.polys.numberfields.primes.PrimeIdeal.reduce_element
    "sympy.polys.numberfields.primes.PrimeIdeal.reduce_element"), [`reduce_alg_num`](#sympy.polys.numberfields.primes.PrimeIdeal.reduce_alg_num
    "sympy.polys.numberfields.primes.PrimeIdeal.reduce_alg_num"), [`Submodule.reduce_element`](#sympy.polys.numberfields.modules.Submodule.reduce_element
    "sympy.polys.numberfields.modules.Submodule.reduce_element")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Reduce an [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber") to a “small representative” modulo this
    prime ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**elt** : [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber")'
  prefs: []
  type: TYPE_NORMAL
- en: The element to be reduced.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")'
  prefs: []
  type: TYPE_NORMAL
- en: The reduced element.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`reduce_element`](#sympy.polys.numberfields.primes.PrimeIdeal.reduce_element
    "sympy.polys.numberfields.primes.PrimeIdeal.reduce_element"), [`reduce_ANP`](#sympy.polys.numberfields.primes.PrimeIdeal.reduce_ANP
    "sympy.polys.numberfields.primes.PrimeIdeal.reduce_ANP"), [`Submodule.reduce_element`](#sympy.polys.numberfields.modules.Submodule.reduce_element
    "sympy.polys.numberfields.modules.Submodule.reduce_element")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Reduce a [`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement
    "sympy.polys.numberfields.modules.PowerBasisElement") to a “small representative”
    modulo this prime ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**elt** : [`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement
    "sympy.polys.numberfields.modules.PowerBasisElement")'
  prefs: []
  type: TYPE_NORMAL
- en: The element to be reduced.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement "sympy.polys.numberfields.modules.PowerBasisElement")'
  prefs: []
  type: TYPE_NORMAL
- en: The reduced element.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`reduce_ANP`](#sympy.polys.numberfields.primes.PrimeIdeal.reduce_ANP "sympy.polys.numberfields.primes.PrimeIdeal.reduce_ANP"),
    [`reduce_alg_num`](#sympy.polys.numberfields.primes.PrimeIdeal.reduce_alg_num
    "sympy.polys.numberfields.primes.PrimeIdeal.reduce_alg_num"), [`Submodule.reduce_element`](#sympy.polys.numberfields.modules.Submodule.reduce_element
    "sympy.polys.numberfields.modules.Submodule.reduce_element")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Print a representation of this prime ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**field_gen** : [`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol"),
    `None`, optional (default=None)'
  prefs: []
  type: TYPE_NORMAL
- en: The symbol to use for the generator of the field. This will appear in our representation
    of `self.alpha`. If `None`, we use the variable of the defining polynomial of
    `self.ZK`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**just_gens** : bool, optional (default=False)'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, just print the “(p, alpha)” part, showing “just the generators” of
    the prime ideal. Otherwise, print a string of the form “[ (p, alpha) e=…, f=…
    ]”, giving the ramification index and inertia degree, along with the generators.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Compute a test factor for this prime ideal.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Write \(\mathfrak{p}\) for this prime ideal, \(p\) for the rational prime it
    divides. Then, for computing \(\mathfrak{p}\)-adic valuations it is useful to
    have a number \(\beta \in \mathbb{Z}_K\) such that \(p/\mathfrak{p} = p \mathbb{Z}_K
    + \beta \mathbb{Z}_K\).
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, this is the same as the number \(\Psi\) (or the “reagent”) from
    Kummer’s 1847 paper (*Ueber die Zerlegung…*, Crelle vol. 35) in which ideal divisors
    were invented.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Compute the \(\mathfrak{p}\)-adic valuation of integral ideal I at this prime
    ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**I** : [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`prime_valuation`](#sympy.polys.numberfields.primes.prime_valuation "sympy.polys.numberfields.primes.prime_valuation")'
  prefs: []
  type: TYPE_NORMAL
- en: p-adic Valuation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Compute the *P*-adic valuation for an integral ideal *I*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**I** : [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: An integral ideal whose valuation is desired.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**P** : [`PrimeIdeal`](#sympy.polys.numberfields.primes.PrimeIdeal "sympy.polys.numberfields.primes.PrimeIdeal")'
  prefs: []
  type: TYPE_NORMAL
- en: The prime at which to compute the valuation.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`PrimeIdeal.valuation`](#sympy.polys.numberfields.primes.PrimeIdeal.valuation
    "sympy.polys.numberfields.primes.PrimeIdeal.valuation")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R804](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: Cohen, H. *A Course in Computational Algebraic Number Theory.* (See Algorithm
    4.8.17.)
  prefs: []
  type: TYPE_NORMAL
- en: Galois Groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Compute the Galois group for polynomials *f* up to degree 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: Irreducible polynomial over [ZZ](domainsref.html#zz) or [QQ](domainsref.html#qq),
    whose Galois group is to be determined.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**gens** : optional list of symbols'
  prefs: []
  type: TYPE_NORMAL
- en: For converting *f* to Poly, and will be passed on to the [`poly_from_expr()`](reference.html#sympy.polys.polytools.poly_from_expr
    "sympy.polys.polytools.poly_from_expr") function.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**by_name** : bool, default False'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, the Galois group will be returned by name. Otherwise it will be returned
    as a [`PermutationGroup`](../combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup
    "sympy.combinatorics.perm_groups.PermutationGroup").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**max_tries** : int, default 30'
  prefs: []
  type: TYPE_NORMAL
- en: Make at most this many attempts in those steps that involve generating Tschirnhausen
    transformations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**randomize** : bool, default False'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, then use random coefficients when generating Tschirnhausen transformations.
    Otherwise try transformations in a fixed order. Both approaches start with small
    coefficients and degrees and work upward.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**args** : optional'
  prefs: []
  type: TYPE_NORMAL
- en: For converting *f* to Poly, and will be passed on to the [`poly_from_expr()`](reference.html#sympy.polys.polytools.poly_from_expr
    "sympy.polys.polytools.poly_from_expr") function.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Pair `(G, alt)`
  prefs: []
  type: TYPE_NORMAL
- en: The first element `G` indicates the Galois group. It is an instance of one of
    the [`sympy.combinatorics.galois.S1TransitiveSubgroups`](../combinatorics/galois.html#sympy.combinatorics.galois.S1TransitiveSubgroups
    "sympy.combinatorics.galois.S1TransitiveSubgroups") [`sympy.combinatorics.galois.S2TransitiveSubgroups`](../combinatorics/galois.html#sympy.combinatorics.galois.S2TransitiveSubgroups
    "sympy.combinatorics.galois.S2TransitiveSubgroups"), etc. enum classes if *by_name*
    was `True`, and a [`PermutationGroup`](../combinatorics/perm_groups.html#sympy.combinatorics.perm_groups.PermutationGroup
    "sympy.combinatorics.perm_groups.PermutationGroup") if `False`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The second element is a boolean, saying whether the group is contained in the
    alternating group \(A_n\) (\(n\) the degree of *T*).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: if *f* is of an unsupported degree.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**MaxTriesException**'
  prefs: []
  type: TYPE_NORMAL
- en: if could not complete before exceeding *max_tries* in those steps that involve
    generating Tschirnhausen transformations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The group is returned along with a boolean, indicating whether it is contained
    in the alternating group \(A_n\), where \(n\) is the degree of *T*. Along with
    other group properties, this can help determine which group it is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the group can be returned by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The group itself can then be obtained by calling the name’s `get_perm_group()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Group names are values of the enum classes [`sympy.combinatorics.galois.S1TransitiveSubgroups`](../combinatorics/galois.html#sympy.combinatorics.galois.S1TransitiveSubgroups
    "sympy.combinatorics.galois.S1TransitiveSubgroups"), [`sympy.combinatorics.galois.S2TransitiveSubgroups`](../combinatorics/galois.html#sympy.combinatorics.galois.S2TransitiveSubgroups
    "sympy.combinatorics.galois.S2TransitiveSubgroups"), etc.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Poly.galois_group`](reference.html#sympy.polys.polytools.Poly.galois_group
    "sympy.polys.polytools.Poly.galois_group")'
  prefs: []
  type: TYPE_NORMAL
- en: Finding Minimal Polynomials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Computes the minimal polynomial of an algebraic element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ex** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: Element or expression whose minimal polynomial is to be calculated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**x** : Symbol, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Independent variable of the minimal polynomial
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**compose** : boolean, optional (default=True)'
  prefs: []
  type: TYPE_NORMAL
- en: Method to use for computing minimal polynomial. If `compose=True` (default)
    then `_minpoly_compose` is used, if `compose=False` then groebner bases are used.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**polys** : boolean, optional (default=False)'
  prefs: []
  type: TYPE_NORMAL
- en: If `True` returns a `Poly` object else an `Expr` object.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**domain** : Domain, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Ground domain
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: By default `compose=True`, the minimal polynomial of the subexpressions of `ex`
    are computed, then the arithmetic operations on them are performed using the resultant
    and factorization. If `compose=False`, a bottom-up algorithm is used with `groebner`.
    The default algorithm stalls less frequently.
  prefs: []
  type: TYPE_NORMAL
- en: If no ground domain is given, it will be generated automatically from the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This is a synonym for [`minimal_polynomial()`](#sympy.polys.numberfields.minpoly.minimal_polynomial
    "sympy.polys.numberfields.minpoly.minimal_polynomial").
  prefs: []
  type: TYPE_NORMAL
- en: The Subfield Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Functions in `polys.numberfields.subfield` solve the “Subfield Problem” and
    allied problems, for algebraic number fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following Cohen (see [[Cohen93]](literature.html#cohen93) Section 4.5), we
    can define the main problem as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Subfield Problem:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given two number fields \(\mathbb{Q}(\alpha)\), \(\mathbb{Q}(\beta)\) via the
    minimal polynomials for their generators \(\alpha\) and \(\beta\), decide whether
    one field is isomorphic to a subfield of the other.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'From a solution to this problem flow solutions to the following problems as
    well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primitive Element Problem:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given several algebraic numbers \(\alpha_1, \ldots, \alpha_m\), compute a single
    algebraic number \(\theta\) such that \(\mathbb{Q}(\alpha_1, \ldots, \alpha_m)
    = \mathbb{Q}(\theta)\).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Field Isomorphism Problem:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decide whether two number fields \(\mathbb{Q}(\alpha)\), \(\mathbb{Q}(\beta)\)
    are isomorphic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Field Membership Problem:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given two algebraic numbers \(\alpha\), \(\beta\), decide whether \(\alpha \in
    \mathbb{Q}(\beta)\), and if so write \(\alpha = f(\beta)\) for some \(f(x) \in
    \mathbb{Q}[x]\).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Find an embedding of one number field into another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")'
  prefs: []
  type: TYPE_NORMAL
- en: Any expression representing an algebraic number.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**b** : [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")'
  prefs: []
  type: TYPE_NORMAL
- en: Any expression representing an algebraic number.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**fast** : boolean, optional (default=True)'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, we first attempt a potentially faster way of computing the isomorphism,
    falling back on a slower method if this fails. If `False`, we go directly to the
    slower method, which is guaranteed to return a result.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: List of rational numbers, or None
  prefs: []
  type: TYPE_NORMAL
- en: If \(\mathbb{Q}(a)\) is not isomorphic to some subfield of \(\mathbb{Q}(b)\),
    then return `None`. Otherwise, return a list of rational numbers representing
    an element of \(\mathbb{Q}(b)\) to which \(a\) may be mapped, in order to define
    a monomorphism, i.e. an isomorphism from \(\mathbb{Q}(a)\) to some subfield of
    \(\mathbb{Q}(b)\). The elements of the list are the coefficients of falling powers
    of \(b\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This function looks for an isomorphism from \(\mathbb{Q}(a)\) onto some subfield
    of \(\mathbb{Q}(b)\). Thus, it solves the Subfield Problem.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Find a single generator for a number field given by several generators.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**extension** : list of [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")'
  prefs: []
  type: TYPE_NORMAL
- en: Each expression must represent an algebraic number \(\alpha_i\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**x** : [`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol"),
    optional (default=None)'
  prefs: []
  type: TYPE_NORMAL
- en: The desired symbol to appear in the computed minimal polynomial for the primitive
    element \(\theta\). If `None`, we use a dummy symbol.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ex** : boolean, optional (default=False)'
  prefs: []
  type: TYPE_NORMAL
- en: If and only if `True`, compute the representation of each \(\alpha_i\) as a
    \(\mathbb{Q}\)-linear combination over the powers of \(\theta\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**polys** : boolean, optional (default=False)'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, return the minimal polynomial as a [`Poly`](reference.html#sympy.polys.polytools.Poly
    "sympy.polys.polytools.Poly"). Otherwise return it as an [`Expr`](../core.html#sympy.core.expr.Expr
    "sympy.core.expr.Expr").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pair (f, coeffs) or triple (f, coeffs, reps), where:'
  prefs: []
  type: TYPE_NORMAL
- en: '`f` is the minimal polynomial for the primitive element. `coeffs` gives the
    primitive element as a linear combination of the given generators. `reps` is present
    if and only if argument `ex=True` was passed, and is a list of lists of rational
    numbers. Each list gives the coefficients of falling powers of the primitive element,
    to recover one of the original, given generators.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic problem is this: Given several algebraic numbers \(\alpha_1, \alpha_2,
    \ldots, \alpha_n\), find a single algebraic number \(\theta\) such that \(\mathbb{Q}(\alpha_1,
    \alpha_2, \ldots, \alpha_n) = \mathbb{Q}(\theta)\).'
  prefs: []
  type: TYPE_NORMAL
- en: This function actually guarantees that \(\theta\) will be a linear combination
    of the \(\alpha_i\), with non-negative integer coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, if desired, this function will tell you how to express each \(\alpha_i\)
    as a \(\mathbb{Q}\)-linear combination of the powers of \(\theta\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Then `lincomb` tells us the primitive element as a linear combination of the
    given generators `sqrt(2)` and `sqrt(3)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This means the primtiive element is \(\sqrt{2} + \sqrt{3}\). Meanwhile `f` is
    the minimal polynomial for this primitive element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Finally, `reps` (which was returned only because we set keyword arg `ex=True`)
    tells us how to recover each of the generators \(\sqrt{2}\) and \(\sqrt{3}\) as
    \(\mathbb{Q}\)-linear combinations of the powers of the primitive element \(\sqrt{2}
    + \sqrt{3}\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Express one algebraic number in the field generated by another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**extension** : [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")
    or list of [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")'
  prefs: []
  type: TYPE_NORMAL
- en: Either the algebraic number that is to be expressed in the other field, or else
    a list of algebraic numbers, a primitive element for which is to be expressed
    in the other field.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**theta** : [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr"),
    None, optional (default=None)'
  prefs: []
  type: TYPE_NORMAL
- en: If an [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr") representing
    an algebraic number, behavior is as described under **Explanation**. If `None`,
    then this function reduces to a shorthand for calling [`primitive_element()`](#sympy.polys.numberfields.subfield.primitive_element
    "sympy.polys.numberfields.subfield.primitive_element") on `extension` and turning
    the computed primitive element into an [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**gen** : [`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol"),
    None, optional (default=None)'
  prefs: []
  type: TYPE_NORMAL
- en: If provided, this will be used as the generator symbol for the minimal polynomial
    in the returned [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**alias** : str, [`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol"),
    None, optional (default=None)'
  prefs: []
  type: TYPE_NORMAL
- en: If provided, this will be used as the alias symbol for the returned [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: AlgebraicNumber
  prefs: []
  type: TYPE_NORMAL
- en: Belonging to \(\mathbb{Q}(\theta)\) and equaling \(\eta\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IsomorphismFailed**'
  prefs: []
  type: TYPE_NORMAL
- en: If \(\eta \not\in \mathbb{Q}(\theta)\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Given two algebraic numbers \(\eta, \theta\), this function either expresses
    \(\eta\) as an element of \(\mathbb{Q}(\theta)\), or else raises an exception
    if \(\eta \not\in \mathbb{Q}(\theta)\).
  prefs: []
  type: TYPE_NORMAL
- en: This function is essentially just a convenience, utilizing [`field_isomorphism()`](#sympy.polys.numberfields.subfield.field_isomorphism
    "sympy.polys.numberfields.subfield.field_isomorphism") (our solution of the Subfield
    Problem) to solve this, the Field Membership Problem.
  prefs: []
  type: TYPE_NORMAL
- en: As an additional convenience, this function allows you to pass a list of algebraic
    numbers \(\alpha_1, \alpha_2, \ldots, \alpha_n\) instead of \(\eta\). It then
    computes \(\eta\) for you, as a solution of the Primitive Element Problem, using
    [`primitive_element()`](#sympy.polys.numberfields.subfield.primitive_element "sympy.polys.numberfields.subfield.primitive_element")
    on the list of \(\alpha_i\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We get an [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber"), whose `.root` is \(\theta\), whose value
    is \(\eta\), and whose `.coeffs()` show how to write \(\eta\) as a \(\mathbb{Q}\)-linear
    combination in falling powers of \(\theta\).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`field_isomorphism`](#sympy.polys.numberfields.subfield.field_isomorphism
    "sympy.polys.numberfields.subfield.field_isomorphism"), [`primitive_element`](#sympy.polys.numberfields.subfield.primitive_element
    "sympy.polys.numberfields.subfield.primitive_element")'
  prefs: []
  type: TYPE_NORMAL
- en: Internals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Algebraic number fields
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Algebraic number fields are represented in SymPy by the [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") class, which is a part of [the polynomial
    domains system](domainsref.html#polys-domainsref).
  prefs: []
  type: TYPE_NORMAL
- en: Representing algebraic numbers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several different ways to represent algebraic numbers, and different
    forms may be preferable for different computational tasks. See [[Cohen93]](literature.html#cohen93),
    Sec. 4.2.
  prefs: []
  type: TYPE_NORMAL
- en: As number field elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In SymPy, there is a distinction between number and expression classes defined
    in the [`sympy.core.numbers`](../core.html#module-sympy.core.numbers "sympy.core.numbers")
    module on the one hand, and domains and domain elements defined in the [`polys`](reference.html#module-sympy.polys
    "sympy.polys") module on the other. This is explained in more detail [here](domainsintro.html#polys-domainsintro).
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to algebraic numbers, the [`sympy.core.numbers`](../core.html#module-sympy.core.numbers
    "sympy.core.numbers") module offers the [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber") class, while the [`polys`](reference.html#module-sympy.polys
    "sympy.polys") module offers the [`ANP`](domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP") class. This is the type of domain elements belonging
    to the [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField "sympy.polys.domains.AlgebraicField")
    domain.
  prefs: []
  type: TYPE_NORMAL
- en: As elements of finitely-generated modules
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In computational algebraic number theory, finitely-generated \(\mathbb{Z}\)-modules
    are of central importance. For example, every [order](https://en.wikipedia.org/wiki/Order_(ring_theory))
    and every [ideal](https://en.wikipedia.org/wiki/Ideal_(ring_theory)) is such a
    module.
  prefs: []
  type: TYPE_NORMAL
- en: In particular, the maximal order – or [ring of integers](https://en.wikipedia.org/wiki/Ring_of_integers)
    – in a number field is a finitely-generated \(\mathbb{Z}\)-module, whose generators
    form an [integral basis](https://en.wikipedia.org/wiki/Algebraic_number_field#Integral_basis)
    for the field.
  prefs: []
  type: TYPE_NORMAL
- en: Classes allowing us to represent such modules, and their elements, are provided
    in the [`modules`](#module-sympy.polys.numberfields.modules "sympy.polys.numberfields.modules")
    module. Here, the [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") class provides another way to
    represent algebraic numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '### Finitely-generated modules'
  prefs: []
  type: TYPE_NORMAL
- en: Modules in number fields.
  prefs: []
  type: TYPE_NORMAL
- en: The classes defined here allow us to work with finitely generated, free modules,
    whose generators are algebraic numbers.
  prefs: []
  type: TYPE_NORMAL
- en: There is an abstract base class called [`Module`](#sympy.polys.numberfields.modules.Module
    "sympy.polys.numberfields.modules.Module"), which has two concrete subclasses,
    [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis "sympy.polys.numberfields.modules.PowerBasis")
    and [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule").
  prefs: []
  type: TYPE_NORMAL
- en: 'Every module is defined by its basis, or set of generators:'
  prefs: []
  type: TYPE_NORMAL
- en: For a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis "sympy.polys.numberfields.modules.PowerBasis"),
    the generators are the first \(n\) powers (starting with the zeroth) of an algebraic
    integer \(\theta\) of degree \(n\). The [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") is constructed by passing either
    the minimal polynomial of \(\theta\), or an [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") having \(\theta\) as its primitive element.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule"),
    the generators are a set of \(\mathbb{Q}\)-linear combinations of the generators
    of another module. That other module is then the “parent” of the [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule"). The coefficients of the \(\mathbb{Q}\)-linear
    combinations may be given by an integer matrix, and a positive integer denominator.
    Each column of the matrix defines a generator.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Thus, every module is either a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis"), or a [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule"), some ancestor of which is a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis"). (If `S` is a [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule"), then its ancestors are `S.parent`,
    `S.parent.parent`, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    class represents a linear combination of the generators of any module. Critically,
    the coefficients of this linear combination are not restricted to be integers,
    but may be any rational numbers. This is necessary so that any and all algebraic
    integers be representable, starting from the power basis in a primitive element
    \(\theta\) for the number field in question. For example, in a quadratic field
    \(\mathbb{Q}(\sqrt{d})\) where \(d \equiv 1 \mod{4}\), a denominator of \(2\)
    is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    can be constructed from an integer column vector and a denominator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The [`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement
    "sympy.polys.numberfields.modules.PowerBasisElement") class is a subclass of [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") that represents elements of
    a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis "sympy.polys.numberfields.modules.PowerBasis"),
    and adds functionality pertinent to elements represented directly over powers
    of the primitive element \(\theta\).
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic with module elements
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: While a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    represents a linear combination over the generators of a particular module, recall
    that every module is either a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") or a descendant (along a chain
    of [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    objects) thereof, so that in fact every [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") represents an algebraic number
    in some field \(\mathbb{Q}(\theta)\), where \(\theta\) is the defining element
    of some [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis "sympy.polys.numberfields.modules.PowerBasis").
    It thus makes sense to talk about the number field to which a given [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") belongs.
  prefs: []
  type: TYPE_NORMAL
- en: This means that any two [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") instances can be added, subtracted,
    multiplied, or divided, provided they belong to the same number field. Similarly,
    since \(\mathbb{Q}\) is a subfield of every number field, any [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") may be added, multiplied, etc.
    by any rational number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: However, care must be taken with arithmetic operations on [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement"), because the module \(C\) to
    which the result will belong will be the nearest common ancestor (NCA) of the
    modules \(A\), \(B\) to which the two operands belong, and \(C\) may be different
    from either or both of \(A\) and \(B\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the arithmetic operation is performed, copies of the two operands are
    automatically converted into elements of the NCA (the operands themselves are
    not modified). This upward conversion along an ancestor chain is easy: it just
    requires the successive multiplication by the defining matrix of each [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule").'
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, downward conversion, i.e. representing a given [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") in a submodule, is also supported
    – namely by the [`represent()`](#sympy.polys.numberfields.modules.Submodule.represent
    "sympy.polys.numberfields.modules.Submodule.represent") method – but is not guaranteed
    to succeed in general, since the given element may not belong to the submodule.
    The main circumstance in which this issue tends to arise is with multiplication,
    since modules, while closed under addition, need not be closed under multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Multiplication
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: Generally speaking, a module need not be closed under multiplication, i.e. need
    not form a ring. However, many of the modules we work with in the context of number
    fields are in fact rings, and our classes do support multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, any [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")
    can attempt to compute its own multiplication table, but this does not happen
    unless an attempt is made to multiply two [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") instances belonging to it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Every [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis "sympy.polys.numberfields.modules.PowerBasis")
    is, by its nature, closed under multiplication, so instances of [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") can always successfully compute
    their multiplication table.
  prefs: []
  type: TYPE_NORMAL
- en: When a [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    attempts to compute its multiplication table, it converts each of its own generators
    into elements of its parent module, multiplies them there, in every possible pairing,
    and then tries to represent the results in itself, i.e. as \(\mathbb{Z}\)-linear
    combinations over its own generators. This will succeed if and only if the submodule
    is in fact closed under multiplication.
  prefs: []
  type: TYPE_NORMAL
- en: Module Homomorphisms
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Many important number theoretic algorithms require the calculation of the kernel
    of one or more module homomorphisms. Accordingly we have several lightweight classes,
    [`ModuleHomomorphism`](#sympy.polys.numberfields.modules.ModuleHomomorphism "sympy.polys.numberfields.modules.ModuleHomomorphism"),
    [`ModuleEndomorphism`](#sympy.polys.numberfields.modules.ModuleEndomorphism "sympy.polys.numberfields.modules.ModuleEndomorphism"),
    [`InnerEndomorphism`](#sympy.polys.numberfields.modules.InnerEndomorphism "sympy.polys.numberfields.modules.InnerEndomorphism"),
    and [`EndomorphismRing`](#sympy.polys.numberfields.modules.EndomorphismRing "sympy.polys.numberfields.modules.EndomorphismRing"),
    which provide the minimal necessary machinery to support this.
  prefs: []
  type: TYPE_NORMAL
- en: Class Reference
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Generic finitely-generated module.
  prefs: []
  type: TYPE_NORMAL
- en: This is an abstract base class, and should not be instantiated directly. The
    two concrete subclasses are [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") and [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule").
  prefs: []
  type: TYPE_NORMAL
- en: Every [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    is derived from another module, referenced by its `parent` attribute. If `S` is
    a submodule, then we refer to `S.parent`, `S.parent.parent`, and so on, as the
    “ancestors” of `S`. Thus, every [`Module`](#sympy.polys.numberfields.modules.Module
    "sympy.polys.numberfields.modules.Module") is either a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") or a [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule"), some ancestor of which is a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Generate a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") belonging to this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**spec** : [`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix"), int'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the numerators of the coefficients of the [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement"). Can be either a column vector
    over [ZZ](domainsref.html#zz), whose length must equal the number \(n\) of generators
    of this module, or else an integer `j`, \(0 \leq j < n\), which is a shorthand
    for column \(j\) of \(I_n\), the \(n \times n\) identity matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**denom** : int, optional (default=1)'
  prefs: []
  type: TYPE_NORMAL
- en: Denominator for the coefficients of the [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")'
  prefs: []
  type: TYPE_NORMAL
- en: The coefficients are the entries of the *spec* vector, divided by *denom*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Return the list of ancestor modules of this module, from the foundational [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") downward, optionally including
    `self`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Get list of [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") being the generators of this
    module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    representing a rational number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a** : int, [ZZ](domainsref.html#zz), [QQ](domainsref.html#qq)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The returned [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") will belong to the first module
    on this module’s ancestor chain (including this module itself) that starts with
    unity.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Form the [`EndomorphismRing`](#sympy.polys.numberfields.modules.EndomorphismRing
    "sympy.polys.numberfields.modules.EndomorphismRing") for this module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Say whether *col* is a suitable column vector for this module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Get the multiplication table for this module (if closed under mult).
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: dict of dict of lists
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ClosureFailure**'
  prefs: []
  type: TYPE_NORMAL
- en: If the module is not closed under multiplication.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Computes a dictionary `M` of dictionaries of lists, representing the upper triangular
    half of the multiplication table.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, if `0 <= i <= j < self.n`, then `M[i][j]` is the list `c` of
    coefficients such that `g[i] * g[j] == sum(c[k]*g[k], k in range(self.n))`, where
    `g` is the list of generators of this module.
  prefs: []
  type: TYPE_NORMAL
- en: If `j < i` then `M[i][j]` is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The number of generators of this module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Locate the nearest common ancestor of this module and another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module"),
    `None`'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Return the associated [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField"), if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField "sympy.polys.domains.AlgebraicField"),
    `None`'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: A [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis "sympy.polys.numberfields.modules.PowerBasis")
    can be constructed on a [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    \(f\) or on an [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") \(K\). In the latter case, the [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") and all its descendant modules
    will return \(K\) as their `.number_field` property, while in the former case
    they will all return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    representing unity, and belonging to the first ancestor of this module (including
    itself) that starts with unity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The parent module, if any, for this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module"),
    `None`'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: For a [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    this is its `parent` attribute; for a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") this is `None`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Return the [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis "sympy.polys.numberfields.modules.PowerBasis")
    that is an ancestor of this module.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Represent a module element as an integer-linear combination over the generators
    of this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**elt** : [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement")'
  prefs: []
  type: TYPE_NORMAL
- en: The module element to be represented. Must belong to some ancestor module of
    this module (including this module itself).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") over [ZZ](domainsref.html#zz)'
  prefs: []
  type: TYPE_NORMAL
- en: This will be a column vector, representing the coefficients of a linear combination
    of this module’s generators, which equals the given element.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ClosureFailure**'
  prefs: []
  type: TYPE_NORMAL
- en: If the given element cannot be represented as a [ZZ](domainsref.html#zz)-linear
    combination over this module.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: In our system, to “represent” always means to write a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") as a [ZZ](domainsref.html#zz)-linear
    combination over the generators of the present [`Module`](#sympy.polys.numberfields.modules.Module
    "sympy.polys.numberfields.modules.Module"). Furthermore, the incoming [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") must belong to an ancestor of
    the present [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")
    (or to the present [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")
    itself).
  prefs: []
  type: TYPE_NORMAL
- en: The most common application is to represent a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") in a [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule"). For example, this is involved in
    computing multiplication tables.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, representing in a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") is an odd case, and one which tends
    not to arise in practice, except for example when using a [`ModuleEndomorphism`](#sympy.polys.numberfields.modules.ModuleEndomorphism
    "sympy.polys.numberfields.modules.ModuleEndomorphism") on a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis").
  prefs: []
  type: TYPE_NORMAL
- en: In such a case, (1) the incoming [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") must belong to the [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") itself (since the latter has no
    proper ancestors) and (2) it is “representable” iff it belongs to \(\mathbb{Z}[\theta]\)
    (although generally a [`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement
    "sympy.polys.numberfields.modules.PowerBasisElement") may represent any element
    of \(\mathbb{Q}(\theta)\), i.e. any algebraic number).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    `a` has all even coefficients. If we represent `a` in the submodule `B = 2*A`,
    the coefficients in the column vector will be halved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the element of `B` so defined still represents the same algebraic
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Submodule.represent`](#sympy.polys.numberfields.modules.Submodule.represent
    "sympy.polys.numberfields.modules.Submodule.represent"), [`PowerBasis.represent`](#sympy.polys.numberfields.modules.PowerBasis.represent
    "sympy.polys.numberfields.modules.PowerBasis.represent")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Say whether the module’s first generator equals unity.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Form the submodule generated by a list of [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") belonging to this module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gens** : list of [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") belonging to this module.'
  prefs: []
  type: TYPE_NORMAL
- en: '**hnf** : boolean, optional (default=True)'
  prefs: []
  type: TYPE_NORMAL
- en: If True, we will reduce the matrix into Hermite Normal Form before forming the
    [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**hnf_modulus** : int, None, optional (default=None)'
  prefs: []
  type: TYPE_NORMAL
- en: Modulus for use in the HNF reduction algorithm. See [`hermite_normal_form()`](domainmatrix.html#sympy.polys.matrices.normalforms.hermite_normal_form
    "sympy.polys.matrices.normalforms.hermite_normal_form").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`submodule_from_matrix`](#sympy.polys.numberfields.modules.Module.submodule_from_matrix
    "sympy.polys.numberfields.modules.Module.submodule_from_matrix")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Form the submodule generated by the elements of this module indicated by the
    columns of a matrix, with an optional denominator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**B** : [`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") over [ZZ](domainsref.html#zz)'
  prefs: []
  type: TYPE_NORMAL
- en: Each column gives the numerators of the coefficients of one generator of the
    submodule. Thus, the number of rows of *B* must equal the number of generators
    of the present module.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**denom** : int, optional (default=1)'
  prefs: []
  type: TYPE_NORMAL
- en: Common denominator for all generators of the submodule.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the given matrix *B* is not over [ZZ](domainsref.html#zz) or its number of
    rows does not equal the number of generators of the present module.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`submodule_from_gens`](#sympy.polys.numberfields.modules.Module.submodule_from_gens
    "sympy.polys.numberfields.modules.Module.submodule_from_gens")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Return a submodule equal to this entire module.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This is useful when you have a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") and want to turn it into a [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule") (in order to use methods belonging
    to the latter).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    representing zero.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: The module generated by the powers of an algebraic integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**T** : [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly"),
    [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField "sympy.polys.domains.AlgebraicField")'
  prefs: []
  type: TYPE_NORMAL
- en: Either (1) the monic, irreducible, univariate polynomial over [ZZ](domainsref.html#zz),
    a root of which is the generator of the power basis, or (2) an [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") whose primitive element is the generator
    of the power basis.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Convert an ANP into a PowerBasisElement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Convert an AlgebraicNumber into a PowerBasisElement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Produce an element of this module, representing *f* after reduction mod our
    defining minimal polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f** : [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")
    over [ZZ](domainsref.html#zz) in same var as our defining poly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement "sympy.polys.numberfields.modules.PowerBasisElement")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Represent a module element as an integer-linear combination over the generators
    of this module.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Module.represent`](#sympy.polys.numberfields.modules.Module.represent "sympy.polys.numberfields.modules.Module.represent"),
    [`Submodule.represent`](#sympy.polys.numberfields.modules.Submodule.represent
    "sympy.polys.numberfields.modules.Submodule.represent")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: A submodule of another module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**parent** : [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: The module from which this one is derived.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**matrix** : [`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") over [ZZ](domainsref.html#zz)'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix whose columns define this submodule’s generators as linear combinations
    over the parent’s generators.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**denom** : int, optional (default=1)'
  prefs: []
  type: TYPE_NORMAL
- en: Denominator for the coefficients given by the matrix.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**mult_tab** : dict, `None`, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If already known, the multiplication table for this module may be supplied.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") over [QQ](domainsref.html#qq),
    equal to `self.matrix / self.denom`, and guaranteed to be dense.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") over [QQ](domainsref.html#qq)'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Depending on how it is formed, a [`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") may have an internal representation
    that is sparse or dense. We guarantee a dense representation here, so that tests
    for equivalence of submodules always come out as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Add this [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**other** : [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: '**hnf** : boolean, optional (default=True)'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, reduce the matrix of the combined module to its Hermite Normal Form.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**hnf_modulus** : [ZZ](domainsref.html#zz), None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If a positive integer is provided, use this as modulus in the HNF reduction.
    See [`hermite_normal_form()`](domainmatrix.html#sympy.polys.matrices.normalforms.hermite_normal_form
    "sympy.polys.matrices.normalforms.hermite_normal_form").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This represents the module generated by the union of the two modules’ sets of
    generators.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Return list of this submodule’s basis elements as elements of the submodule’s
    parent module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Produce a new module by discarding all generators before a given index *r*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Multiply this [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    by a rational number, a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement"), or another [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**other** : int, [ZZ](domainsref.html#zz), [QQ](domainsref.html#qq), [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement"), [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: '**hnf** : boolean, optional (default=True)'
  prefs: []
  type: TYPE_NORMAL
- en: If `True`, reduce the matrix of the product module to its Hermite Normal Form.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**hnf_modulus** : [ZZ](domainsref.html#zz), None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If a positive integer is provided, use this as modulus in the HNF reduction.
    See [`hermite_normal_form()`](domainmatrix.html#sympy.polys.matrices.normalforms.hermite_normal_form
    "sympy.polys.matrices.normalforms.hermite_normal_form").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: To multiply by a rational number or [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") means to form the submodule
    whose generators are the products of this quantity with all the generators of
    the present submodule.
  prefs: []
  type: TYPE_NORMAL
- en: To multiply by another [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule") means to form the submodule whose
    generators are all the products of one generator from the one submodule, and one
    generator from the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: If this submodule \(B\) has defining matrix \(W\) in square, maximal-rank Hermite
    normal form, then, given an element \(x\) of the parent module \(A\), we produce
    an element \(y \in A\) such that \(x - y \in B\), and the \(i\)th coordinate of
    \(y\) satisfies \(0 \leq y_i < w_{i,i}\). This representative \(y\) is unique,
    in the sense that every element of the coset \(x + B\) reduces to it under this
    procedure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**elt** : [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement")'
  prefs: []
  type: TYPE_NORMAL
- en: An element of this submodule’s parent module.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**elt** : [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement")'
  prefs: []
  type: TYPE_NORMAL
- en: An element of this submodule’s parent module.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**NotImplementedError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the given [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") does not belong to this submodule’s
    parent module.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**StructureError**'
  prefs: []
  type: TYPE_NORMAL
- en: If this submodule’s defining matrix is not in square, maximal-rank Hermite normal
    form.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: In the special case where \(A\) is a power basis for a number field \(K\), and
    \(B\) is a submodule representing an ideal \(I\), this operation represents one
    of a few important ways of reducing an element of \(K\) modulo \(I\) to obtain
    a “small” representative. See [[Cohen00]](#cohen00) Section 1.4.3.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[Cohen00] ([1](#id9),[2](#id10))'
  prefs: []
  type: TYPE_NORMAL
- en: Cohen, H. *Advanced Topics in Computational Number Theory.*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Produce a reduced version of this submodule.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: In the reduced version, it is guaranteed that 1 is the only positive integer
    dividing both the submodule’s denominator, and every entry in the submodule’s
    matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Represent a module element as an integer-linear combination over the generators
    of this module.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Module.represent`](#sympy.polys.numberfields.modules.Module.represent "sympy.polys.numberfields.modules.Module.represent"),
    [`PowerBasis.represent`](#sympy.polys.numberfields.modules.PowerBasis.represent
    "sympy.polys.numberfields.modules.PowerBasis.represent")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Represents an element of a [`Module`](#sympy.polys.numberfields.modules.Module
    "sympy.polys.numberfields.modules.Module").
  prefs: []
  type: TYPE_NORMAL
- en: 'NOTE: Should not be constructed directly. Use the [`__call__()`](#sympy.polys.numberfields.modules.Module.__call__
    "sympy.polys.numberfields.modules.Module.__call__") method or the [`make_mod_elt()`](#sympy.polys.numberfields.modules.make_mod_elt
    "sympy.polys.numberfields.modules.make_mod_elt") factory function instead.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**module** : [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: The module to which this element belongs.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**col** : [`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") over [ZZ](domainsref.html#zz)'
  prefs: []
  type: TYPE_NORMAL
- en: Column vector giving the numerators of the coefficients of this element.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**denom** : int, optional (default=1)'
  prefs: []
  type: TYPE_NORMAL
- en: Denominator for the coefficients of this element.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: A [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    can be added to a rational number, or to another [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement").
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: When the other summand is a rational number, it will be converted into a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") (belonging to the first ancestor
    of this module that starts with unity).
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, the sum belongs to the nearest common ancestor (NCA) of the modules
    of the two summands. If the NCA does not exist, we return `NotImplemented`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: A [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    can be multiplied by a rational number, or by another [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement").
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: When the multiplier is a rational number, the product is computed by operating
    directly on the coefficients of this [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement").
  prefs: []
  type: TYPE_NORMAL
- en: When the multiplier is another [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement"), the product will belong to
    the nearest common ancestor (NCA) of the modules of the two operands, and that
    NCA must have a multiplication table. If the NCA does not exist, we return `NotImplemented`.
    If the NCA does not have a mult. table, `ClosureFailure` will be raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Reduce this [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") mod a [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**m** : int, [ZZ](domainsref.html#zz), [QQ](domainsref.html#qq), [`Submodule`](#sympy.polys.numberfields.modules.Submodule
    "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: If a [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule"),
    reduce `self` relative to this. If an integer or rational, reduce relative to
    the [`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")
    that is our own module times this constant.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Submodule.reduce_element`](#sympy.polys.numberfields.modules.Submodule.reduce_element
    "sympy.polys.numberfields.modules.Submodule.reduce_element")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix") over [QQ](domainsref.html#qq),
    equal to `self.col / self.denom`, and guaranteed to be dense.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Submodule.QQ_matrix`](#sympy.polys.numberfields.modules.Submodule.QQ_matrix
    "sympy.polys.numberfields.modules.Submodule.QQ_matrix")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Get a copy of this element’s column, optionally converting to a domain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: A [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    may test as equivalent to a rational number or another [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement"), if they represent the same
    algebraic number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**other** : int, [ZZ](domainsref.html#zz), [QQ](domainsref.html#qq), [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UnificationFailed**'
  prefs: []
  type: TYPE_NORMAL
- en: If `self` and `other` do not share a common [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") ancestor.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: This method is intended to check equivalence only in those cases in which it
    is easy to test; namely, when *other* is either a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") that can be unified with this
    one (i.e. one which shares a common [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") ancestor), or else a rational number
    (which is easy because every [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") represents every rational number).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Make a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement "sympy.polys.numberfields.modules.ModuleElement")
    from a list of ints (instead of a column vector).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Test whether other is another [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") with same module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: The length of this element’s column.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Transform into a [`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement
    "sympy.polys.numberfields.modules.PowerBasisElement") over our [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") ancestor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Produce a reduced version of this ModuleElement, i.e. one in which the gcd of
    the denominator together with all numerator coefficients is 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Produce a version of this [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") in which all numerator coefficients
    have been reduced mod *p*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Transform into a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") belonging to a given ancestor
    of this element’s module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**anc** : [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Transform into a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") belonging to the parent of this
    element’s module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: Try to make a compatible pair of [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement"), one equivalent to this one,
    and one equivalent to the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Pair `(e1, e2)`
  prefs: []
  type: TYPE_NORMAL
- en: Each `ei` is a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement"), they belong to the same [`Module`](#sympy.polys.numberfields.modules.Module
    "sympy.polys.numberfields.modules.Module"), `e1` is equivalent to `self`, and
    `e2` is equivalent to `other`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UnificationFailed**'
  prefs: []
  type: TYPE_NORMAL
- en: If `self` and `other` have no common ancestor module.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: We search for the nearest common ancestor module for the pair of elements, and
    represent each one there.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Subclass for [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") instances whose module is a
    [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis "sympy.polys.numberfields.modules.PowerBasis").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Access the defining polynomial of the [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Create a Basic expression from `self`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Return a [`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")
    to be used when expressing this element as a polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: If we have an associated [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField") whose primitive element has an alias symbol,
    we use that. Otherwise we use the variable of the minimal polynomial defining
    the power basis to which we belong.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Say whether this element represents a rational number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Compute the norm of this number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Obtain the numerator as a polynomial over [ZZ](domainsref.html#zz).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Obtain the number as a polynomial over [QQ](domainsref.html#qq).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Convert to an equivalent [`ANP`](domainsref.html#sympy.polys.polyclasses.ANP
    "sympy.polys.polyclasses.ANP").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Try to convert to an equivalent [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber").
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber "sympy.core.numbers.AlgebraicNumber")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**StructureError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis "sympy.polys.numberfields.modules.PowerBasis")
    to which this element belongs does not have an associated [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField").
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: In general, the conversion from an [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber") to a [`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement
    "sympy.polys.numberfields.modules.PowerBasisElement") throws away information,
    because an [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber") specifies a complex embedding, while a [`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement
    "sympy.polys.numberfields.modules.PowerBasisElement") does not. However, in some
    cases it is possible to convert a [`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement
    "sympy.polys.numberfields.modules.PowerBasisElement") back into an [`AlgebraicNumber`](../core.html#sympy.core.numbers.AlgebraicNumber
    "sympy.core.numbers.AlgebraicNumber"), namely when the associated [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis") has a reference to an [`AlgebraicField`](domainsref.html#sympy.polys.domains.AlgebraicField
    "sympy.polys.domains.AlgebraicField").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Factory function which builds a [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement"), but ensures that it is a [`PowerBasisElement`](#sympy.polys.numberfields.modules.PowerBasisElement
    "sympy.polys.numberfields.modules.PowerBasisElement") if the module is a [`PowerBasis`](#sympy.polys.numberfields.modules.PowerBasis
    "sympy.polys.numberfields.modules.PowerBasis").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: A homomorphism from one module to another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**domain** : [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: The domain of the mapping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**codomain** : [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: The codomain of the mapping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**mapping** : callable'
  prefs: []
  type: TYPE_NORMAL
- en: An arbitrary callable is accepted, but should be chosen so as to represent an
    actual module homomorphism. In particular, should accept elements of *domain*
    and return elements of *codomain*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Compute a Submodule representing the kernel of this homomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**modulus** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A positive prime number \(p\) if the kernel should be computed mod \(p\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Submodule`](#sympy.polys.numberfields.modules.Submodule "sympy.polys.numberfields.modules.Submodule")'
  prefs: []
  type: TYPE_NORMAL
- en: This submodule’s generators span the kernel of this homomorphism over [ZZ](domainsref.html#zz),
    or else over [GF(p)](domainsref.html#gf-p) if a modulus was given.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Compute the matrix of this homomorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**modulus** : int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: A positive prime number \(p\) if the matrix should be reduced mod \(p\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix")'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix is over [ZZ](domainsref.html#zz), or else over [GF(p)](domainsref.html#gf-p)
    if a modulus was given.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: A homomorphism from one module to itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**domain** : [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: The common domain and codomain of the mapping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**mapping** : callable'
  prefs: []
  type: TYPE_NORMAL
- en: An arbitrary callable is accepted, but should be chosen so as to represent an
    actual module endomorphism. In particular, should accept and return elements of
    *domain*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: An inner endomorphism on a module, i.e. the endomorphism corresponding to multiplication
    by a fixed element.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**domain** : [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: The domain and codomain of the endomorphism.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**multiplier** : [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement")'
  prefs: []
  type: TYPE_NORMAL
- en: The element \(a\) defining the mapping as \(x \mapsto a x\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The ring of endomorphisms on a module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**domain** : [`Module`](#sympy.polys.numberfields.modules.Module "sympy.polys.numberfields.modules.Module")'
  prefs: []
  type: TYPE_NORMAL
- en: The domain and codomain of the endomorphisms.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Form an inner endomorphism belonging to this endomorphism ring.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**multiplier** : [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement")'
  prefs: []
  type: TYPE_NORMAL
- en: Element \(a\) defining the inner endomorphism \(x \mapsto a x\).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`InnerEndomorphism`](#sympy.polys.numberfields.modules.InnerEndomorphism "sympy.polys.numberfields.modules.InnerEndomorphism")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Represent an element of this endomorphism ring, as a single column vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**element** : [`ModuleEndomorphism`](#sympy.polys.numberfields.modules.ModuleEndomorphism
    "sympy.polys.numberfields.modules.ModuleEndomorphism") belonging to this ring.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix")'
  prefs: []
  type: TYPE_NORMAL
- en: Column vector equalling the vertical stacking of all the columns of the matrix
    that represents the given *element* as a mapping.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Let \(M\) be a module, and \(E\) its ring of endomorphisms. Let \(N\) be another
    module, and consider a homomorphism \(\varphi: N \rightarrow E\). In the event
    that \(\varphi\) is to be represented by a matrix \(A\), each column of \(A\)
    must represent an element of \(E\). This is possible when the elements of \(E\)
    are themselves representable as matrices, by stacking the columns of such a matrix
    into a single column.'
  prefs: []
  type: TYPE_NORMAL
- en: This method supports calculating such matrices \(A\), by representing an element
    of this endomorphism ring first as a matrix, and then stacking that matrix’s columns
    into a single column.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Note that in these examples we print matrix transposes, to make their columns
    easier to inspect.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Let \(\zeta\) be a primitive 5th root of unity, a generator of our field, and
    consider the inner endomorphism \(\tau\) on the ring of integers, induced by \(\zeta\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The matrix representation of \(\tau\) is as expected. The first column shows
    that multiplying by \(\zeta\) carries \(1\) to \(\zeta\), the second column that
    it carries \(\zeta\) to \(\zeta^2\), and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `represent` method of the endomorphism ring `E` stacks these into a single
    column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful when we want to consider a homomorphism \(\varphi\) having `E`
    as codomain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'and we want to compute the matrix of such a homomorphism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Note that the stacked matrix of \(\tau\) occurs as the second column in this
    example. This is because \(\zeta\) is the second basis element of `M`, and \(\varphi(\zeta)
    = \tau\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Find a polynomial of least degree (not necessarily irreducible) satisfied by
    an element of a finitely-generated ring with unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alpha** : [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement")'
  prefs: []
  type: TYPE_NORMAL
- en: The element whose min poly is to be found, and whose module has multiplication
    and starts with unity.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**domain** : [`Domain`](domainsref.html#sympy.polys.domains.domain.Domain "sympy.polys.domains.domain.Domain")'
  prefs: []
  type: TYPE_NORMAL
- en: The desired domain of the polynomial.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**x** : [`Symbol`](../core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol"),
    optional'
  prefs: []
  type: TYPE_NORMAL
- en: The desired variable for the polynomial.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**powers** : list, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If desired, pass an empty list. The powers of *alpha* (as [`ModuleElement`](#sympy.polys.numberfields.modules.ModuleElement
    "sympy.polys.numberfields.modules.ModuleElement") instances) from the zeroth up
    to the degree of the min poly will be recorded here, as we compute them.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly"),
    `None`'
  prefs: []
  type: TYPE_NORMAL
- en: The minimal polynomial for alpha, or `None` if no polynomial could be found
    over the desired domain.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**MissingUnityError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the module to which alpha belongs does not start with unity.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**ClosureFailure**'
  prefs: []
  type: TYPE_NORMAL
- en: If the module to which alpha belongs is not closed under multiplication.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: For the \(n\)th cyclotomic field, \(n\) an odd prime, consider the quadratic
    equation whose roots are the two periods of length \((n-1)/2\). Article 356 of
    Gauss tells us that we should get \(x^2 + x - (n-1)/4\) or \(x^2 + x + (n+1)/4\)
    according to whether \(n\) is 1 or 3 mod 4, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Utilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Test whether an argument is of an acceptable type to be used as a rational number.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Returns `True` on any argument of type `int`, [ZZ](domainsref.html#zz), or [QQ](domainsref.html#qq).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_int`](#sympy.polys.numberfields.utilities.is_int "sympy.polys.numberfields.utilities.is_int")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: Test whether an argument is of an acceptable type to be used as an integer.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Returns `True` on any argument of type `int` or [ZZ](domainsref.html#zz).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_rat`](#sympy.polys.numberfields.utilities.is_rat "sympy.polys.numberfields.utilities.is_rat")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Given any argument on which [`is_rat()`](#sympy.polys.numberfields.utilities.is_rat
    "sympy.polys.numberfields.utilities.is_rat") is `True`, return the numerator and
    denominator of this number.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`is_rat`](#sympy.polys.numberfields.utilities.is_rat "sympy.polys.numberfields.utilities.is_rat")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Extract a fundamental discriminant from an integer *a*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a: int, must be 0 or 1 mod 4**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Pair `(D, F)` of dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError**'
  prefs: []
  type: TYPE_NORMAL
- en: If *a* is not 0 or 1 mod 4.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Given any rational integer *a* that is 0 or 1 mod 4, write \(a = d f^2\), where
    \(d\) is either 1 or a fundamental discriminant, and return a pair of dictionaries
    `(D, F)` giving the prime factorizations of \(d\) and \(f\) respectively, in the
    same format returned by [`factorint()`](../ntheory.html#sympy.ntheory.factor_.factorint
    "sympy.ntheory.factor_.factorint").
  prefs: []
  type: TYPE_NORMAL
- en: A fundamental discriminant \(d\) is different from unity, and is either 1 mod
    4 and squarefree, or is 0 mod 4 and such that \(d/4\) is squarefree and 2 or 3
    mod 4\. This is the same as being the discriminant of some quadratic field.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'For comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R805](#id11)]'
  prefs: []
  type: TYPE_NORMAL
- en: Cohen, H. *A Course in Computational Algebraic Number Theory.* (See Prop. 5.1.3)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: Compute the powers of an algebraic integer.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Given an algebraic integer \(\theta\) by its monic irreducible polynomial `T`
    over [ZZ](domainsref.html#zz), this class computes representations of arbitrarily
    high powers of \(\theta\), as [ZZ](domainsref.html#zz)-linear combinations over
    \(\{1, \theta, \ldots, \theta^{n-1}\}\), where \(n = \deg(T)\).
  prefs: []
  type: TYPE_NORMAL
- en: The representations are computed using the linear recurrence relations for powers
    of \(\theta\), derived from the polynomial `T`. See [1], Sec. 4.2.2.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, the representations may be reduced with respect to a modulus.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R806](#id12)]'
  prefs: []
  type: TYPE_NORMAL
- en: Cohen, H. *A Course in Computational Algebraic Number Theory.*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**T** : [`Poly`](reference.html#sympy.polys.polytools.Poly "sympy.polys.polytools.Poly")'
  prefs: []
  type: TYPE_NORMAL
- en: The monic irreducible polynomial over [ZZ](domainsref.html#zz) defining the
    algebraic integer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**modulus** : int, None, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If not `None`, all representations will be reduced w.r.t. this.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Generate coefficients for searching through polynomials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**m** : int'
  prefs: []
  type: TYPE_NORMAL
- en: Length of coeff list.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**R** : int'
  prefs: []
  type: TYPE_NORMAL
- en: Initial max abs val for coeffs (will increase as search proceeds).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: generator
  prefs: []
  type: TYPE_NORMAL
- en: Infinite generator of lists of coefficients.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Lead coeff is always non-negative. Explore all combinations with coeffs bounded
    in absolute value before increasing the bound. Skip the all-zero list, and skip
    any repeats. See examples.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Extend a basis for a subspace to a basis for the whole space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**M** : [`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix")'
  prefs: []
  type: TYPE_NORMAL
- en: The columns give the basis for the subspace.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DomainMatrix`](domainmatrix.html#sympy.polys.matrices.domainmatrix.DomainMatrix
    "sympy.polys.matrices.domainmatrix.DomainMatrix")'
  prefs: []
  type: TYPE_NORMAL
- en: This matrix is invertible and its first \(r\) columns equal *M*.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DMRankError**'
  prefs: []
  type: TYPE_NORMAL
- en: If *M* was not of maximal rank.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Given an \(n \times r\) matrix *M* of rank \(r\) (so \(r \leq n\)), this function
    computes an invertible \(n \times n\) matrix \(B\) such that the first \(r\) columns
    of \(B\) equal *M*.
  prefs: []
  type: TYPE_NORMAL
- en: This operation can be interpreted as a way of extending a basis for a subspace,
    to give a basis for the whole space.
  prefs: []
  type: TYPE_NORMAL
- en: To be precise, suppose you have an \(n\)-dimensional vector space \(V\), with
    basis \(\{v_1, v_2, \ldots, v_n\}\), and an \(r\)-dimensional subspace \(W\) of
    \(V\), spanned by a basis \(\{w_1, w_2, \ldots, w_r\}\), where the \(w_j\) are
    given as linear combinations of the \(v_i\). If the columns of *M* represent the
    \(w_j\) as such linear combinations, then the columns of the matrix \(B\) computed
    by this function give a new basis \(\{u_1, u_2, \ldots, u_n\}\) for \(V\), again
    relative to the \(\{v_i\}\) basis, and such that \(u_j = w_j\) for \(1 \leq j
    \leq r\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: The function works in terms of columns, so in these examples we print
    matrix transposes in order to make the columns easier to inspect.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R807](#id13)]'
  prefs: []
  type: TYPE_NORMAL
- en: Cohen, H. *A Course in Computational Algebraic Number Theory* (See Sec. 2.3.2.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Find a rational isolating interval for a real algebraic number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alg** : str, int, [`Expr`](../core.html#sympy.core.expr.Expr "sympy.core.expr.Expr")'
  prefs: []
  type: TYPE_NORMAL
- en: The algebraic number to be isolated. Must be a real number, to use this particular
    function. However, see also [`Poly.intervals()`](reference.html#sympy.polys.polytools.Poly.intervals
    "sympy.polys.polytools.Poly.intervals"), which isolates complex roots when you
    pass `all=True`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**eps** : positive element of [QQ](domainsref.html#qq), None, optional (default=None)'
  prefs: []
  type: TYPE_NORMAL
- en: Precision to be passed to [`Poly.refine_root()`](reference.html#sympy.polys.polytools.Poly.refine_root
    "sympy.polys.polytools.Poly.refine_root")
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**fast** : boolean, optional (default=False)'
  prefs: []
  type: TYPE_NORMAL
- en: Say whether fast refinement procedure should be used. (Will be passed to [`Poly.refine_root()`](reference.html#sympy.polys.polytools.Poly.refine_root
    "sympy.polys.polytools.Poly.refine_root").)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: Pair of rational numbers defining an isolating interval for the given
  prefs: []
  type: TYPE_NORMAL
- en: algebraic number.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Poly.intervals`](reference.html#sympy.polys.polytools.Poly.intervals "sympy.polys.polytools.Poly.intervals")'
  prefs: []
  type: TYPE_NORMAL
