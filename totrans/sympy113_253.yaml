- en: Lambdify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/utilities/lambdify.html](https://docs.sympy.org/latest/modules/utilities/lambdify.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This module provides convenient functions to transform SymPy expressions to
    lambda functions which can be used to calculate numerical values very fast.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Add numerical `implementation` to function `symfunc`.
  prefs: []
  type: TYPE_NORMAL
- en: '`symfunc` can be an `UndefinedFunction` instance, or a name string. In the
    latter case we create an `UndefinedFunction` instance with that name.'
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that this is a quick workaround, not a general method to create special
    symbolic functions. If you want to create a symbolic function to be used by all
    the machinery of SymPy you should subclass the `Function` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**symfunc** : `str` or `UndefinedFunction` instance'
  prefs: []
  type: TYPE_NORMAL
- en: If `str`, then create new `UndefinedFunction` with this as name. If `symfunc`
    is an Undefined function, create a new function with the same name and the implemented
    function attached.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**implementation** : callable'
  prefs: []
  type: TYPE_NORMAL
- en: numerical implementation to be called by `evalf()` or `lambdify`
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**afunc** : sympy.FunctionClass instance'
  prefs: []
  type: TYPE_NORMAL
- en: function with attached implementation
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Returns a string that can be evaluated to a lambda function.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Although tuples may not appear as arguments to lambda in Python 3, lambdastr
    will create a lambda function that will unpack the original arguments so that
    nested arguments can be handled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Convert a SymPy expression into a function that allows for fast numeric evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This function uses `exec`, and thus should not be used on unsanitized input.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.7: Passing a set for the *args* parameter is deprecated
    as sets are unordered. Use an ordered iterable such as a list or tuple.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**args** : List[Symbol]'
  prefs: []
  type: TYPE_NORMAL
- en: A variable or a list of variables whose nesting represents the nesting of the
    arguments that will be passed to the function.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Variables can be symbols, undefined functions, or matrix symbols.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The list of variables should match the structure of how the arguments will be
    passed to the function. Simply enclose the parameters as they will be passed in
    a list.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To call a function like `f(x)` then `[x]` should be the first argument to `lambdify`;
    for this case a single `x` can also be used:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To call a function like `f(x, y)` then `[x, y]` will be the first argument
    of the `lambdify`:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'To call a function with a single 3-element tuple like `f((x, y, z))` then `[(x,
    y, z)]` will be the first argument of the `lambdify`:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If two args will be passed and the first is a scalar but the second is a tuple
    with two arguments then the items in the list should match that structure:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: '**expr** : Expr'
  prefs: []
  type: TYPE_NORMAL
- en: An expression, list of expressions, or matrix to be evaluated.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Lists may be nested. If the expression is a list, the output will also be a
    list.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is a matrix, an array will be returned (for the NumPy module).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Note that the argument order here (variables then expression) is used to emulate
    the Python `lambda` keyword. `lambdify(x, expr)` works (roughly) like `lambda
    x: expr` (see [How It Works](#lambdify-how-it-works) below).'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**modules** : str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the numeric library to use.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If not specified, *modules* defaults to:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '`["scipy", "numpy"]` if SciPy is installed'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`["numpy"]` if only NumPy is installed'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`["math", "mpmath", "sympy"]` if neither is installed.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: That is, SymPy functions are replaced as far as possible by either `scipy` or
    `numpy` functions if available, and Python’s standard library `math`, or `mpmath`
    functions otherwise.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*modules* can be one of the following types:'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The strings `"math"`, `"mpmath"`, `"numpy"`, `"numexpr"`, `"scipy"`, `"sympy"`,
    or `"tensorflow"` or `"jax"`. This uses the corresponding printer and namespace
    mapping for that module.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: A module (e.g., `math`). This uses the global namespace of the module. If the
    module is one of the above known modules, it will also use the corresponding printer
    and namespace mapping (i.e., `modules=numpy` is equivalent to `modules="numpy"`).
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A dictionary that maps names of SymPy functions to arbitrary functions (e.g.,
    `{''sin'': custom_sin}`).'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A list that contains a mix of the arguments above, with higher priority given
    to entries appearing first (e.g., to use the NumPy module but override the `sin`
    function with a custom version, you can use `[{''sin'': custom_sin}, ''numpy'']`).'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dummify** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Whether or not the variables in the provided expression that are not valid Python
    identifiers are substituted with dummy symbols.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This allows for undefined functions like `Function('f')(t)` to be supplied as
    arguments. By default, the variables are only dummified if they are not valid
    Python identifiers.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Set `dummify=True` to replace all arguments with dummy symbols (if `args` is
    not a string) - for example, to ensure that the arguments do not redefine any
    built-in names.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**cse** : bool, or callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Large expressions can be computed more efficiently when common subexpressions
    are identified and precomputed before being used multiple time. Finding the subexpressions
    will make creation of the ‘lambdify’ function slower, however.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When `True`, `sympy.simplify.cse` is used, otherwise (the default) the user
    may pass a function matching the `cse` signature.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**docstring_limit** : int or None'
  prefs: []
  type: TYPE_NORMAL
- en: When lambdifying large expressions, a significant proportion of the time spent
    inside `lambdify` is spent producing a string representation of the expression
    for use in the automatically generated docstring of the returned function. For
    expressions containing hundreds or more nodes the resulting docstring often becomes
    so long and dense that it is difficult to read. To reduce the runtime of lambdify,
    the rendering of the full expression inside the docstring can be disabled.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When `None`, the full expression is rendered in the docstring. When `0` or a
    negative `int`, an ellipsis is rendering in the docstring instead of the expression.
    When a strictly positive `int`, if the number of nodes in the expression exceeds
    `docstring_limit` an ellipsis is rendered in the docstring, otherwise a string
    representation of the expression is rendered as normal. The default is `1000`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to convert the SymPy expression `sin(x) + cos(x)` to an equivalent
    NumPy function that numerically evaluates it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The primary purpose of this function is to provide a bridge from SymPy expressions
    to numerical libraries such as NumPy, SciPy, NumExpr, mpmath, and tensorflow.
    In general, SymPy functions do not work with objects from other libraries, such
    as NumPy arrays, and functions from numeric libraries like NumPy or mpmath do
    not work on SymPy expressions. `lambdify` bridges the two by converting a SymPy
    expression to an equivalent numeric function.
  prefs: []
  type: TYPE_NORMAL
- en: The basic workflow with `lambdify` is to first create a SymPy expression representing
    whatever mathematical function you wish to evaluate. This should be done using
    only SymPy functions and expressions. Then, use `lambdify` to convert this to
    an equivalent function for numerical evaluation. For instance, above we created
    `expr` using the SymPy symbol `x` and SymPy functions `sin` and `cos`, then converted
    it to an equivalent NumPy function `f`, and called it on a NumPy array `a`.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`lambdify` can be used to translate SymPy expressions into mpmath functions.
    This may be preferable to using `evalf` (which uses mpmath on the backend) in
    some cases.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuple arguments are handled and the lambdified function should be called with
    the same type of arguments as were used to create the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `flatten` function can be used to always work with flattened arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions present in `expr` can also carry their own numerical implementations,
    in a callable attached to the `_imp_` attribute. This can be used with undefined
    functions using the `implemented_function` factory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`lambdify` always prefers `_imp_` implementations to implementations in other
    namespaces, unless the `use_imps` input parameter is False.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage with Tensorflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: After tensorflow v2, eager execution is enabled by default. If you want to get
    the compatible result across tensorflow v1 and v2 as same as this tutorial, run
    this line.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you have eager execution enabled, you can get the result out immediately
    as you can use numpy.
  prefs: []
  type: TYPE_NORMAL
- en: If you pass tensorflow objects, you may get an `EagerTensor` object instead
    of value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can use `.numpy()` to get the numpy value of the tensor.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And it works with any shape array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'For functions involving large array calculations, numexpr can provide a significant
    speedup over numpy. Please note that the available functions for numexpr are more
    limited than numpy but can be expanded with `implemented_function` and user defined
    subclasses of Function. If specified, numexpr may be the only option in modules.
    The official list of numexpr functions can be found at: [https://numexpr.readthedocs.io/en/latest/user_guide.html#supported-functions](https://numexpr.readthedocs.io/en/latest/user_guide.html#supported-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the above examples, the generated functions can accept scalar values or
    numpy arrays as arguments. However, in some cases the generated function relies
    on the input being a numpy array:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In such cases, the input should be wrapped in a numpy array:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or if numpy functionality is not required another module can be used:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How It Works
  prefs: []
  type: TYPE_NORMAL
- en: When using this function, it helps a great deal to have an idea of what it is
    doing. At its core, lambdify is nothing more than a namespace translation, on
    top of a special printer that makes some corner cases work properly.
  prefs: []
  type: TYPE_NORMAL
- en: To understand lambdify, first we must properly understand how Python namespaces
    work. Say we had two files. One called `sin_cos_sympy.py`, with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: and one called `sin_cos_numpy.py` with
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The two files define an identical function `sin_cos`. However, in the first
    file, `sin` and `cos` are defined as the SymPy `sin` and `cos`. In the second,
    they are defined as the NumPy versions.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to import the first file and use the `sin_cos` function, we would
    get something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, if we imported `sin_cos` from the second file, we would get
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the first case we got a symbolic output, because it used the symbolic `sin`
    and `cos` functions from SymPy. In the second, we got a numeric result, because
    `sin_cos` used the numeric `sin` and `cos` functions from NumPy. But notice that
    the versions of `sin` and `cos` that were used was not inherent to the `sin_cos`
    function definition. Both `sin_cos` definitions are exactly the same. Rather,
    it was based on the names defined at the module where the `sin_cos` function was
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: The key point here is that when function in Python references a name that is
    not defined in the function, that name is looked up in the “global” namespace
    of the module where that function is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in Python, we can emulate this behavior without actually writing a file
    to disk using the `exec` function. `exec` takes a string containing a block of
    Python code, and a dictionary that should contain the global variables of the
    module. It then executes the code “in” that dictionary, as if it were the module
    globals. The following is equivalent to the `sin_cos` defined in `sin_cos_sympy.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'and similarly with `sin_cos_numpy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'So now we can get an idea of how `lambdify` works. The name “lambdify” comes
    from the fact that we can think of something like `lambdify(x, sin(x) + cos(x),
    ''numpy'')` as `lambda x: sin(x) + cos(x)`, where `sin` and `cos` come from the
    `numpy` namespace. This is also why the symbols argument is first in `lambdify`,
    as opposed to most SymPy functions where it comes after the expression: to better
    mimic the `lambda` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: '`lambdify` takes the input expression (like `sin(x) + cos(x)`) and'
  prefs: []
  type: TYPE_NORMAL
- en: Converts it to a string
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creates a module globals dictionary based on the modules that are passed in
    (by default, it uses the NumPy module)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creates the string `"def func({vars}): return {expr}"`, where `{vars}` is the
    list of variables separated by commas, and `{expr}` is the string created in step
    1., then [PRE38].'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In fact, functions returned by `lambdify` support inspection. So you can see
    exactly how they are defined by using `inspect.getsource`, or `??` if you are
    using IPython or the Jupyter notebook.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows us the source code of the function, but not the namespace it was
    defined in. We can inspect that by looking at the `__globals__` attribute of `f`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This shows us that `sin` and `cos` in the namespace of `f` will be `numpy.sin`
    and `numpy.cos`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that there are some convenience layers in each of these steps, but at the
    core, this is how `lambdify` works. Step 1 is done using the `LambdaPrinter` printers
    defined in the printing module (see [`sympy.printing.lambdarepr`](../printing.html#module-sympy.printing.lambdarepr
    "sympy.printing.lambdarepr")). This allows different SymPy expressions to define
    how they should be converted to a string for different modules. You can change
    which printer `lambdify` uses by passing a custom printer in to the `printer`
    argument.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 is augmented by certain translations. There are default translations
    for each module, but you can provide your own by passing a list to the `modules`
    argument. For instance,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The globals dictionary is generated from the list by merging the dictionary
    `{''sin'': mysin}` and the module dictionary for NumPy. The merging is done so
    that earlier items take precedence, which is why `mysin` is used above instead
    of `numpy.sin`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to modify the way `lambdify` works for a given function, it is usually
    easiest to do so by modifying the globals dictionary as such. In more complicated
    cases, it may be necessary to create and pass in a custom printer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, step 3 is augmented with certain convenience operations, such as the
    addition of a docstring.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how `lambdify` works can make it easier to avoid certain gotchas
    when using it. For instance, a common mistake is to create a lambdified function
    for one module (say, NumPy), and pass it objects from another (say, a SymPy expression).
  prefs: []
  type: TYPE_NORMAL
- en: For instance, say we create
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Now if we pass in a NumPy array, we get that array plus 1
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'But what happens if you make the mistake of passing in a SymPy expression instead
    of a NumPy array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This worked, but it was only by accident. Now take a different lambdified function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This works as expected on NumPy arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: But if we try to pass in a SymPy expression, it fails
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s look at what happened. The reason this fails is that `g` calls `numpy.sin`
    on the input expression, and `numpy.sin` does not know how to operate on a SymPy
    object. **As a general rule, NumPy functions do not know how to operate on SymPy
    expressions, and SymPy functions do not know how to operate on NumPy arrays. This
    is why lambdify exists: to provide a bridge between SymPy and NumPy.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, why is it that `f` did work? That’s because `f` does not call any
    functions, it only adds 1\. So the resulting function that is created, `def _lambdifygenerated(x):
    return x + 1` does not depend on the globals namespace it is defined in. Thus
    it works, but only by accident. A future version of `lambdify` may remove this
    behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: Be aware that certain implementation details described here may change in future
    versions of SymPy. The API of passing in custom modules and printers will not
    change, but the details of how a lambda function is created may change. However,
    the basic idea will remain the same, and understanding it will be helpful to understanding
    the behavior of lambdify.
  prefs: []
  type: TYPE_NORMAL
- en: '**In general: you should create lambdified functions for one module (say, NumPy),
    and only pass it input types that are compatible with that module (say, NumPy
    arrays).** Remember that by default, if the `module` argument is not provided,
    `lambdify` creates functions using the NumPy and SciPy namespaces.'
  prefs: []
  type: TYPE_NORMAL
