- en: Multidimensional image processing (scipy.ndimage)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多维图像处理（scipy.ndimage）
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/ndimage.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/ndimage.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/ndimage.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/ndimage.html)
- en: '## Introduction'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '## 简介'
- en: 'Image processing and analysis are generally seen as operations on 2-D arrays
    of values. There are, however, a number of fields where images of higher dimensionality
    must be analyzed. Good examples of these are medical imaging and biological imaging.
    [`numpy`](https://numpy.org/devdocs/reference/index.html#module-numpy "(in NumPy
    v2.0.dev0)") is suited very well for this type of applications due to its inherent
    multidimensional nature. The [`scipy.ndimage`](../reference/ndimage.html#module-scipy.ndimage
    "scipy.ndimage") packages provides a number of general image processing and analysis
    functions that are designed to operate with arrays of arbitrary dimensionality.
    The packages currently includes: functions for linear and non-linear filtering,
    binary morphology, B-spline interpolation, and object measurements.  ## Properties
    shared by all functions'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '图像处理和分析通常被视为对值的二维数组进行操作。然而，在一些领域中，必须分析更高维度的图像。医学成像和生物成像是这方面的典型例子。由于其固有的多维特性，[`numpy`](https://numpy.org/devdocs/reference/index.html#module-numpy
    "(在 NumPy v2.0.dev0)")非常适合于这类应用。[`scipy.ndimage`](../reference/ndimage.html#module-scipy.ndimage
    "scipy.ndimage")包提供了许多通用的图像处理和分析函数，设计用于处理任意维度的数组。目前这些包括：线性和非线性滤波函数，二值形态学，B样条插值以及对象测量。  ##
    所有函数共享的属性'
- en: All functions share some common properties. Notably, all functions allow the
    specification of an output array with the *output* argument. With this argument,
    you can specify an array that will be changed in-place with the result with the
    operation. In this case, the result is not returned. Usually, using the *output*
    argument is more efficient, since an existing array is used to store the result.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 所有函数都具有一些共同的特性。特别是，所有函数都允许使用*output*参数来指定输出数组。通过这个参数，你可以指定一个数组，在操作中会就地改变这个数组并存储结果。在这种情况下，不会返回结果。通常情况下，使用*output*参数更加高效，因为可以利用现有数组来存储结果。
- en: 'The type of arrays returned is dependent on the type of operation, but it is,
    in most cases, equal to the type of the input. If, however, the *output* argument
    is used, the type of the result is equal to the type of the specified output argument.
    If no output argument is given, it is still possible to specify what the result
    of the output should be. This is done by simply assigning the desired [`numpy`](https://numpy.org/devdocs/reference/index.html#module-numpy
    "(in NumPy v2.0.dev0)") type object to the output argument. For example:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的数组类型取决于操作的类型，但大多数情况下等于输入的类型。然而，如果使用*output*参数，则结果的类型将等于指定的输出参数的类型。如果没有给出输出参数，则仍然可以指定输出结果的类型。这可以通过简单地将所需的[`numpy`](https://numpy.org/devdocs/reference/index.html#module-numpy
    "(在 NumPy v2.0.dev0)")类型对象分配给输出参数来实现。例如：
- en: '[PRE0]  ## Filter functions'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE0]  ## 过滤函数'
- en: 'The functions described in this section all perform some type of spatial filtering
    of the input array: the elements in the output are some function of the values
    in the neighborhood of the corresponding input element. We refer to this neighborhood
    of elements as the filter kernel, which is often rectangular in shape but may
    also have an arbitrary footprint. Many of the functions described below allow
    you to define the footprint of the kernel by passing a mask through the *footprint*
    parameter. For example, a cross-shaped kernel can be defined as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的函数都执行某种类型的空间过滤输入数组的操作：输出中的元素是相应输入元素邻域值的某种函数。我们称这些元素邻域为滤波核，通常是矩形的形状，但也可以具有任意的足迹。下面描述的许多函数允许通过*footprint*参数定义核的足迹。例如，可以如下定义十字形的核：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Usually, the origin of the kernel is at the center calculated by dividing the
    dimensions of the kernel shape by two. For instance, the origin of a 1-D kernel
    of length three is at the second element. Take, for example, the correlation of
    a 1-D array with a filter of length 3 consisting of ones:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，核的原点位于核形状的维度的中心，通过将核形状的维度除以2来计算。例如，长度为3的一维核的原点位于第二个元素。例如，与长度为3的由1组成的滤波器的相关性：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Sometimes, it is convenient to choose a different origin for the kernel. For
    this reason, most functions support the *origin* parameter, which gives the origin
    of the filter relative to its center. For example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，为了选择内核的不同起点更为方便。因此，大多数函数支持 *origin* 参数，该参数指定了滤波器相对于其中心的起点。例如：
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The effect is a shift of the result towards the left. This feature will not
    be needed very often, but it may be useful, especially for filters that have an
    even size. A good example is the calculation of backward and forward differences:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这会使结果向左移动。这个特性通常不经常需要，但可能会很有用，特别是对于具有偶数大小的滤波器。一个很好的例子是计算后向和前向差分：
- en: '[PRE4]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We could also have calculated the forward difference as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以按以下方式计算前向差分：
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: However, using the origin parameter instead of a larger kernel is more efficient.
    For multidimensional kernels, *origin* can be a number, in which case the origin
    is assumed to be equal along all axes, or a sequence giving the origin along each
    axis.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，相比于较大的内核，使用 origin 参数更为高效。对于多维内核，*origin* 可以是一个数字，此时假定各轴上的起点相等，或者是一个序列，分别给出每个轴上的起点。
- en: 'Since the output elements are a function of elements in the neighborhood of
    the input elements, the borders of the array need to be dealt with appropriately
    by providing the values outside the borders. This is done by assuming that the
    arrays are extended beyond their boundaries according to certain boundary conditions.
    In the functions described below, the boundary conditions can be selected using
    the *mode* parameter, which must be a string with the name of the boundary condition.
    The following boundary conditions are currently supported:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于输出元素是输入元素邻域内元素的函数，所以数组的边界需要适当处理，即在边界外提供值。这是通过假设根据特定边界条件扩展数组来完成的。在下述描述的函数中，可以使用
    *mode* 参数来选择边界条件，该参数必须是一个字符串，表示边界条件的名称。当前支持以下边界条件：
- en: '| **mode** | **description** | **example** |'
  id: totrans-19
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **模式** | **描述** | **示例** |'
- en: '| --- | --- | --- |'
  id: totrans-20
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| “nearest” | use the value at the boundary | [1 2 3]->[1 1 2 3 3] |'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| “nearest” | 使用边界处的值 | [1 2 3]->[1 1 2 3 3] |'
- en: '| “wrap” | periodically replicate the array | [1 2 3]->[3 1 2 3 1] |'
  id: totrans-22
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| “wrap” | 周期性地复制数组 | [1 2 3]->[3 1 2 3 1] |'
- en: '| “reflect” | reflect the array at the boundary | [1 2 3]->[1 1 2 3 3] |'
  id: totrans-23
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| “reflect” | 在边界处反射数组 | [1 2 3]->[1 1 2 3 3] |'
- en: '| “mirror” | mirror the array at the boundary | [1 2 3]->[2 1 2 3 2] |'
  id: totrans-24
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| “mirror” | 在边界处镜像数组 | [1 2 3]->[2 1 2 3 2] |'
- en: '| “constant” | use a constant value, default is 0.0 | [1 2 3]->[0 1 2 3 0]
    |'
  id: totrans-25
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| “constant” | 使用常量值，默认为 0.0 | [1 2 3]->[0 1 2 3 0] |'
- en: 'The following synonyms are also supported for consistency with the interpolation
    routines:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持与插值例程的一致性，还支持以下同义词：
- en: '| **mode** | **description** |'
  id: totrans-27
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| **模式** | **描述** |'
- en: '| --- | --- |'
  id: totrans-28
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| “grid-constant” | equivalent to “constant”* |'
  id: totrans-29
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| “grid-constant” | 等同于 “constant”* |'
- en: '| “grid-mirror” | equivalent to “reflect” |'
  id: totrans-30
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| “grid-mirror” | 等同于 “reflect” |'
- en: '| “grid-wrap” | equivalent to “wrap” |'
  id: totrans-31
  prefs:
  - PREF_BQ
  type: TYPE_TB
  zh: '| “grid-wrap” | 等同于 “wrap” |'
- en: '* “grid-constant” and “constant” are equivalent for filtering operations, but
    have different behavior in interpolation functions. For API consistency, the filtering
    functions accept either name.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '* “grid-constant” 和 “constant” 在滤波操作中等效，但在插值函数中具有不同的行为。为了 API 的一致性，滤波函数接受任一名称。'
- en: The “constant” mode is special since it needs an additional parameter to specify
    the constant value that should be used.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: “constant” 模式是特殊的，因为它需要额外的参数来指定应使用的常量值。
- en: Note that modes mirror and reflect differ only in whether the sample at the
    boundary is repeated upon reflection. For mode mirror, the point of symmetry is
    exactly at the final sample, so that value is not repeated. This mode is also
    known as whole-sample symmetric since the point of symmetry falls on the final
    sample. Similarly, reflect is often referred to as half-sample symmetric as the
    point of symmetry is half a sample beyond the array boundary.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，mirror 和 reflect 模式的区别仅在于边界处的样本是否在反射时重复。对于 mirror 模式，对称点正好位于最后一个样本，因此该值不重复。这种模式也被称为整样本对称，因为对称点位于最后一个样本上。类似地，reflect
    常被称为半样本对称，因为对称点位于数组边界的半样本之外。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The easiest way to implement such boundary conditions would be to copy the data
    to a larger array and extend the data at the borders according to the boundary
    conditions. For large arrays and large filter kernels, this would be very memory
    consuming, and the functions described below, therefore, use a different approach
    that does not require allocating large temporary buffers.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这种边界条件的最简单方法是将数据复制到一个更大的数组中，并根据边界条件在边界处扩展数据。对于大数组和大滤波器核，这将非常消耗内存，因此下面描述的函数使用一种不需要分配大临时缓冲区的不同方法。
- en: Correlation and convolution
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相关和卷积
- en: The [`correlate1d`](../reference/generated/scipy.ndimage.correlate1d.html#scipy.ndimage.correlate1d
    "scipy.ndimage.correlate1d") function calculates a 1-D correlation along the given
    axis. The lines of the array along the given axis are correlated with the given
    *weights*. The *weights* parameter must be a 1-D sequence of numbers.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`correlate1d`](../reference/generated/scipy.ndimage.correlate1d.html#scipy.ndimage.correlate1d
    "scipy.ndimage.correlate1d")沿指定轴计算1-D相关。数组沿指定轴的行与给定的*权重*相关。*权重*参数必须是一个1-D数字序列。
- en: The function [`correlate`](../reference/generated/scipy.ndimage.correlate.html#scipy.ndimage.correlate
    "scipy.ndimage.correlate") implements multidimensional correlation of the input
    array with a given kernel.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`correlate`](../reference/generated/scipy.ndimage.correlate.html#scipy.ndimage.correlate
    "scipy.ndimage.correlate")实现输入数组与给定核的多维相关。
- en: The [`convolve1d`](../reference/generated/scipy.ndimage.convolve1d.html#scipy.ndimage.convolve1d
    "scipy.ndimage.convolve1d") function calculates a 1-D convolution along the given
    axis. The lines of the array along the given axis are convoluted with the given
    *weights*. The *weights* parameter must be a 1-D sequence of numbers.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`convolve1d`](../reference/generated/scipy.ndimage.convolve1d.html#scipy.ndimage.convolve1d
    "scipy.ndimage.convolve1d")沿指定轴计算1-D卷积。数组沿指定轴的行与给定的*权重*进行卷积。*权重*参数必须是一个1-D数字序列。
- en: The function [`convolve`](../reference/generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve
    "scipy.ndimage.convolve") implements multidimensional convolution of the input
    array with a given kernel.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`convolve`](../reference/generated/scipy.ndimage.convolve.html#scipy.ndimage.convolve
    "scipy.ndimage.convolve")实现输入数组与给定核的多维卷积。
- en: Note
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'A convolution is essentially a correlation after mirroring the kernel. As a
    result, the *origin* parameter behaves differently than in the case of a correlation:
    the results is shifted in the opposite direction.'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 卷积本质上是在镜像核之后进行相关。因此，*origin*参数的行为与相关的情况不同：结果向相反方向移动。
- en: '### Smoothing filters'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '### 平滑滤波器'
- en: The [`gaussian_filter1d`](../reference/generated/scipy.ndimage.gaussian_filter1d.html#scipy.ndimage.gaussian_filter1d
    "scipy.ndimage.gaussian_filter1d") function implements a 1-D Gaussian filter.
    The standard deviation of the Gaussian filter is passed through the parameter
    *sigma*. Setting *order* = 0 corresponds to convolution with a Gaussian kernel.
    An order of 1, 2, or 3 corresponds to convolution with the first, second, or third
    derivatives of a Gaussian. Higher-order derivatives are not implemented.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`gaussian_filter1d`](../reference/generated/scipy.ndimage.gaussian_filter1d.html#scipy.ndimage.gaussian_filter1d
    "scipy.ndimage.gaussian_filter1d")实现1-D高斯滤波器。高斯滤波器的标准差通过参数*sigma*传递。将*order* =
    0设置为与高斯核的卷积。顺序为1、2或3对应于与高斯的一、二或三阶导数的卷积。高阶导数未实现。
- en: The [`gaussian_filter`](../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter
    "scipy.ndimage.gaussian_filter") function implements a multidimensional Gaussian
    filter. The standard deviations of the Gaussian filter along each axis are passed
    through the parameter *sigma* as a sequence or numbers. If *sigma* is not a sequence
    but a single number, the standard deviation of the filter is equal along all directions.
    The order of the filter can be specified separately for each axis. An order of
    0 corresponds to convolution with a Gaussian kernel. An order of 1, 2, or 3 corresponds
    to convolution with the first, second, or third derivatives of a Gaussian. Higher-order
    derivatives are not implemented. The *order* parameter must be a number, to specify
    the same order for all axes, or a sequence of numbers to specify a different order
    for each axis. The example below shows the filter applied on test data with different
    values of *sigma*. The *order* parameter is kept at 0.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`gaussian_filter`](../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter
    "scipy.ndimage.gaussian_filter") 函数实现了多维高斯滤波器。高斯滤波器沿着每个轴的标准差通过参数*sigma*作为数字序列传递。如果*sigma*不是一个序列而是一个单一数字，则滤波器的标准差在所有方向上都相等。滤波器的顺序可以分别为每个轴指定。顺序为0对应于与高斯核的卷积。顺序为1、2或3对应于与高斯的一阶、二阶或三阶导数的卷积。高阶导数未实现。*order*参数必须是一个数字，以指定所有轴的相同顺序，或者是一个数字序列，以指定每个轴的不同顺序。下面的示例显示了在具有不同*sigma*值的测试数据上应用的滤波器。*order*参数保持为0。'
- en: '![" "](../Images/1707e05f56813d14ba8e33db91ee768a.png)'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![" "](../Images/1707e05f56813d14ba8e33db91ee768a.png)'
- en: Note
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The multidimensional filter is implemented as a sequence of 1-D Gaussian filters.
    The intermediate arrays are stored in the same data type as the output. Therefore,
    for output types with a lower precision, the results may be imprecise because
    intermediate results may be stored with insufficient precision. This can be prevented
    by specifying a more precise output type.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多维滤波器被实现为一系列1-D高斯滤波器。中间数组以与输出相同的数据类型存储。因此，对于精度较低的输出类型，结果可能不精确，因为中间结果可能以不足的精度存储。可以通过指定更精确的输出类型来防止这种情况。
- en: The [`uniform_filter1d`](../reference/generated/scipy.ndimage.uniform_filter1d.html#scipy.ndimage.uniform_filter1d
    "scipy.ndimage.uniform_filter1d") function calculates a 1-D uniform filter of
    the given *size* along the given axis.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`uniform_filter1d`](../reference/generated/scipy.ndimage.uniform_filter1d.html#scipy.ndimage.uniform_filter1d
    "scipy.ndimage.uniform_filter1d") 函数沿着给定轴计算给定*size*的1-D均匀滤波器。'
- en: The [`uniform_filter`](../reference/generated/scipy.ndimage.uniform_filter.html#scipy.ndimage.uniform_filter
    "scipy.ndimage.uniform_filter") implements a multidimensional uniform filter.
    The sizes of the uniform filter are given for each axis as a sequence of integers
    by the *size* parameter. If *size* is not a sequence, but a single number, the
    sizes along all axes are assumed to be equal.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`uniform_filter`](../reference/generated/scipy.ndimage.uniform_filter.html#scipy.ndimage.uniform_filter
    "scipy.ndimage.uniform_filter") 实现了多维均匀滤波器。均匀滤波器的大小由*size*参数作为整数序列给出，每个轴一个。如果*size*不是一个序列，而是一个单一数字，则假定所有轴上的大小相等。'
- en: Note
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The multidimensional filter is implemented as a sequence of 1-D uniform filters.
    The intermediate arrays are stored in the same data type as the output. Therefore,
    for output types with a lower precision, the results may be imprecise because
    intermediate results may be stored with insufficient precision. This can be prevented
    by specifying a more precise output type.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多维滤波器被实现为一系列1-D均匀滤波器。中间数组以与输出相同的数据类型存储。因此，对于精度较低的输出类型，结果可能不精确，因为中间结果可能以不足的精度存储。可以通过指定更精确的输出类型来防止这种情况。
- en: Filters based on order statistics
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于顺序统计的滤波器
- en: The [`minimum_filter1d`](../reference/generated/scipy.ndimage.minimum_filter1d.html#scipy.ndimage.minimum_filter1d
    "scipy.ndimage.minimum_filter1d") function calculates a 1-D minimum filter of
    the given *size* along the given axis.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`minimum_filter1d`](../reference/generated/scipy.ndimage.minimum_filter1d.html#scipy.ndimage.minimum_filter1d
    "scipy.ndimage.minimum_filter1d") 函数沿着给定轴计算给定*size*的1-D最小值滤波器。'
- en: The [`maximum_filter1d`](../reference/generated/scipy.ndimage.maximum_filter1d.html#scipy.ndimage.maximum_filter1d
    "scipy.ndimage.maximum_filter1d") function calculates a 1-D maximum filter of
    the given *size* along the given axis.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`maximum_filter1d`](../reference/generated/scipy.ndimage.maximum_filter1d.html#scipy.ndimage.maximum_filter1d
    "scipy.ndimage.maximum_filter1d") 函数沿着给定轴计算给定*size*的1-D最大值滤波器。'
- en: The [`minimum_filter`](../reference/generated/scipy.ndimage.minimum_filter.html#scipy.ndimage.minimum_filter
    "scipy.ndimage.minimum_filter") function calculates a multidimensional minimum
    filter. Either the sizes of a rectangular kernel or the footprint of the kernel
    must be provided. The *size* parameter, if provided, must be a sequence of sizes
    or a single number, in which case the size of the filter is assumed to be equal
    along each axis. The *footprint*, if provided, must be an array that defines the
    shape of the kernel by its non-zero elements.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`minimum_filter`](../reference/generated/scipy.ndimage.minimum_filter.html#scipy.ndimage.minimum_filter
    "scipy.ndimage.minimum_filter") 函数用于计算多维最小值滤波器。必须提供矩形核的尺寸或核的足迹。如果提供了*size*参数，必须是一系列尺寸或单个数字，此时滤波器沿每个轴的尺寸被假定相等。如果提供了*footprint*，必须是一个定义核形状的数组，其非零元素定义了核的形状。'
- en: The [`maximum_filter`](../reference/generated/scipy.ndimage.maximum_filter.html#scipy.ndimage.maximum_filter
    "scipy.ndimage.maximum_filter") function calculates a multidimensional maximum
    filter. Either the sizes of a rectangular kernel or the footprint of the kernel
    must be provided. The *size* parameter, if provided, must be a sequence of sizes
    or a single number, in which case the size of the filter is assumed to be equal
    along each axis. The *footprint*, if provided, must be an array that defines the
    shape of the kernel by its non-zero elements.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`maximum_filter`](../reference/generated/scipy.ndimage.maximum_filter.html#scipy.ndimage.maximum_filter
    "scipy.ndimage.maximum_filter") 函数用于计算多维最大值滤波器。必须提供矩形核的尺寸或核的足迹。如果提供了*size*参数，必须是一系列尺寸或单个数字，此时滤波器沿每个轴的尺寸被假定相等。如果提供了*footprint*，必须是一个定义核形状的数组，其非零元素定义了核的形状。'
- en: The [`rank_filter`](../reference/generated/scipy.ndimage.rank_filter.html#scipy.ndimage.rank_filter
    "scipy.ndimage.rank_filter") function calculates a multidimensional rank filter.
    The *rank* may be less than zero, i.e., *rank* = -1 indicates the largest element.
    Either the sizes of a rectangular kernel or the footprint of the kernel must be
    provided. The *size* parameter, if provided, must be a sequence of sizes or a
    single number, in which case the size of the filter is assumed to be equal along
    each axis. The *footprint*, if provided, must be an array that defines the shape
    of the kernel by its non-zero elements.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`rank_filter`](../reference/generated/scipy.ndimage.rank_filter.html#scipy.ndimage.rank_filter
    "scipy.ndimage.rank_filter") 函数用于计算多维等级滤波器。*rank* 可以小于零，例如*rank* = -1表示最大元素。必须提供矩形核的尺寸或核的足迹。如果提供了*size*参数，必须是一系列尺寸或单个数字，此时滤波器沿每个轴的尺寸被假定相等。如果提供了*footprint*，必须是一个定义核形状的数组，其非零元素定义了核的形状。'
- en: The [`percentile_filter`](../reference/generated/scipy.ndimage.percentile_filter.html#scipy.ndimage.percentile_filter
    "scipy.ndimage.percentile_filter") function calculates a multidimensional percentile
    filter. The *percentile* may be less than zero, i.e., *percentile* = -20 equals
    *percentile* = 80\. Either the sizes of a rectangular kernel or the footprint
    of the kernel must be provided. The *size* parameter, if provided, must be a sequence
    of sizes or a single number, in which case the size of the filter is assumed to
    be equal along each axis. The *footprint*, if provided, must be an array that
    defines the shape of the kernel by its non-zero elements.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`percentile_filter`](../reference/generated/scipy.ndimage.percentile_filter.html#scipy.ndimage.percentile_filter
    "scipy.ndimage.percentile_filter") 函数用于计算多维百分位数滤波器。*percentile* 可以小于零，例如*percentile*
    = -20 等同于 *percentile* = 80。必须提供矩形核的尺寸或核的足迹。如果提供了*size*参数，必须是一系列尺寸或单个数字，此时滤波器沿每个轴的尺寸被假定相等。如果提供了*footprint*，必须是一个定义核形状的数组，其非零元素定义了核的形状。'
- en: The [`median_filter`](../reference/generated/scipy.ndimage.median_filter.html#scipy.ndimage.median_filter
    "scipy.ndimage.median_filter") function calculates a multidimensional median filter.
    Either the sizes of a rectangular kernel or the footprint of the kernel must be
    provided. The *size* parameter, if provided, must be a sequence of sizes or a
    single number, in which case the size of the filter is assumed to be equal along
    each axis. The *footprint* if provided, must be an array that defines the shape
    of the kernel by its non-zero elements.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`median_filter`](../reference/generated/scipy.ndimage.median_filter.html#scipy.ndimage.median_filter
    "scipy.ndimage.median_filter") 函数用于计算多维中值滤波器。必须提供矩形核的尺寸或核的足迹。如果提供了*size*参数，必须是一系列尺寸或单个数字，此时滤波器沿每个轴的尺寸被假定相等。如果提供了*footprint*，必须是一个定义核形状的数组，其非零元素定义了核的形状。'
- en: Derivatives
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导数
- en: 'Derivative filters can be constructed in several ways. The function [`gaussian_filter1d`](../reference/generated/scipy.ndimage.gaussian_filter1d.html#scipy.ndimage.gaussian_filter1d
    "scipy.ndimage.gaussian_filter1d"), described in [Smoothing filters](#ndimage-filter-functions-smoothing),
    can be used to calculate derivatives along a given axis using the *order* parameter.
    Other derivative filters are the Prewitt and Sobel filters:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 滤波器可以通过几种方法构造。函数[`gaussian_filter1d`](../reference/generated/scipy.ndimage.gaussian_filter1d.html#scipy.ndimage.gaussian_filter1d
    "scipy.ndimage.gaussian_filter1d")，描述于[平滑滤波器](#ndimage-filter-functions-smoothing)，可用于沿指定轴使用*order*参数计算导数。其他导数滤波器包括Prewitt和Sobel滤波器：
- en: The [`prewitt`](../reference/generated/scipy.ndimage.prewitt.html#scipy.ndimage.prewitt
    "scipy.ndimage.prewitt") function calculates a derivative along the given axis.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`prewitt`](../reference/generated/scipy.ndimage.prewitt.html#scipy.ndimage.prewitt
    "scipy.ndimage.prewitt")计算沿给定轴的导数。
- en: The [`sobel`](../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel
    "scipy.ndimage.sobel") function calculates a derivative along the given axis.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`sobel`](../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel
    "scipy.ndimage.sobel")计算沿给定轴的导数。
- en: The Laplace filter is calculated by the sum of the second derivatives along
    all axes. Thus, different Laplace filters can be constructed using different second-derivative
    functions. Therefore, we provide a general function that takes a function argument
    to calculate the second derivative along a given direction.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Laplace滤波器通过所有轴上的二阶导数之和计算。因此，可以使用不同的二阶导数函数构造不同的Laplace滤波器。因此，我们提供了一个通用函数，该函数接受函数参数以计算给定方向上的二阶导数。
- en: The function [`generic_laplace`](../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace
    "scipy.ndimage.generic_laplace") calculates a Laplace filter using the function
    passed through `derivative2` to calculate second derivatives. The function `derivative2`
    should have the following signature
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`generic_laplace`](../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace
    "scipy.ndimage.generic_laplace")使用通过`derivative2`传递的函数计算二阶导数来计算拉普拉斯滤波器。函数`derivative2`应具有以下签名
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It should calculate the second derivative along the dimension *axis*. If *output*
    is not `None`, it should use that for the output and return `None`, otherwise
    it should return the result. *mode*, *cval* have the usual meaning.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应计算沿尺寸*axis*的二阶导数。如果*output*不为`None`，则应将其用于输出并返回`None`，否则应返回结果。*mode*，*cval*具有通常的意义。
- en: The *extra_arguments* and *extra_keywords* arguments can be used to pass a tuple
    of extra arguments and a dictionary of named arguments that are passed to `derivative2`
    at each call.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*extra_arguments*和*extra_keywords*参数可用于传递每次调用`derivative2`时传递给其的额外参数元组和命名参数字典。'
- en: For example
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如
- en: '[PRE7]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: To demonstrate the use of the *extra_arguments* argument, we could do
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了演示*extra_arguments*参数的使用，我们可以执行
- en: '[PRE8]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: or
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE9]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following two functions are implemented using [`generic_laplace`](../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace
    "scipy.ndimage.generic_laplace") by providing appropriate functions for the second-derivative
    function:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 通过提供适当的二阶导数函数，以下两个函数使用[`generic_laplace`](../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace
    "scipy.ndimage.generic_laplace")实现：
- en: The function [`laplace`](../reference/generated/scipy.ndimage.laplace.html#scipy.ndimage.laplace
    "scipy.ndimage.laplace") calculates the Laplace using discrete differentiation
    for the second derivative (i.e., convolution with `[1, -2, 1]`).
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`laplace`](../reference/generated/scipy.ndimage.laplace.html#scipy.ndimage.laplace
    "scipy.ndimage.laplace")使用离散差分计算二阶导数的拉普拉斯（即与`[1, -2, 1]`卷积）。
- en: The function [`gaussian_laplace`](../reference/generated/scipy.ndimage.gaussian_laplace.html#scipy.ndimage.gaussian_laplace
    "scipy.ndimage.gaussian_laplace") calculates the Laplace filter using [`gaussian_filter`](../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter
    "scipy.ndimage.gaussian_filter") to calculate the second derivatives. The standard
    deviations of the Gaussian filter along each axis are passed through the parameter
    *sigma* as a sequence or numbers. If *sigma* is not a sequence but a single number,
    the standard deviation of the filter is equal along all directions.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`gaussian_laplace`](../reference/generated/scipy.ndimage.gaussian_laplace.html#scipy.ndimage.gaussian_laplace
    "scipy.ndimage.gaussian_laplace")使用[`gaussian_filter`](../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter
    "scipy.ndimage.gaussian_filter")计算二阶导数的拉普拉斯滤波器。通过参数*sigma*作为数字序列传递高斯滤波器沿每个轴的标准差。如果*sigma*不是序列而是单个数字，则滤波器的标准差在所有方向上是相等的。
- en: The gradient magnitude is defined as the square root of the sum of the squares
    of the gradients in all directions. Similar to the generic Laplace function, there
    is a [`generic_gradient_magnitude`](../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude
    "scipy.ndimage.generic_gradient_magnitude") function that calculates the gradient
    magnitude of an array.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 梯度幅度定义为所有方向梯度平方和的平方根。与通用拉普拉斯函数类似，有一个[`generic_gradient_magnitude`](../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude
    "scipy.ndimage.generic_gradient_magnitude")函数用于计算数组的梯度幅度。
- en: The function [`generic_gradient_magnitude`](../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude
    "scipy.ndimage.generic_gradient_magnitude") calculates a gradient magnitude using
    the function passed through `derivative` to calculate first derivatives. The function
    `derivative` should have the following signature
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`generic_gradient_magnitude`](../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude
    "scipy.ndimage.generic_gradient_magnitude")使用通过`derivative`计算一阶导数的函数来计算梯度幅度。函数`derivative`应具有以下签名
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: It should calculate the derivative along the dimension *axis*. If *output* is
    not `None`, it should use that for the output and return `None`, otherwise it
    should return the result. *mode*, *cval* have the usual meaning.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它应计算维度*axis*上的导数。如果*output*不是`None`，则应用于输出并返回`None`，否则应返回结果。*mode*，*cval*具有通常的意义。
- en: The *extra_arguments* and *extra_keywords* arguments can be used to pass a tuple
    of extra arguments and a dictionary of named arguments that are passed to *derivative*
    at each call.
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*extra_arguments*和*extra_keywords*参数可用于传递额外参数的元组和传递给*derivative*的命名参数字典。'
- en: For example, the [`sobel`](../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel
    "scipy.ndimage.sobel") function fits the required signature
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，[`sobel`](../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel
    "scipy.ndimage.sobel")函数符合所需的签名
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See the documentation of [`generic_laplace`](../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace
    "scipy.ndimage.generic_laplace") for examples of using the *extra_arguments* and
    *extra_keywords* arguments.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 查看[`generic_laplace`](../reference/generated/scipy.ndimage.generic_laplace.html#scipy.ndimage.generic_laplace
    "scipy.ndimage.generic_laplace")的文档以获取使用*extra_arguments*和*extra_keywords*参数的示例。
- en: The [`sobel`](../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel
    "scipy.ndimage.sobel") and [`prewitt`](../reference/generated/scipy.ndimage.prewitt.html#scipy.ndimage.prewitt
    "scipy.ndimage.prewitt") functions fit the required signature and can, therefore,
    be used directly with [`generic_gradient_magnitude`](../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude
    "scipy.ndimage.generic_gradient_magnitude").
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 函数[`sobel`](../reference/generated/scipy.ndimage.sobel.html#scipy.ndimage.sobel
    "scipy.ndimage.sobel")和[`prewitt`](../reference/generated/scipy.ndimage.prewitt.html#scipy.ndimage.prewitt
    "scipy.ndimage.prewitt")函数符合所需的签名，因此可以直接与[`generic_gradient_magnitude`](../reference/generated/scipy.ndimage.generic_gradient_magnitude.html#scipy.ndimage.generic_gradient_magnitude
    "scipy.ndimage.generic_gradient_magnitude")一起使用。
- en: The function [`gaussian_gradient_magnitude`](../reference/generated/scipy.ndimage.gaussian_gradient_magnitude.html#scipy.ndimage.gaussian_gradient_magnitude
    "scipy.ndimage.gaussian_gradient_magnitude") calculates the gradient magnitude
    using [`gaussian_filter`](../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter
    "scipy.ndimage.gaussian_filter") to calculate the first derivatives. The standard
    deviations of the Gaussian filter along each axis are passed through the parameter
    *sigma* as a sequence or numbers. If *sigma* is not a sequence but a single number,
    the standard deviation of the filter is equal along all directions.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`gaussian_gradient_magnitude`](../reference/generated/scipy.ndimage.gaussian_gradient_magnitude.html#scipy.ndimage.gaussian_gradient_magnitude
    "scipy.ndimage.gaussian_gradient_magnitude")使用[`gaussian_filter`](../reference/generated/scipy.ndimage.gaussian_filter.html#scipy.ndimage.gaussian_filter
    "scipy.ndimage.gaussian_filter")来计算梯度幅度。高斯滤波器沿每个轴的标准偏差通过参数*sigma*作为数字序列传递。如果*sigma*不是序列而是一个单一数字，则滤波器的标准偏差沿所有方向均相等。
- en: '### Generic filter functions'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '### 通用滤波函数'
- en: To implement filter functions, generic functions can be used that accept a callable
    object that implements the filtering operation. The iteration over the input and
    output arrays is handled by these generic functions, along with such details as
    the implementation of the boundary conditions. Only a callable object implementing
    a callback function that does the actual filtering work must be provided. The
    callback function can also be written in C and passed using a [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.12)") (see [Extending scipy.ndimage in C](#ndimage-ccallbacks)
    for more information).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现滤波函数，可以使用通用函数，它们接受一个实现滤波操作的可调用对象。这些通用函数处理输入和输出数组的迭代，以及边界条件的实现等详细信息。只需提供一个实现实际滤波工作的回调函数的可调用对象。回调函数也可以用C语言编写，并使用[`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.12)")传递（有关更多信息，请参见[在C中扩展scipy.ndimage](#ndimage-ccallbacks)）。
- en: 'The [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d") function implements a generic 1-D filter function,
    where the actual filtering operation must be supplied as a python function (or
    other callable object). The [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d") function iterates over the lines of an array
    and calls `function` at each line. The arguments that are passed to `function`
    are 1-D arrays of the `numpy.float64` type. The first contains the values of the
    current line. It is extended at the beginning and the end, according to the *filter_size*
    and *origin* arguments. The second array should be modified in-place to provide
    the output values of the line. For example, consider a correlation along one dimension:'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d")函数实现了一个通用的一维滤波函数，其中实际的滤波操作必须作为Python函数（或其他可调用对象）提供。[`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d")函数迭代数组的行，并在每行调用`function`。传递给`function`的参数是`numpy.float64`类型的一维数组。第一个包含当前行的值。根据*filter_size*和*origin*参数，在开头和结尾进行扩展。第二个数组应该就地修改，以提供行的输出值。例如，考虑沿一个维度的相关性：'
- en: '[PRE12]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The same operation can be implemented using [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d"), as follows:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用[`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d")函数可以实现相同的操作，如下所示：
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, the origin of the kernel was (by default) assumed to be in the middle
    of the filter of length 3\. Therefore, each input line had been extended by one
    value at the beginning and at the end, before the function was called.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，默认情况下，内核的起源被假定为长度为3的滤波器的中间。因此，在调用函数之前，每个输入行都在开始和结束时扩展了一个值。
- en: Optionally, extra arguments can be defined and passed to the filter function.
    The *extra_arguments* and *extra_keywords* arguments can be used to pass a tuple
    of extra arguments and/or a dictionary of named arguments that are passed to derivative
    at each call. For example, we can pass the parameters of our filter as an argument
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以选择定义并传递额外参数给滤波器函数。*extra_arguments*和*extra_keywords*参数可用于传递一组额外参数的元组和/或传递给每次调用的命名参数的字典。例如，我们可以将我们的滤波器的参数作为一个参数传递
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: or
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE15]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The [`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter") function implements a generic filter function,
    where the actual filtering operation must be supplied as a python function (or
    other callable object). The [`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter") function iterates over the array and calls `function`
    at each element. The argument of `function` is a 1-D array of the `numpy.float64`
    type that contains the values around the current element that are within the footprint
    of the filter. The function should return a single value that can be converted
    to a double precision number. For example, consider a correlation:'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter")函数实现了一个通用的滤波器函数，其中实际的过滤操作必须作为Python函数（或其他可调用对象）提供。[`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter")函数迭代数组并在每个元素上调用`function`。`function`的参数是一个1-D数组，类型为`numpy.float64`，包含在滤波器足迹内的当前元素周围的值。函数应返回一个可以转换为双精度数的单个值。例如，考虑一个相关性：'
- en: '[PRE16]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The same operation can be implemented using *generic_filter*, as follows:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用*generic_filter*执行相同的操作，如下所示：
- en: '[PRE17]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, a kernel footprint was specified that contains only two elements. Therefore,
    the filter function receives a buffer of length equal to two, which was multiplied
    with the proper weights and the result summed.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，指定了一个仅包含两个元素的核足迹。因此，过滤器函数接收到一个长度等于两个的缓冲区，该缓冲区与适当的权重相乘并求和得到结果。
- en: When calling [`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter"), either the sizes of a rectangular kernel or the
    footprint of the kernel must be provided. The *size* parameter, if provided, must
    be a sequence of sizes or a single number, in which case the size of the filter
    is assumed to be equal along each axis. The *footprint*, if provided, must be
    an array that defines the shape of the kernel by its non-zero elements.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当调用[`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter")函数时，必须提供矩形核的大小或核的足迹。如果提供了*size*参数，则必须是大小序列或单个数字，其中情况下假定过滤器沿每个轴的大小相等。如果提供了*footprint*参数，则必须是一个数组，通过其中的非零元素定义核的形状。
- en: Optionally, extra arguments can be defined and passed to the filter function.
    The *extra_arguments* and *extra_keywords* arguments can be used to pass a tuple
    of extra arguments and/or a dictionary of named arguments that are passed to derivative
    at each call. For example, we can pass the parameters of our filter as an argument
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以选择定义并传递额外参数给滤波器函数。*extra_arguments*和*extra_keywords*参数可用于传递一组额外参数的元组和/或传递给每次调用的命名参数的字典。例如，我们可以将我们的滤波器的参数作为一个参数传递
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: or
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'These functions iterate over the lines or elements starting at the last axis,
    i.e., the last index changes the fastest. This order of iteration is guaranteed
    for the case that it is important to adapt the filter depending on spatial location.
    Here is an example of using a class that implements the filter and keeps track
    of the current coordinates while iterating. It performs the same filter operation
    as described above for [`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter"), but additionally prints the current coordinates:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数按照从最后一个轴开始的行或元素进行迭代，即最后一个索引变化最快。对于重要的情况，这种迭代顺序是有保证的，以便根据空间位置调整滤波器。以下是使用实现滤波器并在迭代时跟踪当前坐标的类的示例。它执行与上述[`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter")相同的滤波操作，但还打印当前坐标：
- en: '[PRE20]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For the [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d") function, the same approach works, except that
    this function does not iterate over the axis that is being filtered. The example
    for [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d") then becomes this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d")函数，相同的方法适用，只是这个函数不会迭代正在被过滤的轴。然后[`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d")的示例如下：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Fourier domain filters
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 傅里叶域滤波器
- en: The functions described in this section perform filtering operations in the
    Fourier domain. Thus, the input array of such a function should be compatible
    with an inverse Fourier transform function, such as the functions from the [`numpy.fft`](https://numpy.org/devdocs/reference/routines.fft.html#module-numpy.fft
    "(in NumPy v2.0.dev0)") module. We, therefore, have to deal with arrays that may
    be the result of a real or a complex Fourier transform. In the case of a real
    Fourier transform, only half of the of the symmetric complex transform is stored.
    Additionally, it needs to be known what the length of the axis was that was transformed
    by the real fft. The functions described here provide a parameter *n* that, in
    the case of a real transform, must be equal to the length of the real transform
    axis before transformation. If this parameter is less than zero, it is assumed
    that the input array was the result of a complex Fourier transform. The parameter
    *axis* can be used to indicate along which axis the real transform was executed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述的函数在傅里叶域执行滤波操作。因此，此类函数的输入数组应与逆傅里叶变换函数兼容，例如[`numpy.fft`](https://numpy.org/devdocs/reference/routines.fft.html#module-numpy.fft
    "(in NumPy v2.0.dev0)")模块中的函数。因此，我们需要处理可能是实部或复数傅里叶变换结果的数组。在实傅里叶变换的情况下，仅存储对称复数变换的一半。此外，需要知道在实fft变换之前被转换的轴的长度。本节描述的函数提供了一个*n*参数，在实变换的情况下，必须等于变换之前的实变换轴的长度。如果此参数小于零，则假定输入数组是复数傅里叶变换的结果。*axis*参数可用于指示执行实变换的轴。
- en: The [`fourier_shift`](../reference/generated/scipy.ndimage.fourier_shift.html#scipy.ndimage.fourier_shift
    "scipy.ndimage.fourier_shift") function multiplies the input array with the multidimensional
    Fourier transform of a shift operation for the given shift. The *shift* parameter
    is a sequence of shifts for each dimension or a single value for all dimensions.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fourier_shift`](../reference/generated/scipy.ndimage.fourier_shift.html#scipy.ndimage.fourier_shift
    "scipy.ndimage.fourier_shift")函数将输入数组乘以给定移位操作的多维傅里叶变换。*shift*参数是每个维度的移位序列或所有维度的单个值。'
- en: The [`fourier_gaussian`](../reference/generated/scipy.ndimage.fourier_gaussian.html#scipy.ndimage.fourier_gaussian
    "scipy.ndimage.fourier_gaussian") function multiplies the input array with the
    multidimensional Fourier transform of a Gaussian filter with given standard deviations
    *sigma*. The *sigma* parameter is a sequence of values for each dimension or a
    single value for all dimensions.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fourier_gaussian`](../reference/generated/scipy.ndimage.fourier_gaussian.html#scipy.ndimage.fourier_gaussian
    "scipy.ndimage.fourier_gaussian")函数将输入数组乘以具有给定标准差*sigma*的高斯滤波器的多维傅里叶变换。*sigma*参数是每个维度的值序列或所有维度的单个值。'
- en: The [`fourier_uniform`](../reference/generated/scipy.ndimage.fourier_uniform.html#scipy.ndimage.fourier_uniform
    "scipy.ndimage.fourier_uniform") function multiplies the input array with the
    multidimensional Fourier transform of a uniform filter with given sizes *size*.
    The *size* parameter is a sequence of values for each dimension or a single value
    for all dimensions.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fourier_uniform`](../reference/generated/scipy.ndimage.fourier_uniform.html#scipy.ndimage.fourier_uniform
    "scipy.ndimage.fourier_uniform")函数将输入数组乘以具有给定大小*size*的均匀滤波器的多维傅里叶变换。*size*参数是每个维度的值序列或所有维度的单个值。'
- en: 'The [`fourier_ellipsoid`](../reference/generated/scipy.ndimage.fourier_ellipsoid.html#scipy.ndimage.fourier_ellipsoid
    "scipy.ndimage.fourier_ellipsoid") function multiplies the input array with the
    multidimensional Fourier transform of an elliptically-shaped filter with given
    sizes *size*. The *size* parameter is a sequence of values for each dimension
    or a single value for all dimensions. This function is only implemented for dimensions
    1, 2, and 3.  ## Interpolation functions'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`fourier_ellipsoid`](../reference/generated/scipy.ndimage.fourier_ellipsoid.html#scipy.ndimage.fourier_ellipsoid
    "scipy.ndimage.fourier_ellipsoid") 函数将输入数组与给定尺寸*size*的椭球形滤波器的多维傅里叶变换相乘。*size*参数是每个维度的值序列或所有维度的单个值。此函数仅实现维度为1、2和3的情况。##
    插值函数'
- en: This section describes various interpolation functions that are based on B-spline
    theory. A good introduction to B-splines can be found in [[1]](#id8) with detailed
    algorithms for image interpolation given in [[5]](#id12).
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述基于B样条理论的各种插值函数。关于B样条的良好介绍可参见[[1]](#id8)，图像插值的详细算法见[[5]](#id12)。
- en: Spline pre-filters
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 样条预滤波器
- en: 'Interpolation using splines of an order larger than 1 requires a pre-filtering
    step. The interpolation functions described in section [Interpolation functions](#ndimage-interpolation)
    apply pre-filtering by calling [`spline_filter`](../reference/generated/scipy.ndimage.spline_filter.html#scipy.ndimage.spline_filter
    "scipy.ndimage.spline_filter"), but they can be instructed not to do this by setting
    the *prefilter* keyword equal to False. This is useful if more than one interpolation
    operation is done on the same array. In this case, it is more efficient to do
    the pre-filtering only once and use a pre-filtered array as the input of the interpolation
    functions. The following two functions implement the pre-filtering:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大于1阶的样条进行插值需要预滤波步骤。在[section [Interpolation functions](#ndimage-interpolation)]中描述的插值函数通过调用[`spline_filter`](../reference/generated/scipy.ndimage.spline_filter.html#scipy.ndimage.spline_filter
    "scipy.ndimage.spline_filter")应用预滤波，但可以通过将*prefilter*关键字设置为False来指示不执行此操作。如果在同一数组上执行多次插值操作，则这很有用。在这种情况下，只需进行一次预滤波并使用预滤波后的数组作为插值函数的输入更有效。以下两个函数实现预滤波：
- en: The [`spline_filter1d`](../reference/generated/scipy.ndimage.spline_filter1d.html#scipy.ndimage.spline_filter1d
    "scipy.ndimage.spline_filter1d") function calculates a 1-D spline filter along
    the given axis. An output array can optionally be provided. The order of the spline
    must be larger than 1 and less than 6.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`spline_filter1d`](../reference/generated/scipy.ndimage.spline_filter1d.html#scipy.ndimage.spline_filter1d
    "scipy.ndimage.spline_filter1d") 函数沿给定轴计算1-D样条滤波器。可选择提供输出数组。样条的阶数必须大于1且小于6。'
- en: The [`spline_filter`](../reference/generated/scipy.ndimage.spline_filter.html#scipy.ndimage.spline_filter
    "scipy.ndimage.spline_filter") function calculates a multidimensional spline filter.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`spline_filter`](../reference/generated/scipy.ndimage.spline_filter.html#scipy.ndimage.spline_filter
    "scipy.ndimage.spline_filter") 函数计算多维样条滤波器。'
- en: Note
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The multidimensional filter is implemented as a sequence of 1-D spline filters.
    The intermediate arrays are stored in the same data type as the output. Therefore,
    if an output with a limited precision is requested, the results may be imprecise
    because intermediate results may be stored with insufficient precision. This can
    be prevented by specifying a output type of high precision.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 多维滤波器是通过一系列1-D样条滤波器实现的。中间数组与输出相同数据类型存储。因此，如果要求有限精度的输出，由于中间结果可能存储不足精度，结果可能不准确。可以通过指定高精度的输出类型来避免这种情况。
- en: '### Interpolation boundary handling'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '### 插值边界处理'
- en: The interpolation functions all employ spline interpolation to effect some type
    of geometric transformation of the input array. This requires a mapping of the
    output coordinates to the input coordinates, and therefore, the possibility arises
    that input values outside the boundaries may be needed. This problem is solved
    in the same way as described in [Filter functions](#ndimage-filter-functions)
    for the multidimensional filter functions. Therefore, these functions all support
    a *mode* parameter that determines how the boundaries are handled, and a *cval*
    parameter that gives a constant value in case that the ‘constant’ mode is used.
    The behavior of all modes, including at non-integer locations is illustrated below.
    Note the boundaries are not handled the same for all modes; *reflect* (aka *grid-mirror*)
    and *grid-wrap* involve symmetry or repetition about a point that is half way
    between image samples (dashed vertical lines) while modes *mirror* and *wrap*
    treat the image as if it’s extent ends exactly at the first and last sample point
    rather than 0.5 samples past it.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的插值函数都使用样条插值来实现输入数组的某种几何变换。这要求将输出坐标映射到输入坐标，因此，可能需要处理超出边界的输入值。对于多维滤波函数中描述的相同问题，解决方法与[过滤函数](#ndimage-filter-functions)相同。因此，这些函数都支持一个
    *mode* 参数，用于确定如何处理边界，并支持一个 *cval* 参数，在使用“constant”模式时给出一个常数值。下面展示了所有模式的行为，包括在非整数位置的行为。请注意，不同模式下的边界处理方式不同；*reflect*（又称*grid-mirror*）和*grid-wrap*涉及关于距离图像样本之间一半位置的对称或重复（虚线垂直线），而*mirror*和*wrap*将图像视为其范围恰好结束于第一个和最后一个样本点，而不是过了0.5个样本点。
- en: '![" "](../Images/107cdb725ccd95831a4ba5074b502a4b.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/107cdb725ccd95831a4ba5074b502a4b.png)'
- en: The coordinates of image samples fall on integer sampling locations in the range
    from 0 to `shape[i] - 1` along each axis, `i`. The figure below illustrates the
    interpolation of a point at location `(3.7, 3.3)` within an image of shape `(7,
    7)`. For an interpolation of order `n`, `n + 1` samples are involved along each
    axis. The filled circles illustrate the sampling locations involved in the interpolation
    of the value at the location of the red x.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图像样本的坐标落在每个轴上从0到`shape[i] - 1`的整数采样位置范围内，其中 `i` 是轴的索引。下图展示了在形状为`(7, 7)`的图像中位置为`(3.7,
    3.3)`处的插值。对于阶数为 `n` 的插值，每个轴上涉及 `n + 1` 个样本。填充的圆圈显示了插值中涉及到的采样位置，在红色 x 的位置插值的图中。
- en: '![" "](../Images/b4cf03bdffeaf405ab1e3824e1e6cb0c.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![" "](../Images/b4cf03bdffeaf405ab1e3824e1e6cb0c.png)'
- en: Interpolation functions
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 插值函数
- en: The [`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform") function applies an arbitrary geometric transform
    to the input. The given *mapping* function is called at each point in the output
    to find the corresponding coordinates in the input. *mapping* must be a callable
    object that accepts a tuple of length equal to the output array rank and returns
    the corresponding input coordinates as a tuple of length equal to the input array
    rank. The output shape and output type can optionally be provided. If not given,
    they are equal to the input shape and type.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform") 函数将任意几何变换应用于输入。给定的 *mapping* 函数在输出中的每个点被调用，以找到对应的输入坐标。*mapping*
    必须是一个可调用对象，接受一个长度等于输出数组秩的元组，并返回与输入数组秩相等的对应输入坐标的元组。输出形状和输出类型可以选择性地提供。如果没有给出，它们等于输入的形状和类型。'
- en: 'For example:'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE22]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Optionally, extra arguments can be defined and passed to the filter function.
    The *extra_arguments* and *extra_keywords* arguments can be used to pass a tuple
    of extra arguments and/or a dictionary of named arguments that are passed to derivative
    at each call. For example, we can pass the shifts in our example as arguments
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选地，可以定义并传递额外的参数给过滤器函数。*extra_arguments* 和 *extra_keywords* 参数可用于传递额外参数的元组和/或传递给每次调用中的导数的命名参数的字典。例如，我们可以像以下示例中一样传递偏移量。
- en: '[PRE23]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: or
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或
- en: '[PRE24]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Note
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The mapping function can also be written in C and passed using a [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable"). See [Extending scipy.ndimage in C](#ndimage-ccallbacks)
    for more information.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 映射函数也可以用C语言编写，并使用[`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable")进行传递。更多信息请参阅[在C中扩展scipy.ndimage](#ndimage-ccallbacks)。
- en: The function [`map_coordinates`](../reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates
    "scipy.ndimage.map_coordinates") applies an arbitrary coordinate transformation
    using the given array of coordinates. The shape of the output is derived from
    that of the coordinate array by dropping the first axis. The parameter *coordinates*
    is used to find for each point in the output the corresponding coordinates in
    the input. The values of *coordinates* along the first axis are the coordinates
    in the input array at which the output value is found. (See also the numarray
    *coordinates* function.) Since the coordinates may be non- integer coordinates,
    the value of the input at these coordinates is determined by spline interpolation
    of the requested order.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`map_coordinates`](../reference/generated/scipy.ndimage.map_coordinates.html#scipy.ndimage.map_coordinates
    "scipy.ndimage.map_coordinates")使用给定的坐标数组应用任意坐标变换。输出的形状从坐标数组的形状派生，通过删除第一个轴。参数*coordinates*用于找到输出中每个点在输入中对应的坐标。*coordinates*沿第一个轴的值是输入数组中找到输出值的坐标。（另见numarray
    *coordinates*函数。）由于坐标可以是非整数坐标，因此在这些坐标处的输入值由请求的阶数的样条插值确定。
- en: 'Here is an example that interpolates a 2D array at `(0.5, 0.5)` and `(1, 2)`:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里是一个示例，插值一个2D数组在`(0.5, 0.5)`和`(1, 2)`处：
- en: '[PRE25]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The [`affine_transform`](../reference/generated/scipy.ndimage.affine_transform.html#scipy.ndimage.affine_transform
    "scipy.ndimage.affine_transform") function applies an affine transformation to
    the input array. The given transformation *matrix* and *offset* are used to find
    for each point in the output the corresponding coordinates in the input. The value
    of the input at the calculated coordinates is determined by spline interpolation
    of the requested order. The transformation *matrix* must be 2-D or can also be
    given as a 1-D sequence or array. In the latter case, it is assumed that the matrix
    is diagonal. A more efficient interpolation algorithm is then applied that exploits
    the separability of the problem. The output shape and output type can optionally
    be provided. If not given, they are equal to the input shape and type.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`affine_transform`](../reference/generated/scipy.ndimage.affine_transform.html#scipy.ndimage.affine_transform
    "scipy.ndimage.affine_transform")将仿射变换应用于输入数组。给定的变换*矩阵*和*偏移量*用于查找输出中每个点在输入中对应的坐标。在计算的坐标处的输入值由请求的阶数的样条插值确定。变换*矩阵*必须是2-D，或者也可以作为1-D序列或数组给出。在后一种情况下，假定矩阵是对角的。然后应用更有效的插值算法，利用问题的可分离性。输出形状和输出类型可以选择性地提供。如果未给出，则它们与输入的形状和类型相等。
- en: The [`shift`](../reference/generated/scipy.ndimage.shift.html#scipy.ndimage.shift
    "scipy.ndimage.shift") function returns a shifted version of the input, using
    spline interpolation of the requested *order*.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`shift`](../reference/generated/scipy.ndimage.shift.html#scipy.ndimage.shift
    "scipy.ndimage.shift")返回输入的移位版本，使用请求的*order*的样条插值。
- en: The [`zoom`](../reference/generated/scipy.ndimage.zoom.html#scipy.ndimage.zoom
    "scipy.ndimage.zoom") function returns a rescaled version of the input, using
    spline interpolation of the requested *order*.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`zoom`](../reference/generated/scipy.ndimage.zoom.html#scipy.ndimage.zoom
    "scipy.ndimage.zoom")返回输入的重新缩放版本，使用请求的*order*的样条插值。
- en: 'The [`rotate`](../reference/generated/scipy.ndimage.rotate.html#scipy.ndimage.rotate
    "scipy.ndimage.rotate") function returns the input array rotated in the plane
    defined by the two axes given by the parameter *axes*, using spline interpolation
    of the requested *order*. The angle must be given in degrees. If *reshape* is
    true, then the size of the output array is adapted to contain the rotated input.  ##
    Morphology'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`rotate`](../reference/generated/scipy.ndimage.rotate.html#scipy.ndimage.rotate
    "scipy.ndimage.rotate")返回在由参数*axes*给出的两个轴定义的平面中旋转的输入数组，使用请求的*order*的样条插值。角度必须以度为单位给出。如果*reshape*为真，则输出数组的大小将适应包含旋转输入的内容。##
    形态学
- en: '### Binary morphology'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '### 二进制形态学'
- en: 'The [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") functions generates a binary structuring
    element for use in binary morphology operations. The *rank* of the structure must
    be provided. The size of the structure that is returned is equal to three in each
    direction. The value of each element is equal to one if the square of the Euclidean
    distance from the element to the center is less than or equal to *connectivity*.
    For instance, 2-D 4-connected and 8-connected structures are generated as follows:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") 函数生成一个用于二值形态学操作的二值结构元素。必须提供结构的*rank*。返回的结构大小在每个方向上都等于三。每个元素的值等于1，如果从元素到中心的欧氏距离的平方小于或等于*connectivity*。例如，生成2D
    4连接和8连接结构如下：'
- en: '[PRE26]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This is a visual presentation of [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") in 3D:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这是[`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure")在3D中的视觉呈现：
- en: '![" "](../Images/ef3b334e00490f57e7f362b27434c7e1.png)'
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![" "](../Images/ef3b334e00490f57e7f362b27434c7e1.png)'
- en: 'Most binary morphology functions can be expressed in terms of the basic operations
    erosion and dilation, which can be seen here:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数二值形态学函数可以用基本操作腐蚀和膨胀来表示，这些操作可以在这里看到：
- en: '![" "](../Images/a74b3111309bd8011739df3806ce86e7.png)'
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_IMG
  zh: '![" "](../Images/a74b3111309bd8011739df3806ce86e7.png)'
- en: The [`binary_erosion`](../reference/generated/scipy.ndimage.binary_erosion.html#scipy.ndimage.binary_erosion
    "scipy.ndimage.binary_erosion") function implements binary erosion of arrays of
    arbitrary rank with the given structuring element. The origin parameter controls
    the placement of the structuring element, as described in [Filter functions](#ndimage-filter-functions).
    If no structuring element is provided, an element with connectivity equal to one
    is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure"). The *border_value* parameter gives
    the value of the array outside boundaries. The erosion is repeated *iterations*
    times. If *iterations* is less than one, the erosion is repeated until the result
    does not change anymore. If a *mask* array is given, only those elements with
    a true value at the corresponding mask element are modified at each iteration.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`binary_erosion`](../reference/generated/scipy.ndimage.binary_erosion.html#scipy.ndimage.binary_erosion
    "scipy.ndimage.binary_erosion") 函数使用给定的结构元素对任意秩的数组进行二值腐蚀。原点参数控制结构元素的放置，如[过滤器函数](#ndimage-filter-functions)中所述。如果没有提供结构元素，则使用[`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure")生成一个连接度等于1的元素。*border_value*参数给出边界外数组的值。腐蚀重复*iterations*次。如果*iterations*小于1，则重复腐蚀直到结果不再改变。如果给出*mask*数组，则仅在每次迭代时修改对应掩码元素处具有真值的元素。'
- en: The [`binary_dilation`](../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation
    "scipy.ndimage.binary_dilation") function implements binary dilation of arrays
    of arbitrary rank with the given structuring element. The origin parameter controls
    the placement of the structuring element, as described in [Filter functions](#ndimage-filter-functions).
    If no structuring element is provided, an element with connectivity equal to one
    is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure"). The *border_value* parameter gives
    the value of the array outside boundaries. The dilation is repeated *iterations*
    times. If *iterations* is less than one, the dilation is repeated until the result
    does not change anymore. If a *mask* array is given, only those elements with
    a true value at the corresponding mask element are modified at each iteration.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`binary_dilation`](../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation
    "scipy.ndimage.binary_dilation") 函数实现了带有给定结构元素的任意秩数组的二值膨胀。原点参数控制结构元素的放置位置，如[滤波函数](#ndimage-filter-functions)中所述。如果没有提供结构元素，则使用
    [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") 生成连接等于一的元素。*border_value* 参数指定边界外数组的值。膨胀重复
    *iterations* 次。如果 *iterations* 小于一，则膨胀重复直到结果不再改变。如果给定 *mask* 数组，则只有在每次迭代时对应掩模元素处为
    true 的元素才会被修改。'
- en: 'Here is an example of using [`binary_dilation`](../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation
    "scipy.ndimage.binary_dilation") to find all elements that touch the border, by
    repeatedly dilating an empty array from the border using the data array as the
    mask:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 [`binary_dilation`](../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation
    "scipy.ndimage.binary_dilation") 的示例，通过多次使用数据数组作为掩模，从边界膨胀空数组来找到所有接触边界的元素：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The [`binary_erosion`](../reference/generated/scipy.ndimage.binary_erosion.html#scipy.ndimage.binary_erosion
    "scipy.ndimage.binary_erosion") and [`binary_dilation`](../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation
    "scipy.ndimage.binary_dilation") functions both have an *iterations* parameter,
    which allows the erosion or dilation to be repeated a number of times. Repeating
    an erosion or a dilation with a given structure *n* times is equivalent to an
    erosion or a dilation with a structure that is *n-1* times dilated with itself.
    A function is provided that allows the calculation of a structure that is dilated
    a number of times with itself:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[`binary_erosion`](../reference/generated/scipy.ndimage.binary_erosion.html#scipy.ndimage.binary_erosion
    "scipy.ndimage.binary_erosion") 和 [`binary_dilation`](../reference/generated/scipy.ndimage.binary_dilation.html#scipy.ndimage.binary_dilation
    "scipy.ndimage.binary_dilation") 函数都有一个 *iterations* 参数，允许腐蚀或膨胀重复多次。用给定结构 *n*
    次腐蚀或膨胀等同于使用自身膨胀 *n-1* 次的结构进行腐蚀或膨胀。提供了一个函数来计算多次膨胀自身的结构：'
- en: The [`iterate_structure`](../reference/generated/scipy.ndimage.iterate_structure.html#scipy.ndimage.iterate_structure
    "scipy.ndimage.iterate_structure") function returns a structure by dilation of
    the input structure *iteration* - 1 times with itself.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`iterate_structure`](../reference/generated/scipy.ndimage.iterate_structure.html#scipy.ndimage.iterate_structure
    "scipy.ndimage.iterate_structure") 函数通过将输入结构自身膨胀 *迭代* - 1 次来返回一个结构。'
- en: 'For instance:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE28]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Other morphology operations can be defined in terms of erosion and dilation.
    The following functions provide a few of these operations for convenience:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 其他形态学操作可以通过腐蚀和膨胀来定义。以下函数为方便起见提供了一些这些操作：
- en: The [`binary_opening`](../reference/generated/scipy.ndimage.binary_opening.html#scipy.ndimage.binary_opening
    "scipy.ndimage.binary_opening") function implements binary opening of arrays of
    arbitrary rank with the given structuring element. Binary opening is equivalent
    to a binary erosion followed by a binary dilation with the same structuring element.
    The origin parameter controls the placement of the structuring element, as described
    in [Filter functions](#ndimage-filter-functions). If no structuring element is
    provided, an element with connectivity equal to one is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure"). The *iterations* parameter gives the
    number of erosions that is performed followed by the same number of dilations.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`binary_opening`](../reference/generated/scipy.ndimage.binary_opening.html#scipy.ndimage.binary_opening
    "scipy.ndimage.binary_opening") 函数实现了使用给定结构元素进行任意秩数组的二进制开运算。二进制开运算相当于使用相同结构元素进行二进制腐蚀，然后进行二进制膨胀。原点参数控制结构元素的放置，如[滤波函数](#ndimage-filter-functions)中描述的那样。如果没有提供结构元素，则使用[`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure")生成具有连接性等于一的元素。*iterations* 参数指定进行的腐蚀次数，然后是相同次数的膨胀。'
- en: The [`binary_closing`](../reference/generated/scipy.ndimage.binary_closing.html#scipy.ndimage.binary_closing
    "scipy.ndimage.binary_closing") function implements binary closing of arrays of
    arbitrary rank with the given structuring element. Binary closing is equivalent
    to a binary dilation followed by a binary erosion with the same structuring element.
    The origin parameter controls the placement of the structuring element, as described
    in [Filter functions](#ndimage-filter-functions). If no structuring element is
    provided, an element with connectivity equal to one is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure"). The *iterations* parameter gives the
    number of dilations that is performed followed by the same number of erosions.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`binary_closing`](../reference/generated/scipy.ndimage.binary_closing.html#scipy.ndimage.binary_closing
    "scipy.ndimage.binary_closing") 函数实现了使用给定结构元素进行任意秩数组的二进制闭运算。二进制闭运算相当于使用相同结构元素进行二进制膨胀，然后进行二进制腐蚀。原点参数控制结构元素的放置，如[滤波函数](#ndimage-filter-functions)中描述的那样。如果没有提供结构元素，则使用[`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure")生成具有连接性等于一的元素。*iterations* 参数指定进行的膨胀次数，然后是相同次数的腐蚀。'
- en: The [`binary_fill_holes`](../reference/generated/scipy.ndimage.binary_fill_holes.html#scipy.ndimage.binary_fill_holes
    "scipy.ndimage.binary_fill_holes") function is used to close holes in objects
    in a binary image, where the structure defines the connectivity of the holes.
    The origin parameter controls the placement of the structuring element, as described
    in [Filter functions](#ndimage-filter-functions). If no structuring element is
    provided, an element with connectivity equal to one is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure").
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`binary_fill_holes`](../reference/generated/scipy.ndimage.binary_fill_holes.html#scipy.ndimage.binary_fill_holes
    "scipy.ndimage.binary_fill_holes") 函数用于关闭二进制图像中物体的孔洞，其中结构定义了孔洞的连接性。原点参数控制结构元素的放置，如[滤波函数](#ndimage-filter-functions)中描述的那样。如果没有提供结构元素，则使用[`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure")生成具有连接性等于一的元素。'
- en: 'The [`binary_hit_or_miss`](../reference/generated/scipy.ndimage.binary_hit_or_miss.html#scipy.ndimage.binary_hit_or_miss
    "scipy.ndimage.binary_hit_or_miss") function implements a binary hit-or-miss transform
    of arrays of arbitrary rank with the given structuring elements. The hit-or-miss
    transform is calculated by erosion of the input with the first structure, erosion
    of the logical *not* of the input with the second structure, followed by the logical
    *and* of these two erosions. The origin parameters control the placement of the
    structuring elements, as described in [Filter functions](#ndimage-filter-functions).
    If *origin2* equals `None`, it is set equal to the *origin1* parameter. If the
    first structuring element is not provided, a structuring element with connectivity
    equal to one is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure"). If *structure2* is not provided, it
    is set equal to the logical *not* of *structure1*.  ### Grey-scale morphology'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`binary_hit_or_miss`](../reference/generated/scipy.ndimage.binary_hit_or_miss.html#scipy.ndimage.binary_hit_or_miss
    "scipy.ndimage.binary_hit_or_miss") 函数实现了对具有给定结构元素的任意秩数组的二进制击中或未击中变换。击中或未击中变换通过对输入与第一个结构元素进行腐蚀，对输入的逻辑
    *not* 与第二个结构元素进行腐蚀，然后对这两个腐蚀结果进行逻辑 *and* 来计算。原点参数控制结构元素的放置位置，如 [Filter functions](#ndimage-filter-functions)
    中所述。如果 *origin2* 等于 `None`，则设为 *origin1* 参数的值。如果未提供第一个结构元素，则使用 [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") 生成一个连接度等于一的结构元素。如果未提供 *structure2*，则设置为
    *structure1* 的逻辑 *not*。### 灰度形态学'
- en: Grey-scale morphology operations are the equivalents of binary morphology operations
    that operate on arrays with arbitrary values. Below, we describe the grey-scale
    equivalents of erosion, dilation, opening and closing. These operations are implemented
    in a similar fashion as the filters described in [Filter functions](#ndimage-filter-functions),
    and we refer to this section for the description of filter kernels and footprints,
    and the handling of array borders. The grey-scale morphology operations optionally
    take a *structure* parameter that gives the values of the structuring element.
    If this parameter is not given, the structuring element is assumed to be flat
    with a value equal to zero. The shape of the structure can optionally be defined
    by the *footprint* parameter. If this parameter is not given, the structure is
    assumed to be rectangular, with sizes equal to the dimensions of the *structure*
    array, or by the *size* parameter if *structure* is not given. The *size* parameter
    is only used if both *structure* and *footprint* are not given, in which case
    the structuring element is assumed to be rectangular and flat with the dimensions
    given by *size*. The *size* parameter, if provided, must be a sequence of sizes
    or a single number in which case the size of the filter is assumed to be equal
    along each axis. The *footprint* parameter, if provided, must be an array that
    defines the shape of the kernel by its non-zero elements.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度形态学操作是在具有任意值的数组上操作的二进制形态学操作的等价物。下面我们描述了侵蚀、膨胀、开运算和闭运算的灰度等价物。这些操作的实现方式与 [Filter
    functions](#ndimage-filter-functions) 中描述的滤波器类似，并且我们参考此部分来描述滤波器核和足迹的处理以及数组边界的处理。灰度形态学操作可以选择接受一个
    *structure* 参数，该参数给出结构元素的值。如果未提供此参数，则假定结构元素是一个值为零的平坦结构元素。结构的形状可以通过 *footprint*
    参数进行可选定义。如果未提供此参数，则假定结构是矩形的，大小等于 *structure* 数组的尺寸，或者由 *size* 参数定义（如果未提供 *structure*）。仅当
    *structure* 和 *footprint* 都未给出时，*size* 参数才会被使用，此时结构元素被假定为矩形和平坦的，其尺寸由 *size* 给出。如果提供了
    *size* 参数，则必须是一个尺寸序列或一个单独的数字，此时滤波器在每个轴上的尺寸是相同的。如果提供了 *footprint* 参数，则必须是一个数组，通过其非零元素定义核的形状。
- en: 'Similarly to binary erosion and dilation, there are operations for grey-scale
    erosion and dilation:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于二进制腐蚀和膨胀，灰度腐蚀和膨胀也有相应的操作：
- en: The [`grey_erosion`](../reference/generated/scipy.ndimage.grey_erosion.html#scipy.ndimage.grey_erosion
    "scipy.ndimage.grey_erosion") function calculates a multidimensional grey-scale
    erosion.
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`grey_erosion`](../reference/generated/scipy.ndimage.grey_erosion.html#scipy.ndimage.grey_erosion
    "scipy.ndimage.grey_erosion") 函数计算多维灰度侵蚀。'
- en: The [`grey_dilation`](../reference/generated/scipy.ndimage.grey_dilation.html#scipy.ndimage.grey_dilation
    "scipy.ndimage.grey_dilation") function calculates a multidimensional grey-scale
    dilation.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`grey_dilation`](../reference/generated/scipy.ndimage.grey_dilation.html#scipy.ndimage.grey_dilation
    "scipy.ndimage.grey_dilation") 函数计算多维灰度膨胀。'
- en: 'Grey-scale opening and closing operations can be defined similarly to their
    binary counterparts:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 灰度开运算和闭运算操作可以类似于它们的二值化对应物定义：
- en: The [`grey_opening`](../reference/generated/scipy.ndimage.grey_opening.html#scipy.ndimage.grey_opening
    "scipy.ndimage.grey_opening") function implements grey-scale opening of arrays
    of arbitrary rank. Grey-scale opening is equivalent to a grey-scale erosion followed
    by a grey-scale dilation.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`grey_opening`](../reference/generated/scipy.ndimage.grey_opening.html#scipy.ndimage.grey_opening
    "scipy.ndimage.grey_opening") 函数实现了任意秩数组的灰度开运算。灰度开运算等效于灰度腐蚀后再进行灰度膨胀。'
- en: The [`grey_closing`](../reference/generated/scipy.ndimage.grey_closing.html#scipy.ndimage.grey_closing
    "scipy.ndimage.grey_closing") function implements grey-scale closing of arrays
    of arbitrary rank. Grey-scale opening is equivalent to a grey-scale dilation followed
    by a grey-scale erosion.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`grey_closing`](../reference/generated/scipy.ndimage.grey_closing.html#scipy.ndimage.grey_closing
    "scipy.ndimage.grey_closing") 函数实现了任意秩数组的灰度闭运算。灰度闭运算等效于灰度膨胀后再进行灰度腐蚀。'
- en: The [`morphological_gradient`](../reference/generated/scipy.ndimage.morphological_gradient.html#scipy.ndimage.morphological_gradient
    "scipy.ndimage.morphological_gradient") function implements a grey-scale morphological
    gradient of arrays of arbitrary rank. The grey-scale morphological gradient is
    equal to the difference of a grey-scale dilation and a grey-scale erosion.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`morphological_gradient`](../reference/generated/scipy.ndimage.morphological_gradient.html#scipy.ndimage.morphological_gradient
    "scipy.ndimage.morphological_gradient") 函数实现了任意秩数组的灰度形态梯度。灰度形态梯度等于灰度膨胀与灰度腐蚀的差。'
- en: The [`morphological_laplace`](../reference/generated/scipy.ndimage.morphological_laplace.html#scipy.ndimage.morphological_laplace
    "scipy.ndimage.morphological_laplace") function implements a grey-scale morphological
    laplace of arrays of arbitrary rank. The grey-scale morphological laplace is equal
    to the sum of a grey-scale dilation and a grey-scale erosion minus twice the input.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`morphological_laplace`](../reference/generated/scipy.ndimage.morphological_laplace.html#scipy.ndimage.morphological_laplace
    "scipy.ndimage.morphological_laplace") 函数实现了任意秩数组的灰度形态拉普拉斯。灰度形态拉普拉斯等于灰度膨胀与灰度腐蚀的和减去两倍的输入。'
- en: The [`white_tophat`](../reference/generated/scipy.ndimage.white_tophat.html#scipy.ndimage.white_tophat
    "scipy.ndimage.white_tophat") function implements a white top-hat filter of arrays
    of arbitrary rank. The white top-hat is equal to the difference of the input and
    a grey-scale opening.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`white_tophat`](../reference/generated/scipy.ndimage.white_tophat.html#scipy.ndimage.white_tophat
    "scipy.ndimage.white_tophat") 函数实现了任意秩数组的白顶帽滤波器。白顶帽等于输入与灰度开运算的差。'
- en: 'The [`black_tophat`](../reference/generated/scipy.ndimage.black_tophat.html#scipy.ndimage.black_tophat
    "scipy.ndimage.black_tophat") function implements a black top-hat filter of arrays
    of arbitrary rank. The black top-hat is equal to the difference of a grey-scale
    closing and the input.  ## Distance transforms'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`black_tophat`](../reference/generated/scipy.ndimage.black_tophat.html#scipy.ndimage.black_tophat
    "scipy.ndimage.black_tophat") 函数实现了任意秩数组的黑顶帽滤波器。黑顶帽等于灰度闭运算与输入的差。'
- en: 'Distance transforms are used to calculate the minimum distance from each element
    of an object to the background. The following functions implement distance transforms
    for three different distance metrics: Euclidean, city block, and chessboard distances.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 距离变换用于计算对象中每个元素到背景的最小距离。以下函数实现了三种不同距离度量的距离变换：欧几里得距离、城市街区距离和棋盘距离。
- en: The function [`distance_transform_cdt`](../reference/generated/scipy.ndimage.distance_transform_cdt.html#scipy.ndimage.distance_transform_cdt
    "scipy.ndimage.distance_transform_cdt") uses a chamfer type algorithm to calculate
    the distance transform of the input, by replacing each object element (defined
    by values larger than zero) with the shortest distance to the background (all
    non-object elements). The structure determines the type of chamfering that is
    done. If the structure is equal to ‘cityblock’, a structure is generated using
    [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") with a squared distance equal to 1\.
    If the structure is equal to ‘chessboard’, a structure is generated using [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") with a squared distance equal to the
    rank of the array. These choices correspond to the common interpretations of the
    city block and the chessboard distance metrics in two dimensions.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`distance_transform_cdt`](../reference/generated/scipy.ndimage.distance_transform_cdt.html#scipy.ndimage.distance_transform_cdt
    "scipy.ndimage.distance_transform_cdt")使用 chamfer 类型算法计算输入的距离变换，通过将每个对象元素（定义为大于零的值）替换为到背景的最短距离（所有非对象元素）。结构确定所做
    chamfering 的类型。如果结构等于“cityblock”，则使用[`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure")生成一个距离平方等于1的结构。如果结构等于“chessboard”，则使用[`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure")生成一个距离平方等于数组秩的结构。这些选择对应于二维中城市街区距离和棋盘距离度量的常见解释。
- en: In addition to the distance transform, the feature transform can be calculated.
    In this case, the index of the closest background element is returned along the
    first axis of the result. The *return_distances*, and *return_indices* flags can
    be used to indicate if the distance transform, the feature transform, or both
    must be returned.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了距离变换外，还可以计算特征变换。在这种情况下，返回结果的第一个轴上最接近背景元素的索引。可以使用*return_distances*和*return_indices*标志来指示是否返回距离变换、特征变换或两者。
- en: The *distances* and *indices* arguments can be used to give optional output
    arrays that must be of the correct size and type (both `numpy.int32`). The basics
    of the algorithm used to implement this function are described in [[2]](#id9).
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用*distances*和*indices*参数来提供必须是正确大小和类型（`numpy.int32`）的可选输出数组。用于实现此功能的算法的基本原理在[[2]](#id9)中描述。
- en: The function [`distance_transform_edt`](../reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt
    "scipy.ndimage.distance_transform_edt") calculates the exact Euclidean distance
    transform of the input, by replacing each object element (defined by values larger
    than zero) with the shortest Euclidean distance to the background (all non-object
    elements).
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`distance_transform_edt`](../reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt
    "scipy.ndimage.distance_transform_edt")通过将每个对象元素（定义为大于零的值）替换为到背景的最短欧几里得距离，计算输入的精确欧几里得距离变换。
- en: In addition to the distance transform, the feature transform can be calculated.
    In this case, the index of the closest background element is returned along the
    first axis of the result. The *return_distances* and *return_indices* flags can
    be used to indicate if the distance transform, the feature transform, or both
    must be returned.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了距离变换外，还可以计算特征变换。在这种情况下，返回结果的第一个轴上最接近背景元素的索引。可以使用*return_distances*和*return_indices*标志来指示是否返回距离变换、特征变换或两者。
- en: Optionally, the sampling along each axis can be given by the *sampling* parameter,
    which should be a sequence of length equal to the input rank, or a single number
    in which the sampling is assumed to be equal along all axes.
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选地，可以通过*sampling*参数给出每个轴向的采样，它应该是与输入秩相等的长度序列，或者是一个单一的数，在这种情况下，假定沿所有轴向的采样是相等的。
- en: The *distances* and *indices* arguments can be used to give optional output
    arrays that must be of the correct size and type (`numpy.float64` and `numpy.int32`).The
    algorithm used to implement this function is described in [[3]](#id10).
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以使用*distances*和*indices*参数来提供必须是正确大小和类型（`numpy.float64`和`numpy.int32`）的可选输出数组。用于实现此功能的算法的基本原理在[[3]](#id10)中描述。
- en: The function [`distance_transform_bf`](../reference/generated/scipy.ndimage.distance_transform_bf.html#scipy.ndimage.distance_transform_bf
    "scipy.ndimage.distance_transform_bf") uses a brute-force algorithm to calculate
    the distance transform of the input, by replacing each object element (defined
    by values larger than zero) with the shortest distance to the background (all
    non-object elements). The metric must be one of “euclidean”, “cityblock”, or “chessboard”.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`distance_transform_bf`](../reference/generated/scipy.ndimage.distance_transform_bf.html#scipy.ndimage.distance_transform_bf
    "scipy.ndimage.distance_transform_bf")使用蛮力算法计算输入的距离变换，通过将每个对象元素（由大于零的值定义）替换为到背景（所有非对象元素）的最短距离。度量必须是“euclidean”、“cityblock”或“chessboard”之一。
- en: In addition to the distance transform, the feature transform can be calculated.
    In this case, the index of the closest background element is returned along the
    first axis of the result. The *return_distances* and *return_indices* flags can
    be used to indicate if the distance transform, the feature transform, or both
    must be returned.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了距离变换之外，还可以计算特征变换。在这种情况下，返回结果的第一个轴上最接近的背景元素的索引。*return_distances*和*return_indices*标志可以用于指示是否必须返回距离变换、特征变换或两者。
- en: Optionally, the sampling along each axis can be given by the *sampling* parameter,
    which should be a sequence of length equal to the input rank, or a single number
    in which the sampling is assumed to be equal along all axes. This parameter is
    only used in the case of the Euclidean distance transform.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选地，沿每个轴的采样可以由*sampling*参数给出，该参数应该是与输入秩相等的长度序列，或者是一个单独的数字，其中假定沿所有轴的采样相等。这个参数仅在欧几里得距离变换的情况下使用。
- en: The *distances* and *indices* arguments can be used to give optional output
    arrays that must be of the correct size and type (`numpy.float64` and `numpy.int32`).
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*distances*和*indices*参数可用于提供必须具有正确大小和类型(`numpy.float64`和`numpy.int32`)的可选输出数组。'
- en: Note
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: This function uses a slow brute-force algorithm, the function [`distance_transform_cdt`](../reference/generated/scipy.ndimage.distance_transform_cdt.html#scipy.ndimage.distance_transform_cdt
    "scipy.ndimage.distance_transform_cdt") can be used to more efficiently calculate
    city block and chessboard distance transforms. The function [`distance_transform_edt`](../reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt
    "scipy.ndimage.distance_transform_edt") can be used to more efficiently calculate
    the exact Euclidean distance transform.
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数使用缓慢的蛮力算法，函数[`distance_transform_cdt`](../reference/generated/scipy.ndimage.distance_transform_cdt.html#scipy.ndimage.distance_transform_cdt
    "scipy.ndimage.distance_transform_cdt")可用于更有效地计算城市块和棋盘距离变换。函数[`distance_transform_edt`](../reference/generated/scipy.ndimage.distance_transform_edt.html#scipy.ndimage.distance_transform_edt
    "scipy.ndimage.distance_transform_edt")可用于更有效地计算精确的欧几里得距离变换。
- en: Segmentation and labeling
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分割和标记
- en: 'Segmentation is the process of separating objects of interest from the background.
    The most simple approach is, probably, intensity thresholding, which is easily
    done with [`numpy`](https://numpy.org/devdocs/reference/index.html#module-numpy
    "(in NumPy v2.0.dev0)") functions:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 分割是从背景中分离感兴趣的对象的过程。可能最简单的方法是强度阈值分割，可以轻松使用[`numpy`](https://numpy.org/devdocs/reference/index.html#module-numpy
    "(in NumPy v2.0.dev0)")函数完成：
- en: '[PRE29]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The result is a binary image, in which the individual objects still need to
    be identified and labeled. The function [`label`](../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label
    "scipy.ndimage.label") generates an array where each object is assigned a unique
    number:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个二进制图像，其中仍需要识别和标记各个对象。函数[`label`](../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label
    "scipy.ndimage.label")生成一个数组，其中每个对象被分配一个唯一的编号：
- en: 'The [`label`](../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label
    "scipy.ndimage.label") function generates an array where the objects in the input
    are labeled with an integer index. It returns a tuple consisting of the array
    of object labels and the number of objects found, unless the *output* parameter
    is given, in which case only the number of objects is returned. The connectivity
    of the objects is defined by a structuring element. For instance, in 2D using
    a 4-connected structuring element gives:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`label`](../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label
    "scipy.ndimage.label")生成一个数组，其中输入中的对象用整数索引标记。它返回一个元组，包括对象标签数组和找到的对象数，除非给出了*output*参数，在这种情况下仅返回对象数。对象的连接性由一个结构元素定义。例如，在2D中使用4连接结构元素：
- en: '[PRE30]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'These two objects are not connected because there is no way in which we can
    place the structuring element, such that it overlaps with both objects. However,
    an 8-connected structuring element results in only a single object:'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个对象之间没有连接，因为我们无法将结构元素放置在既与第一个对象又与第二个对象重叠的方式。然而，8连接结构元素会导致只有一个对象：
- en: '[PRE31]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If no structuring element is provided, one is generated by calling [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") (see [Binary morphology](#ndimage-binary-morphology))
    using a connectivity of one (which in 2D is the 4-connected structure of the first
    example). The input can be of any type, any value not equal to zero is taken to
    be part of an object. This is useful if you need to ‘re-label’ an array of object
    indices, for instance, after removing unwanted objects. Just apply the label function
    again to the index array. For instance:'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果未提供结构元素，则通过调用[`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure")（参见[二元形态学](#ndimage-binary-morphology)）生成一个结构元素，使用连接性为1（在2D中是第一个示例的4连接结构）。输入可以是任何类型，任何不等于零的值被视为对象的一部分。如果需要在移除不需要的对象后重新标记对象索引数组，则这是有用的。只需再次将标签函数应用于索引数组。例如：
- en: '[PRE32]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The structuring element used by [`label`](../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label
    "scipy.ndimage.label") is assumed to be symmetric.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`label`](../reference/generated/scipy.ndimage.label.html#scipy.ndimage.label
    "scipy.ndimage.label")使用的结构元素被假定为对称的。'
- en: 'There is a large number of other approaches for segmentation, for instance,
    from an estimation of the borders of the objects that can be obtained by derivative
    filters. One such approach is watershed segmentation. The function [`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift") generates an array where each object is assigned
    a unique label, from an array that localizes the object borders, generated, for
    instance, by a gradient magnitude filter. It uses an array containing initial
    markers for the objects:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量其他分割方法，例如，可以通过导数滤波器估计边界来获得对象的边界。其中一种方法是分水岭分割。函数[`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift")生成一个数组，其中每个对象被分配一个唯一的标签，从定位对象边界的数组生成，例如通过梯度幅度滤波器。它使用一个包含对象初始标记的数组：
- en: The [`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift") function applies a watershed from markers algorithm,
    using Image Foresting Transform, as described in [[4]](#id11).
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数[`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift")应用从标记算法开始的分水岭算法，使用图像森林变换，如[[4]](#id11)中所述。
- en: 'The inputs of this function are the array to which the transform is applied,
    and an array of markers that designate the objects by a unique label, where any
    non-zero value is a marker. For instance:'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该函数的输入是应用变换的数组，以及一个由唯一标签指定对象的标记数组，其中任何非零值均为标记。例如：
- en: '[PRE33]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Here, two markers were used to designate an object (*marker* = 2) and the background
    (*marker* = 1). The order in which these are processed is arbitrary: moving the
    marker for the background to the lower-right corner of the array yields a different
    result:'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，使用了两个标记来指定一个对象（*marker* = 2）和背景（*marker* = 1）。这些标记的处理顺序是任意的：将背景的标记移动到数组的右下角会产生不同的结果：
- en: '[PRE34]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The result is that the object (*marker* = 2) is smaller because the second
    marker was processed earlier. This may not be the desired effect if the first
    marker was supposed to designate a background object. Therefore, [`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift") treats markers with a negative value explicitly
    as background markers and processes them after the normal markers. For instance,
    replacing the first marker by a negative marker gives a result similar to the
    first example:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果是对象（*marker* = 2）较小，因为第二个标记被先处理了。如果第一个标记本应指定背景对象，则可能不是期望的效果。因此，[`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift")明确地将具有负值的标记作为背景标记并在常规标记之后处理它们。例如，将第一个标记替换为负标记会产生与第一个示例类似的结果：
- en: '[PRE35]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The connectivity of the objects is defined by a structuring element. If no
    structuring element is provided, one is generated by calling [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") (see [Binary morphology](#ndimage-binary-morphology))
    using a connectivity of one (which in 2D is a 4-connected structure.) For example,
    using an 8-connected structure with the last example yields a different object:'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对象的连通性由结构元素定义。如果未提供结构元素，则通过调用 [`generate_binary_structure`](../reference/generated/scipy.ndimage.generate_binary_structure.html#scipy.ndimage.generate_binary_structure
    "scipy.ndimage.generate_binary_structure") 函数生成一个结构元素（参见[二进制形态学](#ndimage-binary-morphology)），使用连通性为一（在2D中为4连通结构）。例如，使用8连通结构来处理上一个示例将得到一个不同的对象：
- en: '[PRE36]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The implementation of [`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift") limits the data types of the input to `numpy.uint8`
    and `numpy.uint16`.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`watershed_ift`](../reference/generated/scipy.ndimage.watershed_ift.html#scipy.ndimage.watershed_ift
    "scipy.ndimage.watershed_ift") 的实现将输入数据类型限制为 `numpy.uint8` 和 `numpy.uint16`。'
- en: '## Object measurements'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '## 对象测量'
- en: 'Given an array of labeled objects, the properties of the individual objects
    can be measured. The [`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") function can be used to generate a list of slices
    that for each object, give the smallest sub-array that fully contains the object:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个带标签对象的数组，可以测量各个对象的属性。[`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") 函数可用于生成一个切片列表，每个对象对应一个完全包含该对象的最小子数组：
- en: The [`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") function finds all objects in a labeled array and
    returns a list of slices that correspond to the smallest regions in the array
    that contains the object.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") 函数查找标记数组中的所有对象，并返回一个切片列表，对应于包含对象的数组中最小的区域。'
- en: 'For instance:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE37]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The function [`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") returns slices for all objects, unless the *max_label*
    parameter is larger then zero, in which case only the first *max_label* objects
    are returned. If an index is missing in the *label* array, `None` is return instead
    of a slice. For example:'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 函数 [`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") 返回所有对象的切片，除非 *max_label* 参数大于零，此时仅返回前 *max_label*
    个对象。如果 *label* 数组中缺少索引，则返回 `None` 而不是切片。例如：
- en: '[PRE38]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The list of slices generated by [`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") is useful to find the position and dimensions of
    the objects in the array, but can also be used to perform measurements on the
    individual objects. Say, we want to find the sum of the intensities of an object
    in image:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [`find_objects`](../reference/generated/scipy.ndimage.find_objects.html#scipy.ndimage.find_objects
    "scipy.ndimage.find_objects") 生成的切片列表有助于找到数组中对象的位置和尺寸，也可用于对各个对象进行测量。例如，我们想要找到图像中一个对象强度的总和：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Then we can calculate the sum of the elements in the second object:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以计算第二个对象中元素的总和：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'That is, however, not particularly efficient and may also be more complicated
    for other types of measurements. Therefore, a few measurements functions are defined
    that accept the array of object labels and the index of the object to be measured.
    For instance, calculating the sum of the intensities can be done by:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不特别高效，对于其他类型的测量可能也更加复杂。因此，定义了一些测量函数，这些函数接受对象标签数组和要测量的对象的索引。例如，可以通过以下方式计算强度的总和：
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'For large arrays and small objects, it is more efficient to call the measurement
    functions after slicing the array:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大数组和小对象，调用数组切片后再调用测量函数效率更高：
- en: '[PRE42]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Alternatively, we can do the measurements for a number of labels with a single
    function call, returning a list of results. For instance, to measure the sum of
    the values of the background and the second object in our example, we give a list
    of labels:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过单个函数调用对多个标签进行测量，返回一个结果列表。例如，在我们的示例中，要测量背景和第二个对象的值之和，我们提供一个标签列表：
- en: '[PRE43]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The measurement functions described below all support the *index* parameter
    to indicate which object(s) should be measured. The default value of *index* is
    `None`. This indicates that all elements where the label is larger than zero should
    be treated as a single object and measured. Thus, in this case the *labels* array
    is treated as a mask defined by the elements that are larger than zero. If *index*
    is a number or a sequence of numbers it gives the labels of the objects that are
    measured. If *index* is a sequence, a list of the results is returned. Functions
    that return more than one result return their result as a tuple if *index* is
    a single number, or as a tuple of lists if *index* is a sequence.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 下面描述的测量函数都支持*index*参数，以指示应测量哪些对象。*index*的默认值为`None`。这表示所有标签大于零的元素都应视为单个对象并进行测量。因此，在这种情况下，*labels*数组被视为由大于零的元素定义的掩码。如果*index*是一个数字或数字序列，则给出被测量对象的标签。如果*index*是一个序列，则返回结果的列表。如果返回多个结果的函数在*index*为单个数字时返回其结果作为元组，或在*index*为序列时返回其结果作为列表的元组。
- en: The [`sum`](https://docs.python.org/3/library/functions.html#sum "(in Python
    v3.12)") function calculates the sum of the elements of the object with label(s)
    given by *index*, using the *labels* array for the object labels. If *index* is
    `None`, all elements with a non-zero label value are treated as a single object.
    If *label* is `None`, all elements of *input* are used in the calculation.
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`sum`](https://docs.python.org/3/library/functions.html#sum "(在 Python v3.12
    中)") 函数计算由*index*给定标签的对象元素的总和，使用*labels*数组作为对象标签。如果*index*为`None`，则所有非零标签值的元素被视为单个对象。如果*label*为`None`，则计算中使用*input*的所有元素。'
- en: The [`mean`](../reference/generated/scipy.ndimage.mean.html#scipy.ndimage.mean
    "scipy.ndimage.mean") function calculates the mean of the elements of the object
    with label(s) given by *index*, using the *labels* array for the object labels.
    If *index* is `None`, all elements with a non-zero label value are treated as
    a single object. If *label* is `None`, all elements of *input* are used in the
    calculation.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`mean`](../reference/generated/scipy.ndimage.mean.html#scipy.ndimage.mean
    "scipy.ndimage.mean") 函数计算由*index*给定标签的对象元素的平均值，使用*labels*数组作为对象标签。如果*index*为`None`，则所有非零标签值的元素被视为单个对象。如果*label*为`None`，则计算中使用*input*的所有元素。'
- en: The [`variance`](../reference/generated/scipy.ndimage.variance.html#scipy.ndimage.variance
    "scipy.ndimage.variance") function calculates the variance of the elements of
    the object with label(s) given by *index*, using the *labels* array for the object
    labels. If *index* is `None`, all elements with a non-zero label value are treated
    as a single object. If *label* is `None`, all elements of *input* are used in
    the calculation.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`variance`](../reference/generated/scipy.ndimage.variance.html#scipy.ndimage.variance
    "scipy.ndimage.variance") 函数计算由*index*给定标签的对象元素的方差，使用*labels*数组作为对象标签。如果*index*为`None`，则所有非零标签值的元素被视为单个对象。如果*label*为`None`，则计算中使用*input*的所有元素。'
- en: The [`standard_deviation`](../reference/generated/scipy.ndimage.standard_deviation.html#scipy.ndimage.standard_deviation
    "scipy.ndimage.standard_deviation") function calculates the standard deviation
    of the elements of the object with label(s) given by *index*, using the *labels*
    array for the object labels. If *index* is `None`, all elements with a non-zero
    label value are treated as a single object. If *label* is `None`, all elements
    of *input* are used in the calculation.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`standard_deviation`](../reference/generated/scipy.ndimage.standard_deviation.html#scipy.ndimage.standard_deviation
    "scipy.ndimage.standard_deviation") 函数计算由*index*给定标签的对象元素的标准差，使用*labels*数组作为对象标签。如果*index*为`None`，则所有非零标签值的元素被视为单个对象。如果*label*为`None`，则计算中使用*input*的所有元素。'
- en: The [`minimum`](../reference/generated/scipy.ndimage.minimum.html#scipy.ndimage.minimum
    "scipy.ndimage.minimum") function calculates the minimum of the elements of the
    object with label(s) given by *index*, using the *labels* array for the object
    labels. If *index* is `None`, all elements with a non-zero label value are treated
    as a single object. If *label* is `None`, all elements of *input* are used in
    the calculation.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`minimum`](../reference/generated/scipy.ndimage.minimum.html#scipy.ndimage.minimum
    "scipy.ndimage.minimum") 函数计算由*index*给定标签的对象元素的最小值，使用*labels*数组作为对象标签。如果*index*为`None`，则所有非零标签值的元素被视为单个对象。如果*label*为`None`，则计算中使用*input*的所有元素。'
- en: The [`maximum`](../reference/generated/scipy.ndimage.maximum.html#scipy.ndimage.maximum
    "scipy.ndimage.maximum") function calculates the maximum of the elements of the
    object with label(s) given by *index*, using the *labels* array for the object
    labels. If *index* is `None`, all elements with a non-zero label value are treated
    as a single object. If *label* is `None`, all elements of *input* are used in
    the calculation.
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`maximum`](../reference/generated/scipy.ndimage.maximum.html#scipy.ndimage.maximum
    "scipy.ndimage.maximum") 函数计算由*index*给定标签的对象元素的最大值，使用*labels*数组作为对象标签。如果*index*为`None`，则所有具有非零标签值的元素被视为单个对象。如果*label*为`None`，则计算中使用*input*的所有元素。'
- en: The [`minimum_position`](../reference/generated/scipy.ndimage.minimum_position.html#scipy.ndimage.minimum_position
    "scipy.ndimage.minimum_position") function calculates the position of the minimum
    of the elements of the object with label(s) given by *index*, using the *labels*
    array for the object labels. If *index* is `None`, all elements with a non-zero
    label value are treated as a single object. If *label* is `None`, all elements
    of *input* are used in the calculation.
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`minimum_position`](../reference/generated/scipy.ndimage.minimum_position.html#scipy.ndimage.minimum_position
    "scipy.ndimage.minimum_position") 函数计算由*index*给定标签的对象元素的最小位置，使用*labels*数组作为对象标签。如果*index*为`None`，则所有具有非零标签值的元素被视为单个对象。如果*label*为`None`，则计算中使用*input*的所有元素。'
- en: The [`maximum_position`](../reference/generated/scipy.ndimage.maximum_position.html#scipy.ndimage.maximum_position
    "scipy.ndimage.maximum_position") function calculates the position of the maximum
    of the elements of the object with label(s) given by *index*, using the *labels*
    array for the object labels. If *index* is `None`, all elements with a non-zero
    label value are treated as a single object. If *label* is `None`, all elements
    of *input* are used in the calculation.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`maximum_position`](../reference/generated/scipy.ndimage.maximum_position.html#scipy.ndimage.maximum_position
    "scipy.ndimage.maximum_position") 函数计算由*index*给定标签的对象元素的最大位置，使用*labels*数组作为对象标签。如果*index*为`None`，则所有具有非零标签值的元素被视为单个对象。如果*label*为`None`，则计算中使用*input*的所有元素。'
- en: The [`extrema`](../reference/generated/scipy.ndimage.extrema.html#scipy.ndimage.extrema
    "scipy.ndimage.extrema") function calculates the minimum, the maximum, and their
    positions, of the elements of the object with label(s) given by *index*, using
    the *labels* array for the object labels. If *index* is `None`, all elements with
    a non-zero label value are treated as a single object. If *label* is `None`, all
    elements of *input* are used in the calculation. The result is a tuple giving
    the minimum, the maximum, the position of the minimum, and the position of the
    maximum. The result is the same as a tuple formed by the results of the functions
    *minimum*, *maximum*, *minimum_position*, and *maximum_position* that are described
    above.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`extrema`](../reference/generated/scipy.ndimage.extrema.html#scipy.ndimage.extrema
    "scipy.ndimage.extrema") 函数计算由*index*给定标签的对象元素的最小值、最大值及其位置，使用*labels*数组作为对象标签。如果*index*为`None`，则所有具有非零标签值的元素被视为单个对象。如果*label*为`None`，则计算中使用*input*的所有元素。结果是一个元组，包含最小值、最大值、最小位置和最大位置。其结果与上述*minimum*、*maximum*、*minimum_position*
    和 *maximum_position* 函数的结果组成的元组相同。'
- en: The [`center_of_mass`](../reference/generated/scipy.ndimage.center_of_mass.html#scipy.ndimage.center_of_mass
    "scipy.ndimage.center_of_mass") function calculates the center of mass of the
    object with label(s) given by *index*, using the *labels* array for the object
    labels. If *index* is `None`, all elements with a non-zero label value are treated
    as a single object. If *label* is `None`, all elements of *input* are used in
    the calculation.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`center_of_mass`](../reference/generated/scipy.ndimage.center_of_mass.html#scipy.ndimage.center_of_mass
    "scipy.ndimage.center_of_mass") 函数计算由*index*给定标签的对象的质心，使用*labels*数组作为对象标签。如果*index*为`None`，则所有具有非零标签值的元素被视为单个对象。如果*label*为`None`，则计算中使用*input*的所有元素。'
- en: 'The [`histogram`](../reference/generated/scipy.ndimage.histogram.html#scipy.ndimage.histogram
    "scipy.ndimage.histogram") function calculates a histogram of the object with
    label(s) given by *index*, using the *labels* array for the object labels. If
    *index* is `None`, all elements with a non-zero label value are treated as a single
    object. If *label* is `None`, all elements of *input* are used in the calculation.
    Histograms are defined by their minimum (*min*), maximum (*max*), and the number
    of bins (*bins*). They are returned as 1-D arrays of type `numpy.int32`.  ## Extending
    [`scipy.ndimage`](../reference/ndimage.html#module-scipy.ndimage "scipy.ndimage")
    in C'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`histogram`](../reference/generated/scipy.ndimage.histogram.html#scipy.ndimage.histogram
    "scipy.ndimage.histogram") 函数使用 *index* 指定的标签的对象计算直方图，并使用 *labels* 数组作为对象标签。如果
    *index* 为 `None`，则所有具有非零标签值的元素将被视为单个对象。如果 *label* 为 `None`，则计算时使用 *input* 的所有元素。直方图由其最小值
    (*min*)、最大值 (*max*) 和箱数 (*bins*) 定义。它们作为 `numpy.int32` 类型的 1-D 数组返回。## 在 C 中扩展
    [`scipy.ndimage`](../reference/ndimage.html#module-scipy.ndimage "scipy.ndimage")'
- en: A few functions in [`scipy.ndimage`](../reference/ndimage.html#module-scipy.ndimage
    "scipy.ndimage") take a callback argument. This can be either a python function
    or a [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") containing a pointer to a C function. Using a C function
    will generally be more efficient, since it avoids the overhead of calling a python
    function on many elements of an array. To use a C function, you must write a C
    extension that contains the callback function and a Python function that returns
    a [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") containing a pointer to the callback.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[`scipy.ndimage`](../reference/ndimage.html#module-scipy.ndimage "scipy.ndimage")
    中的几个函数接受回调参数。这可以是一个 Python 函数或一个包含指向 C 函数指针的 [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable")。使用 C 函数通常更有效率，因为它避免了在数组的许多元素上调用 Python 函数的开销。要使用 C 函数，您必须编写一个
    C 扩展，其中包含回调函数和一个返回 [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") 的 Python 函数，该函数包含指向回调函数的指针。'
- en: An example of a function that supports callbacks is [`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform"), which accepts a callback function that defines
    a mapping from all output coordinates to corresponding coordinates in the input
    array. Consider the following python example, which uses [`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform") to implement a shift function.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 支持回调的一个函数示例是 [`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform")，它接受定义从所有输出坐标到输入数组中对应坐标的映射的回调函数。考虑以下 Python
    示例，它使用 [`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform") 实现了一个移位函数。
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can also implement the callback function with the following C code:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用以下 C 代码来实现回调函数：
- en: '[PRE45]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'More information on writing Python extension modules can be found [here](https://docs.python.org/3/extending/index.html).
    If the C code is in the file `example.c`, then it can be compiled after adding
    it to `meson.build` (see examples inside `meson.build` files) and follow what’s
    there. After that is done, running the script:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 关于编写 Python 扩展模块的更多信息可以在[这里](https://docs.python.org/3/extending/index.html)找到。如果
    C 代码在文件 `example.c` 中，则可以在将其添加到 `meson.build`（查看 `meson.build` 文件中的示例）之后进行编译并遵循其中的步骤。完成后，运行脚本：
- en: '[PRE46]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: produces the same result as the original python script.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 产生与原始的 Python 脚本相同的结果。
- en: In the C version, `_transform` is the callback function and the parameters `output_coordinates`
    and `input_coordinates` play the same role as they do in the python version, while
    `output_rank` and `input_rank` provide the equivalents of `len(output_coordinates)`
    and `len(input_coordinates)`. The variable `shift` is passed through `user_data`
    instead of `extra_arguments`. Finally, the C callback function returns an integer
    status, which is one upon success and zero otherwise.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C 版本中，`_transform` 是回调函数，参数 `output_coordinates` 和 `input_coordinates` 的作用与
    Python 版本相同，而 `output_rank` 和 `input_rank` 则提供了 `len(output_coordinates)` 和 `len(input_coordinates)`
    的等效值。变量 `shift` 通过 `user_data` 而不是 `extra_arguments` 传递。最后，C 回调函数返回一个整数状态，成功时为1，否则为0。
- en: 'The function `py_transform` wraps the callback function in a [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.12)"). The main steps are:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `py_transform` 将回调函数封装在 [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.12)") 中。主要步骤如下：
- en: Initialize a [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.12)"). The first argument is a pointer to the callback function.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化一个 [`PyCapsule`](https://docs.python.org/3/c-api/capsule.html#c.PyCapsule
    "(in Python v3.12)")。第一个参数是指向回调函数的指针。
- en: The second argument is the function signature, which must match exactly the
    one expected by [`ndimage`](../reference/ndimage.html#module-scipy.ndimage "scipy.ndimage").
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数是函数签名，必须与 [`ndimage`](../reference/ndimage.html#module-scipy.ndimage "scipy.ndimage")
    预期的完全匹配。
- en: Above, we used [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") to specify `user_data` that we generated with [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.12)").
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上述示例中，我们使用了 [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") 来指定由 [`ctypes`](https://docs.python.org/3/library/ctypes.html#module-ctypes
    "(in Python v3.12)") 生成的 `user_data`。
- en: A different approach would be to supply the data in the capsule context, that
    can be set by *PyCapsule_SetContext* and omit specifying `user_data` in [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable"). However, in this approach we would need to deal with
    allocation/freeing of the data — freeing the data after the capsule has been destroyed
    can be done by specifying a non-NULL callback function in the third argument of
    *PyCapsule_New*.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种方法是在胶囊上下文中提供数据，可以通过 *PyCapsule_SetContext* 设置，且在 [`scipy.LowLevelCallable`](../reference/generated/scipy.LowLevelCallable.html#scipy.LowLevelCallable
    "scipy.LowLevelCallable") 中省略指定 `user_data`。然而，在此方法中，我们需要处理数据的分配/释放 —— 在销毁胶囊后释放数据可以通过在
    *PyCapsule_New* 的第三个参数中指定非空回调函数来完成。
- en: C callback functions for [`ndimage`](../reference/ndimage.html#module-scipy.ndimage
    "scipy.ndimage") all follow this scheme. The next section lists the [`ndimage`](../reference/ndimage.html#module-scipy.ndimage
    "scipy.ndimage") functions that accept a C callback function and gives the prototype
    of the function.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 用于 [`ndimage`](../reference/ndimage.html#module-scipy.ndimage "scipy.ndimage")
    的 C 回调函数都遵循此模式。下一节列出了接受 C 回调函数并给出函数原型的 [`ndimage`](../reference/ndimage.html#module-scipy.ndimage
    "scipy.ndimage") 函数。
- en: See also
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: 'The functions that support low-level callback arguments are:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 支持低级回调参数的函数有：
- en: '[`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter"), [`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d"), [`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform")'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[`generic_filter`](../reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter
    "scipy.ndimage.generic_filter")，[`generic_filter1d`](../reference/generated/scipy.ndimage.generic_filter1d.html#scipy.ndimage.generic_filter1d
    "scipy.ndimage.generic_filter1d")，[`geometric_transform`](../reference/generated/scipy.ndimage.geometric_transform.html#scipy.ndimage.geometric_transform
    "scipy.ndimage.geometric_transform")'
- en: Below, we show alternative ways to write the code, using [Numba](https://numba.pydata.org/),
    [Cython](https://cython.org/), [ctypes](https://docs.python.org/3/library/ctypes.html),
    or [cffi](https://cffi.readthedocs.io/) instead of writing wrapper code in C.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，我们展示了使用 [Numba](https://numba.pydata.org/)、[Cython](https://cython.org/)、[ctypes](https://docs.python.org/3/library/ctypes.html)
    或 [cffi](https://cffi.readthedocs.io/) 写代码的替代方式，而不是在 C 中编写包装器代码。
- en: Numba
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Numba
- en: '[Numba](https://numba.pydata.org/) provides a way to write low-level functions
    easily in Python. We can write the above using Numba as:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[Numba](https://numba.pydata.org/) 提供了在 Python 中轻松编写低级函数的方式。我们可以使用 Numba 来编写上述代码：'
- en: '[PRE47]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Cython
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Cython
- en: 'Functionally the same code as above can be written in Cython with somewhat
    less boilerplate as follows:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 从功能上看，与上述代码相同的代码可以在 Cython 中写成，而且更少繁文缛节，如下所示：
- en: '[PRE48]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: cffi
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: cffi
- en: 'With [cffi](https://cffi.readthedocs.io/), you can interface with a C function
    residing in a shared library (DLL). First, we need to write the shared library,
    which we do in C — this example is for Linux/OSX:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [cffi](https://cffi.readthedocs.io/)，您可以与驻留在共享库（DLL）中的 C 函数进行接口。首先，我们需要编写共享库，在
    Linux/OSX 上如下：
- en: '[PRE50]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The Python code calling the library is:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 调用库的 Python 代码如下：
- en: '[PRE51]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: You can find more information in the [cffi](https://cffi.readthedocs.io/) documentation.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [cffi](https://cffi.readthedocs.io/) 文档中找到更多信息。
- en: ctypes
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: ctypes
- en: 'With *ctypes*, the C code and the compilation of the so/DLL is as for cffi
    above. The Python code is different:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *ctypes*，与上述 cffi 的情况一样，C 代码和 so/DLL 的编译是一样的。Python 代码则有所不同：
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You can find more information in the [ctypes](https://docs.python.org/3/library/ctypes.html)
    documentation.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [ctypes](https://docs.python.org/3/library/ctypes.html) 文档中找到更多信息。
- en: References
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
