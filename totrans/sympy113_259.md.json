["```py\nsympy.parsing.sympy_parser.parse_expr(s: str, local_dict: ~typing.Dict[str, ~typing.Any] | None = None, transformations: ~typing.Tuple[~typing.Callable[[~typing.List[~typing.Tuple[int, str]], ~typing.Dict[str, ~typing.Any], ~typing.Dict[str, ~typing.Any]], ~typing.List[~typing.Tuple[int, str]]], ...] | str = (<function lambda_notation>, <function auto_symbol>, <function repeated_decimals>, <function auto_number>, <function factorial_notation>), global_dict: ~typing.Dict[str, ~typing.Any] | None = None, evaluate=True)\n```", "```py\n>>> from sympy.parsing.sympy_parser import parse_expr\n>>> parse_expr(\"1/2\")\n1/2\n>>> type(_)\n<class 'sympy.core.numbers.Half'>\n>>> from sympy.parsing.sympy_parser import standard_transformations,\\\n... implicit_multiplication_application\n>>> transformations = (standard_transformations +\n...     (implicit_multiplication_application,))\n>>> parse_expr(\"2x\", transformations=transformations)\n2*x \n```", "```py\n>>> parse_expr(\"2**3\"), parse_expr(\"2**3\", evaluate=False)\n(8, 2**3) \n```", "```py\n>>> a = parse_expr('1 + x', evaluate=False)\n>>> b = parse_expr('x + 1', evaluate=0)\n>>> a == b\nFalse\n>>> a.args\n(1, x)\n>>> b.args\n(x, 1) \n```", "```py\n>>> assert str(a) == str(b) \n```", "```py\n>>> from sympy.parsing.sympy_parser import transformations \n```", "```py\n>>> print(transformations)\n0: lambda_notation\n1: auto_symbol\n2: repeated_decimals\n3: auto_number\n4: factorial_notation\n5: implicit_multiplication_application\n6: convert_xor\n7: implicit_application\n8: implicit_multiplication\n9: convert_equals_signs\n10: function_exponentiation\n11: rationalize \n```", "```py\n>>> from sympy.parsing.sympy_parser import T \n```", "```py\n>>> str(T) == str(transformations)\nTrue \n```", "```py\n>>> T[:5] == standard_transformations\nTrue \n```", "```py\n>>> parse_expr(\"2x\", transformations=T[:5])\nTraceback (most recent call last):\n...\nSyntaxError: invalid syntax\n>>> parse_expr(\"2x\", transformations=T[:6])\n2*x\n>>> parse_expr('.3', transformations=T[3, 11])\n3/10\n>>> parse_expr('.3x', transformations=T[:])\n3*x/10 \n```", "```py\n>>> parse_expr('.3x', transformations='all')\n3*x/10 \n```", "```py\nsympy.parsing.sympy_parser.stringify_expr(s: str, local_dict: Dict[str, Any], global_dict: Dict[str, Any], transformations: Tuple[Callable[[List[Tuple[int, str]], Dict[str, Any], Dict[str, Any]], List[Tuple[int, str]]], ...]) → str\n```", "```py\nsympy.parsing.sympy_parser.eval_expr(code, local_dict: Dict[str, Any], global_dict: Dict[str, Any])\n```", "```py\nsympy.parsing.maxima.parse_maxima(str, globals=None, name_dict={})\n```", "```py\nsympy.parsing.mathematica.parse_mathematica(s)\n```", "```py\n>>> from sympy.parsing.mathematica import parse_mathematica\n>>> parse_mathematica(\"Sin[x]^2 Tan[y]\")\nsin(x)**2*tan(y)\n>>> e = parse_mathematica(\"F[7,5,3]\")\n>>> e\nF(7, 5, 3)\n>>> from sympy import Function, Max, Min\n>>> e.replace(Function(\"F\"), lambda *x: Max(*x)*Min(*x))\n21 \n```", "```py\n>>> parse_mathematica(\"x*(a + b)\")\nx*(a + b)\n>>> parse_mathematica(\"Times[x, Plus[a, b]]\")\nx*(a + b) \n```", "```py\n>>> m = parse_mathematica(\"{{a, b}, {c, d}}\")\n>>> m\n((a, b), (c, d))\n>>> from sympy import Matrix\n>>> Matrix(m)\nMatrix([\n[a, b],\n[c, d]]) \n```", "```py\n>>> parse_mathematica(\"x_.\")\nOptional(Pattern(x, Blank()))\n>>> parse_mathematica(\"Plus @@ {x, y, z}\")\nApply(Plus, (x, y, z))\n>>> parse_mathematica(\"f[x_, 3] := x^3 /; x > 0\")\nSetDelayed(f(Pattern(x, Blank()), 3), Condition(x**3, x > 0)) \n```", "```py\nsympy.parsing.sympy_parser.standard_transformations: Tuple[Callable[[List[Tuple[int, str]], Dict[str, Any], Dict[str, Any]], List[Tuple[int, str]]], ...] = (<function lambda_notation>, <function auto_symbol>, <function repeated_decimals>, <function auto_number>, <function factorial_notation>)\n```", "```py\nsympy.parsing.sympy_parser.split_symbols(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any])\n```", "```py\nsympy.parsing.sympy_parser.split_symbols_custom(predicate: Callable[[str], bool])\n```", "```py\n>>> from sympy.parsing.sympy_parser import (parse_expr, _token_splittable,\n... standard_transformations, implicit_multiplication,\n... split_symbols_custom)\n>>> def can_split(symbol):\n...     if symbol not in ('list', 'of', 'unsplittable', 'names'):\n...             return _token_splittable(symbol)\n...     return False\n...\n>>> transformation = split_symbols_custom(can_split)\n>>> parse_expr('unsplittable', transformations=standard_transformations +\n... (transformation, implicit_multiplication))\nunsplittable \n```", "```py\nsympy.parsing.sympy_parser.implicit_multiplication(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any]) → List[Tuple[int, str]]\n```", "```py\n>>> from sympy.parsing.sympy_parser import (parse_expr,\n... standard_transformations, implicit_multiplication)\n>>> transformations = standard_transformations + (implicit_multiplication,)\n>>> parse_expr('3 x y', transformations=transformations)\n3*x*y \n```", "```py\nsympy.parsing.sympy_parser.implicit_application(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any]) → List[Tuple[int, str]]\n```", "```py\n>>> from sympy.parsing.sympy_parser import (parse_expr,\n... standard_transformations, implicit_application)\n>>> transformations = standard_transformations + (implicit_application,)\n>>> parse_expr('cot z + csc z', transformations=transformations)\ncot(z) + csc(z) \n```", "```py\nsympy.parsing.sympy_parser.function_exponentiation(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any])\n```", "```py\n>>> from sympy.parsing.sympy_parser import (parse_expr,\n... standard_transformations, function_exponentiation)\n>>> transformations = standard_transformations + (function_exponentiation,)\n>>> parse_expr('sin**4(x)', transformations=transformations)\nsin(x)**4 \n```", "```py\nsympy.parsing.sympy_parser.implicit_multiplication_application(result: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any]) → List[Tuple[int, str]]\n```", "```py\n>>> from sympy.parsing.sympy_parser import (parse_expr,\n... standard_transformations, implicit_multiplication_application)\n>>> parse_expr(\"10sin**2 x**2 + 3xyz + tan theta\",\n... transformations=(standard_transformations +\n... (implicit_multiplication_application,)))\n3*x*y*z + 10*sin(x**2)**2 + tan(theta) \n```", "```py\nsympy.parsing.sympy_parser.rationalize(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any])\n```", "```py\nsympy.parsing.sympy_parser.convert_xor(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any])\n```", "```py\nsympy.parsing.sympy_parser.lambda_notation(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any])\n```", "```py\nsympy.parsing.sympy_parser.auto_symbol(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any])\n```", "```py\nsympy.parsing.sympy_parser.repeated_decimals(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any])\n```", "```py\nsympy.parsing.sympy_parser.auto_number(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any])\n```", "```py\nsympy.parsing.sympy_parser.factorial_notation(tokens: List[Tuple[int, str]], local_dict: Dict[str, Any], global_dict: Dict[str, Any])\n```", "```py\nsympy.parsing.latex.parse_latex(s, strict=False, backend='antlr')\n```", "```py\n>>> from sympy.parsing.latex import parse_latex\n>>> expr = parse_latex(r\"\\frac {1 + \\sqrt {\\a}} {\\b}\")\n>>> expr\n(sqrt(a) + 1)/b\n>>> expr.evalf(4, subs=dict(a=5, b=2))\n1.618\n>>> func = parse_latex(r\"\\int_1^\\alpha \\dfrac{\\mathrm{d}t}{t}\", backend=\"lark\")\n>>> func.evalf(subs={\"alpha\": 2})\n0.693147180559945 \n```", "```py\nparse_latex(r'x -') \n```", "```py\nparse_latex(r'x -', backend='ANTLR') \n```", "```py\nparse_latex(r'x -', backend='Lark') \n```", "```py\nsympy.parsing.latex.parse_latex_lark(s: str)\n```", "```py\nclass sympy.parsing.latex.lark.LarkLaTeXParser(print_debug_output=False, transform=True, grammar_file=None, transformer=None)\n```", "```py\nclass sympy.parsing.latex.lark.TransformToSymPyExpr\n```", "```py\nclass sympy.parsing.latex.LaTeXParsingError\n```", "```py\nclass sympy.parsing.sym_expr.SymPyExpression(source_code=None, mode=None)\n```", "```py\n>>> from sympy.parsing.sym_expr import SymPyExpression\n>>> src = '''\n... int a,b;\n... float c = 2, d =4;\n... '''\n>>> a = SymPyExpression(src, 'c')\n>>> a.return_expr()\n[Declaration(Variable(a, type=intc)),\nDeclaration(Variable(b, type=intc)),\nDeclaration(Variable(c, type=float32, value=2.0)),\nDeclaration(Variable(d, type=float32, value=4.0))] \n```", "```py\n>>> from sympy.parsing.sym_expr import SymPyExpression\n>>> src2 = '''\n... integer :: a, b, c, d\n... real :: p, q, r, s\n... '''\n>>> p = SymPyExpression()\n>>> p.convert_to_expr(src2, 'f')\n>>> p.convert_to_c()\n['int a = 0', 'int b = 0', 'int c = 0', 'int d = 0', 'double p = 0.0', 'double q = 0.0', 'double r = 0.0', 'double s = 0.0'] \n```", "```py\n>>> from sympy.parsing.sym_expr import SymPyExpression\n>>> src3 = '''\n... integer :: a, b, c, d, e\n... d = a + b - c\n... e = b * d + c * e / a\n... '''\n>>> p = SymPyExpression(src3, 'f')\n>>> p.convert_to_python()\n['a = 0', 'b = 0', 'c = 0', 'd = 0', 'e = 0', 'd = a + b - c', 'e = b*d + c*e/a'] \n```", "```py\n>>> from sympy.parsing.sym_expr import SymPyExpression\n>>> src = '''\n... integer function f(a,b)\n... integer, intent(in) :: a, b\n... integer :: r\n... end function\n... '''\n>>> a = SymPyExpression(src, 'f')\n>>> a.convert_to_python()\n['def f(a, b):\\n   f = 0\\n    r = 0\\n    return f'] \n```", "```py\nconvert_to_c()\n```", "```py\n>>> from sympy.parsing.sym_expr import SymPyExpression\n>>> src2 = '''\n... integer :: a, b, c, d\n... real :: p, q, r, s\n... c = a/b\n... d = c/a\n... s = p/q\n... r = q/p\n... '''\n>>> p = SymPyExpression()\n>>> p.convert_to_expr(src2, 'f')\n>>> p.convert_to_c()\n['int a = 0', 'int b = 0', 'int c = 0', 'int d = 0', 'double p = 0.0', 'double q = 0.0', 'double r = 0.0', 'double s = 0.0', 'c = a/b;', 'd = c/a;', 's = p/q;', 'r = q/p;'] \n```", "```py\nconvert_to_expr(src_code, mode)\n```", "```py\n>>> from sympy.parsing.sym_expr import SymPyExpression\n>>> src3 = '''\n... integer function f(a,b) result(r)\n... integer, intent(in) :: a, b\n... integer :: x\n... r = a + b -x\n... end function\n... '''\n>>> p = SymPyExpression()\n>>> p.convert_to_expr(src3, 'f')\n>>> p.return_expr()\n[FunctionDefinition(integer, name=f, parameters=(Variable(a), Variable(b)), body=CodeBlock(\nDeclaration(Variable(r, type=integer, value=0)),\nDeclaration(Variable(x, type=integer, value=0)),\nAssignment(Variable(r), a + b - x),\nReturn(Variable(r))\n))] \n```", "```py\nconvert_to_fortran()\n```", "```py\n>>> from sympy.parsing.sym_expr import SymPyExpression\n>>> src2 = '''\n... integer :: a, b, c, d\n... real :: p, q, r, s\n... c = a/b\n... d = c/a\n... s = p/q\n... r = q/p\n... '''\n>>> p = SymPyExpression(src2, 'f')\n>>> p.convert_to_fortran()\n['      integer*4 a', '      integer*4 b', '      integer*4 c', '      integer*4 d', '      real*8 p', '      real*8 q', '      real*8 r', '      real*8 s', '      c = a/b', '      d = c/a', '      s = p/q', '      r = q/p'] \n```", "```py\nconvert_to_python()\n```", "```py\n>>> from sympy.parsing.sym_expr import SymPyExpression\n>>> src2 = '''\n... integer :: a, b, c, d\n... real :: p, q, r, s\n... c = a/b\n... d = c/a\n... s = p/q\n... r = q/p\n... '''\n>>> p = SymPyExpression(src2, 'f')\n>>> p.convert_to_python()\n['a = 0', 'b = 0', 'c = 0', 'd = 0', 'p = 0.0', 'q = 0.0', 'r = 0.0', 's = 0.0', 'c = a/b', 'd = c/a', 's = p/q', 'r = q/p'] \n```", "```py\nreturn_expr()\n```", "```py\n>>> from sympy.parsing.sym_expr import SymPyExpression\n>>> src3 = '''\n... integer function f(a,b)\n... integer, intent(in) :: a, b\n... integer :: r\n... r = a+b\n... f = r\n... end function\n... '''\n>>> p = SymPyExpression()\n>>> p.convert_to_expr(src3, 'f')\n>>> p.return_expr()\n[FunctionDefinition(integer, name=f, parameters=(Variable(a), Variable(b)), body=CodeBlock(\nDeclaration(Variable(f, type=integer, value=0)),\nDeclaration(Variable(r, type=integer, value=0)),\nAssignment(Variable(f), Variable(r)),\nReturn(Variable(f))\n))] \n```", "```py\n$ pip install antlr4-python3-runtime==4.11 \n```", "```py\n$ conda install -c conda-forge antlr-python-runtime==4.11 \n```", "```py\n$ conda install -c conda-forge lfortran clang \n```"]