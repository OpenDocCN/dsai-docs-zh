- en: scipy.signal.minimum_phase
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.minimum_phase.html#scipy.signal.minimum_phase](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.minimum_phase.html#scipy.signal.minimum_phase)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Convert a linear-phase FIR filter to minimum phase
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**h**array'
  prefs: []
  type: TYPE_NORMAL
- en: Linear-phase FIR filter coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: '**method**{‘hilbert’, ‘homomorphic’}'
  prefs: []
  type: TYPE_NORMAL
- en: 'The method to use:'
  prefs: []
  type: TYPE_NORMAL
- en: ‘homomorphic’ (default)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This method [[4]](#rde52ba5e24c3-4) [[5]](#rde52ba5e24c3-5) works best with
    filters with an odd number of taps, and the resulting minimum phase filter will
    have a magnitude response that approximates the square root of the original filter’s
    magnitude response.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ‘hilbert’
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This method [[1]](#rde52ba5e24c3-1) is designed to be used with equiripple filters
    (e.g., from [`remez`](scipy.signal.remez.html#scipy.signal.remez "scipy.signal.remez"))
    with unity or zero gain regions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**n_fft**int'
  prefs: []
  type: TYPE_NORMAL
- en: The number of points to use for the FFT. Should be at least a few times larger
    than the signal length (see Notes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**h_minimum**array'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum-phase version of the filter, with length `(length(h) + 1) // 2`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`firwin`](scipy.signal.firwin.html#scipy.signal.firwin "scipy.signal.firwin")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`firwin2`](scipy.signal.firwin2.html#scipy.signal.firwin2 "scipy.signal.firwin2")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`remez`](scipy.signal.remez.html#scipy.signal.remez "scipy.signal.remez")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Both the Hilbert [[1]](#rde52ba5e24c3-1) or homomorphic [[4]](#rde52ba5e24c3-4)
    [[5]](#rde52ba5e24c3-5) methods require selection of an FFT length to estimate
    the complex cepstrum of the filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the Hilbert method, the deviation from the ideal spectrum `epsilon`
    is related to the number of stopband zeros `n_stop` and FFT length `n_fft` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, with 100 stopband zeros and a FFT length of 2048, `epsilon = 0.0976`.
    If we conservatively assume that the number of stopband zeros is one less than
    the filter length, we can take the FFT length to be the next power of 2 that satisfies
    `epsilon=0.01` as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This gives reasonable results for both the Hilbert and homomorphic methods,
    and gives the value used when `n_fft=None`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternative implementations exist for creating minimum-phase filters, including
    zero inversion [[2]](#rde52ba5e24c3-2) and spectral factorization [[3]](#rde52ba5e24c3-3)
    [[4]](#rde52ba5e24c3-4). For more information, see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://dspguru.com/dsp/howtos/how-to-design-minimum-phase-fir-filters](http://dspguru.com/dsp/howtos/how-to-design-minimum-phase-fir-filters)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1] ([1](#id3),[2](#id4))'
  prefs: []
  type: TYPE_NORMAL
- en: N. Damera-Venkata and B. L. Evans, “Optimal design of real and complex minimum
    phase digital FIR filters,” Acoustics, Speech, and Signal Processing, 1999\. Proceedings.,
    1999 IEEE International Conference on, Phoenix, AZ, 1999, pp. 1145-1148 vol.3.
    [DOI:10.1109/ICASSP.1999.756179](https://doi.org/10.1109/ICASSP.1999.756179)
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: X. Chen and T. W. Parks, “Design of optimal minimum phase FIR filters by direct
    factorization,” Signal Processing, vol. 10, no. 4, pp. 369-383, Jun. 1986.
  prefs: []
  type: TYPE_NORMAL
- en: '[[3](#id8)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'T. Saramaki, “Finite Impulse Response Filter Design,” in Handbook for Digital
    Signal Processing, chapter 4, New York: Wiley-Interscience, 1993.'
  prefs: []
  type: TYPE_NORMAL
- en: '[4] ([1](#id1),[2](#id5),[3](#id9))'
  prefs: []
  type: TYPE_NORMAL
- en: 'J. S. Lim, Advanced Topics in Signal Processing. Englewood Cliffs, N.J.: Prentice
    Hall, 1988.'
  prefs: []
  type: TYPE_NORMAL
- en: '[5] ([1](#id2),[2](#id6))'
  prefs: []
  type: TYPE_NORMAL
- en: 'A. V. Oppenheim, R. W. Schafer, and J. R. Buck, “Discrete-Time Signal Processing,”
    2nd edition. Upper Saddle River, N.J.: Prentice Hall, 1999.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an optimal linear-phase filter, then convert it to minimum phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert it to minimum phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare the three filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-signal-minimum_phase-1.png](../Images/bfe8f5797209b34d94df19494fc65890.png)'
  prefs: []
  type: TYPE_IMG
