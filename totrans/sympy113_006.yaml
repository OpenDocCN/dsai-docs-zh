- en: Gotchas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/tutorials/intro-tutorial/gotchas.html](https://docs.sympy.org/latest/tutorials/intro-tutorial/gotchas.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To begin, we should make something about SymPy clear. SymPy is nothing more
    than a Python library, like `NumPy`, `Django`, or even modules in the Python standard
    library `sys` or `re`. What this means is that SymPy does not add anything to
    the Python language. Limitations that are inherent in the Python language are
    also inherent in SymPy. It also means that SymPy tries to use Python idioms whenever
    possible, making programming with SymPy easy for those already familiar with programming
    with Python. As a simple example, SymPy uses Python syntax to build expressions.
    Implicit multiplication (like `3x` or `3 x`) is not allowed in Python, and thus
    not allowed in SymPy. To multiply `3` and `x`, you must type `3*x` with the `*`.
  prefs: []
  type: TYPE_NORMAL
- en: '## Symbols'
  prefs: []
  type: TYPE_NORMAL
- en: 'One consequence of this fact is that SymPy can be used in any environment where
    Python is available. We just import it, like we would any other library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This imports all the functions and classes from SymPy into our interactive Python
    session. Now, suppose we start to do a computation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Oops! What happened here? We tried to use the variable `x`, but it tells us
    that `x` is not defined. In Python, variables have no meaning until they are defined.
    SymPy is no different. Unlike many symbolic manipulation systems you may have
    used, in SymPy, variables are not defined automatically. To define variables,
    we must use `symbols`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`symbols` takes a string of variable names separated by spaces or commas, and
    creates Symbols out of them. We can then assign these to variable names. Later,
    we will investigate some convenient ways we can work around this issue. For now,
    let us just define the most common variable names, `x`, `y`, and `z`, for use
    through the rest of this section'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As a final note, we note that the name of a Symbol and the name of the variable
    it is assigned to need not have anything to do with one another.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here we have done the very confusing thing of assigning a Symbol with the name
    `a` to the variable `b`, and a Symbol of the name `b` to the variable `a`. Now
    the Python variable named `a` points to the SymPy Symbol named `b`, and vice versa.
    How confusing. We could have also done something like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This also shows that Symbols can have names longer than one character if we
    want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, the best practice is to assign Symbols to Python variables of the
    same name, although there are exceptions: Symbol names can contain characters
    that are not allowed in Python variable names, or may just want to avoid typing
    long names by assigning Symbols with long names to single letter Python variables.'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid confusion, throughout this tutorial, Symbol names and Python variable
    names will always coincide. Furthermore, the word “Symbol” will refer to a SymPy
    Symbol and the word “variable” will refer to a Python variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let us be sure we understand the difference between SymPy Symbols
    and Python variables. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: What do you think the output of this code will be? If you thought `3`, you’re
    wrong. Let’s see what really happens
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Changing `x` to `2` had no effect on `expr`. This is because `x = 2` changes
    the Python variable `x` to `2`, but has no effect on the SymPy Symbol `x`, which
    was what we used in creating `expr`. When we created `expr`, the Python variable
    `x` was a Symbol. After we created, it, we changed the Python variable `x` to
    2\. But `expr` remains the same. This behavior is not unique to SymPy. All Python
    programs work this way: if a variable is changed, expressions that were already
    created with that variable do not change automatically. For example'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, if we want to know what `expr` is with the new value of `x`,
    we need to reevaluate the code that created `expr`, namely, `expr = x + 1`. This
    can be complicated if several lines created `expr`. One advantage of using a symbolic
    computation system like SymPy is that we can build a symbolic representation for
    `expr`, and then substitute `x` with values. The correct way to do this in SymPy
    is to use `subs`, which will be discussed in more detail later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]  ## Equals signs'
  prefs: []
  type: TYPE_NORMAL
- en: Another very important consequence of the fact that SymPy does not extend Python
    syntax is that `=` does not represent equality in SymPy. Rather it is Python variable
    assignment. This is hard-coded into the Python language, and SymPy makes no attempts
    to change that.
  prefs: []
  type: TYPE_NORMAL
- en: You may think, however, that `==`, which is used for equality testing in Python,
    is used for SymPy as equality. This is not quite correct either. Let us see what
    happens when we use `==`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Instead of treating `x + 1 == 4` symbolically, we just got `False`. In SymPy,
    `==` represents exact structural equality testing. This means that `a == b` means
    that we are *asking* if \(a = b\). We always get a `bool` as the result of `==`.
    There is a separate object, called `Eq`, which can be used to create symbolic
    equalities
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one additional caveat about `==` as well. Suppose we want to know
    if \((x + 1)^2 = x^2 + 2x + 1\). We might try something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We got `False` again. However, \((x + 1)^2\) *does* equal \(x^2 + 2x + 1\).
    What is going on here? Did we find a bug in SymPy, or is it just not powerful
    enough to recognize this basic algebraic fact?
  prefs: []
  type: TYPE_NORMAL
- en: Recall from above that `==` represents *exact* structural equality testing.
    “Exact” here means that two expressions will compare equal with `==` only if they
    are exactly equal structurally. Here, \((x + 1)^2\) and \(x^2 + 2x + 1\) are not
    the same structurally. One is the power of an addition of two terms, and the other
    is the addition of three terms.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that when using SymPy as a library, having `==` test for exact
    structural equality is far more useful than having it represent symbolic equality,
    or having it test for mathematical equality. However, as a new user, you will
    probably care more about the latter two. We have already seen an alternative to
    representing equalities symbolically, `Eq`. To test if two things are equal, it
    is best to recall the basic fact that if \(a = b\), then \(a - b = 0\). Thus,
    the best way to check if \(a = b\) is to take \(a - b\) and simplify it, and see
    if it goes to 0\. We will learn [later](simplification.html#tutorial-simplify)
    that the function to do this is called `simplify`. This method is not infallible—in
    fact, it can be [theoretically proven](https://en.wikipedia.org/wiki/Richardson%27s_theorem)
    that it is impossible to determine if two symbolic expressions are identically
    equal in general—but for most common expressions, it works quite well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is also a method called `equals` that tests if two expressions are equal
    by evaluating them numerically at random points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]  ## Two Final Notes: `^` and `/`'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we have been using `**` for exponentiation instead
    of the standard `^`. That’s because SymPy follows Python’s conventions. In Python,
    `^` represents logical exclusive or. SymPy follows this convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, a small technical discussion on how SymPy works is in order. When you
    type something like `x + 1`, the SymPy Symbol `x` is added to the Python int `1`.
    Python’s operator rules then allow SymPy to tell Python that SymPy objects know
    how to be added to Python ints, and so `1` is automatically converted to the SymPy
    Integer object.
  prefs: []
  type: TYPE_NORMAL
- en: This sort of operator magic happens automatically behind the scenes, and you
    rarely need to even know that it is happening. However, there is one exception.
    Whenever you combine a SymPy object and a SymPy object, or a SymPy object and
    a Python object, you get a SymPy object, but whenever you combine two Python objects,
    SymPy never comes into play, and so you get a Python object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is usually not a big deal. Python ints work much the same as SymPy Integers,
    but there is one important exception: division. In SymPy, the division of two
    Integers gives a Rational:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'But in Python `/` represents either integer division or floating point division,
    depending on whether you are in Python 2 or Python 3, and depending on whether
    or not you have run `from __future__ import division` in Python 2 which is no
    longer supported from versions above SymPy 1.5.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To avoid this, we can construct the rational object explicitly
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This problem also comes up whenever we have a larger symbolic expression with
    `int/int` in it. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This happens because Python first evaluates `1/2` into `0.5`, and then that
    is cast into a SymPy type when it is added to `x`. Again, we can get around this
    by explicitly creating a Rational:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: There are several tips on avoiding this situation in the [Gotchas and Pitfalls](../../explanation/gotchas.html#gotchas)
    document.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For more discussion on the topics covered in this section, see [Gotchas and
    Pitfalls](../../explanation/gotchas.html#gotchas).
  prefs: []
  type: TYPE_NORMAL
