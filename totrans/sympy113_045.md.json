["```py\nimport warnings\nfrom sympy.utilities.exceptions import SymPyDeprecationWarning\n\nwarnings.filterwarnings(\n    # replace \"ignore\" with \"error\" to make the warning raise an exception.\n    # This useful if you want to test you aren't using deprecated code.\n    \"ignore\",\n\n    # message may be omitted to filter all SymPyDeprecationWarnings\n    message=r\"(?s).*<regex matching the warning message>\",\n\n    category=SymPyDeprecationWarning,\n    module=r\"<regex matching your module>\"\n) \n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.mechanics import Body\n>>> Body(\"rigid_body\")  \nrigid_body\n>>> Body(\"particle\", mass=symbols(\"m\"))  \nparticle \n```", "```py\n>>> from sympy.physics.mechanics import RigidBody, Particle\n>>> RigidBody(\"rigid_body\")\nrigid_body\n>>> Particle(\"particle\")\nparticle \n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.mechanics import (\n...   Body, JointsMethod, PinJoint, PrismaticJoint)\n>>> g, l = symbols(\"g l\")\n>>> wall = Body(\"wall\")\n>>> cart = Body(\"cart\")\n>>> pendulum = Body(\"Pendulum\")\n>>> slider = PrismaticJoint(\"s\", wall, cart, joint_axis=wall.x)\n>>> pin = PinJoint(\"j\", cart, pendulum, joint_axis=cart.z,\n...                child_point=l * pendulum.y)\n>>> pendulum.masscenter.set_vel(pendulum.frame, 0)\n>>> cart.apply_force(-g * cart.mass * wall.y)\n>>> pendulum.apply_force(-g * pendulum.mass * wall.y)\n>>> method = JointsMethod(wall, slider, pin)  \n>>> method.form_eoms()  \nMatrix([\n[ Pendulum_mass*l*u_j(t)**2*sin(q_j(t)) - Pendulum_mass*l*cos(q_j(t))*Derivative(u_j(t), t) - (Pendulum_mass + cart_mass)*Derivative(u_s(t), t)],\n[-Pendulum_mass*g*l*sin(q_j(t)) - Pendulum_mass*l*cos(q_j(t))*Derivative(u_s(t), t) - (Pendulum_izz + Pendulum_mass*l**2)*Derivative(u_j(t), t)]]) \n```", "```py\n>>> from sympy import symbols\n>>> from sympy.physics.mechanics import (\n...   Particle, PinJoint, PrismaticJoint, RigidBody, System)\n>>> g, l = symbols(\"g l\")\n>>> wall = RigidBody(\"wall\")\n>>> cart = RigidBody(\"cart\")\n>>> pendulum = RigidBody(\"Pendulum\")\n>>> slider = PrismaticJoint(\"s\", wall, cart, joint_axis=wall.x)\n>>> pin = PinJoint(\"j\", cart, pendulum, joint_axis=cart.z,\n...                child_point=l * pendulum.y)\n>>> system = System.from_newtonian(wall)\n>>> system.add_joints(slider, pin)\n>>> system.apply_uniform_gravity(-g * wall.y)\n>>> system.form_eoms()\nMatrix([\n[ Pendulum_mass*l*u_j(t)**2*sin(q_j(t)) - Pendulum_mass*l*cos(q_j(t))*Derivative(u_j(t), t) - (Pendulum_mass + cart_mass)*Derivative(u_s(t), t)],\n[-Pendulum_mass*g*l*sin(q_j(t)) - Pendulum_mass*l*cos(q_j(t))*Derivative(u_s(t), t) - (Pendulum_izz + Pendulum_mass*l**2)*Derivative(u_j(t), t)]]) \n```", "```py\nclass MatrixRequired:\nclass MatrixShaping(MatrixRequired):\nclass MatrixSpecial(MatrixRequired):\nclass MatrixProperties(MatrixRequired):\nclass MatrixOperations(MatrixRequired):\nclass MatrixArithmetic(MatrixRequired):\nclass MatrixCommon(\n    MatrixArithmetic,\n    MatrixOperations,\n    MatrixProperties,\n    MatrixSpecial,\n    MatrixShaping):\nclass MatrixDeterminant(MatrixCommon):\nclass MatrixReductions(MatrixDeterminant):\nclass MatrixSubspaces(MatrixReductions):\nclass MatrixEigen(MatrixSubspaces)\nclass MatrixCalculus(MatrixCommon):\nclass MatrixDeprecated(MatrixCommon):\nclass MatrixBase(MatrixDeprecated,\n   MatrixCalculus,\n   MatrixEigen,\n   MatrixCommon,\n   Printable):\nclass RepMatrix(MatrixBase):\nclass DenseMatrix(RepMatrix):\nclass MutableRepMatrix(RepMatrix):\nclass MutableDenseMatrix(DenseMatrix, MutableRepMatrix): \n```", "```py\nclass MatrixBase(Printable):\nclass RepMatrix(MatrixBase):\nclass DenseMatrix(RepMatrix):\nclass MutableRepMatrix(RepMatrix):\nclass MutableDenseMatrix(DenseMatrix, MutableRepMatrix): \n```", "```py\n>>> from sympy import symbols, Poly\n>>> x = symbols('x')\n>>> p = Poly(x**2 + 2*x + 3)\n>>> p\nPoly(x**2 + 2*x + 3, x, domain='ZZ')\n>>> p.rep  \nDMP([1, 2, 3], ZZ)\n>>> p.rep.rep  \n[1, 2, 3] \n```", "```py\n>>> p.rep.to_list()\n[1, 2, 3] \n```", "```py\np = plot(x,\n  markers=[{\"args\":[[0, 1], [0, 1]], \"marker\": \"*\", \"linestyle\": \"none\"}],\n  annotations=[{\"text\": \"test\", \"xy\": (0, 0)}],\n  fill={\"x\": [0, 1, 2, 3], \"y1\": [0, 1, 2, 3]},\n  rectangles=[{\"xy\": (0, 0), \"width\": 5, \"height\": 1}]) \n```", "```py\np = plot(x, show=False)\np.markers = [{\"args\":[[0, 1], [0, 1]], \"marker\": \"*\", \"linestyle\": \"none\"}]\np.annotations = [{\"text\": \"test\", \"xy\": (0, 0)}]\np.fill = {\"x\": [0, 1, 2, 3], \"y1\": [0, 1, 2, 3]}\np.rectangles = [{\"xy\": (0, 0), \"width\": 5, \"height\": 1}]\np.show() \n```", "```py\n# plot symbolic expression\np = plot(cos(x))\n# retrieve Matplotlib's figure and axes object\nfig, ax = p._backend.fig, p._backend.ax[0]\n# add the desired numerical data using Matplotlib's API\nax.plot([0, 1, 2], [0, 1, -1], \"*\")\nax.axhline(0.5)\n# visualize the figure\nfig \n```", "```py\n>>> from sympy.physics.mechanics.functions import inertia, inertia_of_point_mass, gravity \n```", "```py\n>>> from sympy.physics.mechanics import inertia, inertia_of_point_mass\n>>> from sympy.physics.mechanics.loads import gravity \n```", "```py\n>>> from sympy import GF\n>>> F5 = GF(5)\n>>> F5(2) < F5(3) \nTrue \n```", "```py\n>>> e = F5(4)\n>>> e + 1 > e \nFalse \n```", "```py\n>>> from sympy import GF\n>>> K = GF(5)\n>>> a = K(7)\n>>> a\n2 mod 5 \n```", "```py\n>>> # this is deprecated:\n>>> a.to_int()  \n2 \n```", "```py\n>>> K.to_int(a)\n2\n>>> int(a)\n2 \n```", "```py\n>>> KS = GF(5, symmetric=True)\n>>> KU = GF(5, symmetric=False)\n>>> [KS.to_int(KS(n)) for n in range(10)]\n[0, 1, 2, -2, -1, 0, 1, 2, -2, -1]\n>>> [KU.to_int(KU(n)) for n in range(10)]\n[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\n>>> [int(KS(n)) for n in range(10)]\n[0, 1, 2, 3, 4, 0, 1, 2, 3, 4]\n>>> [int(KU(n)) for n in range(10)]\n[0, 1, 2, 3, 4, 0, 1, 2, 3, 4] \n```", "```py\n    def to_int(K, a):\n        if hasattr(K, 'to_int'):\n            return K.to_int(a)\n        else:\n            return a.to_int() \n    ```", "```py\n>>> from sympy import carmichael\n>>> carmichael.is_carmichael(561)\nTrue \n```", "```py\n>>> from sympy import is_carmichael\n>>> is_carmichael(561)\nTrue \n```", "```py\n>>> from sympy.physics.mechanics import Body, PinJoint\n>>> parent, child = Body('parent'), Body('child')\n>>> pin = PinJoint('pin', parent, child, parent_axis=parent.z,\n...                child_axis=-child.z)   \n>>> parent.dcm(child)   \nMatrix([\n[-cos(q_pin(t)), -sin(q_pin(t)),  0],\n[-sin(q_pin(t)),  cos(q_pin(t)),  0],\n[             0,              0, -1]]) \n```", "```py\n>>> from sympy import pi\n>>> from sympy.physics.mechanics import Body, PinJoint, ReferenceFrame\n>>> parent, child, = Body('parent'), Body('child')\n>>> int_frame = ReferenceFrame('int_frame')\n>>> int_frame.orient_axis(child.frame, child.y, pi)\n>>> pin = PinJoint('pin', parent, child, joint_axis=parent.z,\n...                child_interframe=int_frame)\n>>> parent.dcm(child)\nMatrix([\n[-cos(q_pin(t)), -sin(q_pin(t)),  0],\n[-sin(q_pin(t)),  cos(q_pin(t)),  0],\n[             0,              0, -1]]) \n```", "```py\n>>> from sympy.physics.mechanics import Body, PinJoint\n>>> parent, child = Body('parent'), Body('child')\n>>> pin = PinJoint('pin', parent, child, parent_interframe=parent.z,\n...                child_interframe=-child.z)\n>>> parent.dcm(child)\nMatrix([\n[-cos(q_pin(t)), -sin(q_pin(t)),  0],\n[-sin(q_pin(t)),  cos(q_pin(t)),  0],\n[             0,              0, -1]]) \n```", "```py\n>>> from sympy.physics.mechanics import Body, PinJoint\n>>> parent, child = Body('parent'), Body('child')\n>>> pin = PinJoint('pin', parent, child, parent_joint_pos=parent.frame.x,\n...                child_joint_pos=-child.frame.x)   \n>>> pin.parent_point.pos_from(parent.masscenter)   \nparent_frame.x\n>>> pin.child_point.pos_from(child.masscenter)   \n- child_frame.x \n```", "```py\n>>> from sympy.physics.mechanics import Body, PinJoint\n>>> parent, child = Body('parent'), Body('child')\n>>> pin = PinJoint('pin', parent, child, parent_point=parent.frame.x,\n...                child_point=-child.frame.x)\n>>> pin.parent_point.pos_from(parent.masscenter)\nparent_frame.x\n>>> pin.child_point.pos_from(child.masscenter)\n- child_frame.x \n```", "```py\n>>> from sympy.physics.mechanics import Body, PinJoint, Point\n>>> parent, child = Body('parent'), Body('child')\n>>> parent_point = parent.masscenter.locatenew('parent_point', parent.frame.x)\n>>> child_point = child.masscenter.locatenew('child_point', -child.frame.x)\n>>> pin = PinJoint('pin', parent, child, parent_point=parent_point,\n...                child_point=child_point)\n>>> pin.parent_point.pos_from(parent.masscenter)\nparent_frame.x\n>>> pin.child_point.pos_from(child.masscenter)\n- child_frame.x \n```", "```py\n>>> from sympy.parsing.mathematica import mathematica\n>>> mathematica('F[7,5,3]', {'F[*x]': 'Max(*x)*Min(*x)'})   \n21 \n```", "```py\n>>> from sympy.parsing.mathematica import parse_mathematica\n>>> from sympy import Function, Max, Min\n>>> parse_mathematica(\"F[7,5,3]\").replace(Function(\"F\"), lambda *x: Max(*x)*Min(*x))\n21 \n```", "```py\nn % p == 0 \n```", "```py\nsympy.preorder_traversal \n```", "```py\nfrom sympy import preorder_traversal \n```", "```py\nsympy.ordered\nsympy.default_sort_key \n```", "```py\nfrom sympy import ordered, default_sort_key \n```", "```py\n>>> from sympy import Indexed, MatrixSymbol, diff\n>>> a = Indexed(\"A\", 0)\n>>> diff(a**2, a)\n2*A[0]\n>>> X = MatrixSymbol(\"X\", 3, 3)\n>>> diff(X[0, 0]**2, X[0, 0])\n2*X[0, 0] \n```", "```py\n    >>> from sympy import Derivative, symbols, Function\n    >>> x = symbols('x')\n    >>> f = Function('f')\n    >>> Derivative(f(x), x).expr\n    f(x) \n    ```", "```py\n    >>> S(2).expr_free_symbols \n    2 \n    ```", "```py\n>>> from sympy.stats import Die, sample\n>>> X = Die('X', 6)\n>>> sample(X, numsamples=3) \n[3, 2, 3] \n```", "```py\n>>> [sample(X) for i in range(3)] \n[5, 4, 3] \n```", "```py\n>>> sample(X, size=(3,)) \narray([6, 6, 1]) \n```", "```py\n>>> M = Matrix([[(1, 2), {}]]) \n```", "```py\n>>> M + M \nTraceback (most recent call last):\n...\nTypeError: unsupported operand type(s) for +: 'Dict' and 'Dict' \n```", "```py\n>>> from sympy.physics.matrices import mdft\n>>> mdft(3) # DEPRECATED \nMatrix([\n[sqrt(3)/3,                sqrt(3)/3,                sqrt(3)/3],\n[sqrt(3)/3, sqrt(3)*exp(-2*I*pi/3)/3,  sqrt(3)*exp(2*I*pi/3)/3],\n[sqrt(3)/3,  sqrt(3)*exp(2*I*pi/3)/3, sqrt(3)*exp(-2*I*pi/3)/3]]) \n```", "```py\n>>> from sympy.matrices.expressions.fourier import DFT\n>>> DFT(3)\nDFT(3)\n>>> DFT(3).as_explicit()\nMatrix([\n[sqrt(3)/3,                sqrt(3)/3,                sqrt(3)/3],\n[sqrt(3)/3, sqrt(3)*exp(-2*I*pi/3)/3,  sqrt(3)*exp(2*I*pi/3)/3],\n[sqrt(3)/3,  sqrt(3)*exp(2*I*pi/3)/3, sqrt(3)*exp(-2*I*pi/3)/3]]) \n```", "```py\n>>> from sympy import laplace_transform, symbols, eye\n>>> t, z = symbols('t z')\n>>> laplace_transform(eye(2), t, z) \nMatrix([\n[(1/z, 0, True),   (0, 0, True)],\n[  (0, 0, True), (1/z, 0, True)]]) \n```", "```py\n>>> laplace_transform(eye(2), t, z, noconds=True)\nMatrix([\n[1/z,   0],\n[  0, 1/z]]) \n```", "```py\n>>> laplace_transform(eye(2), t, z, legacy_matrix=False)\n(Matrix([\n[1/z,   0],\n[  0, 1/z]]), 0, True) \n```", "```py\nclass AskPrimeHandler(AskHandler):\n    @staticmethod\n    def Integer(expr, assumptions):\n        return expr.is_prime\n\nregister_handler('prime', AskPrimeHandler) \n```", "```py\n# Predicate definition.\n# Not needed if you are registering the handler to existing predicate.\nclass PrimePredicate(Predicate):\n    name = 'prime'\nQ.prime = PrimePredicate()\n\n# Handler registration\n@Q.prime.register(Integer)\ndef _(expr, assumptions):\n    return expr.is_prime \n```", "```py\n>>> from sympy import symbols\n>>> from sympy.stats import WienerProcess\n>>> W = WienerProcess('W')\n>>> t = symbols('t', positive=True) \n```", "```py\nW.distribution(W(t)) # DEPRECATED \n```", "```py\n>>> W.distribution(t)\nNormalDistribution(0, sqrt(t)) \n```", "```py\n    CoordSystem(name, patch, ['x', 'y']) # DEPRECATED \n    ```", "```py\n    CoordSystem(name, patch, symbols('x y', real=True)) \n    ```", "```py\nlambdify({x, y}, x + 2*y) # WRONG \n```", "```py\nlambdify((x, y), x + 2*y) # RIGHT \n```", "```py\nMul(1, Tuple(2)) # This is deprecated \n```", "```py\nMul(2, Tuple(2)) # This is deprecated \n```", "```py\nAttributeError: 'Tuple' object has no attribute 'as_coeff_Mul' \n```", "```py\nPoly(x)*sin(x) # DEPRECATED \n```", "```py\n>>> from sympy import init_printing\n>>> init_printing(perm_cyclic=False) # Makes Permutation print in array form \n>>> from sympy.combinatorics import Permutation\n>>> Permutation(1, 2)(3, 4) \n⎛0 1 2 3 4⎞\n⎝0 2 1 4 3⎠ \n```", "```py\nfrom sympy import S\ns is S.EmptySet \n```", "```py\ns.is_empty \n```", "```py\n>>> from sympy import ProductSet\n>>> sets = [{i} for i in range(3)]\n>>> ProductSet(*sets)\nProductSet({0}, {1}, {2})\n>>> ProductSet({1, 2}, {1})\nProductSet({1, 2}, {1}) \n```", "```py\nP.potential_energy = scalar \n```", "```py\nConditionSet(symbol, set_condition) \n```", "```py\nConditionSet(symbol, And(*[Eq(lhs, 0) for lhs in set_condition])) \n```", "```py\nConditionSet((x, y), {x + 1, x + y}, S.Reals) # DEPRECATED \n```", "```py\nConditionSet((x, y), Eq(x + 1, 0) & Eq(x + y, 0), S.Reals) \n```", "```py\n>>> from sympy import Lambda, symbols\n>>> x, y, z = symbols('x y z')\n>>> f = Lambda((x, (y, z)), x + y + z)\n>>> f(1, (2, 3))\n6 \n```", "```py\ndiff(expr, x).replace(\n    lambda arg: arg.is_Derivative,\n    lambda arg: arg.as_finite_difference()) \n```"]