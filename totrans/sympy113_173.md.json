["```py\n>>> from sympy.physics.mechanics import *\n>>> from sympy import symbols, atan, Matrix, solve\n>>> # Create generalized coordinates and speeds for this non-minimal realization\n>>> # q1, q2 = N.x and N.y coordinates of pendulum\n>>> # u1, u2 = N.x and N.y velocities of pendulum\n>>> q1, q2 = dynamicsymbols('q1:3')\n>>> q1d, q2d = dynamicsymbols('q1:3', level=1)\n>>> u1, u2 = dynamicsymbols('u1:3')\n>>> u1d, u2d = dynamicsymbols('u1:3', level=1)\n>>> L, m, g, t = symbols('L, m, g, t') \n```", "```py\n>>> # Compose world frame\n>>> N = ReferenceFrame('N')\n>>> pN = Point('N*')\n>>> pN.set_vel(N, 0)\n\n>>> # A.x is along the pendulum\n>>> theta1 = atan(q2/q1)\n>>> A = N.orientnew('A', 'axis', [theta1, N.z]) \n```", "```py\n>>> # Locate the pendulum mass\n>>> P = pN.locatenew('P1', q1*N.x + q2*N.y)\n>>> pP = Particle('pP', P, m) \n```", "```py\n>>> # Calculate the kinematic differential equations\n>>> kde = Matrix([q1d - u1,\n...               q2d - u2])\n>>> dq_dict = solve(kde, [q1d, q2d]) \n```", "```py\n>>> # Set velocity of point P\n>>> P.set_vel(N, P.pos_from(pN).dt(N).subs(dq_dict)) \n```", "```py\n>>> f_c = Matrix([P.pos_from(pN).magnitude() - L])\n>>> f_v = Matrix([P.vel(N).express(A).dot(A.x)])\n>>> f_v.simplify() \n```", "```py\n>>> # Input the force resultant at P\n>>> R = m*g*N.x \n```", "```py\n>>> # Derive the equations of motion using the KanesMethod class.\n>>> KM = KanesMethod(N, q_ind=[q2], u_ind=[u2], q_dependent=[q1],\n...                  u_dependent=[u1], configuration_constraints=f_c,\n...                  velocity_constraints=f_v, kd_eqs=kde)\n>>> (fr, frstar) = KM.kanes_equations([pP],[(P, R)]) \n```", "```py\n>>> # Set the operating point to be straight down, and non-moving\n>>> q_op = {q1: L, q2: 0}\n>>> u_op = {u1: 0, u2: 0}\n>>> ud_op = {u1d: 0, u2d: 0}\n>>> # Perform the linearization\n>>> A, B, inp_vec = KM.linearize(op_point=[q_op, u_op, ud_op], A_and_B=True,\n...                              new_method=True, simplify=True)\n>>> A\nMatrix([\n[   0, 1],\n[-g/L, 0]])\n>>> B\nMatrix(0, 0, []) \n```", "```py\n>>> from sympy.physics.mechanics import *\n>>> from sympy import symbols, atan, Matrix\n>>> q1, q2 = dynamicsymbols('q1:3')\n>>> q1d, q2d = dynamicsymbols('q1:3', level=1)\n>>> L, m, g, t = symbols('L, m, g, t') \n```", "```py\n>>> # Compose World Frame\n>>> N = ReferenceFrame('N')\n>>> pN = Point('N*')\n>>> pN.set_vel(N, 0)\n>>> # A.x is along the pendulum\n>>> theta1 = atan(q2/q1)\n>>> A = N.orientnew('A', 'axis', [theta1, N.z]) \n```", "```py\n>>> # Create point P, the pendulum mass\n>>> P = pN.locatenew('P1', q1*N.x + q2*N.y)\n>>> P.set_vel(N, P.pos_from(pN).dt(N))\n>>> pP = Particle('pP', P, m) \n```", "```py\n>>> # Holonomic Constraint Equations\n>>> f_c = Matrix([q1**2 + q2**2 - L**2]) \n```", "```py\n>>> # Input the force resultant at P\n>>> R = m*g*N.x \n```", "```py\n>>> # Calculate the lagrangian, and form the equations of motion\n>>> Lag = Lagrangian(N, pP)\n>>> LM = LagrangesMethod(Lag, [q1, q2], hol_coneqs=f_c, forcelist=[(P, R)], frame=N)\n>>> lag_eqs = LM.form_lagranges_equations() \n```", "```py\n>>> # Compose operating point\n>>> op_point = {q1: L, q2: 0, q1d: 0, q2d: 0, q1d.diff(t): 0, q2d.diff(t): 0} \n```", "```py\n>>> # Solve for multiplier operating point\n>>> lam_op = LM.solve_multipliers(op_point=op_point) \n```", "```py\n>>> op_point.update(lam_op)\n>>> # Perform the Linearization\n>>> A, B, inp_vec = LM.linearize([q2], [q2d], [q1], [q1d],\n...                             op_point=op_point, A_and_B=True)\n>>> A\nMatrix([\n[     0, 1],\n[-g/L, 0]])\n>>> B\nMatrix(0, 0, []) \n```"]