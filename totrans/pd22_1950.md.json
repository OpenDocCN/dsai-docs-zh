["```py\nIn [1]: df = pd.DataFrame({'A': [1, 2, 3],\n ...:                   'B': np.array([1, 2, 3], dtype='object'),\n ...:                   'C': ['1', '2', '3']})\n ...: \n\nIn [2]: df.dtypes\nOut[2]: \nA     int64\nB    object\nC    object\nLength: 3, dtype: object\n\nIn [3]: df.infer_objects().dtypes\nOut[3]: \nA     int64\nB     int64\nC    object\nLength: 3, dtype: object \n```", "```py\nIn [4]: df = df.infer_objects()\n\nIn [5]: df['C'] = pd.to_numeric(df['C'], errors='coerce')\n\nIn [6]: df.dtypes\nOut[6]: \nA    int64\nB    int64\nC    int64\nLength: 3, dtype: object \n```", "```py\nIn [1]: df = pd.DataFrame({'one': [1., 2., 3.]})\nIn [2]: df.two = [4, 5, 6] \n```", "```py\nIn [3]: df\nOut[3]:\n one\n0  1.0\n1  2.0\n2  3.0 \n```", "```py\nIn [7]: df = pd.DataFrame(np.arange(8).reshape(2, 4),\n ...:                  columns=['A', 'B', 'C', 'D'])\n ...: \n\nIn [8]: df\nOut[8]: \n A  B  C  D\n0  0  1  2  3\n1  4  5  6  7\n\n[2 rows x 4 columns]\n\nIn [9]: df.drop(['B', 'C'], axis=1)\nOut[9]: \n A  D\n0  0  3\n1  4  7\n\n[2 rows x 2 columns]\n\n# the following is now equivalent\nIn [10]: df.drop(columns=['B', 'C'])\nOut[10]: \n A  D\n0  0  3\n1  4  7\n\n[2 rows x 2 columns] \n```", "```py\nIn [11]: df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n\nIn [12]: df.rename(str.lower, axis='columns')\nOut[12]: \n a  b\n0  1  4\n1  2  5\n2  3  6\n\n[3 rows x 2 columns]\n\nIn [13]: df.rename(id, axis='index')\nOut[13]: \n A  B\n140682504175824  1  4\n140682504175856  2  5\n140682504175888  3  6\n\n[3 rows x 2 columns] \n```", "```py\nIn [14]: df.reindex(['A', 'B', 'C'], axis='columns')\nOut[14]: \n A  B   C\n0  1  4 NaN\n1  2  5 NaN\n2  3  6 NaN\n\n[3 rows x 3 columns]\n\nIn [15]: df.reindex([0, 1, 3], axis='index')\nOut[15]: \n A    B\n0  1.0  4.0\n1  2.0  5.0\n3  NaN  NaN\n\n[3 rows x 2 columns] \n```", "```py\nIn [16]: df.rename(index=id, columns=str.lower)\nOut[16]: \n a  b\n140682504175824  1  4\n140682504175856  2  5\n140682504175888  3  6\n\n[3 rows x 2 columns]\n\nIn [17]: df.reindex(index=[0, 1, 3], columns=['A', 'B', 'C'])\nOut[17]: \n A    B   C\n0  1.0  4.0 NaN\n1  2.0  5.0 NaN\n3  NaN  NaN NaN\n\n[3 rows x 3 columns] \n```", "```py\nIn [18]: from pandas.api.types import CategoricalDtype\n\nIn [19]: s = pd.Series(['a', 'b', 'c', 'a'])  # strings\n\nIn [20]: dtype = CategoricalDtype(categories=['a', 'b', 'c', 'd'], ordered=True)\n\nIn [21]: s.astype(dtype)\nOut[21]: \n0    a\n1    b\n2    c\n3    a\nLength: 4, dtype: category\nCategories (4, object): ['a' < 'b' < 'c' < 'd'] \n```", "```py\nIn [22]: data = 'A,B\\na,1\\nb,2\\nc,3'\n\nIn [23]: pd.read_csv(StringIO(data), dtype={'B': 'category'}).B.cat.categories\nOut[23]: Index(['1', '2', '3'], dtype='object') \n```", "```py\nIn [24]: dtype = {'B': CategoricalDtype([1, 2, 3])}\n\nIn [25]: pd.read_csv(StringIO(data), dtype=dtype).B.cat.categories\nOut[25]: Index([1, 2, 3], dtype='int64') \n```", "```py\nIn [26]: import numpy as np\n\nIn [27]: n = 1000\n\nIn [28]: df = pd.DataFrame({'Store': np.random.choice(['Store_1', 'Store_2'], n),\n ....:                   'Product': np.random.choice(['Product_1',\n ....:                                                'Product_2',\n ....:                                                'Product_3'\n ....:                                                ], n),\n ....:                   'Revenue': (np.random.random(n) * 50 + 10).round(2),\n ....:                   'Quantity': np.random.randint(1, 10, size=n)})\n ....: \n\nIn [29]: df.head(2)\nOut[29]: \n Store    Product  Revenue  Quantity\n0  Store_2  Product_2    32.09         7\n1  Store_1  Product_3    14.20         1\n\n[2 rows x 4 columns] \n```", "```py\nIn [30]: (df.groupby(['Store', 'Product'])\n ....:   .pipe(lambda grp: grp.Revenue.sum() / grp.Quantity.sum())\n ....:   .unstack().round(2))\n ....: \nOut[30]: \nProduct  Product_1  Product_2  Product_3\nStore \nStore_1       6.73       6.72       7.14\nStore_2       7.59       6.98       7.23\n\n[2 rows x 3 columns] \n```", "```py\nIn [31]: c = pd.Categorical(['a', 'a', 'b'])\n\nIn [32]: c.rename_categories({\"a\": \"eh\", \"b\": \"bee\"})\nOut[32]: \n['eh', 'eh', 'bee']\nCategories (2, object): ['eh', 'bee'] \n```", "```py\nIn [33]: c.rename_categories(pd.Series([0, 1], index=['a', 'c']))\nFutureWarning: Treating Series 'new_categories' as a list-like and using the values.\nIn a future version, 'rename_categories' will treat Series like a dictionary.\nFor dict-like, use 'new_categories.to_dict()'\nFor list-like, use 'new_categories.values'.\nOut[33]:\n[0, 0, 1]\nCategories (2, int64): [0, 1] \n```", "```py\nIn [33]: s = pd.Series([np.nan]) \n```", "```py\nIn [2]: s.sum()\nOut[2]: np.nan \n```", "```py\nIn [2]: s.sum()\nOut[2]: 0.0 \n```", "```py\nIn [34]: s.sum()\nOut[34]: 0.0 \n```", "```py\nIn [1]: pd.Series([]).sum()\nOut[1]: 0 \n```", "```py\nIn [2]: pd.Series([]).sum()\nOut[2]: 0 \n```", "```py\nIn [35]: s = pd.Series([1, 2, 3])\n\nIn [36]: s\nOut[36]: \n0    1\n1    2\n2    3\nLength: 3, dtype: int64 \n```", "```py\nIn [4]: s.loc[[1, 2, 3]]\nOut[4]:\n1    2.0\n2    3.0\n3    NaN\ndtype: float64 \n```", "```py\nIn [4]: s.loc[[1, 2, 3]]\nPassing list-likes to .loc or [] with any missing label will raise\nKeyError in the future, you can use .reindex() as an alternative.\n\nSee the documentation here:\nhttps://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike\n\nOut[4]:\n1    2.0\n2    3.0\n3    NaN\ndtype: float64 \n```", "```py\nIn [37]: s.reindex([1, 2, 3])\nOut[37]: \n1    2.0\n2    3.0\n3    NaN\nLength: 3, dtype: float64 \n```", "```py\nIn [38]: s.loc[[1, 2]]\nOut[38]: \n1    2\n2    3\nLength: 2, dtype: int64 \n```", "```py\nIn [39]: s = pd.Series([1, 2, 3])\n\nIn [40]: s\nOut[40]: \n0    1\n1    2\n2    3\nLength: 3, dtype: int64 \n```", "```py\nIn [2]: type(list(s)[0])\nOut[2]: numpy.int64 \n```", "```py\nIn [41]: type(list(s)[0])\nOut[41]: int \n```", "```py\nIn [42]: d = {'a': [1], 'b': ['b']}\n\nIn [43]: df = pd.DataFrame(d) \n```", "```py\nIn [8]: type(df.to_dict()['a'][0])\nOut[8]: numpy.int64 \n```", "```py\nIn [44]: type(df.to_dict()['a'][0])\nOut[44]: int \n```", "```py\nIn [45]: s = pd.Series([1, 2, 3], index=[False, True, False])\n\nIn [46]: s\nOut[46]: \nFalse    1\nTrue     2\nFalse    3\nLength: 3, dtype: int64 \n```", "```py\nIn [59]: s.loc[pd.Index([True, False, True])]\nOut[59]:\nTrue     2\nFalse    1\nFalse    3\nTrue     2\ndtype: int64 \n```", "```py\nIn [47]: s.loc[pd.Index([True, False, True])]\nOut[47]: \nFalse    1\nFalse    3\nLength: 2, dtype: int64 \n```", "```py\nIn [48]: s = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\n\nIn [49]: s\nOut[49]: \na    1\nb    2\nc    3\nLength: 3, dtype: int64 \n```", "```py\nIn [39]: s.loc[pd.Index([True, False, True])]\nKeyError: \"None of [Index([True, False, True], dtype='object')] are in the [index]\" \n```", "```py\nIn [50]: s.loc[pd.Index([True, False, True])]\nOut[50]: \na    1\nc    3\nLength: 2, dtype: int64 \n```", "```py\nIn [1]: pi = pd.period_range('2017-01', periods=12, freq='M')\n\nIn [2]: s = pd.Series(np.arange(12), index=pi)\n\nIn [3]: resampled = s.resample('2Q').mean()\n\nIn [4]: resampled\nOut[4]:\n2017-03-31     1.0\n2017-09-30     5.5\n2018-03-31    10.0\nFreq: 2Q-DEC, dtype: float64\n\nIn [5]: resampled.index\nOut[5]: DatetimeIndex(['2017-03-31', '2017-09-30', '2018-03-31'], dtype='datetime64[ns]', freq='2Q-DEC') \n```", "```py\nIn [1]: pi = pd.period_range('2017-01', periods=12, freq='M')\n\nIn [2]: s = pd.Series(np.arange(12), index=pi)\n\nIn [3]: resampled = s.resample('2Q').mean()\n\nIn [4]: resampled\nOut[4]:\n2017Q1    2.5\n2017Q3    8.5\nFreq: 2Q-DEC, dtype: float64\n\nIn [5]: resampled.index\nOut[5]: PeriodIndex(['2017Q1', '2017Q3'], dtype='period[2Q-DEC]') \n```", "```py\nIn [1]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)\n\nIn [2]: s = pd.Series(np.arange(10), index=pi)\n\nIn [3]: s.resample('H').ohlc()\nOut[3]:\n2000-01-01 00:00    0.0\n ...\n2000-01-10 23:00    NaN\nFreq: H, Length: 240, dtype: float64\n\nIn [4]: s.resample('M').ohlc()\nOut[4]:\n open  high  low  close\n2000-01     0     9    0      9 \n```", "```py\nIn [56]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)\n\nIn [57]: s = pd.Series(np.arange(10), index=pi)\n\nIn [58]: s.resample('H').ohlc()\nOut[58]:\n open  high  low  close\n2000-01-01 00:00   0.0   0.0  0.0    0.0\n2000-01-01 01:00   NaN   NaN  NaN    NaN\n2000-01-01 02:00   NaN   NaN  NaN    NaN\n2000-01-01 03:00   NaN   NaN  NaN    NaN\n2000-01-01 04:00   NaN   NaN  NaN    NaN\n...                ...   ...  ...    ...\n2000-01-10 19:00   NaN   NaN  NaN    NaN\n2000-01-10 20:00   NaN   NaN  NaN    NaN\n2000-01-10 21:00   NaN   NaN  NaN    NaN\n2000-01-10 22:00   NaN   NaN  NaN    NaN\n2000-01-10 23:00   NaN   NaN  NaN    NaN\n\n[240 rows x 4 columns]\n\nIn [59]: s.resample('M').ohlc()\nOut[59]:\n open  high  low  close\n2000-01     0     9    0      9\n\n[1 rows x 4 columns] \n```", "```py\nIn [51]: arr = np.array([1, 2, 3]) \n```", "```py\nIn [3]: pd.eval(\"a = 1 + 2\", target=arr, inplace=True)\n...\nIndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`)\nand integer or boolean arrays are valid indices \n```", "```py\nIn [3]: pd.eval(\"a = 1 + 2\", target=arr, inplace=True)\n...\nValueError: Cannot assign expression output to target \n```", "```py\nIn [4]: pd.eval(\"1 + 2\", target=arr, inplace=True)\nOut[4]: 3 \n```", "```py\nIn [4]: pd.eval(\"1 + 2\", target=arr, inplace=True)\n...\nValueError: Cannot operate inplace if there is no assignment \n```", "```py\nIn [52]: s = pd.Series([1, 2, 3]) \n```", "```py\nIn [5]: s[1] = True\n\nIn [6]: s\nOut[6]:\n0    1\n1    1\n2    3\ndtype: int64 \n```", "```py\nIn [7]: s[1] = True\n\nIn [8]: s\nOut[8]:\n0       1\n1    True\n2       3\nLength: 3, dtype: object \n```", "```py\nIn [53]: s = pd.Series([pd.Timestamp('2011-01-01'), pd.Timestamp('2012-01-01')]) \n```", "```py\nIn [1]: s[1] = 1\n\nIn [2]: s\nOut[2]:\n0   2011-01-01 00:00:00.000000000\n1   1970-01-01 00:00:00.000000001\ndtype: datetime64[ns] \n```", "```py\nIn [1]: s[1] = 1\n\nIn [2]: s\nOut[2]:\n0    2011-01-01 00:00:00\n1                      1\ndtype: object \n```", "```py\nIn [2]: pd.MultiIndex.from_tuples([('a',), ('b',)])\nOut[2]: Index(['a', 'b'], dtype='object') \n```", "```py\nIn [54]: pd.MultiIndex.from_tuples([('a',), ('b',)])\nOut[54]: \nMultiIndex([('a',),\n ('b',)],\n ) \n```", "```py\nIn [55]: s = pd.Series(['20130101 00:00:00'] * 3) \n```", "```py\nIn [12]: pd.to_datetime(s, utc=True)\nOut[12]:\n0   2013-01-01\n1   2013-01-01\n2   2013-01-01\ndtype: datetime64[ns] \n```", "```py\nIn [56]: pd.to_datetime(s, utc=True)\nOut[56]: \n0   2013-01-01 00:00:00+00:00\n1   2013-01-01 00:00:00+00:00\n2   2013-01-01 00:00:00+00:00\nLength: 3, dtype: datetime64[ns, UTC] \n```", "```py\n In [2]: pd.interval_range(start=0, end=4, periods=6)\n Out[2]:\n IntervalIndex([(0, 1], (1, 2], (2, 3]]\n closed='right',\n dtype='interval[int64]')\n\nIn [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')\nOut[3]: PeriodIndex(['2017Q1', '2017Q2', '2017Q3', '2017Q4', '2018Q1', '2018Q2'], dtype='period[Q-DEC]', freq='Q-DEC') \n```", "```py\nIn [2]: pd.interval_range(start=0, end=4, periods=6)\n---------------------------------------------------------------------------\nValueError: Of the three parameters: start, end, and periods, exactly two must be specified\n\nIn [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')\n---------------------------------------------------------------------------\nValueError: Of the three parameters: start, end, and periods, exactly two must be specified \n```", "```py\nIn [4]: pd.interval_range(start=0, end=4)\nOut[4]:\nIntervalIndex([(0, 1], (1, 2], (2, 3]]\n closed='right',\n dtype='interval[int64]') \n```", "```py\nIn [57]: pd.interval_range(start=0, end=4)\nOut[57]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4]], dtype='interval[int64, right]') \n```", "```py\nIn [58]: df = pd.DataFrame({'A': [1, 2, 3]}, index=['foo', 'bar', 'baz']) \n```", "```py\nIn [3]: df.select(lambda x: x in ['bar', 'baz'])\nFutureWarning: select is deprecated and will be removed in a future release. You can use .loc[crit] as a replacement\nOut[3]:\n A\nbar  2\nbaz  3 \n```", "```py\nIn [59]: df.loc[df.index.map(lambda x: x in ['bar', 'baz'])]\nOut[59]: \n A\nbar  2\nbaz  3\n\n[2 rows x 1 columns] \n```", "```py\nIn [1]: df = pd.DataFrame({'A': [1, 2, 3],\n ...:                   'B': np.array([1, 2, 3], dtype='object'),\n ...:                   'C': ['1', '2', '3']})\n ...: \n\nIn [2]: df.dtypes\nOut[2]: \nA     int64\nB    object\nC    object\nLength: 3, dtype: object\n\nIn [3]: df.infer_objects().dtypes\nOut[3]: \nA     int64\nB     int64\nC    object\nLength: 3, dtype: object \n```", "```py\nIn [4]: df = df.infer_objects()\n\nIn [5]: df['C'] = pd.to_numeric(df['C'], errors='coerce')\n\nIn [6]: df.dtypes\nOut[6]: \nA    int64\nB    int64\nC    int64\nLength: 3, dtype: object \n```", "```py\nIn [1]: df = pd.DataFrame({'one': [1., 2., 3.]})\nIn [2]: df.two = [4, 5, 6] \n```", "```py\nIn [3]: df\nOut[3]:\n one\n0  1.0\n1  2.0\n2  3.0 \n```", "```py\nIn [7]: df = pd.DataFrame(np.arange(8).reshape(2, 4),\n ...:                  columns=['A', 'B', 'C', 'D'])\n ...: \n\nIn [8]: df\nOut[8]: \n A  B  C  D\n0  0  1  2  3\n1  4  5  6  7\n\n[2 rows x 4 columns]\n\nIn [9]: df.drop(['B', 'C'], axis=1)\nOut[9]: \n A  D\n0  0  3\n1  4  7\n\n[2 rows x 2 columns]\n\n# the following is now equivalent\nIn [10]: df.drop(columns=['B', 'C'])\nOut[10]: \n A  D\n0  0  3\n1  4  7\n\n[2 rows x 2 columns] \n```", "```py\nIn [11]: df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n\nIn [12]: df.rename(str.lower, axis='columns')\nOut[12]: \n a  b\n0  1  4\n1  2  5\n2  3  6\n\n[3 rows x 2 columns]\n\nIn [13]: df.rename(id, axis='index')\nOut[13]: \n A  B\n140682504175824  1  4\n140682504175856  2  5\n140682504175888  3  6\n\n[3 rows x 2 columns] \n```", "```py\nIn [14]: df.reindex(['A', 'B', 'C'], axis='columns')\nOut[14]: \n A  B   C\n0  1  4 NaN\n1  2  5 NaN\n2  3  6 NaN\n\n[3 rows x 3 columns]\n\nIn [15]: df.reindex([0, 1, 3], axis='index')\nOut[15]: \n A    B\n0  1.0  4.0\n1  2.0  5.0\n3  NaN  NaN\n\n[3 rows x 2 columns] \n```", "```py\nIn [16]: df.rename(index=id, columns=str.lower)\nOut[16]: \n a  b\n140682504175824  1  4\n140682504175856  2  5\n140682504175888  3  6\n\n[3 rows x 2 columns]\n\nIn [17]: df.reindex(index=[0, 1, 3], columns=['A', 'B', 'C'])\nOut[17]: \n A    B   C\n0  1.0  4.0 NaN\n1  2.0  5.0 NaN\n3  NaN  NaN NaN\n\n[3 rows x 3 columns] \n```", "```py\nIn [18]: from pandas.api.types import CategoricalDtype\n\nIn [19]: s = pd.Series(['a', 'b', 'c', 'a'])  # strings\n\nIn [20]: dtype = CategoricalDtype(categories=['a', 'b', 'c', 'd'], ordered=True)\n\nIn [21]: s.astype(dtype)\nOut[21]: \n0    a\n1    b\n2    c\n3    a\nLength: 4, dtype: category\nCategories (4, object): ['a' < 'b' < 'c' < 'd'] \n```", "```py\nIn [22]: data = 'A,B\\na,1\\nb,2\\nc,3'\n\nIn [23]: pd.read_csv(StringIO(data), dtype={'B': 'category'}).B.cat.categories\nOut[23]: Index(['1', '2', '3'], dtype='object') \n```", "```py\nIn [24]: dtype = {'B': CategoricalDtype([1, 2, 3])}\n\nIn [25]: pd.read_csv(StringIO(data), dtype=dtype).B.cat.categories\nOut[25]: Index([1, 2, 3], dtype='int64') \n```", "```py\nIn [26]: import numpy as np\n\nIn [27]: n = 1000\n\nIn [28]: df = pd.DataFrame({'Store': np.random.choice(['Store_1', 'Store_2'], n),\n ....:                   'Product': np.random.choice(['Product_1',\n ....:                                                'Product_2',\n ....:                                                'Product_3'\n ....:                                                ], n),\n ....:                   'Revenue': (np.random.random(n) * 50 + 10).round(2),\n ....:                   'Quantity': np.random.randint(1, 10, size=n)})\n ....: \n\nIn [29]: df.head(2)\nOut[29]: \n Store    Product  Revenue  Quantity\n0  Store_2  Product_2    32.09         7\n1  Store_1  Product_3    14.20         1\n\n[2 rows x 4 columns] \n```", "```py\nIn [30]: (df.groupby(['Store', 'Product'])\n ....:   .pipe(lambda grp: grp.Revenue.sum() / grp.Quantity.sum())\n ....:   .unstack().round(2))\n ....: \nOut[30]: \nProduct  Product_1  Product_2  Product_3\nStore \nStore_1       6.73       6.72       7.14\nStore_2       7.59       6.98       7.23\n\n[2 rows x 3 columns] \n```", "```py\nIn [31]: c = pd.Categorical(['a', 'a', 'b'])\n\nIn [32]: c.rename_categories({\"a\": \"eh\", \"b\": \"bee\"})\nOut[32]: \n['eh', 'eh', 'bee']\nCategories (2, object): ['eh', 'bee'] \n```", "```py\nIn [33]: c.rename_categories(pd.Series([0, 1], index=['a', 'c']))\nFutureWarning: Treating Series 'new_categories' as a list-like and using the values.\nIn a future version, 'rename_categories' will treat Series like a dictionary.\nFor dict-like, use 'new_categories.to_dict()'\nFor list-like, use 'new_categories.values'.\nOut[33]:\n[0, 0, 1]\nCategories (2, int64): [0, 1] \n```", "```py\nIn [1]: df = pd.DataFrame({'A': [1, 2, 3],\n ...:                   'B': np.array([1, 2, 3], dtype='object'),\n ...:                   'C': ['1', '2', '3']})\n ...: \n\nIn [2]: df.dtypes\nOut[2]: \nA     int64\nB    object\nC    object\nLength: 3, dtype: object\n\nIn [3]: df.infer_objects().dtypes\nOut[3]: \nA     int64\nB     int64\nC    object\nLength: 3, dtype: object \n```", "```py\nIn [4]: df = df.infer_objects()\n\nIn [5]: df['C'] = pd.to_numeric(df['C'], errors='coerce')\n\nIn [6]: df.dtypes\nOut[6]: \nA    int64\nB    int64\nC    int64\nLength: 3, dtype: object \n```", "```py\nIn [1]: df = pd.DataFrame({'one': [1., 2., 3.]})\nIn [2]: df.two = [4, 5, 6] \n```", "```py\nIn [3]: df\nOut[3]:\n one\n0  1.0\n1  2.0\n2  3.0 \n```", "```py\nIn [7]: df = pd.DataFrame(np.arange(8).reshape(2, 4),\n ...:                  columns=['A', 'B', 'C', 'D'])\n ...: \n\nIn [8]: df\nOut[8]: \n A  B  C  D\n0  0  1  2  3\n1  4  5  6  7\n\n[2 rows x 4 columns]\n\nIn [9]: df.drop(['B', 'C'], axis=1)\nOut[9]: \n A  D\n0  0  3\n1  4  7\n\n[2 rows x 2 columns]\n\n# the following is now equivalent\nIn [10]: df.drop(columns=['B', 'C'])\nOut[10]: \n A  D\n0  0  3\n1  4  7\n\n[2 rows x 2 columns] \n```", "```py\nIn [11]: df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n\nIn [12]: df.rename(str.lower, axis='columns')\nOut[12]: \n a  b\n0  1  4\n1  2  5\n2  3  6\n\n[3 rows x 2 columns]\n\nIn [13]: df.rename(id, axis='index')\nOut[13]: \n A  B\n140682504175824  1  4\n140682504175856  2  5\n140682504175888  3  6\n\n[3 rows x 2 columns] \n```", "```py\nIn [14]: df.reindex(['A', 'B', 'C'], axis='columns')\nOut[14]: \n A  B   C\n0  1  4 NaN\n1  2  5 NaN\n2  3  6 NaN\n\n[3 rows x 3 columns]\n\nIn [15]: df.reindex([0, 1, 3], axis='index')\nOut[15]: \n A    B\n0  1.0  4.0\n1  2.0  5.0\n3  NaN  NaN\n\n[3 rows x 2 columns] \n```", "```py\nIn [16]: df.rename(index=id, columns=str.lower)\nOut[16]: \n a  b\n140682504175824  1  4\n140682504175856  2  5\n140682504175888  3  6\n\n[3 rows x 2 columns]\n\nIn [17]: df.reindex(index=[0, 1, 3], columns=['A', 'B', 'C'])\nOut[17]: \n A    B   C\n0  1.0  4.0 NaN\n1  2.0  5.0 NaN\n3  NaN  NaN NaN\n\n[3 rows x 3 columns] \n```", "```py\nIn [18]: from pandas.api.types import CategoricalDtype\n\nIn [19]: s = pd.Series(['a', 'b', 'c', 'a'])  # strings\n\nIn [20]: dtype = CategoricalDtype(categories=['a', 'b', 'c', 'd'], ordered=True)\n\nIn [21]: s.astype(dtype)\nOut[21]: \n0    a\n1    b\n2    c\n3    a\nLength: 4, dtype: category\nCategories (4, object): ['a' < 'b' < 'c' < 'd'] \n```", "```py\nIn [22]: data = 'A,B\\na,1\\nb,2\\nc,3'\n\nIn [23]: pd.read_csv(StringIO(data), dtype={'B': 'category'}).B.cat.categories\nOut[23]: Index(['1', '2', '3'], dtype='object') \n```", "```py\nIn [24]: dtype = {'B': CategoricalDtype([1, 2, 3])}\n\nIn [25]: pd.read_csv(StringIO(data), dtype=dtype).B.cat.categories\nOut[25]: Index([1, 2, 3], dtype='int64') \n```", "```py\nIn [26]: import numpy as np\n\nIn [27]: n = 1000\n\nIn [28]: df = pd.DataFrame({'Store': np.random.choice(['Store_1', 'Store_2'], n),\n ....:                   'Product': np.random.choice(['Product_1',\n ....:                                                'Product_2',\n ....:                                                'Product_3'\n ....:                                                ], n),\n ....:                   'Revenue': (np.random.random(n) * 50 + 10).round(2),\n ....:                   'Quantity': np.random.randint(1, 10, size=n)})\n ....: \n\nIn [29]: df.head(2)\nOut[29]: \n Store    Product  Revenue  Quantity\n0  Store_2  Product_2    32.09         7\n1  Store_1  Product_3    14.20         1\n\n[2 rows x 4 columns] \n```", "```py\nIn [30]: (df.groupby(['Store', 'Product'])\n ....:   .pipe(lambda grp: grp.Revenue.sum() / grp.Quantity.sum())\n ....:   .unstack().round(2))\n ....: \nOut[30]: \nProduct  Product_1  Product_2  Product_3\nStore \nStore_1       6.73       6.72       7.14\nStore_2       7.59       6.98       7.23\n\n[2 rows x 3 columns] \n```", "```py\nIn [31]: c = pd.Categorical(['a', 'a', 'b'])\n\nIn [32]: c.rename_categories({\"a\": \"eh\", \"b\": \"bee\"})\nOut[32]: \n['eh', 'eh', 'bee']\nCategories (2, object): ['eh', 'bee'] \n```", "```py\nIn [33]: c.rename_categories(pd.Series([0, 1], index=['a', 'c']))\nFutureWarning: Treating Series 'new_categories' as a list-like and using the values.\nIn a future version, 'rename_categories' will treat Series like a dictionary.\nFor dict-like, use 'new_categories.to_dict()'\nFor list-like, use 'new_categories.values'.\nOut[33]:\n[0, 0, 1]\nCategories (2, int64): [0, 1] \n```", "```py\nIn [33]: s = pd.Series([np.nan]) \n```", "```py\nIn [2]: s.sum()\nOut[2]: np.nan \n```", "```py\nIn [2]: s.sum()\nOut[2]: 0.0 \n```", "```py\nIn [34]: s.sum()\nOut[34]: 0.0 \n```", "```py\nIn [1]: pd.Series([]).sum()\nOut[1]: 0 \n```", "```py\nIn [2]: pd.Series([]).sum()\nOut[2]: 0 \n```", "```py\nIn [35]: s = pd.Series([1, 2, 3])\n\nIn [36]: s\nOut[36]: \n0    1\n1    2\n2    3\nLength: 3, dtype: int64 \n```", "```py\nIn [4]: s.loc[[1, 2, 3]]\nOut[4]:\n1    2.0\n2    3.0\n3    NaN\ndtype: float64 \n```", "```py\nIn [4]: s.loc[[1, 2, 3]]\nPassing list-likes to .loc or [] with any missing label will raise\nKeyError in the future, you can use .reindex() as an alternative.\n\nSee the documentation here:\nhttps://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike\n\nOut[4]:\n1    2.0\n2    3.0\n3    NaN\ndtype: float64 \n```", "```py\nIn [37]: s.reindex([1, 2, 3])\nOut[37]: \n1    2.0\n2    3.0\n3    NaN\nLength: 3, dtype: float64 \n```", "```py\nIn [38]: s.loc[[1, 2]]\nOut[38]: \n1    2\n2    3\nLength: 2, dtype: int64 \n```", "```py\nIn [39]: s = pd.Series([1, 2, 3])\n\nIn [40]: s\nOut[40]: \n0    1\n1    2\n2    3\nLength: 3, dtype: int64 \n```", "```py\nIn [2]: type(list(s)[0])\nOut[2]: numpy.int64 \n```", "```py\nIn [41]: type(list(s)[0])\nOut[41]: int \n```", "```py\nIn [42]: d = {'a': [1], 'b': ['b']}\n\nIn [43]: df = pd.DataFrame(d) \n```", "```py\nIn [8]: type(df.to_dict()['a'][0])\nOut[8]: numpy.int64 \n```", "```py\nIn [44]: type(df.to_dict()['a'][0])\nOut[44]: int \n```", "```py\nIn [45]: s = pd.Series([1, 2, 3], index=[False, True, False])\n\nIn [46]: s\nOut[46]: \nFalse    1\nTrue     2\nFalse    3\nLength: 3, dtype: int64 \n```", "```py\nIn [59]: s.loc[pd.Index([True, False, True])]\nOut[59]:\nTrue     2\nFalse    1\nFalse    3\nTrue     2\ndtype: int64 \n```", "```py\nIn [47]: s.loc[pd.Index([True, False, True])]\nOut[47]: \nFalse    1\nFalse    3\nLength: 2, dtype: int64 \n```", "```py\nIn [48]: s = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\n\nIn [49]: s\nOut[49]: \na    1\nb    2\nc    3\nLength: 3, dtype: int64 \n```", "```py\nIn [39]: s.loc[pd.Index([True, False, True])]\nKeyError: \"None of [Index([True, False, True], dtype='object')] are in the [index]\" \n```", "```py\nIn [50]: s.loc[pd.Index([True, False, True])]\nOut[50]: \na    1\nc    3\nLength: 2, dtype: int64 \n```", "```py\nIn [1]: pi = pd.period_range('2017-01', periods=12, freq='M')\n\nIn [2]: s = pd.Series(np.arange(12), index=pi)\n\nIn [3]: resampled = s.resample('2Q').mean()\n\nIn [4]: resampled\nOut[4]:\n2017-03-31     1.0\n2017-09-30     5.5\n2018-03-31    10.0\nFreq: 2Q-DEC, dtype: float64\n\nIn [5]: resampled.index\nOut[5]: DatetimeIndex(['2017-03-31', '2017-09-30', '2018-03-31'], dtype='datetime64[ns]', freq='2Q-DEC') \n```", "```py\nIn [1]: pi = pd.period_range('2017-01', periods=12, freq='M')\n\nIn [2]: s = pd.Series(np.arange(12), index=pi)\n\nIn [3]: resampled = s.resample('2Q').mean()\n\nIn [4]: resampled\nOut[4]:\n2017Q1    2.5\n2017Q3    8.5\nFreq: 2Q-DEC, dtype: float64\n\nIn [5]: resampled.index\nOut[5]: PeriodIndex(['2017Q1', '2017Q3'], dtype='period[2Q-DEC]') \n```", "```py\nIn [1]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)\n\nIn [2]: s = pd.Series(np.arange(10), index=pi)\n\nIn [3]: s.resample('H').ohlc()\nOut[3]:\n2000-01-01 00:00    0.0\n ...\n2000-01-10 23:00    NaN\nFreq: H, Length: 240, dtype: float64\n\nIn [4]: s.resample('M').ohlc()\nOut[4]:\n open  high  low  close\n2000-01     0     9    0      9 \n```", "```py\nIn [56]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)\n\nIn [57]: s = pd.Series(np.arange(10), index=pi)\n\nIn [58]: s.resample('H').ohlc()\nOut[58]:\n open  high  low  close\n2000-01-01 00:00   0.0   0.0  0.0    0.0\n2000-01-01 01:00   NaN   NaN  NaN    NaN\n2000-01-01 02:00   NaN   NaN  NaN    NaN\n2000-01-01 03:00   NaN   NaN  NaN    NaN\n2000-01-01 04:00   NaN   NaN  NaN    NaN\n...                ...   ...  ...    ...\n2000-01-10 19:00   NaN   NaN  NaN    NaN\n2000-01-10 20:00   NaN   NaN  NaN    NaN\n2000-01-10 21:00   NaN   NaN  NaN    NaN\n2000-01-10 22:00   NaN   NaN  NaN    NaN\n2000-01-10 23:00   NaN   NaN  NaN    NaN\n\n[240 rows x 4 columns]\n\nIn [59]: s.resample('M').ohlc()\nOut[59]:\n open  high  low  close\n2000-01     0     9    0      9\n\n[1 rows x 4 columns] \n```", "```py\nIn [51]: arr = np.array([1, 2, 3]) \n```", "```py\nIn [3]: pd.eval(\"a = 1 + 2\", target=arr, inplace=True)\n...\nIndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`)\nand integer or boolean arrays are valid indices \n```", "```py\nIn [3]: pd.eval(\"a = 1 + 2\", target=arr, inplace=True)\n...\nValueError: Cannot assign expression output to target \n```", "```py\nIn [4]: pd.eval(\"1 + 2\", target=arr, inplace=True)\nOut[4]: 3 \n```", "```py\nIn [4]: pd.eval(\"1 + 2\", target=arr, inplace=True)\n...\nValueError: Cannot operate inplace if there is no assignment \n```", "```py\nIn [52]: s = pd.Series([1, 2, 3]) \n```", "```py\nIn [5]: s[1] = True\n\nIn [6]: s\nOut[6]:\n0    1\n1    1\n2    3\ndtype: int64 \n```", "```py\nIn [7]: s[1] = True\n\nIn [8]: s\nOut[8]:\n0       1\n1    True\n2       3\nLength: 3, dtype: object \n```", "```py\nIn [53]: s = pd.Series([pd.Timestamp('2011-01-01'), pd.Timestamp('2012-01-01')]) \n```", "```py\nIn [1]: s[1] = 1\n\nIn [2]: s\nOut[2]:\n0   2011-01-01 00:00:00.000000000\n1   1970-01-01 00:00:00.000000001\ndtype: datetime64[ns] \n```", "```py\nIn [1]: s[1] = 1\n\nIn [2]: s\nOut[2]:\n0    2011-01-01 00:00:00\n1                      1\ndtype: object \n```", "```py\nIn [2]: pd.MultiIndex.from_tuples([('a',), ('b',)])\nOut[2]: Index(['a', 'b'], dtype='object') \n```", "```py\nIn [54]: pd.MultiIndex.from_tuples([('a',), ('b',)])\nOut[54]: \nMultiIndex([('a',),\n ('b',)],\n ) \n```", "```py\nIn [55]: s = pd.Series(['20130101 00:00:00'] * 3) \n```", "```py\nIn [12]: pd.to_datetime(s, utc=True)\nOut[12]:\n0   2013-01-01\n1   2013-01-01\n2   2013-01-01\ndtype: datetime64[ns] \n```", "```py\nIn [56]: pd.to_datetime(s, utc=True)\nOut[56]: \n0   2013-01-01 00:00:00+00:00\n1   2013-01-01 00:00:00+00:00\n2   2013-01-01 00:00:00+00:00\nLength: 3, dtype: datetime64[ns, UTC] \n```", "```py\n In [2]: pd.interval_range(start=0, end=4, periods=6)\n Out[2]:\n IntervalIndex([(0, 1], (1, 2], (2, 3]]\n closed='right',\n dtype='interval[int64]')\n\nIn [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')\nOut[3]: PeriodIndex(['2017Q1', '2017Q2', '2017Q3', '2017Q4', '2018Q1', '2018Q2'], dtype='period[Q-DEC]', freq='Q-DEC') \n```", "```py\nIn [2]: pd.interval_range(start=0, end=4, periods=6)\n---------------------------------------------------------------------------\nValueError: Of the three parameters: start, end, and periods, exactly two must be specified\n\nIn [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')\n---------------------------------------------------------------------------\nValueError: Of the three parameters: start, end, and periods, exactly two must be specified \n```", "```py\nIn [4]: pd.interval_range(start=0, end=4)\nOut[4]:\nIntervalIndex([(0, 1], (1, 2], (2, 3]]\n closed='right',\n dtype='interval[int64]') \n```", "```py\nIn [57]: pd.interval_range(start=0, end=4)\nOut[57]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4]], dtype='interval[int64, right]') \n```", "```py\nIn [33]: s = pd.Series([np.nan]) \n```", "```py\nIn [2]: s.sum()\nOut[2]: np.nan \n```", "```py\nIn [2]: s.sum()\nOut[2]: 0.0 \n```", "```py\nIn [34]: s.sum()\nOut[34]: 0.0 \n```", "```py\nIn [1]: pd.Series([]).sum()\nOut[1]: 0 \n```", "```py\nIn [2]: pd.Series([]).sum()\nOut[2]: 0 \n```", "```py\nIn [35]: s = pd.Series([1, 2, 3])\n\nIn [36]: s\nOut[36]: \n0    1\n1    2\n2    3\nLength: 3, dtype: int64 \n```", "```py\nIn [4]: s.loc[[1, 2, 3]]\nOut[4]:\n1    2.0\n2    3.0\n3    NaN\ndtype: float64 \n```", "```py\nIn [4]: s.loc[[1, 2, 3]]\nPassing list-likes to .loc or [] with any missing label will raise\nKeyError in the future, you can use .reindex() as an alternative.\n\nSee the documentation here:\nhttps://pandas.pydata.org/pandas-docs/stable/indexing.html#deprecate-loc-reindex-listlike\n\nOut[4]:\n1    2.0\n2    3.0\n3    NaN\ndtype: float64 \n```", "```py\nIn [37]: s.reindex([1, 2, 3])\nOut[37]: \n1    2.0\n2    3.0\n3    NaN\nLength: 3, dtype: float64 \n```", "```py\nIn [38]: s.loc[[1, 2]]\nOut[38]: \n1    2\n2    3\nLength: 2, dtype: int64 \n```", "```py\nIn [39]: s = pd.Series([1, 2, 3])\n\nIn [40]: s\nOut[40]: \n0    1\n1    2\n2    3\nLength: 3, dtype: int64 \n```", "```py\nIn [2]: type(list(s)[0])\nOut[2]: numpy.int64 \n```", "```py\nIn [41]: type(list(s)[0])\nOut[41]: int \n```", "```py\nIn [42]: d = {'a': [1], 'b': ['b']}\n\nIn [43]: df = pd.DataFrame(d) \n```", "```py\nIn [8]: type(df.to_dict()['a'][0])\nOut[8]: numpy.int64 \n```", "```py\nIn [44]: type(df.to_dict()['a'][0])\nOut[44]: int \n```", "```py\nIn [45]: s = pd.Series([1, 2, 3], index=[False, True, False])\n\nIn [46]: s\nOut[46]: \nFalse    1\nTrue     2\nFalse    3\nLength: 3, dtype: int64 \n```", "```py\nIn [59]: s.loc[pd.Index([True, False, True])]\nOut[59]:\nTrue     2\nFalse    1\nFalse    3\nTrue     2\ndtype: int64 \n```", "```py\nIn [47]: s.loc[pd.Index([True, False, True])]\nOut[47]: \nFalse    1\nFalse    3\nLength: 2, dtype: int64 \n```", "```py\nIn [48]: s = pd.Series([1, 2, 3], index=['a', 'b', 'c'])\n\nIn [49]: s\nOut[49]: \na    1\nb    2\nc    3\nLength: 3, dtype: int64 \n```", "```py\nIn [39]: s.loc[pd.Index([True, False, True])]\nKeyError: \"None of [Index([True, False, True], dtype='object')] are in the [index]\" \n```", "```py\nIn [50]: s.loc[pd.Index([True, False, True])]\nOut[50]: \na    1\nc    3\nLength: 2, dtype: int64 \n```", "```py\nIn [1]: pi = pd.period_range('2017-01', periods=12, freq='M')\n\nIn [2]: s = pd.Series(np.arange(12), index=pi)\n\nIn [3]: resampled = s.resample('2Q').mean()\n\nIn [4]: resampled\nOut[4]:\n2017-03-31     1.0\n2017-09-30     5.5\n2018-03-31    10.0\nFreq: 2Q-DEC, dtype: float64\n\nIn [5]: resampled.index\nOut[5]: DatetimeIndex(['2017-03-31', '2017-09-30', '2018-03-31'], dtype='datetime64[ns]', freq='2Q-DEC') \n```", "```py\nIn [1]: pi = pd.period_range('2017-01', periods=12, freq='M')\n\nIn [2]: s = pd.Series(np.arange(12), index=pi)\n\nIn [3]: resampled = s.resample('2Q').mean()\n\nIn [4]: resampled\nOut[4]:\n2017Q1    2.5\n2017Q3    8.5\nFreq: 2Q-DEC, dtype: float64\n\nIn [5]: resampled.index\nOut[5]: PeriodIndex(['2017Q1', '2017Q3'], dtype='period[2Q-DEC]') \n```", "```py\nIn [1]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)\n\nIn [2]: s = pd.Series(np.arange(10), index=pi)\n\nIn [3]: s.resample('H').ohlc()\nOut[3]:\n2000-01-01 00:00    0.0\n ...\n2000-01-10 23:00    NaN\nFreq: H, Length: 240, dtype: float64\n\nIn [4]: s.resample('M').ohlc()\nOut[4]:\n open  high  low  close\n2000-01     0     9    0      9 \n```", "```py\nIn [56]: pi = pd.period_range(start='2000-01-01', freq='D', periods=10)\n\nIn [57]: s = pd.Series(np.arange(10), index=pi)\n\nIn [58]: s.resample('H').ohlc()\nOut[58]:\n open  high  low  close\n2000-01-01 00:00   0.0   0.0  0.0    0.0\n2000-01-01 01:00   NaN   NaN  NaN    NaN\n2000-01-01 02:00   NaN   NaN  NaN    NaN\n2000-01-01 03:00   NaN   NaN  NaN    NaN\n2000-01-01 04:00   NaN   NaN  NaN    NaN\n...                ...   ...  ...    ...\n2000-01-10 19:00   NaN   NaN  NaN    NaN\n2000-01-10 20:00   NaN   NaN  NaN    NaN\n2000-01-10 21:00   NaN   NaN  NaN    NaN\n2000-01-10 22:00   NaN   NaN  NaN    NaN\n2000-01-10 23:00   NaN   NaN  NaN    NaN\n\n[240 rows x 4 columns]\n\nIn [59]: s.resample('M').ohlc()\nOut[59]:\n open  high  low  close\n2000-01     0     9    0      9\n\n[1 rows x 4 columns] \n```", "```py\nIn [51]: arr = np.array([1, 2, 3]) \n```", "```py\nIn [3]: pd.eval(\"a = 1 + 2\", target=arr, inplace=True)\n...\nIndexError: only integers, slices (`:`), ellipsis (`...`), numpy.newaxis (`None`)\nand integer or boolean arrays are valid indices \n```", "```py\nIn [3]: pd.eval(\"a = 1 + 2\", target=arr, inplace=True)\n...\nValueError: Cannot assign expression output to target \n```", "```py\nIn [4]: pd.eval(\"1 + 2\", target=arr, inplace=True)\nOut[4]: 3 \n```", "```py\nIn [4]: pd.eval(\"1 + 2\", target=arr, inplace=True)\n...\nValueError: Cannot operate inplace if there is no assignment \n```", "```py\nIn [52]: s = pd.Series([1, 2, 3]) \n```", "```py\nIn [5]: s[1] = True\n\nIn [6]: s\nOut[6]:\n0    1\n1    1\n2    3\ndtype: int64 \n```", "```py\nIn [7]: s[1] = True\n\nIn [8]: s\nOut[8]:\n0       1\n1    True\n2       3\nLength: 3, dtype: object \n```", "```py\nIn [53]: s = pd.Series([pd.Timestamp('2011-01-01'), pd.Timestamp('2012-01-01')]) \n```", "```py\nIn [1]: s[1] = 1\n\nIn [2]: s\nOut[2]:\n0   2011-01-01 00:00:00.000000000\n1   1970-01-01 00:00:00.000000001\ndtype: datetime64[ns] \n```", "```py\nIn [1]: s[1] = 1\n\nIn [2]: s\nOut[2]:\n0    2011-01-01 00:00:00\n1                      1\ndtype: object \n```", "```py\nIn [2]: pd.MultiIndex.from_tuples([('a',), ('b',)])\nOut[2]: Index(['a', 'b'], dtype='object') \n```", "```py\nIn [54]: pd.MultiIndex.from_tuples([('a',), ('b',)])\nOut[54]: \nMultiIndex([('a',),\n ('b',)],\n ) \n```", "```py\nIn [55]: s = pd.Series(['20130101 00:00:00'] * 3) \n```", "```py\nIn [12]: pd.to_datetime(s, utc=True)\nOut[12]:\n0   2013-01-01\n1   2013-01-01\n2   2013-01-01\ndtype: datetime64[ns] \n```", "```py\nIn [56]: pd.to_datetime(s, utc=True)\nOut[56]: \n0   2013-01-01 00:00:00+00:00\n1   2013-01-01 00:00:00+00:00\n2   2013-01-01 00:00:00+00:00\nLength: 3, dtype: datetime64[ns, UTC] \n```", "```py\n In [2]: pd.interval_range(start=0, end=4, periods=6)\n Out[2]:\n IntervalIndex([(0, 1], (1, 2], (2, 3]]\n closed='right',\n dtype='interval[int64]')\n\nIn [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')\nOut[3]: PeriodIndex(['2017Q1', '2017Q2', '2017Q3', '2017Q4', '2018Q1', '2018Q2'], dtype='period[Q-DEC]', freq='Q-DEC') \n```", "```py\nIn [2]: pd.interval_range(start=0, end=4, periods=6)\n---------------------------------------------------------------------------\nValueError: Of the three parameters: start, end, and periods, exactly two must be specified\n\nIn [3]: pd.period_range(start='2017Q1', end='2017Q4', periods=6, freq='Q')\n---------------------------------------------------------------------------\nValueError: Of the three parameters: start, end, and periods, exactly two must be specified \n```", "```py\nIn [4]: pd.interval_range(start=0, end=4)\nOut[4]:\nIntervalIndex([(0, 1], (1, 2], (2, 3]]\n closed='right',\n dtype='interval[int64]') \n```", "```py\nIn [57]: pd.interval_range(start=0, end=4)\nOut[57]: IntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4]], dtype='interval[int64, right]') \n```", "```py\nIn [58]: df = pd.DataFrame({'A': [1, 2, 3]}, index=['foo', 'bar', 'baz']) \n```", "```py\nIn [3]: df.select(lambda x: x in ['bar', 'baz'])\nFutureWarning: select is deprecated and will be removed in a future release. You can use .loc[crit] as a replacement\nOut[3]:\n A\nbar  2\nbaz  3 \n```", "```py\nIn [59]: df.loc[df.index.map(lambda x: x in ['bar', 'baz'])]\nOut[59]: \n A\nbar  2\nbaz  3\n\n[2 rows x 1 columns] \n```", "```py\nIn [58]: df = pd.DataFrame({'A': [1, 2, 3]}, index=['foo', 'bar', 'baz']) \n```", "```py\nIn [3]: df.select(lambda x: x in ['bar', 'baz'])\nFutureWarning: select is deprecated and will be removed in a future release. You can use .loc[crit] as a replacement\nOut[3]:\n A\nbar  2\nbaz  3 \n```", "```py\nIn [59]: df.loc[df.index.map(lambda x: x in ['bar', 'baz'])]\nOut[59]: \n A\nbar  2\nbaz  3\n\n[2 rows x 1 columns] \n```"]