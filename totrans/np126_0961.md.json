["```py\nfrom numpy.random import SeedSequence, default_rng\n\nss = SeedSequence(12345)\n\n# Spawn off 10 child SeedSequences to pass to child processes.\nchild_seeds = ss.spawn(10)\nstreams = [default_rng(s) for s in child_seeds] \n```", "```py\nparent_rng = default_rng(12345)\nstreams = parent_rng.spawn(10) \n```", "```py\ngrandchildren = streams[0].spawn(4) \n```", "```py\n# default_rng() and each of the BitGenerators use SeedSequence underneath, so\n# they all accept sequences of integers as seeds the same way.\nfrom numpy.random import default_rng\n\ndef worker(root_seed, worker_id):\n    rng = default_rng([worker_id, root_seed])\n    # Do work ...\n\nroot_seed = 0x8c3c010cb4754c905776bdac5ee7501\nresults = [worker(root_seed, worker_id) for worker_id in range(10)] \n```", "```py\n# UNSAFE! Do not do this!\nworker_seed = root_seed + worker_id\nrng = np.random.RandomState(worker_seed) \n```", "```py\n# Good.\nworker_seed = [worker_id, root_seed]\n\n# Less good. It will *work*, but it's less flexible.\nworker_seed = [root_seed, worker_id] \n```", "```py\nimport secrets\nfrom numpy.random import Philox\n\n# 128-bit number as a seed\nroot_seed = secrets.getrandbits(128)\nstreams = [Philox(key=root_seed + stream_id) for stream_id in range(10)] \n```", "```py\nimport secrets\nfrom numpy.random import PCG64\n\nseed = secrets.getrandbits(128)\nblocked_rng = []\nrng = PCG64(seed)\nfor i in range(10):\n    blocked_rng.append(rng.jumped(i)) \n```", "```py\nfrom numpy.random import SeedSequence, default_rng\n\nss = SeedSequence(12345)\n\n# Spawn off 10 child SeedSequences to pass to child processes.\nchild_seeds = ss.spawn(10)\nstreams = [default_rng(s) for s in child_seeds] \n```", "```py\nparent_rng = default_rng(12345)\nstreams = parent_rng.spawn(10) \n```", "```py\ngrandchildren = streams[0].spawn(4) \n```", "```py\n# default_rng() and each of the BitGenerators use SeedSequence underneath, so\n# they all accept sequences of integers as seeds the same way.\nfrom numpy.random import default_rng\n\ndef worker(root_seed, worker_id):\n    rng = default_rng([worker_id, root_seed])\n    # Do work ...\n\nroot_seed = 0x8c3c010cb4754c905776bdac5ee7501\nresults = [worker(root_seed, worker_id) for worker_id in range(10)] \n```", "```py\n# UNSAFE! Do not do this!\nworker_seed = root_seed + worker_id\nrng = np.random.RandomState(worker_seed) \n```", "```py\n# Good.\nworker_seed = [worker_id, root_seed]\n\n# Less good. It will *work*, but it's less flexible.\nworker_seed = [root_seed, worker_id] \n```", "```py\nimport secrets\nfrom numpy.random import Philox\n\n# 128-bit number as a seed\nroot_seed = secrets.getrandbits(128)\nstreams = [Philox(key=root_seed + stream_id) for stream_id in range(10)] \n```", "```py\nimport secrets\nfrom numpy.random import PCG64\n\nseed = secrets.getrandbits(128)\nblocked_rng = []\nrng = PCG64(seed)\nfor i in range(10):\n    blocked_rng.append(rng.jumped(i)) \n```"]