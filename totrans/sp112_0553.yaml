- en: scipy.signal.freqz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.freqz.html#scipy.signal.freqz](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.freqz.html#scipy.signal.freqz)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Compute the frequency response of a digital filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the M-order numerator *b* and N-order denominator *a* of a digital filter,
    compute its frequency response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**b**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Numerator of a linear filter. If *b* has dimension greater than 1, it is assumed
    that the coefficients are stored in the first dimension, and `b.shape[1:]`, `a.shape[1:]`,
    and the shape of the frequencies array must be compatible for broadcasting.
  prefs: []
  type: TYPE_NORMAL
- en: '**a**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Denominator of a linear filter. If *b* has dimension greater than 1, it is assumed
    that the coefficients are stored in the first dimension, and `b.shape[1:]`, `a.shape[1:]`,
    and the shape of the frequencies array must be compatible for broadcasting.
  prefs: []
  type: TYPE_NORMAL
- en: '**worN**{None, int, array_like}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a single integer, then compute at that many frequencies (default is N=512).
    This is a convenient alternative to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using a number that is fast for FFT computations can result in faster computations
    (see Notes).
  prefs: []
  type: TYPE_NORMAL
- en: If an array_like, compute the response at the frequencies given. These are in
    the same units as *fs*.
  prefs: []
  type: TYPE_NORMAL
- en: '**whole**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, frequencies are computed from 0 to the Nyquist frequency, fs/2 (upper-half
    of unit-circle). If *whole* is True, compute frequencies from 0 to fs. Ignored
    if worN is array_like.
  prefs: []
  type: TYPE_NORMAL
- en: '**plot**callable'
  prefs: []
  type: TYPE_NORMAL
- en: A callable that takes two arguments. If given, the return parameters *w* and
    *h* are passed to plot. Useful for plotting the frequency response inside [`freqz`](#scipy.signal.freqz
    "scipy.signal.freqz").
  prefs: []
  type: TYPE_NORMAL
- en: '**fs**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The sampling frequency of the digital system. Defaults to 2*pi radians/sample
    (so w is from 0 to pi).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**include_nyquist**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *whole* is False and *worN* is an integer, setting *include_nyquist* to True
    will include the last frequency (Nyquist frequency) and is otherwise ignored.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.5.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**w**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The frequencies at which *h* was computed, in the same units as *fs*. By default,
    *w* is normalized to the range [0, pi) (radians/sample).
  prefs: []
  type: TYPE_NORMAL
- en: '**h**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: The frequency response, as complex numbers.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`freqz_zpk`](scipy.signal.freqz_zpk.html#scipy.signal.freqz_zpk "scipy.signal.freqz_zpk")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sosfreqz`](scipy.signal.sosfreqz.html#scipy.signal.sosfreqz "scipy.signal.sosfreqz")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Matplotlib’s [`matplotlib.pyplot.plot`](https://matplotlib.org/stable/api/_as_gen/matplotlib.pyplot.plot.html#matplotlib.pyplot.plot
    "(in Matplotlib v3.8.2)") function as the callable for *plot* produces unexpected
    results, as this plots the real part of the complex transfer function, not the
    magnitude. Try `lambda w, h: plot(w, np.abs(h))`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A direct computation via (R)FFT is used to compute the frequency response when
    the following conditions are met:'
  prefs: []
  type: TYPE_NORMAL
- en: An integer value is given for *worN*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*worN* is fast to compute via FFT (i.e., [`next_fast_len(worN)`](scipy.fft.next_fast_len.html#scipy.fft.next_fast_len
    "scipy.fft.next_fast_len") equals *worN*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The denominator coefficients are a single value (`a.shape[0] == 1`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*worN* is at least as long as the numerator coefficients (`worN >= b.shape[0]`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `b.ndim > 1`, then `b.shape[-1] == 1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For long FIR filters, the FFT approach can have lower error and be much faster
    than the equivalent direct polynomial calculation.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-signal-freqz-1_00_00.png](../Images/93c9d64d7c517e269b9bd306bf209cb5.png)'
  prefs: []
  type: TYPE_IMG
- en: Broadcasting Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have two FIR filters whose coefficients are stored in the rows of
    an array with shape (2, 25). For this demonstration, we’ll use random data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the frequency response for these two filters with one call to [`freqz`](#scipy.signal.freqz
    "scipy.signal.freqz"), we must pass in `b.T`, because [`freqz`](#scipy.signal.freqz
    "scipy.signal.freqz") expects the first axis to hold the coefficients. We must
    then extend the shape with a trivial dimension of length 1 to allow broadcasting
    with the array of frequencies. That is, we pass in `b.T[..., np.newaxis]`, which
    has shape (25, 2, 1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, suppose we have two transfer functions, with the same numerator coefficients
    `b = [0.5, 0.5]`. The coefficients for the two denominators are stored in the
    first dimension of the 2-D array *a*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Only *a* is more than 1-D. To make it compatible for broadcasting with the
    frequencies, we extend it with a trivial dimension in the call to [`freqz`](#scipy.signal.freqz
    "scipy.signal.freqz"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
