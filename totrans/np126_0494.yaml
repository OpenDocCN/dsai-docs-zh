- en: Discrete Fourier Transform (numpy.fft)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/routines.fft.html](https://numpy.org/doc/1.26/reference/routines.fft.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The SciPy module [`scipy.fft`](https://docs.scipy.org/doc/scipy/reference/fft.html#module-scipy.fft
    "(in SciPy v1.11.2)") is a more comprehensive superset of `numpy.fft`, which includes
    only a basic set of routines.
  prefs: []
  type: TYPE_NORMAL
- en: Standard FFTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`fft`](generated/numpy.fft.fft.html#numpy.fft.fft "numpy.fft.fft")(a[, n, axis, norm])
    | Compute the one-dimensional discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ifft`](generated/numpy.fft.ifft.html#numpy.fft.ifft "numpy.fft.ifft")(a[, n, axis, norm])
    | Compute the one-dimensional inverse discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fft2`](generated/numpy.fft.fft2.html#numpy.fft.fft2 "numpy.fft.fft2")(a[, s, axes, norm])
    | Compute the 2-dimensional discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ifft2`](generated/numpy.fft.ifft2.html#numpy.fft.ifft2 "numpy.fft.ifft2")(a[, s, axes, norm])
    | Compute the 2-dimensional inverse discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fftn`](generated/numpy.fft.fftn.html#numpy.fft.fftn "numpy.fft.fftn")(a[, s, axes, norm])
    | Compute the N-dimensional discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ifftn`](generated/numpy.fft.ifftn.html#numpy.fft.ifftn "numpy.fft.ifftn")(a[, s, axes, norm])
    | Compute the N-dimensional inverse discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: Real FFTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")(a[, n, axis, norm])
    | Compute the one-dimensional discrete Fourier Transform for real input. |'
  prefs: []
  type: TYPE_TB
- en: '| [`irfft`](generated/numpy.fft.irfft.html#numpy.fft.irfft "numpy.fft.irfft")(a[, n, axis, norm])
    | Computes the inverse of [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft
    "numpy.fft.rfft"). |'
  prefs: []
  type: TYPE_TB
- en: '| [`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2 "numpy.fft.rfft2")(a[, s, axes, norm])
    | Compute the 2-dimensional FFT of a real array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`irfft2`](generated/numpy.fft.irfft2.html#numpy.fft.irfft2 "numpy.fft.irfft2")(a[, s, axes, norm])
    | Computes the inverse of [`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2
    "numpy.fft.rfft2"). |'
  prefs: []
  type: TYPE_TB
- en: '| [`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn "numpy.fft.rfftn")(a[, s, axes, norm])
    | Compute the N-dimensional discrete Fourier Transform for real input. |'
  prefs: []
  type: TYPE_TB
- en: '| [`irfftn`](generated/numpy.fft.irfftn.html#numpy.fft.irfftn "numpy.fft.irfftn")(a[, s, axes, norm])
    | Computes the inverse of [`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn
    "numpy.fft.rfftn"). |'
  prefs: []
  type: TYPE_TB
- en: Hermitian FFTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft")(a[, n, axis, norm])
    | Compute the FFT of a signal that has Hermitian symmetry, i.e., a real spectrum.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`ihfft`](generated/numpy.fft.ihfft.html#numpy.fft.ihfft "numpy.fft.ihfft")(a[, n, axis, norm])
    | Compute the inverse FFT of a signal that has Hermitian symmetry. |'
  prefs: []
  type: TYPE_TB
- en: Helper routines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`fftfreq`](generated/numpy.fft.fftfreq.html#numpy.fft.fftfreq "numpy.fft.fftfreq")(n[, d])
    | Return the Discrete Fourier Transform sample frequencies. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rfftfreq`](generated/numpy.fft.rfftfreq.html#numpy.fft.rfftfreq "numpy.fft.rfftfreq")(n[, d])
    | Return the Discrete Fourier Transform sample frequencies (for usage with rfft,
    irfft). |'
  prefs: []
  type: TYPE_TB
- en: '| [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift "numpy.fft.fftshift")(x[, axes])
    | Shift the zero-frequency component to the center of the spectrum. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ifftshift`](generated/numpy.fft.ifftshift.html#numpy.fft.ifftshift "numpy.fft.ifftshift")(x[, axes])
    | The inverse of [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift
    "numpy.fft.fftshift"). |'
  prefs: []
  type: TYPE_TB
- en: Background information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fourier analysis is fundamentally a method for expressing a function as a sum
    of periodic components, and for recovering the function from those components.
    When both the function and its Fourier transform are replaced with discretized
    counterparts, it is called the discrete Fourier transform (DFT). The DFT has become
    a mainstay of numerical computing in part because of a very fast algorithm for
    computing it, called the Fast Fourier Transform (FFT), which was known to Gauss
    (1805) and was brought to light in its current form by Cooley and Tukey [[CT]](#rfb1dc64dd6a5-ct).
    Press et al. [[NR]](#rfb1dc64dd6a5-nr) provide an accessible introduction to Fourier
    analysis and its applications.
  prefs: []
  type: TYPE_NORMAL
- en: Because the discrete Fourier transform separates its input into components that
    contribute at discrete frequencies, it has a great number of applications in digital
    signal processing, e.g., for filtering, and in this context the discretized input
    to the transform is customarily referred to as a *signal*, which exists in the
    *time domain*. The output is called a *spectrum* or *transform* and exists in
    the *frequency domain*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to define the DFT, varying in the sign of the exponent,
    normalization, etc. In this implementation, the DFT is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[A_k = \sum_{m=0}^{n-1} a_m \exp\left\{-2\pi i{mk \over n}\right\} \qquad k
    = 0,\ldots,n-1.\]
  prefs: []
  type: TYPE_NORMAL
- en: The DFT is in general defined for complex inputs and outputs, and a single-frequency
    component at linear frequency \(f\) is represented by a complex exponential \(a_m
    = \exp\{2\pi i\,f m\Delta t\}\), where \(\Delta t\) is the sampling interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values in the result follow so-called “standard” order: If `A = fft(a,
    n)`, then `A[0]` contains the zero-frequency term (the sum of the signal), which
    is always purely real for real inputs. Then `A[1:n/2]` contains the positive-frequency
    terms, and `A[n/2+1:]` contains the negative-frequency terms, in order of decreasingly
    negative frequency. For an even number of input points, `A[n/2]` represents both
    positive and negative Nyquist frequency, and is also purely real for real input.
    For an odd number of input points, `A[(n-1)/2]` contains the largest positive
    frequency, while `A[(n+1)/2]` contains the largest negative frequency. The routine
    `np.fft.fftfreq(n)` returns an array giving the frequencies of corresponding elements
    in the output. The routine `np.fft.fftshift(A)` shifts transforms and their frequencies
    to put the zero-frequency components in the middle, and `np.fft.ifftshift(A)`
    undoes that shift.'
  prefs: []
  type: TYPE_NORMAL
- en: When the input *a* is a time-domain signal and `A = fft(a)`, `np.abs(A)` is
    its amplitude spectrum and `np.abs(A)**2` is its power spectrum. The phase spectrum
    is obtained by `np.angle(A)`.
  prefs: []
  type: TYPE_NORMAL
- en: The inverse DFT is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[a_m = \frac{1}{n}\sum_{k=0}^{n-1}A_k\exp\left\{2\pi i{mk\over n}\right\} \qquad
    m = 0,\ldots,n-1.\]
  prefs: []
  type: TYPE_NORMAL
- en: It differs from the forward transform by the sign of the exponential argument
    and the default normalization by \(1/n\).
  prefs: []
  type: TYPE_NORMAL
- en: Type Promotion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`numpy.fft`](#module-numpy.fft "numpy.fft") promotes `float32` and `complex64`
    arrays to `float64` and `complex128` arrays respectively. For an FFT implementation
    that does not promote input arrays, see [`scipy.fftpack`](https://docs.scipy.org/doc/scipy/reference/fftpack.html#module-scipy.fftpack
    "(in SciPy v1.11.2)").'
  prefs: []
  type: TYPE_NORMAL
- en: Normalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The argument `norm` indicates which direction of the pair of direct/inverse
    transforms is scaled and with what normalization factor. The default normalization
    (`"backward"`) has the direct (forward) transforms unscaled and the inverse (backward)
    transforms scaled by \(1/n\). It is possible to obtain unitary transforms by setting
    the keyword argument `norm` to `"ortho"` so that both direct and inverse transforms
    are scaled by \(1/\sqrt{n}\). Finally, setting the keyword argument `norm` to
    `"forward"` has the direct transforms scaled by \(1/n\) and the inverse transforms
    unscaled (i.e. exactly opposite to the default `"backward"`). *None* is an alias
    of the default option `"backward"` for backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Real and Hermitian transforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the input is purely real, its transform is Hermitian, i.e., the component
    at frequency \(f_k\) is the complex conjugate of the component at frequency \(-f_k\),
    which means that for real inputs there is no information in the negative frequency
    components that is not already available from the positive frequency components.
    The family of [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")
    functions is designed to operate on real inputs, and exploits this symmetry by
    computing only the positive frequency components, up to and including the Nyquist
    frequency. Thus, `n` input points produce `n/2+1` complex output points. The inverses
    of this family assumes the same symmetry of its input, and for an output of `n`
    points uses `n/2+1` input points.
  prefs: []
  type: TYPE_NORMAL
- en: Correspondingly, when the spectrum is purely real, the signal is Hermitian.
    The [`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft") family
    of functions exploits this symmetry by using `n/2+1` complex points in the input
    (time) domain for `n` real points in the frequency domain.
  prefs: []
  type: TYPE_NORMAL
- en: In higher dimensions, FFTs are used, e.g., for image analysis and filtering.
    The computational efficiency of the FFT means that it can also be a faster way
    to compute large convolutions, using the property that a convolution in the time
    domain is equivalent to a point-by-point multiplication in the frequency domain.
  prefs: []
  type: TYPE_NORMAL
- en: Higher dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In two dimensions, the DFT is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[A_{kl} = \sum_{m=0}^{M-1} \sum_{n=0}^{N-1} a_{mn}\exp\left\{-2\pi i \left({mk\over
    M}+{nl\over N}\right)\right\} \qquad k = 0, \ldots, M-1;\quad l = 0, \ldots, N-1,\]
  prefs: []
  type: TYPE_NORMAL
- en: which extends in the obvious way to higher dimensions, and the inverses in higher
    dimensions also extend in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[[CT](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cooley, James W., and John W. Tukey, 1965, “An algorithm for the machine calculation
    of complex Fourier series,” *Math. Comput.* 19: 297-301.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[NR](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P., 2007, *Numerical
    Recipes: The Art of Scientific Computing*, ch. 12-13\. Cambridge Univ. Press,
    Cambridge, UK.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For examples, see the various functions.
  prefs: []
  type: TYPE_NORMAL
- en: Standard FFTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`fft`](generated/numpy.fft.fft.html#numpy.fft.fft "numpy.fft.fft")(a[, n, axis, norm])
    | Compute the one-dimensional discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ifft`](generated/numpy.fft.ifft.html#numpy.fft.ifft "numpy.fft.ifft")(a[, n, axis, norm])
    | Compute the one-dimensional inverse discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fft2`](generated/numpy.fft.fft2.html#numpy.fft.fft2 "numpy.fft.fft2")(a[, s, axes, norm])
    | Compute the 2-dimensional discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ifft2`](generated/numpy.fft.ifft2.html#numpy.fft.ifft2 "numpy.fft.ifft2")(a[, s, axes, norm])
    | Compute the 2-dimensional inverse discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`fftn`](generated/numpy.fft.fftn.html#numpy.fft.fftn "numpy.fft.fftn")(a[, s, axes, norm])
    | Compute the N-dimensional discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ifftn`](generated/numpy.fft.ifftn.html#numpy.fft.ifftn "numpy.fft.ifftn")(a[, s, axes, norm])
    | Compute the N-dimensional inverse discrete Fourier Transform. |'
  prefs: []
  type: TYPE_TB
- en: Real FFTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")(a[, n, axis, norm])
    | Compute the one-dimensional discrete Fourier Transform for real input. |'
  prefs: []
  type: TYPE_TB
- en: '| [`irfft`](generated/numpy.fft.irfft.html#numpy.fft.irfft "numpy.fft.irfft")(a[, n, axis, norm])
    | Computes the inverse of [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft
    "numpy.fft.rfft"). |'
  prefs: []
  type: TYPE_TB
- en: '| [`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2 "numpy.fft.rfft2")(a[, s, axes, norm])
    | Compute the 2-dimensional FFT of a real array. |'
  prefs: []
  type: TYPE_TB
- en: '| [`irfft2`](generated/numpy.fft.irfft2.html#numpy.fft.irfft2 "numpy.fft.irfft2")(a[, s, axes, norm])
    | Computes the inverse of [`rfft2`](generated/numpy.fft.rfft2.html#numpy.fft.rfft2
    "numpy.fft.rfft2"). |'
  prefs: []
  type: TYPE_TB
- en: '| [`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn "numpy.fft.rfftn")(a[, s, axes, norm])
    | Compute the N-dimensional discrete Fourier Transform for real input. |'
  prefs: []
  type: TYPE_TB
- en: '| [`irfftn`](generated/numpy.fft.irfftn.html#numpy.fft.irfftn "numpy.fft.irfftn")(a[, s, axes, norm])
    | Computes the inverse of [`rfftn`](generated/numpy.fft.rfftn.html#numpy.fft.rfftn
    "numpy.fft.rfftn"). |'
  prefs: []
  type: TYPE_TB
- en: Hermitian FFTs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft")(a[, n, axis, norm])
    | Compute the FFT of a signal that has Hermitian symmetry, i.e., a real spectrum.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`ihfft`](generated/numpy.fft.ihfft.html#numpy.fft.ihfft "numpy.fft.ihfft")(a[, n, axis, norm])
    | Compute the inverse FFT of a signal that has Hermitian symmetry. |'
  prefs: []
  type: TYPE_TB
- en: Helper routines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| [`fftfreq`](generated/numpy.fft.fftfreq.html#numpy.fft.fftfreq "numpy.fft.fftfreq")(n[, d])
    | Return the Discrete Fourier Transform sample frequencies. |'
  prefs: []
  type: TYPE_TB
- en: '| [`rfftfreq`](generated/numpy.fft.rfftfreq.html#numpy.fft.rfftfreq "numpy.fft.rfftfreq")(n[, d])
    | Return the Discrete Fourier Transform sample frequencies (for usage with rfft,
    irfft). |'
  prefs: []
  type: TYPE_TB
- en: '| [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift "numpy.fft.fftshift")(x[, axes])
    | Shift the zero-frequency component to the center of the spectrum. |'
  prefs: []
  type: TYPE_TB
- en: '| [`ifftshift`](generated/numpy.fft.ifftshift.html#numpy.fft.ifftshift "numpy.fft.ifftshift")(x[, axes])
    | The inverse of [`fftshift`](generated/numpy.fft.fftshift.html#numpy.fft.fftshift
    "numpy.fft.fftshift"). |'
  prefs: []
  type: TYPE_TB
- en: Background information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Fourier analysis is fundamentally a method for expressing a function as a sum
    of periodic components, and for recovering the function from those components.
    When both the function and its Fourier transform are replaced with discretized
    counterparts, it is called the discrete Fourier transform (DFT). The DFT has become
    a mainstay of numerical computing in part because of a very fast algorithm for
    computing it, called the Fast Fourier Transform (FFT), which was known to Gauss
    (1805) and was brought to light in its current form by Cooley and Tukey [[CT]](#rfb1dc64dd6a5-ct).
    Press et al. [[NR]](#rfb1dc64dd6a5-nr) provide an accessible introduction to Fourier
    analysis and its applications.
  prefs: []
  type: TYPE_NORMAL
- en: Because the discrete Fourier transform separates its input into components that
    contribute at discrete frequencies, it has a great number of applications in digital
    signal processing, e.g., for filtering, and in this context the discretized input
    to the transform is customarily referred to as a *signal*, which exists in the
    *time domain*. The output is called a *spectrum* or *transform* and exists in
    the *frequency domain*.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many ways to define the DFT, varying in the sign of the exponent,
    normalization, etc. In this implementation, the DFT is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[A_k = \sum_{m=0}^{n-1} a_m \exp\left\{-2\pi i{mk \over n}\right\} \qquad k
    = 0,\ldots,n-1.\]
  prefs: []
  type: TYPE_NORMAL
- en: The DFT is in general defined for complex inputs and outputs, and a single-frequency
    component at linear frequency \(f\) is represented by a complex exponential \(a_m
    = \exp\{2\pi i\,f m\Delta t\}\), where \(\Delta t\) is the sampling interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values in the result follow so-called “standard” order: If `A = fft(a,
    n)`, then `A[0]` contains the zero-frequency term (the sum of the signal), which
    is always purely real for real inputs. Then `A[1:n/2]` contains the positive-frequency
    terms, and `A[n/2+1:]` contains the negative-frequency terms, in order of decreasingly
    negative frequency. For an even number of input points, `A[n/2]` represents both
    positive and negative Nyquist frequency, and is also purely real for real input.
    For an odd number of input points, `A[(n-1)/2]` contains the largest positive
    frequency, while `A[(n+1)/2]` contains the largest negative frequency. The routine
    `np.fft.fftfreq(n)` returns an array giving the frequencies of corresponding elements
    in the output. The routine `np.fft.fftshift(A)` shifts transforms and their frequencies
    to put the zero-frequency components in the middle, and `np.fft.ifftshift(A)`
    undoes that shift.'
  prefs: []
  type: TYPE_NORMAL
- en: When the input *a* is a time-domain signal and `A = fft(a)`, `np.abs(A)` is
    its amplitude spectrum and `np.abs(A)**2` is its power spectrum. The phase spectrum
    is obtained by `np.angle(A)`.
  prefs: []
  type: TYPE_NORMAL
- en: The inverse DFT is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[a_m = \frac{1}{n}\sum_{k=0}^{n-1}A_k\exp\left\{2\pi i{mk\over n}\right\} \qquad
    m = 0,\ldots,n-1.\]
  prefs: []
  type: TYPE_NORMAL
- en: It differs from the forward transform by the sign of the exponential argument
    and the default normalization by \(1/n\).
  prefs: []
  type: TYPE_NORMAL
- en: Type Promotion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`numpy.fft`](#module-numpy.fft "numpy.fft") promotes `float32` and `complex64`
    arrays to `float64` and `complex128` arrays respectively. For an FFT implementation
    that does not promote input arrays, see [`scipy.fftpack`](https://docs.scipy.org/doc/scipy/reference/fftpack.html#module-scipy.fftpack
    "(in SciPy v1.11.2)").'
  prefs: []
  type: TYPE_NORMAL
- en: Normalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The argument `norm` indicates which direction of the pair of direct/inverse
    transforms is scaled and with what normalization factor. The default normalization
    (`"backward"`) has the direct (forward) transforms unscaled and the inverse (backward)
    transforms scaled by \(1/n\). It is possible to obtain unitary transforms by setting
    the keyword argument `norm` to `"ortho"` so that both direct and inverse transforms
    are scaled by \(1/\sqrt{n}\). Finally, setting the keyword argument `norm` to
    `"forward"` has the direct transforms scaled by \(1/n\) and the inverse transforms
    unscaled (i.e. exactly opposite to the default `"backward"`). *None* is an alias
    of the default option `"backward"` for backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Real and Hermitian transforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the input is purely real, its transform is Hermitian, i.e., the component
    at frequency \(f_k\) is the complex conjugate of the component at frequency \(-f_k\),
    which means that for real inputs there is no information in the negative frequency
    components that is not already available from the positive frequency components.
    The family of [`rfft`](generated/numpy.fft.rfft.html#numpy.fft.rfft "numpy.fft.rfft")
    functions is designed to operate on real inputs, and exploits this symmetry by
    computing only the positive frequency components, up to and including the Nyquist
    frequency. Thus, `n` input points produce `n/2+1` complex output points. The inverses
    of this family assumes the same symmetry of its input, and for an output of `n`
    points uses `n/2+1` input points.
  prefs: []
  type: TYPE_NORMAL
- en: Correspondingly, when the spectrum is purely real, the signal is Hermitian.
    The [`hfft`](generated/numpy.fft.hfft.html#numpy.fft.hfft "numpy.fft.hfft") family
    of functions exploits this symmetry by using `n/2+1` complex points in the input
    (time) domain for `n` real points in the frequency domain.
  prefs: []
  type: TYPE_NORMAL
- en: In higher dimensions, FFTs are used, e.g., for image analysis and filtering.
    The computational efficiency of the FFT means that it can also be a faster way
    to compute large convolutions, using the property that a convolution in the time
    domain is equivalent to a point-by-point multiplication in the frequency domain.
  prefs: []
  type: TYPE_NORMAL
- en: Higher dimensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In two dimensions, the DFT is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[A_{kl} = \sum_{m=0}^{M-1} \sum_{n=0}^{N-1} a_{mn}\exp\left\{-2\pi i \left({mk\over
    M}+{nl\over N}\right)\right\} \qquad k = 0, \ldots, M-1;\quad l = 0, \ldots, N-1,\]
  prefs: []
  type: TYPE_NORMAL
- en: which extends in the obvious way to higher dimensions, and the inverses in higher
    dimensions also extend in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[[CT](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cooley, James W., and John W. Tukey, 1965, “An algorithm for the machine calculation
    of complex Fourier series,” *Math. Comput.* 19: 297-301.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[NR](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P., 2007, *Numerical
    Recipes: The Art of Scientific Computing*, ch. 12-13\. Cambridge Univ. Press,
    Cambridge, UK.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For examples, see the various functions.
  prefs: []
  type: TYPE_NORMAL
