["```py\nIn [1]: df = pd.DataFrame(\n ...:    {\n ...:        \"a\": np.random.randn(1000),\n ...:        \"b\": np.random.randn(1000),\n ...:        \"N\": np.random.randint(100, 1000, (1000)),\n ...:        \"x\": \"x\",\n ...:    }\n ...: )\n ...: \n\nIn [2]: df\nOut[2]: \n a         b    N  x\n0    0.469112 -0.218470  585  x\n1   -0.282863 -0.061645  841  x\n2   -1.509059 -0.723780  251  x\n3   -1.135632  0.551225  972  x\n4    1.212112 -0.497767  181  x\n..        ...       ...  ... ..\n995 -1.512743  0.874737  374  x\n996  0.933753  1.120790  246  x\n997 -0.308013  0.198768  157  x\n998 -0.079915  1.757555  977  x\n999 -1.010589 -1.115680  770  x\n\n[1000 rows x 4 columns] \n```", "```py\nIn [3]: def f(x):\n ...:    return x * (x - 1)\n ...: \n\nIn [4]: def integrate_f(a, b, N):\n ...:    s = 0\n ...:    dx = (b - a) / N\n ...:    for i in range(N):\n ...:        s += f(a + i * dx)\n ...:    return s * dx\n ...: \n```", "```py\nIn [5]: %timeit df.apply(lambda x: integrate_f(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n74.9 ms +- 728 us per loop (mean +- std. dev. of 7 runs, 10 loops each) \n```", "```py\n# most time consuming 4 calls\nIn [6]: %prun -l 4 df.apply(lambda x: integrate_f(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)  # noqa E999\n 605956 function calls (605938 primitive calls) in 0.167 seconds\n\n Ordered by: internal time\n List reduced from 163 to 4 due to restriction <4>\n\n ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 1000    0.097    0.000    0.148    0.000 <ipython-input-4-c2a74e076cf0>:1(integrate_f)\n 552423    0.051    0.000    0.051    0.000 <ipython-input-3-c138bdd570e3>:1(f)\n 3000    0.003    0.000    0.012    0.000 series.py:1095(__getitem__)\n 3000    0.002    0.000    0.005    0.000 series.py:1220(_get_value) \n```", "```py\nIn [7]: %load_ext Cython \n```", "```py\nIn [8]: %%cython\n ...: def f_plain(x):\n ...:    return x * (x - 1)\n ...: def integrate_f_plain(a, b, N):\n ...:    s = 0\n ...:    dx = (b - a) / N\n ...:    for i in range(N):\n ...:        s += f_plain(a + i * dx)\n ...:    return s * dx\n ...: \n```", "```py\nIn [9]: %timeit df.apply(lambda x: integrate_f_plain(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n46.6 ms +- 466 us per loop (mean +- std. dev. of 7 runs, 10 loops each) \n```", "```py\nIn [10]: %%cython\n ....: cdef double f_typed(double x) except? -2:\n ....:    return x * (x - 1)\n ....: cpdef double integrate_f_typed(double a, double b, int N):\n ....:    cdef int i\n ....:    cdef double s, dx\n ....:    s = 0\n ....:    dx = (b - a) / N\n ....:    for i in range(N):\n ....:        s += f_typed(a + i * dx)\n ....:    return s * dx\n ....: \n```", "```py\nIn [11]: %timeit df.apply(lambda x: integrate_f_typed(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n7.76 ms +- 83.8 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [12]: %prun -l 4 df.apply(lambda x: integrate_f_typed(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n 52533 function calls (52515 primitive calls) in 0.019 seconds\n\n Ordered by: internal time\n List reduced from 161 to 4 due to restriction <4>\n\n ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 3000    0.003    0.000    0.012    0.000 series.py:1095(__getitem__)\n 3000    0.002    0.000    0.005    0.000 series.py:1220(_get_value)\n 3000    0.002    0.000    0.002    0.000 base.py:3777(get_loc)\n 3000    0.002    0.000    0.002    0.000 indexing.py:2765(check_dict_or_set_indexers) \n```", "```py\nIn [13]: %%cython\n ....: cimport numpy as np\n ....: import numpy as np\n ....: cdef double f_typed(double x) except? -2:\n ....:    return x * (x - 1)\n ....: cpdef double integrate_f_typed(double a, double b, int N):\n ....:    cdef int i\n ....:    cdef double s, dx\n ....:    s = 0\n ....:    dx = (b - a) / N\n ....:    for i in range(N):\n ....:        s += f_typed(a + i * dx)\n ....:    return s * dx\n ....: cpdef np.ndarray[double] apply_integrate_f(np.ndarray col_a, np.ndarray col_b,\n ....:                                           np.ndarray col_N):\n ....:    assert (col_a.dtype == np.float64\n ....:            and col_b.dtype == np.float64 and col_N.dtype == np.dtype(int))\n ....:    cdef Py_ssize_t i, n = len(col_N)\n ....:    assert (len(col_a) == len(col_b) == n)\n ....:    cdef np.ndarray[double] res = np.empty(n)\n ....:    for i in range(len(col_a)):\n ....:        res[i] = integrate_f_typed(col_a[i], col_b[i], col_N[i])\n ....:    return res\n ....: \nContent of stderr:\nIn file included from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h:1929,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h:12,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h:5,\n from /home/runner/.cache/ipython/cython/_cython_magic_96d1519457caba8fa4f96b759be00659f51c6b18.c:1215:\n/home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:17:2: warning: #warning \"Using deprecated NumPy API, disable it with \" \"#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION\" [-Wcpp]\n 17 | #warning \"Using deprecated NumPy API, disable it with \" \\\n |  ^~~~~~~ \n```", "```py\nIn [14]: %timeit apply_integrate_f(df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy())\n834 us +- 4.04 us per loop (mean +- std. dev. of 7 runs, 1,000 loops each) \n```", "```py\nIn [15]: %prun -l 4 apply_integrate_f(df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy())\n 78 function calls in 0.001 seconds\n\n Ordered by: internal time\n List reduced from 21 to 4 due to restriction <4>\n\n ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 1    0.001    0.001    0.001    0.001 <string>:1(<module>)\n 1    0.000    0.000    0.001    0.001 {built-in method builtins.exec}\n 3    0.000    0.000    0.000    0.000 frame.py:4062(__getitem__)\n 3    0.000    0.000    0.000    0.000 base.py:541(to_numpy) \n```", "```py\nIn [16]: %%cython\n ....: cimport cython\n ....: cimport numpy as np\n ....: import numpy as np\n ....: cdef np.float64_t f_typed(np.float64_t x) except? -2:\n ....:    return x * (x - 1)\n ....: cpdef np.float64_t integrate_f_typed(np.float64_t a, np.float64_t b, np.int64_t N):\n ....:    cdef np.int64_t i\n ....:    cdef np.float64_t s = 0.0, dx\n ....:    dx = (b - a) / N\n ....:    for i in range(N):\n ....:        s += f_typed(a + i * dx)\n ....:    return s * dx\n ....: @cython.boundscheck(False)\n ....: @cython.wraparound(False)\n ....: cpdef np.ndarray[np.float64_t] apply_integrate_f_wrap(\n ....:    np.ndarray[np.float64_t] col_a,\n ....:    np.ndarray[np.float64_t] col_b,\n ....:    np.ndarray[np.int64_t] col_N\n ....: ):\n ....:    cdef np.int64_t i, n = len(col_N)\n ....:    assert len(col_a) == len(col_b) == n\n ....:    cdef np.ndarray[np.float64_t] res = np.empty(n, dtype=np.float64)\n ....:    for i in range(n):\n ....:        res[i] = integrate_f_typed(col_a[i], col_b[i], col_N[i])\n ....:    return res\n ....: \nContent of stderr:\nIn file included from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h:1929,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h:12,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h:5,\n from /home/runner/.cache/ipython/cython/_cython_magic_3bb7bde31cdaf5ab952bfe5a612c6edef03550d0.c:1216:\n/home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:17:2: warning: #warning \"Using deprecated NumPy API, disable it with \" \"#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION\" [-Wcpp]\n 17 | #warning \"Using deprecated NumPy API, disable it with \" \\\n |  ^~~~~~~ \n```", "```py\nIn [17]: %timeit apply_integrate_f_wrap(df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy())\n620 us +- 2.65 us per loop (mean +- std. dev. of 7 runs, 1,000 loops each) \n```", "```py\nIn [1]: data = pd.Series(range(1_000_000))  # noqa: E225\n\nIn [2]: roll = data.rolling(10)\n\nIn [3]: def f(x):\n ...:    return np.sum(x) + 5\n# Run the first time, compilation time will affect performance\nIn [4]: %timeit -r 1 -n 1 roll.apply(f, engine='numba', raw=True)\n1.23 s \u00b1 0 ns per loop (mean \u00b1 std. dev. of 1 run, 1 loop each)\n# Function is cached and performance will improve\nIn [5]: %timeit roll.apply(f, engine='numba', raw=True)\n188 ms \u00b1 1.93 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\nIn [6]: %timeit roll.apply(f, engine='cython', raw=True)\n3.92 s \u00b1 59 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) \n```", "```py\nIn [1]: import numba\n\nIn [2]: numba.set_num_threads(1)\n\nIn [3]: df = pd.DataFrame(np.random.randn(10_000, 100))\n\nIn [4]: roll = df.rolling(100)\n\nIn [5]: %timeit roll.mean(engine=\"numba\", engine_kwargs={\"parallel\": True})\n347 ms \u00b1 26 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n\nIn [6]: numba.set_num_threads(2)\n\nIn [7]: %timeit roll.mean(engine=\"numba\", engine_kwargs={\"parallel\": True})\n201 ms \u00b1 2.97 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) \n```", "```py\nimport numba\n\n@numba.jit\ndef f_plain(x):\n    return x * (x - 1)\n\n@numba.jit\ndef integrate_f_numba(a, b, N):\n    s = 0\n    dx = (b - a) / N\n    for i in range(N):\n        s += f_plain(a + i * dx)\n    return s * dx\n\n@numba.jit\ndef apply_integrate_f_numba(col_a, col_b, col_N):\n    n = len(col_N)\n    result = np.empty(n, dtype=\"float64\")\n    assert len(col_a) == len(col_b) == n\n    for i in range(n):\n        result[i] = integrate_f_numba(col_a[i], col_b[i], col_N[i])\n    return result\n\ndef compute_numba(df):\n    result = apply_integrate_f_numba(\n        df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy()\n    )\n    return pd.Series(result, index=df.index, name=\"result\") \n```", "```py\nIn [4]: %timeit compute_numba(df)\n1000 loops, best of 3: 798 us per loop \n```", "```py\nimport numba\n\ndef double_every_value_nonumba(x):\n    return x * 2\n\n@numba.vectorize\ndef double_every_value_withnumba(x):  # noqa E501\n    return x * 2 \n```", "```py\n# Custom function without numba\nIn [5]: %timeit df[\"col1_doubled\"] = df[\"a\"].apply(double_every_value_nonumba)  # noqa E501\n1000 loops, best of 3: 797 us per loop\n\n# Standard implementation (faster than a custom function)\nIn [6]: %timeit df[\"col1_doubled\"] = df[\"a\"] * 2\n1000 loops, best of 3: 233 us per loop\n\n# Custom function with numba\nIn [7]: %timeit df[\"col1_doubled\"] = double_every_value_withnumba(df[\"a\"].to_numpy())\n1000 loops, best of 3: 145 us per loop \n```", "```py\nIn [18]: df = pd.DataFrame(np.random.randn(5, 2), columns=list(\"ab\"))\n\nIn [19]: newcol = np.random.randn(len(df))\n\nIn [20]: df.eval(\"b + @newcol\")\nOut[20]: \n0   -0.206122\n1   -1.029587\n2    0.519726\n3   -2.052589\n4    1.453210\ndtype: float64\n\nIn [21]: df.query(\"b < @newcol\")\nOut[21]: \n a         b\n1  0.160268 -0.848896\n3  0.333758 -1.180355\n4  0.572182  0.439895 \n```", "```py\nIn [22]: a = np.random.randn()\n\nIn [23]: df.query(\"@a < a\")\nOut[23]: \n a         b\n0  0.473349  0.891236\n1  0.160268 -0.848896\n2  0.803311  1.662031\n3  0.333758 -1.180355\n4  0.572182  0.439895\n\nIn [24]: df.loc[a < df[\"a\"]]  # same as the previous expression\nOut[24]: \n a         b\n0  0.473349  0.891236\n1  0.160268 -0.848896\n2  0.803311  1.662031\n3  0.333758 -1.180355\n4  0.572182  0.439895 \n```", "```py\nIn [25]: a, b = 1, 2\n\nIn [26]: pd.eval(\"@a + b\")\nTraceback (most recent call last):\n\n File ~/micromamba/envs/test/lib/python3.10/site-packages/IPython/core/interactiveshell.py:3577 in run_code\n exec(code_obj, self.user_global_ns, self.user_ns)\n\n Cell In[26], line 1\n pd.eval(\"@a + b\")\n\n File ~/work/pandas/pandas/pandas/core/computation/eval.py:325 in eval\n _check_for_locals(expr, level, parser)\n\n File ~/work/pandas/pandas/pandas/core/computation/eval.py:167 in _check_for_locals\n raise SyntaxError(msg)\n\n File <string>\nSyntaxError: The '@' prefix is not allowed in top-level eval calls.\nplease refer to your variables by name without the '@' prefix. \n```", "```py\nIn [27]: pd.eval(\"a + b\")\nOut[27]: 3 \n```", "```py\nIn [28]: nrows, ncols = 20000, 100\n\nIn [29]: df1, df2, df3, df4 = [pd.DataFrame(np.random.randn(nrows, ncols)) for _ in range(4)]\n\nIn [30]: expr = \"(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\"\n\nIn [31]: x = pd.eval(expr, parser=\"python\")\n\nIn [32]: expr_no_parens = \"df1 > 0 & df2 > 0 & df3 > 0 & df4 > 0\"\n\nIn [33]: y = pd.eval(expr_no_parens, parser=\"pandas\")\n\nIn [34]: np.all(x == y)\nOut[34]: True \n```", "```py\nIn [35]: expr = \"(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\"\n\nIn [36]: x = pd.eval(expr, parser=\"python\")\n\nIn [37]: expr_with_ands = \"df1 > 0 and df2 > 0 and df3 > 0 and df4 > 0\"\n\nIn [38]: y = pd.eval(expr_with_ands, parser=\"pandas\")\n\nIn [39]: np.all(x == y)\nOut[39]: True \n```", "```py\nIn [40]: %timeit df1 + df2 + df3 + df4\n7.42 ms +- 81.8 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [41]: %timeit pd.eval(\"df1 + df2 + df3 + df4\", engine=\"python\")\n8.11 ms +- 161 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [42]: df = pd.DataFrame(np.random.randn(5, 2), columns=[\"a\", \"b\"])\n\nIn [43]: df.eval(\"a + b\")\nOut[43]: \n0   -0.161099\n1    0.805452\n2    0.747447\n3    1.189042\n4   -2.057490\ndtype: float64 \n```", "```py\nIn [44]: df = pd.DataFrame(dict(a=range(5), b=range(5, 10)))\n\nIn [45]: df = df.eval(\"c = a + b\")\n\nIn [46]: df = df.eval(\"d = a + b + c\")\n\nIn [47]: df = df.eval(\"a = 1\")\n\nIn [48]: df\nOut[48]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26 \n```", "```py\nIn [49]: df\nOut[49]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26\n\nIn [50]: df.eval(\"e = a - c\")\nOut[50]: \n a  b   c   d   e\n0  1  5   5  10  -4\n1  1  6   7  14  -6\n2  1  7   9  18  -8\n3  1  8  11  22 -10\n4  1  9  13  26 -12\n\nIn [51]: df\nOut[51]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26 \n```", "```py\nIn [52]: df.eval(\n ....: \"\"\"\n ....: c = a + b\n ....: d = a + b + c\n ....: a = 1\"\"\",\n ....: )\n ....: \nOut[52]: \n a  b   c   d\n0  1  5   6  12\n1  1  6   7  14\n2  1  7   8  16\n3  1  8   9  18\n4  1  9  10  20 \n```", "```py\nIn [53]: df = pd.DataFrame(dict(a=range(5), b=range(5, 10)))\n\nIn [54]: df[\"c\"] = df[\"a\"] + df[\"b\"]\n\nIn [55]: df[\"d\"] = df[\"a\"] + df[\"b\"] + df[\"c\"]\n\nIn [56]: df[\"a\"] = 1\n\nIn [57]: df\nOut[57]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26 \n```", "```py\nIn [58]: nrows, ncols = 20000, 100\n\nIn [59]: df1, df2, df3, df4 = [pd.DataFrame(np.random.randn(nrows, ncols)) for _ in range(4)] \n```", "```py\nIn [60]: %timeit df1 + df2 + df3 + df4\n7.34 ms +- 117 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [61]: %timeit pd.eval(\"df1 + df2 + df3 + df4\")\n2.85 ms +- 58.8 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [62]: %timeit (df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\n5.98 ms +- 37 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [63]: %timeit pd.eval(\"(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\")\n9.38 ms +- 36.7 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [64]: s = pd.Series(np.random.randn(50))\n\nIn [65]: %timeit df1 + df2 + df3 + df4 + s\n12.6 ms +- 105 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [66]: %timeit pd.eval(\"df1 + df2 + df3 + df4 + s\")\n3.69 ms +- 62 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\n1 and 2  # would parse to 1 & 2, but should evaluate to 2\n3 or 4  # would parse to 3 | 4, but should evaluate to 3\n~1  # this is okay, but slower when using eval \n```", "```py\nIn [67]: df = pd.DataFrame(\n ....:    {\"strings\": np.repeat(list(\"cba\"), 3), \"nums\": np.repeat(range(3), 3)}\n ....: )\n ....: \n\nIn [68]: df\nOut[68]: \n strings  nums\n0       c     0\n1       c     0\n2       c     0\n3       b     1\n4       b     1\n5       b     1\n6       a     2\n7       a     2\n8       a     2\n\nIn [69]: df.query(\"strings == 'a' and nums == 1\")\nOut[69]: \nEmpty DataFrame\nColumns: [strings, nums]\nIndex: [] \n```", "```py\nIn [1]: df = pd.DataFrame(\n ...:    {\n ...:        \"a\": np.random.randn(1000),\n ...:        \"b\": np.random.randn(1000),\n ...:        \"N\": np.random.randint(100, 1000, (1000)),\n ...:        \"x\": \"x\",\n ...:    }\n ...: )\n ...: \n\nIn [2]: df\nOut[2]: \n a         b    N  x\n0    0.469112 -0.218470  585  x\n1   -0.282863 -0.061645  841  x\n2   -1.509059 -0.723780  251  x\n3   -1.135632  0.551225  972  x\n4    1.212112 -0.497767  181  x\n..        ...       ...  ... ..\n995 -1.512743  0.874737  374  x\n996  0.933753  1.120790  246  x\n997 -0.308013  0.198768  157  x\n998 -0.079915  1.757555  977  x\n999 -1.010589 -1.115680  770  x\n\n[1000 rows x 4 columns] \n```", "```py\nIn [3]: def f(x):\n ...:    return x * (x - 1)\n ...: \n\nIn [4]: def integrate_f(a, b, N):\n ...:    s = 0\n ...:    dx = (b - a) / N\n ...:    for i in range(N):\n ...:        s += f(a + i * dx)\n ...:    return s * dx\n ...: \n```", "```py\nIn [5]: %timeit df.apply(lambda x: integrate_f(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n74.9 ms +- 728 us per loop (mean +- std. dev. of 7 runs, 10 loops each) \n```", "```py\n# most time consuming 4 calls\nIn [6]: %prun -l 4 df.apply(lambda x: integrate_f(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)  # noqa E999\n 605956 function calls (605938 primitive calls) in 0.167 seconds\n\n Ordered by: internal time\n List reduced from 163 to 4 due to restriction <4>\n\n ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 1000    0.097    0.000    0.148    0.000 <ipython-input-4-c2a74e076cf0>:1(integrate_f)\n 552423    0.051    0.000    0.051    0.000 <ipython-input-3-c138bdd570e3>:1(f)\n 3000    0.003    0.000    0.012    0.000 series.py:1095(__getitem__)\n 3000    0.002    0.000    0.005    0.000 series.py:1220(_get_value) \n```", "```py\nIn [7]: %load_ext Cython \n```", "```py\nIn [8]: %%cython\n ...: def f_plain(x):\n ...:    return x * (x - 1)\n ...: def integrate_f_plain(a, b, N):\n ...:    s = 0\n ...:    dx = (b - a) / N\n ...:    for i in range(N):\n ...:        s += f_plain(a + i * dx)\n ...:    return s * dx\n ...: \n```", "```py\nIn [9]: %timeit df.apply(lambda x: integrate_f_plain(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n46.6 ms +- 466 us per loop (mean +- std. dev. of 7 runs, 10 loops each) \n```", "```py\nIn [10]: %%cython\n ....: cdef double f_typed(double x) except? -2:\n ....:    return x * (x - 1)\n ....: cpdef double integrate_f_typed(double a, double b, int N):\n ....:    cdef int i\n ....:    cdef double s, dx\n ....:    s = 0\n ....:    dx = (b - a) / N\n ....:    for i in range(N):\n ....:        s += f_typed(a + i * dx)\n ....:    return s * dx\n ....: \n```", "```py\nIn [11]: %timeit df.apply(lambda x: integrate_f_typed(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n7.76 ms +- 83.8 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [12]: %prun -l 4 df.apply(lambda x: integrate_f_typed(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n 52533 function calls (52515 primitive calls) in 0.019 seconds\n\n Ordered by: internal time\n List reduced from 161 to 4 due to restriction <4>\n\n ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 3000    0.003    0.000    0.012    0.000 series.py:1095(__getitem__)\n 3000    0.002    0.000    0.005    0.000 series.py:1220(_get_value)\n 3000    0.002    0.000    0.002    0.000 base.py:3777(get_loc)\n 3000    0.002    0.000    0.002    0.000 indexing.py:2765(check_dict_or_set_indexers) \n```", "```py\nIn [13]: %%cython\n ....: cimport numpy as np\n ....: import numpy as np\n ....: cdef double f_typed(double x) except? -2:\n ....:    return x * (x - 1)\n ....: cpdef double integrate_f_typed(double a, double b, int N):\n ....:    cdef int i\n ....:    cdef double s, dx\n ....:    s = 0\n ....:    dx = (b - a) / N\n ....:    for i in range(N):\n ....:        s += f_typed(a + i * dx)\n ....:    return s * dx\n ....: cpdef np.ndarray[double] apply_integrate_f(np.ndarray col_a, np.ndarray col_b,\n ....:                                           np.ndarray col_N):\n ....:    assert (col_a.dtype == np.float64\n ....:            and col_b.dtype == np.float64 and col_N.dtype == np.dtype(int))\n ....:    cdef Py_ssize_t i, n = len(col_N)\n ....:    assert (len(col_a) == len(col_b) == n)\n ....:    cdef np.ndarray[double] res = np.empty(n)\n ....:    for i in range(len(col_a)):\n ....:        res[i] = integrate_f_typed(col_a[i], col_b[i], col_N[i])\n ....:    return res\n ....: \nContent of stderr:\nIn file included from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h:1929,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h:12,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h:5,\n from /home/runner/.cache/ipython/cython/_cython_magic_96d1519457caba8fa4f96b759be00659f51c6b18.c:1215:\n/home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:17:2: warning: #warning \"Using deprecated NumPy API, disable it with \" \"#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION\" [-Wcpp]\n 17 | #warning \"Using deprecated NumPy API, disable it with \" \\\n |  ^~~~~~~ \n```", "```py\nIn [14]: %timeit apply_integrate_f(df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy())\n834 us +- 4.04 us per loop (mean +- std. dev. of 7 runs, 1,000 loops each) \n```", "```py\nIn [15]: %prun -l 4 apply_integrate_f(df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy())\n 78 function calls in 0.001 seconds\n\n Ordered by: internal time\n List reduced from 21 to 4 due to restriction <4>\n\n ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 1    0.001    0.001    0.001    0.001 <string>:1(<module>)\n 1    0.000    0.000    0.001    0.001 {built-in method builtins.exec}\n 3    0.000    0.000    0.000    0.000 frame.py:4062(__getitem__)\n 3    0.000    0.000    0.000    0.000 base.py:541(to_numpy) \n```", "```py\nIn [16]: %%cython\n ....: cimport cython\n ....: cimport numpy as np\n ....: import numpy as np\n ....: cdef np.float64_t f_typed(np.float64_t x) except? -2:\n ....:    return x * (x - 1)\n ....: cpdef np.float64_t integrate_f_typed(np.float64_t a, np.float64_t b, np.int64_t N):\n ....:    cdef np.int64_t i\n ....:    cdef np.float64_t s = 0.0, dx\n ....:    dx = (b - a) / N\n ....:    for i in range(N):\n ....:        s += f_typed(a + i * dx)\n ....:    return s * dx\n ....: @cython.boundscheck(False)\n ....: @cython.wraparound(False)\n ....: cpdef np.ndarray[np.float64_t] apply_integrate_f_wrap(\n ....:    np.ndarray[np.float64_t] col_a,\n ....:    np.ndarray[np.float64_t] col_b,\n ....:    np.ndarray[np.int64_t] col_N\n ....: ):\n ....:    cdef np.int64_t i, n = len(col_N)\n ....:    assert len(col_a) == len(col_b) == n\n ....:    cdef np.ndarray[np.float64_t] res = np.empty(n, dtype=np.float64)\n ....:    for i in range(n):\n ....:        res[i] = integrate_f_typed(col_a[i], col_b[i], col_N[i])\n ....:    return res\n ....: \nContent of stderr:\nIn file included from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h:1929,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h:12,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h:5,\n from /home/runner/.cache/ipython/cython/_cython_magic_3bb7bde31cdaf5ab952bfe5a612c6edef03550d0.c:1216:\n/home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:17:2: warning: #warning \"Using deprecated NumPy API, disable it with \" \"#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION\" [-Wcpp]\n 17 | #warning \"Using deprecated NumPy API, disable it with \" \\\n |  ^~~~~~~ \n```", "```py\nIn [17]: %timeit apply_integrate_f_wrap(df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy())\n620 us +- 2.65 us per loop (mean +- std. dev. of 7 runs, 1,000 loops each) \n```", "```py\nIn [1]: df = pd.DataFrame(\n ...:    {\n ...:        \"a\": np.random.randn(1000),\n ...:        \"b\": np.random.randn(1000),\n ...:        \"N\": np.random.randint(100, 1000, (1000)),\n ...:        \"x\": \"x\",\n ...:    }\n ...: )\n ...: \n\nIn [2]: df\nOut[2]: \n a         b    N  x\n0    0.469112 -0.218470  585  x\n1   -0.282863 -0.061645  841  x\n2   -1.509059 -0.723780  251  x\n3   -1.135632  0.551225  972  x\n4    1.212112 -0.497767  181  x\n..        ...       ...  ... ..\n995 -1.512743  0.874737  374  x\n996  0.933753  1.120790  246  x\n997 -0.308013  0.198768  157  x\n998 -0.079915  1.757555  977  x\n999 -1.010589 -1.115680  770  x\n\n[1000 rows x 4 columns] \n```", "```py\nIn [3]: def f(x):\n ...:    return x * (x - 1)\n ...: \n\nIn [4]: def integrate_f(a, b, N):\n ...:    s = 0\n ...:    dx = (b - a) / N\n ...:    for i in range(N):\n ...:        s += f(a + i * dx)\n ...:    return s * dx\n ...: \n```", "```py\nIn [5]: %timeit df.apply(lambda x: integrate_f(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n74.9 ms +- 728 us per loop (mean +- std. dev. of 7 runs, 10 loops each) \n```", "```py\n# most time consuming 4 calls\nIn [6]: %prun -l 4 df.apply(lambda x: integrate_f(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)  # noqa E999\n 605956 function calls (605938 primitive calls) in 0.167 seconds\n\n Ordered by: internal time\n List reduced from 163 to 4 due to restriction <4>\n\n ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 1000    0.097    0.000    0.148    0.000 <ipython-input-4-c2a74e076cf0>:1(integrate_f)\n 552423    0.051    0.000    0.051    0.000 <ipython-input-3-c138bdd570e3>:1(f)\n 3000    0.003    0.000    0.012    0.000 series.py:1095(__getitem__)\n 3000    0.002    0.000    0.005    0.000 series.py:1220(_get_value) \n```", "```py\nIn [7]: %load_ext Cython \n```", "```py\nIn [8]: %%cython\n ...: def f_plain(x):\n ...:    return x * (x - 1)\n ...: def integrate_f_plain(a, b, N):\n ...:    s = 0\n ...:    dx = (b - a) / N\n ...:    for i in range(N):\n ...:        s += f_plain(a + i * dx)\n ...:    return s * dx\n ...: \n```", "```py\nIn [9]: %timeit df.apply(lambda x: integrate_f_plain(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n46.6 ms +- 466 us per loop (mean +- std. dev. of 7 runs, 10 loops each) \n```", "```py\nIn [10]: %%cython\n ....: cdef double f_typed(double x) except? -2:\n ....:    return x * (x - 1)\n ....: cpdef double integrate_f_typed(double a, double b, int N):\n ....:    cdef int i\n ....:    cdef double s, dx\n ....:    s = 0\n ....:    dx = (b - a) / N\n ....:    for i in range(N):\n ....:        s += f_typed(a + i * dx)\n ....:    return s * dx\n ....: \n```", "```py\nIn [11]: %timeit df.apply(lambda x: integrate_f_typed(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n7.76 ms +- 83.8 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [12]: %prun -l 4 df.apply(lambda x: integrate_f_typed(x[\"a\"], x[\"b\"], x[\"N\"]), axis=1)\n 52533 function calls (52515 primitive calls) in 0.019 seconds\n\n Ordered by: internal time\n List reduced from 161 to 4 due to restriction <4>\n\n ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 3000    0.003    0.000    0.012    0.000 series.py:1095(__getitem__)\n 3000    0.002    0.000    0.005    0.000 series.py:1220(_get_value)\n 3000    0.002    0.000    0.002    0.000 base.py:3777(get_loc)\n 3000    0.002    0.000    0.002    0.000 indexing.py:2765(check_dict_or_set_indexers) \n```", "```py\nIn [13]: %%cython\n ....: cimport numpy as np\n ....: import numpy as np\n ....: cdef double f_typed(double x) except? -2:\n ....:    return x * (x - 1)\n ....: cpdef double integrate_f_typed(double a, double b, int N):\n ....:    cdef int i\n ....:    cdef double s, dx\n ....:    s = 0\n ....:    dx = (b - a) / N\n ....:    for i in range(N):\n ....:        s += f_typed(a + i * dx)\n ....:    return s * dx\n ....: cpdef np.ndarray[double] apply_integrate_f(np.ndarray col_a, np.ndarray col_b,\n ....:                                           np.ndarray col_N):\n ....:    assert (col_a.dtype == np.float64\n ....:            and col_b.dtype == np.float64 and col_N.dtype == np.dtype(int))\n ....:    cdef Py_ssize_t i, n = len(col_N)\n ....:    assert (len(col_a) == len(col_b) == n)\n ....:    cdef np.ndarray[double] res = np.empty(n)\n ....:    for i in range(len(col_a)):\n ....:        res[i] = integrate_f_typed(col_a[i], col_b[i], col_N[i])\n ....:    return res\n ....: \nContent of stderr:\nIn file included from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h:1929,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h:12,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h:5,\n from /home/runner/.cache/ipython/cython/_cython_magic_96d1519457caba8fa4f96b759be00659f51c6b18.c:1215:\n/home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:17:2: warning: #warning \"Using deprecated NumPy API, disable it with \" \"#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION\" [-Wcpp]\n 17 | #warning \"Using deprecated NumPy API, disable it with \" \\\n |  ^~~~~~~ \n```", "```py\nIn [14]: %timeit apply_integrate_f(df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy())\n834 us +- 4.04 us per loop (mean +- std. dev. of 7 runs, 1,000 loops each) \n```", "```py\nIn [15]: %prun -l 4 apply_integrate_f(df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy())\n 78 function calls in 0.001 seconds\n\n Ordered by: internal time\n List reduced from 21 to 4 due to restriction <4>\n\n ncalls  tottime  percall  cumtime  percall filename:lineno(function)\n 1    0.001    0.001    0.001    0.001 <string>:1(<module>)\n 1    0.000    0.000    0.001    0.001 {built-in method builtins.exec}\n 3    0.000    0.000    0.000    0.000 frame.py:4062(__getitem__)\n 3    0.000    0.000    0.000    0.000 base.py:541(to_numpy) \n```", "```py\nIn [16]: %%cython\n ....: cimport cython\n ....: cimport numpy as np\n ....: import numpy as np\n ....: cdef np.float64_t f_typed(np.float64_t x) except? -2:\n ....:    return x * (x - 1)\n ....: cpdef np.float64_t integrate_f_typed(np.float64_t a, np.float64_t b, np.int64_t N):\n ....:    cdef np.int64_t i\n ....:    cdef np.float64_t s = 0.0, dx\n ....:    dx = (b - a) / N\n ....:    for i in range(N):\n ....:        s += f_typed(a + i * dx)\n ....:    return s * dx\n ....: @cython.boundscheck(False)\n ....: @cython.wraparound(False)\n ....: cpdef np.ndarray[np.float64_t] apply_integrate_f_wrap(\n ....:    np.ndarray[np.float64_t] col_a,\n ....:    np.ndarray[np.float64_t] col_b,\n ....:    np.ndarray[np.int64_t] col_N\n ....: ):\n ....:    cdef np.int64_t i, n = len(col_N)\n ....:    assert len(col_a) == len(col_b) == n\n ....:    cdef np.ndarray[np.float64_t] res = np.empty(n, dtype=np.float64)\n ....:    for i in range(n):\n ....:        res[i] = integrate_f_typed(col_a[i], col_b[i], col_N[i])\n ....:    return res\n ....: \nContent of stderr:\nIn file included from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarraytypes.h:1929,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/ndarrayobject.h:12,\n from /home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/arrayobject.h:5,\n from /home/runner/.cache/ipython/cython/_cython_magic_3bb7bde31cdaf5ab952bfe5a612c6edef03550d0.c:1216:\n/home/runner/micromamba/envs/test/lib/python3.10/site-packages/numpy/core/include/numpy/npy_1_7_deprecated_api.h:17:2: warning: #warning \"Using deprecated NumPy API, disable it with \" \"#define NPY_NO_DEPRECATED_API NPY_1_7_API_VERSION\" [-Wcpp]\n 17 | #warning \"Using deprecated NumPy API, disable it with \" \\\n |  ^~~~~~~ \n```", "```py\nIn [17]: %timeit apply_integrate_f_wrap(df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy())\n620 us +- 2.65 us per loop (mean +- std. dev. of 7 runs, 1,000 loops each) \n```", "```py\nIn [1]: data = pd.Series(range(1_000_000))  # noqa: E225\n\nIn [2]: roll = data.rolling(10)\n\nIn [3]: def f(x):\n ...:    return np.sum(x) + 5\n# Run the first time, compilation time will affect performance\nIn [4]: %timeit -r 1 -n 1 roll.apply(f, engine='numba', raw=True)\n1.23 s \u00b1 0 ns per loop (mean \u00b1 std. dev. of 1 run, 1 loop each)\n# Function is cached and performance will improve\nIn [5]: %timeit roll.apply(f, engine='numba', raw=True)\n188 ms \u00b1 1.93 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\nIn [6]: %timeit roll.apply(f, engine='cython', raw=True)\n3.92 s \u00b1 59 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) \n```", "```py\nIn [1]: import numba\n\nIn [2]: numba.set_num_threads(1)\n\nIn [3]: df = pd.DataFrame(np.random.randn(10_000, 100))\n\nIn [4]: roll = df.rolling(100)\n\nIn [5]: %timeit roll.mean(engine=\"numba\", engine_kwargs={\"parallel\": True})\n347 ms \u00b1 26 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n\nIn [6]: numba.set_num_threads(2)\n\nIn [7]: %timeit roll.mean(engine=\"numba\", engine_kwargs={\"parallel\": True})\n201 ms \u00b1 2.97 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) \n```", "```py\nimport numba\n\n@numba.jit\ndef f_plain(x):\n    return x * (x - 1)\n\n@numba.jit\ndef integrate_f_numba(a, b, N):\n    s = 0\n    dx = (b - a) / N\n    for i in range(N):\n        s += f_plain(a + i * dx)\n    return s * dx\n\n@numba.jit\ndef apply_integrate_f_numba(col_a, col_b, col_N):\n    n = len(col_N)\n    result = np.empty(n, dtype=\"float64\")\n    assert len(col_a) == len(col_b) == n\n    for i in range(n):\n        result[i] = integrate_f_numba(col_a[i], col_b[i], col_N[i])\n    return result\n\ndef compute_numba(df):\n    result = apply_integrate_f_numba(\n        df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy()\n    )\n    return pd.Series(result, index=df.index, name=\"result\") \n```", "```py\nIn [4]: %timeit compute_numba(df)\n1000 loops, best of 3: 798 us per loop \n```", "```py\nimport numba\n\ndef double_every_value_nonumba(x):\n    return x * 2\n\n@numba.vectorize\ndef double_every_value_withnumba(x):  # noqa E501\n    return x * 2 \n```", "```py\n# Custom function without numba\nIn [5]: %timeit df[\"col1_doubled\"] = df[\"a\"].apply(double_every_value_nonumba)  # noqa E501\n1000 loops, best of 3: 797 us per loop\n\n# Standard implementation (faster than a custom function)\nIn [6]: %timeit df[\"col1_doubled\"] = df[\"a\"] * 2\n1000 loops, best of 3: 233 us per loop\n\n# Custom function with numba\nIn [7]: %timeit df[\"col1_doubled\"] = double_every_value_withnumba(df[\"a\"].to_numpy())\n1000 loops, best of 3: 145 us per loop \n```", "```py\nIn [1]: data = pd.Series(range(1_000_000))  # noqa: E225\n\nIn [2]: roll = data.rolling(10)\n\nIn [3]: def f(x):\n ...:    return np.sum(x) + 5\n# Run the first time, compilation time will affect performance\nIn [4]: %timeit -r 1 -n 1 roll.apply(f, engine='numba', raw=True)\n1.23 s \u00b1 0 ns per loop (mean \u00b1 std. dev. of 1 run, 1 loop each)\n# Function is cached and performance will improve\nIn [5]: %timeit roll.apply(f, engine='numba', raw=True)\n188 ms \u00b1 1.93 ms per loop (mean \u00b1 std. dev. of 7 runs, 10 loops each)\n\nIn [6]: %timeit roll.apply(f, engine='cython', raw=True)\n3.92 s \u00b1 59 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) \n```", "```py\nIn [1]: import numba\n\nIn [2]: numba.set_num_threads(1)\n\nIn [3]: df = pd.DataFrame(np.random.randn(10_000, 100))\n\nIn [4]: roll = df.rolling(100)\n\nIn [5]: %timeit roll.mean(engine=\"numba\", engine_kwargs={\"parallel\": True})\n347 ms \u00b1 26 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each)\n\nIn [6]: numba.set_num_threads(2)\n\nIn [7]: %timeit roll.mean(engine=\"numba\", engine_kwargs={\"parallel\": True})\n201 ms \u00b1 2.97 ms per loop (mean \u00b1 std. dev. of 7 runs, 1 loop each) \n```", "```py\nimport numba\n\n@numba.jit\ndef f_plain(x):\n    return x * (x - 1)\n\n@numba.jit\ndef integrate_f_numba(a, b, N):\n    s = 0\n    dx = (b - a) / N\n    for i in range(N):\n        s += f_plain(a + i * dx)\n    return s * dx\n\n@numba.jit\ndef apply_integrate_f_numba(col_a, col_b, col_N):\n    n = len(col_N)\n    result = np.empty(n, dtype=\"float64\")\n    assert len(col_a) == len(col_b) == n\n    for i in range(n):\n        result[i] = integrate_f_numba(col_a[i], col_b[i], col_N[i])\n    return result\n\ndef compute_numba(df):\n    result = apply_integrate_f_numba(\n        df[\"a\"].to_numpy(), df[\"b\"].to_numpy(), df[\"N\"].to_numpy()\n    )\n    return pd.Series(result, index=df.index, name=\"result\") \n```", "```py\nIn [4]: %timeit compute_numba(df)\n1000 loops, best of 3: 798 us per loop \n```", "```py\nimport numba\n\ndef double_every_value_nonumba(x):\n    return x * 2\n\n@numba.vectorize\ndef double_every_value_withnumba(x):  # noqa E501\n    return x * 2 \n```", "```py\n# Custom function without numba\nIn [5]: %timeit df[\"col1_doubled\"] = df[\"a\"].apply(double_every_value_nonumba)  # noqa E501\n1000 loops, best of 3: 797 us per loop\n\n# Standard implementation (faster than a custom function)\nIn [6]: %timeit df[\"col1_doubled\"] = df[\"a\"] * 2\n1000 loops, best of 3: 233 us per loop\n\n# Custom function with numba\nIn [7]: %timeit df[\"col1_doubled\"] = double_every_value_withnumba(df[\"a\"].to_numpy())\n1000 loops, best of 3: 145 us per loop \n```", "```py\nIn [18]: df = pd.DataFrame(np.random.randn(5, 2), columns=list(\"ab\"))\n\nIn [19]: newcol = np.random.randn(len(df))\n\nIn [20]: df.eval(\"b + @newcol\")\nOut[20]: \n0   -0.206122\n1   -1.029587\n2    0.519726\n3   -2.052589\n4    1.453210\ndtype: float64\n\nIn [21]: df.query(\"b < @newcol\")\nOut[21]: \n a         b\n1  0.160268 -0.848896\n3  0.333758 -1.180355\n4  0.572182  0.439895 \n```", "```py\nIn [22]: a = np.random.randn()\n\nIn [23]: df.query(\"@a < a\")\nOut[23]: \n a         b\n0  0.473349  0.891236\n1  0.160268 -0.848896\n2  0.803311  1.662031\n3  0.333758 -1.180355\n4  0.572182  0.439895\n\nIn [24]: df.loc[a < df[\"a\"]]  # same as the previous expression\nOut[24]: \n a         b\n0  0.473349  0.891236\n1  0.160268 -0.848896\n2  0.803311  1.662031\n3  0.333758 -1.180355\n4  0.572182  0.439895 \n```", "```py\nIn [25]: a, b = 1, 2\n\nIn [26]: pd.eval(\"@a + b\")\nTraceback (most recent call last):\n\n File ~/micromamba/envs/test/lib/python3.10/site-packages/IPython/core/interactiveshell.py:3577 in run_code\n exec(code_obj, self.user_global_ns, self.user_ns)\n\n Cell In[26], line 1\n pd.eval(\"@a + b\")\n\n File ~/work/pandas/pandas/pandas/core/computation/eval.py:325 in eval\n _check_for_locals(expr, level, parser)\n\n File ~/work/pandas/pandas/pandas/core/computation/eval.py:167 in _check_for_locals\n raise SyntaxError(msg)\n\n File <string>\nSyntaxError: The '@' prefix is not allowed in top-level eval calls.\nplease refer to your variables by name without the '@' prefix. \n```", "```py\nIn [27]: pd.eval(\"a + b\")\nOut[27]: 3 \n```", "```py\nIn [28]: nrows, ncols = 20000, 100\n\nIn [29]: df1, df2, df3, df4 = [pd.DataFrame(np.random.randn(nrows, ncols)) for _ in range(4)]\n\nIn [30]: expr = \"(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\"\n\nIn [31]: x = pd.eval(expr, parser=\"python\")\n\nIn [32]: expr_no_parens = \"df1 > 0 & df2 > 0 & df3 > 0 & df4 > 0\"\n\nIn [33]: y = pd.eval(expr_no_parens, parser=\"pandas\")\n\nIn [34]: np.all(x == y)\nOut[34]: True \n```", "```py\nIn [35]: expr = \"(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\"\n\nIn [36]: x = pd.eval(expr, parser=\"python\")\n\nIn [37]: expr_with_ands = \"df1 > 0 and df2 > 0 and df3 > 0 and df4 > 0\"\n\nIn [38]: y = pd.eval(expr_with_ands, parser=\"pandas\")\n\nIn [39]: np.all(x == y)\nOut[39]: True \n```", "```py\nIn [40]: %timeit df1 + df2 + df3 + df4\n7.42 ms +- 81.8 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [41]: %timeit pd.eval(\"df1 + df2 + df3 + df4\", engine=\"python\")\n8.11 ms +- 161 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [42]: df = pd.DataFrame(np.random.randn(5, 2), columns=[\"a\", \"b\"])\n\nIn [43]: df.eval(\"a + b\")\nOut[43]: \n0   -0.161099\n1    0.805452\n2    0.747447\n3    1.189042\n4   -2.057490\ndtype: float64 \n```", "```py\nIn [44]: df = pd.DataFrame(dict(a=range(5), b=range(5, 10)))\n\nIn [45]: df = df.eval(\"c = a + b\")\n\nIn [46]: df = df.eval(\"d = a + b + c\")\n\nIn [47]: df = df.eval(\"a = 1\")\n\nIn [48]: df\nOut[48]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26 \n```", "```py\nIn [49]: df\nOut[49]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26\n\nIn [50]: df.eval(\"e = a - c\")\nOut[50]: \n a  b   c   d   e\n0  1  5   5  10  -4\n1  1  6   7  14  -6\n2  1  7   9  18  -8\n3  1  8  11  22 -10\n4  1  9  13  26 -12\n\nIn [51]: df\nOut[51]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26 \n```", "```py\nIn [52]: df.eval(\n ....: \"\"\"\n ....: c = a + b\n ....: d = a + b + c\n ....: a = 1\"\"\",\n ....: )\n ....: \nOut[52]: \n a  b   c   d\n0  1  5   6  12\n1  1  6   7  14\n2  1  7   8  16\n3  1  8   9  18\n4  1  9  10  20 \n```", "```py\nIn [53]: df = pd.DataFrame(dict(a=range(5), b=range(5, 10)))\n\nIn [54]: df[\"c\"] = df[\"a\"] + df[\"b\"]\n\nIn [55]: df[\"d\"] = df[\"a\"] + df[\"b\"] + df[\"c\"]\n\nIn [56]: df[\"a\"] = 1\n\nIn [57]: df\nOut[57]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26 \n```", "```py\nIn [58]: nrows, ncols = 20000, 100\n\nIn [59]: df1, df2, df3, df4 = [pd.DataFrame(np.random.randn(nrows, ncols)) for _ in range(4)] \n```", "```py\nIn [60]: %timeit df1 + df2 + df3 + df4\n7.34 ms +- 117 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [61]: %timeit pd.eval(\"df1 + df2 + df3 + df4\")\n2.85 ms +- 58.8 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [62]: %timeit (df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\n5.98 ms +- 37 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [63]: %timeit pd.eval(\"(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\")\n9.38 ms +- 36.7 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [64]: s = pd.Series(np.random.randn(50))\n\nIn [65]: %timeit df1 + df2 + df3 + df4 + s\n12.6 ms +- 105 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [66]: %timeit pd.eval(\"df1 + df2 + df3 + df4 + s\")\n3.69 ms +- 62 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\n1 and 2  # would parse to 1 & 2, but should evaluate to 2\n3 or 4  # would parse to 3 | 4, but should evaluate to 3\n~1  # this is okay, but slower when using eval \n```", "```py\nIn [67]: df = pd.DataFrame(\n ....:    {\"strings\": np.repeat(list(\"cba\"), 3), \"nums\": np.repeat(range(3), 3)}\n ....: )\n ....: \n\nIn [68]: df\nOut[68]: \n strings  nums\n0       c     0\n1       c     0\n2       c     0\n3       b     1\n4       b     1\n5       b     1\n6       a     2\n7       a     2\n8       a     2\n\nIn [69]: df.query(\"strings == 'a' and nums == 1\")\nOut[69]: \nEmpty DataFrame\nColumns: [strings, nums]\nIndex: [] \n```", "```py\nIn [18]: df = pd.DataFrame(np.random.randn(5, 2), columns=list(\"ab\"))\n\nIn [19]: newcol = np.random.randn(len(df))\n\nIn [20]: df.eval(\"b + @newcol\")\nOut[20]: \n0   -0.206122\n1   -1.029587\n2    0.519726\n3   -2.052589\n4    1.453210\ndtype: float64\n\nIn [21]: df.query(\"b < @newcol\")\nOut[21]: \n a         b\n1  0.160268 -0.848896\n3  0.333758 -1.180355\n4  0.572182  0.439895 \n```", "```py\nIn [22]: a = np.random.randn()\n\nIn [23]: df.query(\"@a < a\")\nOut[23]: \n a         b\n0  0.473349  0.891236\n1  0.160268 -0.848896\n2  0.803311  1.662031\n3  0.333758 -1.180355\n4  0.572182  0.439895\n\nIn [24]: df.loc[a < df[\"a\"]]  # same as the previous expression\nOut[24]: \n a         b\n0  0.473349  0.891236\n1  0.160268 -0.848896\n2  0.803311  1.662031\n3  0.333758 -1.180355\n4  0.572182  0.439895 \n```", "```py\nIn [25]: a, b = 1, 2\n\nIn [26]: pd.eval(\"@a + b\")\nTraceback (most recent call last):\n\n File ~/micromamba/envs/test/lib/python3.10/site-packages/IPython/core/interactiveshell.py:3577 in run_code\n exec(code_obj, self.user_global_ns, self.user_ns)\n\n Cell In[26], line 1\n pd.eval(\"@a + b\")\n\n File ~/work/pandas/pandas/pandas/core/computation/eval.py:325 in eval\n _check_for_locals(expr, level, parser)\n\n File ~/work/pandas/pandas/pandas/core/computation/eval.py:167 in _check_for_locals\n raise SyntaxError(msg)\n\n File <string>\nSyntaxError: The '@' prefix is not allowed in top-level eval calls.\nplease refer to your variables by name without the '@' prefix. \n```", "```py\nIn [27]: pd.eval(\"a + b\")\nOut[27]: 3 \n```", "```py\nIn [28]: nrows, ncols = 20000, 100\n\nIn [29]: df1, df2, df3, df4 = [pd.DataFrame(np.random.randn(nrows, ncols)) for _ in range(4)]\n\nIn [30]: expr = \"(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\"\n\nIn [31]: x = pd.eval(expr, parser=\"python\")\n\nIn [32]: expr_no_parens = \"df1 > 0 & df2 > 0 & df3 > 0 & df4 > 0\"\n\nIn [33]: y = pd.eval(expr_no_parens, parser=\"pandas\")\n\nIn [34]: np.all(x == y)\nOut[34]: True \n```", "```py\nIn [35]: expr = \"(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\"\n\nIn [36]: x = pd.eval(expr, parser=\"python\")\n\nIn [37]: expr_with_ands = \"df1 > 0 and df2 > 0 and df3 > 0 and df4 > 0\"\n\nIn [38]: y = pd.eval(expr_with_ands, parser=\"pandas\")\n\nIn [39]: np.all(x == y)\nOut[39]: True \n```", "```py\nIn [40]: %timeit df1 + df2 + df3 + df4\n7.42 ms +- 81.8 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [41]: %timeit pd.eval(\"df1 + df2 + df3 + df4\", engine=\"python\")\n8.11 ms +- 161 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [42]: df = pd.DataFrame(np.random.randn(5, 2), columns=[\"a\", \"b\"])\n\nIn [43]: df.eval(\"a + b\")\nOut[43]: \n0   -0.161099\n1    0.805452\n2    0.747447\n3    1.189042\n4   -2.057490\ndtype: float64 \n```", "```py\nIn [44]: df = pd.DataFrame(dict(a=range(5), b=range(5, 10)))\n\nIn [45]: df = df.eval(\"c = a + b\")\n\nIn [46]: df = df.eval(\"d = a + b + c\")\n\nIn [47]: df = df.eval(\"a = 1\")\n\nIn [48]: df\nOut[48]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26 \n```", "```py\nIn [49]: df\nOut[49]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26\n\nIn [50]: df.eval(\"e = a - c\")\nOut[50]: \n a  b   c   d   e\n0  1  5   5  10  -4\n1  1  6   7  14  -6\n2  1  7   9  18  -8\n3  1  8  11  22 -10\n4  1  9  13  26 -12\n\nIn [51]: df\nOut[51]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26 \n```", "```py\nIn [52]: df.eval(\n ....: \"\"\"\n ....: c = a + b\n ....: d = a + b + c\n ....: a = 1\"\"\",\n ....: )\n ....: \nOut[52]: \n a  b   c   d\n0  1  5   6  12\n1  1  6   7  14\n2  1  7   8  16\n3  1  8   9  18\n4  1  9  10  20 \n```", "```py\nIn [53]: df = pd.DataFrame(dict(a=range(5), b=range(5, 10)))\n\nIn [54]: df[\"c\"] = df[\"a\"] + df[\"b\"]\n\nIn [55]: df[\"d\"] = df[\"a\"] + df[\"b\"] + df[\"c\"]\n\nIn [56]: df[\"a\"] = 1\n\nIn [57]: df\nOut[57]: \n a  b   c   d\n0  1  5   5  10\n1  1  6   7  14\n2  1  7   9  18\n3  1  8  11  22\n4  1  9  13  26 \n```", "```py\nIn [58]: nrows, ncols = 20000, 100\n\nIn [59]: df1, df2, df3, df4 = [pd.DataFrame(np.random.randn(nrows, ncols)) for _ in range(4)] \n```", "```py\nIn [60]: %timeit df1 + df2 + df3 + df4\n7.34 ms +- 117 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [61]: %timeit pd.eval(\"df1 + df2 + df3 + df4\")\n2.85 ms +- 58.8 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [62]: %timeit (df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\n5.98 ms +- 37 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [63]: %timeit pd.eval(\"(df1 > 0) & (df2 > 0) & (df3 > 0) & (df4 > 0)\")\n9.38 ms +- 36.7 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [64]: s = pd.Series(np.random.randn(50))\n\nIn [65]: %timeit df1 + df2 + df3 + df4 + s\n12.6 ms +- 105 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\nIn [66]: %timeit pd.eval(\"df1 + df2 + df3 + df4 + s\")\n3.69 ms +- 62 us per loop (mean +- std. dev. of 7 runs, 100 loops each) \n```", "```py\n1 and 2  # would parse to 1 & 2, but should evaluate to 2\n3 or 4  # would parse to 3 | 4, but should evaluate to 3\n~1  # this is okay, but slower when using eval \n```", "```py\nIn [67]: df = pd.DataFrame(\n ....:    {\"strings\": np.repeat(list(\"cba\"), 3), \"nums\": np.repeat(range(3), 3)}\n ....: )\n ....: \n\nIn [68]: df\nOut[68]: \n strings  nums\n0       c     0\n1       c     0\n2       c     0\n3       b     1\n4       b     1\n5       b     1\n6       a     2\n7       a     2\n8       a     2\n\nIn [69]: df.query(\"strings == 'a' and nums == 1\")\nOut[69]: \nEmpty DataFrame\nColumns: [strings, nums]\nIndex: [] \n```"]