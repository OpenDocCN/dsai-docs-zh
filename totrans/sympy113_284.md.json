["```py\n>>> from sympy import Symbol, Poly\n>>> x = Symbol('x')\n>>> Poly(x**2 + x)\nPoly(x**2 + x, x, domain='ZZ')\n>>> Poly(x**2 + x/2)\nPoly(x**2 + 1/2*x, x, domain='QQ') \n```", "```py\n>>> p = Poly(x**2 + x/2)\n>>> p\nPoly(x**2 + 1/2*x, x, domain='QQ')\n>>> p.domain\nQQ\n>>> p.rep  \nDMP_Python([1, 1/2, 0], QQ)\n>>> p.rep.rep  \n[1, 1/2, 0]\n>>> type(p.rep.rep[0])  \n<class 'sympy.external.pythonmpq.PythonMPQ'> \n```", "```py\n>>> from sympy import Symbol, srepr\n>>> x = Symbol('x')\n>>> e = 1 + 1/(2 + x**2)\n>>> e\n1 + 1/(x**2 + 2)\n>>> print(srepr(e))\nAdd(Integer(1), Pow(Add(Pow(Symbol('x'), Integer(2)), Integer(2)), Integer(-1))) \n```", "```py\n>>> e = x*(x + 1)\n>>> e\nx*(x + 1)\n>>> e.expand()\nx**2 + x \n```", "```py\n>>> print(srepr(e))\nMul(Symbol('x'), Add(Symbol('x'), Integer(1)))\n>>> print(srepr(e.expand()))\nAdd(Pow(Symbol('x'), Integer(2)), Symbol('x')) \n```", "```py\n>>> p = Poly(x**4 + x + 1)\n>>> p.rep.rep  \n[1, 0, 0, 1, 1] \n```", "```py\n>>> from sympy import factor\n>>> e = 2*x**3 + 10*x**2 + 16*x + 8\n>>> e\n2*x**3 + 10*x**2 + 16*x + 8\n>>> factor(e)\n2*(x + 1)*(x + 2)**2 \n```", "```py\n>>> from sympy import ZZ\n>>> from sympy.polys.factortools import dup_factor_list\n>>> p = [ZZ(2), ZZ(10), ZZ(16), ZZ(8)]\n>>> p\n[2, 10, 16, 8]\n>>> dup_factor_list(p, ZZ)\n(2, [([1, 1], 1), ([1, 2], 2)]) \n```", "```py\n>>> from sympy import symbols\n>>> x, y = symbols('x, y')\n>>> p = Poly(x**2*y + x**2 + x*y + y + 1)\n>>> p\nPoly(x**2*y + x**2 + x*y + y + 1, x, y, domain='ZZ')\n>>> p.rep.rep  \n[[1, 1], [1, 0], [1, 1]] \n```", "```py\n>>> Poly(7*x**20 + 8*x + 9).rep.rep  \n[7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8, 9]\n>>> Poly(7*x**20 + 8*x + 9).as_dict()\n{(0,): 9, (1,): 8, (20,): 7} \n```", "```py\n>>> from sympy import prod\n>>> gens = symbols('x:10')\n>>> gens\n(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)\n>>> p = Poly(prod(gens))\n>>> p\nPoly(x0*x1*x2*x3*x4*x5*x6*x7*x8*x9, x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, domain='ZZ')\n>>> p.rep.rep  \n[[[[[[[[[[1, 0], []], [[]]], [[[]]]], [[[[]]]]], [[[[[]]]]]], [[[[[[]]]]]]], [[[[[[[]]]]]]]], [[[[[[[[]]]]]]]]], [[[[[[[[[]]]]]]]]]]\n>>> p.as_dict()\n{(1, 1, 1, 1, 1, 1, 1, 1, 1, 1): 1} \n```", "```py\n>>> from sympy import ZZ\n>>> z1 = ZZ(2)\n>>> z1\n2\n>>> z1 + z1\n4\n>>> type(z1)  \n<class 'int'>\n>>> z1 in ZZ\nTrue \n```", "```py\n>>> z1 / z1  \n1.0\n>>> type(z1 / z1)  \n<class 'float'>\n>>> ZZ.is_Field\nFalse \n```", "```py\n>>> z1 / z1  \nTraceback (most recent call last):\n...\nTypeError: unsupported operand type(s) for /: 'flint._flint.fmpz' and 'flint._flint.fmpz' \n```", "```py\n>>> z1 // z1\n1\n>>> z1 % z1\n0 \n```", "```py\n>>> from sympy import QQ\n>>> q1 = QQ(1, 2)\n>>> q1\n1/2\n>>> q2 = QQ(2, 3)\n>>> q2\n2/3\n>>> q1 / q2\n3/4\n>>> type(q1)  \n<class 'sympy.external.pythonmpq.PythonMPQ'> \n```", "```py\n>>> ZZ.quo(ZZ(5), ZZ(3))  # 5 // 3\n1\n>>> ZZ.rem(ZZ(5), ZZ(3))  # 5 % 3\n2\n>>> ZZ.div(ZZ(5), ZZ(3))  # divmod(5, 3)\n(1, 2)\n>>> QQ.div(QQ(5), QQ(3))\n(5/3, 0) \n```", "```py\n>>> QQ.exquo(QQ(5), QQ(3))\n5/3\n>>> ZZ.exquo(ZZ(4), ZZ(2))\n2\n>>> ZZ.exquo(ZZ(5), ZZ(3))\nTraceback (most recent call last):\n...\nExactQuotientFailed: 3 does not divide 5 in ZZ \n```", "```py\n>>> from sympy import ZZ, QQ\n>>> ZZ(2)  \nmpz(2)\n>>> QQ(2, 3)  \nmpq(2, 3) \n```", "```py\n>>> z = ZZ(2)\n>>> type(z)  \n<class 'int'>\n>>> ZZ.dtype  \n<class 'int'>\n>>> ZZ.of_type(z)\nTrue \n```", "```py\n>>> from sympy import sympify\n>>> z1_sympy = sympify(2)  # Normal sympy object\n>>> z1_sympy\n2\n>>> type(z1_sympy)\n<class 'sympy.core.numbers.Integer'>\n>>> from sympy import Expr\n>>> isinstance(z1_sympy, Expr)\nTrue \n```", "```py\n>>> z_sympy = sympify(2)\n>>> z_zz = ZZ.from_sympy(z_sympy)\n>>> z_zz\n2\n>>> type(z_sympy)\n<class 'sympy.core.numbers.Integer'>\n>>> type(z_zz)  \n<class 'int'>\n>>> ZZ.to_sympy(z_zz)\n2\n>>> type(ZZ.to_sympy(z_zz))\n<class 'sympy.core.numbers.Integer'> \n```", "```py\n>>> from sympy import sqrt\n>>> e = sqrt(2)\n>>> e\nsqrt(2)\n>>> ZZ.from_sympy(e)\nTraceback (most recent call last):\n...\nCoercionFailed: expected an integer, got sqrt(2) \n```", "```py\n>>> ZZ.one\n1\n>>> ZZ.zero\n0\n>>> sum([ZZ(1), ZZ(2)])  # don't do this (even it sometimes works)\n3\n>>> sum([ZZ(1), ZZ(2)], ZZ.zero) # provide the zero from the domain\n3 \n```", "```py\ndef sum_domain(expressions_sympy):\n  \"\"\"Sum sympy expressions but performing calculations in domain ZZ\"\"\"\n\n    # Convert to domain\n    expressions_dom = [ZZ.from_sympy(e) for e in expressions_sympy]\n\n    # Perform calculations in the domain\n    result_dom = ZZ.zero\n    for e_dom in expressions_dom:\n        result_dom += e_dom\n\n    # Convert the result back to Expr\n    result_sympy = ZZ.to_sympy(result_dom)\n    return result_sympy \n```", "```py\n>>> from sympy import ZZ_I, QQ_I, I\n>>> z = ZZ_I.from_sympy(1 + 2*I)\n>>> z\n(1 + 2*I)\n>>> z**2\n(-3 + 4*I) \n```", "```py\n>>> from sympy import expand, I\n>>> z = 1 + 2*I\n>>> z**2\n(1 + 2*I)**2\n>>> expand(z**2)\n-3 + 4*I \n```", "```py\n>>> ZZ.is_Field\nFalse\n>>> QQ.is_Field\nTrue\n>>> ZZ_I.is_Field\nFalse\n>>> QQ_I.is_Field\nTrue \n```", "```py\n>>> e1 = QQ_I.from_sympy(1+I)\n>>> e2 = QQ_I.from_sympy(2-I/2)\n>>> e1/e2\n(6/17 + 10/17*I)\n>>> ZZ_I.gcd(ZZ_I(5), ZZ_I.from_sympy(1+2*I))\n(1 + 2*I) \n```", "```py\n>>> from sympy import GF\n>>> K = GF(5)\n>>> two = K(2)\n>>> two \n2 mod 5\n>>> two ** 2A \n4 mod 5\n>>> two ** 3 \n3 mod 5 \n```", "```py\n>>> K = GF(6)\n>>> K(3) * K(2) \n0 mod 6 \n```", "```py\n>>> from sympy import RR, CC\n>>> xr = RR(3)\n>>> xr\n3.0\n>>> xr._mpf_\n(0, 3, 0, 2)\n>>> zc = CC(3+1j)\n>>> zc\n(3.0 + 1.0j)\n>>> zc._mpc_\n((0, 3, 0, 2), (0, 1, 0, 1)) \n```", "```py\n>>> RR('0.1') + RR('0.2') == RR('0.3')\nFalse \n```", "```py\n>>> from sympy.polys.domains.realfield import RealField\n>>> RR.precision\n53\n>>> RR.dps\n15\n>>> RR(1) / RR(3)\n0.333333333333333\n>>> RR100 = RealField(100)\n>>> RR100.precision\n100\n>>> RR100.dps\n29\n>>> RR100(1) / RR100(3)\n0.33333333333333333333333333333 \n```", "```py\n>>> RR(1) / RR(3)  # wrong result!\n0.33333333333333333333333333333\n>>> dummy = RealField(53)  # hack to restore precision\n>>> RR(1) / RR(3)  # restored\n0.333333333333333 \n```", "```py\n>>> K = QQ.algebraic_field(sqrt(2))\n>>> K\nQQ<sqrt(2)>\n>>> b = K.one + K.from_sympy(sqrt(2))\n>>> b  \nANP([1, 1], [1, 0, -2], QQ)\n>>> K.to_sympy(b)\n1 + sqrt(2)\n>>> b ** 2  \nANP([2, 3], [1, 0, -2], QQ)\n>>> K.to_sympy(b**2)\n2*sqrt(2) + 3 \n```", "```py\n>>> from sympy import minpoly, Symbol\n>>> x = Symbol('x')\n>>> minpoly(sqrt(2), x)\nx**2 - 2 \n```", "```py\n>>> K = QQ.algebraic_field(sqrt(2), sqrt(3))\n>>> K\nQQ<sqrt(2) + sqrt(3)>\n>>> sqrt2 = K.from_sympy(sqrt(2))\n>>> sqrt3 = K.from_sympy(sqrt(3))\n>>> p = (K.one + sqrt2) * (K.one + sqrt3)\n>>> p  \nANP([1/2, 1, -3/2], [1, 0, -10, 0, 1], QQ)\n>>> K.to_sympy(p)\n1 + sqrt(2) + sqrt(3) + sqrt(6)\n>>> K.to_sympy(p**2)\n4*sqrt(6) + 6*sqrt(3) + 8*sqrt(2) + 12 \n```", "```py\n>>> from sympy import primitive_element, minpoly\n>>> e = primitive_element([sqrt(2), sqrt(3)], x)\n>>> e[0]\nx**4 - 10*x**2 + 1\n>>> e[0].subs(x, sqrt(2) + sqrt(3)).expand()\n0 \n```", "```py\n>>> from sympy import ZZ, symbols\n>>> x = symbols('x')\n>>> K = ZZ[x]\n>>> K\nZZ[x]\n>>> x_dom = K(x)\n>>> x_dom + K.one\nx + 1 \n```", "```py\n>>> p = x_dom + K.one\n>>> p\nx + 1\n>>> p + p\n2*x + 2\n>>> p - p\n0\n>>> p * p\nx**2 + 2*x + 1\n>>> p ** 3\nx**3 + 3*x**2 + 3*x + 1\n>>> K.exquo(x_dom**2 - K.one, x_dom - K.one)\nx + 1 \n```", "```py\n>>> from sympy import srepr\n>>> K = ZZ[x]\n>>> p_expr = x**2 + 2*x + 1\n>>> p_expr\nx**2 + 2*x + 1\n>>> srepr(p_expr)\n\"Add(Pow(Symbol('x'), Integer(2)), Mul(Integer(2), Symbol('x')), Integer(1))\" \n```", "```py\n>>> x = symbols('x')\n>>> p_expr = x*(x + 1) + x\n>>> p_expr\nx*(x + 1) + x\n>>> p_expr.expand()\nx**2 + 2*x \n```", "```py\n>>> x = symbols('x')\n>>> K = ZZ[x]\n>>> x_dom = K(x)\n>>> p_dom = K(3)*x_dom**2 + K(2)*x_dom + K(7)\n>>> p_dom\n3*x**2 + 2*x + 7\n>>> dict(p_dom)\n{(0,): 7, (1,): 2, (2,): 3} \n```", "```py\n>>> x = symbols('x')\n>>> K = ZZ[x]\n>>> x_dom = K(x)\n>>> p_expr = x * (x + 1) + x\n>>> p_expr\nx*(x + 1) + x\n>>> p_dom = x_dom * (x_dom + K.one) + x_dom\n>>> p_dom\nx**2 + 2*x \n```", "```py\n>>> (x + 1) ** 2\n(x + 1)**2\n>>> (x_dom + K.one) ** 2\nx**2 + 2*x + 1 \n```", "```py\n>>> x, y = symbols('x, y')\n>>> K = ZZ[x,y]\n>>> xk = K(x)\n>>> yk = K(y)\n>>> xk**2*yk + xk + yk\nx**2*y + x + y \n```", "```py\n>>> K = ZZ[x][y]\n>>> p = K(x**2 + x*y + y**2)\n>>> p\ny**2 + x*y + x**2\n>>> dict(p)\n{(0,): x**2, (1,): x, (2,): 1} \n```", "```py\n>>> {k: dict(v) for k, v in p.items()}\n{(0,): {(2,): 1}, (1,): {(1,): 1}, (2,): {(0,): 1}} \n```", "```py\n>>> K = ZZ[x,y]\n>>> p = K(x**2 + x*y + y**2)\n>>> p\nx**2 + x*y + y**2\n>>> dict(p)\n{(0, 2): 1, (1, 1): 1, (2, 0): 1} \n```", "```py\n>>> K1 = ZZ.poly_ring(x)\n>>> K2 = ZZ.old_poly_ring(x)\n>>> K1\nZZ[x]\n>>> K2\nZZ[x]\n>>> K1 == ZZ[x]\nTrue\n>>> K2 == ZZ[x]\nFalse\n>>> p1 = K1.from_sympy(x**2 + 1)\n>>> p2 = K2.from_sympy(x**2 + 1)\n>>> p1\nx**2 + 1\n>>> p2  \nDMP_Python([1, 0, 1], ZZ)\n>>> type(K1)\n<class 'sympy.polys.domains.polynomialring.PolynomialRing'>\n>>> type(p1)\n<class 'sympy.polys.rings.PolyElement'>\n>>> type(K2)\n<class 'sympy.polys.domains.old_polynomialring.GlobalPolynomialRing'>\n>>> type(p2)  \n<class 'sympy.polys.polyclasses.DMP_Python'> \n```", "```py\n>>> repr(p2)  \n'DMP_Python([1, 0, 1], ZZ, ZZ[x])' \n```", "```py\n>>> from sympy import ring\n>>> K, xr, yr = ring([x, y], ZZ)\n>>> K\nPolynomial ring in x, y over ZZ with lex order\n>>> xr**2 - yr**2\nx**2 - y**2\n>>> (xr**2 - yr**2) // (xr - yr)\nx + y \n```", "```py\n>>> K, xr, yr = ring([x, y], ZZ)\n>>> K\nPolynomial ring in x, y over ZZ with lex order\n>>> K2 = ZZ[x,y]\n>>> K2\nZZ[x,y]\n>>> K2.ring\nPolynomial ring in x, y over ZZ with lex order\n>>> K2.ring == K\nTrue\n>>> K(x+y)\nx + y\n>>> K2(x+y)\nx + y\n>>> type(K(x+y))\n<class 'sympy.polys.rings.PolyElement'>\n>>> type(K2(x+y))\n<class 'sympy.polys.rings.PolyElement'>\n>>> K(x+y) == K2(x+y)\nTrue \n```", "```py\n>>> from sympy import ZZ, QQ, symbols\n>>> x, y = symbols('x, y')\n>>> ZZ.is_Field\nFalse\n>>> QQ.is_Field\nTrue\n>>> QQ[x]\nQQ[x]\n>>> QQ[x].is_Field\nFalse\n>>> QQ[x].get_field()\nQQ(x)\n>>> QQ[x].get_field().is_Field\nTrue\n>>> QQ.frac_field(x)\nQQ(x) \n```", "```py\n>>> K = QQ.frac_field(x)\n>>> xk = K(x)\n>>> f = xk / (K.one + xk**2)\n>>> f\nx/(x**2 + 1)\n>>> f.numer\nx\n>>> f.denom\nx**2 + 1\n>>> QQ[x].of_type(f.numer)\nTrue\n>>> QQ[x].of_type(f.denom)\nTrue \n```", "```py\n>>> p1 = xk**2 - 1\n>>> p2 = xk - 1\n>>> p1\nx**2 - 1\n>>> p2\nx - 1\n>>> p1 / p2\nx + 1 \n```", "```py\n>>> K1 = QQ.frac_field(x)\n>>> K2 = QQ.old_frac_field(x)\n>>> K1\nQQ(x)\n>>> K2\nQQ(x)\n>>> type(K1)\n<class 'sympy.polys.domains.fractionfield.FractionField'>\n>>> type(K2)\n<class 'sympy.polys.domains.old_fractionfield.FractionField'> \n```", "```py\n>>> from sympy import field\n>>> K, xf, yf = field([x, y], ZZ)\n>>> xf / (1 - yf)\n-x/(y - 1) \n```", "```py\n>>> from sympy import EX\n>>> p = EX.from_sympy(1 + x)\n>>> p\nEX(x + 1)\n>>> type(p)\n<class 'sympy.polys.domains.expressiondomain.ExpressionDomain.Expression'>\n>>> p.ex\nx + 1\n>>> type(p.ex)\n<class 'sympy.core.add.Add'> \n```", "```py\n>>> from sympy import construct_domain, Integer\n>>> elements_sympy = [Integer(3), Integer(2)]  # elements as Expr instances\n>>> elements_sympy\n[3, 2]\n>>> K, elements_K = construct_domain(elements_sympy)\n>>> K\nZZ\n>>> elements_K\n[3, 2]\n>>> type(elements_sympy[0])\n<class 'sympy.core.numbers.Integer'>\n>>> type(elements_K[0])  \n<class 'int'> \n```", "```py\n>>> from sympy import Rational, symbols\n>>> x, y = symbols('x, y')\n>>> construct_domain([Rational(1, 2), Integer(3)])[0]\nQQ\n>>> construct_domain([2*x, 3])[0]\nZZ[x]\n>>> construct_domain([x/2, 3])[0]\nQQ[x]\n>>> construct_domain([2/x, 3])[0]\nZZ(x)\n>>> construct_domain([x, y])[0]\nZZ[x,y] \n```", "```py\n>>> construct_domain([1, 2], field=True)[0]\nQQ\n>>> construct_domain([2*x, 3], field=True)[0]\nZZ(x)\n>>> construct_domain([x/2, 3], field=True)[0]\nZZ(x)\n>>> construct_domain([2/x, 3], field=True)[0]\nZZ(x)\n>>> construct_domain([x, y], field=True)[0]\nZZ(x,y) \n```", "```py\n>>> from sympy import sqrt\n>>> construct_domain([sqrt(2)])[0]\nEX\n>>> construct_domain([sqrt(2)], extension=True)[0]\nQQ<sqrt(2)>\n>>> construct_domain([sqrt(2), sqrt(3)], extension=True)[0]\nQQ<sqrt(2) + sqrt(3)> \n```", "```py\n>>> from sympy import sin, cos\n>>> construct_domain([sin(x), y])[0]\nZZ[y,sin(x)] \n```", "```py\n>>> construct_domain([sin(x), cos(x)])[0]\nEX \n```", "```py\n>>> num_zz = ZZ(3)\n>>> ZZ.of_type(num_zz)\nTrue\n>>> num_qq = QQ.convert_from(num_zz, ZZ)\n>>> ZZ.of_type(num_qq)\nFalse\n>>> QQ.of_type(num_qq)\nTrue \n```", "```py\n>>> QQ.convert(ZZ(2))\n2 \n```", "```py\n>>> from sympy import ZZ, Symbol\n>>> x = Symbol('x')\n>>> K = ZZ[x]\n>>> K\nZZ[x]\n>>> p = K(x) + K.one\n>>> p\nx + 1\n>>> type(p)\n<class 'sympy.polys.rings.PolyElement'>\n>>> p.parent()\nZZ[x]\n>>> p.parent() == K\nTrue \n```", "```py\n>>> QQ.convert_from(ZZ(2), ZZ)\n2 \n```", "```py\n>>> x1, K1 = ZZ(2), ZZ\n>>> y2, K2 = QQ(3, 2), QQ\n>>> K1\nZZ\n>>> K2\nQQ\n>>> K3 = K1.unify(K2)\n>>> K3\nQQ\n>>> x3 = K3.convert_from(x1, K1)\n>>> y3 = K3.convert_from(y2, K2)\n>>> x3 + y3\n7/2 \n```", "```py\n>>> ZZ[x].unify(ZZ[y])\nZZ[x,y]\n>>> ZZ[x,y].unify(ZZ[y])\nZZ[x,y]\n>>> ZZ[x].unify(QQ)\nQQ[x] \n```", "```py\n>>> K1 = QQ.algebraic_field(sqrt(2))[x]\n>>> K2 = QQ.algebraic_field(sqrt(3))[y]\n>>> K1\nQQ<sqrt(2)>[x]\n>>> K2\nQQ<sqrt(3)>[y]\n>>> K1.unify(K2)\nQQ<sqrt(2) + sqrt(3)>[x,y]\n>>> QQ.frac_field(x).unify(ZZ[y])\nZZ(x,y) \n```", "```py\n>>> from sympy import Poly, symbols, ZZ\n>>> x, y, z, t = symbols('x, y, z, t')\n>>> p = Poly(x**2 + 1, x, domain=ZZ)\n>>> p\nPoly(x**2 + 1, x, domain='ZZ')\n>>> p.gens\n(x,)\n>>> p.domain\nZZ\n>>> p.all_coeffs()\n[1, 0, 1]\n>>> p.as_expr()\nx**2 + 1 \n```", "```py\n>>> d = p.rep  # internal representation of Poly\n>>> d  \nDMP_Python([1, 0, 1], ZZ)\n>>> d.rep      # internal representation of DMP \n[1, 0, 1]\n>>> type(d.rep)  \n<class 'list'>\n>>> type(d.rep[0])  \n<class 'int'>\n>>> d.dom\nZZ \n```", "```py\n>>> from sympy import sqrt\n>>> Poly(x**2 + 1, x)\nPoly(x**2 + 1, x, domain='ZZ')\n>>> Poly(x**2 + 1, x, field=True)\nPoly(x**2 + 1, x, domain='QQ')\n>>> Poly(x**2/2 + 1, x)\nPoly(1/2*x**2 + 1, x, domain='QQ')\n>>> Poly(x**2 + sqrt(2), x)\nPoly(x**2 + sqrt(2), x, domain='EX')\n>>> Poly(x**2 + sqrt(2), x, extension=True)\nPoly(x**2 + sqrt(2), x, domain='QQ<sqrt(2)>') \n```", "```py\n>>> from sympy import construct_domain\n>>> Poly(x**2 + 1, x)\nPoly(x**2 + 1, x, domain='ZZ')\n>>> Poly(x**2 + 1, x, extension=sqrt(2))\nPoly(x**2 + 1, x, domain='QQ<sqrt(2)>')\n>>> Poly(x**2 + 1, x, extension=[sqrt(2), sqrt(3)])\nPoly(x**2 + 1, x, domain='QQ<sqrt(2) + sqrt(3)>')\n>>> construct_domain([1, 0, 1], extension=sqrt(2))[0]\nZZ \n```", "```py\n>>> p = Poly(x**2*y + z, x)\n>>> p\nPoly(y*x**2 + z, x, domain='ZZ[y,z]')\n>>> p.gens\n(x,)\n>>> p.domain\nZZ[y,z]\n>>> p.domain == ZZ[y,z]\nTrue\n>>> p.domain == ZZ.poly_ring(y, z)\nTrue\n>>> p.domain == ZZ.old_poly_ring(y, z)\nFalse\n>>> p.rep.rep  \n[y, 0, z]\n>>> p.rep.rep[0]  \ny\n>>> type(p.rep.rep[0])  \n<class 'sympy.polys.rings.PolyElement'>\n>>> dict(p.rep.rep[0])  \n{(1, 0): 1} \n```", "```py\n>>> p = Poly(x**2*y + z, x, y, z)\n>>> p\nPoly(x**2*y + z, x, y, z, domain='ZZ')\n>>> p.rep\nDMP_Python([[[1], []], [[]], [[1, 0]]], ZZ)\n>>> p.rep.rep  \n[[[1], []], [[]], [[1, 0]]]\n>>> p.rep.rep[0][0][0]  \n1\n>>> type(p.rep.rep[0][0][0])  \n<class 'int'> \n```", "```py\n>>> p = Poly(x**2*y + z, t)\n>>> p\nPoly(x**2*y + z, t, domain='ZZ[x,y,z]')\n>>> p.rep\nDMP_Python([x**2*y + z], ZZ[x,y,z])\n>>> p.rep.rep[0]  \nx**2*y + z\n>>> type(p.rep.rep[0])  \n<class 'sympy.polys.rings.PolyElement'>\n>>> dict(p.rep.rep[0])  \n{(0, 0, 1): 1, (2, 1, 0): 1} \n```", "```py\n>>> Poly(x**2*y + z)\nPoly(x**2*y + z, x, y, z, domain='ZZ')\n>>> from sympy import pi, exp\n>>> Poly(exp(x) + exp(2*x) + 1)\nPoly((exp(x))**2 + (exp(x)) + 1, exp(x), domain='ZZ')\n>>> Poly(pi*x)\nPoly(x*pi, x, pi, domain='ZZ')\n>>> Poly(pi*x, x)\nPoly(pi*x, x, domain='ZZ[pi]') \n```", "```py\n>>> from sympy import sin, cos, sqrt\n>>> Poly(x*exp(x))      # fine\nPoly(x*(exp(x)), x, exp(x), domain='ZZ')\n>>> Poly(sin(x)+cos(x)) # not fine\nPoly((cos(x)) + (sin(x)), cos(x), sin(x), domain='ZZ')\n>>> Poly(x + sqrt(x))   # not fine\nPoly(x + (sqrt(x)), x, sqrt(x), domain='ZZ') \n```", "```py\n>>> p1 = Poly(x, x, sqrt(x))\n>>> p2 = Poly(sqrt(x), x, sqrt(x))\n>>> p1\nPoly(x, x, sqrt(x), domain='ZZ')\n>>> p2\nPoly((sqrt(x)), x, sqrt(x), domain='ZZ')\n>>> p3 = p1 - p2**2\n>>> p3                  # should be zero...\nPoly(x - (sqrt(x))**2, x, sqrt(x), domain='ZZ')\n>>> p3.as_expr()\n0 \n```", "```py\n>>> Poly(x + sqrt(x))            # this could be improved!\nPoly(x + (sqrt(x)), x, sqrt(x), domain='ZZ')\n>>> Poly(x + sqrt(x), sqrt(x))   # this could be improved!\nPoly((sqrt(x)) + x, sqrt(x), domain='ZZ[x]') \n```"]