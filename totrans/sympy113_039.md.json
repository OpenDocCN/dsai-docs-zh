["```py\n    >>> from sympy import symbols\n    >>> x = symbols('x')\n    >>> a, b, c = symbols('a b c') \n    ```", "```py\n    >>> i, j, k = symbols('i j k', integer=True) \n    ```", "```py\n    >>> from sympy import Function\n    >>> f, g, h = symbols('f g h', cls=Function) \n    ```", "```py\n    >>> symbols('x:10')\n    (x0, x1, x2, x3, x4, x5, x6, x7, x8, x9) \n    ```", "```py\n    >>> from sympy import Symbol\n    >>> x_y = Symbol('x y') # This creates a single symbol named 'x y' \n    ```", "```py\n    >>> from sympy import S\n    >>> x = S(\"x\") # DO NOT DO THIS \n    ```", "```py\n    >>> # These both fail\n    >>> x = S(\"0x\") \n    Traceback (most recent call last):\n    ...\n    SyntaxError: invalid syntax (<string>, line 1)\n    >>> x = S(\"x+\") \n    Traceback (most recent call last):\n    ...\n    SyntaxError: invalid syntax (<string>, line 1) \n    ```", "```py\n    >>> from sympy import integrate, exp, oo\n    >>> a = symbols('a') # no assumptions\n    >>> integrate(exp(-a*x), (x, 0, oo))\n    Piecewise((1/a, Abs(arg(a)) < pi/2), (Integral(exp(-a*x), (x, 0, oo)), True)) \n    ```", "```py\n    >>> a = symbols('a', positive=True)\n    >>> integrate(exp(-a*x), (x, 0, oo))\n    1/a \n    ```", "```py\n    >>> z1 = symbols('z')\n    >>> z2 = symbols('z', positive=True)\n    >>> z1 == z2\n    False\n    >>> z1 + z2\n    z + z \n    ```", "```py\n>>> from sympy import expand\n>>> expand(\"(x**2 + x)/x\")\nx + 1 \n```", "```py\n>>> from sympy import symbols\n>>> x = symbols('x')\n>>> expand((x**2 + x)/x)\nx + 1 \n```", "```py\n>>> from sympy import parse_expr\n>>> string_input = \"(x**2 + x)/x\"\n>>> expr = parse_expr(string_input)\n>>> expand(expr)\nx + 1 \n```", "```py\n    >>> from sympy import expand_trig\n    >>> expand_trig(\"sine(x + y)\")\n    sine(x + y) \n    ```", "```py\n    >>> from sympy import sin, symbols\n    >>> x, y = symbols('x y')\n    >>> expand_trig(sine(x + y)) # The typo is caught by a NameError\n    Traceback (most recent call last):\n    ...\n    NameError: name 'sine' is not defined\n    >>> expand_trig(sin(x + y))\n    sin(x)*cos(y) + sin(y)*cos(x) \n    ```", "```py\n    >>> z1 = symbols('z')\n    >>> z2 = symbols('z', positive=True)\n    >>> z1 == z2\n    False\n    >>> z1 + z2\n    z + z \n    ```", "```py\n    >>> from sympy import diff\n    >>> z = symbols('z', positive=True)\n    >>> diff('z**2', z)\n    0 \n    ```", "```py\n    >>> a, b, c = symbols('a b c', real=True)\n    >>> # a, b, and c in expr are different symbols without assumptions\n    >>> expr = parse_expr('a**2 + b - c')\n    >>> expr.subs({a: 1, b: 1, c: 1}) # The substitution (apparently) doesn't work\n    a**2 + b - c \n    ```", "```py\n    >>> # a, b, and c are the same as the a, b, c with real=True defined above\n    >>> expr = parse_expr('a**2 + b - c', {'a': a, 'b': b, 'c': c})\n    >>> expr.subs({a: 1, b: 1, c: 1})\n    1 \n    ```", "```py\n    >>> \"x + 1\".subs(\"x\", \"y\")\n    Traceback (most recent call last):\n    ...\n    AttributeError: 'str' object has no attribute 'subs' \n    ```", "```py\n    >>> x, y = symbols('x y')\n    >>> (x + 1).subs(x, y)\n    y + 1 \n    ```", "```py\n    >>> from sympy import solve\n    >>> solve('x_{2} - 1') \n    ValueError: Error from parse_expr with transformed code: \"Symbol ('x_' ){Integer (2 )}-Integer (1 )\"\n    ...\n    SyntaxError: invalid syntax (<string>, line 1) \n    ```", "```py\n    >>> x2 = symbols('x_{2}')\n    >>> solve(x2 - 1, x2)\n    [1] \n    ```", "```py\n    >>> solve('x^1_2 - 1')\n    [-1, 1, -I, I, -1/2 - sqrt(3)*I/2, -1/2 + sqrt(3)*I/2, 1/2 - sqrt(3)*I/2, 1/2 + sqrt(3)*I/2, -sqrt(3)/2 - I/2, -sqrt(3)/2 + I/2, sqrt(3)/2 - I/2, sqrt(3)/2 + I/2] \n    ```", "```py\n    >>> x12 = symbols('x^1_2')\n    >>> solve(x12 - 1, x12)\n    [1] \n    ```", "```py\n>>> expression_str = '+'.join([f'{i}*x_{i}' for i in range(10)])\n>>> expr = parse_expr(expression_str)\n>>> expr\nx_1 + 2*x_2 + 3*x_3 + 4*x_4 + 5*x_5 + 6*x_6 + 7*x_7 + 8*x_8 + 9*x_9 \n```", "```py\n>>> from sympy import Add, Symbol\n>>> expr = Add(*[i*Symbol(f'x_{i}') for i in range(10)])\n>>> expr\nx_1 + 2*x_2 + 3*x_3 + 4*x_4 + 5*x_5 + 6*x_6 + 7*x_7 + 8*x_8 + 9*x_9 \n```", "```py\n>>> expression = x**2 + 0.5*x + 1 \n```", "```py\n>>> from sympy import Rational\n>>> expression = x**2 + Rational(1, 2)*x + 1\n>>> expression = x**2 + x/2 + 1 # Equivalently \n```", "```py\n>>> import math\n>>> import sympy\n>>> math.pi\n3.141592653589793\n>>> sympy.sin(math.pi)\n1.22464679914735e-16 \n```", "```py\n>>> sympy.pi\npi\n>>> sympy.sin(sympy.pi)\n0 \n```", "```py\n>>> x + 2/7 # The exact value of 2/7 is lost\nx + 0.2857142857142857 \n```", "```py\n>>> from sympy import Rational, S\n>>> x + Rational(2, 7)\nx + 2/7\n>>> x + S(2)/7 # Equivalently\nx + 2/7 \n```", "```py\n    >>> from sympy import factor\n    >>> factor(x**2.0 - 1)\n    x**2.0 - 1\n    >>> factor(x**2 - 1)\n    (x - 1)*(x + 1) \n    ```", "```py\n    >>> from sympy import expand\n    >>> expand((x + 1.0)*(x - 1e-16)) # the coefficient of x should be slightly less than 1\n    x**2 + 1.0*x - 1.0e-16\n    >>> expand((x + 1)*(x - Rational('1e-16'))) # Using rational numbers gives the coefficient of x exactly\n    x**2 + 9999999999999999*x/10000000000000000 - 1/10000000000000000 \n    ```", "```py\n    >>> from sympy import Float\n    >>> expand((x + 1.0)*(x - Float('1e-16', 20)))\n    x**2 + 0.9999999999999999*x - 1.0e-16 \n    ```", "```py\n>>> from sympy import nsimplify\n>>> Rational(0.7)\n3152519739159347/4503599627370496\n>>> nsimplify(0.7)\n7/10 \n```", "```py\ndef theta_operator(expr):\n    z = symbols('z')\n    return z*expr.diff(z) \n```", "```py\ndef theta_operator(expr, z):\n    return z*expr.diff(z) \n```", "```py\n>>> def theta_operator(expr):\n...     z = symbols('z')\n...     return z*expr.diff(z)\n>>> theta_operator(x**2) # The expected answer is 2*x**2\n0 \n```", "```py\n>>> z = symbols('z', positive=True) \n```", "```py\n>>> theta_operator(z**2)\n0 \n```", "```py\n>>> import numpy as np\n>>> import sympy\n>>> a = np.array([0., 1., 2.])\n>>> sympy.sin(a)\nTraceback (most recent call last):\n...\nAttributeError: 'ImmutableDenseNDimArray' object has no attribute 'as_coefficient' \n```", "```py\n>>> x = Symbol('x')\n>>> np.sin(x) # NumPy functions do not know how to handle SymPy expressions\nTraceback (most recent call last):\n...\nTypeError: loop of ufunc does not support argument 0 of type Symbol which has no callable sin method \n```", "```py\n>>> # First symbolically construct the expression you are interested in with SymPy\n>>> from sympy import diff, sin, exp, lambdify, symbols\n>>> x = symbols('x')\n>>> expr = diff(sin(x)*exp(x**2), x)\n\n>>> # Then convert it to a numeric function with lambdify()\n>>> f = lambdify(x, expr)\n\n>>> # Now use this function with NumPy\n>>> import numpy as np\n>>> a = np.linspace(0, 10)\n>>> f(a) \n[ 1.00000000e+00  1.10713341e+00  1.46699555e+00 ... -3.15033720e+44] \n```", "```py\n    >>> import math\n    >>> math.pi # a float\n    3.141592653589793\n    >>> import sympy\n    >>> sympy.sin(math.pi)\n    1.22464679914735e-16 \n    ```", "```py\n    >>> sympy.sin(sympy.pi)\n    0 \n    ```", "```py\n    >>> x = Symbol('x')\n    >>> math.sin(x)\n    Traceback (most recent call last):\n    ...\n    TypeError: Cannot convert expression to float \n    ```", "```py\n    >>> sympy.sin(1).evalf(30)\n    0.841470984807896506652502321630\n    >>> math.sin(1)\n    0.8414709848078965 \n    ```", "```py\n    >>> import numpy as np\n    >>> import sympy\n    >>> a = np.asarray([sympy.Float(1.0), sympy.Float(0.0)]) # Do not do this\n    >>> print(repr(a)) # Note that the dtype is 'object'\n    array([1.00000000000000, 0.0], dtype=object)\n    >>> np.sin(a)\n    Traceback (most recent call last):\n    ...\n    TypeError: loop of ufunc does not support argument 0 of type Float which has no callable sin method \n    ```", "```py\n>>> x > 0\nx > 0 \n```", "```py\n>>> bool(x > 0)\nTraceback (most recent call last):\n...\nTypeError: cannot determine truth value of Relational \n```", "```py\nif x > 0:\n    ... \n```", "```py\n>>> sorted([x, 0])\nTraceback (most recent call last):\n...\nTypeError: cannot determine truth value of Relational \n```", "```py\n    if x.is_positive:\n        ... \n    ```", "```py\n    if x > 0:\n        expr = 1\n    else:\n        expr = 0 \n    ```", "```py\n    >>> from sympy import Piecewise, pprint\n    >>> expr = Piecewise((1, x > 0), (0, True))\n    >>> pprint(expr, use_unicode=True)\n    ⎧1  for x > 0\n    ⎨\n    ⎩0  otherwise\n    >>> expr.subs(x, 1)\n    1\n    >>> expr.subs(x, -1)\n    0 \n    ```", "```py\n    >>> from sympy import ordered\n    >>> list(ordered([x, 0]))\n    [0, x] \n    ```", "```py\n>>> def replace(expr, x, y):\n...  \"\"\"Replace x with y in expr\"\"\"\n...     newargs = []\n...     for arg in expr.args:\n...         if arg == x:\n...             newargs.append(y)\n...         else:\n...             newargs.append(replace(arg, x, y))\n...     return expr.func(*newargs)\n>>> replace(x + sin(x - 1), x, y)\ny + sin(y - 1) \n```", "```py\n>>> from sympy import Integral\n>>> expr = Integral(sin(x), x)\n>>> expr.args # args are normalized\n(sin(x), (x,))\n>>> Integral(sin(x), (x,)) # Also accepted\nIntegral(sin(x), x) \n```", "```py\nclass f(Function):\n    @classmethod\n    def eval(cls, x):\n        if x.is_integer: # Bad (checking general assumptions)\n            return 0\n        if isinstance(x, Add): # Bad (applying symbolic identities)\n            return Add(*[f(i) for i in x.args]) \n```", "```py\nclass f(Function):\n    @classmethod\n    def eval(cls, x):\n        if isinstance(x, Integer): # Good (only evaluating on explicit integers)\n            return 0\n\n    # Good (applying simplification on assumptions in doit())\n    def doit(self, deep=True, **hints):\n        x = self.args[0]\n        if deep:\n           x = x.doit(deep=deep, **hints)\n        if x.is_integer:\n           return S(0)\n        return self\n\n    # Good (applying symbolic identities inside of simplification functions)\n    def _eval_expand_func(self, **hints):\n        x = self.args[0]\n        if isinstance(x, Add):\n            return Add(*[f(i) for i in x.args])\n        return self \n```", "```py\n>>> from sympy import FiniteSet\n>>> FiniteSet(1, 2, 3)\n{1, 2, 3} \n```", "```py\n>>> FiniteSet(FiniteSet(1, 2, 3)) # We don't want this to be the same as {1, 2, 3}\nFiniteSet({1, 2, 3}) \n```", "```py\n>>> x*(x - 1) == x**2 - x\nFalse \n```", "```py\n# BAD\n\nclass f(Function):\n    def _eval_is_integer(self):\n        # Quick return if self is not real (do not do this).\n        if self.is_real is False:\n            return False\n        return self.args[0].is_integer \n```", "```py\n>>> class f(Function):\n...     def _eval_is_integer(self):\n...         if self.is_real is False:\n...             return False\n...         return self.args[0].is_integer\n>>> f(x).is_real\nTraceback (most recent call last):\n...\nRecursionError: maximum recursion depth exceeded while calling a Python object \n```", "```py\n# GOOD\n\nclass f(Function):\n    def _eval_is_integer(self):\n        return self.args[0].is_integer \n```"]