- en: Kane’s Method in Physics/Mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/physics/mechanics/kane.html](https://docs.sympy.org/latest/modules/physics/mechanics/kane.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`sympy.physics.mechanics`](index.html#module-sympy.physics.mechanics "sympy.physics.mechanics")
    provides functionality for deriving equations of motion using Kane’s method [[Kane1985]](reference.html#kane1985).
    This document will describe Kane’s method as used in this module, but not how
    the equations are actually derived.'
  prefs: []
  type: TYPE_NORMAL
- en: Structure of Equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [`sympy.physics.mechanics`](index.html#module-sympy.physics.mechanics "sympy.physics.mechanics")
    we are assuming there are 5 basic sets of equations needed to describe a system.
    They are: holonomic constraints, non-holonomic constraints, kinematic differential
    equations, dynamic equations, and differentiated non-holonomic equations.'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\mathbf{f_h}(q, t) &= 0\\ \mathbf{k_{nh}}(q, t) u + \mathbf{f_{nh}}(q,
    t) &= 0\\ \mathbf{k_{k\dot{q}}}(q, t) \dot{q} + \mathbf{k_{ku}}(q, t) u + \mathbf{f_k}(q,
    t) &= 0\\ \mathbf{k_d}(q, t) \dot{u} + \mathbf{f_d}(q, \dot{q}, u, t) &= 0\\ \mathbf{k_{dnh}}(q,
    t) \dot{u} + \mathbf{f_{dnh}}(q, \dot{q}, u, t) &= 0\\\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: In [`sympy.physics.mechanics`](index.html#module-sympy.physics.mechanics "sympy.physics.mechanics")
    holonomic constraints are only used for the linearization process; it is assumed
    that they will be too complicated to solve for the dependent coordinate(s). If
    you are able to easily solve a holonomic constraint, you should consider redefining
    your problem in terms of a smaller set of coordinates. Alternatively, the time-differentiated
    holonomic constraints can be supplied.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kane’s method forms two expressions, \(F_r\) and \(F_r^*\), whose sum is zero.
    In this module, these expressions are rearranged into the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: \(\mathbf{M}(q, t) \dot{u} = \mathbf{f}(q, \dot{q}, u, t)\)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'For a non-holonomic system with \(o\) total speeds and \(m\) motion constraints,
    we will get o - m equations. The mass-matrix/forcing equations are then augmented
    in the following fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}\mathbf{M}(q, t) &= \begin{bmatrix} \mathbf{k_d}(q, t) \\ \mathbf{k_{dnh}}(q,
    t) \end{bmatrix}\\ \mathbf{_{(forcing)}}(q, \dot{q}, u, t) &= \begin{bmatrix}
    - \mathbf{f_d}(q, \dot{q}, u, t) \\ - \mathbf{f_{dnh}}(q, \dot{q}, u, t) \end{bmatrix}\\\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: Kane’s Method in Physics/Mechanics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The formulation of the equations of motion in [`sympy.physics.mechanics`](index.html#module-sympy.physics.mechanics
    "sympy.physics.mechanics") starts with creation of a `KanesMethod` object. Upon
    initialization of the `KanesMethod` object, an inertial reference frame needs
    to be supplied. along with some basic system information, such as coordinates
    and speeds
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is also important to supply the order of coordinates and speeds properly
    if there are dependent coordinates and speeds. They must be supplied after independent
    coordinates and speeds or as a keyword argument; this is shown later.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, if there are auxiliary speeds, they need to be identified here.
    See the examples for more information on this. In this example u4 is the auxiliary
    speed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Kinematic differential equations must also be supplied; there are to be provided
    as a list of expressions which are each equal to zero. A trivial example follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Turning on `mechanics_printing()` makes the expressions significantly shorter
    and is recommended. Alternatively, the `mprint` and `mpprint` commands can be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are non-holonomic constraints, dependent speeds need to be specified
    (and so do dependent coordinates, but they only come into play when linearizing
    the system). The constraints need to be supplied in a list of expressions which
    are equal to zero, trivial motion and configuration constraints are shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A dictionary returning the solved \(\dot{q}\)’s can also be solved for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The final step in forming the equations of motion is supplying a list of bodies
    and particles, and a list of 2-tuples of the form `(Point, Vector)` or `(ReferenceFrame,
    Vector)` to represent applied forces and torques.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When there are motion constraints, the mass matrix is augmented by the \(k_{dnh}(q,
    t)\) matrix, and the forcing vector by the \(f_{dnh}(q, \dot{q}, u, t)\) vector.
  prefs: []
  type: TYPE_NORMAL
- en: There are also the “full” mass matrix and “full” forcing vector terms, these
    include the kinematic differential equations; the mass matrix is of size (n +
    o) x (n + o), or square and the size of all coordinates and speeds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Exploration of the provided examples is encouraged in order to gain more understanding
    of the `KanesMethod` object.
  prefs: []
  type: TYPE_NORMAL
