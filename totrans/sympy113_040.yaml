- en: Gotchas and Pitfalls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gotchas 和 pitfalls
- en: 原文：[https://docs.sympy.org/latest/explanation/gotchas.html](https://docs.sympy.org/latest/explanation/gotchas.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/explanation/gotchas.html](https://docs.sympy.org/latest/explanation/gotchas.html)
- en: '## Introduction'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '## Introduction'
- en: SymPy runs under the [Python Programming Language](https://www.python.org/),
    so there are some things that may behave differently than they do in other, independent
    computer algebra systems like Maple or Mathematica. These are some of the gotchas
    and pitfalls that you may encounter when using SymPy. See also the [introductory
    tutorial](../tutorials/intro-tutorial/index.html#intro-tutorial), the remainder
    of the SymPy Docs, and the [official Python Tutorial](https://docs.python.org/3/tutorial/).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 是在[Python编程语言](https://www.python.org/)下运行的，因此可能有些事情的行为与其他独立的计算机代数系统（如Maple或Mathematica）不同。这些都是在使用SymPy时可能遇到的一些陷阱和问题。另请参阅[入门教程](../tutorials/intro-tutorial/index.html#intro-tutorial)、SymPy文档的其余部分以及[官方Python教程](https://docs.python.org/3/tutorial/)。
- en: If you are already familiar with C or Java, you might also want to look at this
    [4 minute Python tutorial](https://nerdparadise.com/programming/python4minutes/).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉C或Java，你可能还想看看这个[4分钟的Python教程](https://nerdparadise.com/programming/python4minutes/)。
- en: 'Ignore `#doctest: +SKIP` in the examples. That has to do with internal testing
    of the examples.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '忽略例子中的 `#doctest: +SKIP`。这与例子的内部测试有关。'
- en: '## Equals Signs (=)'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## 等号 (=)'
- en: Single Equals Sign
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单等号
- en: The equals sign (`=`) is the assignment operator, not equality. If you want
    to do \(x = y\), use `Eq(x, y)` for equality. Alternatively, all expressions are
    assumed to equal zero, so you can just subtract one side and use `x - y`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 等号 (`=`) 是赋值运算符，不是相等。如果要执行 \(x = y\)，请使用 `Eq(x, y)` 表示相等。或者，所有表达式都假定为零，因此你可以只减去一边并使用
    `x - y`。
- en: The proper use of the equals sign is to assign expressions to variables.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 等号的正确使用是将表达式分配给变量。
- en: 'For example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Double Equals Signs
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 双等号
- en: 'Double equals signs (`==`) are used to test equality. However, this tests expressions
    exactly, not symbolically. For example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 双等号 (`==`) 用于测试相等性。但是，这会精确地测试表达式，而不是符号上的相等性。例如：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you want to test for symbolic equality, one way is to subtract one expression
    from the other and run it through functions like [`expand()`](../modules/core.html#sympy.core.function.expand
    "sympy.core.function.expand"), [`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify"), and [`trigsimp()`](../modules/simplify/simplify.html#sympy.simplify.trigsimp.trigsimp
    "sympy.simplify.trigsimp.trigsimp") and see if the equation reduces to 0.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要测试符号相等性，一种方法是从一个表达式中减去另一个表达式，并通过[`expand()`](../modules/core.html#sympy.core.function.expand
    "sympy.core.function.expand")、[`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify")和[`trigsimp()`](../modules/simplify/simplify.html#sympy.simplify.trigsimp.trigsimp
    "sympy.simplify.trigsimp.trigsimp")等函数进行处理，看方程是否简化为零。
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See also [Structural Equality](glossary.html#term-Structural-Equality) in the
    [Glossary](glossary.html).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅[结构相等性](glossary.html#term-Structural-Equality)和[术语表](glossary.html)中的[结构相等性]。
- en: Variables
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量
- en: Variables Assignment does not Create a Relation Between Expressions
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量分配不会创建表达式之间的关系
- en: 'When you use `=` to do assignment, remember that in Python, as in most programming
    languages, the variable does not change if you change the value you assigned to
    it. The equations you are typing use the values present at the time of creation
    to “fill in” values, just like regular Python definitions. They are not altered
    by changes made afterwards. Consider the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `=` 进行赋值时，请记住在Python中，像大多数编程语言一样，如果你改变分配给它的值，变量本身不会改变。你正在输入的方程式使用在创建时存在的值来“填充”值，就像常规的Python定义一样。它们不会因后续的更改而改变。考虑以下情况：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Changing quantity `a` does not change `b`; you are not working with a set of
    simultaneous equations. It might be helpful to remember that the string that gets
    printed when you print a variable referring to a SymPy object is the string that
    was given to it when it was created; that string does not have to be the same
    as the variable that you assign it to.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 更改量 `a` 不会改变 `b`；你不是在处理一组同时方程式。记住打印一个引用SymPy对象的变量时得到的字符串是在创建时给定的字符串；那个字符串不一定与你赋给它的变量相同。
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If you need variables that have dependence on each other, you can define functions.
    Use the `def` operator. Indent the body of the function. See the Python docs for
    more information on defining functions.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要具有相互依赖的变量，可以定义函数。使用 `def` 操作符。缩进函数体。有关定义函数的更多信息，请参阅 Python 文档。
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you define a circular relationship, you will get a `RuntimeError`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果定义了循环关系，将会出现 `RuntimeError`。
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See also [immutable](glossary.html#term-Immutable) in the [Glossary](glossary.html).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅 [Glossary](glossary.html) 中的 [不可变](glossary.html#term-Immutable)。
- en: '### Symbols'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '### 符号'
- en: 'Symbols are variables, and like all other variables, they need to be assigned
    before you can use them. For example:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 符号是变量，与所有其他变量一样，使用前需要赋值。例如：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you use **isympy**, it runs the following commands for you, giving you some
    default Symbols and Functions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 **isympy**，它会为您运行以下命令，为您提供一些默认的符号和函数。
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You can also import common symbol names from [`sympy.abc`](../modules/abc.html#module-sympy.abc
    "sympy.abc").
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以从 [`sympy.abc`](../modules/abc.html#module-sympy.abc "sympy.abc") 导入常见符号名称。
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If you want control over the assumptions of the variables, use [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol") and [`symbols()`](../modules/core.html#sympy.core.symbol.symbols
    "sympy.core.symbol.symbols"). See [Keyword Arguments](#keyword-arguments) below.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望控制变量的假设条件，请使用 [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol") 和 [`symbols()`](../modules/core.html#sympy.core.symbol.symbols
    "sympy.core.symbol.symbols")。请参阅下面的[关键字参数](#keyword-arguments)。
- en: Lastly, it is recommended that you not use [`I`](../modules/core.html#sympy.core.numbers.ImaginaryUnit
    "sympy.core.numbers.ImaginaryUnit"), [`E`](../modules/stats.html#sympy.stats.E
    "sympy.stats.E"), [`S`](../modules/physics/quantum/gate.html#sympy.physics.quantum.gate.S
    "sympy.physics.quantum.gate.S"), [`N`](../modules/core.html#sympy.core.evalf.N
    "sympy.core.evalf.N"), `C`, [`O`](../modules/series/series.html#sympy.series.order.Order
    "sympy.series.order.Order"), or [`Q`](../modules/assumptions/ask.html#sympy.assumptions.ask.AssumptionKeys
    "sympy.assumptions.ask.AssumptionKeys") for variable or symbol names, as those
    are used for the imaginary unit (\(i\)), the base of the natural logarithm (\(e\)),
    the [`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")
    function (see [Symbolic Expressions](#symbolic-expressions) below), numeric evaluation
    ([`N()`](../modules/core.html#sympy.core.evalf.N "sympy.core.evalf.N") is equivalent
    to [evalf()](../modules/evalf.html#evalf-label) ), the [big O](https://en.wikipedia.org/wiki/Big_O_notation)
    order symbol (as in \(O(n\log{n})\)), and the assumptions object that holds a
    list of supported ask keys (such as `Q.real`), respectively. You can use the mnemonic
    `OSINEQ` to remember what Symbols are defined by default in SymPy. Or better yet,
    always use lowercase letters for Symbol names. Python will not prevent you from
    overriding default SymPy names or functions, so be careful.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，建议不要使用 [`I`](../modules/core.html#sympy.core.numbers.ImaginaryUnit "sympy.core.numbers.ImaginaryUnit"),
    [`E`](../modules/stats.html#sympy.stats.E "sympy.stats.E"), [`S`](../modules/physics/quantum/gate.html#sympy.physics.quantum.gate.S
    "sympy.physics.quantum.gate.S"), [`N`](../modules/core.html#sympy.core.evalf.N
    "sympy.core.evalf.N"), `C`, [`O`](../modules/series/series.html#sympy.series.order.Order
    "sympy.series.order.Order"), 或 [`Q`](../modules/assumptions/ask.html#sympy.assumptions.ask.AssumptionKeys
    "sympy.assumptions.ask.AssumptionKeys") 作为变量或符号名称，因为它们分别用于虚数单位 (\(i\))，自然对数的底
    (\(e\))，[`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")
    函数（见下文的[符号表达式](#symbolic-expressions)），数值评估（[`N()`](../modules/core.html#sympy.core.evalf.N
    "sympy.core.evalf.N") 相当于 [evalf()](../modules/evalf.html#evalf-label) ），大 O 表示法（如
    \(O(n\log{n})\)），以及保存支持的查询键列表的假设对象（例如 `Q.real`）。建议记住这些符号的助记符 `OSINEQ`，以了解 SymPy
    中默认定义的符号。或者更好的做法是，总是使用小写字母作为符号名称。Python 不会阻止您覆盖默认的 SymPy 名称或函数，因此请小心。
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To get a full list of all default names in SymPy do:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得 SymPy 中所有默认名称的完整列表，请执行以下操作：
- en: '[PRE11]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you have [IPython](https://ipython.org/) installed and use **isympy**, you
    can also press the TAB key to get a list of all built-in names and to autocomplete.
    Also, see [this page](https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks)
    for a trick for getting tab completion in the regular Python console.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已安装 [IPython](https://ipython.org/) 并使用 **isympy**，您还可以按 TAB 键获取所有内置名称的列表并进行自动完成。另请参阅[此页面](https://kogs-www.informatik.uni-hamburg.de/~meine/python_tricks)，了解如何在常规
    Python 控制台中实现 TAB 完成的技巧。
- en: Note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'See also the [Defining Symbols](best-practices.html#best-practices-defining-symbols)
    section of the [Best Practices](best-practices.html) page.  ### Functions'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 参见 [最佳实践](best-practices.html) 页面的 [定义符号](best-practices.html#best-practices-defining-symbols)
    部分。### 函数
- en: 'A function like `f(x)` can be created by defining the Function and the variable:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似 `f(x)` 的函数可以通过定义函数和变量来创建：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If you assign `f(x)` to a Python variable \(f\) you will lose your ability
    to copy and paste that function or to create a function with a different argument:
    `Function(''f'')` is callable, but `Function(''f'')(x)` is not:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将 `f(x)` 赋给Python变量 \( f \)，你将失去复制和粘贴该函数或创建具有不同参数的函数的能力：`Function('f')` 可调用，但
    `Function('f')(x)` 不可：
- en: '[PRE13]  ## Symbolic Expressions'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE13]  ## 符号表达式'
- en: '### Python numbers vs. SymPy Numbers'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '### Python数字 vs. SymPy数字'
- en: SymPy uses its own classes for integers, rational numbers, and floating point
    numbers instead of the default Python `int` and `float` types because it allows
    for more control. But you have to be careful. If you type an expression that just
    has numbers in it, it will default to a Python expression. Use the [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") function, or just [`S`](../modules/physics/quantum/gate.html#sympy.physics.quantum.gate.S
    "sympy.physics.quantum.gate.S"), to ensure that something is a SymPy expression.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy使用其自己的整数、有理数和浮点数类，而不是默认的Python `int` 和 `float` 类型，因为它允许更多的控制。但你必须小心。如果你输入一个只有数字的表达式，它将默认为Python表达式。使用[`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify")函数，或者仅仅使用[`S`](../modules/physics/quantum/gate.html#sympy.physics.quantum.gate.S
    "sympy.physics.quantum.gate.S")，以确保某物是SymPy表达式。
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: If you include numbers in a SymPy expression, they will be sympified automatically,
    but there is one gotcha you should be aware of. If you do `<number>/<number>`
    inside of a SymPy expression, Python will evaluate the two numbers before SymPy
    has a chance to get to them. The solution is to [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") one of the numbers, or use [`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在SymPy表达式中包含数字，它们将自动变为SymPy类型，但你应该注意一个陷阱。如果在SymPy表达式中执行 `<数字>/<数字>`，Python将在SymPy处理它们之前对这两个数字进行求值。解决方案是使用[`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify")其中一个数字，或使用[`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational")。
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With a power of `1/2` you can also use `sqrt` shorthand:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `1/2` 的幂也可以使用 `sqrt` 的简写：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If the two integers are not directly separated by a division sign then you
    don’t have to worry about this problem:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个整数没有直接用除号分开，那么你不必担心这个问题：
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A common mistake is copying an expression that is printed and reusing it. If
    the expression has a [`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational") (i.e., `<number>/<number>`) in it, you will not
    get the same result, obtaining the Python result for the division rather than
    a SymPy Rational.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 常见的错误是复制并重用打印的表达式。如果表达式中包含一个[`有理数`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational")（即 `<数字>/<数字>`），你将得到Python除法的结果，而不是SymPy的有理数。
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The other solution is to put quotes around the expression and run it through
    S() (i.e., sympify it):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个解决方案是在表达式周围加上引号，并通过S()运行它（即，对其进行sympify）：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Also, if you do not use **isympy**, you could use `from __future__ import division`
    to prevent the `/` sign from performing [integer division](https://en.wikipedia.org/wiki/Integer_division).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你不使用 **isympy**，你可以使用 `from __future__ import division` 来防止 `/` 符号执行[整数除法](https://en.wikipedia.org/wiki/Integer_division)。
- en: '[PRE20]'
  id: totrans-65
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE20]'
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'But be careful: you will now receive floats where you might have desired a
    Rational:'
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 但要小心：现在你将收到浮点数，而不是你可能想要的有理数：
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[`Rational`](../modules/core.html#sympy.core.numbers.Rational "sympy.core.numbers.Rational")
    only works for number/number and is only meant for rational numbers. If you want
    a fraction with symbols or expressions in it, just use `/`. If you do number/expression
    or expression/number, then the number will automatically be converted into a SymPy
    Number. You only need to be careful with number/number.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Rational`](../modules/core.html#sympy.core.numbers.Rational "sympy.core.numbers.Rational")
    仅适用于数字/数字，并且仅适用于有理数。如果你想要一个包含符号或表达式的分数，只需使用 `/`。如果你做数字/表达式或表达式/数字，则该数字将自动转换为SymPy数字。你只需小心处理数字/数字。'
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Evaluating Expressions with Floats and Rationals
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用浮点数和有理数评估表达式
- en: SymPy keeps track of the precision of `Float` objects. The default precision
    is 15 digits. When an expression involving a `Float` is evaluated, the result
    will be expressed to 15 digits of precision but those digits (depending on the
    numbers involved with the calculation) may not all be significant.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 跟踪`Float`对象的精度。默认精度为15位小数。当计算涉及`Float`的表达式时，结果将被表达为15位的精度，但这些位数（取决于计算中涉及的数字）可能不全是有效的；
- en: 'The first issue to keep in mind is how the `Float` is created: it is created
    with a value and a precision. The precision indicates how precise of a value to
    use when that `Float` (or an expression it appears in) is evaluated.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要记住的问题是如何创建`Float`：它是用一个值和一个精度创建的。精度表示在评估该`Float`（或其出现在其中的表达式）时要使用多精确的值。
- en: The values can be given as strings, integers, floats, or rationals.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值可以作为字符串、整数、浮点数或有理数给出；
- en: strings and integers are interpreted as exact
  id: totrans-76
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串和整数被解释为精确值；
- en: ''
  id: totrans-77
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-78
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-79
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE23]'
- en: ''
  id: totrans-81
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: to have the precision match the number of digits, the null string can be used
    for the precision
  id: totrans-82
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使精度与数字的位数匹配，可以使用空字符串来表示精度；
- en: ''
  id: totrans-83
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-84
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-85
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE24]'
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, notice that each of those values looks correct to 3 digits. But if we
    try to evaluate them to 20 digits, a difference will become apparent:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，注意每一个值在3位数看起来都是正确的。但是如果我们尝试将它们评估到20位数，一个差异将变得明显：
- en: 'The 0.25 (with precision of 3) represents a number that has a non-repeating
    binary decimal; 1/7 is repeating in binary and decimal – it cannot be represented
    accurately too far past those first 3 digits (the correct decimal is a repeating
    142857):'
  id: totrans-90
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`0.25`（精度为3）表示一个具有非重复二进制小数的数字；`1/7`在二进制和十进制中是重复的 - 它不能在这些前三位数之外精确表示（正确的十进制是一个重复的142857）；'
- en: ''
  id: totrans-91
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-92
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE26]'
- en: ''
  id: totrans-93
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It is important to realize that although a Float is being displayed in decimal
    at arbitrary precision, it is actually stored in binary. Once the Float is created,
    its binary information is set at the given precision. The accuracy of that value
    cannot be subsequently changed; so 1/7, at a precision of 3 digits, can be padded
    with binary zeros, but these will not make it a more accurate value of 1/7.
  id: totrans-94
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 重要的是要意识到，尽管`Float`以任意精度的十进制形式显示，但实际上它以二进制形式存储。一旦创建了`Float`，其二进制信息就以给定的精度设置。该值的准确性不能后续更改；因此，对于3位数精度的1/7，可以用二进制零填充，但这些不会使其成为1/7更准确的值；
- en: 'If inexact, low-precision numbers are involved in a calculation with higher
    precision values, the evalf engine will increase the precision of the low precision
    values and inexact results will be obtained. This is feature of calculations with
    limited precision:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果涉及到不精确、低精度数字与高精度值的计算，则`evalf`引擎将增加低精度值的精度，并获得不精确的结果。这是具有有限精度的计算特性；
- en: '[PRE27]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Although the `evalf` engine tried to maintain 10 digits of precision (since
    that was the highest precision represented) the 3-digit precision used limits
    the accuracy to about 4 digits – not all the digits you see are significant. evalf
    doesn’t try to keep track of the number of significant digits.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管`evalf`引擎尝试维持10位精度（因为那是最高表示的精度），但使用的3位精度限制了精度约为4位数 - 你看到的并非所有位数都是有效的。`evalf`不试图跟踪有效数字的数量；
- en: 'That very simple expression involving the addition of two numbers with different
    precisions will hopefully be instructive in helping you understand why more complicated
    expressions (like trig expressions that may not be simplified) will not evaluate
    to an exact zero even though, with the right simplification, they should be zero.
    Consider this unsimplified trig identity, multiplied by a big number:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 那个非常简单的涉及两个不同精度数字相加的表达式，希望能够帮助你理解为什么更复杂的表达式（比如可能没有简化的三角表达式）即使正确简化也不会评估为精确的零。考虑这个未简化的三角同一式，乘以一个大数：
- en: '[PRE28]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the \(\cos\) and \(\sin\) terms were evaluated to 15 digits of precision
    and multiplied by the big number, they gave a large number that was only precise
    to 15 digits (approximately) and when the 20 digit big number was subtracted the
    result was not zero.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当将`cos`和`sin`项评估为15位精度并乘以大数时，它们给出了一个大约15位精度的大数，当20位大数被减去时，结果不为零；
- en: 'There are three things that will help you obtain more precise numerical values
    for expressions:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 有三件事可以帮助你获得更精确的表达式数值：
- en: '1) Pass the desired substitutions with the call to evaluate. By doing the subs
    first, the `Float` values cannot be updated as necessary. By passing the desired
    substitutions with the call to evalf the ability to re-evaluate as necessary is
    gained and the results are impressively better:'
  id: totrans-102
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 1) 通过调用评估传递所需的替换。通过首先进行替换，可以防止Float值按需更新。通过在evalf调用中传递所需的替换，可以重新评估的能力是获得印象深刻更好的结果：
- en: ''
  id: totrans-103
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-104
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE29]'
- en: ''
  id: totrans-105
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '2) Use Rationals, not Floats. During the evaluation process, the Rational can
    be computed to an arbitrary precision while the Float, once created – at a default
    of 15 digits – cannot. Compare the value of `-1.4e+3` above with the nearly zero
    value obtained when replacing x with a Rational representing 1/10 – before the
    call to evaluate:'
  id: totrans-106
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 2) 使用有理数，而不是浮点数。在评估过程中，有理数可以计算到任意精度，而浮点数一旦创建（默认为15位数字）就不能这样做。将x替换为表示1/10的有理数后，在进行评估之前，将上述-1.4e+3的值与几乎为零的值进行比较：
- en: ''
  id: totrans-107
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-108
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE30]'
- en: ''
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '3) Try to simplify the expression. In this case, SymPy will recognize the trig
    identity and simplify it to zero so you don’t even have to evaluate it numerically:'
  id: totrans-110
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 3) 尝试简化表达式。在这种情况下，SymPy将识别三角恒等式并将其简化为零，因此您甚至不需要数值评估它：
- en: ''
  id: totrans-111
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-112
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '### Immutability of Expressions'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '### 表达式的不可变性'
- en: 'Expressions in SymPy are immutable, and cannot be modified by an in-place operation.
    This means that a function will always return an object, and the original expression
    will not be modified. The following example snippet demonstrates how this works:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在SymPy中，表达式是不可变的，不能通过原位操作修改。这意味着函数始终会返回一个对象，而原始表达式不会被修改。以下示例代码片段演示了这是如何工作的：
- en: '[PRE32]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output shows that the [`subs()`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs") function has replaced variable `x` with variable
    `a`, and variable `y` with variable `b`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示[`subs()`](../modules/core.html#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")
    函数已经用变量`a`替换了变量`x`，并且用变量`b`替换了变量`y`：
- en: '[PRE33]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The [`subs()`](../modules/core.html#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")
    function does not modify the original expression `expr`. Rather, a modified copy
    of the expression is returned. This returned object is stored in the variable
    `expr_modified`. Note that unlike C/C++ and other high-level languages, Python
    does not require you to declare a variable before it is used.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[`subs()`](../modules/core.html#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")
    函数不会修改原始表达式`expr`。相反，它会返回表达式的修改副本。这个返回的对象存储在变量`expr_modified`中。请注意，与C/C++和其他高级语言不同，Python不要求您在使用变量之前声明它。'
- en: Mathematical Operators
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数学运算符
- en: SymPy uses the same default operators as Python. Most of these, like `*/+-`,
    are standard. Aside from integer division discussed in [Python numbers vs. SymPy
    Numbers](#python-vs-sympy-numbers) above, you should also be aware that implied
    multiplication is not allowed. You need to use `*` whenever you wish to multiply
    something. Also, to raise something to a power, use `**`, not `^` as many computer
    algebra systems use. Parentheses `()` change operator precedence as you would
    normally expect.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy使用与Python相同的默认操作符。其中大多数，如 `*/+-`，都是标准的。除了在[Python数字 vs SymPy数字](#python-vs-sympy-numbers)中讨论的整数除法之外，还应注意，隐含乘法是不允许的。每当需要乘以某些东西时，都需要使用
    `*`。此外，要提升某个值的幂，请使用 `**`，而不是许多计算机代数系统使用的 `^`。括号 `()` 可以按您通常预期的方式更改操作符优先级。
- en: 'In **isympy**, with the **ipython** shell:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在**isympy**中，使用**ipython** shell：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Inverse Trig Functions
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反三角函数
- en: SymPy uses different names for some functions than most computer algebra systems.
    In particular, the inverse trig functions use the python names of [`asin`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.asin
    "sympy.functions.elementary.trigonometric.asin"), [`acos`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.acos
    "sympy.functions.elementary.trigonometric.acos") and so on instead of the usual
    `arcsin` and `arccos`. Use the methods described in [Symbols](#symbols) above
    to see the names of all SymPy functions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy对于某些函数使用不同的名称，而不是大多数计算机代数系统所用的通用名称。特别是，反三角函数使用Python的名称[`asin`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.asin
    "sympy.functions.elementary.trigonometric.asin")、[`acos`](../modules/functions/elementary.html#sympy.functions.elementary.trigonometric.acos
    "sympy.functions.elementary.trigonometric.acos")等，而不是通常的`arcsin`和`arccos`。使用上面[符号](#symbols)描述的方法查看所有SymPy函数的名称。
- en: Sqrt is not a Function
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Sqrt 不是一个函数
- en: There is no `sqrt` function in the same way that there is an exponential function
    (`exp`). `sqrt(x)` is used to represent `Pow(x, S(1)/2)` so if you want to know
    if an expression has any square roots in it, `expr.has(sqrt)` will not work. You
    must look for `Pow` with an exponent of one half (or negative one half if it is
    in a denominator, e.g.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqrt` 函数不像指数函数 (`exp`) 那样存在。`sqrt(x)` 用于表示 `Pow(x, S(1)/2)`，因此如果要确定表达式中是否有平方根，`expr.has(sqrt)`
    将无效。必须查找指数为一半的 `Pow`（如果是分母，则为负一半，例如：'
- en: '[PRE35]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: If you are interested in any power of the `sqrt` then the following pattern
    would be appropriate
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对 `sqrt` 的任何幂次方感兴趣，则以下模式是合适的
- en: '[PRE36]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Special Symbols
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特殊符号
- en: The symbols `[]`, `{}`, `=`, and `()` have special meanings in Python, and thus
    in SymPy. See the Python docs linked to above for additional information.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 符号 `[]`, `{}`, `=`, 和 `()` 在Python中有特殊意义，因此在SymPy中也是如此。有关更多信息，请参阅上面链接的Python文档。
- en: '### Lists'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '### 列表'
- en: Square brackets `[]` denote a list. A list is a container that holds any number
    of different objects. A list can contain anything, including items of different
    types. Lists are mutable, which means that you can change the elements of a list
    after it has been created. You access the items of a list also using square brackets,
    placing them after the list or list variable. Items are numbered using the space
    before the item.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 方括号 `[]` 表示列表。列表是一个容器，可以容纳任意数量的不同对象。列表可以包含任何内容，包括不同类型的项目。列表是可变的，这意味着可以在创建后更改列表的元素。还可以使用方括号访问列表或列表变量的项目。项目使用空间号进行编号。
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: List indexes begin at 0.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 列表索引从0开始。
- en: 'Example:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE37]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See the Python docs for more information on lists and the square bracket notation
    for accessing elements of a list.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有关列表和使用方括号访问列表元素的更多信息，请参阅Python文档。
- en: Dictionaries
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 字典
- en: 'Curly brackets `{}` denote a dictionary, or a dict for short. A dictionary
    is an unordered list of non-duplicate keys and values. The syntax is `{key: value}`.
    You can access values of keys using square bracket notation.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '花括号 `{}` 表示字典，简称为 dict。字典是一个无序的非重复键值对列表。语法是 `{key: value}`。可以使用方括号表示法访问键的值。'
- en: '[PRE38]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See the Python docs for more information on dictionaries.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 有关字典的更多信息，请参阅Python文档。
- en: Tuples
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 元组
- en: Parentheses `()`, aside from changing operator precedence and their use in function
    calls, (like `cos(x)`), are also used for tuples. A `tuple` is identical to a
    [list](#lists), except that it is not mutable. That means that you cannot change
    their values after they have been created. In general, you will not need tuples
    in SymPy, but sometimes it can be more convenient to type parentheses instead
    of square brackets.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 括号 `()` 除了改变运算符优先级和在函数调用中的使用（如 `cos(x)`）外，还用于元组。`tuple` 和 [list](#lists) 完全相同，但不可变。这意味着创建后不能更改它们的值。在SymPy中通常不需要使用元组，但有时使用括号代替方括号可能更方便。
- en: '[PRE39]'
  id: totrans-147
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE39]'
- en: ''
  id: totrans-148
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Single element tuples, unlike lists, must have a comma in them:'
  id: totrans-149
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 单元素元组与列表不同，必须在其中包含逗号：
- en: ''
  id: totrans-150
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-151
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE40]'
- en: ''
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Without the comma, a single expression without a comma is not a tuple:'
  id: totrans-153
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 没有逗号，单个表达式没有逗号不是元组：
- en: ''
  id: totrans-154
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE41]'
- en: ''
  id: totrans-156
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'integrate takes a sequence as the second argument if you want to integrate
    with limits (and a tuple or list will work):'
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: integrate 将序列作为第二个参数，如果要带上限积分（列表或元组都可以使用）：
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See the Python docs for more information on tuples.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 有关元组的更多信息，请参阅Python文档。
- en: '### Keyword Arguments'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '### 关键字参数'
- en: Aside from the usage described [above](#equals-signs), equals signs (`=`) are
    also used to give named arguments to functions. Any function that has `key=value`
    in its parameters list (see below on how to find this out), then `key` is set
    to `value` by default. You can change the value of the key by supplying your own
    value using the equals sign in the function call. Also, functions that have `**`
    followed by a name in the parameters list (usually `**kwargs` or `**assumptions`)
    allow you to add any number of `key=value` pairs that you want, and they will
    all be evaluated according to the function.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上述用法外，等号 (`=`) 还用于将命名参数传递给函数。任何在参数列表中带有 `key=value` 的函数（请参阅下面如何查找此信息），则默认情况下将
    `key` 设置为 `value`。您可以通过在函数调用中使用等号更改键的值。还有一些带有参数列表中的 `**` 后面跟有名称的函数（通常是 `**kwargs`
    或 `**assumptions`），允许您添加任意数量的 `key=value` 对，它们将根据函数进行评估。
- en: '`sqrt(x**2)` doesn’t auto simplify to x because x is assumed to be complex
    by default, and, for example, `sqrt((-1)**2) == sqrt(1) == 1 != -1`:'
  id: totrans-164
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`sqrt(x**2)` 不会自动简化为 x，因为默认情况下假定 x 是复数，并且，例如，`sqrt((-1)**2) == sqrt(1) == 1
    != -1`：'
- en: ''
  id: totrans-165
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-166
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE43]'
- en: ''
  id: totrans-167
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Giving assumptions to Symbols is an example of using the keyword argument:'
  id: totrans-168
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 给 Symbols 添加假设是使用关键字参数的示例：
- en: ''
  id: totrans-169
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-170
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE44]'
- en: ''
  id: totrans-171
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The square root will now simplify since it knows that `x >= 0`:'
  id: totrans-172
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，平方根会简化，因为它知道 `x >= 0`：
- en: ''
  id: totrans-173
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-174
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE45]'
- en: ''
  id: totrans-175
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'powsimp has a default argument of `combine=''all''`:'
  id: totrans-176
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '`powsimp` 的默认参数为 `combine=''all''`：'
- en: ''
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE46]'
- en: ''
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Setting combine to the default value is the same as not setting it.
  id: totrans-180
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 将 `combine` 设置为默认值等同于不设置它。
- en: ''
  id: totrans-181
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-182
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE47]'
- en: ''
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The non-default options are `'exp'`, which combines exponents…
  id: totrans-184
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 非默认选项是 `'exp'`，它结合指数…
- en: ''
  id: totrans-185
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …and ‘base’, which combines bases.
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: …和‘base’，它合并基数。
- en: ''
  id: totrans-189
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-190
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Note
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: See the Python docs for more information on function parameters.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 有关函数参数的更多信息，请参阅 Python 文档。
- en: Getting help from within SymPy
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 SymPy 中获取帮助
- en: help()
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 帮助()
- en: 'Although all docs are available at [docs.sympy.org](https://docs.sympy.org/)
    or on the [SymPy Wiki](https://wiki.sympy.org/), you can also get info on functions
    from within the Python interpreter that runs SymPy. The easiest way to do this
    is to do `help(function)`, or `function?` if you are using **ipython**:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有文档都可以在 [docs.sympy.org](https://docs.sympy.org/) 或 [SymPy Wiki](https://wiki.sympy.org/)
    上找到，但您也可以从运行 SymPy 的 Python 解释器内部获取函数信息。最简单的方法是执行 `help(function)` 或者在使用 **ipython**
    时执行 `function?`：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'These will give you the function parameters and docstring for [`powsimp()`](../modules/simplify/simplify.html#sympy.simplify.powsimp.powsimp
    "sympy.simplify.powsimp.powsimp"). The output will look something like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将为您提供 [`powsimp()`](../modules/simplify/simplify.html#sympy.simplify.powsimp.powsimp
    "sympy.simplify.powsimp.powsimp") 的函数参数和文档字符串。输出将类似于以下内容：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Reduce expression by combining powers with similar bases and exponents.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 通过合并具有相似基数和指数的幂来简化表达式。
- en: Explanation
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 解释
- en: If `deep` is `True` then powsimp() will also simplify arguments of functions.
    By default `deep` is set to `False`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `deep` 是 `True`，那么 powsimp() 还将简化函数的参数。默认情况下，`deep` 设置为 `False`。
- en: If `force` is `True` then bases will be combined without checking for assumptions,
    e.g. sqrt(x)*sqrt(y) -> sqrt(x*y) which is not true if x and y are both negative.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `force` 是 `True`，则将合并基数而不检查假设，例如，sqrt(x)*sqrt(y) -> sqrt(x*y)，如果 x 和 y 都是负数，则不成立。
- en: 'You can make powsimp() only combine bases or only combine exponents by changing
    combine=’base’ or combine=’exp’. By default, combine=’all’, which does both. combine=’base’
    will only combine:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过更改 `combine='base'` 或 `combine='exp'` 使 powsimp() 仅组合基数或仅组合指数。默认情况下，`combine='all'`，即两者都做。`combine='base'`
    仅会组合：
- en: '[PRE52]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: and combine=’exp’ will only combine
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 并且 `combine='exp'` 将仅组合
- en: '[PRE53]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: combine=’exp’ will strictly only combine exponents in the way that used to be
    automatic. Also use deep=True if you need the old behavior.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`combine=''exp''` 严格只组合以前自动完成的指数方式。如果需要旧行为，请同时使用 `deep=True`。'
- en: When combine=’all’, ‘exp’ is evaluated first. Consider the first example below
    for when there could be an ambiguity relating to this. This is done so things
    like the second example can be completely combined. If you want ‘base’ combined
    first, do something like powsimp(powsimp(expr, combine=’base’), combine=’exp’).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `combine='all'` 时，首先评估 'exp'。考虑下面的第一个例子，当可能涉及此问题时可能会出现歧义。这样做是为了完全组合类似第二个例子的内容。如果您希望首先组合
    'base'，请像这样执行 powsimp(powsimp(expr, combine='base'), combine='exp')。
- en: Examples
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Radicals with Mul bases will be combined if combine=’exp’
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `combine='exp'`，则具有 Mul 基数的根号将被组合
- en: '[PRE57]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Two radicals are automatically joined through Mul:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 两个根号会通过 Mul 自动连接：
- en: '[PRE58]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'But if an integer power of that radical has been autoexpanded then Mul does
    not join the resulting factors:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果根号的整数次幂已经自动展开，则 Mul 不会连接结果因子：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
