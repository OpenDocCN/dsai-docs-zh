- en: Autolev Parser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/physics/mechanics/autolev_parser.html](https://docs.sympy.org/latest/modules/physics/mechanics/autolev_parser.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## Introduction'
  prefs: []
  type: TYPE_NORMAL
- en: Autolev (now superseded by MotionGenesis) is a domain specific language used
    for symbolic multibody dynamics. The SymPy mechanics module now has enough power
    and functionality to be a fully featured symbolic dynamics module. This parser
    parses Autolev (version 4.1) code to SymPy code by making use of SymPy’s math
    libraries and the mechanics module.
  prefs: []
  type: TYPE_NORMAL
- en: The parser has been built using the [ANTLR](https://www.antlr.org/) framework
    and its main purpose is to help former users of Autolev to get familiarized with
    multibody dynamics in SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: The sections below shall discuss details of the parser like usage, gotchas,
    issues and future improvements. For a detailed comparison of Autolev and SymPy
    Mechanics you might want to look at the [SymPy Mechanics for Autolev Users guide](sympy_mechanics_for_autolev_users.html#sympy-mechanics-for-autolev-users).
  prefs: []
  type: TYPE_NORMAL
- en: '## Usage'
  prefs: []
  type: TYPE_NORMAL
- en: We first start with an Autolev code file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take this example (Comments `%` have been included to show the Autolev
    responses):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The parser can be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The commented code is not part of the output code. The print statements demonstrate
    how to get responses similar to the ones in the Autolev file. Note that we need
    to use SymPy functions like `.ang_vel_in()`, `.dcm()` etc in many cases unlike
    directly printing out the variables like `zero`. If you are completely new to
    SymPy mechanics, the [SymPy Mechanics for Autolev Users guide](sympy_mechanics_for_autolev_users.html#sympy-mechanics-for-autolev-users)
    guide should help. You might also have to use basic SymPy simplifications and
    manipulations like `trigsimp()`, `expand()`, `evalf()` etc for getting outputs
    similar to Autolev. Refer to the [SymPy Tutorial](https://docs.sympy.org/latest/tutorial/index.html)
    to know more about these.  ## Gotchas'
  prefs: []
  type: TYPE_NORMAL
- en: 'Don’t use variable names that conflict with Python’s reserved words. This is
    one example where this is violated:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the names of vectors and scalars are different. Autolev treats
    these differently but these will get overwritten in Python. The parser currently
    allows the names of bodies and scalars/vectors to coincide but doesn’t do this
    between scalars and vectors. This should probably be changed in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with Matrices returned by functions, one must check the order of
    the values as they may not be the same as in Autolev. This is especially the case
    for eigenvalues and eigenvectors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: When using `EVALUATE`, use something like `90*UNITS(deg,rad)` for angle substitutions
    as radians are the default in SymPy. You could also add `np.deg2rad()` directly
    in the SymPy code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This need not be done for the output code (generated on parsing the `CODE` commands)
    as the parser takes care of this when `deg` units are given in the `INPUT` declarations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `DEGREES` setting, on the other hand, works only in some cases like in `SIMPROT`
    where an angle is expected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Most of the Autolev settings have not been parsed and have no effect on the
    parser. The only ones that work somewhat are `COMPLEX` and `DEGREES`. It is advised
    to look into alternatives to these in SymPy and Python.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The `REPRESENT` command is not supported. Use the `MATRIX`, `VECTOR` or `DYADIC`
    commands instead. Autolev 4.1 suggests these over `REPRESENT` as well while still
    allowing it but the parser doesn’t parse it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Do not use variables declarations of the type `WO{3}RD{2,4}`. The parser can
    only handle one variable name followed by one pair of curly braces and any number
    of `'` s. You would have to declare all the cases manually if you want to achieve
    something like `WO{3}RD{2,4}`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parser can handle normal versions of most commands but it may not parse
    functions with Matrix arguments properly in most cases. Eg:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`M=COEF([E1;E2],[U1,U2,U3])`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This would compute the coefficients of `U1`, `U2` and `U3` in `E1` and `E2`.
    It is preferable to manually construct a Matrix using the regular versions of
    these commands.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '`MOTIONVARIABLE` declarations must be used for the generalized coordinates
    and speeds and all other variables must be declared in regular `VARIABLE` declarations.
    The parser requires this to distinguish between them to pass the correct parameters
    to the Kane’s method object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also preferred to always declare the speeds corresponding to the coordinates
    and to pass in the kinematic differential equations. The parser is able to handle
    some cases where this isn’t the case by introducing some dummy variables of its
    own but SymPy on its own does require them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also note that older Autolev declarations like `VARIABLES U{3}'` are not supported
    either.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Need to change `me.dynamicsymbols._t` to `me.dynamicsymbols('t')` for all occurrences
    of it in the Kane’s equations. For example have a look at line 10 of this [spring
    damper example](https://github.com/sympy/sympy/blob/master/sympy/parsing/autolev/test-examples/pydy-example-repo/mass_spring_damper.py#L10).
    This equation is used in forming the Kane’s equations so we need to change `me.dynamicsymbols._t`
    to `me.dynamicsymbols('t')` in this case.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main reason that this needs to be done is because PyDy requires time dependent
    specifieds to be explicitly laid out while Autolev simply takes care of the stray
    time variables in the equations by itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The problem is that PyDy’s System class does not accept `dynamicsymbols._t`
    as a specified. Refer to issue [#396](https://github.com/pydy/pydy/issues/396).
    This change is not actually ideal so a better solution should be figured out in
    the future.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: The parser creates SymPy `symbols` and `dynamicsymbols` by parsing variable
    declarations in the Autolev Code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For intermediate expressions which are directly initialized the parser does
    not create SymPy symbols. It just assigns them to the expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the other hand, when a declared variable is assigned to an expression, the
    parser stores the expression against the variable in a dictionary so as to not
    reassign it to a completely different entity. This constraint is due to the inherent
    nature of Python and how it differs from a language like Autolev.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Also, Autolev seems to be able to assume whether to use a variable or the rhs
    expression that variable has been assigned to in equations even without an explicit
    `RHS()` call in some cases. For the parser to work correctly however, it is better
    to use `RHS()` wherever a variable’s rhs expression is meant to be used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the `SOLVE` command is parsed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The indexing like `[x]` and `[y]` doesn’t always work so you might want to look
    at the underlying dictionary that solve returns and index it correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inertia declarations and Inertia functions work somewhat differently in the
    context of the parser. This might be hard to understand at first but this had
    to be done to bridge the gap due to the differences in SymPy and Autolev. Here
    are some points about them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1\. Inertia declarations (`INERTIA B,I1,I2,I3`) set the inertias of rigid bodies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 2\. Inertia setters of the form `I_C_D>> = expr` however, set the inertias only
    when C is a body. If C is a particle then `I_C_D>> = expr` simply parses to `i_c_d
    = expr` and `i_c_d` acts like a regular variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 3\. When it comes to inertia getters (`I_C_D>>` used in an expression or `INERTIA`
    commands), these MUST be used with the `EXPRESS` command to specify the frame
    as SymPy needs this information to compute the inertia dyadic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: In an inertia declaration of a body, if the inertia is being set about a point
    other than the center of mass, one needs to make sure that the position vector
    setter for that point and the center of mass appears before the inertia declaration
    as SymPy will throw an error otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that all Autolev commands have not been implemented. The parser now covers
    the important ones in their basic forms. If you are doubtful whether a command
    is included or not, please have a look at [this file](https://github.com/sympy/sympy/blob/master/sympy/parsing/autolev/_listener_autolev_antlr.py)
    in the source code. Search for “<command>” to verify this. Looking at the code
    for the specific command will also give an idea about what form it is expected
    to work in.  ## Limitations and Issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A lot of the issues have already been discussed in the Gotchas section. Some
    of these are:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vector names coinciding with scalar names are overwritten in Python.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some convenient variable declarations aren’t parsed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some convenient forms of functions to return matrices aren’t parsed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Settings aren’t parsed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: symbols and rhs expressions work very differently in Python which might cause
    undesirable results.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Dictionary indexing for the parsed code of the `SOLVE` command is not proper
    in many cases.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Need to change `dynamicsymbols._t` to `dynamicsymbols('t')` for the PyDy simulation
    code to work properly.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some other ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Eigenvectors do not seem to work as expected. The values in Autolev and SymPy
    are not the same in many cases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Block matrices aren’t parsed by the parser. It would actually be easier to make
    a change in SymPy to allow matrices to accept other matrices for arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SymPy equivalent of the `TAYLOR` command `.series()` does not work with
    `dynamicsymbols()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only `DEPENDENT` constraints are currently parsed. Need to parse `AUXILIARY`
    constraints as well. This should be done soon as it isn’t very difficult.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: None of the energy and momentum functions are parsed right now. It would be
    nice to get these working as well. Some changes should probably be made to SymPy.
    For instance, SymPy doesn’t have a function equivalent to `NICHECK()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The numerical integration parts work properly only in the case of the `KANE`
    command with no arguments. Things like `KANE(F1,F2)` do not currently work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Also, the PyDy numerical simulation code works only for cases where the matrix
    say `ZERO = FR() + FRSTAR()` is solved for. It doesn’t work well when the matrix
    has some other equations plugged in as well. One hurdle faced in achieving this
    was that PyDy’s System class automatically takes in the `forcing_full` and `mass_matrix_full`
    and solves them without giving the user the flexibility to specify the equations.
    It would be nice to add this functionality to the System class.  ## Future Improvements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1\. Completing Dynamics Online
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The parser has been built by referring to and parsing codes from the [Autolev
    Tutorial](https://mae.ufl.edu/~fregly/PDFs/autolev_tutorial.pdf) and the book
    *Dynamics Online: Theory and Implementation Using Autolev*. Basically, the process
    involved going through each of these codes, validating the parser results and
    improving the rules if required to make sure the codes parsed well.'
  prefs: []
  type: TYPE_NORMAL
- en: The parsed codes of these are available on GitLab [here](https://gitlab.com/sympy/autolev-test-examples).
    The repo is private so access needs to be requested. As of now, most codes till
    Chapter 4 of *Dynamics Online* have been parsed.
  prefs: []
  type: TYPE_NORMAL
- en: Completing all the remaining codes of the book (namely, *2-10*, *2-11*, *rest
    of Ch4*, *Ch5* and *Ch6* (less important) ) would make the parser more complete.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Fixing Issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The second thing to do would be to go about fixing the problems described above
    in the [Gotchas](#gotchas-autolev) and [Limitations and Issues](#issues) sections
    in order of priority and ease. Many of these require changes in the parser code
    while some of these are better fixed by adding some functionality to SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Switching to an AST
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The parser is currently built using a kind of Concrete Syntax Tree (CST) using
    the [ANTLR](https://www.antlr.org/) framework. It would be ideal to switch from
    a CST to an Abstract Syntax Tree (AST). This way, the parser code will be independent
    of the ANTLR grammar which makes it a lot more flexible. It would also be easier
    to make changes to the grammar and the rules of the parser.
  prefs: []
  type: TYPE_NORMAL
