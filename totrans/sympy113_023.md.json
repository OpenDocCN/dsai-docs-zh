["```py\n>>> from sympy import symbols, Function\n>>> x = symbols('x')\n>>> f = Function('f') \n```", "```py\n>>> f(x)\nf(x)\n>>> f(0)\nf(0) \n```", "```py\n>>> from sympy.abc import x, y\n>>> y.diff(x)\n0 \n```", "```py\n>>> y = Function('y')\n>>> y(x).diff(x)\nDerivative(y(x), x) \n```", "```py\n>>> g = Function('g', real=True) \n```", "```py\n>>> g(x)\ng(x)\n>>> g(x).is_real\nTrue \n```", "```py\n>>> def f(x):\n...     if x == 0:\n...         return 0\n...     else:\n...         return x + 1 \n```", "```py\n>>> f(0)\n0\n>>> f(1)\n2\n>>> f(x)\nx + 1 \n```", "```py\n>>> from sympy import Piecewise, Eq, pprint\n>>> f = Piecewise((0, Eq(x, 0)), (x + 1, True)) \n```", "```py\n>>> pprint(f, use_unicode=True)\n⎧  0    for x = 0\n⎨\n⎩x + 1  otherwise\n>>> f.subs(x, 0)\n0\n>>> f.subs(x, 1)\n2 \n```", "```py\n>>> from sympy import lambdify\n>>> func = lambdify(x, Piecewise((0, Eq(x, 0)), (x + 1, True)))\n>>> import numpy as np \n>>> func(np.arange(5)) \narray([0., 2., 3., 4., 5.]) \n```", "```py\n>>> class versin(Function):\n...     pass \n```", "```py\n>>> versin(x)\nversin(x)\n>>> isinstance(versin(x), versin)\nTrue \n```", "```py\n>>> from sympy import pi, Integer\n>>> class versin(Function):\n...    @classmethod\n...    def eval(cls, x):\n...        # If x is an integer multiple of pi, x/pi will cancel and be an Integer\n...        n = x/pi\n...        if isinstance(n, Integer):\n...            return 1 - (-1)**n \n```", "```py\n>>> versin(pi)\n2\n>>> versin(2*pi)\n0 \n```", "```py\n>>> versin(x*pi)\nversin(pi*x) \n```", "```py\n>>> class f(Function):\n...     @classmethod\n...     def eval(cls, x, y=1, *args):\n...         return None \n```", "```py\n>>> f(1).args\n(1,)\n>>> f(1, 2).args\n(1, 2)\n>>> f(1, 2, 3).args\n(1, 2, 3) \n```", "```py\n    >>> from sympy import cos\n    >>> class versin(Function):\n    ...     @classmethod\n    ...     def eval(cls, x):\n    ...         # !! Not actually a good eval() method !!\n    ...         return 1 - cos(x) \n    ```", "```py\n    >>> from sympy import Add, sin\n    >>> class versin(Function):\n    ...     @classmethod\n    ...     def eval(cls, x):\n    ...         # !! Not actually a good eval() method !!\n    ...         if isinstance(x, Add):\n    ...             a, b = x.as_two_terms()\n    ...             return (versin(a)*versin(b) - versin(a) - versin(b)\n    ...                     - sin(a)*sin(b) + 1) \n    ```", "```py\n    >>> x, y, z = symbols('x y z')\n    >>> versin(x + y)\n    -sin(x)*sin(y) + versin(x)*versin(y) - versin(x) - versin(y) + 1 \n    ```", "```py\n    >>> class versin(Function):\n    ...     @classmethod\n    ...     def eval(cls, x):\n    ...         # !! Not actually a good eval() method !!\n    ...         if isinstance(x, Add):\n    ...             a, b = x.as_two_terms()\n    ...             return (versin(a)*versin(b) - versin(a) - versin(b)\n    ...                     - sin(a)*sin(b) + 1)\n    ...\n    ...     def fdiff(self, argindex=1):\n    ...         return sin(self.args[0]) \n    ```", "```py\n    >>> versin(x + y).diff(x)\n    sin(x)*versin(y) - sin(x) - sin(y)*cos(x) \n    ```", "```py\n    >>> versin(x + y + z)\n    (-sin(y)*sin(z) + versin(y)*versin(z) - versin(y) - versin(z) +\n    1)*versin(x) - sin(x)*sin(y + z) + sin(y)*sin(z) - versin(x) -\n    versin(y)*versin(z) + versin(y) + versin(z) \n    ```", "```py\n    >>> class divides(Function):\n    ...     @classmethod\n    ...     def eval(cls, m, n):\n    ...         # !! Not actually a good eval() method !!\n    ...\n    ...         # Evaluate for explicit integer m and n. This part is fine.\n    ...         if isinstance(m, Integer) and isinstance(n, Integer):\n    ...             return int(n % m == 0)\n    ...\n    ...         # For symbolic arguments, require m and n to be integer.\n    ...         # If we write the logic this way, we will run into trouble.\n    ...         if not m.is_integer or not n.is_integer:\n    ...             raise TypeError(\"m and n should be integers\") \n    ```", "```py\n    >>> n, m = symbols('n m')\n    >>> print(n.is_integer)\n    None\n    >>> divides(m, n)\n    Traceback (most recent call last):\n    ...\n    TypeError: m and n should be integers \n    ```", "```py\n    >>> n, m = symbols('n m', integer=True)\n    >>> divides(m, n)\n    divides(m, n) \n    ```", "```py\n    >>> # n and m are still defined as integer=True as above\n    >>> divides(2, (m**2 + m)/2)\n    Traceback (most recent call last):\n    ...\n    TypeError: m and n should be integers \n    ```", "```py\n    >>> print(((m**2 + m)/2).is_integer)\n    None \n    ```", "```py\n    >>> class divides(Function):\n    ...     @classmethod\n    ...     def eval(cls, m, n):\n    ...         # Evaluate for explicit integer m and n. This part is fine.\n    ...         if isinstance(m, Integer) and isinstance(n, Integer):\n    ...             return int(n % m == 0)\n    ...\n    ...         # For symbolic arguments, require m and n to be integer.\n    ...         # This is the better way to write this logic.\n    ...         if m.is_integer is False or n.is_integer is False:\n    ...             raise TypeError(\"m and n should be integers\") \n    ```", "```py\n    >>> divides(1.5, 1)\n    Traceback (most recent call last):\n    ...\n    TypeError: m and n should be integers \n    ```", "```py\n    >>> divides(2, (m**2 + m)/2)\n    divides(2, m**2/2 + m/2)\n    >>> _.subs(m, 2)\n    0\n    >>> n, m = symbols('n m') # Redefine n and m without the integer assumption\n    >>> divides(m, n)\n    divides(m, n) \n    ```", "```py\n>>> class divides(Function):\n...     is_integer = True\n...     is_negative = False \n```", "```py\n>>> divides(m, n).is_integer\nTrue\n>>> divides(m, n).is_nonnegative\nTrue \n```", "```py\n>>> from sympy import I\n>>> 1 - cos(pi + I*pi)\n1 + cosh(pi)\n>>> (1 - cos(pi + I*pi)).evalf()\n12.5919532755215 \n```", "```py\n>>> from sympy.core.logic import fuzzy_and, fuzzy_not\n>>> class versin(Function):\n...     def _eval_is_nonnegative(self):\n...         # versin(x) is nonnegative if x is real\n...         x = self.args[0]\n...         if x.is_real is True:\n...             return True\n...\n...     def _eval_is_positive(self):\n...         # versin(x) is positive if x is real and not an even multiple of pi\n...         x = self.args[0]\n...\n...         # x.as_independent(pi, as_Add=False) will split x as a Mul of the\n...         # form coeff*pi\n...         coeff, pi_ = x.as_independent(pi, as_Add=False)\n...         # If pi_ = pi, x = coeff*pi. Otherwise x is not (structurally) of\n...         # the form coeff*pi.\n...         if pi_ == pi:\n...             return fuzzy_and([x.is_real, fuzzy_not(coeff.is_even)])\n...         elif x.is_real is False:\n...             return False\n...         # else: return None. We do not know for sure whether x is an even\n...         # multiple of pi \n```", "```py\n>>> versin(1).is_nonnegative\nTrue\n>>> versin(2*pi).is_positive\nFalse\n>>> versin(3*pi).is_positive\nTrue \n```", "```py\n>>> versin(1).is_real\nTrue \n```", "```py\n>>> n = symbols('n', integer=True)\n>>> versin(2*n*pi).is_zero\nTrue \n```", "```py\n>>> from sympy import sin\n>>> class versin(Function):\n...     def _eval_evalf(self, prec):\n...         return (2*sin(self.args[0]/2)**2)._eval_evalf(prec) \n```", "```py\n>>> versin(1).evalf()\n0.459697694131860 \n```", "```py\n>>> versin(1.)\n0.459697694131860 \n```", "```py\n>>> sin(x).rewrite(cos)\ncos(x - pi/2) \n```", "```py\n>>> class versin(Function):\n...     def _eval_rewrite(self, rule, args, **hints):\n...         if rule == cos:\n...             return 1 - cos(*args)\n>>> versin(x).rewrite(cos)\n1 - cos(x) \n```", "```py\n>>> from sympy import simplify\n>>> simplify(versin(x) + cos(x))\n1 \n```", "```py\n>>> from sympy import Integer\n>>> class divides(Function):\n...     # Define evaluation on basic inputs, as well as type checking that the\n...     # inputs are not nonintegral.\n...     @classmethod\n...     def eval(cls, m, n):\n...         # Evaluate for explicit integer m and n.\n...         if isinstance(m, Integer) and isinstance(n, Integer):\n...             return int(n % m == 0)\n...\n...         # For symbolic arguments, require m and n to be integer.\n...         if m.is_integer is False or n.is_integer is False:\n...             raise TypeError(\"m and n should be integers\")\n...\n...     # Define doit() as further evaluation on symbolic arguments using\n...     # assumptions.\n...     def doit(self, deep=False, **hints):\n...         m, n = self.args\n...         # Recursively call doit() on the args whenever deep=True.\n...         # Be sure to pass deep=True and **hints through here.\n...         if deep:\n...            m, n = m.doit(deep=deep, **hints), n.doit(deep=deep, **hints)\n...\n...         # divides(m, n) is 1 iff n/m is an integer. Note that m and n are\n...         # already assumed to be integers because of the logic in eval().\n...         isint = (n/m).is_integer\n...         if isint is True:\n...             return Integer(1)\n...         elif isint is False:\n...             return Integer(0)\n...         else:\n...             return divides(m, n) \n```", "```py\n>>> n, m, k = symbols('n m k', integer=True)\n>>> divides(k, k*n)\ndivides(k, k*n)\n>>> divides(k, k*n).doit()\n1 \n```", "```py\n>>> from sympy import Number\n>>> class FMA(Function):\n...  \"\"\"\n...     FMA(x, y, z) = x*y + z\n...     \"\"\"\n...     @classmethod\n...     def eval(cls, x, y, z):\n...         # Number is the base class of Integer, Rational, and Float\n...         if all(isinstance(i, Number) for i in [x, y, z]):\n...            return x*y + z\n...\n...     def doit(self, deep=True, **hints):\n...         x, y, z = self.args\n...         # Recursively call doit() on the args whenever deep=True.\n...         # Be sure to pass deep=True and **hints through here.\n...         if deep:\n...             x = x.doit(deep=deep, **hints)\n...             y = y.doit(deep=deep, **hints)\n...             z = z.doit(deep=deep, **hints)\n...         return x*y + z \n```", "```py\n>>> x, y, z = symbols('x y z')\n>>> FMA(x, y, z)\nFMA(x, y, z)\n>>> FMA(x, y, z).doit()\nx*y + z \n```", "```py\n>>> from sympy import expand_trig\n>>> y = symbols('y')\n>>> class versin(Function):\n...    def _eval_expand_trig(self, **hints):\n...        x = self.args[0]\n...        return expand_trig(1 - cos(x))\n>>> versin(x + y).expand(trig=True)\nsin(x)*sin(y) - cos(x)*cos(y) + 1 \n```", "```py\n>>> class versin(Function):\n...     def fdiff(self, argindex=1):\n...         # argindex indexes the args, starting at 1\n...         return sin(self.args[0]) \n```", "```py\n>>> versin(x).diff(x)\nsin(x)\n>>> versin(x**2).diff(x)\n2*x*sin(x**2)\n>>> versin(x + y).diff(x)\nsin(x + y) \n```", "```py\n>>> from sympy import Number, symbols\n>>> x, y, z = symbols('x y z')\n>>> class FMA(Function):\n...  \"\"\"\n...     FMA(x, y, z) = x*y + z\n...     \"\"\"\n...     def fdiff(self, argindex):\n...         # argindex indexes the args, starting at 1\n...         x, y, z = self.args\n...         if argindex == 1:\n...             return y\n...         elif argindex == 2:\n...             return x\n...         elif argindex == 3:\n...             return 1 \n```", "```py\n>>> FMA(x, y, z).diff(x)\ny\n>>> FMA(x, y, z).diff(y)\nx\n>>> FMA(x, y, z).diff(z)\n1\n>>> FMA(x**2, x + 1, y).diff(x)\nx**2 + 2*x*(x + 1) \n```", "```py\n>>> from sympy.core.function import ArgumentIndexError\n>>> class f(Function):\n...    @classmethod\n...    def eval(cls, x, y):\n...        pass\n...\n...    def fdiff(self, argindex):\n...        if argindex == 1:\n...           return 1\n...        raise ArgumentIndexError(self, argindex) \n```", "```py\n>>> f(x, y).diff(x)\n1\n>>> f(x, y).diff(y)\nDerivative(f(x, y), y) \n```", "```py\n>>> from sympy import latex\n>>> class divides(Function):\n...     def _latex(self, printer):\n...         m, n = self.args\n...         _m, _n = printer._print(m), printer._print(n)\n...         return r'\\left [ %s \\middle | %s \\right ]' % (_m, _n) \n```", "```py\n>>> print(latex(divides(m, n)))\n\\left [ m \\middle | n \\right ] \n```", "```py\n>>> class aversin(Function):\n...     def inverse(self, argindex=1):\n...         return versin \n```", "```py\n>>> from sympy import solve\n>>> solve(aversin(x) - y, x)\n[versin(y)] \n```", "```py\n>>> class versin(Function):\n...     def as_real_imag(self, deep=True, **hints):\n...         return (1 - cos(self.args[0])).as_real_imag(deep=deep, **hints)\n>>> versin(x).as_real_imag()\n(-cos(re(x))*cosh(im(x)) + 1, sin(re(x))*sinh(im(x))) \n```", "```py\n>>> versin(x).expand(complex=True)\nI*sin(re(x))*sinh(im(x)) - cos(re(x))*cosh(im(x)) + 1 \n```", "```py\n>>> from sympy import Function, cos, expand_trig, Integer, pi, sin\n>>> from sympy.core.logic import fuzzy_and, fuzzy_not\n>>> class versin(Function):\n...  r\"\"\"\n...     The versine function.\n...\n...     $\\operatorname{versin}(x) = 1 - \\cos(x) = 2\\sin(x/2)^2.$\n...\n...     Geometrically, given a standard right triangle with angle x in the\n...     unit circle, the versine of x is the positive horizontal distance from\n...     the right angle of the triangle to the rightmost point on the unit\n...     circle. It was historically used as a more numerically accurate way to\n...     compute 1 - cos(x), but it is rarely used today.\n...\n...     References\n...     ==========\n...\n...     .. [1] https://en.wikipedia.org/wiki/Versine\n...     .. [2] https://blogs.scientificamerican.com/roots-of-unity/10-secret-trig-functions-your-math-teachers-never-taught-you/\n...     \"\"\"\n...     # Define evaluation on basic inputs.\n...     @classmethod\n...     def eval(cls, x):\n...         # If x is an explicit integer multiple of pi, x/pi will cancel and\n...         # be an Integer.\n...         n = x/pi\n...         if isinstance(n, Integer):\n...             return 1 - (-1)**n\n...\n...     # Define numerical evaluation with evalf().\n...     def _eval_evalf(self, prec):\n...         return (2*sin(self.args[0]/2)**2)._eval_evalf(prec)\n...\n...     # Define basic assumptions.\n...     def _eval_is_nonnegative(self):\n...         # versin(x) is nonnegative if x is real\n...         x = self.args[0]\n...         if x.is_real is True:\n...             return True\n...\n...     def _eval_is_positive(self):\n...         # versin(x) is positive if x is real and not an even multiple of pi\n...         x = self.args[0]\n...\n...         # x.as_independent(pi, as_Add=False) will split x as a Mul of the\n...         # form n*pi\n...         coeff, pi_ = x.as_independent(pi, as_Add=False)\n...         # If pi_ = pi, x = coeff*pi. Otherwise pi_ = 1 and x is not\n...         # (structurally) of the form n*pi.\n...         if pi_ == pi:\n...             return fuzzy_and([x.is_real, fuzzy_not(coeff.is_even)])\n...         elif x.is_real is False:\n...             return False\n...         # else: return None. We do not know for sure whether x is an even\n...         # multiple of pi\n...\n...     # Define the behavior for various simplification and rewriting\n...     # functions.\n...     def _eval_rewrite(self, rule, args, **hints):\n...         if rule == cos:\n...             return 1 - cos(*args)\n...         elif rule == sin:\n...             return 2*sin(x/2)**2\n...\n...     def _eval_expand_trig(self, **hints):\n...         x = self.args[0]\n...         return expand_trig(1 - cos(x))\n...\n...     def as_real_imag(self, deep=True, **hints):\n...         # reuse _eval_rewrite(cos) defined above\n...         return self.rewrite(cos).as_real_imag(deep=deep, **hints)\n...\n...     # Define differentiation.\n...     def fdiff(self, argindex=1):\n...         return sin(self.args[0]) \n```", "```py\n>>> x, y = symbols('x y')\n>>> versin(x)\nversin(x)\n>>> versin(2*pi)\n0\n>>> versin(1.0)\n0.459697694131860 \n```", "```py\n>>> n = symbols('n', integer=True)\n>>> versin(n).is_real\nTrue\n>>> versin((2*n + 1)*pi).is_positive\nTrue\n>>> versin(2*n*pi).is_zero\nTrue\n>>> print(versin(n*pi).is_positive)\nNone\n>>> r = symbols('r', real=True)\n>>> print(versin(r).is_positive)\nNone\n>>> nr = symbols('nr', real=False)\n>>> print(versin(nr).is_nonnegative)\nNone \n```", "```py\n>>> a, b = symbols('a b', real=True)\n>>> from sympy import I\n>>> versin(x).rewrite(cos)\n1 - cos(x)\n>>> versin(x).rewrite(sin)\n2*sin(x/2)**2\n>>> versin(2*x).expand(trig=True)\n2 - 2*cos(x)**2\n>>> versin(a + b*I).expand(complex=True)\nI*sin(a)*sinh(b) - cos(a)*cosh(b) + 1 \n```", "```py\n>>> versin(x).diff(x)\nsin(x) \n```", "```py\n>>> class aversin(Function):\n...     def inverse(self, argindex=1):\n...         return versin\n>>> from sympy import solve\n>>> solve(aversin(x**2) - y, x)\n[-sqrt(versin(y)), sqrt(versin(y))] \n```", "```py\n>>> from sympy import Function, Integer\n>>> from sympy.core.logic import fuzzy_not\n>>> class divides(Function):\n...  r\"\"\"\n...     $$\\operatorname{divides}(m, n) = \\begin{cases} 1 & \\text{for}\\: m \\mid n \\\\ 0 & \\text{for}\\: m\\not\\mid n  \\end{cases}.$$\n...\n...     That is, ``divides(m, n)`` is ``1`` if ``m`` divides ``n`` and ``0``\n...     if ``m`` does not divide ``n`. It is undefined if ``m`` or ``n`` are\n...     not integers. For simplicity, the convention is used that\n...     ``divides(m, 0) = 1`` for all integers ``m``.\n...\n...     References\n...     ==========\n...\n...     .. [1] https://en.wikipedia.org/wiki/Divisor#Definition\n...     \"\"\"\n...     # Define evaluation on basic inputs, as well as type checking that the\n...     # inputs are not nonintegral.\n...     @classmethod\n...     def eval(cls, m, n):\n...         # Evaluate for explicit integer m and n.\n...         if isinstance(m, Integer) and isinstance(n, Integer):\n...             return int(n % m == 0)\n...\n...         # For symbolic arguments, require m and n to be integer.\n...         if m.is_integer is False or n.is_integer is False:\n...             raise TypeError(\"m and n should be integers\")\n...\n...     # Define basic assumptions.\n...\n...     # divides is always either 0 or 1.\n...     is_integer = True\n...     is_negative = False\n...\n...     # Whether divides(m, n) is 0 or 1 depends on m and n. Note that this\n...     # method only makes sense because we don't automatically evaluate on\n...     # such cases, but instead simplify these cases in doit() below.\n...     def _eval_is_zero(self):\n...         m, n = self.args\n...         if m.is_integer and n.is_integer:\n...              return fuzzy_not((n/m).is_integer)\n...\n...     # Define doit() as further evaluation on symbolic arguments using\n...     # assumptions.\n...     def doit(self, deep=False, **hints):\n...         m, n = self.args\n...         # Recursively call doit() on the args whenever deep=True.\n...         # Be sure to pass deep=True and **hints through here.\n...         if deep:\n...            m, n = m.doit(deep=deep, **hints), n.doit(deep=deep, **hints)\n...\n...         # divides(m, n) is 1 iff n/m is an integer. Note that m and n are\n...         # already assumed to be integers because of the logic in eval().\n...         isint = (n/m).is_integer\n...         if isint is True:\n...             return Integer(1)\n...         elif isint is False:\n...             return Integer(0)\n...         else:\n...             return divides(m, n)\n...\n...     # Define LaTeX printing for use with the latex() function and the\n...     # Jupyter notebook.\n...     def _latex(self, printer):\n...         m, n = self.args\n...         _m, _n = printer._print(m), printer._print(n)\n...         return r'\\left [ %s \\middle | %s \\right ]' % (_m, _n)\n... \n```", "```py\n>>> from sympy import symbols\n>>> n, m, k = symbols('n m k', integer=True)\n>>> divides(3, 10)\n0\n>>> divides(3, 12)\n1\n>>> divides(m, n).is_integer\nTrue\n>>> divides(k, 2*k)\ndivides(k, 2*k)\n>>> divides(k, 2*k).is_zero\nFalse\n>>> divides(k, 2*k).doit()\n1 \n```", "```py\n>>> str(divides(m, n)) # This is using the default str printer\n'divides(m, n)'\n>>> print(latex(divides(m, n)))\n\\left [ m \\middle | n \\right ] \n```", "```py\n>>> from sympy import Number, symbols, Add, Mul\n>>> x, y, z = symbols('x y z')\n>>> class FMA(Function):\n...  \"\"\"\n...     FMA(x, y, z) = x*y + z\n...\n...     FMA is often defined as a single operation in hardware for better\n...     rounding and performance.\n...\n...     FMA can be evaluated by using the doit() method.\n...\n...     References\n...     ==========\n...\n...     .. [1] https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation#Fused_multiply%E2%80%93add\n...     \"\"\"\n...     # Define automatic evaluation on explicit numbers\n...     @classmethod\n...     def eval(cls, x, y, z):\n...         # Number is the base class of Integer, Rational, and Float\n...         if all(isinstance(i, Number) for i in [x, y, z]):\n...            return x*y + z\n...\n...     # Define numerical evaluation with evalf().\n...     def _eval_evalf(self, prec):\n...         return self.doit(deep=False)._eval_evalf(prec)\n...\n...     # Define full evaluation to Add and Mul in doit(). This effectively\n...     # treats FMA(x, y, z) as just a shorthand for x*y + z that is useful\n...     # to have as a separate expression in some contexts and which can be\n...     # evaluated to its expanded form in other contexts.\n...     def doit(self, deep=True, **hints):\n...         x, y, z = self.args\n...         # Recursively call doit() on the args whenever deep=True.\n...         # Be sure to pass deep=True and **hints through here.\n...         if deep:\n...             x = x.doit(deep=deep, **hints)\n...             y = y.doit(deep=deep, **hints)\n...             z = z.doit(deep=deep, **hints)\n...         return x*y + z\n...\n...     # Define FMA.rewrite(Add) and FMA.rewrite(Mul).\n...     def _eval_rewrite(self, rule, args, **hints):\n...         x, y, z = self.args\n...         if rule in [Add, Mul]:\n...             return self.doit()\n...\n...     # Define differentiation.\n...     def fdiff(self, argindex):\n...         # argindex indexes the args, starting at 1\n...         x, y, z = self.args\n...         if argindex == 1:\n...             return y\n...         elif argindex == 2:\n...             return x\n...         elif argindex == 3:\n...             return 1\n...\n...     # Define code printers for ccode() and cxxcode()\n...     def _ccode(self, printer):\n...         x, y, z = self.args\n...         _x, _y, _z = printer._print(x), printer._print(y), printer._print(z)\n...         return \"fma(%s, %s, %s)\" % (_x, _y, _z)\n...\n...     def _cxxcode(self, printer):\n...         x, y, z = self.args\n...         _x, _y, _z = printer._print(x), printer._print(y), printer._print(z)\n...         return \"std::fma(%s, %s, %s)\" % (_x, _y, _z) \n```", "```py\n>>> x, y, z = symbols('x y z')\n>>> FMA(2, 3, 4)\n10\n>>> FMA(x, y, z)\nFMA(x, y, z)\n>>> FMA(x, y, z).doit()\nx*y + z\n>>> FMA(x, y, z).rewrite(Add)\nx*y + z\n>>> FMA(2, pi, 1).evalf()\n7.28318530717959 \n```", "```py\n>>> FMA(x, x, y).diff(x)\n2*x\n>>> FMA(x, y, x).diff(x)\ny + 1 \n```", "```py\n>>> from sympy import ccode, cxxcode\n>>> ccode(FMA(x, y, z))\n'fma(x, y, z)'\n>>> cxxcode(FMA(x, y, z))\n'std::fma(x, y, z)' \n```"]