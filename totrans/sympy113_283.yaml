- en: AGCA - Algebraic Geometry and Commutative Algebra Module
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AGCA - 代数几何和交换代数模块
- en: Original text：[https://docs.sympy.org/latest/modules/polys/agca.html](https://docs.sympy.org/latest/modules/polys/agca.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文链接：[https://docs.sympy.org/latest/modules/polys/agca.html](https://docs.sympy.org/latest/modules/polys/agca.html)
- en: '## Introduction'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '## 简介'
- en: Algebraic geometry is a mixture of the ideas of two Mediterranean cultures.
    It is the superposition of the Arab science of the lightening calculation of the
    solutions of equations over the Greek art of position and shape. This tapestry
    was originally woven on European soil and is still being refined under the influence
    of international fashion. Algebraic geometry studies the delicate balance between
    the geometrically plausible and the algebraically possible. Whenever one side
    of this mathematical teeter-totter outweighs the other, one immediately loses
    interest and runs off in search of a more exciting amusement.
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 代数几何是两种地中海文化理念的融合。它是阿拉伯科学中求解方程轻松计算的超越，与希腊的位置和形状艺术的叠加。这种编织最初在欧洲土地上产生，并在国际时尚的影响下不断完善。代数几何研究几何可信和代数可能之间的微妙平衡。每当这数学跷跷板的一边超过另一边时，人们立即失去兴趣并寻找更激动人心的娱乐。
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: —George R. Kempf (1944 – 2002)
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: —George R. Kempf（1944 – 2002）
- en: Algebraic Geometry refers to the study of geometric problems via algebraic methods
    (and sometimes vice versa). While this is a rather old topic, algebraic geometry
    as understood today is very much a 20th century development. Building on ideas
    of e.g. Riemann and Dedekind, it was realized that there is an intimate connection
    between properties of the set of solutions of a system of polynomial equations
    (called an algebraic variety) and the behavior of the set of polynomial functions
    on that variety (called the coordinate ring).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 代数几何通过代数方法（有时反之亦然）研究几何问题。虽然这是一个相当古老的主题，但当今理解的代数几何在很大程度上是20世纪的发展。在如Riemann和Dedekind的思想基础上，人们意识到多项式方程组的解集（称为代数变量）的性质与在该变量上的多项式函数集的行为（称为坐标环）之间存在密切联系。
- en: As in many geometric disciplines, we can distinguish between local and global
    questions (and methods). Local investigations in algebraic geometry are essentially
    equivalent to the study of certain rings, their ideals and modules. This latter
    topic is also called commutative algebra. It is the basic local toolset of algebraic
    geometers, in much the same way that differential analysis is the local toolset
    of differential geometers.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多几何学科中，我们可以区分局部和全局的问题（及其方法）。代数几何中的局部研究基本上等同于研究某些环、它们的理想和模。后一主题也称为交换代数。它是代数几何学家的基本局部工具集，类似于微分分析是微分几何学家的局部工具集。
- en: A good conceptual introduction to commutative algebra is [[Atiyah69]](literature.html#atiyah69).
    An introduction more geared towards computations, and the work most of the algorithms
    in this module are based on, is [[Greuel2008]](literature.html#greuel2008).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 有关交换代数的良好概念介绍可以参考[[Atiyah69]](literature.html#atiyah69)。更注重计算的介绍，以及该模块中大多数算法所依赖的工作，可以参考[[Greuel2008]](literature.html#greuel2008)。
- en: This module aims to eventually allow expression and solution of both local and
    global geometric problems, both in the classical case over a field and in the
    more modern arithmetic cases. So far, however, there is no geometric functionality
    at all. Currently the module only provides tools for computational commutative
    algebra over fields.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块的最终目标是允许在经典情况下（在一个域上）和更现代的算术情况下表达和解决局部和全局的几何问题。然而，到目前为止，几何功能还没有实现。当前，该模块仅提供关于域上的计算交换代数的工具。
- en: 'All code examples assume:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 所有代码示例假定
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Reference
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考资料
- en: In this section we document the usage of the AGCA module. For convenience of
    the reader, some definitions and examples/explanations are interspersed.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们记录了AGCA模块的使用方法。为了方便读者，我们插入了一些定义、例子和解释。
- en: Base Rings
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基础环
- en: Almost all computations in commutative algebra are relative to a “base ring”.
    (For example, when asking questions about an ideal, the base ring is the ring
    the ideal is a subset of.) In principle all polys “domains” can be used as base
    rings. However, useful functionality is only implemented for polynomial rings
    over fields, and various localizations and quotients thereof.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在交换代数中，几乎所有计算都是相对于“基础环”进行的。（例如，当询问一个理想的问题时，基础环是理想的子集。）原则上，所有“多项式域”都可以用作基础环。然而，实际上，只有在域上的多项式环及其各种局部化和商环中实现了有用的功能。
- en: 'As demonstrated in the examples below, the most convenient method to create
    objects you are interested in is to build them up from the ground field, and then
    use the various methods to create new objects from old. For example, in order
    to create the local ring of the nodal cubic \(y^2 = x^3\) at the origin, over
    \(\mathbb{Q}\), you do:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如下面的示例所示，创建你感兴趣的对象的最便捷方法是从基地领域中构建它们，然后使用各种方法从旧对象中创建新对象。例如，在有理数域\(\mathbb{Q}\)上，在原点处创建尖点立方体\(y^2
    = x^3\)的局部环：
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Note how the python list notation can be used as a short cut to express ideals.
    You can use the `convert` method to return ordinary sympy objects into objects
    understood by the AGCA module (although in many cases this will be done automatically
    – for example the list was automatically turned into an ideal, and in the process
    the symbols \(x\) and \(y\) were automatically converted into other representations).
    For example:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意如何使用Python列表表示法作为表达理想的捷径。您可以使用`convert`方法将普通的sympy对象转换为AGCA模块理解的对象（尽管在许多情况下，这将自动完成
    - 例如，列表被自动转换为理想，并在此过程中，符号\(x\)和\(y\)被自动转换为其他表示）。例如：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When no localisation is needed, a more mathematical notation can be used. For
    example, let us create the coordinate ring of three-dimensional affine space \(\mathbb{A}^3\):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当不需要局部化时，可以使用更数学化的符号。例如，让我们创建三维仿射空间\(\mathbb{A}^3\)的坐标环：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: For more details, refer to the following class documentation. Note that the
    base rings, being domains, are the main point of overlap between the AGCA module
    and the rest of the polys module. All domains are documented in detail in the
    polys reference, so we show here only an abridged version, with the methods most
    pertinent to the AGCA module.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 更多细节，请参考以下类文档。注意，作为域的基础环是AGCA模块与其他多项式模块之间的重要重叠点。所有域都在多项式参考中有详细文档，因此我们在此仅展示一个摘要版本，包含最相关AGCA模块的方法。
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Represents a ring domain.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表示一个环域。
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Generate a free module of rank `rank` over self.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生成自己的等级`rank`自由模块。
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Generate an ideal of `self`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个`self`的理想。
- en: '[PRE8]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Form a quotient ring of `self`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 形成`self`的商环。
- en: Here `e` can be an ideal or an iterable.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`e`可以是一个理想或一个可迭代对象。
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The division operator has been overloaded for this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为此重载了除法运算符：
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A class for representing multivariate polynomial rings.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 表示多变量多项式环的类。
- en: '[PRE13]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Class representing (commutative) quotient rings.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表示（交换）商环的类。
- en: You should not usually instantiate this by hand, instead use the constructor
    from the base ring in the construction.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不应该手动实例化它，而是应该使用基础环的构造函数进行构造。
- en: '[PRE14]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Shorter versions are possible:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更简短的版本：
- en: '[PRE15]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Attributes:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 属性：
- en: ring - the base ring
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环 - 基础环
- en: base_ideal - the ideal used to form the quotient
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: base_ideal - 用于形成商的理想。
- en: Modules, Ideals and their Elementary Properties
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模、理想及其基本性质
- en: 'Let \(A\) be a ring. An \(A\)-module is a set \(M\), together with two binary
    operations \(+: M \times M \to M\) and \(\times: R \times M \to M\) called addition
    and scalar multiplication. These are required to satisfy certain axioms, which
    can be found in e.g. [[Atiyah69]](literature.html#atiyah69). In this way modules
    are a direct generalisation of both vector spaces (\(A\) being a field) and abelian
    groups (\(A = \mathbb{Z}\)). A *submodule* of the \(A\)-module \(M\) is a subset
    \(N \subset M\), such that the binary operations restrict to \(N\), and \(N\)
    becomes an \(A\)-module with these operations.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '设\(A\)是一个环。一个\(A\)-模是一个集合\(M\)，加上两个二元操作\(+: M \times M \to M\)和\(\times: R
    \times M \to M\)，称为加法和标量乘法。这些操作需要满足某些公理，详见例如[[Atiyah69]](literature.html#atiyah69)。这样，模是向量空间（\(A\)为域）和阿贝尔群（\(A
    = \mathbb{Z}\)）的直接推广。\(A\)-模\(M\)的*子模*是集合\(N \subset M\)，使得二元操作限制在\(N\)上，并且\(N\)成为具有这些操作的\(A\)-模。'
- en: The ring \(A\) itself has a natural \(A\)-module structure where addition and
    multiplication in the module coincide with addition and multiplication in the
    ring. This \(A\)-module is also written as \(A\). An \(A\)-submodule of \(A\)
    is called an *ideal* of \(A\). Ideals come up very naturally in algebraic geometry.
    More general modules can be seen as a technically convenient “elbow room” beyond
    talking only about ideals.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 环\(A\)本身具有一个自然的\(A\)-模结构，其中模中的加法和乘法与环中的加法和乘法一致。这个\(A\)-模也被写作\(A\)。\(A\)的一个\(A\)-子模被称为\(A\)的*理想*。在代数几何中，理想非常自然地出现。更一般的模可以看作是技术上方便的“活动空间”，超越了仅仅讨论理想。
- en: 'If \(M\), \(N\) are \(A\)-modules, then there is a natural (componentwise)
    \(A\)-module structure on \(M \times N\). Similarly there are \(A\)-module structures
    on cartesian products of more components. (For the categorically inclined: the
    cartesian product of finitely many \(A\)-modules, with this \(A\)-module structure,
    is the finite biproduct in the category of all \(A\)-modules. With infinitely
    many components, it is the direct product (but the infinite direct sum has to
    be constructed differently).) As usual, repeated product of the \(A\)-module \(M\)
    is denoted \(M, M^2, M^3 \ldots\), or \(M^I\) for arbitrary index sets \(I\).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果\(M\)，\(N\)是\(A\)-模块，则\(M \times N\)具有自然的（分量方式的）\(A\)-模块结构。类似地，更多组分的笛卡尔积上有\(A\)-模块结构。
    （对于类别倾向者：带有此\(A\)-模块结构的有限多个\(A\)-模块的笛卡尔积，在所有\(A\)-模块的类别中是有限的双积。 对于无限多个组件，它是直积（但无限直和必须以不同方式构造）。）通常，\(A\)-模块\(M\)的重复积记为\(M,
    M^2, M^3 \ldots\)，或者对于任意指数集\(I\)为\(M^I\)。
- en: 'An \(A\)-module \(M\) is called *free* if it is isomorphic to the \(A\)-module
    \(A^I\) for some (not necessarily finite) index set \(I\) (refer to the next section
    for a definition of isomorphism). The cardinality of \(I\) is called the *rank*
    of \(M\); one may prove this is well-defined. In general, the AGCA module only
    works with free modules of finite rank, and other closely related modules. The
    easiest way to create modules is to use member methods of the objects they are
    made up from. For example, let us create a free module of rank 4 over the coordinate
    ring of \(\mathbb{A}^2\) we created above, together with a submodule:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果\(A\)-模块\(M\)称为*自由*，则它等价于\(A\)-模块\(A^I\)，对于某个（不一定有限的）指数集\(I\)（关于同构定义的定义，请参见下一节）。\(I\)的基数称为\(M\)的*秩*；可以证明这是良定义的。通常情况下，AGCA模块只与有限秩的自由模块及其他密切相关的模块一起使用。创建模块的最简单方法是使用它们由对象的成员方法构成。例如，让我们在上面创建的\(\mathbb{A}^2\)的坐标环上创建一个秩为4的自由模块，以及一个子模块：
- en: '[PRE17]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note how python lists can be used as a short-cut notation for module elements
    (vectors). As usual, the `convert` method can be used to convert sympy/python
    objects into the internal AGCA representation (see detailed reference below).
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意Python列表可以用作模块元素（向量）的快捷表示法。通常，`convert`方法可用于将sympy/python对象转换为内部AGCA表示（参见下面的详细参考）。
- en: 'Here is the detailed documentation of the classes for modules, free modules,
    and submodules:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是模块、自由模块和子模块的详细文档：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Abstract base class for modules.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 模块的抽象基类。
- en: 'Do not instantiate - use ring explicit constructors instead:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 不要实例化 - 而是使用显式构造函数：
- en: '[PRE19]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Attributes:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 属性：
- en: dtype - type of elements
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: dtype - 元素类型
- en: ring - containing ring
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ring - 包含环
- en: 'Non-implemented methods:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 未实现的方法：
- en: submodule
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子模块
- en: quotient_module
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 商模块
- en: is_zero
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: is_zero
- en: is_submodule
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: is_submodule
- en: multiply_ideal
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: multiply_ideal
- en: The method convert likely needs to be changed in subclasses.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 子类中的`convert`方法可能需要更改。
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Return True if `elem` is an element of this module.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`elem`是该模块的元素，则返回True。
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Convert `elem` into internal representation of this module.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 将`elem`转换为该模块的内部表示。
- en: If `M` is not None, it should be a module containing it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`M`不是`None`，则应该是包含它的模块。
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Return the identity homomorphism on `self`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`self`上的单位同态。
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Returns True if `other` is a submodule of `self`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`other`是`self`的子模块，则返回True。
- en: '[PRE24]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Returns True if `self` is a zero module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是零模块，则返回True。
- en: '[PRE25]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Multiply `self` by the ideal `other`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 将`self`乘以理想`other`。
- en: '[PRE26]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Generate a quotient module.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 生成商模块。
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Generate a submodule.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个子模块。
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Returns True if `other` is is a subset of `self`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`other`是`self`的子集，则返回True。
- en: Examples
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Abstract base class for free modules.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 自由模块的抽象基类。
- en: 'Additional attributes:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 附加属性：
- en: rank - rank of the free module
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: rank - 自由模块的秩
- en: 'Non-implemented methods:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 未实现的方法：
- en: submodule
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子模块
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Return a set of basis elements.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一组基元素。
- en: Examples
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Convert `elem` into the internal representation.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 将`elem`转换为内部表示。
- en: This method is called implicitly whenever computations involve elements not
    in the internal representation.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 每当涉及不在内部表示中的元素时，将隐式调用此方法。
- en: Examples
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE34]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: alias of [`FreeModuleElement`](#sympy.polys.agca.modules.FreeModuleElement "sympy.polys.agca.modules.FreeModuleElement")
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为[`FreeModuleElement`](#sympy.polys.agca.modules.FreeModuleElement "sympy.polys.agca.modules.FreeModuleElement")
- en: '[PRE36]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Return the identity homomorphism on `self`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`self`上的单位同态。
- en: Examples
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE37]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Returns True if `other` is a submodule of `self`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`other`是`self`的子模块，则返回True。
- en: Examples
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE39]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Returns True if `self` is a zero module.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是零模块，则返回True。
- en: (If, as this implementation assumes, the coefficient ring is not the zero ring,
    then this is equivalent to the rank being zero.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: （如果像这个实现假设的那样，系数环不是零环，那么这等价于秩为零。）
- en: Examples
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE41]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Multiply `self` by the ideal `other`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将`self`乘以理想`other`。
- en: Examples
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE43]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Return a quotient module.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个商模块。
- en: Examples
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE45]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Or more conicisely, using the overloaded division operator:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简洁地，使用重载的除法运算符：
- en: '[PRE46]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Element of a free module. Data stored as a tuple.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 自由模块的元素。数据存储为元组。
- en: '[PRE48]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Base class for submodules.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 子模块的基类。
- en: 'Attributes:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 属性：
- en: container - containing module
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: container - 包含模块
- en: gens - generators (subset of containing module)
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gens - generators (subset of containing module)
- en: rank - rank of containing module
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: rank - 包含模块的秩
- en: 'Non-implemented methods:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 未实现的方法：
- en: _contains
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _contains
- en: _syzygies
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _syzygies
- en: _in_terms_of_generators
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _in_terms_of_generators
- en: _intersect
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _intersect
- en: _module_quotient
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _module_quotient
- en: 'Methods that likely need change in subclasses:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要在子类中更改的方法：
- en: reduce_element
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reduce_element
- en: '[PRE49]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Convert `elem` into the internal represantition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将`elem`转换为内部表示。
- en: Mostly called implicitly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下会隐式调用。
- en: Examples
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE50]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Return the identity homomorphism on `self`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 返回在`self`上的恒同同态。
- en: Examples
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE52]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Express element `e` of `self` in terms of the generators.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 用生成元表达元素`e`。
- en: Examples
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE54]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Return a homomorphism representing the inclusion map of `self`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表示`self`包含映射的同态。
- en: That is, the natural map from `self` to `self.container`.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，从`self`到`self.container`的自然映射。
- en: Examples
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE56]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Returns the intersection of `self` with submodule `other`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`self`与子模块`other`的交集。
- en: Examples
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE58]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Some implementation allow further options to be passed. Currently, to only one
    implemented is `relations=True`, in which case the function will return a triple
    `(res, rela, relb)`, where `res` is the intersection module, and `rela` and `relb`
    are lists of coefficient vectors, expressing the generators of `res` in terms
    of the generators of `self` (`rela`) and `other` (`relb`).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现允许传递更多选项。目前，只有一个实现是`relations=True`，在这种情况下，函数将返回三元组`(res, rela, relb)`，其中`res`是交集模块，`rela`和`relb`是系数向量列表，表示`res`的生成元在`self`的生成元（`rela`）和`other`的生成元（`relb`）中的表达。
- en: '[PRE59]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The above result says: the intersection module is generated by the single element
    \((-xy, -xy) = -y (x, x) = -x (y, y)\), where \((x, x)\) and \((y, y)\) respectively
    are the unique generators of the two modules being intersected.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 上述结果说明：交集模块由单一元素\((-xy, -xy) = -y (x, x) = -x (y, y)\)生成，其中\((x, x)\)和\((y,
    y)\)分别是被交集的两个模块的唯一生成元。
- en: '[PRE60]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Return True if `self` is the entire free module.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是整个自由模块，则返回True。
- en: Examples
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE61]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Returns True if `other` is a submodule of `self`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`other`是`self`的子模块，则返回True。
- en: '[PRE63]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Return True if `self` is a zero module.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是零模块，则返回True。
- en: Examples
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE65]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Returns the module quotient of `self` by submodule `other`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`self`除以子模块`other`的模块商。
- en: That is, if `self` is the module \(M\) and `other` is \(N\), then return the
    ideal \(\{f \in R | fN \subset M\}\).
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果`self`是模块\(M\)，`other`是\(N\)，那么返回理想\(\{f \in R | fN \subset M\}\)。
- en: Examples
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE67]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Some implementations allow further options to be passed. Currently, the only
    one implemented is `relations=True`, which may only be passed if `other` is principal.
    In this case the function will return a pair `(res, rel)` where `res` is the ideal,
    and `rel` is a list of coefficient vectors, expressing the generators of the ideal,
    multiplied by the generator of `other` in terms of generators of `self`.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一些实现允许传递更多选项。目前，只有一个实现是`relations=True`，只有在`other`是主理想时才能传递。在这种情况下，函数将返回一对`(res,
    rel)`，其中`res`是理想，`rel`是系数向量列表，表示理想的生成元在`self`的生成元中乘以`other`的生成元的表达。
- en: '[PRE68]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This means that the quotient ideal is generated by the single element \(y\),
    and that \(y (x, x) = 1 (xy, xy)\), \((x, x)\) and \((xy, xy)\) being the generators
    of \(T\) and \(S\), respectively.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着商理想由单一元素\(y\)生成，并且\(y (x, x) = 1 (xy, xy)\)，\((x, x)\)和\((xy, xy)\)分别是\(T\)和\(S\)的生成元。
- en: '[PRE69]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Multiply `self` by the ideal `I`.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 将`self`乘以理想`I`。
- en: Examples
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE70]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Return a quotient module.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个商模块。
- en: This is the same as taking a submodule of a quotient of the containing module.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这等同于取包含模块的商模块的子模块。
- en: Examples
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE72]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Or more coincisely, using the overloaded division operator:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更简洁地，使用重载的除法运算符：
- en: '[PRE73]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Reduce the element `x` of our ring modulo the ideal `self`.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 将环中的元素`x`模除理想`self`。
- en: Here “reduce” has no specific meaning, it could return a unique normal form,
    simplify the expression a bit, or just do nothing.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的“reduce”没有特定的含义，它可以返回唯一的正常形式，稍微简化表达式，或者什么也不做。
- en: '[PRE75]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Generate a submodule.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个子模块。
- en: Examples
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE76]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Compute the syzygy module of the generators of `self`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`self`生成元的syzygy模块。
- en: 'Suppose \(M\) is generated by \(f_1, \ldots, f_n\) over the ring \(R\). Consider
    the homomorphism \(\phi: R^n \to M\), given by sending \((r_1, \ldots, r_n) \to
    r_1 f_1 + \cdots + r_n f_n\). The syzygy module is defined to be the kernel of
    \(\phi\).'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '假设\(M\)由环\(R\)上的\(f_1, \ldots, f_n\)生成。考虑同态\(\phi: R^n \to M\)，定义为将\((r_1,
    \ldots, r_n)\)映射至\(r_1 f_1 + \cdots + r_n f_n\)。syzygy模块定义为\(\phi\)的核。'
- en: Examples
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'The syzygy module is zero iff the generators generate freely a free submodule:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: syzygy模块为零当且仅当生成元自由生成自由子模块：
- en: '[PRE78]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'A slightly more interesting example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稍微有趣的例子：
- en: '[PRE79]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Returns the module generated by the union of `self` and `other`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 返回由`self`和`other`的并集生成的模块。
- en: Examples
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE81]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Ideals are created very similarly to modules. For example, let’s verify that
    the nodal cubic is indeed singular at the origin:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的创建与模块非常相似。例如，让我们验证节点三次曲线在原点确实是奇异的：
- en: '[PRE82]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: We are using here the fact that a curve is non-singular at a point if and only
    if the maximal ideal of the local ring is principal, and that in this case at
    least one of \(x\) and \(y\) must be generators.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用了这样一个事实，即一条曲线在某一点非奇异当且仅当局部环的极大理想是主理想，并且在这种情况下至少一个\(x\)和\(y\)必须是生成元。
- en: This is the detailed documentation of the class ideal. Please note that most
    of the methods regarding properties of ideals (primality etc.) are not yet implemented.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这是理想类的详细文档。请注意，大多数关于理想属性（素性等）的方法尚未实现。
- en: '[PRE83]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Abstract base class for ideals.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 理想的抽象基类。
- en: 'Do not instantiate - use explicit constructors in the ring class instead:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 不要实例化 - 在环类中使用显式构造函数代替：
- en: '[PRE84]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Attributes
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: ring - the ring this ideal belongs to
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环 - 此理想所属的环
- en: 'Non-implemented methods:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 未实现的方法：
- en: _contains_elem
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _contains_elem
- en: _contains_ideal
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _contains_ideal
- en: _quotient
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _quotient
- en: _intersect
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _intersect
- en: _union
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _union
- en: _product
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _product
- en: is_whole_ring
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否整个环
- en: is_zero
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否为零
- en: is_prime, is_maximal, is_primary, is_radical
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否为素理想，极大理想，主理想，根理想
- en: is_principal
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是否为主理想
- en: height, depth
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高度，深度
- en: radical
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根理想
- en: 'Methods that likely should be overridden in subclasses:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 子类中可能应该重写的方法：
- en: reduce_element
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: reduce_element
- en: '[PRE85]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Return True if `elem` is an element of this ideal.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`elem`是这个理想的一个元素则返回True。
- en: Examples
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE86]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Compute the depth of `self`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`self`的深度。
- en: '[PRE88]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Compute the height of `self`.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`self`的高度。
- en: '[PRE89]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Compute the intersection of self with ideal J.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`self`与理想J的交集。
- en: Examples
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE90]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Return True if `self` is a maximal ideal.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是极大理想则返回True。
- en: '[PRE92]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Return True if `self` is a primary ideal.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是主理想则返回True。
- en: '[PRE93]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Return True if `self` is a prime ideal.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是素理想则返回True。
- en: '[PRE94]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Return True if `self` is a principal ideal.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是主理想则返回True。
- en: '[PRE95]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Return True if `self` is a radical ideal.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是根理想则返回True。
- en: '[PRE96]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Return True if `self` is the whole ring.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是整环则返回True。
- en: '[PRE97]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Return True if `self` is the zero ideal.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是零理想则返回True。
- en: '[PRE98]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Compute the ideal product of `self` and `J`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`self`和`J`的理想积。
- en: That is, compute the ideal generated by products \(xy\), for \(x\) an element
    of `self` and \(y \in J\).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 即，计算由\(xy\)的乘积生成的理想，其中\(x\)是`self`的元素，\(y \in J\)。
- en: Examples
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE99]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Compute the ideal quotient of `self` by `J`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`self`除以`J`的理想商。
- en: 'That is, if `self` is the ideal \(I\), compute the set \(I : J = \{x \in R
    | xJ \subset I \}\).'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '即，如果`self`是理想\(I\)，计算集合\(I : J = \{x \in R | xJ \subset I \}\)。'
- en: Examples
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE101]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Compute the radical of `self`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`self`的根理想。
- en: '[PRE103]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Reduce the element `x` of our ring modulo the ideal `self`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们环的元素`x`减少至理想`self`。
- en: 'Here “reduce” has no specific meaning: it could return a unique normal form,
    simplify the expression a bit, or just do nothing.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的“reduce”没有具体的含义：它可以返回一个唯一的标准形式，简化表达式，或者什么也不做。
- en: '[PRE104]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Compute the ideal saturation of `self` by `J`.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`self`通过`J`的理想饱和。
- en: 'That is, if `self` is the ideal \(I\), compute the set \(I : J^\infty = \{x
    \in R | xJ^n \subset I \text{ for some } n\}\).'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '即，如果`self`是理想\(I\)，计算集合\(I : J^\infty = \{x \in R | xJ^n \subset I \text{ for
    some } n\}\)。'
- en: '[PRE105]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Returns True if `other` is is a subset of `self`.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`other`是`self`的子集则返回True。
- en: Here `other` may be an ideal.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`other`可能是一个理想。
- en: Examples
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE106]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Compute the ideal generated by the union of `self` and `J`.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 计算由`self`和J的并集生成的理想。
- en: Examples
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE108]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'If \(M\) is an \(A\)-module and \(N\) is an \(A\)-submodule, we can define
    two elements \(x\) and \(y\) of \(M\) to be equivalent if \(x - y \in N\). The
    set of equivalence classes is written \(M/N\), and has a natural \(A\)-module
    structure. This is called the quotient module of \(M\) by \(N\). If \(K\) is a
    submodule of \(M\) containing \(N\), then \(K/N\) is in a natural way a submodule
    of \(M/N\). Such a module is called a subquotient. Here is the documentation of
    quotient and subquotient modules:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 \(M\) 是 \(A\)-模块且 \(N\) 是 \(A\)-子模块，我们可以定义 \(M\) 的两个元素 \(x\) 和 \(y\) 等价，如果
    \(x - y \in N\)。等价类的集合写作 \(M/N\)，并且具有自然的 \(A\)-模块结构。这被称为 \(M\) 关于 \(N\) 的商模。如果
    \(K\) 是包含 \(N\) 的 \(M\) 的子模块，则 \(K/N\) 以一种自然的方式是 \(M/N\) 的子模块。这样的模块称为子商模。这是商模和子商模的文档：
- en: '[PRE109]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Class for quotient modules.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 商模类。
- en: Do not instantiate this directly. For subquotients, see the SubQuotientModule
    class.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接实例化这个类。对于子商模，请参见SubQuotientModule类。
- en: 'Attributes:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 属性：
- en: base - the base module we are a quotient of
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: base - 我们是其商的基模块
- en: killed_module - the submodule used to form the quotient
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: killed_module - 用于形成商的子模块
- en: rank of the base
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基模的秩
- en: '[PRE110]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Convert `elem` into the internal representation.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `elem` 转换为内部表示。
- en: This method is called implicitly whenever computations involve elements not
    in the internal representation.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 每当计算涉及不在内部表示中的元素时，都会隐式调用此方法。
- en: Examples
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE111]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: alias of [`QuotientModuleElement`](#sympy.polys.agca.modules.QuotientModuleElement
    "sympy.polys.agca.modules.QuotientModuleElement")
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 别名 [`QuotientModuleElement`](#sympy.polys.agca.modules.QuotientModuleElement
    "sympy.polys.agca.modules.QuotientModuleElement")
- en: '[PRE113]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Return the identity homomorphism on `self`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 返回在 `self` 上的恒同同态。
- en: Examples
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE114]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Return True if `other` is a submodule of `self`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `other` 是 `self` 的子模块，则返回 True。
- en: Examples
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE116]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Return True if `self` is a zero module.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `self` 是零模块，则返回 True。
- en: This happens if and only if the base module is the same as the submodule being
    killed.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果基模块与被杀死的子模块相同，则会发生这种情况。
- en: Examples
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE118]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Return the quotient homomorphism to `self`.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `self` 的商同态。
- en: That is, return a homomorphism representing the natural map from `self.base`
    to `self`.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 即，返回表示从 `self.base` 到 `self` 的自然映射的同态。
- en: Examples
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE120]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Generate a submodule.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 生成一个子模块。
- en: This is the same as taking a quotient of a submodule of the base module.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这与取基模块的子模块的商是相同的。
- en: Examples
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE122]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Element of a quotient module.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 商模的元素。
- en: '[PRE124]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Equality comparison.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 相等比较。
- en: '[PRE125]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Submodule of a quotient module.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 商模的子模块。
- en: Equivalently, quotient module of a submodule.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 等价地，子模的商模。
- en: 'Do not instantiate this, instead use the submodule or quotient_module constructing
    methods:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 不要直接实例化它，而是使用子模块或商模块构造方法：
- en: '[PRE126]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Attributes:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 属性：
- en: base - base module we are quotient of
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: base - 我们是其商的基模块
- en: killed_module - submodule used to form the quotient
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: killed_module - 用于形成商的子模块
- en: '[PRE127]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Return True if `self` is the entire free module.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `self` 是整个自由模块，则返回 True。
- en: Examples
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE128]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Return the quotient homomorphism to self.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 `self` 的商同态。
- en: That is, return the natural map from `self.base` to `self`.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 即，返回从 `self.base` 到 `self` 的自然映射。
- en: Examples
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 例子
- en: '[PRE130]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Module Homomorphisms and Syzygies
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模同态和Syzygies
- en: 'Let \(M\) and \(N\) be \(A\)-modules. A mapping \(f: M \to N\) satisfying various
    obvious properties (see [[Atiyah69]](literature.html#atiyah69)) is called an \(A\)-module
    homomorphism. In this case \(M\) is called the *domain* and *N* the *codomain*.
    The set \(\{x \in M | f(x) = 0\}\) is called the *kernel* \(ker(f)\), whereas
    the set \(\{f(x) | x \in M\}\) is called the *image* \(im(f)\). The kernel is
    a submodule of \(M\), the image is a submodule of \(N\). The homomorphism \(f\)
    is injective if and only if \(ker(f) = 0\) and surjective if and only if \(im(f)
    = N\). A bijective homomorphism is called an *isomorphism*. Equivalently, \(ker(f)
    = 0\) and \(im(f) = N\). (A related notion, which currently has no special name
    in the AGCA module, is that of the *cokernel*, \(coker(f) = N/im(f)\).)'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '设 \(M\) 和 \(N\) 是 \(A\)-模块。满足各种明显性质的映射 \(f: M \to N\)（见[[Atiyah69]](literature.html#atiyah69)）被称为
    \(A\)-模同态。在这种情况下，\(M\) 被称为*定义域*，*N* 被称为*陪域*。集合 \(\{x \in M | f(x) = 0\}\) 称为*核*
    \(ker(f)\)，而集合 \(\{f(x) | x \in M\}\) 称为*像* \(im(f)\)。核是 \(M\) 的子模，像是 \(N\) 的子模。同态
    \(f\) 是单射当且仅当 \(ker(f) = 0\)，是满射当且仅当 \(im(f) = N\)。双射同态称为*同构*。等价地，\(ker(f) = 0\)
    并且 \(im(f) = N\)。（AGCA模块中目前没有特殊名称的相关概念是*cokernel*，\(coker(f) = N/im(f)\)。）'
- en: Suppose now \(M\) is an \(A\)-module. \(M\) is called *finitely generated* if
    there exists a surjective homomorphism \(A^n \to M\) for some \(n\). If such a
    morphism \(f\) is chosen, the images of the standard basis of \(A^n\) are called
    the *generators* of \(M\). The module \(ker(f)\) is called *syzygy module* with
    respect to the generators. A module is called *finitely presented* if it is finitely
    generated with a finitely generated syzygy module. The class of finitely presented
    modules is essentially the largest class we can hope to be able to meaningfully
    compute in.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设\( M \)是一个\( A \)-模。如果存在一个满同态\( A^n \to M \)（对于某些\( n \)），则\( M \)被称为*有限生成*的。如果选择这样的同态\(
    f \)，则\( A^n \)的标准基的像称为\( M \)的*生成元*。模\( \ker(f) \)称为关于生成元的*syzygy模块*。如果一个模是有限生成的且有一个有限生成的syzygy模块，则称其为*有限呈现*模。有限呈现模的类别实质上是我们可以有意义地计算的最大类别。
- en: It is an important theorem that, for all the rings we are considering, all submodules
    of finitely generated modules are finitely generated, and hence finitely generated
    and finitely presented modules are the same.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的定理是，对于我们考虑的所有环，有限生成模的所有子模都是有限生成的，因此有限生成模和有限呈现模是相同的。
- en: The notion of syzygies, while it may first seem rather abstract, is actually
    very computational. This is because there exist (fairly easy) algorithms for computing
    them, and more general questions (kernels, intersections, …) are often reduced
    to syzygy computation.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初看起来可能有些抽象，但是syzygies的概念实际上非常具有计算性。这是因为存在（相当简单的）算法来计算它们，而更一般的问题（核，交集等）通常可以简化为syzygy的计算。
- en: 'Let us say a few words about the definition of homomorphisms in the AGCA module.
    Suppose first that \(f : M \to N\) is an arbitrary morphism of \(A\)-modules.
    Then if \(K\) is a submodule of \(M\), \(f\) naturally defines a new homomorphism
    \(g: K \to N\) (via \(g(x) = f(x)\)), called the *restriction* of \(f\) to \(K\).
    If now \(K\) contained in the kernel of \(f\), then moreover \(f\) defines in
    a natural homomorphism \(g: M/K \to N\) (same formula as above!), and we say that
    \(f\) *descends* to \(M/K\). Similarly, if \(L\) is a submodule of \(N\), there
    is a natural homomorphism \(g: M \to N/L\), we say that \(g\) *factors* through
    \(f\). Finally, if now \(L\) contains the image of \(f\), then there is a natural
    homomorphism \(g: M \to L\) (defined, again, by the same formula), and we say
    \(g\) is obtained from \(f\) by restriction of codomain. Observe also that each
    of these four operations is reversible, in the sense that given \(g\), one can
    always (non-uniquely) find \(f\) such that \(g\) is obtained from \(f\) in the
    above way.'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们先谈一下AGCA模块中同态的定义。首先假设\( f: M \to N \)是\( A \)-模的任意同态。如果\( K \)是\( M \)的子模，则\(
    f \)自然地定义了一个新的同态\( g: K \to N \)（通过\( g(x) = f(x) \)），称为\( f \)在\( K \)上的*限制*。如果现在\(
    K \)包含在\( f \)的核中，则此外\( f \)还自然地定义了一个同态\( g: M/K \to N \)（同上公式！），我们称\( f \) *降至*
    \( M/K \)。类似地，如果\( L \)是\( N \)的子模，则存在一个自然的同态\( g: M \to N/L \)，我们称\( g \) *通过*
    \( f \)。最后，如果现在\( L \)包含\( f \)的像，则有一个自然的同态\( g: M \to L \)（同上定义），我们称\( g \)是通过限制像域从\(
    f \)获得的。还要注意这四个操作中的每一个都是可逆的，也就是说，给定\( g \)，可以总是（非唯一地）找到\( f \)，使得\( g \)是通过上述方式从\(
    f \)获得的。'
- en: Note that all modules implemented in AGCA are obtained from free modules by
    taking a succession of submodules and quotients. Hence, in order to explain how
    to define a homomorphism between arbitrary modules, in light of the above, we
    need only explain how to define homomorphisms of free modules. But, essentially
    by the definition of free module, a homomorphism from a free module \(A^n\) to
    any module \(M\) is precisely the same as giving \(n\) elements of \(M\) (the
    images of the standard basis), and giving an element of a free module \(A^m\)
    is precisely the same as giving \(m\) elements of \(A\). Hence a homomorphism
    of free modules \(A^n \to A^m\) can be specified via a matrix, entirely analogously
    to the case of vector spaces.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有在AGCA中实现的模块都是通过连续取子模和商模从自由模块获得的。因此，为了解释如何在上述情况下定义任意模块之间的同态，我们只需解释如何定义自由模块的同态。但是，基本上通过自由模块的定义，从自由模块\(
    A^n \)到任何模块\( M \)的同态恰好等同于给出\( M \)的\( n \)个元素（标准基的像），而从自由模块\( A^m \)给出元素恰好等同于给出\(
    A \)的\( m \)个元素。因此，自由模块\( A^n \to A^m \)的同态可以通过矩阵指定，与向量空间的情况完全类似。
- en: The functions `restrict_domain` etc. of the class `Homomorphism` can be used
    to carry out the operations described above, and homomorphisms of free modules
    can in principle be instantiated by hand. Since these operations are so common,
    there is a convenience function `homomorphism` to define a homomorphism between
    arbitrary modules via the method outlined above. It is essentially the only way
    homomorphisms need ever be created by the user.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 类`Homomorphism`的函数`restrict_domain`等可以用于执行上述操作，并且自由模的同态映射原则上可以手动实例化。由于这些操作如此常见，因此有一个方便的函数`homomorphism`来通过上述方法定义任意模块之间的同态映射。这基本上是用户创建同态映射的唯一方法。
- en: '[PRE131]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Create a homomorphism object.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个同态映射对象。
- en: This function tries to build a homomorphism from `domain` to `codomain` via
    the matrix `matrix`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数尝试通过矩阵`matrix`从`domain`到`codomain`构建同态映射。
- en: Examples
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE132]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: If `domain` is a free module generated by \(e_1, \ldots, e_n\), then `matrix`
    should be an n-element iterable \((b_1, \ldots, b_n)\) where the \(b_i\) are elements
    of `codomain`. The constructed homomorphism is the unique homomorphism sending
    \(e_i\) to \(b_i\).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`domain`是由\(e_1, \ldots, e_n\)生成的自由模，则`matrix`应该是一个n元可迭代对象\((b_1, \ldots,
    b_n)\)，其中\(b_i\)是`codomain`的元素。构造的同态映射是将\(e_i\)发送到\(b_i\)的唯一同态映射。
- en: '[PRE134]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: If `domain` is a submodule of a free module, them `matrix` determines a homomoprhism
    from the containing free module to `codomain`, and the homomorphism returned is
    obtained by restriction to `domain`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`domain`是自由模的子模，则`matrix`确定从包含自由模到`codomain`的同态映射，并且通过限制到`domain`获得返回的同态映射。
- en: '[PRE135]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: If `domain` is a (sub)quotient \(N/K\), then `matrix` determines a homomorphism
    from \(N\) to `codomain`. If the kernel contains \(K\), this homomorphism descends
    to `domain` and is returned; otherwise an exception is raised.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`domain`是一个(子)商模 \(N/K\)，那么`matrix`确定了从\(N\)到`codomain`的同态映射。如果核包含\(K\)，则此同态映射下降到`domain`并返回；否则会引发异常。
- en: '[PRE136]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Finally, here is the detailed reference of the actual homomorphism class:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里是实际同态映射类的详细参考：
- en: '[PRE137]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Abstract base class for module homomoprhisms. Do not instantiate.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 模块同态映射的抽象基类。不要实例化。
- en: 'Instead, use the `homomorphism` function:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是，使用`homomorphism`函数：
- en: '[PRE138]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Attributes:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 属性：
- en: ring - the ring over which we are considering modules
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 环 - 我们考虑的模块的环
- en: domain - the domain module
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域 - 域模
- en: codomain - the codomain module
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: codomain - 积模
- en: _ker - cached kernel
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _ker - 缓存的核
- en: _img - cached image
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _img - 缓存的图像
- en: 'Non-implemented methods:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 未实现的方法：
- en: _kernel
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _核
- en: _image
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _图像
- en: _restrict_domain
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _restrict_domain
- en: _restrict_codomain
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _restrict_codomain
- en: _quotient_domain
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _quotient_domain
- en: _quotient_codomain
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _quotient_codomain
- en: _apply
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _apply
- en: _mul_scalar
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _mul_scalar
- en: _compose
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _compose
- en: _add
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: _add
- en: '[PRE140]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Compute the image of `self`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`self`的图像。
- en: 'That is, if `self` is the homomorphism \(\phi: M \to N\), then compute \(im(\phi)
    = \{\phi(x) | x \in M \}\). This is a submodule of \(N\).'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '也就是说，如果`self`是同态映射\(\phi: M \to N\)，那么计算\(im(\phi) = \{\phi(x) | x \in M \}\)。这是\(N\)的子模块。'
- en: Examples
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE141]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Return True if `self` is injective.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是单射，则返回True。
- en: That is, check if the elements of the domain are mapped to the same codomain
    element.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，检查域的元素是否映射到相同的积模元素。
- en: Examples
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE144]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Return True if `self` is an isomorphism.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是同构，则返回True。
- en: That is, check if every element of the codomain has precisely one preimage.
    Equivalently, `self` is both injective and surjective.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，检查每个域的元素是否具有精确一个原像。等效地，`self`既是单射又是满射。
- en: Examples
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE147]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Return True if `self` is surjective.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是满射，则返回True。
- en: That is, check if every element of the codomain has at least one preimage.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，检查每个域的元素是否至少有一个原像。
- en: Examples
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE150]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Return True if `self` is a zero morphism.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`self`是零态射，则返回True。
- en: That is, check if every element of the domain is mapped to zero under self.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，检查域的每个元素是否在自身下映射为零。
- en: Examples
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE153]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Compute the kernel of `self`.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 计算`self`的核。
- en: 'That is, if `self` is the homomorphism \(\phi: M \to N\), then compute \(ker(\phi)
    = \{x \in M | \phi(x) = 0\}\). This is a submodule of \(M\).'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '也就是说，如果`self`是同态映射\(\phi: M \to N\)，那么计算\(ker(\phi) = \{x \in M | \phi(x) =
    0\}\)。这是\(M\)的子模块。'
- en: Examples
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE156]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Return `self` with codomain replaced by `codomain/sm`.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 用`codomain/sm`替换`self`返回。
- en: Here `sm` must be a submodule of `self.codomain`.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`sm`必须是`self.codomain`的子模块。
- en: Examples
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE159]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'This is the same as composing with the quotient map on the left:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这与在左侧使用商映射进行组合相同：
- en: '[PRE161]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Return `self` with domain replaced by `domain/sm`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 用`domain/sm`替换`self`返回。
- en: Here `sm` must be a submodule of `self.kernel()`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`sm`必须是`self.kernel()`的子模块。
- en: Examples
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE163]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Return `self`, with codomain restricted to to `sm`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`self`，其余值被限制为`sm`。
- en: Here `sm` has to be a submodule of `self.codomain` containing the image.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`sm`必须是包含图像的`self.codomain`的子模。
- en: Examples
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE166]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Return `self`, with the domain restricted to `sm`.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 返回`self`，其定义被限制为`sm`。
- en: Here `sm` has to be a submodule of `self.domain`.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`sm`必须是`self.domain`的子模。
- en: Examples
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: '[PRE169]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'This is the same as just composing on the right with the submodule inclusion:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这与仅在右侧与子模包含组合相同：
- en: '[PRE171]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Finite Extensions
  id: totrans-466
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有限扩展
- en: Let \(A\) be a (commutative) ring and \(B\) an extension ring of \(A\). An element
    \(t\) of \(B\) is a generator of \(B\) (over \(A\)) if all elements of \(B\) can
    be represented as polynomials in \(t\) with coefficients in \(A\). The representation
    is unique if and only if \(t\) satisfies no non-trivial polynomial relation, in
    which case \(B\) can be identified with a (univariate) polynomial ring over \(A\).
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 设\(A\)为（交换）环，\(B\)为\(A\)的扩展环。若\(B\)中的元素\(t\)是\(A\)上\(B\)的生成器，则\(B\)中的所有元素都可以用\(t\)的系数为\(A\)的多项式表示。如果且仅如果\(t\)满足没有非平凡多项式关系，则表示是唯一的，此时\(B\)可以被视为\(A\)上的（单变量）多项式环。
- en: The polynomials having \(t\) as a root form a non-zero ideal in general. The
    most important case in practice is that of an ideal generated by a single monic
    polynomial. If \(t\) satisfies such a polynomial relation, then its highest power
    \(t^n\) can be written as linear combination of lower powers. It follows, inductively,
    that all higher powers of \(t\) also have such a representation. Hence the lower
    powers \(t^i\) (\(i = 0, \dots, n-1\)) form a basis of \(B\), which is then called
    a finite extension of \(A\), or, more precisely, a monogenic finite extension
    as it is generated by a single element \(t\).
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 一般情况下，以\(t\)为根的多项式形成一个非零理想。在实践中最重要的情况是由单一单项式生成的理想。如果\(t\)满足这样的多项式关系，则其最高幂\(t^n\)可以写成较低幂的线性组合。归纳地，所有更高的幂\(t\)也有这样的表示。因此，较低的幂\(t^i\)（\(i
    = 0, \dots, n-1\))形成\(B\)的一组基础，然后称为\(A\)的有限扩展，或更准确地说是由单个元素\(t\)生成的单基有限扩展。
- en: '[PRE172]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: Finite extension generated by an integral element.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 由整数元素生成的有限扩展。
- en: The generator is defined by a monic univariate polynomial derived from the argument
    `mod`.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器由从参数`mod`导出的单变量单项式定义。
- en: A shorter alias is `FiniteExtension`.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 更短的别名是`FiniteExtension`。
- en: Examples
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 示例
- en: 'Quadratic integer ring \(\mathbb{Z}[\sqrt2]\):'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 二次整数环\(\mathbb{Z}[\sqrt2]\)：
- en: '[PRE173]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Finite field \(GF(5^3)\) defined by the primitive polynomial \(x^3 + x^2 + 2\)
    (over \(\mathbb{Z}_5\)).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 有限域\(GF(5^3)\)，由原始多项式\(x^3 + x^2 + 2\)（在\(\mathbb{Z}_5\)上）定义。
- en: '[PRE174]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Function field of an elliptic curve:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 椭圆曲线的函数域：
- en: '[PRE175]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: alias of [`ExtensionElement`](#sympy.polys.agca.extensions.ExtensionElement
    "sympy.polys.agca.extensions.ExtensionElement")
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 别名为[`ExtensionElement`](#sympy.polys.agca.extensions.ExtensionElement "sympy.polys.agca.extensions.ExtensionElement")
- en: '[PRE177]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: Element of a finite extension.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 有限扩展的元素。
- en: A class of univariate polynomials modulo the `modulus` of the extension `ext`.
    It is represented by the unique polynomial `rep` of lowest degree. Both `rep`
    and the representation `mod` of `modulus` are of class DMP.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在扩展`ext`的模`modulus`的`DMP`类的唯一多项式`rep`表示。它由`mod`的表示和`modulus`的表示构成。
- en: '[PRE178]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Multiplicative inverse.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 乘法逆元。
- en: 'Raises:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '**NotInvertible**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**NotInvertible**'
- en: If the element is a zero divisor.
  id: totrans-489
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果元素是零除数。
