["```py\nIn [1]: df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [1, 2, 3]}, index=['a', 'a', 'b'])\n\nIn [2]: print(df.to_markdown())\n|    |   A |   B |\n|:---|----:|----:|\n| a  |   1 |   1 |\n| a  |   2 |   2 |\n| b  |   3 |   3 | \n```", "```py\nIn [3]: s = pd.Series([1, 2, None], dtype=\"Int64\")\n\nIn [4]: s\nOut[4]: \n0       1\n1       2\n2    <NA>\ndtype: Int64\n\nIn [5]: s[2]\nOut[5]: <NA> \n```", "```py\nIn [6]: np.nan > 1\nOut[6]: False\n\nIn [7]: pd.NA > 1\nOut[7]: <NA> \n```", "```py\nIn [8]: pd.NA | True\nOut[8]: True \n```", "```py\nIn [9]: pd.Series(['abc', None, 'def'], dtype=pd.StringDtype())\nOut[9]: \n0     abc\n1    <NA>\n2     def\ndtype: string \n```", "```py\nIn [10]: s = pd.Series(['abc', None, 'def'], dtype=\"string\")\n\nIn [11]: s\nOut[11]: \n0     abc\n1    <NA>\n2     def\ndtype: string \n```", "```py\nIn [12]: s.str.upper()\nOut[12]: \n0     ABC\n1    <NA>\n2     DEF\ndtype: string\n\nIn [13]: s.str.split('b', expand=True).dtypes\nOut[13]: \n0    string[python]\n1    string[python]\ndtype: object \n```", "```py\nIn [14]: s.str.count(\"a\")\nOut[14]: \n0       1\n1    <NA>\n2       0\ndtype: Int64 \n```", "```py\nIn [15]: pd.Series([True, False, None], dtype=pd.BooleanDtype())\nOut[15]: \n0     True\n1    False\n2     <NA>\ndtype: boolean \n```", "```py\nIn [16]: s = pd.Series([True, False, None], dtype=\"boolean\")\n\nIn [17]: s\nOut[17]: \n0     True\n1    False\n2     <NA>\ndtype: boolean \n```", "```py\nIn [18]: df = pd.DataFrame({'x': ['abc', None, 'def'],\n ....:                   'y': [1, 2, np.nan],\n ....:                   'z': [True, False, True]})\n ....: \n\nIn [19]: df\nOut[19]: \n x    y      z\n0   abc  1.0   True\n1  None  2.0  False\n2   def  NaN   True\n\nIn [20]: df.dtypes\nOut[20]: \nx     object\ny    float64\nz       bool\ndtype: object \n```", "```py\nIn [21]: converted = df.convert_dtypes()\n\nIn [22]: converted\nOut[22]: \n x     y      z\n0   abc     1   True\n1  <NA>     2  False\n2   def  <NA>   True\n\nIn [23]: converted.dtypes\nOut[23]: \nx    string[python]\ny             Int64\nz           boolean\ndtype: object \n```", "```py\nIn [24]: mi = pd.MultiIndex.from_product([[1, 2], ['a', 'b']], names=['x', 'y'])\n\nIn [25]: mi.levels[0].name\nOut[25]: 'x' \n```", "```py\nIn [26]: mi.levels[0].name = \"new name\"\n---------------------------------------------------------------------------\nRuntimeError  Traceback (most recent call last)\nCell In[26], line 1\n----> 1 mi.levels[0].name = \"new name\"\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:1690, in Index.name(self, value)\n  1686 @name.setter\n  1687 def name(self, value: Hashable) -> None:\n  1688     if self._no_setting_name:\n  1689         # Used in MultiIndex.levels to avoid silently ignoring name updates.\n-> 1690         raise RuntimeError(\n  1691             \"Cannot set name on a level of a MultiIndex. Use \"\n  1692             \"'MultiIndex.set_names' instead.\"\n  1693         )\n  1694     maybe_extract_name(value, None, type(self))\n  1695     self._name = value\n\nRuntimeError: Cannot set name on a level of a MultiIndex. Use 'MultiIndex.set_names' instead.\n\nIn [27]: mi.names\nOut[27]: FrozenList(['x', 'y']) \n```", "```py\nIn [28]: mi2 = mi.set_names(\"new name\", level=0)\n\nIn [29]: mi2.names\nOut[29]: FrozenList(['new name', 'y']) \n```", "```py\nIn [1]: pd.arrays.IntervalArray.from_tuples([(0, 1), (2, 3)])\nOut[2]:\nIntervalArray([(0, 1], (2, 3]],\n closed='right',\n dtype='interval[int64]') \n```", "```py\nIn [30]: pd.arrays.IntervalArray.from_tuples([(0, 1), (2, 3)])\nOut[30]: \n<IntervalArray>\n[(0, 1], (2, 3]]\nLength: 2, dtype: interval[int64, right] \n```", "```py\nIn [1]: df = pd.DataFrame([[1]])\nIn [2]: df.rename({0: 1}, {0: 2})\nOut[2]:\nFutureWarning: ...Use named arguments to resolve ambiguity...\n 2\n1  1 \n```", "```py\nIn [3]: df.rename({0: 1}, {0: 2})\nTraceback (most recent call last):\n...\nTypeError: rename() takes from 1 to 2 positional arguments but 3 were given \n```", "```py\nIn [4]: df.rename({0: 1}, index={0: 2})\nOut[4]:\n 0\n1  1\n\nIn [5]: df.rename(mapper={0: 1}, index={0: 2})\nOut[5]:\n 0\n2  1 \n```", "```py\nIn [6]: df.rename({0: 1}, index={0: 2})\nTraceback (most recent call last):\n...\nTypeError: Cannot specify both 'mapper' and any of 'index' or 'columns'\n\nIn [7]: df.rename(mapper={0: 1}, index={0: 2})\nTraceback (most recent call last):\n...\nTypeError: Cannot specify both 'mapper' and any of 'index' or 'columns' \n```", "```py\nIn [31]: df.rename({0: 1})\nOut[31]: \n 0\n1  1\n\nIn [32]: df.rename({0: 1}, axis=1)\nOut[32]: \n 1\n0  1 \n```", "```py\nIn [33]: df.rename(index={0: 1}, columns={0: 2})\nOut[33]: \n 2\n1  1 \n```", "```py\nIn [1]: df = pd.DataFrame({\"int_col\": [1, 2, 3],\n...                    \"text_col\": [\"a\", \"b\", \"c\"],\n...                    \"float_col\": [0.0, 0.1, 0.2]})\nIn [2]: df.info(verbose=True)\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nint_col      3 non-null int64\ntext_col     3 non-null object\nfloat_col    3 non-null float64\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 152.0+ bytes \n```", "```py\nIn [34]: df = pd.DataFrame({\"int_col\": [1, 2, 3],\n ....:                   \"text_col\": [\"a\", \"b\", \"c\"],\n ....:                   \"float_col\": [0.0, 0.1, 0.2]})\n ....: \n\nIn [35]: df.info(verbose=True)\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\n #   Column     Non-Null Count  Dtype \n---  ------     --------------  ----- \n 0   int_col    3 non-null      int64 \n 1   text_col   3 non-null      object \n 2   float_col  3 non-null      float64\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 200.0+ bytes \n```", "```py\nIn [1]: pd.array([\"a\", None])\nOut[1]:\n<PandasArray>\n['a', None]\nLength: 2, dtype: object\n\nIn [2]: pd.array([1, None])\nOut[2]:\n<PandasArray>\n[1, None]\nLength: 2, dtype: object \n```", "```py\nIn [36]: pd.array([\"a\", None])\nOut[36]: \n<StringArray>\n['a', <NA>]\nLength: 2, dtype: string\n\nIn [37]: pd.array([1, None])\nOut[37]: \n<IntegerArray>\n[1, <NA>]\nLength: 2, dtype: Int64 \n```", "```py\nIn [1]: a = pd.array([1, 2, None], dtype=\"Int64\")\nIn [2]: a\nOut[2]:\n<IntegerArray>\n[1, 2, NaN]\nLength: 3, dtype: Int64\n\nIn [3]: a[2]\nOut[3]:\nnan \n```", "```py\nIn [38]: a = pd.array([1, 2, None], dtype=\"Int64\")\n\nIn [39]: a\nOut[39]: \n<IntegerArray>\n[1, 2, <NA>]\nLength: 3, dtype: Int64\n\nIn [40]: a[2]\nOut[40]: <NA> \n```", "```py\nIn [1]: np.asarray(a, dtype=\"float\")\nOut[1]:\narray([ 1.,  2., nan]) \n```", "```py\nIn [41]: np.asarray(a, dtype=\"float\")\nOut[41]: array([ 1.,  2., nan]) \n```", "```py\nIn [42]: a.to_numpy(dtype=\"float\", na_value=np.nan)\nOut[42]: array([ 1.,  2., nan]) \n```", "```py\nIn [1]: pd.Series(a).sum(skipna=False)\nOut[1]:\nnan \n```", "```py\nIn [43]: pd.Series(a).sum(skipna=False)\nOut[43]: <NA> \n```", "```py\nIn [1]: pd.Series([2, 1, 1, None], dtype=\"Int64\").value_counts().dtype\nOut[1]:\ndtype('int64') \n```", "```py\nIn [44]: pd.Series([2, 1, 1, None], dtype=\"Int64\").value_counts().dtype\nOut[44]: Int64Dtype() \n```", "```py\nIn [1]: a = pd.array([1, 2, None], dtype=\"Int64\")\nIn [2]: a\nOut[2]:\n<IntegerArray>\n[1, 2, NaN]\nLength: 3, dtype: Int64\n\nIn [3]: a > 1\nOut[3]:\narray([False,  True, False]) \n```", "```py\nIn [45]: a = pd.array([1, 2, None], dtype=\"Int64\")\n\nIn [46]: a > 1\nOut[46]: \n<BooleanArray>\n[False, True, <NA>]\nLength: 3, dtype: boolean \n```", "```py\nIn [1]: pd.Categorical([1, 2, np.nan], ordered=True).min()\nOut[1]: nan \n```", "```py\nIn [47]: pd.Categorical([1, 2, np.nan], ordered=True).min()\nOut[47]: 1 \n```", "```py\nIn [1]: pd.Series()\nOut[2]:\nDeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\nSeries([], dtype: float64) \n```", "```py\nIn [48]: df = pd.DataFrame({\"A\": ['a', 'b']}, dtype='category',\n ....:                  index=pd.date_range('2000', periods=2))\n ....: \n\nIn [49]: df\nOut[49]: \n A\n2000-01-01  a\n2000-01-02  b \n```", "```py\nIn [1]> df.resample(\"2D\").agg(lambda x: 'a').A.dtype\nOut[1]:\nCategoricalDtype(categories=['a', 'b'], ordered=False) \n```", "```py\nIn [50]: df.resample(\"2D\").agg(lambda x: 'a').A.dtype\nOut[50]: CategoricalDtype(categories=['a', 'b'], ordered=False, categories_dtype=object) \n```", "```py\nIn [1] df.resample(\"2D\").agg(lambda x: 'c')\nOut[1]:\n\n     A\n0  NaN \n```", "```py\nIn [51]: df.resample(\"2D\").agg(lambda x: 'c')\nOut[51]: \n A\n2000-01-01  c \n```", "```py\ndf = pd.DataFrame({\n    \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n    \"B\": np.random.randn(8),\n    \"C\": np.random.randn(8),\n})\ng = df.groupby('A')\n\n# single key, returns SeriesGroupBy\ng['B']\n\n# tuple of single key, returns SeriesGroupBy\ng[('B',)]\n\n# tuple of multiple keys, returns DataFrameGroupBy, raises FutureWarning\ng[('B', 'C')]\n\n# multiple keys passed directly, returns DataFrameGroupBy, raises FutureWarning\n# (implicitly converts the passed strings into a single tuple)\ng['B', 'C']\n\n# proper way, returns DataFrameGroupBy\ng[['B', 'C']] \n```", "```py\nIn [1]: import pandas as pd\nIn [2]: pd.options.plotting.matplotlib.register_converters = True \n```", "```py\nIn [1]: df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [1, 2, 3]}, index=['a', 'a', 'b'])\n\nIn [2]: print(df.to_markdown())\n|    |   A |   B |\n|:---|----:|----:|\n| a  |   1 |   1 |\n| a  |   2 |   2 |\n| b  |   3 |   3 | \n```", "```py\nIn [1]: df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [1, 2, 3]}, index=['a', 'a', 'b'])\n\nIn [2]: print(df.to_markdown())\n|    |   A |   B |\n|:---|----:|----:|\n| a  |   1 |   1 |\n| a  |   2 |   2 |\n| b  |   3 |   3 | \n```", "```py\nIn [3]: s = pd.Series([1, 2, None], dtype=\"Int64\")\n\nIn [4]: s\nOut[4]: \n0       1\n1       2\n2    <NA>\ndtype: Int64\n\nIn [5]: s[2]\nOut[5]: <NA> \n```", "```py\nIn [6]: np.nan > 1\nOut[6]: False\n\nIn [7]: pd.NA > 1\nOut[7]: <NA> \n```", "```py\nIn [8]: pd.NA | True\nOut[8]: True \n```", "```py\nIn [9]: pd.Series(['abc', None, 'def'], dtype=pd.StringDtype())\nOut[9]: \n0     abc\n1    <NA>\n2     def\ndtype: string \n```", "```py\nIn [10]: s = pd.Series(['abc', None, 'def'], dtype=\"string\")\n\nIn [11]: s\nOut[11]: \n0     abc\n1    <NA>\n2     def\ndtype: string \n```", "```py\nIn [12]: s.str.upper()\nOut[12]: \n0     ABC\n1    <NA>\n2     DEF\ndtype: string\n\nIn [13]: s.str.split('b', expand=True).dtypes\nOut[13]: \n0    string[python]\n1    string[python]\ndtype: object \n```", "```py\nIn [14]: s.str.count(\"a\")\nOut[14]: \n0       1\n1    <NA>\n2       0\ndtype: Int64 \n```", "```py\nIn [15]: pd.Series([True, False, None], dtype=pd.BooleanDtype())\nOut[15]: \n0     True\n1    False\n2     <NA>\ndtype: boolean \n```", "```py\nIn [16]: s = pd.Series([True, False, None], dtype=\"boolean\")\n\nIn [17]: s\nOut[17]: \n0     True\n1    False\n2     <NA>\ndtype: boolean \n```", "```py\nIn [18]: df = pd.DataFrame({'x': ['abc', None, 'def'],\n ....:                   'y': [1, 2, np.nan],\n ....:                   'z': [True, False, True]})\n ....: \n\nIn [19]: df\nOut[19]: \n x    y      z\n0   abc  1.0   True\n1  None  2.0  False\n2   def  NaN   True\n\nIn [20]: df.dtypes\nOut[20]: \nx     object\ny    float64\nz       bool\ndtype: object \n```", "```py\nIn [21]: converted = df.convert_dtypes()\n\nIn [22]: converted\nOut[22]: \n x     y      z\n0   abc     1   True\n1  <NA>     2  False\n2   def  <NA>   True\n\nIn [23]: converted.dtypes\nOut[23]: \nx    string[python]\ny             Int64\nz           boolean\ndtype: object \n```", "```py\nIn [3]: s = pd.Series([1, 2, None], dtype=\"Int64\")\n\nIn [4]: s\nOut[4]: \n0       1\n1       2\n2    <NA>\ndtype: Int64\n\nIn [5]: s[2]\nOut[5]: <NA> \n```", "```py\nIn [6]: np.nan > 1\nOut[6]: False\n\nIn [7]: pd.NA > 1\nOut[7]: <NA> \n```", "```py\nIn [8]: pd.NA | True\nOut[8]: True \n```", "```py\nIn [9]: pd.Series(['abc', None, 'def'], dtype=pd.StringDtype())\nOut[9]: \n0     abc\n1    <NA>\n2     def\ndtype: string \n```", "```py\nIn [10]: s = pd.Series(['abc', None, 'def'], dtype=\"string\")\n\nIn [11]: s\nOut[11]: \n0     abc\n1    <NA>\n2     def\ndtype: string \n```", "```py\nIn [12]: s.str.upper()\nOut[12]: \n0     ABC\n1    <NA>\n2     DEF\ndtype: string\n\nIn [13]: s.str.split('b', expand=True).dtypes\nOut[13]: \n0    string[python]\n1    string[python]\ndtype: object \n```", "```py\nIn [14]: s.str.count(\"a\")\nOut[14]: \n0       1\n1    <NA>\n2       0\ndtype: Int64 \n```", "```py\nIn [15]: pd.Series([True, False, None], dtype=pd.BooleanDtype())\nOut[15]: \n0     True\n1    False\n2     <NA>\ndtype: boolean \n```", "```py\nIn [16]: s = pd.Series([True, False, None], dtype=\"boolean\")\n\nIn [17]: s\nOut[17]: \n0     True\n1    False\n2     <NA>\ndtype: boolean \n```", "```py\nIn [18]: df = pd.DataFrame({'x': ['abc', None, 'def'],\n ....:                   'y': [1, 2, np.nan],\n ....:                   'z': [True, False, True]})\n ....: \n\nIn [19]: df\nOut[19]: \n x    y      z\n0   abc  1.0   True\n1  None  2.0  False\n2   def  NaN   True\n\nIn [20]: df.dtypes\nOut[20]: \nx     object\ny    float64\nz       bool\ndtype: object \n```", "```py\nIn [21]: converted = df.convert_dtypes()\n\nIn [22]: converted\nOut[22]: \n x     y      z\n0   abc     1   True\n1  <NA>     2  False\n2   def  <NA>   True\n\nIn [23]: converted.dtypes\nOut[23]: \nx    string[python]\ny             Int64\nz           boolean\ndtype: object \n```", "```py\nIn [24]: mi = pd.MultiIndex.from_product([[1, 2], ['a', 'b']], names=['x', 'y'])\n\nIn [25]: mi.levels[0].name\nOut[25]: 'x' \n```", "```py\nIn [26]: mi.levels[0].name = \"new name\"\n---------------------------------------------------------------------------\nRuntimeError  Traceback (most recent call last)\nCell In[26], line 1\n----> 1 mi.levels[0].name = \"new name\"\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:1690, in Index.name(self, value)\n  1686 @name.setter\n  1687 def name(self, value: Hashable) -> None:\n  1688     if self._no_setting_name:\n  1689         # Used in MultiIndex.levels to avoid silently ignoring name updates.\n-> 1690         raise RuntimeError(\n  1691             \"Cannot set name on a level of a MultiIndex. Use \"\n  1692             \"'MultiIndex.set_names' instead.\"\n  1693         )\n  1694     maybe_extract_name(value, None, type(self))\n  1695     self._name = value\n\nRuntimeError: Cannot set name on a level of a MultiIndex. Use 'MultiIndex.set_names' instead.\n\nIn [27]: mi.names\nOut[27]: FrozenList(['x', 'y']) \n```", "```py\nIn [28]: mi2 = mi.set_names(\"new name\", level=0)\n\nIn [29]: mi2.names\nOut[29]: FrozenList(['new name', 'y']) \n```", "```py\nIn [1]: pd.arrays.IntervalArray.from_tuples([(0, 1), (2, 3)])\nOut[2]:\nIntervalArray([(0, 1], (2, 3]],\n closed='right',\n dtype='interval[int64]') \n```", "```py\nIn [30]: pd.arrays.IntervalArray.from_tuples([(0, 1), (2, 3)])\nOut[30]: \n<IntervalArray>\n[(0, 1], (2, 3]]\nLength: 2, dtype: interval[int64, right] \n```", "```py\nIn [1]: df = pd.DataFrame([[1]])\nIn [2]: df.rename({0: 1}, {0: 2})\nOut[2]:\nFutureWarning: ...Use named arguments to resolve ambiguity...\n 2\n1  1 \n```", "```py\nIn [3]: df.rename({0: 1}, {0: 2})\nTraceback (most recent call last):\n...\nTypeError: rename() takes from 1 to 2 positional arguments but 3 were given \n```", "```py\nIn [4]: df.rename({0: 1}, index={0: 2})\nOut[4]:\n 0\n1  1\n\nIn [5]: df.rename(mapper={0: 1}, index={0: 2})\nOut[5]:\n 0\n2  1 \n```", "```py\nIn [6]: df.rename({0: 1}, index={0: 2})\nTraceback (most recent call last):\n...\nTypeError: Cannot specify both 'mapper' and any of 'index' or 'columns'\n\nIn [7]: df.rename(mapper={0: 1}, index={0: 2})\nTraceback (most recent call last):\n...\nTypeError: Cannot specify both 'mapper' and any of 'index' or 'columns' \n```", "```py\nIn [31]: df.rename({0: 1})\nOut[31]: \n 0\n1  1\n\nIn [32]: df.rename({0: 1}, axis=1)\nOut[32]: \n 1\n0  1 \n```", "```py\nIn [33]: df.rename(index={0: 1}, columns={0: 2})\nOut[33]: \n 2\n1  1 \n```", "```py\nIn [1]: df = pd.DataFrame({\"int_col\": [1, 2, 3],\n...                    \"text_col\": [\"a\", \"b\", \"c\"],\n...                    \"float_col\": [0.0, 0.1, 0.2]})\nIn [2]: df.info(verbose=True)\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nint_col      3 non-null int64\ntext_col     3 non-null object\nfloat_col    3 non-null float64\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 152.0+ bytes \n```", "```py\nIn [34]: df = pd.DataFrame({\"int_col\": [1, 2, 3],\n ....:                   \"text_col\": [\"a\", \"b\", \"c\"],\n ....:                   \"float_col\": [0.0, 0.1, 0.2]})\n ....: \n\nIn [35]: df.info(verbose=True)\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\n #   Column     Non-Null Count  Dtype \n---  ------     --------------  ----- \n 0   int_col    3 non-null      int64 \n 1   text_col   3 non-null      object \n 2   float_col  3 non-null      float64\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 200.0+ bytes \n```", "```py\nIn [1]: pd.array([\"a\", None])\nOut[1]:\n<PandasArray>\n['a', None]\nLength: 2, dtype: object\n\nIn [2]: pd.array([1, None])\nOut[2]:\n<PandasArray>\n[1, None]\nLength: 2, dtype: object \n```", "```py\nIn [36]: pd.array([\"a\", None])\nOut[36]: \n<StringArray>\n['a', <NA>]\nLength: 2, dtype: string\n\nIn [37]: pd.array([1, None])\nOut[37]: \n<IntegerArray>\n[1, <NA>]\nLength: 2, dtype: Int64 \n```", "```py\nIn [1]: a = pd.array([1, 2, None], dtype=\"Int64\")\nIn [2]: a\nOut[2]:\n<IntegerArray>\n[1, 2, NaN]\nLength: 3, dtype: Int64\n\nIn [3]: a[2]\nOut[3]:\nnan \n```", "```py\nIn [38]: a = pd.array([1, 2, None], dtype=\"Int64\")\n\nIn [39]: a\nOut[39]: \n<IntegerArray>\n[1, 2, <NA>]\nLength: 3, dtype: Int64\n\nIn [40]: a[2]\nOut[40]: <NA> \n```", "```py\nIn [1]: np.asarray(a, dtype=\"float\")\nOut[1]:\narray([ 1.,  2., nan]) \n```", "```py\nIn [41]: np.asarray(a, dtype=\"float\")\nOut[41]: array([ 1.,  2., nan]) \n```", "```py\nIn [42]: a.to_numpy(dtype=\"float\", na_value=np.nan)\nOut[42]: array([ 1.,  2., nan]) \n```", "```py\nIn [1]: pd.Series(a).sum(skipna=False)\nOut[1]:\nnan \n```", "```py\nIn [43]: pd.Series(a).sum(skipna=False)\nOut[43]: <NA> \n```", "```py\nIn [1]: pd.Series([2, 1, 1, None], dtype=\"Int64\").value_counts().dtype\nOut[1]:\ndtype('int64') \n```", "```py\nIn [44]: pd.Series([2, 1, 1, None], dtype=\"Int64\").value_counts().dtype\nOut[44]: Int64Dtype() \n```", "```py\nIn [1]: a = pd.array([1, 2, None], dtype=\"Int64\")\nIn [2]: a\nOut[2]:\n<IntegerArray>\n[1, 2, NaN]\nLength: 3, dtype: Int64\n\nIn [3]: a > 1\nOut[3]:\narray([False,  True, False]) \n```", "```py\nIn [45]: a = pd.array([1, 2, None], dtype=\"Int64\")\n\nIn [46]: a > 1\nOut[46]: \n<BooleanArray>\n[False, True, <NA>]\nLength: 3, dtype: boolean \n```", "```py\nIn [1]: pd.Categorical([1, 2, np.nan], ordered=True).min()\nOut[1]: nan \n```", "```py\nIn [47]: pd.Categorical([1, 2, np.nan], ordered=True).min()\nOut[47]: 1 \n```", "```py\nIn [1]: pd.Series()\nOut[2]:\nDeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\nSeries([], dtype: float64) \n```", "```py\nIn [48]: df = pd.DataFrame({\"A\": ['a', 'b']}, dtype='category',\n ....:                  index=pd.date_range('2000', periods=2))\n ....: \n\nIn [49]: df\nOut[49]: \n A\n2000-01-01  a\n2000-01-02  b \n```", "```py\nIn [1]> df.resample(\"2D\").agg(lambda x: 'a').A.dtype\nOut[1]:\nCategoricalDtype(categories=['a', 'b'], ordered=False) \n```", "```py\nIn [50]: df.resample(\"2D\").agg(lambda x: 'a').A.dtype\nOut[50]: CategoricalDtype(categories=['a', 'b'], ordered=False, categories_dtype=object) \n```", "```py\nIn [1] df.resample(\"2D\").agg(lambda x: 'c')\nOut[1]:\n\n     A\n0  NaN \n```", "```py\nIn [51]: df.resample(\"2D\").agg(lambda x: 'c')\nOut[51]: \n A\n2000-01-01  c \n```", "```py\nIn [24]: mi = pd.MultiIndex.from_product([[1, 2], ['a', 'b']], names=['x', 'y'])\n\nIn [25]: mi.levels[0].name\nOut[25]: 'x' \n```", "```py\nIn [26]: mi.levels[0].name = \"new name\"\n---------------------------------------------------------------------------\nRuntimeError  Traceback (most recent call last)\nCell In[26], line 1\n----> 1 mi.levels[0].name = \"new name\"\n\nFile ~/work/pandas/pandas/pandas/core/indexes/base.py:1690, in Index.name(self, value)\n  1686 @name.setter\n  1687 def name(self, value: Hashable) -> None:\n  1688     if self._no_setting_name:\n  1689         # Used in MultiIndex.levels to avoid silently ignoring name updates.\n-> 1690         raise RuntimeError(\n  1691             \"Cannot set name on a level of a MultiIndex. Use \"\n  1692             \"'MultiIndex.set_names' instead.\"\n  1693         )\n  1694     maybe_extract_name(value, None, type(self))\n  1695     self._name = value\n\nRuntimeError: Cannot set name on a level of a MultiIndex. Use 'MultiIndex.set_names' instead.\n\nIn [27]: mi.names\nOut[27]: FrozenList(['x', 'y']) \n```", "```py\nIn [28]: mi2 = mi.set_names(\"new name\", level=0)\n\nIn [29]: mi2.names\nOut[29]: FrozenList(['new name', 'y']) \n```", "```py\nIn [1]: pd.arrays.IntervalArray.from_tuples([(0, 1), (2, 3)])\nOut[2]:\nIntervalArray([(0, 1], (2, 3]],\n closed='right',\n dtype='interval[int64]') \n```", "```py\nIn [30]: pd.arrays.IntervalArray.from_tuples([(0, 1), (2, 3)])\nOut[30]: \n<IntervalArray>\n[(0, 1], (2, 3]]\nLength: 2, dtype: interval[int64, right] \n```", "```py\nIn [1]: df = pd.DataFrame([[1]])\nIn [2]: df.rename({0: 1}, {0: 2})\nOut[2]:\nFutureWarning: ...Use named arguments to resolve ambiguity...\n 2\n1  1 \n```", "```py\nIn [3]: df.rename({0: 1}, {0: 2})\nTraceback (most recent call last):\n...\nTypeError: rename() takes from 1 to 2 positional arguments but 3 were given \n```", "```py\nIn [4]: df.rename({0: 1}, index={0: 2})\nOut[4]:\n 0\n1  1\n\nIn [5]: df.rename(mapper={0: 1}, index={0: 2})\nOut[5]:\n 0\n2  1 \n```", "```py\nIn [6]: df.rename({0: 1}, index={0: 2})\nTraceback (most recent call last):\n...\nTypeError: Cannot specify both 'mapper' and any of 'index' or 'columns'\n\nIn [7]: df.rename(mapper={0: 1}, index={0: 2})\nTraceback (most recent call last):\n...\nTypeError: Cannot specify both 'mapper' and any of 'index' or 'columns' \n```", "```py\nIn [31]: df.rename({0: 1})\nOut[31]: \n 0\n1  1\n\nIn [32]: df.rename({0: 1}, axis=1)\nOut[32]: \n 1\n0  1 \n```", "```py\nIn [33]: df.rename(index={0: 1}, columns={0: 2})\nOut[33]: \n 2\n1  1 \n```", "```py\nIn [1]: df = pd.DataFrame({\"int_col\": [1, 2, 3],\n...                    \"text_col\": [\"a\", \"b\", \"c\"],\n...                    \"float_col\": [0.0, 0.1, 0.2]})\nIn [2]: df.info(verbose=True)\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\nint_col      3 non-null int64\ntext_col     3 non-null object\nfloat_col    3 non-null float64\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 152.0+ bytes \n```", "```py\nIn [34]: df = pd.DataFrame({\"int_col\": [1, 2, 3],\n ....:                   \"text_col\": [\"a\", \"b\", \"c\"],\n ....:                   \"float_col\": [0.0, 0.1, 0.2]})\n ....: \n\nIn [35]: df.info(verbose=True)\n<class 'pandas.core.frame.DataFrame'>\nRangeIndex: 3 entries, 0 to 2\nData columns (total 3 columns):\n #   Column     Non-Null Count  Dtype \n---  ------     --------------  ----- \n 0   int_col    3 non-null      int64 \n 1   text_col   3 non-null      object \n 2   float_col  3 non-null      float64\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 200.0+ bytes \n```", "```py\nIn [1]: pd.array([\"a\", None])\nOut[1]:\n<PandasArray>\n['a', None]\nLength: 2, dtype: object\n\nIn [2]: pd.array([1, None])\nOut[2]:\n<PandasArray>\n[1, None]\nLength: 2, dtype: object \n```", "```py\nIn [36]: pd.array([\"a\", None])\nOut[36]: \n<StringArray>\n['a', <NA>]\nLength: 2, dtype: string\n\nIn [37]: pd.array([1, None])\nOut[37]: \n<IntegerArray>\n[1, <NA>]\nLength: 2, dtype: Int64 \n```", "```py\nIn [1]: a = pd.array([1, 2, None], dtype=\"Int64\")\nIn [2]: a\nOut[2]:\n<IntegerArray>\n[1, 2, NaN]\nLength: 3, dtype: Int64\n\nIn [3]: a[2]\nOut[3]:\nnan \n```", "```py\nIn [38]: a = pd.array([1, 2, None], dtype=\"Int64\")\n\nIn [39]: a\nOut[39]: \n<IntegerArray>\n[1, 2, <NA>]\nLength: 3, dtype: Int64\n\nIn [40]: a[2]\nOut[40]: <NA> \n```", "```py\nIn [1]: np.asarray(a, dtype=\"float\")\nOut[1]:\narray([ 1.,  2., nan]) \n```", "```py\nIn [41]: np.asarray(a, dtype=\"float\")\nOut[41]: array([ 1.,  2., nan]) \n```", "```py\nIn [42]: a.to_numpy(dtype=\"float\", na_value=np.nan)\nOut[42]: array([ 1.,  2., nan]) \n```", "```py\nIn [1]: pd.Series(a).sum(skipna=False)\nOut[1]:\nnan \n```", "```py\nIn [43]: pd.Series(a).sum(skipna=False)\nOut[43]: <NA> \n```", "```py\nIn [1]: pd.Series([2, 1, 1, None], dtype=\"Int64\").value_counts().dtype\nOut[1]:\ndtype('int64') \n```", "```py\nIn [44]: pd.Series([2, 1, 1, None], dtype=\"Int64\").value_counts().dtype\nOut[44]: Int64Dtype() \n```", "```py\nIn [1]: a = pd.array([1, 2, None], dtype=\"Int64\")\nIn [2]: a\nOut[2]:\n<IntegerArray>\n[1, 2, NaN]\nLength: 3, dtype: Int64\n\nIn [3]: a > 1\nOut[3]:\narray([False,  True, False]) \n```", "```py\nIn [45]: a = pd.array([1, 2, None], dtype=\"Int64\")\n\nIn [46]: a > 1\nOut[46]: \n<BooleanArray>\n[False, True, <NA>]\nLength: 3, dtype: boolean \n```", "```py\nIn [1]: pd.Categorical([1, 2, np.nan], ordered=True).min()\nOut[1]: nan \n```", "```py\nIn [47]: pd.Categorical([1, 2, np.nan], ordered=True).min()\nOut[47]: 1 \n```", "```py\nIn [1]: pd.Series()\nOut[2]:\nDeprecationWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\nSeries([], dtype: float64) \n```", "```py\nIn [48]: df = pd.DataFrame({\"A\": ['a', 'b']}, dtype='category',\n ....:                  index=pd.date_range('2000', periods=2))\n ....: \n\nIn [49]: df\nOut[49]: \n A\n2000-01-01  a\n2000-01-02  b \n```", "```py\nIn [1]> df.resample(\"2D\").agg(lambda x: 'a').A.dtype\nOut[1]:\nCategoricalDtype(categories=['a', 'b'], ordered=False) \n```", "```py\nIn [50]: df.resample(\"2D\").agg(lambda x: 'a').A.dtype\nOut[50]: CategoricalDtype(categories=['a', 'b'], ordered=False, categories_dtype=object) \n```", "```py\nIn [1] df.resample(\"2D\").agg(lambda x: 'c')\nOut[1]:\n\n     A\n0  NaN \n```", "```py\nIn [51]: df.resample(\"2D\").agg(lambda x: 'c')\nOut[51]: \n A\n2000-01-01  c \n```", "```py\ndf = pd.DataFrame({\n    \"A\": [\"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"bar\", \"foo\", \"foo\"],\n    \"B\": np.random.randn(8),\n    \"C\": np.random.randn(8),\n})\ng = df.groupby('A')\n\n# single key, returns SeriesGroupBy\ng['B']\n\n# tuple of single key, returns SeriesGroupBy\ng[('B',)]\n\n# tuple of multiple keys, returns DataFrameGroupBy, raises FutureWarning\ng[('B', 'C')]\n\n# multiple keys passed directly, returns DataFrameGroupBy, raises FutureWarning\n# (implicitly converts the passed strings into a single tuple)\ng['B', 'C']\n\n# proper way, returns DataFrameGroupBy\ng[['B', 'C']] \n```", "```py\nIn [1]: import pandas as pd\nIn [2]: pd.options.plotting.matplotlib.register_converters = True \n```"]