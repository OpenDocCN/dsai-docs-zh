- en: Numeric Computation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/numeric-computation.html](https://docs.sympy.org/latest/modules/numeric-computation.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Symbolic computer algebra systems like SymPy facilitate the construction and
    manipulation of mathematical expressions. Unfortunately when it comes time to
    evaluate these expressions on numerical data, symbolic systems often have poor
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately SymPy offers a number of easy-to-use hooks into other numeric systems,
    allowing you to create mathematical expressions in SymPy and then ship them off
    to the numeric system of your choice. This page documents many of the options
    available including the `math` library, the popular array computing package `numpy`,
    code generation in `Fortran` or `C`, and the use of the array compiler `Aesara`.
  prefs: []
  type: TYPE_NORMAL
- en: Subs/evalf
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subs is the slowest but simplest option. It runs at SymPy speeds. The `.subs(...).evalf()`
    method can substitute a numeric value for a symbolic one and then evaluate the
    result within SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This method is slow. You should use this method production only if performance
    is not an issue. You can expect `.subs` to take tens of microseconds. It can be
    useful while prototyping or if you just want to see a value once.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `lambdify` function translates SymPy expressions into Python functions,
    leveraging a variety of numerical libraries. It is used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here lambdify makes a function that computes `f(x) = sin(x)/x`. By default lambdify
    relies on implementations in the `math` standard library. This numerical evaluation
    takes on the order of hundreds of nanoseconds, roughly two orders of magnitude
    faster than the `.subs` method. This is the speed difference between SymPy and
    raw Python.
  prefs: []
  type: TYPE_NORMAL
- en: Lambdify can leverage a variety of numerical backends. By default it uses the
    `math` library. However it also supports `mpmath` and most notably, `numpy`. Using
    the `numpy` library gives the generated function access to powerful vectorized
    ufuncs that are backed by compiled C code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If you have array-based data this can confer a considerable speedup, on the
    order of 10 nano-seconds per element. Unfortunately numpy incurs some start-up
    time and introduces an overhead of a few microseconds.
  prefs: []
  type: TYPE_NORMAL
- en: CuPy is a NumPy-compatible array library that mainly runs on CUDA, but has increasing
    support for other GPU manufacturers. It can in many cases be used as a drop-in
    replacement for numpy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: JAX is a similar alternative to CuPy that provides GPU and TPU acceleration
    via just-in-time compilation to XLA. It too, can in some cases, be used as a drop-in
    replacement for numpy.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: uFuncify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `autowrap` module contains methods that help in efficient computation.
  prefs: []
  type: TYPE_NORMAL
- en: '[autowrap](codegen.html#id1) method for compiling code generated by the [codegen](codegen.html#codegen-prose)
    module, and wrap the binary for use in python.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[binary_function](codegen.html#binary-function) method automates the steps
    needed to autowrap the SymPy expression and attaching it to a `Function` object
    with `implemented_function()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[ufuncify](codegen.html#ufuncify-method) generates a binary function that supports
    broadcasting on numpy arrays using different backends that are faster as compared
    to `subs/evalf` and `lambdify`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The API reference of all the above is listed here: [`sympy.utilities.autowrap()`](utilities/autowrap.html#module-sympy.utilities.autowrap
    "sympy.utilities.autowrap").'
  prefs: []
  type: TYPE_NORMAL
- en: Aesara
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SymPy has a strong connection with [Aesara](https://aesara.readthedocs.io/en/latest/),
    a mathematical array compiler. SymPy expressions can be easily translated to Aesara
    graphs and then compiled using the Aesara compiler chain.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If array broadcasting or types are desired then Aesara requires this extra information
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Aesara has a more sophisticated code generation system than SymPy’s C/Fortran
    code printers. Among other things it handles common sub-expressions and compilation
    onto the GPU. Aesara also supports SymPy Matrix and Matrix Expression objects.
  prefs: []
  type: TYPE_NORMAL
- en: So Which Should I Use?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The options here were listed in order from slowest and least dependencies to
    fastest and most dependencies. For example, if you have Aesara installed then
    that will often be the best choice. If you don’t have Aesara but do have `f2py`
    then you should use `ufuncify`. If you have been comfortable using lambdify with
    the numpy module, but have a GPU, CuPy and JAX can provide substantial speedups
    with little effort.
  prefs: []
  type: TYPE_NORMAL
- en: '| Tool | Speed | Qualities | Dependencies |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| subs/evalf | 50us | Simple | None |'
  prefs: []
  type: TYPE_TB
- en: '| lambdify | 1us | Scalar functions | math |'
  prefs: []
  type: TYPE_TB
- en: '| lambdify-numpy | 10ns | Vector functions | numpy |'
  prefs: []
  type: TYPE_TB
- en: '| ufuncify | 10ns | Complex vector expressions | f2py, Cython |'
  prefs: []
  type: TYPE_TB
- en: '| lambdify-cupy | 10ns | Vector functions on GPUs | cupy |'
  prefs: []
  type: TYPE_TB
- en: '| lambdify-jax | 10ns | Vector functions on CPUs, GPUs and TPUs | jax |'
  prefs: []
  type: TYPE_TB
- en: '| Aesara | 10ns | Many outputs, CSE, GPUs | Aesara |'
  prefs: []
  type: TYPE_TB
