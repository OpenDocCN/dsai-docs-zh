- en: scipy.spatial.cKDTree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.spatial.cKDTree.html#scipy.spatial.cKDTree](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.spatial.cKDTree.html#scipy.spatial.cKDTree)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: kd-tree for quick nearest-neighbor lookup
  prefs: []
  type: TYPE_NORMAL
- en: This class provides an index into a set of k-dimensional points which can be
    used to rapidly look up the nearest neighbors of any point.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`cKDTree`](#scipy.spatial.cKDTree "scipy.spatial.cKDTree") is functionally
    identical to [`KDTree`](scipy.spatial.KDTree.html#scipy.spatial.KDTree "scipy.spatial.KDTree").
    Prior to SciPy v1.6.0, [`cKDTree`](#scipy.spatial.cKDTree "scipy.spatial.cKDTree")
    had better performance and slightly different functionality but now the two names
    exist only for backward-compatibility reasons. If compatibility with SciPy < 1.6
    is not a concern, prefer [`KDTree`](scipy.spatial.KDTree.html#scipy.spatial.KDTree
    "scipy.spatial.KDTree").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**data**array_like, shape (n,m)'
  prefs: []
  type: TYPE_NORMAL
- en: The n data points of dimension m to be indexed. This array is not copied unless
    this is necessary to produce a contiguous array of doubles, and so modifying this
    data will result in bogus results. The data are also copied if the kd-tree is
    built with copy_data=True.
  prefs: []
  type: TYPE_NORMAL
- en: '**leafsize**positive int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of points at which the algorithm switches over to brute-force. Default:
    16.'
  prefs: []
  type: TYPE_NORMAL
- en: '**compact_nodes**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'If True, the kd-tree is built to shrink the hyperrectangles to the actual data
    range. This usually gives a more compact tree that is robust against degenerated
    input data and gives faster queries at the expense of longer build time. Default:
    True.'
  prefs: []
  type: TYPE_NORMAL
- en: '**copy_data**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'If True the data is always copied to protect the kd-tree against data corruption.
    Default: False.'
  prefs: []
  type: TYPE_NORMAL
- en: '**balanced_tree**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'If True, the median is used to split the hyperrectangles instead of the midpoint.
    This usually gives a more compact tree and faster queries at the expense of longer
    build time. Default: True.'
  prefs: []
  type: TYPE_NORMAL
- en: '**boxsize**array_like or scalar, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a m-d toroidal topology to the KDTree.. The topology is generated by \(x_i
    + n_i L_i\) where \(n_i\) are integers and \(L_i\) is the boxsize along i-th dimension.
    The input data shall be wrapped into \([0, L_i)\). A ValueError is raised if any
    of the data is outside of this bound.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm used is described in Maneewongvatana and Mount 1999. The general
    idea is that the kd-tree is a binary tree, each of whose nodes represents an axis-aligned
    hyperrectangle. Each node specifies an axis and splits the set of points based
    on whether their coordinate along that axis is greater than or less than a particular
    value.
  prefs: []
  type: TYPE_NORMAL
- en: During construction, the axis and splitting point are chosen by the “sliding
    midpoint” rule, which ensures that the cells do not all become long and thin.
  prefs: []
  type: TYPE_NORMAL
- en: The tree can be queried for the r closest neighbors of any given point (optionally
    returning only those within some maximum distance of the point). It can also be
    queried, with a substantial gain in efficiency, for the r approximate closest
    neighbors.
  prefs: []
  type: TYPE_NORMAL
- en: For large dimensions (20 is already large) do not expect this to run significantly
    faster than brute force. High-dimensional nearest-neighbor queries are a substantial
    open problem in computer science.
  prefs: []
  type: TYPE_NORMAL
- en: 'Attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**data**ndarray, shape (n,m)'
  prefs: []
  type: TYPE_NORMAL
- en: The n data points of dimension m to be indexed. This array is not copied unless
    this is necessary to produce a contiguous array of doubles. The data are also
    copied if the kd-tree is built with *copy_data=True*.
  prefs: []
  type: TYPE_NORMAL
- en: '**leafsize**positive int'
  prefs: []
  type: TYPE_NORMAL
- en: The number of points at which the algorithm switches over to brute-force.
  prefs: []
  type: TYPE_NORMAL
- en: '**m**int'
  prefs: []
  type: TYPE_NORMAL
- en: The dimension of a single data-point.
  prefs: []
  type: TYPE_NORMAL
- en: '**n**int'
  prefs: []
  type: TYPE_NORMAL
- en: The number of data points.
  prefs: []
  type: TYPE_NORMAL
- en: '**maxes**ndarray, shape (m,)'
  prefs: []
  type: TYPE_NORMAL
- en: The maximum value in each dimension of the n data points.
  prefs: []
  type: TYPE_NORMAL
- en: '**mins**ndarray, shape (m,)'
  prefs: []
  type: TYPE_NORMAL
- en: The minimum value in each dimension of the n data points.
  prefs: []
  type: TYPE_NORMAL
- en: '**tree**object, class cKDTreeNode'
  prefs: []
  type: TYPE_NORMAL
- en: This attribute exposes a Python view of the root node in the cKDTree object.
    A full Python view of the kd-tree is created dynamically on the first access.
    This attribute allows you to create your own query functions in Python.
  prefs: []
  type: TYPE_NORMAL
- en: '**size**int'
  prefs: []
  type: TYPE_NORMAL
- en: The number of nodes in the tree.
  prefs: []
  type: TYPE_NORMAL
- en: Methods
  prefs: []
  type: TYPE_NORMAL
- en: '| [`count_neighbors`](scipy.spatial.cKDTree.count_neighbors.html#scipy.spatial.cKDTree.count_neighbors
    "scipy.spatial.cKDTree.count_neighbors")(self, other, r[, p, ...]) | Count how
    many nearby pairs can be formed. |'
  prefs: []
  type: TYPE_TB
- en: '| [`query`](scipy.spatial.cKDTree.query.html#scipy.spatial.cKDTree.query "scipy.spatial.cKDTree.query")(self, x[, k, eps, p, ...])
    | Query the kd-tree for nearest neighbors |'
  prefs: []
  type: TYPE_TB
- en: '| [`query_ball_point`](scipy.spatial.cKDTree.query_ball_point.html#scipy.spatial.cKDTree.query_ball_point
    "scipy.spatial.cKDTree.query_ball_point")(self, x, r[, p, eps, ...]) | Find all
    points within distance r of point(s) x. |'
  prefs: []
  type: TYPE_TB
- en: '| [`query_ball_tree`](scipy.spatial.cKDTree.query_ball_tree.html#scipy.spatial.cKDTree.query_ball_tree
    "scipy.spatial.cKDTree.query_ball_tree")(self, other, r[, p, eps]) | Find all
    pairs of points between *self* and *other* whose distance is at most r |'
  prefs: []
  type: TYPE_TB
- en: '| [`query_pairs`](scipy.spatial.cKDTree.query_pairs.html#scipy.spatial.cKDTree.query_pairs
    "scipy.spatial.cKDTree.query_pairs")(self, r[, p, eps, output_type]) | Find all
    pairs of points in *self* whose distance is at most r. |'
  prefs: []
  type: TYPE_TB
- en: '| [`sparse_distance_matrix`](scipy.spatial.cKDTree.sparse_distance_matrix.html#scipy.spatial.cKDTree.sparse_distance_matrix
    "scipy.spatial.cKDTree.sparse_distance_matrix")(self, other, max_distance) | Compute
    a sparse distance matrix |'
  prefs: []
  type: TYPE_TB
