- en: scipy.linalg.solve_continuous_are
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.solve_continuous_are.html#scipy.linalg.solve_continuous_are](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.linalg.solve_continuous_are.html#scipy.linalg.solve_continuous_are)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Solves the continuous-time algebraic Riccati equation (CARE).
  prefs: []
  type: TYPE_NORMAL
- en: The CARE is defined as
  prefs: []
  type: TYPE_NORMAL
- en: \[X A + A^H X - X B R^{-1} B^H X + Q = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: 'The limitations for a solution to exist are :'
  prefs: []
  type: TYPE_NORMAL
- en: All eigenvalues of \(A\) on the right half plane, should be controllable.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: The associated hamiltonian pencil (See Notes), should have eigenvalues sufficiently
    away from the imaginary axis.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, if `e` or `s` is not precisely `None`, then the generalized version
    of CARE
  prefs: []
  type: TYPE_NORMAL
- en: \[E^HXA + A^HXE - (E^HXB + S) R^{-1} (B^HXE + S^H) + Q = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: is solved. When omitted, `e` is assumed to be the identity and `s` is assumed
    to be the zero matrix with sizes compatible with `a` and `b`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**(M, M) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Square matrix
  prefs: []
  type: TYPE_NORMAL
- en: '**b**(M, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs: []
  type: TYPE_NORMAL
- en: '**q**(M, M) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs: []
  type: TYPE_NORMAL
- en: '**r**(N, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Nonsingular square matrix
  prefs: []
  type: TYPE_NORMAL
- en: '**e**(M, M) array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Nonsingular square matrix
  prefs: []
  type: TYPE_NORMAL
- en: '**s**(M, N) array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Input
  prefs: []
  type: TYPE_NORMAL
- en: '**balanced**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The boolean that indicates whether a balancing step is performed on the data.
    The default is set to True.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**(M, M) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Solution to the continuous-time algebraic Riccati equation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: LinAlgError
  prefs: []
  type: TYPE_NORMAL
- en: For cases where the stable subspace of the pencil could not be isolated. See
    Notes section and the references for details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`solve_discrete_are`](scipy.linalg.solve_discrete_are.html#scipy.linalg.solve_discrete_are
    "scipy.linalg.solve_discrete_are")'
  prefs: []
  type: TYPE_NORMAL
- en: Solves the discrete-time algebraic Riccati equation
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: The equation is solved by forming the extended hamiltonian matrix pencil, as
    described in [[1]](#r3fec4c36fde1-1), \(H - \lambda J\) given by the block matrices
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: and using a QZ decomposition method.
  prefs: []
  type: TYPE_NORMAL
- en: In this algorithm, the fail conditions are linked to the symmetry of the product
    \(U_2 U_1^{-1}\) and condition number of \(U_1\). Here, \(U\) is the 2m-by-m matrix
    that holds the eigenvectors spanning the stable subspace with 2-m rows and partitioned
    into two m-row matrices. See [[1]](#r3fec4c36fde1-1) and [[2]](#r3fec4c36fde1-2)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: In order to improve the QZ decomposition accuracy, the pencil goes through a
    balancing step where the sum of absolute values of \(H\) and \(J\) entries (after
    removing the diagonal entries of the sum) is balanced following the recipe given
    in [[3]](#r3fec4c36fde1-3).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1] ([1](#id1),[2](#id2))'
  prefs: []
  type: TYPE_NORMAL
- en: P. van Dooren , “A Generalized Eigenvalue Approach For Solving Riccati Equations.”,
    SIAM Journal on Scientific and Statistical Computing, Vol.2(2), [DOI:10.1137/0902010](https://doi.org/10.1137/0902010)
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'A.J. Laub, “A Schur Method for Solving Algebraic Riccati Equations.”, Massachusetts
    Institute of Technology. Laboratory for Information and Decision Systems. LIDS-R
    ; 859\. Available online : [http://hdl.handle.net/1721.1/1301](http://hdl.handle.net/1721.1/1301)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[3](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: P. Benner, “Symplectic Balancing of Hamiltonian Matrices”, 2001, SIAM J. Sci.
    Comput., 2001, Vol.22(5), [DOI:10.1137/S1064827500367993](https://doi.org/10.1137/S1064827500367993)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Given *a*, *b*, *q*, and *r* solve for *x*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
