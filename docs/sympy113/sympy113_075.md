# 特殊

> 原文：[SymPy文档](https://docs.sympy.org/latest/modules/functions/special.html)

## Dirac Delta和相关的不连续函数

```py
class sympy.functions.special.delta_functions.DiracDelta(arg, k=0)
```

DiracDelta函数及其导数。

解释

DiracDelta不是普通函数。它可以严格地定义为分布或测度之一。

DiracDelta只在定积分中有意义，特别是在形如 `Integral(f(x)*DiracDelta(x - x0), (x, a, b))` 的积分中，当 `a <= x0 <= b` 时，结果为 `f(x0)`，否则为 `0`。形式上，DiracDelta在某些方面表现得像是一个在除了 `0` 外都是 `0` 的函数，但在许多方面又不是这样。在形式化地处理Delta函数时通常很有用，构建和操作包含Delta函数的表达式（最终可能被积分），但需要小心不要将其视为真实函数。SymPy的 `oo` 类似，它只在某些上下文中形式上有意义（如积分限），但SymPy允许在任何地方使用它，并且它尝试在其上执行操作时保持一致性（如 `1/oo`），但如果过度将 `oo` 视为数字，则很容易出错并得到错误的结果。类似地，如果过度将DiracDelta视为函数，则很容易得到错误或无意义的结果。

DiracDelta函数具有以下特性：

1.  \(\frac{d}{d x} \theta(x) = \delta(x)\)

1.  \(\int_{-\infty}^\infty \delta(x - a)f(x)\, dx = f(a)\)，以及 \(\int_{a- \epsilon}^{a+\epsilon} \delta(x - a)f(x)\, dx = f(a)\)

1.  \(\delta(x) = 0\)，对所有的 \(x \neq 0\)

1.  \(\delta(g(x)) = \sum_i \frac{\delta(x - x_i)}{\|g'(x_i)\|}\)，其中 \(x_i\) 是 \(g\) 的根

1.  \(\delta(-x) = \delta(x)\)

DiracDelta的第`k`阶导数具有以下特性：

1.  \(\delta(x, k) = 0\)，对所有的 \(x \neq 0\)

1.  \(\delta(-x, k) = -\delta(x, k)\)，对于奇数 \(k\)

1.  \(\delta(-x, k) = \delta(x, k)\)，对于偶数 \(k\)

示例

```py
>>> from sympy import DiracDelta, diff, pi
>>> from sympy.abc import x, y 
```

```py
>>> DiracDelta(x)
DiracDelta(x)
>>> DiracDelta(1)
0
>>> DiracDelta(-1)
0
>>> DiracDelta(pi)
0
>>> DiracDelta(x - 4).subs(x, 4)
DiracDelta(0)
>>> diff(DiracDelta(x))
DiracDelta(x, 1)
>>> diff(DiracDelta(x - 1), x, 2)
DiracDelta(x - 1, 2)
>>> diff(DiracDelta(x**2 - 1), x, 2)
2*(2*x**2*DiracDelta(x**2 - 1, 2) + DiracDelta(x**2 - 1, 1))
>>> DiracDelta(3*x).is_simple(x)
True
>>> DiracDelta(x**2).is_simple(x)
False
>>> DiracDelta((x**2 - 1)*y).expand(diracdelta=True, wrt=x)
DiracDelta(x - 1)/(2*Abs(y)) + DiracDelta(x + 1)/(2*Abs(y)) 
```

另请参阅

[`Heaviside`](#sympy.functions.special.delta_functions.Heaviside "sympy.functions.special.delta_functions.Heaviside"), [`sympy.simplify.simplify.simplify`](../simplify/simplify.html#sympy.simplify.simplify.simplify "sympy.simplify.simplify.simplify"), [`is_simple`](#sympy.functions.special.delta_functions.DiracDelta.is_simple "sympy.functions.special.delta_functions.DiracDelta.is_simple"), [`sympy.functions.special.tensor_functions.KroneckerDelta`](#sympy.functions.special.tensor_functions.KroneckerDelta "sympy.functions.special.tensor_functions.KroneckerDelta")

参考资料

[[R342](#id1)]

[数学世界](https://mathworld.wolfram.com/DeltaFunction.html)

```py
classmethod eval(arg, k=0)
```

返回DiracDelta对象传递的参数的简化形式或值。

参数：

**k**：整数

> 导数的阶数

**arg**：传递给DiracDelta的参数

解释

当`DiracDelta`类即将实例化时，`eval()`方法会自动调用并返回简化的实例或未评估的实例，具体取决于传递的参数。换句话说，不需要显式调用`eval()`方法，一旦调用对象即会被调用和评估。

示例

```py
>>> from sympy import DiracDelta, S
>>> from sympy.abc import x 
```

```py
>>> DiracDelta(x)
DiracDelta(x) 
```

```py
>>> DiracDelta(-x, 1)
-DiracDelta(x, 1) 
```

```py
>>> DiracDelta(1)
0 
```

```py
>>> DiracDelta(5, 1)
0 
```

```py
>>> DiracDelta(0)
DiracDelta(0) 
```

```py
>>> DiracDelta(-1)
0 
```

```py
>>> DiracDelta(S.NaN)
nan 
```

```py
>>> DiracDelta(x - 100).subs(x, 5)
0 
```

```py
>>> DiracDelta(x - 100).subs(x, 100)
DiracDelta(0) 
```

```py
fdiff(argindex=1)
```

返回DiracDelta函数的第一阶导数。

参数：

**argindex** : 整数

> 导数的程度

解释

`diff()`与`fdiff()`的区别在于：`diff()`是用户级函数，而`fdiff()`是对象方法。`fdiff()`是`Function`类中的便利方法，用于返回不考虑链式法则的函数导数。`diff(function, x)`调用`Function._eval_derivative`，后者在内部调用`fdiff()`来计算函数的导数。

示例

```py
>>> from sympy import DiracDelta, diff
>>> from sympy.abc import x 
```

```py
>>> DiracDelta(x).fdiff()
DiracDelta(x, 1) 
```

```py
>>> DiracDelta(x, 1).fdiff()
DiracDelta(x, 2) 
```

```py
>>> DiracDelta(x**2 - 1).fdiff()
DiracDelta(x**2 - 1, 1) 
```

```py
>>> diff(DiracDelta(x, 1)).fdiff()
DiracDelta(x, 3) 
```

```py
is_simple(x)
```

判断DiracDelta的参数(args[0])是否是*x*的线性表达式。

参数：

**x** : 可以是一个符号

示例

```py
>>> from sympy import DiracDelta, cos
>>> from sympy.abc import x, y 
```

```py
>>> DiracDelta(x*y).is_simple(x)
True
>>> DiracDelta(x*y).is_simple(y)
True 
```

```py
>>> DiracDelta(x**2 + x - 2).is_simple(x)
False 
```

```py
>>> DiracDelta(cos(x)).is_simple(x)
False 
```

另见

[`sympy.simplify.simplify.simplify`](../simplify/simplify.html#sympy.simplify.simplify.simplify "sympy.simplify.simplify.simplify"), [`DiracDelta`](#sympy.functions.special.delta_functions.DiracDelta "sympy.functions.special.delta_functions.DiracDelta")

```py
class sympy.functions.special.delta_functions.Heaviside(arg, H0=1 / 2)
```

Heaviside阶跃函数。

解释

海维赛德阶跃函数具有以下特性：

1.  \(\frac{d}{d x} \theta(x) = \delta(x)\)

1.  \(\theta(x) = \begin{cases} 0 & \text{for}\: x < 0 \\ \frac{1}{2} & \text{for}\: x = 0 \\1 & \text{for}\: x > 0 \end{cases}\)

1.  \(\frac{d}{d x} \max(x, 0) = \theta(x)\)

当SymPy LaTeX打印机将Heaviside(x)打印为\(\theta(x)\)时。

在不同领域中0处的值设置不同。SymPy使用1/2，这是来自电子学和信号处理的约定，并且与通过Fourier变换和卷积求解不适当积分一致。

要在`x=0`处指定不同值的Heaviside，可以提供第二个参数。使用`Heaviside(x, nan)`会给出一个在`x=0`时评估为nan的表达式。

从版本1.9开始更改：`Heaviside(0)`现在返回1/2（之前为未定义）

示例

```py
>>> from sympy import Heaviside, nan
>>> from sympy.abc import x
>>> Heaviside(9)
1
>>> Heaviside(-9)
0
>>> Heaviside(0)
1/2
>>> Heaviside(0, nan)
nan
>>> (Heaviside(x) + 1).replace(Heaviside(x), Heaviside(x, 1))
Heaviside(x, 1) + 1 
```

另见

[`DiracDelta`](#sympy.functions.special.delta_functions.DiracDelta "sympy.functions.special.delta_functions.DiracDelta")

参考文献

[[R343](#id2)]

[https://mathworld.wolfram.com/HeavisideStepFunction.html](https://mathworld.wolfram.com/HeavisideStepFunction.html)

[[R344](#id3)]

[https://dlmf.nist.gov/1.16#iv](https://dlmf.nist.gov/1.16#iv)

```py
classmethod eval(arg, H0=1 / 2)
```

返回由Heaviside对象传递的参数的简化形式或Heaviside的值。

参数：

**arg** : 由Heaviside对象传递的参数

**H0** : Heaviside(0)的值

解释

当 `Heaviside` 类即将实例化时，`eval()` 方法会自动调用，并返回根据传递的参数而确定的某些简化实例或未评估的实例。换句话说，不需要显式调用 `eval()` 方法，它在调用对象时被调用和评估。

示例

```py
>>> from sympy import Heaviside, S
>>> from sympy.abc import x 
```

```py
>>> Heaviside(x)
Heaviside(x) 
```

```py
>>> Heaviside(19)
1 
```

```py
>>> Heaviside(0)
1/2 
```

```py
>>> Heaviside(0, 1)
1 
```

```py
>>> Heaviside(-5)
0 
```

```py
>>> Heaviside(S.NaN)
nan 
```

```py
>>> Heaviside(x - 100).subs(x, 5)
0 
```

```py
>>> Heaviside(x - 100).subs(x, 105)
1 
```

```py
fdiff(argindex=1)
```

返回 Heaviside 函数的第一阶导数。

参数：

**argindex** : 整数

> 导数的顺序

示例

```py
>>> from sympy import Heaviside, diff
>>> from sympy.abc import x 
```

```py
>>> Heaviside(x).fdiff()
DiracDelta(x) 
```

```py
>>> Heaviside(x**2 - 1).fdiff()
DiracDelta(x**2 - 1) 
```

```py
>>> diff(Heaviside(x)).fdiff()
DiracDelta(x, 1) 
```

```py
property pargs
```

Args 没有默认值 S.Half

```py
class sympy.functions.special.singularity_functions.SingularityFunction(variable, offset, exponent)
```

奇异函数是一类不连续函数。

解释

奇异函数以变量、偏移量和指数作为参数。这些函数用 Macaulay 括号表示为：

SingularityFunction(x, a, n) := <x - a>^n

如果 `n < 0`，奇异函数将自动评估为 `Derivative(DiracDelta(x - a), x, -n - 1)`，如果 `n >= 0`，则为 `(x - a)**n*Heaviside(x - a, 1)`。

示例

```py
>>> from sympy import SingularityFunction, diff, Piecewise, DiracDelta, Heaviside, Symbol
>>> from sympy.abc import x, a, n
>>> SingularityFunction(x, a, n)
SingularityFunction(x, a, n)
>>> y = Symbol('y', positive=True)
>>> n = Symbol('n', nonnegative=True)
>>> SingularityFunction(y, -10, n)
(y + 10)**n
>>> y = Symbol('y', negative=True)
>>> SingularityFunction(y, 10, n)
0
>>> SingularityFunction(x, 4, -1).subs(x, 4)
oo
>>> SingularityFunction(x, 10, -2).subs(x, 10)
oo
>>> SingularityFunction(4, 1, 5)
243
>>> diff(SingularityFunction(x, 1, 5) + SingularityFunction(x, 1, 4), x)
4*SingularityFunction(x, 1, 3) + 5*SingularityFunction(x, 1, 4)
>>> diff(SingularityFunction(x, 4, 0), x, 2)
SingularityFunction(x, 4, -2)
>>> SingularityFunction(x, 4, 5).rewrite(Piecewise)
Piecewise(((x - 4)**5, x >= 4), (0, True))
>>> expr = SingularityFunction(x, a, n)
>>> y = Symbol('y', positive=True)
>>> n = Symbol('n', nonnegative=True)
>>> expr.subs({x: y, a: -10, n: n})
(y + 10)**n 
```

方法 `rewrite(DiracDelta)`，`rewrite(Heaviside)` 和 `rewrite('HeavisideDiracDelta')` 返回相同的输出。可以根据需要使用这些方法中的任何一个。

```py
>>> expr = SingularityFunction(x, 4, 5) + SingularityFunction(x, -3, -1) - SingularityFunction(x, 0, -2)
>>> expr.rewrite(Heaviside)
(x - 4)**5*Heaviside(x - 4, 1) + DiracDelta(x + 3) - DiracDelta(x, 1)
>>> expr.rewrite(DiracDelta)
(x - 4)**5*Heaviside(x - 4, 1) + DiracDelta(x + 3) - DiracDelta(x, 1)
>>> expr.rewrite('HeavisideDiracDelta')
(x - 4)**5*Heaviside(x - 4, 1) + DiracDelta(x + 3) - DiracDelta(x, 1) 
```

另见

[`DiracDelta`](#sympy.functions.special.delta_functions.DiracDelta "sympy.functions.special.delta_functions.DiracDelta")，[`Heaviside`](#sympy.functions.special.delta_functions.Heaviside "sympy.functions.special.delta_functions.Heaviside")

参考文献

[[R345](#id4)]

[https://en.wikipedia.org/wiki/Singularity_function](https://en.wikipedia.org/wiki/Singularity_function)

```py
classmethod eval(variable, offset, exponent)
```

根据对象传递的参数，返回奇异函数的简化形式或值。

解释

当 `SingularityFunction` 类即将实例化时，`eval()` 方法会自动调用，并返回根据传递的参数而确定的某些简化实例或未评估的实例。换句话说，不需要显式调用 `eval()` 方法，它在调用对象时被调用和评估。

示例

```py
>>> from sympy import SingularityFunction, Symbol, nan
>>> from sympy.abc import x, a, n
>>> SingularityFunction(x, a, n)
SingularityFunction(x, a, n)
>>> SingularityFunction(5, 3, 2)
4
>>> SingularityFunction(x, a, nan)
nan
>>> SingularityFunction(x, 3, 0).subs(x, 3)
1
>>> SingularityFunction(4, 1, 5)
243
>>> x = Symbol('x', positive = True)
>>> a = Symbol('a', negative = True)
>>> n = Symbol('n', nonnegative = True)
>>> SingularityFunction(x, a, n)
(-a + x)**n
>>> x = Symbol('x', negative = True)
>>> a = Symbol('a', positive = True)
>>> SingularityFunction(x, a, n)
0 
```

```py
fdiff(argindex=1)
```

返回 DiracDelta 函数的第一阶导数。

解释

`diff()` 和 `fdiff()` 的区别是：`diff()` 是用户级函数，`fdiff()` 是对象方法。`fdiff()` 是 `Function` 类中可用的便捷方法。它返回函数的导数，而不考虑链式法则。`diff(function, x)` 调用 `Function._eval_derivative`，后者又在内部调用 `fdiff()` 来计算函数的导数。

## Gamma, Beta and Related Functions

```py
class sympy.functions.special.gamma_functions.gamma(arg)
```

gamma 函数

\[\Gamma(x) := \int^{\infty}_{0} t^{x-1} e^{-t} \mathrm{d}t.\]

解释

`gamma` 函数实现了阶乘函数的值（即，当 n 是整数时，\(\Gamma(n) = (n - 1)!\)）。更一般地，\(\Gamma(z)\) 在整个复平面上定义，除了负整数处有简单极点。

示例

```py
>>> from sympy import S, I, pi, gamma
>>> from sympy.abc import x 
```

已知几个特殊值：

```py
>>> gamma(1)
1
>>> gamma(4)
6
>>> gamma(S(3)/2)
sqrt(pi)/2 
```

`gamma` 函数遵循镜像对称性：

```py
>>> from sympy import conjugate
>>> conjugate(gamma(x))
gamma(conjugate(x)) 
```

支持相对于 \(x\) 的微分：

```py
>>> from sympy import diff
>>> diff(gamma(x), x)
gamma(x)*polygamma(0, x) 
```

还支持级数展开：

```py
>>> from sympy import series
>>> series(gamma(x), x, 0, 3)
1/x - EulerGamma + x*(EulerGamma**2/2 + pi**2/12) + x**2*(-EulerGamma*pi**2/12 - zeta(3)/3 - EulerGamma**3/6) + O(x**3) 
```

我们可以在整个复平面上任意精度地数值计算`gamma`函数：

```py
>>> gamma(pi).evalf(40)
2.288037795340032417959588909060233922890
>>> gamma(1+I).evalf(20)
0.49801566811835604271 - 0.15494982830181068512*I 
```

请参阅

[`lowergamma`](#sympy.functions.special.gamma_functions.lowergamma "sympy.functions.special.gamma_functions.lowergamma")

下不完全伽玛函数。

[`uppergamma`](#sympy.functions.special.gamma_functions.uppergamma "sympy.functions.special.gamma_functions.uppergamma")

上不完全伽玛函数。

[`polygamma`](#sympy.functions.special.gamma_functions.polygamma "sympy.functions.special.gamma_functions.polygamma")

多对数函数。

[`loggamma`](#sympy.functions.special.gamma_functions.loggamma "sympy.functions.special.gamma_functions.loggamma")

对数伽玛函数。

[`digamma`](#sympy.functions.special.gamma_functions.digamma "sympy.functions.special.gamma_functions.digamma")

Digamma函数。

[`trigamma`](#sympy.functions.special.gamma_functions.trigamma "sympy.functions.special.gamma_functions.trigamma")

三对数函数。

[`sympy.functions.special.beta_functions.beta`](#sympy.functions.special.beta_functions.beta "sympy.functions.special.beta_functions.beta")

欧拉贝塔函数。

参考文献

[[R346](#id5)]

[伽玛函数](https://en.wikipedia.org/wiki/Gamma_function)

[[R347](#id6)]

[https://dlmf.nist.gov/5](https://dlmf.nist.gov/5)

[[R348](#id7)]

[https://mathworld.wolfram.com/GammaFunction.html](https://mathworld.wolfram.com/GammaFunction.html)

[[R349](#id8)]

[https://functions.wolfram.com/GammaBetaErf/Gamma/](https://functions.wolfram.com/GammaBetaErf/Gamma/)

```py
class sympy.functions.special.gamma_functions.loggamma(z)
```

`loggamma`函数实现伽玛函数的对数（即，\(\log\Gamma(x)\))。

示例

已知几个特殊值。对于数值积分参数，我们有：

```py
>>> from sympy import loggamma
>>> loggamma(-2)
oo
>>> loggamma(0)
oo
>>> loggamma(1)
0
>>> loggamma(2)
0
>>> loggamma(3)
log(2) 
```

以及符号值：

```py
>>> from sympy import Symbol
>>> n = Symbol("n", integer=True, positive=True)
>>> loggamma(n)
log(gamma(n))
>>> loggamma(-n)
oo 
```

对于半整数值：

```py
>>> from sympy import S
>>> loggamma(S(5)/2)
log(3*sqrt(pi)/4)
>>> loggamma(n/2)
log(2**(1 - n)*sqrt(pi)*gamma(n)/gamma(n/2 + 1/2)) 
```

和一般的有理参数：

```py
>>> from sympy import expand_func
>>> L = loggamma(S(16)/3)
>>> expand_func(L).doit()
-5*log(3) + loggamma(1/3) + log(4) + log(7) + log(10) + log(13)
>>> L = loggamma(S(19)/4)
>>> expand_func(L).doit()
-4*log(4) + loggamma(3/4) + log(3) + log(7) + log(11) + log(15)
>>> L = loggamma(S(23)/7)
>>> expand_func(L).doit()
-3*log(7) + log(2) + loggamma(2/7) + log(9) + log(16) 
```

`loggamma`函数在无穷大时有以下极限：

```py
>>> from sympy import oo
>>> loggamma(oo)
oo
>>> loggamma(-oo)
zoo 
```

如果 \(x \in \mathbb{C} \setminus \{-\infty, 0\}\)，`loggamma`函数遵循镜像对称性：

```py
>>> from sympy.abc import x
>>> from sympy import conjugate
>>> conjugate(loggamma(x))
loggamma(conjugate(x)) 
```

支持对 \(x\) 的微分：

```py
>>> from sympy import diff
>>> diff(loggamma(x), x)
polygamma(0, x) 
```

还支持级数展开：

```py
>>> from sympy import series
>>> series(loggamma(x), x, 0, 4).cancel()
-log(x) - EulerGamma*x + pi**2*x**2/12 - x**3*zeta(3)/3 + O(x**4) 
```

我们可以在整个复平面上任意精度地数值计算`loggamma`函数：

```py
>>> from sympy import I
>>> loggamma(5).evalf(30)
3.17805383034794561964694160130
>>> loggamma(I).evalf(20)
-0.65092319930185633889 - 1.8724366472624298171*I 
```

请参阅

[`gamma`](#sympy.functions.special.gamma_functions.gamma "sympy.functions.special.gamma_functions.gamma")

伽玛函数。

[`lowergamma`](#sympy.functions.special.gamma_functions.lowergamma "sympy.functions.special.gamma_functions.lowergamma")

下不完全伽玛函数。

[`uppergamma`](#sympy.functions.special.gamma_functions.uppergamma "sympy.functions.special.gamma_functions.uppergamma")

上不完全伽玛函数。

[`polygamma`](#sympy.functions.special.gamma_functions.polygamma "sympy.functions.special.gamma_functions.polygamma")

多对数函数。

[`digamma`](#sympy.functions.special.gamma_functions.digamma "sympy.functions.special.gamma_functions.digamma")

Digamma函数。

[`trigamma`](#sympy.functions.special.gamma_functions.trigamma "sympy.functions.special.gamma_functions.trigamma")

Trigamma 函数。

[`sympy.functions.special.beta_functions.beta`](#sympy.functions.special.beta_functions.beta "sympy.functions.special.beta_functions.beta")

欧拉贝塔函数。

参考文献

[[R350](#id9)]

[https://en.wikipedia.org/wiki/Gamma_function](https://en.wikipedia.org/wiki/Gamma_function)

[[R351](#id10)]

[https://dlmf.nist.gov/5](https://dlmf.nist.gov/5)

[[R352](#id11)]

[https://mathworld.wolfram.com/LogGammaFunction.html](https://mathworld.wolfram.com/LogGammaFunction.html)

[[R353](#id12)]

[https://functions.wolfram.com/GammaBetaErf/LogGamma/](https://functions.wolfram.com/GammaBetaErf/LogGamma/)

```py
class sympy.functions.special.gamma_functions.polygamma(n, z)
```

函数 `polygamma(n, z)` 返回 `log(gamma(z)).diff(n + 1)`。

解释

它是 \(\mathbb{C}\) 上的亚黎曼函数，并定义为伽玛函数对数的第 \((n+1)\) 阶导数：

\[\psi^{(n)} (z) := \frac{\mathrm{d}^{n+1}}{\mathrm{d} z^{n+1}} \log\Gamma(z).\]

对于 \(n\) 不是非负整数，使用 Espinosa 和 Moll 的推广[[R358]](#r358)：

\[\psi(s,z) = \frac{\zeta'(s+1, z) + (\gamma + \psi(-s)) \zeta(s+1, z)} {\Gamma(-s)}\]

示例

已知几个特殊值：

```py
>>> from sympy import S, polygamma
>>> polygamma(0, 1)
-EulerGamma
>>> polygamma(0, 1/S(2))
-2*log(2) - EulerGamma
>>> polygamma(0, 1/S(3))
-log(3) - sqrt(3)*pi/6 - EulerGamma - log(sqrt(3))
>>> polygamma(0, 1/S(4))
-pi/2 - log(4) - log(2) - EulerGamma
>>> polygamma(0, 2)
1 - EulerGamma
>>> polygamma(0, 23)
19093197/5173168 - EulerGamma 
```

```py
>>> from sympy import oo, I
>>> polygamma(0, oo)
oo
>>> polygamma(0, -oo)
oo
>>> polygamma(0, I*oo)
oo
>>> polygamma(0, -I*oo)
oo 
```

支持对 \(x\) 的微分：

```py
>>> from sympy import Symbol, diff
>>> x = Symbol("x")
>>> diff(polygamma(0, x), x)
polygamma(1, x)
>>> diff(polygamma(0, x), x, 2)
polygamma(2, x)
>>> diff(polygamma(0, x), x, 3)
polygamma(3, x)
>>> diff(polygamma(1, x), x)
polygamma(2, x)
>>> diff(polygamma(1, x), x, 2)
polygamma(3, x)
>>> diff(polygamma(2, x), x)
polygamma(3, x)
>>> diff(polygamma(2, x), x, 2)
polygamma(4, x) 
```

```py
>>> n = Symbol("n")
>>> diff(polygamma(n, x), x)
polygamma(n + 1, x)
>>> diff(polygamma(n, x), x, 2)
polygamma(n + 2, x) 
```

我们可以用调和数来重写 `polygamma` 函数：

```py
>>> from sympy import harmonic
>>> polygamma(0, x).rewrite(harmonic)
harmonic(x - 1) - EulerGamma
>>> polygamma(2, x).rewrite(harmonic)
2*harmonic(x - 1, 3) - 2*zeta(3)
>>> ni = Symbol("n", integer=True)
>>> polygamma(ni, x).rewrite(harmonic)
(-1)**(n + 1)*(-harmonic(x - 1, n + 1) + zeta(n + 1))*factorial(n) 
```

另见

[`gamma`](#sympy.functions.special.gamma_functions.gamma "sympy.functions.special.gamma_functions.gamma")

Gamma 函数。

[`lowergamma`](#sympy.functions.special.gamma_functions.lowergamma "sympy.functions.special.gamma_functions.lowergamma")

下不完全伽玛函数。

[`uppergamma`](#sympy.functions.special.gamma_functions.uppergamma "sympy.functions.special.gamma_functions.uppergamma")

上不完全伽玛函数。

[`loggamma`](#sympy.functions.special.gamma_functions.loggamma "sympy.functions.special.gamma_functions.loggamma")

对数伽玛函数。

[`digamma`](#sympy.functions.special.gamma_functions.digamma "sympy.functions.special.gamma_functions.digamma")

Digamma 函数。

[`trigamma`](#sympy.functions.special.gamma_functions.trigamma "sympy.functions.special.gamma_functions.trigamma")

Trigamma 函数。

[`sympy.functions.special.beta_functions.beta`](#sympy.functions.special.beta_functions.beta "sympy.functions.special.beta_functions.beta")

欧拉贝塔函数。

参考文献

[[R354](#id14)]

[https://en.wikipedia.org/wiki/Polygamma_function](https://en.wikipedia.org/wiki/Polygamma_function)

[[R355](#id15)]

[https://mathworld.wolfram.com/PolygammaFunction.html](https://mathworld.wolfram.com/PolygammaFunction.html)

[[R356](#id16)]

[https://functions.wolfram.com/GammaBetaErf/PolyGamma/](https://functions.wolfram.com/GammaBetaErf/PolyGamma/)

[[R357](#id17)]

[https://functions.wolfram.com/GammaBetaErf/PolyGamma2/](https://functions.wolfram.com/GammaBetaErf/PolyGamma2/)

[R358] ([1](#id13),[2](#id18))

O. Espinosa 和 V. Moll，“广义多次伽玛函数”，*积分变换与特殊函数*（2004），101-115。

```py
class sympy.functions.special.gamma_functions.digamma(z)
```

`digamma`函数是`loggamma`函数的一阶导数。

\[\psi(x) := \frac{\mathrm{d}}{\mathrm{d} z} \log\Gamma(z) = \frac{\Gamma'(z)}{\Gamma(z) }.\]

在这种情况下，`digamma(z) = polygamma(0, z)`。

示例

```py
>>> from sympy import digamma
>>> digamma(0)
zoo
>>> from sympy import Symbol
>>> z = Symbol('z')
>>> digamma(z)
polygamma(0, z) 
```

保持`digamma`不变：

```py
>>> digamma(0, evaluate=False)
digamma(0)
>>> digamma(z, evaluate=False)
digamma(z) 
```

另见

[`gamma`](#sympy.functions.special.gamma_functions.gamma "sympy.functions.special.gamma_functions.gamma")

Gamma函数。

[`lowergamma`](#sympy.functions.special.gamma_functions.lowergamma "sympy.functions.special.gamma_functions.lowergamma")

下不完全伽玛函数。

[`uppergamma`](#sympy.functions.special.gamma_functions.uppergamma "sympy.functions.special.gamma_functions.uppergamma")

上不完全伽玛函数。

[`polygamma`](#sympy.functions.special.gamma_functions.polygamma "sympy.functions.special.gamma_functions.polygamma")

多次伽玛函数。

[`loggamma`](#sympy.functions.special.gamma_functions.loggamma "sympy.functions.special.gamma_functions.loggamma")

对数Gamma函数。

[`trigamma`](#sympy.functions.special.gamma_functions.trigamma "sympy.functions.special.gamma_functions.trigamma")

三次伽玛函数。

[`sympy.functions.special.beta_functions.beta`](#sympy.functions.special.beta_functions.beta "sympy.functions.special.beta_functions.beta")

欧拉贝塔函数。

参考文献

[[R359](#id19)]

[https://en.wikipedia.org/wiki/Digamma_function](https://en.wikipedia.org/wiki/Digamma_function)

[[R360](#id20)]

[https://mathworld.wolfram.com/DigammaFunction.html](https://mathworld.wolfram.com/DigammaFunction.html)

[[R361](#id21)]

[https://functions.wolfram.com/GammaBetaErf/PolyGamma2/](https://functions.wolfram.com/GammaBetaErf/PolyGamma2/)

```py
class sympy.functions.special.gamma_functions.trigamma(z)
```

`trigamma`函数是`loggamma`函数的二阶导数。

\[\psi^{(1)}(z) := \frac{\mathrm{d}^{2}}{\mathrm{d} z^{2}} \log\Gamma(z).\]

在这种情况下，`trigamma(z) = polygamma(1, z)`。

示例

```py
>>> from sympy import trigamma
>>> trigamma(0)
zoo
>>> from sympy import Symbol
>>> z = Symbol('z')
>>> trigamma(z)
polygamma(1, z) 
```

保持`trigamma`不变：

```py
>>> trigamma(0, evaluate=False)
trigamma(0)
>>> trigamma(z, evaluate=False)
trigamma(z) 
```

另见

[`gamma`](#sympy.functions.special.gamma_functions.gamma "sympy.functions.special.gamma_functions.gamma")

Gamma函数。

[`lowergamma`](#sympy.functions.special.gamma_functions.lowergamma "sympy.functions.special.gamma_functions.lowergamma")

下不完全伽玛函数。

[`uppergamma`](#sympy.functions.special.gamma_functions.uppergamma "sympy.functions.special.gamma_functions.uppergamma")

上不完全伽玛函数。

[`polygamma`](#sympy.functions.special.gamma_functions.polygamma "sympy.functions.special.gamma_functions.polygamma")

多次伽玛函数。

[`loggamma`](#sympy.functions.special.gamma_functions.loggamma "sympy.functions.special.gamma_functions.loggamma")

对数Gamma函数。

[`digamma`](#sympy.functions.special.gamma_functions.digamma "sympy.functions.special.gamma_functions.digamma")

Digamma函数。

[`sympy.functions.special.beta_functions.beta`](#sympy.functions.special.beta_functions.beta "sympy.functions.special.beta_functions.beta")

欧拉贝塔函数。

参考

[[R362](#id22)]

[https://en.wikipedia.org/wiki/Trigamma_function](https://en.wikipedia.org/wiki/Trigamma_function)

[[R363](#id23)]

[https://mathworld.wolfram.com/TrigammaFunction.html](https://mathworld.wolfram.com/TrigammaFunction.html)

[[R364](#id24)]

[https://functions.wolfram.com/GammaBetaErf/PolyGamma2/](https://functions.wolfram.com/GammaBetaErf/PolyGamma2/)

```py
class sympy.functions.special.gamma_functions.uppergamma(a, z)
```

上不完全伽玛函数。

解释

它可以定义为

\[\Gamma(s, x) := \int_x^\infty t^{s-1} e^{-t} \mathrm{d}t = \Gamma(s) - \gamma(s, x).\]

其中 \(\gamma(s, x)\) 是下不完全伽玛函数，[`lowergamma`](#sympy.functions.special.gamma_functions.lowergamma "sympy.functions.special.gamma_functions.lowergamma")。这可以证明与

\[\Gamma(s, x) = \Gamma(s) - \frac{x^s}{s} {}_1F_1\left({s \atop s+1} \middle| -x\right),\]

其中 \({}_1F_1\) 是超几何函数。

上不完全伽玛函数也基本等同于广义指数积分：

\[\operatorname{E}_{n}(x) = \int_{1}^{\infty}{\frac{e^{-xt}}{t^n} \, dt} = x^{n-1}\Gamma(1-n,x).\]

示例

```py
>>> from sympy import uppergamma, S
>>> from sympy.abc import s, x
>>> uppergamma(s, x)
uppergamma(s, x)
>>> uppergamma(3, x)
2*(x**2/2 + x + 1)*exp(-x)
>>> uppergamma(-S(1)/2, x)
-2*sqrt(pi)*erfc(sqrt(x)) + 2*exp(-x)/sqrt(x)
>>> uppergamma(-2, x)
expint(3, x)/x**2 
```

参见

[`gamma`](#sympy.functions.special.gamma_functions.gamma "sympy.functions.special.gamma_functions.gamma")

伽玛函数。

[`lowergamma`](#sympy.functions.special.gamma_functions.lowergamma "sympy.functions.special.gamma_functions.lowergamma")

下不完全伽玛函数。

[`polygamma`](#sympy.functions.special.gamma_functions.polygamma "sympy.functions.special.gamma_functions.polygamma")

Polygamma函数。

[`loggamma`](#sympy.functions.special.gamma_functions.loggamma "sympy.functions.special.gamma_functions.loggamma")

对数伽玛函数。

[`digamma`](#sympy.functions.special.gamma_functions.digamma "sympy.functions.special.gamma_functions.digamma")

Digamma函数。

[`trigamma`](#sympy.functions.special.gamma_functions.trigamma "sympy.functions.special.gamma_functions.trigamma")

Trigamma函数。

[`sympy.functions.special.beta_functions.beta`](#sympy.functions.special.beta_functions.beta "sympy.functions.special.beta_functions.beta")

欧拉贝塔函数。

参考

[[R365](#id25)]

[https://en.wikipedia.org/wiki/Incomplete_gamma_function#Upper_incomplete_gamma_function](https://en.wikipedia.org/wiki/Incomplete_gamma_function#Upper_incomplete_gamma_function)

[[R366](#id26)]

Abramowitz, Milton; Stegun, Irene A., eds. (1965), Chapter 6, Section 5, Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables

[[R367](#id27)]

[https://dlmf.nist.gov/8](https://dlmf.nist.gov/8)

[[R368](#id28)]

[https://functions.wolfram.com/GammaBetaErf/Gamma2/](https://functions.wolfram.com/GammaBetaErf/Gamma2/)

[[R369](#id29)]

[https://functions.wolfram.com/GammaBetaErf/Gamma3/](https://functions.wolfram.com/GammaBetaErf/Gamma3/)

[[R370](#id30)]

[https://en.wikipedia.org/wiki/Exponential_integral#Relation_with_other_functions](https://en.wikipedia.org/wiki/Exponential_integral#Relation_with_other_functions)

```py
class sympy.functions.special.gamma_functions.lowergamma(a, x)
```

下不完全伽玛函数.

说明

它可以定义为

\[\gamma(s, x) := \int_0^x t^{s-1} e^{-t} \mathrm{d}t = \Gamma(s) - \Gamma(s, x).\]

这可以表明是相同的

\[\gamma(s, x) = \frac{x^s}{s} {}_1F_1\left({s \atop s+1} \middle| -x\right),\]

其中 \({}_1F_1\) 是（合流）超几何函数.

例子

```py
>>> from sympy import lowergamma, S
>>> from sympy.abc import s, x
>>> lowergamma(s, x)
lowergamma(s, x)
>>> lowergamma(3, x)
-2*(x**2/2 + x + 1)*exp(-x) + 2
>>> lowergamma(-S(1)/2, x)
-2*sqrt(pi)*erf(sqrt(x)) - 2*exp(-x)/sqrt(x) 
```

参见

[`gamma`](#sympy.functions.special.gamma_functions.gamma "sympy.functions.special.gamma_functions.gamma")

伽玛函数.

[`uppergamma`](#sympy.functions.special.gamma_functions.uppergamma "sympy.functions.special.gamma_functions.uppergamma")

上不完全伽玛函数.

[`polygamma`](#sympy.functions.special.gamma_functions.polygamma "sympy.functions.special.gamma_functions.polygamma")

多次伽玛函数.

[`loggamma`](#sympy.functions.special.gamma_functions.loggamma "sympy.functions.special.gamma_functions.loggamma")

对数伽玛函数.

[`digamma`](#sympy.functions.special.gamma_functions.digamma "sympy.functions.special.gamma_functions.digamma")

二阶Ψ函数.

[`trigamma`](#sympy.functions.special.gamma_functions.trigamma "sympy.functions.special.gamma_functions.trigamma")

三角函数.

[`sympy.functions.special.beta_functions.beta`](#sympy.functions.special.beta_functions.beta "sympy.functions.special.beta_functions.beta")

欧拉贝塔函数.

参考

[[R371](#id31)]

[https://en.wikipedia.org/wiki/Incomplete_gamma_function#Lower_incomplete_gamma_function](https://en.wikipedia.org/wiki/Incomplete_gamma_function#Lower_incomplete_gamma_function)

[[R372](#id32)]

Abramowitz, Milton; Stegun, Irene A., eds. (1965), Chapter 6, Section 5, Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables

[[R373](#id33)]

[https://dlmf.nist.gov/8](https://dlmf.nist.gov/8)

[[R374](#id34)]

[https://functions.wolfram.com/GammaBetaErf/Gamma2/](https://functions.wolfram.com/GammaBetaErf/Gamma2/)

[[R375](#id35)]

[https://functions.wolfram.com/GammaBetaErf/Gamma3/](https://functions.wolfram.com/GammaBetaErf/Gamma3/)

```py
class sympy.functions.special.gamma_functions.multigamma(x, p)
```

多元伽玛函数是伽玛函数的一般化

\[\Gamma_p(z) = \pi^{p(p-1)/4}\prod_{k=1}^p \Gamma[z + (1 - k)/2].\]

在一个特殊情况下，`multigamma(x, 1) = gamma(x)`。

参数：

**p**：多元伽玛函数的阶数或维度

例子

```py
>>> from sympy import S, multigamma
>>> from sympy import Symbol
>>> x = Symbol('x')
>>> p = Symbol('p', positive=True, integer=True) 
```

```py
>>> multigamma(x, p)
pi**(p*(p - 1)/4)*Product(gamma(-_k/2 + x + 1/2), (_k, 1, p)) 
```

已知几个特殊值：

```py
>>> multigamma(1, 1)
1
>>> multigamma(4, 1)
6
>>> multigamma(S(3)/2, 1)
sqrt(pi)/2 
```

将 `multigamma` 表示为 `gamma` 函数：

```py
>>> multigamma(x, 1)
gamma(x) 
```

```py
>>> multigamma(x, 2)
sqrt(pi)*gamma(x)*gamma(x - 1/2) 
```

```py
>>> multigamma(x, 3)
pi**(3/2)*gamma(x)*gamma(x - 1)*gamma(x - 1/2) 
```

参见

[`gamma`](#sympy.functions.special.gamma_functions.gamma "sympy.functions.special.gamma_functions.gamma"), [`lowergamma`](#sympy.functions.special.gamma_functions.lowergamma "sympy.functions.special.gamma_functions.lowergamma"), [`uppergamma`](#sympy.functions.special.gamma_functions.uppergamma "sympy.functions.special.gamma_functions.uppergamma"), [`polygamma`](#sympy.functions.special.gamma_functions.polygamma "sympy.functions.special.gamma_functions.polygamma"), [`loggamma`](#sympy.functions.special.gamma_functions.loggamma "sympy.functions.special.gamma_functions.loggamma"), [`digamma`](#sympy.functions.special.gamma_functions.digamma "sympy.functions.special.gamma_functions.digamma"), [`trigamma`](#sympy.functions.special.gamma_functions.trigamma "sympy.functions.special.gamma_functions.trigamma"), [`sympy.functions.special.beta_functions.beta`](#sympy.functions.special.beta_functions.beta "sympy.functions.special.beta_functions.beta")

参考文献

[[R376](#id36)]

[https://en.wikipedia.org/wiki/Multivariate_gamma_function](https://en.wikipedia.org/wiki/Multivariate_gamma_function)

```py
class sympy.functions.special.beta_functions.beta(x, y=None)
```

贝塔积分被Legendre称为第一类欧拉积分：

\[\mathrm{B}(x,y) \int^{1}_{0} t^{x-1} (1-t)^{y-1} \mathrm{d}t.\]

说明

贝塔函数或欧拉第一积分与伽玛函数密切相关。贝塔函数通常用于概率论和数理统计。它满足如下特性：

\[\begin{split}\mathrm{B}(a,1) = \frac{1}{a} \\ \mathrm{B}(a,b) = \mathrm{B}(b,a) \\ \mathrm{B}(a,b) = \frac{\Gamma(a) \Gamma(b)}{\Gamma(a+b)}\end{split}\]

因此对于\(a\)和\(b\)的整数值：

\[\mathrm{B} = \frac{(a-1)! (b-1)!}{(a+b-1)!}\]

当\(x = y\)时贝塔函数的特殊情况是中心贝塔函数。它具有如下特性：

\[\mathrm{B}(x) = 2^{1 - 2x}\mathrm{B}(x, \frac{1}{2}) \mathrm{B}(x) = 2^{1 - 2x} cos(\pi x) \mathrm{B}(\frac{1}{2} - x, x) \mathrm{B}(x) = \int_{0}^{1} \frac{t^x}{(1 + t)^{2x}} dt \mathrm{B}(x) = \frac{2}{x} \prod_{n = 1}^{\infty} \frac{n(n + 2x)}{(n + x)^2}\]

例子

```py
>>> from sympy import I, pi
>>> from sympy.abc import x, y 
```

贝塔函数遵循镜像对称性：

```py
>>> from sympy import beta, conjugate
>>> conjugate(beta(x, y))
beta(conjugate(x), conjugate(y)) 
```

支持对\(x\)和\(y\)的微分：

```py
>>> from sympy import beta, diff
>>> diff(beta(x, y), x)
(polygamma(0, x) - polygamma(0, x + y))*beta(x, y) 
```

```py
>>> diff(beta(x, y), y)
(polygamma(0, y) - polygamma(0, x + y))*beta(x, y) 
```

```py
>>> diff(beta(x), x)
2*(polygamma(0, x) - polygamma(0, 2*x))*beta(x, x) 
```

我们可以对复数\(x\)和\(y\)任意精确评估贝塔函数：

```py
>>> from sympy import beta
>>> beta(pi).evalf(40)
0.02671848900111377452242355235388489324562 
```

```py
>>> beta(1 + I).evalf(20)
-0.2112723729365330143 - 0.7655283165378005676*I 
```

另请参阅

[`gamma`](#sympy.functions.special.gamma_functions.gamma "sympy.functions.special.gamma_functions.gamma")

伽玛函数。

[`uppergamma`](#sympy.functions.special.gamma_functions.uppergamma "sympy.functions.special.gamma_functions.uppergamma")

上不完全伽玛函数。

[`lowergamma`](#sympy.functions.special.gamma_functions.lowergamma "sympy.functions.special.gamma_functions.lowergamma")

下不完全伽玛函数。

[`polygamma`](#sympy.functions.special.gamma_functions.polygamma "sympy.functions.special.gamma_functions.polygamma")

多元伽玛函数。

[`loggamma`](#sympy.functions.special.gamma_functions.loggamma "sympy.functions.special.gamma_functions.loggamma")

对数伽马函数。

[`digamma`](#sympy.functions.special.gamma_functions.digamma "sympy.functions.special.gamma_functions.digamma")

三角斐函数。

[`trigamma`](#sympy.functions.special.gamma_functions.trigamma "sympy.functions.special.gamma_functions.trigamma")

三角伽马函数。

参考文献

[[R377](#id37)]

[https://en.wikipedia.org/wiki/Beta_function](https://en.wikipedia.org/wiki/Beta_function)

[[R378](#id38)]

[https://mathworld.wolfram.com/BetaFunction.html](https://mathworld.wolfram.com/BetaFunction.html)

[[R379](#id39)]

[https://dlmf.nist.gov/5.12](https://dlmf.nist.gov/5.12)  ## 误差函数与菲涅尔积分

```py
class sympy.functions.special.error_functions.erf(arg)
```

高斯误差函数。

解释

此函数定义为：

\[\mathrm{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-t^2} \mathrm{d}t.\]

例子

```py
>>> from sympy import I, oo, erf
>>> from sympy.abc import z 
```

已知几个特殊值：

```py
>>> erf(0)
0
>>> erf(oo)
1
>>> erf(-oo)
-1
>>> erf(I*oo)
oo*I
>>> erf(-I*oo)
-oo*I 
```

一般来说，可以从参数中提取因子-1和\(I\)：

```py
>>> erf(-z)
-erf(z) 
```

误差函数遵循镜像对称性：

```py
>>> from sympy import conjugate
>>> conjugate(erf(z))
erf(conjugate(z)) 
```

支持对\(z\)的微分：

```py
>>> from sympy import diff
>>> diff(erf(z), z)
2*exp(-z**2)/sqrt(pi) 
```

我们可以在整个复平面上对误差函数进行任意精度的数值评估：

```py
>>> erf(4).evalf(30)
0.999999984582742099719981147840 
```

```py
>>> erf(-4*I).evalf(30)
-1296959.73071763923152794095062*I 
```

另请参阅

[`erfc`](#sympy.functions.special.error_functions.erfc "sympy.functions.special.error_functions.erfc")

补充误差函数。

[`erfi`](#sympy.functions.special.error_functions.erfi "sympy.functions.special.error_functions.erfi")

虚数误差函数。

[`erf2`](#sympy.functions.special.error_functions.erf2 "sympy.functions.special.error_functions.erf2")

二参数误差函数。

[`erfinv`](#sympy.functions.special.error_functions.erfinv "sympy.functions.special.error_functions.erfinv")

误差函数的反函数。

[`erfcinv`](#sympy.functions.special.error_functions.erfcinv "sympy.functions.special.error_functions.erfcinv")

补充误差函数的反函数。

[`erf2inv`](#sympy.functions.special.error_functions.erf2inv "sympy.functions.special.error_functions.erf2inv")

二参数误差函数的反函数。

参考文献

[[R380](#id40)]

[https://en.wikipedia.org/wiki/Error_function](https://en.wikipedia.org/wiki/Error_function)

[[R381](#id41)]

[https://dlmf.nist.gov/7](https://dlmf.nist.gov/7)

[[R382](#id42)]

[https://mathworld.wolfram.com/Erf.html](https://mathworld.wolfram.com/Erf.html)

[[R383](#id43)]

[https://functions.wolfram.com/GammaBetaErf/Erf](https://functions.wolfram.com/GammaBetaErf/Erf)

```py
inverse(argindex=1)
```

返回该函数的反函数。

```py
class sympy.functions.special.error_functions.erfc(arg)
```

补充误差函数。

解释

此函数定义为：

\[\mathrm{erfc}(x) = \frac{2}{\sqrt{\pi}} \int_x^\infty e^{-t^2} \mathrm{d}t\]

例子

```py
>>> from sympy import I, oo, erfc
>>> from sympy.abc import z 
```

已知几个特殊值：

```py
>>> erfc(0)
1
>>> erfc(oo)
0
>>> erfc(-oo)
2
>>> erfc(I*oo)
-oo*I
>>> erfc(-I*oo)
oo*I 
```

误差函数遵循镜像对称性：

```py
>>> from sympy import conjugate
>>> conjugate(erfc(z))
erfc(conjugate(z)) 
```

支持对\(z\)的微分：

```py
>>> from sympy import diff
>>> diff(erfc(z), z)
-2*exp(-z**2)/sqrt(pi) 
```

也遵循

```py
>>> erfc(-z)
2 - erfc(z) 
```

我们可以在整个复平面上对补充误差函数进行任意精度的数值评估：

```py
>>> erfc(4).evalf(30)
0.0000000154172579002800188521596734869 
```

```py
>>> erfc(4*I).evalf(30)
1.0 - 1296959.73071763923152794095062*I 
```

另请参阅

[`erf`](#sympy.functions.special.error_functions.erf "sympy.functions.special.error_functions.erf")

高斯误差函数。

[`erfi`](#sympy.functions.special.error_functions.erfi "sympy.functions.special.error_functions.erfi")

虚误差函数。

[`erf2`](#sympy.functions.special.error_functions.erf2 "sympy.functions.special.error_functions.erf2")

二参数误差函数。

[`erfinv`](#sympy.functions.special.error_functions.erfinv "sympy.functions.special.error_functions.erfinv")

逆误差函数。

[`erfcinv`](#sympy.functions.special.error_functions.erfcinv "sympy.functions.special.error_functions.erfcinv")

逆补充误差函数。

[`erf2inv`](#sympy.functions.special.error_functions.erf2inv "sympy.functions.special.error_functions.erf2inv")

逆二参数误差函数。

参考文献

[[R384](#id44)]

[https://en.wikipedia.org/wiki/Error_function](https://en.wikipedia.org/wiki/Error_function)

[[R385](#id45)]

[https://dlmf.nist.gov/7](https://dlmf.nist.gov/7)

[[R386](#id46)]

[https://mathworld.wolfram.com/Erfc.html](https://mathworld.wolfram.com/Erfc.html)

[[R387](#id47)]

[https://functions.wolfram.com/GammaBetaErf/Erfc](https://functions.wolfram.com/GammaBetaErf/Erfc)

```py
inverse(argindex=1)
```

返回此函数的逆。

```py
class sympy.functions.special.error_functions.erfi(z)
```

虚误差函数。

解释

函数 erfi 定义为：

\[\mathrm{erfi}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{t^2} \mathrm{d}t\]

示例

```py
>>> from sympy import I, oo, erfi
>>> from sympy.abc import z 
```

已知几个特殊值：

```py
>>> erfi(0)
0
>>> erfi(oo)
oo
>>> erfi(-oo)
-oo
>>> erfi(I*oo)
I
>>> erfi(-I*oo)
-I 
```

通常可以从参数中提取出因子 -1 和 \(I\) ：

```py
>>> erfi(-z)
-erfi(z) 
```

```py
>>> from sympy import conjugate
>>> conjugate(erfi(z))
erfi(conjugate(z)) 
```

对 \(z\) 的微分受支持：

```py
>>> from sympy import diff
>>> diff(erfi(z), z)
2*exp(z**2)/sqrt(pi) 
```

我们可以在整个复平面上对虚误差函数进行任意精度的数值评估：

```py
>>> erfi(2).evalf(30)
18.5648024145755525987042919132 
```

```py
>>> erfi(-2*I).evalf(30)
-0.995322265018952734162069256367*I 
```

另见

[`erf`](#sympy.functions.special.error_functions.erf "sympy.functions.special.error_functions.erf")

高斯误差函数。

[`erfc`](#sympy.functions.special.error_functions.erfc "sympy.functions.special.error_functions.erfc")

补充误差函数。

[`erf2`](#sympy.functions.special.error_functions.erf2 "sympy.functions.special.error_functions.erf2")

二参数误差函数。

[`erfinv`](#sympy.functions.special.error_functions.erfinv "sympy.functions.special.error_functions.erfinv")

逆误差函数。

[`erfcinv`](#sympy.functions.special.error_functions.erfcinv "sympy.functions.special.error_functions.erfcinv")

逆补充误差函数。

[`erf2inv`](#sympy.functions.special.error_functions.erf2inv "sympy.functions.special.error_functions.erf2inv")

逆二参数误差函数。

参考文献

[[R388](#id48)]

[https://en.wikipedia.org/wiki/Error_function](https://en.wikipedia.org/wiki/Error_function)

[[R389](#id49)]

[https://mathworld.wolfram.com/Erfi.html](https://mathworld.wolfram.com/Erfi.html)

[[R390](#id50)]

[https://functions.wolfram.com/GammaBetaErf/Erfi](https://functions.wolfram.com/GammaBetaErf/Erfi)

```py
class sympy.functions.special.error_functions.erf2(x, y)
```

二参数误差函数。

解释

此函数定义为：

\[\mathrm{erf2}(x, y) = \frac{2}{\sqrt{\pi}} \int_x^y e^{-t^2} \mathrm{d}t\]

示例

```py
>>> from sympy import oo, erf2
>>> from sympy.abc import x, y 
```

已知几个特殊值：

```py
>>> erf2(0, 0)
0
>>> erf2(x, x)
0
>>> erf2(x, oo)
1 - erf(x)
>>> erf2(x, -oo)
-erf(x) - 1
>>> erf2(oo, y)
erf(y) - 1
>>> erf2(-oo, y)
erf(y) + 1 
```

通常可以从参数中提取出因子 -1：

```py
>>> erf2(-x, -y)
-erf2(x, y) 
```

误差函数服从镜像对称性：

```py
>>> from sympy import conjugate
>>> conjugate(erf2(x, y))
erf2(conjugate(x), conjugate(y)) 
```

支持关于\(x\)、\(y\)的微分：

```py
>>> from sympy import diff
>>> diff(erf2(x, y), x)
-2*exp(-x**2)/sqrt(pi)
>>> diff(erf2(x, y), y)
2*exp(-y**2)/sqrt(pi) 
```

另请参阅

[`erf`](#sympy.functions.special.error_functions.erf "sympy.functions.special.error_functions.erf")

高斯误差函数。

[`erfc`](#sympy.functions.special.error_functions.erfc "sympy.functions.special.error_functions.erfc")

互补误差函数。

[`erfi`](#sympy.functions.special.error_functions.erfi "sympy.functions.special.error_functions.erfi")

虚误差函数。

[`erfinv`](#sympy.functions.special.error_functions.erfinv "sympy.functions.special.error_functions.erfinv")

逆误差函数。

[`erfcinv`](#sympy.functions.special.error_functions.erfcinv "sympy.functions.special.error_functions.erfcinv")

逆互补误差函数。

[`erf2inv`](#sympy.functions.special.error_functions.erf2inv "sympy.functions.special.error_functions.erf2inv")

逆二参数误差函数。

参考

[[R391](#id51)]

[https://functions.wolfram.com/GammaBetaErf/Erf2/](https://functions.wolfram.com/GammaBetaErf/Erf2/)

```py
class sympy.functions.special.error_functions.erfinv(z)
```

逆误差函数。erfinv函数定义为:

\[\mathrm{erf}(x) = y \quad \Rightarrow \quad \mathrm{erfinv}(y) = x\]

示例

```py
>>> from sympy import erfinv
>>> from sympy.abc import x 
```

已知几个特殊值：

```py
>>> erfinv(0)
0
>>> erfinv(1)
oo 
```

支持关于\(x\)的微分：

```py
>>> from sympy import diff
>>> diff(erfinv(x), x)
sqrt(pi)*exp(erfinv(x)**2)/2 
```

我们可以在[-1, 1]上数值评估逆误差函数到任意精度：

```py
>>> erfinv(0.2).evalf(30)
0.179143454621291692285822705344 
```

另请参阅

[`erf`](#sympy.functions.special.error_functions.erf "sympy.functions.special.error_functions.erf")

高斯误差函数。

[`erfc`](#sympy.functions.special.error_functions.erfc "sympy.functions.special.error_functions.erfc")

互补误差函数。

[`erfi`](#sympy.functions.special.error_functions.erfi "sympy.functions.special.error_functions.erfi")

虚误差函数。

[`erf2`](#sympy.functions.special.error_functions.erf2 "sympy.functions.special.error_functions.erf2")

二参数误差函数。

[`erfcinv`](#sympy.functions.special.error_functions.erfcinv "sympy.functions.special.error_functions.erfcinv")

逆互补误差函数。

[`erf2inv`](#sympy.functions.special.error_functions.erf2inv "sympy.functions.special.error_functions.erf2inv")

逆二参数误差函数。

参考

[[R392](#id52)]

[https://en.wikipedia.org/wiki/Error_function#Inverse_functions](https://en.wikipedia.org/wiki/Error_function#Inverse_functions)

[[R393](#id53)]

[https://functions.wolfram.com/GammaBetaErf/InverseErf/](https://functions.wolfram.com/GammaBetaErf/InverseErf/)

```py
inverse(argindex=1)
```

返回该函数的逆。

```py
class sympy.functions.special.error_functions.erfcinv(z)
```

逆互补误差函数。erfcinv函数定义为：

\[\mathrm{erfc}(x) = y \quad \Rightarrow \quad \mathrm{erfcinv}(y) = x\]

示例

```py
>>> from sympy import erfcinv
>>> from sympy.abc import x 
```

已知几个特殊值：

```py
>>> erfcinv(1)
0
>>> erfcinv(0)
oo 
```

支持关于\(x\)的微分：

```py
>>> from sympy import diff
>>> diff(erfcinv(x), x)
-sqrt(pi)*exp(erfcinv(x)**2)/2 
```

另请参阅

[`erf`](#sympy.functions.special.error_functions.erf "sympy.functions.special.error_functions.erf")

高斯误差函数。

[`erfc`](#sympy.functions.special.error_functions.erfc "sympy.functions.special.error_functions.erfc")

互补误差函数。

[`erfi`](#sympy.functions.special.error_functions.erfi "sympy.functions.special.error_functions.erfi")

虚误差函数。

[`erf2`](#sympy.functions.special.error_functions.erf2 "sympy.functions.special.error_functions.erf2")

双参数误差函数。

[`erfinv`](#sympy.functions.special.error_functions.erfinv "sympy.functions.special.error_functions.erfinv")

逆误差函数。

[`erf2inv`](#sympy.functions.special.error_functions.erf2inv "sympy.functions.special.error_functions.erf2inv")

双参数逆误差函数。

参考文献

[[R394](#id54)]

[https://en.wikipedia.org/wiki/Error_function#Inverse_functions](https://en.wikipedia.org/wiki/Error_function#Inverse_functions)

[[R395](#id55)]

[https://functions.wolfram.com/GammaBetaErf/InverseErfc/](https://functions.wolfram.com/GammaBetaErf/InverseErfc/)

```py
inverse(argindex=1)
```

返回此函数的逆。

```py
class sympy.functions.special.error_functions.erf2inv(x, y)
```

双参数逆误差函数。erf2inv 函数定义如下：

\[\mathrm{erf2}(x, w) = y \quad \Rightarrow \quad \mathrm{erf2inv}(x, y) = w\]

示例

```py
>>> from sympy import erf2inv, oo
>>> from sympy.abc import x, y 
```

已知几个特殊值：

```py
>>> erf2inv(0, 0)
0
>>> erf2inv(1, 0)
1
>>> erf2inv(0, 1)
oo
>>> erf2inv(0, y)
erfinv(y)
>>> erf2inv(oo, y)
erfcinv(-y) 
```

支持对 \(x\) 和 \(y\) 的微分：

```py
>>> from sympy import diff
>>> diff(erf2inv(x, y), x)
exp(-x**2 + erf2inv(x, y)**2)
>>> diff(erf2inv(x, y), y)
sqrt(pi)*exp(erf2inv(x, y)**2)/2 
```

参见

[`erf`](#sympy.functions.special.error_functions.erf "sympy.functions.special.error_functions.erf")

高斯误差函数。

[`erfc`](#sympy.functions.special.error_functions.erfc "sympy.functions.special.error_functions.erfc")

互补误差函数。

[`erfi`](#sympy.functions.special.error_functions.erfi "sympy.functions.special.error_functions.erfi")

虚误差函数。

[`erf2`](#sympy.functions.special.error_functions.erf2 "sympy.functions.special.error_functions.erf2")

双参数误差函数。

[`erfinv`](#sympy.functions.special.error_functions.erfinv "sympy.functions.special.error_functions.erfinv")

逆误差函数。

[`erfcinv`](#sympy.functions.special.error_functions.erfcinv "sympy.functions.special.error_functions.erfcinv")

逆互补误差函数。

参考文献

[[R396](#id56)]

[https://functions.wolfram.com/GammaBetaErf/InverseErf2/](https://functions.wolfram.com/GammaBetaErf/InverseErf2/)

```py
class sympy.functions.special.error_functions.FresnelIntegral(z)
```

Fresnel 积分的基类。

```py
class sympy.functions.special.error_functions.fresnels(z)
```

Fresnel 积分 S。

解释

此函数由以下定义

\[\operatorname{S}(z) = \int_0^z \sin{\frac{\pi}{2} t^2} \mathrm{d}t.\]

它是一个整函数。

示例

```py
>>> from sympy import I, oo, fresnels
>>> from sympy.abc import z 
```

已知几个特殊值：

```py
>>> fresnels(0)
0
>>> fresnels(oo)
1/2
>>> fresnels(-oo)
-1/2
>>> fresnels(I*oo)
-I/2
>>> fresnels(-I*oo)
I/2 
```

一般来说，可以从参数中提取因子 -1 和 \(i\)：

```py
>>> fresnels(-z)
-fresnels(z)
>>> fresnels(I*z)
-I*fresnels(z) 
```

Fresnel S 积分遵循镜像对称性 \(\overline{S(z)} = S(\bar{z})\):

```py
>>> from sympy import conjugate
>>> conjugate(fresnels(z))
fresnels(conjugate(z)) 
```

支持对 \(z\) 的微分：

```py
>>> from sympy import diff
>>> diff(fresnels(z), z)
sin(pi*z**2/2) 
```

通过积分定义 Fresnel 函数：

```py
>>> from sympy import integrate, pi, sin, expand_func
>>> integrate(sin(pi*z**2/2), z)
3*fresnels(z)*gamma(3/4)/(4*gamma(7/4))
>>> expand_func(integrate(sin(pi*z**2/2), z))
fresnels(z) 
```

我们可以在整个复平面上对 Fresnel 积分进行任意精度的数值评估：

```py
>>> fresnels(2).evalf(30)
0.343415678363698242195300815958 
```

```py
>>> fresnels(-2*I).evalf(30)
0.343415678363698242195300815958*I 
```

参见

[`fresnelc`](#sympy.functions.special.error_functions.fresnelc "sympy.functions.special.error_functions.fresnelc")

Fresnel 余弦积分。

参考文献

[[R397](#id57)]

[https://en.wikipedia.org/wiki/Fresnel_integral](https://en.wikipedia.org/wiki/Fresnel_integral)

[[R398](#id58)]

[https://dlmf.nist.gov/7](https://dlmf.nist.gov/7)

[[R399](#id59)]

[https://mathworld.wolfram.com/FresnelIntegrals.html](https://mathworld.wolfram.com/FresnelIntegrals.html)

[[R400](#id60)]

[https://functions.wolfram.com/GammaBetaErf/FresnelS](https://functions.wolfram.com/GammaBetaErf/FresnelS)

[[R401](#id61)]

由John W. Wrench Jr.和Vicki Alley推导的Fresnel积分的收敛因子

```py
class sympy.functions.special.error_functions.fresnelc(z)
```

Fresnel积分C。

解释

此函数由以下定义：

\[\operatorname{C}(z) = \int_0^z \cos{\frac{\pi}{2} t^2} \mathrm{d}t.\]

这是一个整函数。

例子

```py
>>> from sympy import I, oo, fresnelc
>>> from sympy.abc import z 
```

已知几个特殊值：

```py
>>> fresnelc(0)
0
>>> fresnelc(oo)
1/2
>>> fresnelc(-oo)
-1/2
>>> fresnelc(I*oo)
I/2
>>> fresnelc(-I*oo)
-I/2 
```

通常可以从参数中提取出-1和\(i\)的因子：

```py
>>> fresnelc(-z)
-fresnelc(z)
>>> fresnelc(I*z)
I*fresnelc(z) 
```

Fresnel C积分遵守镜像对称性 \(\overline{C(z)} = C(\bar{z})\)：

```py
>>> from sympy import conjugate
>>> conjugate(fresnelc(z))
fresnelc(conjugate(z)) 
```

支持对\(z\)微分：

```py
>>> from sympy import diff
>>> diff(fresnelc(z), z)
cos(pi*z**2/2) 
```

通过积分定义Fresnel函数：

```py
>>> from sympy import integrate, pi, cos, expand_func
>>> integrate(cos(pi*z**2/2), z)
fresnelc(z)*gamma(1/4)/(4*gamma(5/4))
>>> expand_func(integrate(cos(pi*z**2/2), z))
fresnelc(z) 
```

我们可以在整个复平面上对Fresnel积分进行任意精度的数值评估：

```py
>>> fresnelc(2).evalf(30)
0.488253406075340754500223503357 
```

```py
>>> fresnelc(-2*I).evalf(30)
-0.488253406075340754500223503357*I 
```

参见

[`fresnels`](#sympy.functions.special.error_functions.fresnels "sympy.functions.special.error_functions.fresnels")

Fresnel正弦积分。

参考文献

[[R402](#id62)]

[https://en.wikipedia.org/wiki/Fresnel_integral](https://en.wikipedia.org/wiki/Fresnel_integral)

[[R403](#id63)]

[https://dlmf.nist.gov/7](https://dlmf.nist.gov/7)

[[R404](#id64)]

[https://mathworld.wolfram.com/FresnelIntegrals.html](https://mathworld.wolfram.com/FresnelIntegrals.html)

[[R405](#id65)]

[https://functions.wolfram.com/GammaBetaErf/FresnelC](https://functions.wolfram.com/GammaBetaErf/FresnelC)

[[R406](#id66)]

由John W. Wrench Jr.和Vicki Alley推导的Fresnel积分的收敛因子

## 指数、对数和三角积分

```py
class sympy.functions.special.error_functions.Ei(z)
```

经典指数积分。

解释

用于SymPy，此函数定义如下：

\[\operatorname{Ei}(x) = \sum_{n=1}^\infty \frac{x^n}{n\, n!} + \log(x) + \gamma,\]

其中\(\gamma\)是欧拉-马斯切罗尼常数。

如果\(x\)是极坐标数，则在对数的Riemann面上定义了一个解析函数。否则，在割面\(\mathbb{C} \setminus (-\infty, 0]\)中定义了一个解析函数。

**背景**

指数积分的名称来源于以下声明：

\[\operatorname{Ei}(x) = \int_{-\infty}^x \frac{e^t}{t} \mathrm{d}t\]

如果将积分解释为柯西主值，则对于\(x > 0\)和上述定义的\(\operatorname{Ei}(x)\)，此声明成立。

例子

```py
>>> from sympy import Ei, polar_lift, exp_polar, I, pi
>>> from sympy.abc import x 
```

```py
>>> Ei(-1)
Ei(-1) 
```

这产生一个实数值：

```py
>>> Ei(-1).n(chop=True)
-0.219383934395520 
```

另一方面，解析延拓并非实数：

```py
>>> Ei(polar_lift(-1)).n(chop=True)
-0.21938393439552 + 3.14159265358979*I 
```

指数积分在原点有对数分支点：

```py
>>> Ei(x*exp_polar(2*I*pi))
Ei(x) + 2*I*pi 
```

支持微分：

```py
>>> Ei(x).diff(x)
exp(x)/x 
```

指数积分与许多其他特殊函数相关联。例如：

```py
>>> from sympy import expint, Shi
>>> Ei(x).rewrite(expint)
-expint(1, x*exp_polar(I*pi)) - I*pi
>>> Ei(x).rewrite(Shi)
Chi(x) + Shi(x) 
```

参见

[`expint`](#sympy.functions.special.error_functions.expint "sympy.functions.special.error_functions.expint")

广义指数积分。

[`E1`](#sympy.functions.special.error_functions.E1 "sympy.functions.special.error_functions.E1")

广义指数积分的特殊情况。

[`li`](#sympy.functions.special.error_functions.li "sympy.functions.special.error_functions.li")

对数积分。

[`Li`](#sympy.functions.special.error_functions.Li "sympy.functions.special.error_functions.Li")

偏移对数积分。

[`Si`](#sympy.functions.special.error_functions.Si "sympy.functions.special.error_functions.Si")

正弦积分。

[`Ci`](#sympy.functions.special.error_functions.Ci "sympy.functions.special.error_functions.Ci")

余弦积分。

[`Shi`](#sympy.functions.special.error_functions.Shi "sympy.functions.special.error_functions.Shi")

双曲正弦积分。

[`Chi`](#sympy.functions.special.error_functions.Chi "sympy.functions.special.error_functions.Chi")

双曲余弦积分。

[`uppergamma`](#sympy.functions.special.gamma_functions.uppergamma "sympy.functions.special.gamma_functions.uppergamma")

上不完全Gamma函数。

参考文献

[[R407](#id67)]

[https://dlmf.nist.gov/6.6](https://dlmf.nist.gov/6.6)

[[R408](#id68)]

[https://en.wikipedia.org/wiki/Exponential_integral](https://en.wikipedia.org/wiki/Exponential_integral)

[[R409](#id69)]

Abramowitz & Stegun, section 5: [https://web.archive.org/web/20201128173312/http://people.math.sfu.ca/~cbm/aands/page_228.htm](https://web.archive.org/web/20201128173312/http://people.math.sfu.ca/~cbm/aands/page_228.htm)

```py
class sympy.functions.special.error_functions.expint(nu, z)
```

广义指数积分。

解释

此函数定义为

\[\operatorname{E}_\nu(z) = z^{\nu - 1} \Gamma(1 - \nu, z),\]

其中 \(\Gamma(1 - \nu, z)\) 是上不完全Gamma函数 (`uppergamma`)。

因此对于具有正实部的 \(z\) 我们有

\[\operatorname{E}_\nu(z) = \int_1^\infty \frac{e^{-zt}}{t^\nu} \mathrm{d}t,\]

这解释了其名称。

表示为不完全Gamma函数提供了 \(\operatorname{E}_\nu(z)\) 的解析延拓。如果 \(\nu\) 是非正整数，则指数积分是 \(z\) 的一个非分支函数，否则在原点有一个分支点。详细的分支行为请参考不完全Gamma函数的文档。

示例

```py
>>> from sympy import expint, S
>>> from sympy.abc import nu, z 
```

支持微分。对 \(z\) 的微分进一步解释了名称：对于整数阶，指数积分是指数函数的迭代积分。

```py
>>> expint(nu, z).diff(z)
-expint(nu - 1, z) 
```

对于 \(\nu\) 的微分没有经典表达式：

```py
>>> expint(nu, z).diff(nu)
-z**(nu - 1)*meijerg(((), (1, 1)), ((0, 0, 1 - nu), ()), z) 
```

在非正整数阶时，指数积分简化为指数函数：

```py
>>> expint(0, z)
exp(-z)/z
>>> expint(-1, z)
exp(-z)/z + exp(-z)/z**2 
```

在半整数处，它简化为误差函数：

```py
>>> expint(S(1)/2, z)
sqrt(pi)*erfc(sqrt(z))/sqrt(z) 
```

在正整数阶时，它可以用指数形式和 `expint(1, z)` 重写。使用 `expand_func()` 来完成这一点：

```py
>>> from sympy import expand_func
>>> expand_func(expint(5, z))
z**4*expint(1, z)/24 + (-z**3 + z**2 - 2*z + 6)*exp(-z)/24 
```

广义指数积分本质上等同于不完全Gamma函数：

```py
>>> from sympy import uppergamma
>>> expint(nu, z).rewrite(uppergamma)
z**(nu - 1)*uppergamma(1 - nu, z) 
```

因此它在原点处分支：

```py
>>> from sympy import exp_polar, pi, I
>>> expint(4, z*exp_polar(2*pi*I))
I*pi*z**3/3 + expint(4, z)
>>> expint(nu, z*exp_polar(2*pi*I))
z**(nu - 1)*(exp(2*I*pi*nu) - 1)*gamma(1 - nu) + expint(nu, z) 
```

另见

[`Ei`](#sympy.functions.special.error_functions.Ei "sympy.functions.special.error_functions.Ei")

另一个相关的称为指数积分的函数。

[`E1`](#sympy.functions.special.error_functions.E1 "sympy.functions.special.error_functions.E1")

经典情况，返回`expint(1, z)`。

[`li`](#sympy.functions.special.error_functions.li "sympy.functions.special.error_functions.li")

对数积分。

[`Li`](#sympy.functions.special.error_functions.Li "sympy.functions.special.error_functions.Li")

偏移对数积分。

[`Si`](#sympy.functions.special.error_functions.Si "sympy.functions.special.error_functions.Si")

正弦积分。

[`Ci`](#sympy.functions.special.error_functions.Ci "sympy.functions.special.error_functions.Ci")

余弦积分。

[`Shi`](#sympy.functions.special.error_functions.Shi "sympy.functions.special.error_functions.Shi")

双曲正弦积分。

[`Chi`](#sympy.functions.special.error_functions.Chi "sympy.functions.special.error_functions.Chi")

双曲余弦积分。

[`uppergamma`](#sympy.functions.special.gamma_functions.uppergamma "sympy.functions.special.gamma_functions.uppergamma")

参考文献

[[R410](#id70)]

[https://dlmf.nist.gov/8.19](https://dlmf.nist.gov/8.19)

[[R411](#id71)]

[https://functions.wolfram.com/GammaBetaErf/ExpIntegralE/](https://functions.wolfram.com/GammaBetaErf/ExpIntegralE/)

[[R412](#id72)]

[https://en.wikipedia.org/wiki/Exponential_integral](https://en.wikipedia.org/wiki/Exponential_integral)

```py
sympy.functions.special.error_functions.E1(z)
```

广义指数积分的经典情况。

解释

这等同于`expint(1, z)`。

示例

```py
>>> from sympy import E1
>>> E1(0)
expint(1, 0) 
```

```py
>>> E1(5)
expint(1, 5) 
```

另请参阅

[`Ei`](#sympy.functions.special.error_functions.Ei "sympy.functions.special.error_functions.Ei")

指数积分。

[`expint`](#sympy.functions.special.error_functions.expint "sympy.functions.special.error_functions.expint")

广义指数积分。

[`li`](#sympy.functions.special.error_functions.li "sympy.functions.special.error_functions.li")

对数积分。

[`Li`](#sympy.functions.special.error_functions.Li "sympy.functions.special.error_functions.Li")

偏移对数积分。

[`Si`](#sympy.functions.special.error_functions.Si "sympy.functions.special.error_functions.Si")

正弦积分。

[`Ci`](#sympy.functions.special.error_functions.Ci "sympy.functions.special.error_functions.Ci")

余弦积分。

[`Shi`](#sympy.functions.special.error_functions.Shi "sympy.functions.special.error_functions.Shi")

双曲正弦积分。

[`Chi`](#sympy.functions.special.error_functions.Chi "sympy.functions.special.error_functions.Chi")

双曲余弦积分。

```py
class sympy.functions.special.error_functions.li(z)
```

经典对数积分。

解释

在SymPy中使用，该函数定义为

\[\operatorname{li}(x) = \int_0^x \frac{1}{\log(t)} \mathrm{d}t \,.\]

示例

```py
>>> from sympy import I, oo, li
>>> from sympy.abc import z 
```

已知几个特殊值：

```py
>>> li(0)
0
>>> li(1)
-oo
>>> li(oo)
oo 
```

支持对\(z\)的微分：

```py
>>> from sympy import diff
>>> diff(li(z), z)
1/log(z) 
```

通过积分定义`li`函数： >>> from sympy import integrate >>> integrate(li(z)) z*li(z) - Ei(2*log(z))

```py
>>> integrate(li(z),z)
z*li(z) - Ei(2*log(z)) 
```

对数积分也可以用`Ei`定义：

```py
>>> from sympy import Ei
>>> li(z).rewrite(Ei)
Ei(log(z))
>>> diff(li(z).rewrite(Ei), z)
1/log(z) 
```

我们可以在整个复平面上（除了奇点）对对数积分进行任意精度的数值计算：

```py
>>> li(2).evalf(30)
1.04516378011749278484458888919 
```

```py
>>> li(2*I).evalf(30)
1.0652795784357498247001125598 + 3.08346052231061726610939702133*I 
```

我们甚至可以通过 mpmath 计算 Soldner 常数：

```py
>>> from mpmath import findroot
>>> findroot(li, 2)
1.45136923488338 
```

进一步的变换包括用三角积分 `Si`、`Ci`、`Shi` 和 `Chi` 重写 `li`：

```py
>>> from sympy import Si, Ci, Shi, Chi
>>> li(z).rewrite(Si)
-log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))
>>> li(z).rewrite(Ci)
-log(I*log(z)) - log(1/log(z))/2 + log(log(z))/2 + Ci(I*log(z)) + Shi(log(z))
>>> li(z).rewrite(Shi)
-log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z))
>>> li(z).rewrite(Chi)
-log(1/log(z))/2 + log(log(z))/2 + Chi(log(z)) - Shi(log(z)) 
```

另见

[`Li`](#sympy.functions.special.error_functions.Li "sympy.functions.special.error_functions.Li")

偏移对数积分。

[`Ei`](#sympy.functions.special.error_functions.Ei "sympy.functions.special.error_functions.Ei")

指数积分。

[`expint`](#sympy.functions.special.error_functions.expint "sympy.functions.special.error_functions.expint")

广义指数积分。

[`E1`](#sympy.functions.special.error_functions.E1 "sympy.functions.special.error_functions.E1")

广义指数积分的特殊情况。

[`Si`](#sympy.functions.special.error_functions.Si "sympy.functions.special.error_functions.Si")

正弦积分。

[`Ci`](#sympy.functions.special.error_functions.Ci "sympy.functions.special.error_functions.Ci")

余弦积分。

[`Shi`](#sympy.functions.special.error_functions.Shi "sympy.functions.special.error_functions.Shi")

双曲正弦积分。

[`Chi`](#sympy.functions.special.error_functions.Chi "sympy.functions.special.error_functions.Chi")

双曲余弦积分。

参考文献

[[R413](#id73)]

[对数积分](https://en.wikipedia.org/wiki/Logarithmic_integral)的广义指数积分。

[[R414](#id74)]

[对数积分](https://mathworld.wolfram.com/LogarithmicIntegral.html)。

[[R415](#id75)]

[https://dlmf.nist.gov/6](https://dlmf.nist.gov/6)

[[R416](#id76)]

[Soldner常数](https://mathworld.wolfram.com/SoldnersConstant.html)。

```py
class sympy.functions.special.error_functions.Li(z)
```

偏移对数积分。

说明

对于 SymPy 使用，此函数被定义为

\[\operatorname{Li}(x) = \operatorname{li}(x) - \operatorname{li}(2)\]

示例

```py
>>> from sympy import Li
>>> from sympy.abc import z 
```

已知以下特殊值：

```py
>>> Li(2)
0 
```

支持对 \(z\) 的微分：

```py
>>> from sympy import diff
>>> diff(Li(z), z)
1/log(z) 
```

偏移对数积分可以用 \(li(z)\) 的形式来表示：

```py
>>> from sympy import li
>>> Li(z).rewrite(li)
li(z) - li(2) 
```

我们可以在整个复平面上（除了奇点）对对数积分进行任意精度的数值计算：

```py
>>> Li(2).evalf(30)
0 
```

```py
>>> Li(4).evalf(30)
1.92242131492155809316615998938 
```

另见

[`li`](#sympy.functions.special.error_functions.li "sympy.functions.special.error_functions.li")

对数积分。

[`Ei`](#sympy.functions.special.error_functions.Ei "sympy.functions.special.error_functions.Ei")

指数积分。

[`expint`](#sympy.functions.special.error_functions.expint "sympy.functions.special.error_functions.expint")

广义指数积分。

[`E1`](#sympy.functions.special.error_functions.E1 "sympy.functions.special.error_functions.E1")

广义指数积分的特殊情况。

[`Si`](#sympy.functions.special.error_functions.Si "sympy.functions.special.error_functions.Si")

正弦积分。

[`Ci`](#sympy.functions.special.error_functions.Ci "sympy.functions.special.error_functions.Ci")

余弦积分。

[`Shi`](#sympy.functions.special.error_functions.Shi "sympy.functions.special.error_functions.Shi")

双曲正弦积分。

[`Chi`](#sympy.functions.special.error_functions.Chi "sympy.functions.special.error_functions.Chi")

双曲余弦积分。

参考文献

[[R417](#id77)]

[https://en.wikipedia.org/wiki/Logarithmic_integral](https://en.wikipedia.org/wiki/Logarithmic_integral)

[[R418](#id78)]

[https://mathworld.wolfram.com/LogarithmicIntegral.html](https://mathworld.wolfram.com/LogarithmicIntegral.html)

[[R419](#id79)]

[https://dlmf.nist.gov/6](https://dlmf.nist.gov/6)

```py
class sympy.functions.special.error_functions.Si(z)
```

正弦积分。

说明

这个函数由

\[\operatorname{Si}(z) = \int_0^z \frac{\sin{t}}{t} \mathrm{d}t.\]

这是一个整函数。

示例

```py
>>> from sympy import Si
>>> from sympy.abc import z 
```

正弦积分是\( \sin(z)/z \)的一个原函数：

```py
>>> Si(z).diff(z)
sin(z)/z 
```

它是无分支的：

```py
>>> from sympy import exp_polar, I, pi
>>> Si(z*exp_polar(2*I*pi))
Si(z) 
```

正弦积分在乘以`I`后表现得像普通正弦一样：

```py
>>> Si(I*z)
I*Shi(z)
>>> Si(-z)
-Si(z) 
```

它还可以用指数积分的形式表达，但请注意后者是分支的：

```py
>>> from sympy import expint
>>> Si(z).rewrite(expint)
-I*(-expint(1, z*exp_polar(-I*pi/2))/2 +
 expint(1, z*exp_polar(I*pi/2))/2) + pi/2 
```

它可以用sinc函数的形式重写（按定义）：

```py
>>> from sympy import sinc
>>> Si(z).rewrite(sinc)
Integral(sinc(_t), (_t, 0, z)) 
```

另请参见

[`Ci`](#sympy.functions.special.error_functions.Ci "sympy.functions.special.error_functions.Ci")

余弦积分。

[`Shi`](#sympy.functions.special.error_functions.Shi "sympy.functions.special.error_functions.Shi")

双曲正弦积分。

[`Chi`](#sympy.functions.special.error_functions.Chi "sympy.functions.special.error_functions.Chi")

双曲余弦积分。

[`Ei`](#sympy.functions.special.error_functions.Ei "sympy.functions.special.error_functions.Ei")

指数积分。

[`expint`](#sympy.functions.special.error_functions.expint "sympy.functions.special.error_functions.expint")

广义指数积分。

[`sinc`](elementary.html#sympy.functions.elementary.trigonometric.sinc "sympy.functions.elementary.trigonometric.sinc")

未归一化的sinc函数

[`E1`](#sympy.functions.special.error_functions.E1 "sympy.functions.special.error_functions.E1")

广义指数积分的特殊情况。

[`li`](#sympy.functions.special.error_functions.li "sympy.functions.special.error_functions.li")

对数积分。

[`Li`](#sympy.functions.special.error_functions.Li "sympy.functions.special.error_functions.Li")

偏移对数积分。

参考文献

[[R420](#id80)]

[https://en.wikipedia.org/wiki/Trigonometric_integral](https://en.wikipedia.org/wiki/Trigonometric_integral)

```py
class sympy.functions.special.error_functions.Ci(z)
```

余弦积分。

说明

这个函数对正\(x\)值定义为

\[\operatorname{Ci}(x) = \gamma + \log{x} + \int_0^x \frac{\cos{t} - 1}{t} \mathrm{d}t = -\int_x^\infty \frac{\cos{t}}{t} \mathrm{d}t,\]

这里\(\gamma\)是欧拉-马歇罗尼常数。

我们有

\[\operatorname{Ci}(z) = -\frac{\operatorname{E}_1\left(e^{i\pi/2} z\right) + \operatorname{E}_1\left(e^{-i \pi/2} z\right)}{2}\]

这适用于所有极坐标\(z\)，因此提供了对数的黎曼曲面的解析延拓。

对于复数域\(z \in \mathbb{C}\)，当\(\Re(z) > 0\)时，该公式也适用。通过提升到主分支，我们在割裂复平面上得到一个解析函数。

示例

```py
>>> from sympy import Ci
>>> from sympy.abc import z 
```

余弦积分是\(\cos(z)/z\)的一个原始函数：

```py
>>> Ci(z).diff(z)
cos(z)/z 
```

它在原点处有一个对数分支点：

```py
>>> from sympy import exp_polar, I, pi
>>> Ci(z*exp_polar(2*I*pi))
Ci(z) + 2*I*pi 
```

余弦积分在乘以\(i\)后的行为类似于普通的\(\cos\)：

```py
>>> from sympy import polar_lift
>>> Ci(polar_lift(I)*z)
Chi(z) + I*pi/2
>>> Ci(polar_lift(-1)*z)
Ci(z) + I*pi 
```

它也可以用指数积分的术语表达：

```py
>>> from sympy import expint
>>> Ci(z).rewrite(expint)
-expint(1, z*exp_polar(-I*pi/2))/2 - expint(1, z*exp_polar(I*pi/2))/2 
```

另请参阅

[`Si`](#sympy.functions.special.error_functions.Si "sympy.functions.special.error_functions.Si")

正弦积分。

[`Shi`](#sympy.functions.special.error_functions.Shi "sympy.functions.special.error_functions.Shi")

双曲正弦积分。

[`Chi`](#sympy.functions.special.error_functions.Chi "sympy.functions.special.error_functions.Chi")

双曲余弦积分。

[`Ei`](#sympy.functions.special.error_functions.Ei "sympy.functions.special.error_functions.Ei")

指数积分。

[`expint`](#sympy.functions.special.error_functions.expint "sympy.functions.special.error_functions.expint")

广义指数积分。

[`E1`](#sympy.functions.special.error_functions.E1 "sympy.functions.special.error_functions.E1")

广义指数积分的特殊情况。

[`li`](#sympy.functions.special.error_functions.li "sympy.functions.special.error_functions.li")

对数积分。

[`Li`](#sympy.functions.special.error_functions.Li "sympy.functions.special.error_functions.Li")

偏移对数积分。

参考文献

[[R421](#id81)]

[https://en.wikipedia.org/wiki/Trigonometric_integral](https://en.wikipedia.org/wiki/Trigonometric_integral)

```py
class sympy.functions.special.error_functions.Shi(z)
```

双曲正弦积分。

解释

此函数的定义为

\[\operatorname{Shi}(z) = \int_0^z \frac{\sinh{t}}{t} \mathrm{d}t.\]

它是一个整函数。

示例

```py
>>> from sympy import Shi
>>> from sympy.abc import z 
```

双曲正弦积分是\(\sinh(z)/z\)的一个原始函数：

```py
>>> Shi(z).diff(z)
sinh(z)/z 
```

它是无分支的：

```py
>>> from sympy import exp_polar, I, pi
>>> Shi(z*exp_polar(2*I*pi))
Shi(z) 
```

\(\sinh\)积分在乘以\(i\)后的行为类似于普通的\(\sinh\)：

```py
>>> Shi(I*z)
I*Si(z)
>>> Shi(-z)
-Shi(z) 
```

它也可以用指数积分的术语表达，但要注意后者是分支的：

```py
>>> from sympy import expint
>>> Shi(z).rewrite(expint)
expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2 
```

另请参阅

[`Si`](#sympy.functions.special.error_functions.Si "sympy.functions.special.error_functions.Si")

正弦积分。

[`Ci`](#sympy.functions.special.error_functions.Ci "sympy.functions.special.error_functions.Ci")

余弦积分。

[`Chi`](#sympy.functions.special.error_functions.Chi "sympy.functions.special.error_functions.Chi")

双曲余弦积分。

[`Ei`](#sympy.functions.special.error_functions.Ei "sympy.functions.special.error_functions.Ei")

指数积分。

[`expint`](#sympy.functions.special.error_functions.expint "sympy.functions.special.error_functions.expint")

广义指数积分。

[`E1`](#sympy.functions.special.error_functions.E1 "sympy.functions.special.error_functions.E1")

广义指数积分的特殊情况。

[`li`](#sympy.functions.special.error_functions.li "sympy.functions.special.error_functions.li")

对数积分。

[`Li`](#sympy.functions.special.error_functions.Li "sympy.functions.special.error_functions.Li")

偏移对数积分。

参考文献

[[R422](#id82)]

[https://en.wikipedia.org/wiki/Trigonometric_integral](https://en.wikipedia.org/wiki/Trigonometric_integral)

```py
class sympy.functions.special.error_functions.Chi(z)
```

双曲余弦积分。

解释

此函数对正 \(x\) 定义为

\[\operatorname{Chi}(x) = \gamma + \log{x} + \int_0^x \frac{\cosh{t} - 1}{t} \mathrm{d}t,\]

这里 \(\gamma\) 是欧拉-马歇罗尼常数。

我们有

\[\operatorname{Chi}(z) = \operatorname{Ci}\left(e^{i \pi/2}z\right) - i\frac{\pi}{2},\]

对所有极坐标 \(z\) 都成立，并且因此在对数的黎曼面上提供了解析延拓。通过提升到主支，我们在切割复平面上获得了解析函数。

示例

```py
>>> from sympy import Chi
>>> from sympy.abc import z 
```

双曲余弦积分是 \(\cosh(z)/z\) 的原函数：

```py
>>> Chi(z).diff(z)
cosh(z)/z 
```

它在原点有一个对数分支点：

```py
>>> from sympy import exp_polar, I, pi
>>> Chi(z*exp_polar(2*I*pi))
Chi(z) + 2*I*pi 
```

双曲余弦积分在乘以 \(i\) 后的行为有些像普通的双曲余弦：

```py
>>> from sympy import polar_lift
>>> Chi(polar_lift(I)*z)
Ci(z) + I*pi/2
>>> Chi(polar_lift(-1)*z)
Chi(z) + I*pi 
```

它也可以用指数积分的形式表示：

```py
>>> from sympy import expint
>>> Chi(z).rewrite(expint)
-expint(1, z)/2 - expint(1, z*exp_polar(I*pi))/2 - I*pi/2 
```

另见

[`Si`](#sympy.functions.special.error_functions.Si "sympy.functions.special.error_functions.Si")

正弦积分。

[`Ci`](#sympy.functions.special.error_functions.Ci "sympy.functions.special.error_functions.Ci")

余弦积分。

[`Shi`](#sympy.functions.special.error_functions.Shi "sympy.functions.special.error_functions.Shi")

双曲正弦积分。

[`Ei`](#sympy.functions.special.error_functions.Ei "sympy.functions.special.error_functions.Ei")

指数积分。

[`expint`](#sympy.functions.special.error_functions.expint "sympy.functions.special.error_functions.expint")

广义指数积分。

[`E1`](#sympy.functions.special.error_functions.E1 "sympy.functions.special.error_functions.E1")

广义指数积分的特殊情况。

[`li`](#sympy.functions.special.error_functions.li "sympy.functions.special.error_functions.li")

对数积分。

[`Li`](#sympy.functions.special.error_functions.Li "sympy.functions.special.error_functions.Li")

偏移对数积分。

参考文献

[[R423](#id83)]

[https://en.wikipedia.org/wiki/Trigonometric_integral](https://en.wikipedia.org/wiki/Trigonometric_integral)

## 贝塞尔类型函数

```py
class sympy.functions.special.bessel.BesselBase(nu, z)
```

贝塞尔类型函数的抽象基类。

这个类旨在减少代码重复。所有贝塞尔类型函数都可以：1）被微分，其导数用类似函数表达，以及 2）用其他贝塞尔类型函数重写。

这里假设贝塞尔类型函数有一个复参数。

要使用这个基类，定义类属性 `_a` 和 `_b`，使得 `2*F_n' = -_a*F_{n+1} + b*F_{n-1}`。

```py
property argument
```

贝塞尔类型函数的参数。

```py
property order
```

贝塞尔类型函数的阶数。

```py
class sympy.functions.special.bessel.besselj(nu, z)
```

第一类贝塞尔函数。

解释

阶数为 \(\nu\) 的贝塞尔 \(J\) 函数被定义为满足贝塞尔微分方程的函数

\[z^2 \frac{\mathrm{d}^2 w}{\mathrm{d}z^2} + z \frac{\mathrm{d}w}{\mathrm{d}z} + (z^2 - \nu^2) w = 0,\]

拉朗日展开

\[J_\nu(z) = z^\nu \left(\frac{1}{\Gamma(\nu + 1) 2^\nu} + O(z^2) \right),\]

如果 \(\nu\) 不是负整数。如果 \(\nu=-n \in \mathbb{Z}_{<0}\) *是* 负整数，则定义为

\[J_{-n}(z) = (-1)^n J_n(z).\]

例子

创建一个贝塞尔函数对象：

```py
>>> from sympy import besselj, jn
>>> from sympy.abc import z, n
>>> b = besselj(n, z) 
```

对其进行微分：

```py
>>> b.diff(z)
besselj(n - 1, z)/2 - besselj(n + 1, z)/2 
```

用球贝塞尔函数重新表述：

```py
>>> b.rewrite(jn)
sqrt(2)*sqrt(z)*jn(n - 1/2, z)/sqrt(pi) 
```

访问参数和参数：

```py
>>> b.order
n
>>> b.argument
z 
```

另请参阅

[`bessely`](#sympy.functions.special.bessel.bessely "sympy.functions.special.bessel.bessely"), [`besseli`](#sympy.functions.special.bessel.besseli "sympy.functions.special.bessel.besseli"), [`besselk`](#sympy.functions.special.bessel.besselk "sympy.functions.special.bessel.besselk")

参考文献

[[R424](#id84)]

Abramowitz, Milton; Stegun, Irene A., eds. (1965), “第9章”, Handbook of Mathematical Functions with Formulas, Graphs, and Mathematical Tables

[[R425](#id85)]

Luke, Y. L. (1969), The Special Functions and Their Approximations, Volume 1

[[R426](#id86)]

[https://en.wikipedia.org/wiki/Bessel_function](https://en.wikipedia.org/wiki/Bessel_function)

[[R427](#id87)]

[https://functions.wolfram.com/Bessel-TypeFunctions/BesselJ/](https://functions.wolfram.com/Bessel-TypeFunctions/BesselJ/)

```py
class sympy.functions.special.bessel.bessely(nu, z)
```

第二类贝塞尔函数。

解释

阶数为 \(\nu\) 的贝塞尔 \(Y\) 函数定义如下：

\[Y_\nu(z) = \lim_{\mu \to \nu} \frac{J_\mu(z) \cos(\pi \mu) - J_{-\mu}(z)}{\sin(\pi \mu)},\]

其中 \(J_\mu(z)\) 是第一类贝塞尔函数。

它是贝塞尔方程的解，且与 \(J_\nu\) 线性无关。

例子

```py
>>> from sympy import bessely, yn
>>> from sympy.abc import z, n
>>> b = bessely(n, z)
>>> b.diff(z)
bessely(n - 1, z)/2 - bessely(n + 1, z)/2
>>> b.rewrite(yn)
sqrt(2)*sqrt(z)*yn(n - 1/2, z)/sqrt(pi) 
```

另请参阅

[`besselj`](#sympy.functions.special.bessel.besselj "sympy.functions.special.bessel.besselj"), [`besseli`](#sympy.functions.special.bessel.besseli "sympy.functions.special.bessel.besseli"), [`besselk`](#sympy.functions.special.bessel.besselk "sympy.functions.special.bessel.besselk")

参考文献

[[R428](#id88)]

[https://functions.wolfram.com/Bessel-TypeFunctions/BesselY/](https://functions.wolfram.com/Bessel-TypeFunctions/BesselY/)

```py
class sympy.functions.special.bessel.besseli(nu, z)
```

第一类修正贝塞尔函数。

解释

贝塞尔 \(I\) 函数是修正贝塞尔方程的解

\[z^2 \frac{\mathrm{d}^2 w}{\mathrm{d}z^2} + z \frac{\mathrm{d}w}{\mathrm{d}z} + (z^2 + \nu^2)^2 w = 0.\]

它可以定义为

\[I_\nu(z) = i^{-\nu} J_\nu(iz),\]

其中 \(J_\nu(z)\) 是第一类贝塞尔函数。

例子

```py
>>> from sympy import besseli
>>> from sympy.abc import z, n
>>> besseli(n, z).diff(z)
besseli(n - 1, z)/2 + besseli(n + 1, z)/2 
```

另请参阅

[`besselj`](#sympy.functions.special.bessel.besselj "sympy.functions.special.bessel.besselj"), [`bessely`](#sympy.functions.special.bessel.bessely "sympy.functions.special.bessel.bessely"), [`besselk`](#sympy.functions.special.bessel.besselk "sympy.functions.special.bessel.besselk")

参考文献

[[R429](#id89)]

[https://functions.wolfram.com/Bessel-TypeFunctions/BesselI/](https://functions.wolfram.com/Bessel-TypeFunctions/BesselI/)

```py
class sympy.functions.special.bessel.besselk(nu, z)
```

第二类修正贝塞尔函数。

解释

第\(K\)类贝塞尔函数的阶数\(\nu\)被定义为

\[K_\nu(z) = \lim_{\mu \to \nu} \frac{\pi}{2} \frac{I_{-\mu}(z) -I_\mu(z)}{\sin(\pi \mu)},\]

其中\(I_\mu(z)\)是修正第一类贝塞尔函数。

它是修正贝塞尔方程的解，且与\(Y_\nu\)线性无关。

例子

```py
>>> from sympy import besselk
>>> from sympy.abc import z, n
>>> besselk(n, z).diff(z)
-besselk(n - 1, z)/2 - besselk(n + 1, z)/2 
```

参见

[`besselj`](#sympy.functions.special.bessel.besselj "sympy.functions.special.bessel.besselj"), [`besseli`](#sympy.functions.special.bessel.besseli "sympy.functions.special.bessel.besseli"), [`bessely`](#sympy.functions.special.bessel.bessely "sympy.functions.special.bessel.bessely")

参考文献

[[R430](#id90)]

[https://functions.wolfram.com/Bessel-TypeFunctions/BesselK/](https://functions.wolfram.com/Bessel-TypeFunctions/BesselK/)

```py
class sympy.functions.special.bessel.hankel1(nu, z)
```

第一类汉克尔函数。

解释

此函数被定义为

\[H_\nu^{(1)} = J_\nu(z) + iY_\nu(z),\]

其中\(J_\nu(z)\)是第一类贝塞尔函数，\(Y_\nu(z)\)是第二类贝塞尔函数。

它是贝塞尔方程的解。

例子

```py
>>> from sympy import hankel1
>>> from sympy.abc import z, n
>>> hankel1(n, z).diff(z)
hankel1(n - 1, z)/2 - hankel1(n + 1, z)/2 
```

参见

[`hankel2`](#sympy.functions.special.bessel.hankel2 "sympy.functions.special.bessel.hankel2"), [`besselj`](#sympy.functions.special.bessel.besselj "sympy.functions.special.bessel.besselj"), [`bessely`](#sympy.functions.special.bessel.bessely "sympy.functions.special.bessel.bessely")

参考文献

[[R431](#id91)]

[https://functions.wolfram.com/Bessel-TypeFunctions/HankelH1/](https://functions.wolfram.com/Bessel-TypeFunctions/HankelH1/)

```py
class sympy.functions.special.bessel.hankel2(nu, z)
```

第二类汉克尔函数。

解释

此函数被定义为

\[H_\nu^{(2)} = J_\nu(z) - iY_\nu(z),\]

其中\(J_\nu(z)\)是第一类贝塞尔函数，\(Y_\nu(z)\)是第二类贝塞尔函数。

它是贝塞尔方程的解，且与\(H_\nu^{(1)}\)线性无关。

例子

```py
>>> from sympy import hankel2
>>> from sympy.abc import z, n
>>> hankel2(n, z).diff(z)
hankel2(n - 1, z)/2 - hankel2(n + 1, z)/2 
```

参见

[`hankel1`](#sympy.functions.special.bessel.hankel1 "sympy.functions.special.bessel.hankel1"), [`besselj`](#sympy.functions.special.bessel.besselj "sympy.functions.special.bessel.besselj"), [`bessely`](#sympy.functions.special.bessel.bessely "sympy.functions.special.bessel.bessely")

参考文献

[[R432](#id92)]

[https://functions.wolfram.com/Bessel-TypeFunctions/HankelH2/](https://functions.wolfram.com/Bessel-TypeFunctions/HankelH2/)

```py
class sympy.functions.special.bessel.jn(nu, z)
```

[第一类球贝塞尔函数](https://functions.wolfram.com/Bessel-TypeFunctions/HankelH1/)。

解释

此函数是球形贝塞尔方程的解

\[z^2 \frac{\mathrm{d}^2 w}{\mathrm{d}z^2} + 2z \frac{\mathrm{d}w}{\mathrm{d}z} + (z^2 - \nu(\nu + 1)) w = 0.\]

可定义为

\[j_\nu(z) = \sqrt{\frac{\pi}{2z}} J_{\nu + \frac{1}{2}}(z),\]

其中\(J_\nu(z)\)是第一类贝塞尔函数。

整数阶球贝塞尔函数使用以下公式计算：

\[j_n(z) = f_n(z) \sin{z} + (-1)^{n+1} f_{-n-1}(z) \cos{z},\]

其中系数 \(f_n(z)\) 可以通过[`sympy.polys.orthopolys.spherical_bessel_fn()`](../polys/reference.html#sympy.polys.orthopolys.spherical_bessel_fn "sympy.polys.orthopolys.spherical_bessel_fn") 获得。

示例

```py
>>> from sympy import Symbol, jn, sin, cos, expand_func, besselj, bessely
>>> z = Symbol("z")
>>> nu = Symbol("nu", integer=True)
>>> print(expand_func(jn(0, z)))
sin(z)/z
>>> expand_func(jn(1, z)) == sin(z)/z**2 - cos(z)/z
True
>>> expand_func(jn(3, z))
(-6/z**2 + 15/z**4)*sin(z) + (1/z - 15/z**3)*cos(z)
>>> jn(nu, z).rewrite(besselj)
sqrt(2)*sqrt(pi)*sqrt(1/z)*besselj(nu + 1/2, z)/2
>>> jn(nu, z).rewrite(bessely)
(-1)**nu*sqrt(2)*sqrt(pi)*sqrt(1/z)*bessely(-nu - 1/2, z)/2
>>> jn(2, 5.2+0.3j).evalf(20)
0.099419756723640344491 - 0.054525080242173562897*I 
```

另请参阅

[`besselj`](#sympy.functions.special.bessel.besselj "sympy.functions.special.bessel.besselj"), [`bessely`](#sympy.functions.special.bessel.bessely "sympy.functions.special.bessel.bessely"), [`besselk`](#sympy.functions.special.bessel.besselk "sympy.functions.special.bessel.besselk"), [`yn`](#sympy.functions.special.bessel.yn "sympy.functions.special.bessel.yn")

参考文献

[[R433](#id93)]

[https://dlmf.nist.gov/10.47](https://dlmf.nist.gov/10.47)

```py
class sympy.functions.special.bessel.yn(nu, z)
```

第二类球贝塞尔函数。

解释

此函数是球贝塞尔方程的另一解，与\(j_n\)线性无关。可以定义为

\[y_\nu(z) = \sqrt{\frac{\pi}{2z}} Y_{\nu + \frac{1}{2}}(z),\]

其中\(Y_\nu(z)\)是第二类贝塞尔函数。

对于整数阶\(n\)，使用以下公式计算\(y_n\)：

\[y_n(z) = (-1)^{n+1} j_{-n-1}(z)\]

示例

```py
>>> from sympy import Symbol, yn, sin, cos, expand_func, besselj, bessely
>>> z = Symbol("z")
>>> nu = Symbol("nu", integer=True)
>>> print(expand_func(yn(0, z)))
-cos(z)/z
>>> expand_func(yn(1, z)) == -cos(z)/z**2-sin(z)/z
True
>>> yn(nu, z).rewrite(besselj)
(-1)**(nu + 1)*sqrt(2)*sqrt(pi)*sqrt(1/z)*besselj(-nu - 1/2, z)/2
>>> yn(nu, z).rewrite(bessely)
sqrt(2)*sqrt(pi)*sqrt(1/z)*bessely(nu + 1/2, z)/2
>>> yn(2, 5.2+0.3j).evalf(20)
0.18525034196069722536 + 0.014895573969924817587*I 
```

另请参阅

[`besselj`](#sympy.functions.special.bessel.besselj "sympy.functions.special.bessel.besselj"), [`bessely`](#sympy.functions.special.bessel.bessely "sympy.functions.special.bessel.bessely"), [`besselk`](#sympy.functions.special.bessel.besselk "sympy.functions.special.bessel.besselk"), [`jn`](#sympy.functions.special.bessel.jn "sympy.functions.special.bessel.jn")

参考文献

[[R434](#id94)]

[https://dlmf.nist.gov/10.47](https://dlmf.nist.gov/10.47)

```py
sympy.functions.special.bessel.jn_zeros(n, k, method='sympy', dps=15)
```

第一类球贝塞尔函数的零点。

参数：

**n** : 整数

> 贝塞尔函数的阶数

**k** : 整数

> 返回的零点数

解释

这返回一个包含\(jn\)的零点数组，直到第\(k\)个零点。

+   method = “sympy”: 使用[mpmath.besseljzero](https://mpmath.org/doc/current/functions/bessel.html#mpmath.besseljzero)

+   method = “scipy”: 使用[SciPy 的 sph_jn](https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.jn_zeros.html) 和[newton](https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.newton.html)来找到所有根，比使用一般数值求解器计算零点更快，但需要 SciPy，并且仅适用于低精度浮点数。（在使用 method=”sympy” 的函数之前，mpmath 使用一般求解器。）

示例

```py
>>> from sympy import jn_zeros
>>> jn_zeros(2, 4, dps=5)
[5.7635, 9.095, 12.323, 15.515] 
```

另请参阅

[`jn`](#sympy.functions.special.bessel.jn "sympy.functions.special.bessel.jn"), [`yn`](#sympy.functions.special.bessel.yn "sympy.functions.special.bessel.yn"), [`besselj`](#sympy.functions.special.bessel.besselj "sympy.functions.special.bessel.besselj"), [`besselk`](#sympy.functions.special.bessel.besselk "sympy.functions.special.bessel.besselk"), [`bessely`](#sympy.functions.special.bessel.bessely "sympy.functions.special.bessel.bessely")

```py
class sympy.functions.special.bessel.marcumq(m, a, b)
```

Marcum Q-函数。

解释

Marcum Q-函数由球贝塞尔方程的亚纯延拓定义

\[Q_m(a, b) = a^{- m + 1} \int_{b}^{\infty} x^{m} e^{- \frac{a^{2}}{2} - \frac{x^{2}}{2}} I_{m - 1}\left(a x\right)\, dx\]

示例

```py
>>> from sympy import marcumq
>>> from sympy.abc import m, a, b
>>> marcumq(m, a, b)
marcumq(m, a, b) 
```

特殊值：

```py
>>> marcumq(m, 0, b)
uppergamma(m, b**2/2)/gamma(m)
>>> marcumq(0, 0, 0)
0
>>> marcumq(0, a, 0)
1 - exp(-a**2/2)
>>> marcumq(1, a, a)
1/2 + exp(-a**2)*besseli(0, a**2)/2
>>> marcumq(2, a, a)
1/2 + exp(-a**2)*besseli(0, a**2)/2 + exp(-a**2)*besseli(1, a**2) 
```

支持对 \(a\) 和 \(b\) 的微分：

```py
>>> from sympy import diff
>>> diff(marcumq(m, a, b), a)
a*(-marcumq(m, a, b) + marcumq(m + 1, a, b))
>>> diff(marcumq(m, a, b), b)
-a**(1 - m)*b**m*exp(-a**2/2 - b**2/2)*besseli(m - 1, a*b) 
```

参考文献

[[R435](#id95)]

[https://en.wikipedia.org/wiki/Marcum_Q-function](https://en.wikipedia.org/wiki/Marcum_Q-function)

[[R436](#id96)]

[https://mathworld.wolfram.com/MarcumQ-Function.html](https://mathworld.wolfram.com/MarcumQ-Function.html)

## Airy 函数

```py
class sympy.functions.special.bessel.AiryBase(*args)
```

Airy 函数的抽象基类。

这个类旨在减少代码重复。

```py
class sympy.functions.special.bessel.airyai(arg)
```

Airy 函数 \(\operatorname{Ai}\) 的第一种形式。

说明

Airy 函数 \(\operatorname{Ai}(z)\) 被定义为满足 Airy 微分方程的函数

\[\frac{\mathrm{d}^2 w(z)}{\mathrm{d}z^2} - z w(z) = 0.\]

同样地，对于实数 \(z\)

\[\operatorname{Ai}(z) := \frac{1}{\pi} \int_0^\infty \cos\left(\frac{t^3}{3} + z t\right) \mathrm{d}t.\]

示例

创建一个 Airy 函数对象：

```py
>>> from sympy import airyai
>>> from sympy.abc import z 
```

```py
>>> airyai(z)
airyai(z) 
```

已知若干特殊值：

```py
>>> airyai(0)
3**(1/3)/(3*gamma(2/3))
>>> from sympy import oo
>>> airyai(oo)
0
>>> airyai(-oo)
0 
```

Airy 函数遵循镜像对称性：

```py
>>> from sympy import conjugate
>>> conjugate(airyai(z))
airyai(conjugate(z)) 
```

支持对 \(z\) 的微分：

```py
>>> from sympy import diff
>>> diff(airyai(z), z)
airyaiprime(z)
>>> diff(airyai(z), z, 2)
z*airyai(z) 
```

系列展开也支持：

```py
>>> from sympy import series
>>> series(airyai(z), z, 0, 3)
3**(5/6)*gamma(1/3)/(6*pi) - 3**(1/6)*z*gamma(2/3)/(2*pi) + O(z**3) 
```

我们可以在整个复平面上对 Airy 函数进行任意精度的数值评估：

```py
>>> airyai(-2).evalf(50)
0.22740742820168557599192443603787379946077222541710 
```

重写 \(\operatorname{Ai}(z)\) 以超几何函数表示：

```py
>>> from sympy import hyper
>>> airyai(z).rewrite(hyper)
-3**(2/3)*z*hyper((), (4/3,), z**3/9)/(3*gamma(1/3)) + 3**(1/3)*hyper((), (2/3,), z**3/9)/(3*gamma(2/3)) 
```

参见

[`airybi`](#sympy.functions.special.bessel.airybi "sympy.functions.special.bessel.airybi")

Airy 函数的第二种形式。

[`airyaiprime`](#sympy.functions.special.bessel.airyaiprime "sympy.functions.special.bessel.airyaiprime")

Airy 函数的第一种形式的导数。

[`airybiprime`](#sympy.functions.special.bessel.airybiprime "sympy.functions.special.bessel.airybiprime")

Airy 函数的第二种形式的导数。

参考文献

[[R437](#id97)]

[https://en.wikipedia.org/wiki/Airy_function](https://en.wikipedia.org/wiki/Airy_function)

[[R438](#id98)]

[https://dlmf.nist.gov/9](https://dlmf.nist.gov/9)

[[R439](#id99)]

[https://encyclopediaofmath.org/wiki/Airy_functions](https://encyclopediaofmath.org/wiki/Airy_functions)

[[R440](#id100)]

[https://mathworld.wolfram.com/AiryFunctions.html](https://mathworld.wolfram.com/AiryFunctions.html)

```py
class sympy.functions.special.bessel.airybi(arg)
```

Airy 函数 \(\operatorname{Bi}\) 的第二种形式。

说明

Airy 函数 \(\operatorname{Bi}(z)\) 被定义为满足 Airy 微分方程的函数

\[\frac{\mathrm{d}^2 w(z)}{\mathrm{d}z^2} - z w(z) = 0.\]

同样地，对于实数 \(z\)

\[\operatorname{Bi}(z) := \frac{1}{\pi} \int_0^\infty \exp\left(-\frac{t^3}{3} + z t\right) + \sin\left(\frac{t^3}{3} + z t\right) \mathrm{d}t.\]

示例

创建一个 Airy 函数对象：

```py
>>> from sympy import airybi
>>> from sympy.abc import z 
```

```py
>>> airybi(z)
airybi(z) 
```

已知若干特殊值：

```py
>>> airybi(0)
3**(5/6)/(3*gamma(2/3))
>>> from sympy import oo
>>> airybi(oo)
oo
>>> airybi(-oo)
0 
```

Airy 函数遵循镜像对称性：

```py
>>> from sympy import conjugate
>>> conjugate(airybi(z))
airybi(conjugate(z)) 
```

支持对 \(z\) 的微分：

```py
>>> from sympy import diff
>>> diff(airybi(z), z)
airybiprime(z)
>>> diff(airybi(z), z, 2)
z*airybi(z) 
```

系列展开也支持：

```py
>>> from sympy import series
>>> series(airybi(z), z, 0, 3)
3**(1/3)*gamma(1/3)/(2*pi) + 3**(2/3)*z*gamma(2/3)/(2*pi) + O(z**3) 
```

我们可以在整个复平面上对 Airy 函数进行任意精度的数值评估：

```py
>>> airybi(-2).evalf(50)
-0.41230258795639848808323405461146104203453483447240 
```

重写 \(\operatorname{Bi}(z)\) 以超几何函数表示：

```py
>>> from sympy import hyper
>>> airybi(z).rewrite(hyper)
3**(1/6)*z*hyper((), (4/3,), z**3/9)/gamma(1/3) + 3**(5/6)*hyper((), (2/3,), z**3/9)/(3*gamma(2/3)) 
```

参见

[`airyai`](#sympy.functions.special.bessel.airyai "sympy.functions.special.bessel.airyai")

艾里函数第一类。

[`airyaiprime`](#sympy.functions.special.bessel.airyaiprime "sympy.functions.special.bessel.airyaiprime")

艾里函数第一类的导数。

[`airybiprime`](#sympy.functions.special.bessel.airybiprime "sympy.functions.special.bessel.airybiprime")

艾里函数第二类的导数。

参考文献

[[R441](#id101)]

[https://en.wikipedia.org/wiki/Airy_function](https://en.wikipedia.org/wiki/Airy_function)

[[R442](#id102)]

[https://dlmf.nist.gov/9](https://dlmf.nist.gov/9)

[[R443](#id103)]

[https://encyclopediaofmath.org/wiki/Airy_functions](https://encyclopediaofmath.org/wiki/Airy_functions)

[[R444](#id104)]

[https://mathworld.wolfram.com/AiryFunctions.html](https://mathworld.wolfram.com/AiryFunctions.html)

```py
class sympy.functions.special.bessel.airyaiprime(arg)
```

艾里函数第一类的导数\(\operatorname{Ai}^\prime\)。

说明

艾里函数\(\operatorname{Ai}^\prime(z)\)定义为函数

\[\operatorname{Ai}^\prime(z) := \frac{\mathrm{d} \operatorname{Ai}(z)}{\mathrm{d} z}.\]

示例

创建一个艾里函数对象：

```py
>>> from sympy import airyaiprime
>>> from sympy.abc import z 
```

```py
>>> airyaiprime(z)
airyaiprime(z) 
```

已知多个特殊值：

```py
>>> airyaiprime(0)
-3**(2/3)/(3*gamma(1/3))
>>> from sympy import oo
>>> airyaiprime(oo)
0 
```

艾里函数遵循镜像对称性：

```py
>>> from sympy import conjugate
>>> conjugate(airyaiprime(z))
airyaiprime(conjugate(z)) 
```

支持关于\(z\)的微分：

```py
>>> from sympy import diff
>>> diff(airyaiprime(z), z)
z*airyai(z)
>>> diff(airyaiprime(z), z, 2)
z*airyaiprime(z) + airyai(z) 
```

级数展开也是支持的：

```py
>>> from sympy import series
>>> series(airyaiprime(z), z, 0, 3)
-3**(2/3)/(3*gamma(1/3)) + 3**(1/3)*z**2/(6*gamma(2/3)) + O(z**3) 
```

我们可以在整个复平面上对艾里函数进行任意精度的数值评估：

```py
>>> airyaiprime(-2).evalf(50)
0.61825902074169104140626429133247528291577794512415 
```

将\(\operatorname{Ai}^\prime(z)\)重写为超几何函数的形式：

```py
>>> from sympy import hyper
>>> airyaiprime(z).rewrite(hyper)
3**(1/3)*z**2*hyper((), (5/3,), z**3/9)/(6*gamma(2/3)) - 3**(2/3)*hyper((), (1/3,), z**3/9)/(3*gamma(1/3)) 
```

另请参阅

[`airyai`](#sympy.functions.special.bessel.airyai "sympy.functions.special.bessel.airyai")

艾里函数第一类。

[`airybi`](#sympy.functions.special.bessel.airybi "sympy.functions.special.bessel.airybi")

艾里函数第二类。

[`airybiprime`](#sympy.functions.special.bessel.airybiprime "sympy.functions.special.bessel.airybiprime")

艾里函数第二类的导数。

参考文献

[[R445](#id105)]

[https://en.wikipedia.org/wiki/Airy_function](https://en.wikipedia.org/wiki/Airy_function)

[[R446](#id106)]

[https://dlmf.nist.gov/9](https://dlmf.nist.gov/9)

[[R447](#id107)]

[https://encyclopediaofmath.org/wiki/Airy_functions](https://encyclopediaofmath.org/wiki/Airy_functions)

[[R448](#id108)]

[https://mathworld.wolfram.com/AiryFunctions.html](https://mathworld.wolfram.com/AiryFunctions.html)

```py
class sympy.functions.special.bessel.airybiprime(arg)
```

艾里函数第一类的导数\(\operatorname{Bi}^\prime\)。

说明

艾里函数\(\operatorname{Bi}^\prime(z)\)定义为函数

\[\operatorname{Bi}^\prime(z) := \frac{\mathrm{d} \operatorname{Bi}(z)}{\mathrm{d} z}.\]

示例

创建一个艾里函数对象：

```py
>>> from sympy import airybiprime
>>> from sympy.abc import z 
```

```py
>>> airybiprime(z)
airybiprime(z) 
```

已知多个特殊值：

```py
>>> airybiprime(0)
3**(1/6)/gamma(1/3)
>>> from sympy import oo
>>> airybiprime(oo)
oo
>>> airybiprime(-oo)
0 
```

艾里函数遵循镜像对称性：

```py
>>> from sympy import conjugate
>>> conjugate(airybiprime(z))
airybiprime(conjugate(z)) 
```

支持关于\(z\)的微分：

```py
>>> from sympy import diff
>>> diff(airybiprime(z), z)
z*airybi(z)
>>> diff(airybiprime(z), z, 2)
z*airybiprime(z) + airybi(z) 
```

级数展开也是支持的：

```py
>>> from sympy import series
>>> series(airybiprime(z), z, 0, 3)
3**(1/6)/gamma(1/3) + 3**(5/6)*z**2/(6*gamma(2/3)) + O(z**3) 
```

我们可以在整个复平面上对艾里函数进行任意精度的数值评估：

```py
>>> airybiprime(-2).evalf(50)
0.27879516692116952268509756941098324140300059345163 
```

重写\(\operatorname{Bi}^\prime(z)\)以超几何函数的形式：

```py
>>> from sympy import hyper
>>> airybiprime(z).rewrite(hyper)
3**(5/6)*z**2*hyper((), (5/3,), z**3/9)/(6*gamma(2/3)) + 3**(1/6)*hyper((), (1/3,), z**3/9)/gamma(1/3) 
```

参见

[`airyai`](#sympy.functions.special.bessel.airyai "sympy.functions.special.bessel.airyai")

Airy函数的第一种。

[`airybi`](#sympy.functions.special.bessel.airybi "sympy.functions.special.bessel.airybi")

Airy函数的第二种。

[`airyaiprime`](#sympy.functions.special.bessel.airyaiprime "sympy.functions.special.bessel.airyaiprime")

Airy函数的第一种的导数。

参考资料

[[R449](#id109)]

[https://en.wikipedia.org/wiki/Airy_function](https://en.wikipedia.org/wiki/Airy_function)

[[R450](#id110)]

[https://dlmf.nist.gov/9](https://dlmf.nist.gov/9)

[[R451](#id111)]

[https://encyclopediaofmath.org/wiki/Airy_functions](https://encyclopediaofmath.org/wiki/Airy_functions)

[[R452](#id112)]

[https://mathworld.wolfram.com/AiryFunctions.html](https://mathworld.wolfram.com/AiryFunctions.html)

## B样条

```py
sympy.functions.special.bsplines.bspline_basis(d, knots, n, x)
```

在给定结点*knots*处的阶为*d*的第*n*个B样条。

参数：

**d**：整数

> B样条的度数

**knots**：整数值列表

> B样条的结节点列表。

**n**：整数

> 第*n*个B样条

**x**：符号

说明

B样条是阶为*d*的分段多项式。它们定义在结点的集合上，这些结点是整数或浮点数序列。

示例

第0阶样条在单个区间上的值为1：

```py
>>> from sympy import bspline_basis
>>> from sympy.abc import x
>>> d = 0
>>> knots = tuple(range(5))
>>> bspline_basis(d, knots, 0, x)
Piecewise((1, (x >= 0) & (x <= 1)), (0, True)) 
```

对于给定的`(d, knots)`，定义了`len(knots)-d-1`个B样条，其由索引`n`（从0开始）索引。

这是一个三次B样条的示例：

```py
>>> bspline_basis(3, tuple(range(5)), 0, x)
Piecewise((x**3/6, (x >= 0) & (x <= 1)),
 (-x**3/2 + 2*x**2 - 2*x + 2/3,
 (x >= 1) & (x <= 2)),
 (x**3/2 - 4*x**2 + 10*x - 22/3,
 (x >= 2) & (x <= 3)),
 (-x**3/6 + 2*x**2 - 8*x + 32/3,
 (x >= 3) & (x <= 4)),
 (0, True)) 
```

通过重复结节点，可以在B样条及其导数中引入不连续性：

```py
>>> d = 1
>>> knots = (0, 0, 2, 3, 4)
>>> bspline_basis(d, knots, 0, x)
Piecewise((1 - x/2, (x >= 0) & (x <= 2)), (0, True)) 
```

构造和评估B样条非常耗时。如果需要多次评估B样条，最好先对它们进行lambdify处理：

```py
>>> from sympy import lambdify
>>> d = 3
>>> knots = tuple(range(10))
>>> b0 = bspline_basis(d, knots, 0, x)
>>> f = lambdify(x, b0)
>>> y = f(0.5) 
```

参见

[`bspline_basis_set`](#sympy.functions.special.bsplines.bspline_basis_set "sympy.functions.special.bsplines.bspline_basis_set")

参考资料

[[R453](#id113)]

[https://en.wikipedia.org/wiki/B-spline](https://en.wikipedia.org/wiki/B-spline)

```py
sympy.functions.special.bsplines.bspline_basis_set(d, knots, x)
```

返回在*knots*处的阶为*d*的*B-splines*的`len(knots)-d-1`个。

参数：

**d**：整数

> B样条的度数

**knots**：整数列表

> B样条的结节点列表

**x**：符号

说明

此函数返回一个多段多项式列表，这些多项式是给定结点*knots*的度数为*d*的`len(knots)-d-1`个B样条。该函数为不同的*n*值调用`bspline_basis(d, knots, n, x)`。

示例

```py
>>> from sympy import bspline_basis_set
>>> from sympy.abc import x
>>> d = 2
>>> knots = range(5)
>>> splines = bspline_basis_set(d, knots, x)
>>> splines
[Piecewise((x**2/2, (x >= 0) & (x <= 1)),
 (-x**2 + 3*x - 3/2, (x >= 1) & (x <= 2)),
 (x**2/2 - 3*x + 9/2, (x >= 2) & (x <= 3)),
 (0, True)),
Piecewise((x**2/2 - x + 1/2, (x >= 1) & (x <= 2)),
 (-x**2 + 5*x - 11/2, (x >= 2) & (x <= 3)),
 (x**2/2 - 4*x + 8, (x >= 3) & (x <= 4)),
 (0, True))] 
```

参见

[`bspline_basis`](#sympy.functions.special.bsplines.bspline_basis "sympy.functions.special.bsplines.bspline_basis")

```py
sympy.functions.special.bsplines.interpolating_spline(d, x, X, Y)
```

返回通过给定*X*和*Y*值的*d*度样条。

参数：

**d**：整数

> Bspline的度数严格大于等于一

**x**：符号

**X**：严格递增的实数值列表

> 通过样条通过的X坐标列表

**Y**：实数值列表

> 通过样条通过的对应Y坐标列表

说明

此函数返回一个分段函数，每个部分都是不大于 *d* 的多项式。*d* 的值必须大于或等于1，而 *X* 的值必须严格增加。

示例

```py
>>> from sympy import interpolating_spline
>>> from sympy.abc import x
>>> interpolating_spline(1, x, [1, 2, 4, 7], [3, 6, 5, 7])
Piecewise((3*x, (x >= 1) & (x <= 2)),
 (7 - x/2, (x >= 2) & (x <= 4)),
 (2*x/3 + 7/3, (x >= 4) & (x <= 7)))
>>> interpolating_spline(3, x, [-2, 0, 1, 3, 4], [4, 2, 1, 1, 3])
Piecewise((7*x**3/117 + 7*x**2/117 - 131*x/117 + 2, (x >= -2) & (x <= 1)),
 (10*x**3/117 - 2*x**2/117 - 122*x/117 + 77/39, (x >= 1) & (x <= 4))) 
```

另请参见

[`bspline_basis_set`](#sympy.functions.special.bsplines.bspline_basis_set "sympy.functions.special.bsplines.bspline_basis_set")，[`interpolating_poly`](../polys/reference.html#sympy.polys.specialpolys.interpolating_poly "sympy.polys.specialpolys.interpolating_poly")

## 黎曼 Zeta 函数及相关函数

```py
class sympy.functions.special.zeta_functions.zeta(s, a=None)
```

赫维茨 zeta 函数（或黎曼 zeta 函数）。

说明

对于 \(\operatorname{Re}(a) > 0\) 和 \(\operatorname{Re}(s) > 1\)，此函数定义为

\[\zeta(s, a) = \sum_{n=0}^\infty \frac{1}{(n + a)^s},\]

其中使用了 \(n + a\) 的标准参数选择。对于固定的 \(a\)，非正整数的赫维茨 zeta 函数在整个 \(\mathbb{C}\) 上都有亚纯延拓；它是一个无分支函数，在 \(s = 1\) 处有一个简单极点。

赫维茨 zeta 函数是勒让德超越函数的一个特例：

\[\zeta(s, a) = \Phi(1, s, a).\]

此公式为所有可能的 \(s\) 和 \(a\) 值（也包括 \(\operatorname{Re}(a) < 0\)）定义了解析延拓，请参阅 [`lerchphi`](#sympy.functions.special.zeta_functions.lerchphi "sympy.functions.special.zeta_functions.lerchphi") 的文档以了解分支行为的描述。

如果没有为 \(a\) 传递值，则假定默认值为 \(a = 1\)，从而得到黎曼 zeta 函数。

示例

对于 \(a = 1\)，赫维茨 zeta 函数简化为著名的黎曼 zeta 函数：

\[\zeta(s, 1) = \zeta(s) = \sum_{n=1}^\infty \frac{1}{n^s}.\]

```py
>>> from sympy import zeta
>>> from sympy.abc import s
>>> zeta(s, 1)
zeta(s)
>>> zeta(s)
zeta(s) 
```

黎曼 zeta 函数也可以用狄利克雷 eta 函数表示：

```py
>>> from sympy import dirichlet_eta
>>> zeta(s).rewrite(dirichlet_eta)
dirichlet_eta(s)/(1 - 2**(1 - s)) 
```

非负偶数和负整数值处的黎曼 zeta 函数与伯努利数和多项式相关：

```py
>>> zeta(2)
pi**2/6
>>> zeta(4)
pi**4/90
>>> zeta(0)
-1/2
>>> zeta(-1)
-1/12
>>> zeta(-4)
0 
```

特定公式如下：

\[\zeta(2n) = -\frac{(2\pi i)^{2n} B_{2n}}{2(2n)!}\]\[\zeta(-n,a) = -\frac{B_{n+1}(a)}{n+1}\]

正奇整数没有已知的闭式表达式，但可以进行数值评估：

```py
>>> zeta(3).n()
1.20205690315959 
```

可计算 \(\zeta(s, a)\) 关于 \(a\) 的导数：

```py
>>> from sympy.abc import a
>>> zeta(s, a).diff(a)
-s*zeta(s + 1, a) 
```

然而，对于 \(s\) 的导数没有有用的闭式表达式：

```py
>>> zeta(s, a).diff(s)
Derivative(zeta(s, a), s) 
```

赫维茨 zeta 函数可以用勒让德超越函数表达，[`lerchphi`](#sympy.functions.special.zeta_functions.lerchphi "sympy.functions.special.zeta_functions.lerchphi")：

```py
>>> from sympy import lerchphi
>>> zeta(s, a).rewrite(lerchphi)
lerchphi(1, s, a) 
```

另请参见

[`dirichlet_eta`](#sympy.functions.special.zeta_functions.dirichlet_eta "sympy.functions.special.zeta_functions.dirichlet_eta")，[`lerchphi`](#sympy.functions.special.zeta_functions.lerchphi "sympy.functions.special.zeta_functions.lerchphi")，[`polylog`](#sympy.functions.special.zeta_functions.polylog "sympy.functions.special.zeta_functions.polylog")

参考

[[R454](#id114)]

[https://dlmf.nist.gov/25.11](https://dlmf.nist.gov/25.11)

[[R455](#id115)]

[https://en.wikipedia.org/wiki/Hurwitz_zeta_function](https://en.wikipedia.org/wiki/Hurwitz_zeta_function)

```py
class sympy.functions.special.zeta_functions.dirichlet_eta(s, a=None)
```

狄利克雷eta函数。

解释

对于\(\operatorname{Re}(s) > 0\)和\(0 < x \le 1\)，此函数定义为

\[\eta(s, a) = \sum_{n=0}^\infty \frac{(-1)^n}{(n+a)^s}.\]

对于任意固定的\(a\)不是非正整数，它在\(\mathbb{C}\)中具有唯一的解析延拓。它是一个整体的，无分支的函数。

它可以用Hurwitz塞塔函数表示为

\[\eta(s, a) = \zeta(s,a) - 2^{1-s} \zeta\left(s, \frac{a+1}{2}\right)\]

并使用广义Genocchi函数表示为

\[\eta(s, a) = \frac{G(1-s, a)}{2(s-1)}.\]

在这两种情况下，当\(s = 1\)时使用的极限值为\(\log2 - \psi(a) + \psi\left(\frac{a+1}{2}\right)\)。

示例

```py
>>> from sympy import dirichlet_eta, zeta
>>> from sympy.abc import s
>>> dirichlet_eta(s).rewrite(zeta)
Piecewise((log(2), Eq(s, 1)), ((1 - 2**(1 - s))*zeta(s), True)) 
```

另请参阅

[`zeta`](#sympy.functions.special.zeta_functions.zeta "sympy.functions.special.zeta_functions.zeta")

参考文献

[[R456](#id116)]

[https://en.wikipedia.org/wiki/Dirichlet_eta_function](https://en.wikipedia.org/wiki/Dirichlet_eta_function)

[[R457](#id117)]

彼得·鲁施尼，“伯努利函数简介”，[https://arxiv.org/abs/2009.06743](https://arxiv.org/abs/2009.06743)

```py
class sympy.functions.special.zeta_functions.polylog(s, z)
```

多对数函数。

解释

对于\(|z| < 1\)和\(s \in \mathbb{C}\)，多对数函数定义为

\[\operatorname{Li}_s(z) = \sum_{n=1}^\infty \frac{z^n}{n^s},\]

对于\(n\)使用参数的标准分支。它允许解析延拓，分支点在\(z=1\)（显然不是在初始定义的表面上），\(z=0\)和\(z=\infty\)。

多对数的名称来源于当\(s=1\)时，多对数与普通对数相关（参见示例），并且

\[\operatorname{Li}_{s+1}(z) = \int_0^z \frac{\operatorname{Li}_s(t)}{t} \mathrm{d}t.\]

多对数函数是勒让函数的一个特例：

\[\operatorname{Li}_{s}(z) = z \Phi(z, s, 1).\]

示例

对于\(z \in \{0, 1, -1\}\)，多对数函数会自动用其他函数表达：

```py
>>> from sympy import polylog
>>> from sympy.abc import s
>>> polylog(s, 0)
0
>>> polylog(s, 1)
zeta(s)
>>> polylog(s, -1)
-dirichlet_eta(s) 
```

如果\(s\)是负整数，\(0\)或\(1\)，则多对数函数可以用初等函数表达。这可以通过`expand_func()`完成：

```py
>>> from sympy import expand_func
>>> from sympy.abc import z
>>> expand_func(polylog(1, z))
-log(1 - z)
>>> expand_func(polylog(0, z))
z/(1 - z) 
```

对\(z\)的导数可以通过封闭形式计算：

```py
>>> polylog(s, z).diff(z)
polylog(s - 1, z)/z 
```

多对数函数可以用勒让函数表示为：

```py
>>> from sympy import lerchphi
>>> polylog(s, z).rewrite(lerchphi)
z*lerchphi(z, s, 1) 
```

另请参阅

[`zeta`](#sympy.functions.special.zeta_functions.zeta "sympy.functions.special.zeta_functions.zeta"), [`lerchphi`](#sympy.functions.special.zeta_functions.lerchphi "sympy.functions.special.zeta_functions.lerchphi")

```py
class sympy.functions.special.zeta_functions.lerchphi(*args)
```

勒让函数（勒让phi函数）。

解释

对于\(\operatorname{Re}(a) > 0\)，\( |z| < 1 \)和\(s \in \mathbb{C}\)，勒让函数被定义为

\[\Phi(z, s, a) = \sum_{n=0}^\infty \frac{z^n}{(n + a)^s},\]

采用参数的标准分支对\(n + a\)进行使用，并通过解析延拓适用于其他参数值。

一个常用的相关函数是勒让塞塔函数，定义如下：

\[L(q, s, a) = \Phi(e^{2\pi i q}, s, a).\]

**解析延拓与分支行为**

可以证明

\[\Phi(z, s, a) = z\Phi(z, s, a+1) + a^{-s}.\]

这提供了对 \(\operatorname{Re}(a) \le 0\) 的解析延拓。

现在假设 \(\operatorname{Re}(a) > 0\)。积分表示

\[\Phi_0(z, s, a) = \int_0^\infty \frac{t^{s-1} e^{-at}}{1 - ze^{-t}} \frac{\mathrm{d}t}{\Gamma(s)}\]

提供了对 \(\mathbb{C} - [1, \infty)\) 的解析延拓。最后，对于 \(x \in (1, \infty)\)，我们找到

\[\lim_{\epsilon \to 0^+} \Phi_0(x + i\epsilon, s, a) -\lim_{\epsilon \to 0^+} \Phi_0(x - i\epsilon, s, a) = \frac{2\pi i \log^{s-1}{x}}{x^a \Gamma(s)},\]

使用 \(\log{x}\) 和 \(\log{\log{x}}\) 的标准分支（\(\log{\log{x}}\) 的分支需要用于计算 \(\log{x}^{s-1}\)）。这结束了解析延拓。因此，勒让德超越函数在 \(z \in \{0, 1, \infty\}\) 和 \(a \in \mathbb{Z}_{\le 0}\) 处分支。对于固定的 \(z, a\) 超出这些分支点，它是 \(s\) 的整个函数。

例子

勒让德超越函数是一个相当通用的函数，因此它不会自动计算为更简单的函数。使用 `expand_func()` 可以实现这一点。

如果 \(z=1\)，则勒让德超越函数简化为Hurwitz zeta函数：

```py
>>> from sympy import lerchphi, expand_func
>>> from sympy.abc import z, s, a
>>> expand_func(lerchphi(1, s, a))
zeta(s, a) 
```

更一般地，如果 \(z\) 是单位根，则勒让德超越函数简化为Hurwitz zeta函数之和：

```py
>>> expand_func(lerchphi(-1, s, a))
zeta(s, a/2)/2**s - zeta(s, a/2 + 1/2)/2**s 
```

如果 \(a=1\)，则勒让德超越函数简化为多对数函数：

```py
>>> expand_func(lerchphi(z, s, 1))
polylog(s, z)/z 
```

更一般地，如果 \(a\) 是有理数，勒让德超越函数简化为多对数函数之和：

```py
>>> from sympy import S
>>> expand_func(lerchphi(z, s, S(1)/2))
2**(s - 1)*(polylog(s, sqrt(z))/sqrt(z) -
 polylog(s, sqrt(z)*exp_polar(I*pi))/sqrt(z))
>>> expand_func(lerchphi(z, s, S(3)/2))
-2**s/z + 2**(s - 1)*(polylog(s, sqrt(z))/sqrt(z) -
 polylog(s, sqrt(z)*exp_polar(I*pi))/sqrt(z))/z 
```

关于 \(z\) 和 \(a\) 的导数可以通过闭合形式计算：

```py
>>> lerchphi(z, s, a).diff(z)
(-a*lerchphi(z, s, a) + lerchphi(z, s - 1, a))/z
>>> lerchphi(z, s, a).diff(a)
-s*lerchphi(z, s + 1, a) 
```

另请参见

[`polylog`](#sympy.functions.special.zeta_functions.polylog "sympy.functions.special.zeta_functions.polylog"), [`zeta`](#sympy.functions.special.zeta_functions.zeta "sympy.functions.special.zeta_functions.zeta")

参考文献

[[R458](#id118)]

Bateman, H.; Erdelyi, A. (1953), Higher Transcendental Functions, Vol. I, New York: McGraw-Hill. Section 1.11.

[[R459](#id119)]

[https://dlmf.nist.gov/25.14](https://dlmf.nist.gov/25.14)

[[R460](#id120)]

[https://en.wikipedia.org/wiki/Lerch_transcendent](https://en.wikipedia.org/wiki/Lerch_transcendent)

```py
class sympy.functions.special.zeta_functions.stieltjes(n, a=None)
```

代表黎曼ζ函数的Laurent级数展开中出现的斯蒂尔切斯常数，\(\gamma_{k}\)。

例子

```py
>>> from sympy import stieltjes
>>> from sympy.abc import n, m
>>> stieltjes(n)
stieltjes(n) 
```

第零斯蒂尔切斯常数：

```py
>>> stieltjes(0)
EulerGamma
>>> stieltjes(0, 1)
EulerGamma 
```

对于广义斯蒂尔切斯常数：

```py
>>> stieltjes(n, m)
stieltjes(n, m) 
```

常数仅对整数 >= 0 定义：

```py
>>> stieltjes(-1)
zoo 
```

参考文献

[[R461](#id121)]

[https://en.wikipedia.org/wiki/Stieltjes_constants](https://en.wikipedia.org/wiki/Stieltjes_constants)

## 超几何函数

```py
class sympy.functions.special.hyper.hyper(ap, bq, z)
```

广义超几何函数由一个级数定义，其中连续项的比值是求和指数的有理函数。当收敛时，它在解析地延拓到最大可能的域。

解释

超几何函数依赖于两个参数向量，称为分子参数 \(a_p\) 和分母参数 \(b_q\)。它还有一个参数 \(z\)。级数定义为

\[\begin{split}{}_pF_q\left(\begin{matrix} a_1, \cdots, a_p \\ b_1, \cdots, b_q \end{matrix} \middle| z \right) = \sum_{n=0}^\infty \frac{(a_1)_n \cdots (a_p)_n}{(b_1)_n \cdots (b_q)_n} \frac{z^n}{n!},\end{split}\]

这里 \((a)_n = (a)(a+1)\cdots(a+n-1)\) 表示升阶乘。

如果 \(b_q\) 中有一个是非正整数，则除非 \(a_p\) 中有一个更大（即绝对值更小）的非正整数，否则级数是未定义的。如果 \(b_q\) 中没有一个是非正整数，而 \(a_p\) 中有一个是非正整数，则级数化简为多项式。为简化以下讨论，我们假设 \(a_p\) 和 \(b_q\) 都不是非正整数。更多细节请参见参考文献。

如果 \(p \le q\)，则级数对所有 \(z\) 收敛，因此在这种情况下定义了一个整个单值函数。如果 \(p = q+1\)，则级数在 \(|z| < 1\) 收敛，并可以在半平面内解析地延拓。如果 \(p > q+1\)，则级数在所有 \(z\) 上发散。

请注意，超几何函数构造器目前*不*检查参数是否实际产生一个良定义的函数。

示例

参数 \(a_p\) 和 \(b_q\) 可以作为任意可迭代对象传递，例如：

```py
>>> from sympy import hyper
>>> from sympy.abc import x, n, a
>>> h = hyper((1, 2, 3), [3, 4], x); h
hyper((1, 2), (4,), x)
>>> hyper((3, 1, 2), [3, 4], x, evaluate=False)  # don't remove duplicates
hyper((1, 2, 3), (3, 4), x) 
```

还有漂亮的打印（使用 Unicode 看起来更好）：

```py
>>> from sympy import pprint
>>> pprint(h, use_unicode=False)
 _
 |_  /1, 2 |  \
 |   |     | x|
2  1 \  4  |  / 
```

参数必须始终是可迭代的，即使它们是长度为一或零的向量：

```py
>>> hyper((1, ), [], x)
hyper((1,), (), x) 
```

但当然它们可能是变量（但如果它们依赖于 \(x\)，那么不应期望有太多实现的功能）：

```py
>>> hyper((n, a), (n**2,), x)
hyper((a, n), (n**2,), x) 
```

超几何函数推广了许多命名特殊函数。函数 `hyperexpand()` 尝试使用命名特殊函数来表达超几何函数。例如：

```py
>>> from sympy import hyperexpand
>>> hyperexpand(hyper([], [], x))
exp(x) 
```

您也可以使用 `expand_func()`：

```py
>>> from sympy import expand_func
>>> expand_func(x*hyper([1, 1], [2], -x))
log(x + 1) 
```

更多例子：

```py
>>> from sympy import S
>>> hyperexpand(hyper([], [S(1)/2], -x**2/4))
cos(x)
>>> hyperexpand(x*hyper([S(1)/2, S(1)/2], [S(3)/2], x**2))
asin(x) 
```

有时我们也可以使用 `hyperexpand()` 参数化函数：

```py
>>> from sympy.abc import a
>>> hyperexpand(hyper([-a], [], x))
(1 - x)**a 
```

另见

[`sympy.simplify.hyperexpand`](../simplify/simplify.html#module-sympy.simplify.hyperexpand "sympy.simplify.hyperexpand"), [`gamma`](#sympy.functions.special.gamma_functions.gamma "sympy.functions.special.gamma_functions.gamma"), [`meijerg`](#sympy.functions.special.hyper.meijerg "sympy.functions.special.hyper.meijerg")

参考文献

[[R462](#id122)]

Luke, Y. L. (1969), The Special Functions and Their Approximations, Volume 1

[[R463](#id123)]

[广义超几何函数](https://zh.wikipedia.org/wiki/%E5%B9%BF%E4%B9%89%E8%B6%85%E5%87%A0%E4%BD%95%E5%87%BD%E6%95%B0)的收敛相关数量。

```py
property ap
```

超几何函数的分子参数。

```py
property argument
```

超几何函数的参数。

```py
property bq
```

超几何函数的分母参数。

```py
property convergence_statement
```

返回一个关于 \(z\) 的条件，使得级数收敛。

```py
property eta
```

与级数收敛性相关的数量。

```py
property radius_of_convergence
```

计算定义级数的收敛半径。

解释

请注意，即使这不是 `oo`，函数仍可以通过解析延拓在收敛半径之外进行评估。但如果这是零，那么函数实际上在任何其他地方都未定义。

示例

```py
>>> from sympy import hyper
>>> from sympy.abc import z
>>> hyper((1, 2), [3], z).radius_of_convergence
1
>>> hyper((1, 2, 3), [4], z).radius_of_convergence
0
>>> hyper((1, 2), (3, 4), z).radius_of_convergence
oo 
```

```py
class sympy.functions.special.hyper.meijerg(*args)
```

Meijer G 函数由类似逆 Mellin 变换的 Mellin-Barnes 类型积分定义。它推广了超几何函数。

解释

Meijer G 函数依赖于四组参数。有“*分子参数*” \(a_1, \ldots, a_n\) 和 \(a_{n+1}, \ldots, a_p\)，以及“*分母参数*” \(b_1, \ldots, b_m\) 和 \(b_{m+1}, \ldots, b_q\)。令人困惑的是，传统上它被表示如下（注意 \(m\)、\(n\)、\(p\)、\(q\) 的位置及它们与四个参数向量的长度的关系）：

\[\begin{split}G_{p,q}^{m,n} \left(\begin{matrix}a_1, \cdots, a_n & a_{n+1}, \cdots, a_p \\ b_1, \cdots, b_m & b_{m+1}, \cdots, b_q \end{matrix} \middle| z \right).\end{split}\]

然而，在 SymPy 中，四个参数向量始终可以单独使用（参见示例），因此无需跟踪 G 符号上的装饰式和上标。

G 函数被定义为以下积分：

\[\frac{1}{2 \pi i} \int_L \frac{\prod_{j=1}^m \Gamma(b_j - s) \prod_{j=1}^n \Gamma(1 - a_j + s)}{\prod_{j=m+1}^q \Gamma(1- b_j +s) \prod_{j=n+1}^p \Gamma(a_j - s)} z^s \mathrm{d}s,\]

这里 \(\Gamma(z)\) 是 gamma 函数。有三种可能的轮廓我们不在此详细描述（参见参考文献）。如果积分沿着其中多于一条路径收敛，则定义是一致的。所有轮廓都将 \(\Gamma(1-a_j+s)\) 的极点与 \(\Gamma(b_k-s)\) 的极点分开，因此特别地，如果对于某些 \(j \le n\) 和 \(k \le m\)，\(a_j - b_k \in \mathbb{Z}_{>0}\)，则 G 函数是未定义的。

一个轮廓产生收敛积分的条件非常复杂，我们不在此声明，请参见参考文献。

请注意，目前 Meijer G 函数构造器 *不* 检查任何收敛条件。

例子

您可以将参数作为四个单独的向量传递：

```py
>>> from sympy import meijerg, Tuple, pprint
>>> from sympy.abc import x, a
>>> pprint(meijerg((1, 2), (a, 4), (5,), [], x), use_unicode=False)
 __1, 2 /1, 2  4, a |  \
/__     |           | x|
\_|4, 1 \ 5         |  / 
```

或者作为两个嵌套向量：

```py
>>> pprint(meijerg([(1, 2), (3, 4)], ([5], Tuple()), x), use_unicode=False)
 __1, 2 /1, 2  3, 4 |  \
/__     |           | x|
\_|4, 1 \ 5         |  / 
```

与超几何函数类似，参数可以作为任意可迭代对象传递。长度为零和一的向量也必须作为可迭代对象传递。参数不必是常数，但如果它们依赖于参数，则不应期望实现太多功能。

所有参数的子向量都可用：

```py
>>> from sympy import pprint
>>> g = meijerg([1], [2], [3], [4], x)
>>> pprint(g, use_unicode=False)
 __1, 1 /1  2 |  \
/__     |     | x|
\_|2, 2 \3  4 |  /
>>> g.an
(1,)
>>> g.ap
(1, 2)
>>> g.aother
(2,)
>>> g.bm
(3,)
>>> g.bq
(3, 4)
>>> g.bother
(4,) 
```

Meijer G 函数推广了超几何函数。在某些情况下，它可以用超几何函数的术语表示，使用 Slater 定理。例如：

```py
>>> from sympy import hyperexpand
>>> from sympy.abc import a, b, c
>>> hyperexpand(meijerg([a], [], [c], [b], x), allow_hyper=True)
x**c*gamma(-a + c + 1)*hyper((-a + c + 1,),
 (-b + c + 1,), -x)/gamma(-b + c + 1) 
```

因此，Meijer G 函数也包含许多命名函数作为特殊情况。您可以使用 `expand_func()` 或 `hyperexpand()` 来（尝试）将 Meijer G 函数重写为命名特殊函数。例如：

```py
>>> from sympy import expand_func, S
>>> expand_func(meijerg([[],[]], [[0],[]], -x))
exp(x)
>>> hyperexpand(meijerg([[],[]], [[S(1)/2],[0]], (x/2)**2))
sin(x)/sqrt(pi) 
```

另请参见

[`hyper`](#sympy.functions.special.hyper.hyper "sympy.functions.special.hyper.hyper"), [`sympy.simplify.hyperexpand`](../simplify/simplify.html#module-sympy.simplify.hyperexpand "sympy.simplify.hyperexpand")

参考文献

[[R464](#id124)]

Luke, Y. L. (1969), The Special Functions and Their Approximations, Volume 1

[[R465](#id125)]

[https://en.wikipedia.org/wiki/Meijer_G-function](https://en.wikipedia.org/wiki/Meijer_G-function)

```py
property an
```

第一组分子参数。

```py
property aother
```

第二组分子参数。

```py
property ap
```

组合的分子参数。

```py
property argument
```

Meijer G-函数的参数。

```py
property bm
```

第一组分母参数。

```py
property bother
```

第二组分母参数。

```py
property bq
```

组合的分母参数。

```py
property delta
```

与积分的收敛区域相关的量，请参见参考文献。

```py
get_period()
```

返回一个数 \(P\)，使得 \(G(x*exp(I*P)) == G(x)\)。

例子

```py
>>> from sympy import meijerg, pi, S
>>> from sympy.abc import z 
```

```py
>>> meijerg([1], [], [], [], z).get_period()
2*pi
>>> meijerg([pi], [], [], [], z).get_period()
oo
>>> meijerg([1, 2], [], [], [], z).get_period()
oo
>>> meijerg([1,1], [2], [1, S(1)/2, S(1)/3], [1], z).get_period()
12*pi 
```

```py
integrand(s)
```

获取定义的被积函数 D(s)。

```py
property is_number
```

如果表达式仅包含数值数据，则返回 true。

```py
property nu
```

与积分的收敛区域相关的量，请参见参考文献。

```py
class sympy.functions.special.hyper.appellf1(a, b1, b2, c, x, y)
```

这是两个变量的 Appell 超几何函数，如下：

\[F_1(a,b_1,b_2,c,x,y) = \sum_{m=0}^{\infty} \sum_{n=0}^{\infty} \frac{(a)_{m+n} (b_1)_m (b_2)_n}{(c)_{m+n}} \frac{x^m y^n}{m! n!}.\]

例子

```py
>>> from sympy import appellf1, symbols
>>> x, y, a, b1, b2, c = symbols('x y a b1 b2 c')
>>> appellf1(2., 1., 6., 4., 5., 6.)
0.0063339426292673
>>> appellf1(12., 12., 6., 4., 0.5, 0.12)
172870711.659936
>>> appellf1(40, 2, 6, 4, 15, 60)
appellf1(40, 2, 6, 4, 15, 60)
>>> appellf1(20., 12., 10., 3., 0.5, 0.12)
15605338197184.4
>>> appellf1(40, 2, 6, 4, x, y)
appellf1(40, 2, 6, 4, x, y)
>>> appellf1(a, b1, b2, c, x, y)
appellf1(a, b1, b2, c, x, y) 
```

参考文献

[[R466](#id126)]

[https://en.wikipedia.org/wiki/Appell_series](https://en.wikipedia.org/wiki/Appell_series)

[[R467](#id127)]

[https://functions.wolfram.com/HypergeometricFunctions/AppellF1/](https://functions.wolfram.com/HypergeometricFunctions/AppellF1/)

## 椭圆积分

```py
class sympy.functions.special.elliptic_integrals.elliptic_k(m)
```

第一类完全椭圆积分由以下定义

\[K(m) = F\left(\tfrac{\pi}{2}\middle| m\right)\]

其中 \(F\left(z\middle| m\right)\) 是第一类勒让德不完全椭圆积分。

解释

函数 \(K(m)\) 在复平面上是单值函数，其分支切割沿着区间 \((1, \infty)\)。

注意，我们的符号学定义中用参数 \(m\) 而不是椭圆模数（偏心率） \(k\) 来定义不完全椭圆积分。在这种情况下，参数 \(m\) 被定义为 \(m=k^2\)。

例子

```py
>>> from sympy import elliptic_k, I
>>> from sympy.abc import m
>>> elliptic_k(0)
pi/2
>>> elliptic_k(1.0 + I)
1.50923695405127 + 0.625146415202697*I
>>> elliptic_k(m).series(n=3)
pi/2 + pi*m/8 + 9*pi*m**2/128 + O(m**3) 
```

参见

[`elliptic_f`](#sympy.functions.special.elliptic_integrals.elliptic_f "sympy.functions.special.elliptic_integrals.elliptic_f")

参考文献

[[R468](#id128)]

[https://en.wikipedia.org/wiki/Elliptic_integrals](https://en.wikipedia.org/wiki/Elliptic_integrals)

[[R469](#id129)]

[https://functions.wolfram.com/EllipticIntegrals/EllipticK](https://functions.wolfram.com/EllipticIntegrals/EllipticK)

```py
class sympy.functions.special.elliptic_integrals.elliptic_f(z, m)
```

第一类勒让德不完全椭圆积分，由以下定义

\[F\left(z\middle| m\right) = \int_0^z \frac{dt}{\sqrt{1 - m \sin^2 t}}\]

解释

当 \(z = \pi/2\) 时，此函数简化为第一类完全椭圆积分 \(K(m)\)。

注意，我们的符号学定义中用参数 \(m\) 而不是椭圆模数（偏心率） \(k\) 来定义不完全椭圆积分。在这种情况下，参数 \(m\) 被定义为 \(m=k^2\)。

例子

```py
>>> from sympy import elliptic_f, I
>>> from sympy.abc import z, m
>>> elliptic_f(z, m).series(z)
z + z**5*(3*m**2/40 - m/30) + m*z**3/6 + O(z**6)
>>> elliptic_f(3.0 + I/2, 1.0 + I)
2.909449841483 + 1.74720545502474*I 
```

参见

[`elliptic_k`](#sympy.functions.special.elliptic_integrals.elliptic_k "sympy.functions.special.elliptic_integrals.elliptic_k")

参考文献

[[R470](#id130)]

[https://en.wikipedia.org/wiki/Elliptic_integrals](https://en.wikipedia.org/wiki/Elliptic_integrals)

[[R471](#id131)]

[https://functions.wolfram.com/EllipticIntegrals/EllipticF](https://functions.wolfram.com/EllipticIntegrals/EllipticF)

```py
class sympy.functions.special.elliptic_integrals.elliptic_e(m, z=None)
```

以两个参数\(z\) 和\(m\) 调用，评估由下式定义的第二类不完全椭圆积分：

\[E\left(z\middle| m\right) = \int_0^z \sqrt{1 - m \sin^2 t} dt\]

以单个参数\(m\) 调用，评估第二类Legendre完全椭圆积分。

\[E(m) = E\left(\tfrac{\pi}{2}\middle| m\right)\]

解释

函数\(E(m)\) 是复平面上的单值函数，其分支沿着区间\((1, \infty)\)。

注意，我们的符号表示中将不完全椭圆积分定义为参数\(m\)，而非椭圆模（偏心率）\(k\)。在此情况下，参数\(m\) 定义为\(m=k^2\)。

示例

```py
>>> from sympy import elliptic_e, I
>>> from sympy.abc import z, m
>>> elliptic_e(z, m).series(z)
z + z**5*(-m**2/40 + m/30) - m*z**3/6 + O(z**6)
>>> elliptic_e(m).series(n=4)
pi/2 - pi*m/8 - 3*pi*m**2/128 - 5*pi*m**3/512 + O(m**4)
>>> elliptic_e(1 + I, 2 - I/2).n()
1.55203744279187 + 0.290764986058437*I
>>> elliptic_e(0)
pi/2
>>> elliptic_e(2.0 - I)
0.991052601328069 + 0.81879421395609*I 
```

参考文献

[[R472](#id132)]

[https://en.wikipedia.org/wiki/Elliptic_integrals](https://en.wikipedia.org/wiki/Elliptic_integrals)

[[R473](#id133)]

[https://functions.wolfram.com/EllipticIntegrals/EllipticE2](https://functions.wolfram.com/EllipticIntegrals/EllipticE2)

[[R474](#id134)]

[https://functions.wolfram.com/EllipticIntegrals/EllipticE](https://functions.wolfram.com/EllipticIntegrals/EllipticE)

```py
class sympy.functions.special.elliptic_integrals.elliptic_pi(n, m, z=None)
```

以三个参数\(n\)、\(z\) 和\(m\) 调用，评估由下式定义的Legendre不完全椭圆积分：

\[\Pi\left(n; z\middle| m\right) = \int_0^z \frac{dt} {\left(1 - n \sin^2 t\right) \sqrt{1 - m \sin^2 t}}\]

以两个参数\(n\) 和\(m\) 调用，评估第三类完全椭圆积分：

\[\Pi\left(n\middle| m\right) = \Pi\left(n; \tfrac{\pi}{2}\middle| m\right)\]

解释

注意，我们的符号表示中将不完全椭圆积分定义为参数\(m\)，而非椭圆模（偏心率）\(k\)。在此情况下，参数\(m\) 定义为\(m=k^2\)。

示例

```py
>>> from sympy import elliptic_pi, I
>>> from sympy.abc import z, n, m
>>> elliptic_pi(n, z, m).series(z, n=4)
z + z**3*(m/6 + n/3) + O(z**4)
>>> elliptic_pi(0.5 + I, 1.0 - I, 1.2)
2.50232379629182 - 0.760939574180767*I
>>> elliptic_pi(0, 0)
pi/2
>>> elliptic_pi(1.0 - I/3, 2.0 + I)
3.29136443417283 + 0.32555634906645*I 
```

参考文献

[[R475](#id135)]

[https://en.wikipedia.org/wiki/Elliptic_integrals](https://en.wikipedia.org/wiki/Elliptic_integrals)

[[R476](#id136)]

[https://functions.wolfram.com/EllipticIntegrals/EllipticPi3](https://functions.wolfram.com/EllipticIntegrals/EllipticPi3)

[[R477](#id137)]

[https://functions.wolfram.com/EllipticIntegrals/EllipticPi](https://functions.wolfram.com/EllipticIntegrals/EllipticPi)  ## Mathieu函数

```py
class sympy.functions.special.mathieu_functions.MathieuBase(*args)
```

Mathieu函数的抽象基类。

此类旨在减少代码重复。

```py
class sympy.functions.special.mathieu_functions.mathieus(a, q, z)
```

Mathieu正弦函数\(S(a,q,z)\)。

解释

此函数是Mathieu微分方程的一个解：

\[y(x)^{\prime\prime} + (a - 2 q \cos(2 x)) y(x) = 0\]

另一个解是Mathieu余弦函数。

示例

```py
>>> from sympy import diff, mathieus
>>> from sympy.abc import a, q, z 
```

```py
>>> mathieus(a, q, z)
mathieus(a, q, z) 
```

```py
>>> mathieus(a, 0, z)
sin(sqrt(a)*z) 
```

```py
>>> diff(mathieus(a, q, z), z)
mathieusprime(a, q, z) 
```

另请参阅

[`mathieuc`](#sympy.functions.special.mathieu_functions.mathieuc "sympy.functions.special.mathieu_functions.mathieuc")

Mathieu余弦函数。

[`mathieusprime`](#sympy.functions.special.mathieu_functions.mathieusprime "sympy.functions.special.mathieu_functions.mathieusprime")

Mathieu正弦函数的导数。

[`mathieucprime`](#sympy.functions.special.mathieu_functions.mathieucprime "sympy.functions.special.mathieu_functions.mathieucprime")

Mathieu余弦函数的导数。

参考文献

[[R478](#id138)]

[https://en.wikipedia.org/wiki/Mathieu_function](https://en.wikipedia.org/wiki/Mathieu_function)

[[R479](#id139)]

[https://dlmf.nist.gov/28](https://dlmf.nist.gov/28)

[[R480](#id140)]

[https://mathworld.wolfram.com/MathieuFunction.html](https://mathworld.wolfram.com/MathieuFunction.html)

[[R481](#id141)]

[https://functions.wolfram.com/MathieuandSpheroidalFunctions/MathieuS/](https://functions.wolfram.com/MathieuandSpheroidalFunctions/MathieuS/)

```py
class sympy.functions.special.mathieu_functions.mathieuc(a, q, z)
```

Mathieu余弦函数 \(C(a,q,z)\)。

解释

这个函数是Mathieu微分方程的一个解：

\[y(x)^{\prime\prime} + (a - 2 q \cos(2 x)) y(x) = 0\]

另一个解是Mathieu正弦函数。

示例

```py
>>> from sympy import diff, mathieuc
>>> from sympy.abc import a, q, z 
```

```py
>>> mathieuc(a, q, z)
mathieuc(a, q, z) 
```

```py
>>> mathieuc(a, 0, z)
cos(sqrt(a)*z) 
```

```py
>>> diff(mathieuc(a, q, z), z)
mathieucprime(a, q, z) 
```

另请参阅

[`mathieus`](#sympy.functions.special.mathieu_functions.mathieus "sympy.functions.special.mathieu_functions.mathieus")

Mathieu正弦函数

[`mathieusprime`](#sympy.functions.special.mathieu_functions.mathieusprime "sympy.functions.special.mathieu_functions.mathieusprime")

Mathieu正弦函数的导数

[`mathieucprime`](#sympy.functions.special.mathieu_functions.mathieucprime "sympy.functions.special.mathieu_functions.mathieucprime")

Mathieu余弦函数的导数

参考文献

[[R482](#id142)]

[https://en.wikipedia.org/wiki/Mathieu_function](https://en.wikipedia.org/wiki/Mathieu_function)

[[R483](#id143)]

[https://dlmf.nist.gov/28](https://dlmf.nist.gov/28)

[[R484](#id144)]

[https://mathworld.wolfram.com/MathieuFunction.html](https://mathworld.wolfram.com/MathieuFunction.html)

[[R485](#id145)]

[https://functions.wolfram.com/MathieuandSpheroidalFunctions/MathieuC/](https://functions.wolfram.com/MathieuandSpheroidalFunctions/MathieuC/)

```py
class sympy.functions.special.mathieu_functions.mathieusprime(a, q, z)
```

Mathieu正弦函数的导数\(S^{\prime}(a,q,z)\)。

解释

这个函数是Mathieu微分方程的一个解：

\[y(x)^{\prime\prime} + (a - 2 q \cos(2 x)) y(x) = 0\]

另一个解是Mathieu余弦函数。

示例

```py
>>> from sympy import diff, mathieusprime
>>> from sympy.abc import a, q, z 
```

```py
>>> mathieusprime(a, q, z)
mathieusprime(a, q, z) 
```

```py
>>> mathieusprime(a, 0, z)
sqrt(a)*cos(sqrt(a)*z) 
```

```py
>>> diff(mathieusprime(a, q, z), z)
(-a + 2*q*cos(2*z))*mathieus(a, q, z) 
```

另请参阅

[`mathieus`](#sympy.functions.special.mathieu_functions.mathieus "sympy.functions.special.mathieu_functions.mathieus")

Mathieu正弦函数

[`mathieuc`](#sympy.functions.special.mathieu_functions.mathieuc "sympy.functions.special.mathieu_functions.mathieuc")

Mathieu余弦函数

[`mathieucprime`](#sympy.functions.special.mathieu_functions.mathieucprime "sympy.functions.special.mathieu_functions.mathieucprime")

Mathieu余弦函数的导数

参考文献

[[R486](#id146)]

[https://en.wikipedia.org/wiki/Mathieu_function](https://en.wikipedia.org/wiki/Mathieu_function)

[[R487](#id147)]

[https://dlmf.nist.gov/28](https://dlmf.nist.gov/28)

[[R488](#id148)]

[https://mathworld.wolfram.com/MathieuFunction.html](https://mathworld.wolfram.com/MathieuFunction.html)

[[R489](#id149)]

[https://functions.wolfram.com/MathieuandSpheroidalFunctions/MathieuSPrime/](https://functions.wolfram.com/MathieuandSpheroidalFunctions/MathieuSPrime/)

```py
class sympy.functions.special.mathieu_functions.mathieucprime(a, q, z)
```

马修余弦函数的导数 \(C^{\prime}(a,q,z)\)。

解释

该函数是马修微分方程的一个解：

\[y(x)^{\prime\prime} + (a - 2 q \cos(2 x)) y(x) = 0\]

另一个解是马修正弦函数。

示例

```py
>>> from sympy import diff, mathieucprime
>>> from sympy.abc import a, q, z 
```

```py
>>> mathieucprime(a, q, z)
mathieucprime(a, q, z) 
```

```py
>>> mathieucprime(a, 0, z)
-sqrt(a)*sin(sqrt(a)*z) 
```

```py
>>> diff(mathieucprime(a, q, z), z)
(-a + 2*q*cos(2*z))*mathieuc(a, q, z) 
```

另请参见

[`mathieus`](#sympy.functions.special.mathieu_functions.mathieus "sympy.functions.special.mathieu_functions.mathieus")

马修正弦函数

[`mathieuc`](#sympy.functions.special.mathieu_functions.mathieuc "sympy.functions.special.mathieu_functions.mathieuc")

马修余弦函数

[`mathieusprime`](#sympy.functions.special.mathieu_functions.mathieusprime "sympy.functions.special.mathieu_functions.mathieusprime")

马修正弦函数的导数

参考文献

[[R490](#id150)]

[https://en.wikipedia.org/wiki/Mathieu_function](https://en.wikipedia.org/wiki/Mathieu_function)

[[R491](#id151)]

[https://dlmf.nist.gov/28](https://dlmf.nist.gov/28)

[[R492](#id152)]

[https://mathworld.wolfram.com/MathieuFunction.html](https://mathworld.wolfram.com/MathieuFunction.html)

[[R493](#id153)]

[https://functions.wolfram.com/MathieuandSpheroidalFunctions/MathieuCPrime/](https://functions.wolfram.com/MathieuandSpheroidalFunctions/MathieuCPrime/)  ## 正交多项式

该模块主要实现特殊正交多项式。

另请参见包含一些组合多项式的函数.combinatorial.numbers。

### 雅各比多项式

```py
class sympy.functions.special.polynomials.jacobi(n, a, b, x)
```

雅各比多项式 \(P_n^{\left(\alpha, \beta\right)}(x)\)。

解释

`jacobi(n, alpha, beta, x)` 给出 \(x\) 中的第 \(n\) 个雅各比多项式，\(P_n^{\left(\alpha, \beta\right)}(x)\)。

雅各比多项式在 \([-1, 1]\) 上相对于权重 \(\left(1-x\right)^\alpha \left(1+x\right)^\beta\) 正交。

示例

```py
>>> from sympy import jacobi, S, conjugate, diff
>>> from sympy.abc import a, b, n, x 
```

```py
>>> jacobi(0, a, b, x)
1
>>> jacobi(1, a, b, x)
a/2 - b/2 + x*(a/2 + b/2 + 1)
>>> jacobi(2, a, b, x)
a**2/8 - a*b/4 - a/8 + b**2/8 - b/8 + x**2*(a**2/8 + a*b/4 + 7*a/8 + b**2/8 + 7*b/8 + 3/2) + x*(a**2/4 + 3*a/4 - b**2/4 - 3*b/4) - 1/2 
```

```py
>>> jacobi(n, a, b, x)
jacobi(n, a, b, x) 
```

```py
>>> jacobi(n, a, a, x)
RisingFactorial(a + 1, n)*gegenbauer(n,
 a + 1/2, x)/RisingFactorial(2*a + 1, n) 
```

```py
>>> jacobi(n, 0, 0, x)
legendre(n, x) 
```

```py
>>> jacobi(n, S(1)/2, S(1)/2, x)
RisingFactorial(3/2, n)*chebyshevu(n, x)/factorial(n + 1) 
```

```py
>>> jacobi(n, -S(1)/2, -S(1)/2, x)
RisingFactorial(1/2, n)*chebyshevt(n, x)/factorial(n) 
```

```py
>>> jacobi(n, a, b, -x)
(-1)**n*jacobi(n, b, a, x) 
```

```py
>>> jacobi(n, a, b, 0)
gamma(a + n + 1)*hyper((-n, -b - n), (a + 1,), -1)/(2**n*factorial(n)*gamma(a + 1))
>>> jacobi(n, a, b, 1)
RisingFactorial(a + 1, n)/factorial(n) 
```

```py
>>> conjugate(jacobi(n, a, b, x))
jacobi(n, conjugate(a), conjugate(b), conjugate(x)) 
```

```py
>>> diff(jacobi(n,a,b,x), x)
(a/2 + b/2 + n/2 + 1/2)*jacobi(n - 1, a + 1, b + 1, x) 
```

另请参见

[`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

参考文献

[[R494](#id154)]

[https://en.wikipedia.org/wiki/Jacobi_polynomials](https://en.wikipedia.org/wiki/Jacobi_polynomials)

[[R495](#id155)]

[https://mathworld.wolfram.com/JacobiPolynomial.html](https://mathworld.wolfram.com/JacobiPolynomial.html)

[[R496](#id156)]

[https://functions.wolfram.com/Polynomials/JacobiP/](https://functions.wolfram.com/Polynomials/JacobiP/)

```py
sympy.functions.special.polynomials.jacobi_normalized(n, a, b, x)
```

Jacobi 多项式 \(P_n^{\left(\alpha, \beta\right)}(x)\).

参数:

**n** : 多项式的整数次数

**a** : alpha 值

**b** : beta 值

**x** : 符号

说明

`jacobi_normalized(n, alpha, beta, x)` 给出在 \(x\) 上的第 \(n\) 个 Jacobi 多项式，\(P_n^{\left(\alpha, \beta\right)}(x)\).

Jacobi 多项式在 \([-1, 1]\) 区间上是关于权重 \(\left(1-x\right)^\alpha \left(1+x\right)^\beta\) 正交的。

该函数返回归一化的多项式：

\[\int_{-1}^{1} P_m^{\left(\alpha, \beta\right)}(x) P_n^{\left(\alpha, \beta\right)}(x) (1-x)^{\alpha} (1+x)^{\beta} \mathrm{d}x = \delta_{m,n}\]

示例

```py
>>> from sympy import jacobi_normalized
>>> from sympy.abc import n,a,b,x 
```

```py
>>> jacobi_normalized(n, a, b, x)
jacobi(n, a, b, x)/sqrt(2**(a + b + 1)*gamma(a + n + 1)*gamma(b + n + 1)/((a + b + 2*n + 1)*factorial(n)*gamma(a + b + n + 1))) 
```

另请参见

[`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

参考文献

[[R497](#id157)]

[https://en.wikipedia.org/wiki/Jacobi_polynomials](https://en.wikipedia.org/wiki/Jacobi_polynomials)

[[R498](#id158)]

[https://mathworld.wolfram.com/JacobiPolynomial.html](https://mathworld.wolfram.com/JacobiPolynomial.html)

[[R499](#id159)]

[https://functions.wolfram.com/Polynomials/JacobiP/](https://functions.wolfram.com/Polynomials/JacobiP/)

### Gegenbauer 多项式

```py
class sympy.functions.special.polynomials.gegenbauer(n, a, x)
```

Gegenbauer 多项式 \(C_n^{\left(\alpha\right)}(x)\)。

解释

`gegenbauer(n, alpha, x)` 给出\(x\)中的第\(n\)个 Gegenbauer 多项式，\(C_n^{\left(\alpha\right)}(x)\)。

根据权重 \(\left(1-x^2\right)^{\alpha-\frac{1}{2}}\) 在区间 \([-1, 1]\) 上与 Gegenbauer 多项式正交。

举例

```py
>>> from sympy import gegenbauer, conjugate, diff
>>> from sympy.abc import n,a,x
>>> gegenbauer(0, a, x)
1
>>> gegenbauer(1, a, x)
2*a*x
>>> gegenbauer(2, a, x)
-a + x**2*(2*a**2 + 2*a)
>>> gegenbauer(3, a, x)
x**3*(4*a**3/3 + 4*a**2 + 8*a/3) + x*(-2*a**2 - 2*a) 
```

```py
>>> gegenbauer(n, a, x)
gegenbauer(n, a, x)
>>> gegenbauer(n, a, -x)
(-1)**n*gegenbauer(n, a, x) 
```

```py
>>> gegenbauer(n, a, 0)
2**n*sqrt(pi)*gamma(a + n/2)/(gamma(a)*gamma(1/2 - n/2)*gamma(n + 1))
>>> gegenbauer(n, a, 1)
gamma(2*a + n)/(gamma(2*a)*gamma(n + 1)) 
```

```py
>>> conjugate(gegenbauer(n, a, x))
gegenbauer(n, conjugate(a), conjugate(x)) 
```

```py
>>> diff(gegenbauer(n, a, x), x)
2*a*gegenbauer(n - 1, a + 1, x) 
```

亦参见

[`jacobi`](#sympy.functions.special.polynomials.jacobi "sympy.functions.special.polynomials.jacobi"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

参考文献

[[R500](#id160)]

[https://en.wikipedia.org/wiki/Gegenbauer_polynomials](https://en.wikipedia.org/wiki/Gegenbauer_polynomials)

[[R501](#id161)]

[https://mathworld.wolfram.com/GegenbauerPolynomial.html](https://mathworld.wolfram.com/GegenbauerPolynomial.html)

[[R502](#id162)]

[https://functions.wolfram.com/Polynomials/GegenbauerC3/](https://functions.wolfram.com/Polynomials/GegenbauerC3/)

### 切比雪夫多项式

```py
class sympy.functions.special.polynomials.chebyshevt(n, x)
```

第一类切比雪夫多项式，\(T_n(x)\)。

解释

`chebyshevt(n, x)` 在\(x\)处给出第\(n\)个切比雪夫多项式（第一类），记为\(T_n(x)\)。

第一类切比雪夫多项式在\([-1, 1]\)上相对于权重\(\frac{1}{\sqrt{1-x^2}}\)是正交的。

示例

```py
>>> from sympy import chebyshevt, diff
>>> from sympy.abc import n,x
>>> chebyshevt(0, x)
1
>>> chebyshevt(1, x)
x
>>> chebyshevt(2, x)
2*x**2 - 1 
```

```py
>>> chebyshevt(n, x)
chebyshevt(n, x)
>>> chebyshevt(n, -x)
(-1)**n*chebyshevt(n, x)
>>> chebyshevt(-n, x)
chebyshevt(n, x) 
```

```py
>>> chebyshevt(n, 0)
cos(pi*n/2)
>>> chebyshevt(n, -1)
(-1)**n 
```

```py
>>> diff(chebyshevt(n, x), x)
n*chebyshevu(n - 1, x) 
```

另见

[`jacobi`](#sympy.functions.special.polynomials.jacobi "sympy.functions.special.polynomials.jacobi"), [`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

参考文献

[[R503](#id163)]

[https://en.wikipedia.org/wiki/Chebyshev_polynomial](https://en.wikipedia.org/wiki/Chebyshev_polynomial)的[切比雪夫多项式](https://en.wikipedia.org/wiki/Chebyshev_polynomial)

[[R504](#id164)]

[https://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html](https://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html)

[[R505](#id165)]

[https://mathworld.wolfram.com/ChebyshevPolynomialoftheSecondKind.html](https://mathworld.wolfram.com/ChebyshevPolynomialoftheSecondKind.html)

[[R506](#id166)]

[https://functions.wolfram.com/Polynomials/ChebyshevT/](https://functions.wolfram.com/Polynomials/ChebyshevT/)

[[R507](#id167)]

[https://functions.wolfram.com/Polynomials/ChebyshevU/](https://functions.wolfram.com/Polynomials/ChebyshevU/)

```py
class sympy.functions.special.polynomials.chebyshevu(n, x)
```

第二类切比雪夫多项式，\(U_n(x)\)。

解释

`chebyshevu(n, x)` 给出\(n\)阶第二类切比雪夫多项式在\(x\)处的值，记作\(U_n(x)\)。

第二类切比雪夫多项式在\([-1, 1]\)上以权重\(\sqrt{1-x^2}\)正交。

示例

```py
>>> from sympy import chebyshevu, diff
>>> from sympy.abc import n,x
>>> chebyshevu(0, x)
1
>>> chebyshevu(1, x)
2*x
>>> chebyshevu(2, x)
4*x**2 - 1 
```

```py
>>> chebyshevu(n, x)
chebyshevu(n, x)
>>> chebyshevu(n, -x)
(-1)**n*chebyshevu(n, x)
>>> chebyshevu(-n, x)
-chebyshevu(n - 2, x) 
```

```py
>>> chebyshevu(n, 0)
cos(pi*n/2)
>>> chebyshevu(n, 1)
n + 1 
```

```py
>>> diff(chebyshevu(n, x), x)
(-x*chebyshevu(n, x) + (n + 1)*chebyshevt(n + 1, x))/(x**2 - 1) 
```

另见

[`jacobi`](#sympy.functions.special.polynomials.jacobi "sympy.functions.special.polynomials.jacobi"), [`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt`](#sympy.functions.special.polynomials.chebyshevt "sympy.functions.special.polynomials.chebyshevt"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

References

[[R508](#id168)]

[https://en.wikipedia.org/wiki/Chebyshev_polynomial](https://en.wikipedia.org/wiki/Chebyshev_polynomial)  

[[R509](#id169)]

[https://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html](https://mathworld.wolfram.com/ChebyshevPolynomialoftheFirstKind.html)  

[[R510](#id170)]

[https://mathworld.wolfram.com/ChebyshevPolynomialoftheSecondKind.html](https://mathworld.wolfram.com/ChebyshevPolynomialoftheSecondKind.html)

[[R511](#id171)]

[https://functions.wolfram.com/Polynomials/ChebyshevT/](https://functions.wolfram.com/Polynomials/ChebyshevT/)

[[R512](#id172)]

[https://functions.wolfram.com/Polynomials/ChebyshevU/](https://functions.wolfram.com/Polynomials/ChebyshevU/)

```py
class sympy.functions.special.polynomials.chebyshevt_root(n, k)
```

`chebyshev_root(n, k)` 返回第一类Chebyshev多项式的第\(n\)个Chebyshev多项式的第\(k\)个根（从零开始索引）；即，如果\(0 \le k < n\)，则 `chebyshevt(n, chebyshevt_root(n, k)) == 0`。

示例

```py
>>> from sympy import chebyshevt, chebyshevt_root
>>> chebyshevt_root(3, 2)
-sqrt(3)/2
>>> chebyshevt(3, chebyshevt_root(3, 2))
0 
```

另请参见

[`jacobi`](#sympy.functions.special.polynomials.jacobi "sympy.functions.special.polynomials.jacobi"), [`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt`](#sympy.functions.special.polynomials.chebyshevt "sympy.functions.special.polynomials.chebyshevt"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

```py
class sympy.functions.special.polynomials.chebyshevu_root(n, k)
```

`chebyshevu_root(n, k)` 返回第 \(n\) 个第二类Chebyshev多项式的第 \(k\) 个根（从零开始索引）；即，如果 \(0 \le k < n\)，则 `chebyshevu(n, chebyshevu_root(n, k)) == 0`。

示例

```py
>>> from sympy import chebyshevu, chebyshevu_root
>>> chebyshevu_root(3, 2)
-sqrt(2)/2
>>> chebyshevu(3, chebyshevu_root(3, 2))
0 
```

参见

[`chebyshevt`](#sympy.functions.special.polynomials.chebyshevt "sympy.functions.special.polynomials.chebyshevt"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

### Legendre多项式

```py
class sympy.functions.special.polynomials.legendre(n, x)
```

`legendre(n, x)` 给出 \(x\) 的第 \(n\) 个Legendre多项式，\(P_n(x)\)

说明

Legendre多项式在\([-1, 1]\)上相对于常数权重 1 是正交的。它们满足 \(P_n(1) = 1\) 对于所有 \(n\)；此外，对于奇数 \(n\)，\(P_n\) 是奇函数，对于偶数 \(n\)，\(P_n\) 是偶函数。

示例

```py
>>> from sympy import legendre, diff
>>> from sympy.abc import x, n
>>> legendre(0, x)
1
>>> legendre(1, x)
x
>>> legendre(2, x)
3*x**2/2 - 1/2
>>> legendre(n, x)
legendre(n, x)
>>> diff(legendre(n,x), x)
n*(x*legendre(n, x) - legendre(n - 1, x))/(x**2 - 1) 
```

参见

[`jacobi`](#sympy.functions.special.polynomials.jacobi "sympy.functions.special.polynomials.jacobi"), [`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt`](#sympy.functions.special.polynomials.chebyshevt "sympy.functions.special.polynomials.chebyshevt"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

References

[[R513](#id173)]

[https://en.wikipedia.org/wiki/Legendre_polynomial](https://en.wikipedia.org/wiki/Legendre_polynomial)

[[R514](#id174)]

[https://mathworld.wolfram.com/LegendrePolynomial.html](https://mathworld.wolfram.com/LegendrePolynomial.html)

[[R515](#id175)]

[https://functions.wolfram.com/Polynomials/LegendreP/](https://functions.wolfram.com/Polynomials/LegendreP/)

[[R516](#id176)]

[https://functions.wolfram.com/Polynomials/LegendreP2/](https://functions.wolfram.com/Polynomials/LegendreP2/)

```py
class sympy.functions.special.polynomials.assoc_legendre(n, m, x)
```

`assoc_legendre(n, m, x)` 给出\(P_n^m(x)\)，其中\(n\)和\(m\)分别是次数和顺序或与n阶Legendre多项式\(P_n(x)\)相关的表达式方式：

\[P_n^m(x) = (-1)^m (1 - x^2)^{\frac{m}{2}} \frac{\mathrm{d}^m P_n(x)}{\mathrm{d} x^m}\]

解释

相关的Legendre多项式在\([-1, 1]\)上正交，具有：

+   对于相同的\(m\)和不同的\(n\)，权重\(= 1\)。

+   对于相同的\(n\)和不同的\(m\)，权重\(= \frac{1}{1-x^2}\)。

示例

```py
>>> from sympy import assoc_legendre
>>> from sympy.abc import x, m, n
>>> assoc_legendre(0,0, x)
1
>>> assoc_legendre(1,0, x)
x
>>> assoc_legendre(1,1, x)
-sqrt(1 - x**2)
>>> assoc_legendre(n,m,x)
assoc_legendre(n, m, x) 
```

另请参阅

[`jacobi`](#sympy.functions.special.polynomials.jacobi "sympy.functions.special.polynomials.jacobi"), [`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt`](#sympy.functions.special.polynomials.chebyshevt "sympy.functions.special.polynomials.chebyshevt"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

参考

[[R517](#id177)]

[https://en.wikipedia.org/wiki/Associated_Legendre_polynomials](https://en.wikipedia.org/wiki/Associated_Legendre_polynomials)

[[R518](#id178)]

[https://mathworld.wolfram.com/LegendrePolynomial.html](https://mathworld.wolfram.com/LegendrePolynomial.html)

[[R519](#id179)]

[https://functions.wolfram.com/Polynomials/LegendreP/](https://functions.wolfram.com/Polynomials/LegendreP/)

[[R520](#id180)]

[https://functions.wolfram.com/Polynomials/LegendreP2/](https://functions.wolfram.com/Polynomials/LegendreP2/)

### 厄米多项式

```py
class sympy.functions.special.polynomials.hermite(n, x)
```

`hermite(n, x)`给出\(x\)中的第\(n\)个厄米多项式，\(H_n(x)\)。

解释

厄米特多项式在\((-\infty, \infty)\)上相对于权重\(\exp\left(-x^2\right)\)正交。

例子

```py
>>> from sympy import hermite, diff
>>> from sympy.abc import x, n
>>> hermite(0, x)
1
>>> hermite(1, x)
2*x
>>> hermite(2, x)
4*x**2 - 2
>>> hermite(n, x)
hermite(n, x)
>>> diff(hermite(n,x), x)
2*n*hermite(n - 1, x)
>>> hermite(n, -x)
(-1)**n*hermite(n, x) 
```

参见

[`jacobi`](#sympy.functions.special.polynomials.jacobi "sympy.functions.special.polynomials.jacobi"), [`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt`](#sympy.functions.special.polynomials.chebyshevt "sympy.functions.special.polynomials.chebyshevt"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

参考文献

[[R521](#id181)]

[https://en.wikipedia.org/wiki/Hermite_polynomial](https://en.wikipedia.org/wiki/Hermite_polynomial)

[[R522](#id182)]

[https://mathworld.wolfram.com/HermitePolynomial.html](https://mathworld.wolfram.com/HermitePolynomial.html)

[[R523](#id183)]

[https://functions.wolfram.com/Polynomials/HermiteH/](https://functions.wolfram.com/Polynomials/HermiteH/)

```py
class sympy.functions.special.polynomials.hermite_prob(n, x)
```

`hermite_prob(n, x)` 给出第 \(n\) 个概率厄米多项式 \(He_n(x)\)。

解释

概率学家的 Hermite 多项式在 \((-\infty, \infty)\) 范围内，相对于权重 \(\exp\left(-\frac{x^2}{2}\right)\) 是正交的。它们是首一多项式，与普通 Hermite 多项式 ([`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite")) 相关。

\[He_n(x) = 2^{-n/2} H_n(x/\sqrt{2})\]

例子

```py
>>> from sympy import hermite_prob, diff, I
>>> from sympy.abc import x, n
>>> hermite_prob(1, x)
x
>>> hermite_prob(5, x)
x**5 - 10*x**3 + 15*x
>>> diff(hermite_prob(n,x), x)
n*hermite_prob(n - 1, x)
>>> hermite_prob(n, -x)
(-1)**n*hermite_prob(n, x) 
```

\(He_n(x)\)的系数绝对值之和等于完全图 \(K_n\) 或电话号码中的匹配数，OEIS中的 A000085：

```py
>>> [hermite_prob(n,I) / I**n for n in range(11)]
[1, 1, 2, 4, 10, 26, 76, 232, 764, 2620, 9496] 
```

另请参阅

[`jacobi`](#sympy.functions.special.polynomials.jacobi "sympy.functions.special.polynomials.jacobi"), [`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt`](#sympy.functions.special.polynomials.chebyshevt "sympy.functions.special.polynomials.chebyshevt"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

参考文献

[[R524](#id184)]

[https://en.wikipedia.org/wiki/Hermite_polynomial](https://en.wikipedia.org/wiki/Hermite_polynomial)

[[R525](#id185)]

[https://mathworld.wolfram.com/HermitePolynomial.html](https://mathworld.wolfram.com/HermitePolynomial.html)

### 拉盖尔多项式

```py
class sympy.functions.special.polynomials.laguerre(n, x)
```

返回在\(x\)中的第\(n\)个拉盖尔多项式，\(L_n(x)\)。

参数：

**n** : 整数

> 拉盖尔多项式的次数。必须满足\(n \ge 0\)。

示例

```py
>>> from sympy import laguerre, diff
>>> from sympy.abc import x, n
>>> laguerre(0, x)
1
>>> laguerre(1, x)
1 - x
>>> laguerre(2, x)
x**2/2 - 2*x + 1
>>> laguerre(3, x)
-x**3/6 + 3*x**2/2 - 3*x + 1 
```

```py
>>> laguerre(n, x)
laguerre(n, x) 
```

```py
>>> diff(laguerre(n, x), x)
-assoc_laguerre(n - 1, 1, x) 
```

另见

[`jacobi`](#sympy.functions.special.polynomials.jacobi "sympy.functions.special.polynomials.jacobi"), [`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt`](#sympy.functions.special.polynomials.chebyshevt "sympy.functions.special.polynomials.chebyshevt"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`assoc_laguerre`](#sympy.functions.special.polynomials.assoc_laguerre "sympy.functions.special.polynomials.assoc_laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

参考资料

[[R526](#id186)]

[https://en.wikipedia.org/wiki/Laguerre_polynomial](https://en.wikipedia.org/wiki/Laguerre_polynomial)

[[R527](#id187)]

[https://mathworld.wolfram.com/LaguerrePolynomial.html](https://mathworld.wolfram.com/LaguerrePolynomial.html)

[[R528](#id188)]

[https://functions.wolfram.com/Polynomials/LaguerreL/](https://functions.wolfram.com/Polynomials/LaguerreL/)

[[R529](#id189)]

[https://functions.wolfram.com/Polynomials/LaguerreL3/](https://functions.wolfram.com/Polynomials/LaguerreL3/)

```py
class sympy.functions.special.polynomials.assoc_laguerre(n, alpha, x)
```

返回\(x\)中第\(n\)个广义Laguerre多项式，\(L_n(x)\)。

参数：

**n** : int

> Laguerre多项式的次数。必须满足\(n \ge 0\)。

**alpha** : Expr

> 任意表达式。对于`alpha=0`，将生成常规的Laguerre多项式。

示例

```py
>>> from sympy import assoc_laguerre, diff
>>> from sympy.abc import x, n, a
>>> assoc_laguerre(0, a, x)
1
>>> assoc_laguerre(1, a, x)
a - x + 1
>>> assoc_laguerre(2, a, x)
a**2/2 + 3*a/2 + x**2/2 + x*(-a - 2) + 1
>>> assoc_laguerre(3, a, x)
a**3/6 + a**2 + 11*a/6 - x**3/6 + x**2*(a/2 + 3/2) +
 x*(-a**2/2 - 5*a/2 - 3) + 1 
```

```py
>>> assoc_laguerre(n, a, 0)
binomial(a + n, a) 
```

```py
>>> assoc_laguerre(n, a, x)
assoc_laguerre(n, a, x) 
```

```py
>>> assoc_laguerre(n, 0, x)
laguerre(n, x) 
```

```py
>>> diff(assoc_laguerre(n, a, x), x)
-assoc_laguerre(n - 1, a + 1, x) 
```

```py
>>> diff(assoc_laguerre(n, a, x), a)
Sum(assoc_laguerre(_k, a, x)/(-a + n), (_k, 0, n - 1)) 
```

另见

[`jacobi`](#sympy.functions.special.polynomials.jacobi "sympy.functions.special.polynomials.jacobi"), [`gegenbauer`](#sympy.functions.special.polynomials.gegenbauer "sympy.functions.special.polynomials.gegenbauer"), [`chebyshevt`](#sympy.functions.special.polynomials.chebyshevt "sympy.functions.special.polynomials.chebyshevt"), [`chebyshevt_root`](#sympy.functions.special.polynomials.chebyshevt_root "sympy.functions.special.polynomials.chebyshevt_root"), [`chebyshevu`](#sympy.functions.special.polynomials.chebyshevu "sympy.functions.special.polynomials.chebyshevu"), [`chebyshevu_root`](#sympy.functions.special.polynomials.chebyshevu_root "sympy.functions.special.polynomials.chebyshevu_root"), [`legendre`](#sympy.functions.special.polynomials.legendre "sympy.functions.special.polynomials.legendre"), [`assoc_legendre`](#sympy.functions.special.polynomials.assoc_legendre "sympy.functions.special.polynomials.assoc_legendre"), [`hermite`](#sympy.functions.special.polynomials.hermite "sympy.functions.special.polynomials.hermite"), [`hermite_prob`](#sympy.functions.special.polynomials.hermite_prob "sympy.functions.special.polynomials.hermite_prob"), [`laguerre`](#sympy.functions.special.polynomials.laguerre "sympy.functions.special.polynomials.laguerre"), [`sympy.polys.orthopolys.jacobi_poly`](../polys/reference.html#sympy.polys.orthopolys.jacobi_poly "sympy.polys.orthopolys.jacobi_poly"), [`sympy.polys.orthopolys.gegenbauer_poly`](../polys/reference.html#sympy.polys.orthopolys.gegenbauer_poly "sympy.polys.orthopolys.gegenbauer_poly"), [`sympy.polys.orthopolys.chebyshevt_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevt_poly "sympy.polys.orthopolys.chebyshevt_poly"), [`sympy.polys.orthopolys.chebyshevu_poly`](../polys/reference.html#sympy.polys.orthopolys.chebyshevu_poly "sympy.polys.orthopolys.chebyshevu_poly"), [`sympy.polys.orthopolys.hermite_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_poly "sympy.polys.orthopolys.hermite_poly"), [`sympy.polys.orthopolys.hermite_prob_poly`](../polys/reference.html#sympy.polys.orthopolys.hermite_prob_poly "sympy.polys.orthopolys.hermite_prob_poly"), [`sympy.polys.orthopolys.legendre_poly`](../polys/reference.html#sympy.polys.orthopolys.legendre_poly "sympy.polys.orthopolys.legendre_poly"), [`sympy.polys.orthopolys.laguerre_poly`](../polys/reference.html#sympy.polys.orthopolys.laguerre_poly "sympy.polys.orthopolys.laguerre_poly")

参考文献

[[R530](#id190)]

[https://en.wikipedia.org/wiki/Laguerre_polynomial#Generalized_Laguerre_polynomials](https://en.wikipedia.org/wiki/Laguerre_polynomial#Generalized_Laguerre_polynomials)

[[R531](#id191)]

[https://mathworld.wolfram.com/AssociatedLaguerrePolynomial.html](https://mathworld.wolfram.com/AssociatedLaguerrePolynomial.html)

[[R532](#id192)]

[https://functions.wolfram.com/Polynomials/LaguerreL/](https://functions.wolfram.com/Polynomials/LaguerreL/)

[[R533](#id193)]

[https://functions.wolfram.com/Polynomials/LaguerreL3/](https://functions.wolfram.com/Polynomials/LaguerreL3/)

## 球谐函数

```py
class sympy.functions.special.spherical_harmonics.Ynm(n, m, theta, phi)
```

定义为球谐函数

\[Y_n^m(\theta, \varphi) := \sqrt{\frac{(2n+1)(n-m)!}{4\pi(n+m)!}} \exp(i m \varphi) \mathrm{P}_n^m\left(\cos(\theta)\right)\]

解释

`Ynm()` 给出在球坐标 \(\theta\) 和 \(\varphi\) 中的阶数为 \(n\) 和 \(m\) 的球谐函数，\(Y_n^m(\theta, \varphi)\)。这四个参数如下：\(n \geq 0\) 是整数，\(m\) 是整数满足 \(-n \leq m \leq n\)。这两个角度是实数，\(\theta \in [0, \pi]\)，\(\varphi \in [0, 2\pi]\)。

例子

```py
>>> from sympy import Ynm, Symbol, simplify
>>> from sympy.abc import n,m
>>> theta = Symbol("theta")
>>> phi = Symbol("phi") 
```

```py
>>> Ynm(n, m, theta, phi)
Ynm(n, m, theta, phi) 
```

已知有多种对称性，例如：

```py
>>> Ynm(n, -m, theta, phi)
(-1)**m*exp(-2*I*m*phi)*Ynm(n, m, theta, phi) 
```

同样适用于角度：

```py
>>> Ynm(n, m, -theta, phi)
Ynm(n, m, theta, phi) 
```

```py
>>> Ynm(n, m, theta, -phi)
exp(-2*I*m*phi)*Ynm(n, m, theta, phi) 
```

对于特定的整数 \(n\) 和 \(m\)，我们可以评估谐波到更有用的表达式：

```py
>>> simplify(Ynm(0, 0, theta, phi).expand(func=True))
1/(2*sqrt(pi)) 
```

```py
>>> simplify(Ynm(1, -1, theta, phi).expand(func=True))
sqrt(6)*exp(-I*phi)*sin(theta)/(4*sqrt(pi)) 
```

```py
>>> simplify(Ynm(1, 0, theta, phi).expand(func=True))
sqrt(3)*cos(theta)/(2*sqrt(pi)) 
```

```py
>>> simplify(Ynm(1, 1, theta, phi).expand(func=True))
-sqrt(6)*exp(I*phi)*sin(theta)/(4*sqrt(pi)) 
```

```py
>>> simplify(Ynm(2, -2, theta, phi).expand(func=True))
sqrt(30)*exp(-2*I*phi)*sin(theta)**2/(8*sqrt(pi)) 
```

```py
>>> simplify(Ynm(2, -1, theta, phi).expand(func=True))
sqrt(30)*exp(-I*phi)*sin(2*theta)/(8*sqrt(pi)) 
```

```py
>>> simplify(Ynm(2, 0, theta, phi).expand(func=True))
sqrt(5)*(3*cos(theta)**2 - 1)/(4*sqrt(pi)) 
```

```py
>>> simplify(Ynm(2, 1, theta, phi).expand(func=True))
-sqrt(30)*exp(I*phi)*sin(2*theta)/(8*sqrt(pi)) 
```

```py
>>> simplify(Ynm(2, 2, theta, phi).expand(func=True))
sqrt(30)*exp(2*I*phi)*sin(theta)**2/(8*sqrt(pi)) 
```

我们可以分别对两个角度进行函数的微分：

```py
>>> from sympy import Ynm, Symbol, diff
>>> from sympy.abc import n,m
>>> theta = Symbol("theta")
>>> phi = Symbol("phi") 
```

```py
>>> diff(Ynm(n, m, theta, phi), theta)
m*cot(theta)*Ynm(n, m, theta, phi) + sqrt((-m + n)*(m + n + 1))*exp(-I*phi)*Ynm(n, m + 1, theta, phi) 
```

```py
>>> diff(Ynm(n, m, theta, phi), phi)
I*m*Ynm(n, m, theta, phi) 
```

进一步，我们可以计算复共轭：

```py
>>> from sympy import Ynm, Symbol, conjugate
>>> from sympy.abc import n,m
>>> theta = Symbol("theta")
>>> phi = Symbol("phi") 
```

```py
>>> conjugate(Ynm(n, m, theta, phi))
(-1)**(2*m)*exp(-2*I*m*phi)*Ynm(n, m, theta, phi) 
```

为了恢复球坐标中的著名表达式，我们使用全面展开：

```py
>>> from sympy import Ynm, Symbol, expand_func
>>> from sympy.abc import n,m
>>> theta = Symbol("theta")
>>> phi = Symbol("phi") 
```

```py
>>> expand_func(Ynm(n, m, theta, phi))
sqrt((2*n + 1)*factorial(-m + n)/factorial(m + n))*exp(I*m*phi)*assoc_legendre(n, m, cos(theta))/(2*sqrt(pi)) 
```

参见也

[`Ynm_c`](#sympy.functions.special.spherical_harmonics.Ynm_c "sympy.functions.special.spherical_harmonics.Ynm_c"), [`Znm`](#sympy.functions.special.spherical_harmonics.Znm "sympy.functions.special.spherical_harmonics.Znm")

References

[[R534](#id194)]

[https://en.wikipedia.org/wiki/Spherical_harmonics](https://en.wikipedia.org/wiki/Spherical_harmonics)

[[R535](#id195)]

[https://mathworld.wolfram.com/SphericalHarmonic.html](https://mathworld.wolfram.com/SphericalHarmonic.html)

[[R536](#id196)]

[https://functions.wolfram.com/Polynomials/SphericalHarmonicY/](https://functions.wolfram.com/Polynomials/SphericalHarmonicY/)

[[R537](#id197)]

[https://dlmf.nist.gov/14.30](https://dlmf.nist.gov/14.30)

```py
sympy.functions.special.spherical_harmonics.Ynm_c(n, m, theta, phi)
```

共轭球谐函数定义为

\[\overline{Y_n^m(\theta, \varphi)} := (-1)^m Y_n^{-m}(\theta, \varphi).\]

例子

```py
>>> from sympy import Ynm_c, Symbol, simplify
>>> from sympy.abc import n,m
>>> theta = Symbol("theta")
>>> phi = Symbol("phi")
>>> Ynm_c(n, m, theta, phi)
(-1)**(2*m)*exp(-2*I*m*phi)*Ynm(n, m, theta, phi)
>>> Ynm_c(n, m, -theta, phi)
(-1)**(2*m)*exp(-2*I*m*phi)*Ynm(n, m, theta, phi) 
```

对于特定的整数 \(n\) 和 \(m\)，我们可以评估谐波到更有用的表达式：

```py
>>> simplify(Ynm_c(0, 0, theta, phi).expand(func=True))
1/(2*sqrt(pi))
>>> simplify(Ynm_c(1, -1, theta, phi).expand(func=True))
sqrt(6)*exp(I*(-phi + 2*conjugate(phi)))*sin(theta)/(4*sqrt(pi)) 
```

参见也

[`Ynm`](#sympy.functions.special.spherical_harmonics.Ynm "sympy.functions.special.spherical_harmonics.Ynm"), [`Znm`](#sympy.functions.special.spherical_harmonics.Znm "sympy.functions.special.spherical_harmonics.Znm")

参考

[[R538](#id198)]

[https://en.wikipedia.org/wiki/Spherical_harmonics](https://en.wikipedia.org/wiki/Spherical_harmonics)

[[R539](#id199)]

[https://mathworld.wolfram.com/SphericalHarmonic.html](https://mathworld.wolfram.com/SphericalHarmonic.html)

[[R540](#id200)]

[https://functions.wolfram.com/Polynomials/SphericalHarmonicY/](https://functions.wolfram.com/Polynomials/SphericalHarmonicY/)

```py
class sympy.functions.special.spherical_harmonics.Znm(n, m, theta, phi)
```

定义为实球谐函数

\[\begin{split}Z_n^m(\theta, \varphi) := \begin{cases} \frac{Y_n^m(\theta, \varphi) + \overline{Y_n^m(\theta, \varphi)}}{\sqrt{2}} &\quad m > 0 \\ Y_n^m(\theta, \varphi) &\quad m = 0 \\ \frac{Y_n^m(\theta, \varphi) - \overline{Y_n^m(\theta, \varphi)}}{i \sqrt{2}} &\quad m < 0 \\ \end{cases}\end{split}\]

这在简化形式中给出

\[\begin{split}Z_n^m(\theta, \varphi) = \begin{cases} \frac{Y_n^m(\theta, \varphi) + (-1)^m Y_n^{-m}(\theta, \varphi)}{\sqrt{2}} &\quad m > 0 \\ Y_n^m(\theta, \varphi) &\quad m = 0 \\ \frac{Y_n^m(\theta, \varphi) - (-1)^m Y_n^{-m}(\theta, \varphi)}{i \sqrt{2}} &\quad m < 0 \\ \end{cases}\end{split}\]

示例

```py
>>> from sympy import Znm, Symbol, simplify
>>> from sympy.abc import n, m
>>> theta = Symbol("theta")
>>> phi = Symbol("phi")
>>> Znm(n, m, theta, phi)
Znm(n, m, theta, phi) 
```

对于特定的整数 \(n\) 和 \(m\)，我们可以评估谐波以获得更有用的表达式：

```py
>>> simplify(Znm(0, 0, theta, phi).expand(func=True))
1/(2*sqrt(pi))
>>> simplify(Znm(1, 1, theta, phi).expand(func=True))
-sqrt(3)*sin(theta)*cos(phi)/(2*sqrt(pi))
>>> simplify(Znm(2, 1, theta, phi).expand(func=True))
-sqrt(15)*sin(2*theta)*cos(phi)/(4*sqrt(pi)) 
```

参见

[`Ynm`](#sympy.functions.special.spherical_harmonics.Ynm "sympy.functions.special.spherical_harmonics.Ynm"), [`Ynm_c`](#sympy.functions.special.spherical_harmonics.Ynm_c "sympy.functions.special.spherical_harmonics.Ynm_c")

参考文献

[[R541](#id201)]

[球谐函数](https://en.wikipedia.org/wiki/Spherical_harmonics)

[[R542](#id202)]

[球谐函数](https://mathworld.wolfram.com/SphericalHarmonic.html)

[[R543](#id203)]

[球谐函数 Y](https://functions.wolfram.com/Polynomials/SphericalHarmonicY/)

## 张量函数

```py
sympy.functions.special.tensor_functions.Eijk(*args, **kwargs)
```

表示利维-奇维塔符号。

这是对 `LeviCivita()` 的兼容性包装。

参见

[`LeviCivita`](#sympy.functions.special.tensor_functions.LeviCivita "sympy.functions.special.tensor_functions.LeviCivita")

```py
sympy.functions.special.tensor_functions.eval_levicivita(*args)
```

评估利维-奇维塔符号。

```py
class sympy.functions.special.tensor_functions.LeviCivita(*args)
```

表示利维-奇维塔符号。

解释

对于指标的偶排列返回 1，对于奇排列返回 -1，对于其他情况（重复指标）返回 0。

因此它表示一个交替的伪张量。

示例

```py
>>> from sympy import LeviCivita
>>> from sympy.abc import i, j, k
>>> LeviCivita(1, 2, 3)
1
>>> LeviCivita(1, 3, 2)
-1
>>> LeviCivita(1, 2, 2)
0
>>> LeviCivita(i, j, k)
LeviCivita(i, j, k)
>>> LeviCivita(i, j, i)
0 
```

参见

[`Eijk`](#sympy.functions.special.tensor_functions.Eijk "sympy.functions.special.tensor_functions.Eijk")

```py
class sympy.functions.special.tensor_functions.KroneckerDelta(i, j, delta_range=None)
```

离散或克罗内克 δ 函数。

参数：

**i** : 数字，符号

> δ 函数的第一个指标。

**j** : 数字，符号

> δ 函数的第二个指标。

解释

一个接受两个整数 \(i\) 和 \(j\) 的函数。如果 \(i\) 和 \(j\) 不相等则返回 \(0\)，如果相等则返回 \(1\)。

示例

带有整数指标的例子：

```py
>>> from sympy import KroneckerDelta
>>> KroneckerDelta(1, 2)
0
>>> KroneckerDelta(3, 3)
1 
```

符号指标：

```py
>>> from sympy.abc import i, j, k
>>> KroneckerDelta(i, j)
KroneckerDelta(i, j)
>>> KroneckerDelta(i, i)
1
>>> KroneckerDelta(i, i + 1)
0
>>> KroneckerDelta(i, i + 1 + k)
KroneckerDelta(i, i + k + 1) 
```

参见

[`eval`](#sympy.functions.special.tensor_functions.KroneckerDelta.eval "sympy.functions.special.tensor_functions.KroneckerDelta.eval"), [`DiracDelta`](#sympy.functions.special.delta_functions.DiracDelta "sympy.functions.special.delta_functions.DiracDelta")

参考文献

[[R544](#id204)]

[克罗内克 δ 函数](https://en.wikipedia.org/wiki/Kronecker_delta)

```py
classmethod eval(i, j, delta_range=None)
```

评估离散 δ 函数。

示例

```py
>>> from sympy import KroneckerDelta
>>> from sympy.abc import i, j, k 
```

```py
>>> KroneckerDelta(i, j)
KroneckerDelta(i, j)
>>> KroneckerDelta(i, i)
1
>>> KroneckerDelta(i, i + 1)
0
>>> KroneckerDelta(i, i + 1 + k)
KroneckerDelta(i, i + k + 1) 
```

# 间接 doctest

```py
property indices_contain_equal_information
```

如果指标都在费米面上方或下方则返回 True。

示例

```py
>>> from sympy import KroneckerDelta, Symbol
>>> a = Symbol('a', above_fermi=True)
>>> i = Symbol('i', below_fermi=True)
>>> p = Symbol('p')
>>> q = Symbol('q')
>>> KroneckerDelta(p, q).indices_contain_equal_information
True
>>> KroneckerDelta(p, q+1).indices_contain_equal_information
True
>>> KroneckerDelta(i, p).indices_contain_equal_information
False 
```

```py
property is_above_fermi
```

若 Delta 在费米面上方可以非零。

示例

```py
>>> from sympy import KroneckerDelta, Symbol
>>> a = Symbol('a', above_fermi=True)
>>> i = Symbol('i', below_fermi=True)
>>> p = Symbol('p')
>>> q = Symbol('q')
>>> KroneckerDelta(p, a).is_above_fermi
True
>>> KroneckerDelta(p, i).is_above_fermi
False
>>> KroneckerDelta(p, q).is_above_fermi
True 
```

参见

[`is_below_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_below_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_below_fermi"), [`is_only_below_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_only_below_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_only_below_fermi"), [`is_only_above_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_only_above_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_only_above_fermi")

```py
property is_below_fermi
```

如果 Delta 可以在费米能级以下非零，则为真。

示例

```py
>>> from sympy import KroneckerDelta, Symbol
>>> a = Symbol('a', above_fermi=True)
>>> i = Symbol('i', below_fermi=True)
>>> p = Symbol('p')
>>> q = Symbol('q')
>>> KroneckerDelta(p, a).is_below_fermi
False
>>> KroneckerDelta(p, i).is_below_fermi
True
>>> KroneckerDelta(p, q).is_below_fermi
True 
```

另请参阅

[`is_above_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_above_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_above_fermi"), [`is_only_above_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_only_above_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_only_above_fermi"), [`is_only_below_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_only_below_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_only_below_fermi")

```py
property is_only_above_fermi
```

如果 Delta 受到费米能级以上的限制，则为真。

示例

```py
>>> from sympy import KroneckerDelta, Symbol
>>> a = Symbol('a', above_fermi=True)
>>> i = Symbol('i', below_fermi=True)
>>> p = Symbol('p')
>>> q = Symbol('q')
>>> KroneckerDelta(p, a).is_only_above_fermi
True
>>> KroneckerDelta(p, q).is_only_above_fermi
False
>>> KroneckerDelta(p, i).is_only_above_fermi
False 
```

另请参阅

[`is_above_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_above_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_above_fermi"), [`is_below_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_below_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_below_fermi"), [`is_only_below_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_only_below_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_only_below_fermi")

```py
property is_only_below_fermi
```

如果 Delta 受到费米能级以下的限制，则为真。

示例

```py
>>> from sympy import KroneckerDelta, Symbol
>>> a = Symbol('a', above_fermi=True)
>>> i = Symbol('i', below_fermi=True)
>>> p = Symbol('p')
>>> q = Symbol('q')
>>> KroneckerDelta(p, i).is_only_below_fermi
True
>>> KroneckerDelta(p, q).is_only_below_fermi
False
>>> KroneckerDelta(p, a).is_only_below_fermi
False 
```

另请参阅

[`is_above_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_above_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_above_fermi"), [`is_below_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_below_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_below_fermi"), [`is_only_above_fermi`](#sympy.functions.special.tensor_functions.KroneckerDelta.is_only_above_fermi "sympy.functions.special.tensor_functions.KroneckerDelta.is_only_above_fermi")

```py
property killable_index
```

返回在最终表达式中优先替换的索引。

解释

要替换的索引是具有关于费米能级更少信息的索引。如果索引包含相同信息，则“a”优先于“b”。

示例

```py
>>> from sympy import KroneckerDelta, Symbol
>>> a = Symbol('a', above_fermi=True)
>>> i = Symbol('i', below_fermi=True)
>>> j = Symbol('j', below_fermi=True)
>>> p = Symbol('p')
>>> KroneckerDelta(p, i).killable_index
p
>>> KroneckerDelta(p, a).killable_index
p
>>> KroneckerDelta(i, j).killable_index
j 
```

另请参阅

[`preferred_index`](#sympy.functions.special.tensor_functions.KroneckerDelta.preferred_index "sympy.functions.special.tensor_functions.KroneckerDelta.preferred_index")

```py
property preferred_index
```

返回在最终表达式中保留的优先索引。

解释

首选索引是具有关于费米能级更多信息的索引。如果索引包含相同信息，则“a”优先于“b”。

示例

```py
>>> from sympy import KroneckerDelta, Symbol
>>> a = Symbol('a', above_fermi=True)
>>> i = Symbol('i', below_fermi=True)
>>> j = Symbol('j', below_fermi=True)
>>> p = Symbol('p')
>>> KroneckerDelta(p, i).preferred_index
i
>>> KroneckerDelta(p, a).preferred_index
a
>>> KroneckerDelta(i, j).preferred_index
i 
```

另请参阅

[`killable_index`](#sympy.functions.special.tensor_functions.KroneckerDelta.killable_index "sympy.functions.special.tensor_functions.KroneckerDelta.killable_index")
