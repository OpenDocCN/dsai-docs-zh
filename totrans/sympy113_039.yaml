- en: Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践
- en: 原文：[https://docs.sympy.org/latest/explanation/best-practices.html](https://docs.sympy.org/latest/explanation/best-practices.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/explanation/best-practices.html](https://docs.sympy.org/latest/explanation/best-practices.html)
- en: This page outlines some of the best practices for users of SymPy. The best practices
    here will help avoid some common bugs and pitfalls that can occur when using SymPy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本页面概述了使用 SymPy 的一些最佳实践。这些最佳实践将有助于避免使用 SymPy 时可能出现的一些常见错误和陷阱。
- en: This page primarily focuses on best practices that apply generally to all parts
    of SymPy. Best practices that are specific to certain SymPy submodules or functions
    are outlined in the documentation for those specific functions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本页面主要关注适用于 SymPy 所有部分的一些最佳实践。适用于特定 SymPy 子模块或函数的最佳实践在这些特定函数的文档中进行了概述。
- en: Basic Usage
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本用法
- en: '### Defining Symbols'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '### 定义符号'
- en: '**Define symbols with [`symbols()`](../modules/core.html#sympy.core.symbol.symbols
    "sympy.core.symbol.symbols") or [`Symbol()`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol").** The `symbols()` function is the most convenient
    way to create symbols. It supports creating one or more symbols at once:'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 [`symbols()`](../modules/core.html#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    或 [`Symbol()`](../modules/core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")
    定义符号。** `symbols()` 函数是创建符号的最便捷方式。它支持一次创建一个或多个符号：'
- en: '[PRE0]'
  id: totrans-7
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Additionally, it supports adding assumptions to symbols
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另外，它支持向符号添加假设。
- en: '[PRE1]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'and defining [`Function`](../modules/core.html#sympy.core.function.Function
    "sympy.core.function.Function") objects:'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 并定义 [`Function`](../modules/core.html#sympy.core.function.Function "sympy.core.function.Function")
    对象：
- en: '[PRE2]'
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It also supports shorthands for defining many numbered symbols at once:'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它还支持快捷方式一次性定义多个编号符号：
- en: '[PRE3]'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Symbol()` constructor may also be used directly. Unlike `symbols()`, `Symbol()`
    always creates one symbol. It is the best option if you want to make a symbol
    with unusual characters in its name or if you are creating symbols programmatically.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Symbol()` 构造函数也可以直接使用。与 `symbols()` 不同，`Symbol()` 总是创建一个符号。如果要创建名称中带有不寻常字符的符号或者在程序中创建符号，则这是最佳选择。'
- en: '[PRE4]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The [`var()`](../modules/core.html#sympy.core.symbol.var "sympy.core.symbol.var")
    function should be avoided, except when working interactively. It works like the
    [`symbols()`](../modules/core.html#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    function, except it automatically injects symbol names into the calling namespace.
    This function is designed solely for interactive typing convenience and is not
    recommended for programmatic use.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`var()`](../modules/core.html#sympy.core.symbol.var "sympy.core.symbol.var")
    函数应避免使用，除非在交互式工作时。它的工作方式类似于 [`symbols()`](../modules/core.html#sympy.core.symbol.symbols
    "sympy.core.symbol.symbols") 函数，但它会自动将符号名称注入到调用命名空间中。此函数仅设计用于交互式输入便捷，不建议用于程序化使用。'
- en: 'Do not use `sympify()` or `S()` to create symbols. This may appear to work:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要使用 `sympify()` 或 `S()` 创建符号。这样看似有效，但可能会出现问题：
- en: '[PRE5]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, `S()`/`sympify()` are not designed to create symbols. They are designed
    to parse entire expressions. This method fails if the input string is not valid
    Python. It also fails if the string parses to a larger expression:'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不过，`S()`/`sympify()` 不适用于创建符号。它们设计用于解析整个表达式。如果输入字符串无效，则该方法失败。如果字符串解析为较大表达式，则同样会失败：
- en: '[PRE6]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Any Python string can be used as a valid Symbol name.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何 Python 字符串都可以用作有效的符号名称。
- en: Furthermore, all the same issues described in the [Avoid String Inputs](#best-practices-avoid-string-inputs)
    section below apply here.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，下面的[避免使用字符串输入](#best-practices-avoid-string-inputs)部分中描述的所有问题也同样适用于此处。
- en: '**Add assumptions to symbols when they are known.** [Assumptions](../guides/assumptions.html#assumptions-guide)
    can be added by passing the relevant keywords to [`symbols()`](../modules/core.html#sympy.core.symbol.symbols
    "sympy.core.symbol.symbols"). The most common assumptions are `real=True`, `positive=True`
    (or `nonnegative=True`), and `integer=True`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在已知的情况下向符号添加假设。** [假设](../guides/assumptions.html#assumptions-guide) 可通过向
    [`symbols()`](../modules/core.html#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    传递相关关键字来添加。最常见的假设是 `real=True`、`positive=True`（或 `nonnegative=True`）和 `integer=True`。'
- en: Assumptions are never required, but it is always recommended to include them
    if they are known because it will allow certain operations to simplify. If no
    assumptions are provided, symbols are assumed to be general complex numbers, and
    simplifications will not be made unless they are true for all complex numbers.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设从不是必需的，但如果已知它们，建议始终包括它们，因为这将允许某些操作简化。如果未提供假设，则假定符号为一般复数，并且不会进行简化，除非它们对所有复数都成立。
- en: 'For example:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE7]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, \(\int_0^\infty e^{-ax}\,dx\) gives a piecewise result when `a` is defined
    with no assumptions, because the integral only converges when `a` is positive.
    Setting `a` to be positive removes this piecewise.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，\(\int_0^\infty e^{-ax}\,dx\) 在`a`定义没有假设时会给出一个分段结果，因为积分只在`a`为正时收敛。将`a`设为正数可以消除这种分段。
- en: 'When you do use assumptions, the best practice is to always use the same assumptions
    for each symbol name. SymPy allows the same symbol name to be defined with different
    assumptions, but these symbols will be considered unequal to each other:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您确实使用假设时，最佳实践是对每个符号名称始终使用相同的假设。SymPy允许使用不同假设定义相同的符号名称，但这些符号将被视为不相等：
- en: '[PRE9]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'See also [Avoid String Inputs](#best-practices-avoid-string-inputs) and [Don’t
    Hardcode Symbol Names in Python Functions](#best-practices-dont-hardcode-symbol-names)
    for related best practices around defining symbols.  ### Avoid String Inputs'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '另请参见[避免字符串输入](#best-practices-avoid-string-inputs)和[不要在Python函数中硬编码符号名称](#best-practices-dont-hardcode-symbol-names)，了解有关定义符号的相关最佳实践。
    ### 避免字符串输入'
- en: Don’t use strings as input to functions. Rather, create the objects symbolically
    using Symbols and the appropriate SymPy functions, and manipulate them.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 不要将字符串作为函数的输入。相反，使用符号（Symbols）和适当的SymPy函数来符号化地创建对象，并对它们进行操作。
- en: '**Don’t**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要**'
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**Do**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**要**'
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It’s always best to create expressions explicitly using Python operators, but
    sometimes you really do start with a string input, like if you accept an expression
    from the user. If you do have a string that you are starting with, you should
    parse it explicitly with [`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr"). It is best to parse all strings early
    and only use symbolic manipulation from there on.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最好始终使用Python运算符显式地创建表达式，但有时您确实从字符串输入开始，例如从用户那里接受表达式。如果您确实有一个要开始的字符串，最好使用[`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr")显式解析它。最好尽早解析所有字符串，然后仅从那里进行符号操作。
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Reason**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**原因**'
- en: 'There are many disadvantages to using strings as input to SymPy functions:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串作为SymPy函数输入存在许多缺点：
- en: It is unpythonic and makes code harder to read. See [the Zen of Python](https://peps.python.org/pep-0020/)
    “explicit is better than implicit”.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这是不符合Python风格的，会使代码难以阅读。参见[Python之禅](https://peps.python.org/pep-0020/)“显式优于隐式”。
- en: Support for string inputs in general SymPy functions is mostly accidental. It
    happens because these functions call [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") on their inputs in order to convert things like
    Python `int`s into SymPy `Integer`s. However, `sympify()` also parses strings
    into SymPy expressions, unless the `strict=True` flag is used. Automatic parsing
    of strings for general SymPy functions (other than `sympify()` or [`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr")) [may go away in a future version of
    SymPy](https://github.com/sympy/sympy/issues/11003).
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一般SymPy函数对字符串输入的支持大多是偶然的。这是因为这些函数在其输入上调用[`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify")，以将Python的`int`之类的东西转换为SymPy的`Integer`。然而，`sympify()`也会将字符串解析为SymPy表达式，除非使用`strict=True`标志。一般SymPy函数（除了`sympify()`或[`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr")之外）对字符串的自动解析可能会在未来的SymPy版本中消失（https://github.com/sympy/sympy/issues/11003）。
- en: Typos in symbol or function names can go unnoticed. This is because all undefined
    names in the string will be automatically parsed into Symbols or Functions. If
    the input has a typo, the string will still parse correctly, but the output will
    not be what was expected. For example
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号或函数名称中的拼写错误可能会被忽略。这是因为字符串中的所有未定义名称将自动解析为符号或函数。如果输入中有拼写错误，字符串仍将被正确解析，但输出将不符合预期。例如
- en: '[PRE13]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Compare this to the explicit error you get when not using strings:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与不使用字符串时得到的显式错误相比：
- en: '[PRE14]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the first example, `sine`, a typo for `sin`, is parsed into `Function("sine")`,
    and it appears that `expand_trig` cannot handle it. In the second case, we immediately
    get an error from the undefined name `sine`, and fixing our typo, we see that
    `expand_trig` can indeed do what we want.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在第一个例子中，`sine`（`sin`的打字错误）被解析为`Function("sine")`，看起来`expand_trig`无法处理它。在第二种情况中，我们立即从未定义的名称`sine`中获得错误，并且在修正我们的打字错误后，我们看到`expand_trig`确实可以实现我们想要的效果。
- en: 'The biggest gotcha when using string inputs comes from using assumptions. In
    SymPy, if two symbols have the same name but different assumptions, they are considered
    unequal:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用字符串输入时最大的陷阱来自于使用假设。在SymPy中，如果两个符号具有相同的名称但不同的假设，则认为它们是不相等的。
- en: '[PRE15]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is generally recommended to avoid doing this, as it can lead to confusing
    expressions like the one above (see [Defining Symbols](#best-practices-defining-symbols)
    above).
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通常建议避免这样做，因为这可能导致混淆的表达式，如上面的例子（参见[定义符号](#best-practices-defining-symbols)）。
- en: However, string inputs will always create symbols without assumptions. So if
    you have a symbol with an assumption and later try to use the string version of
    it, you will end up with confusing results.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，字符串输入始终会创建没有假设的符号。因此，如果您有一个带有假设的符号，并且稍后尝试使用其字符串版本，您将得到令人困惑的结果。
- en: '[PRE16]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The answer here is apparently wrong, but what happened is that the `z` in `"z**2"`
    parsed to `Symbol('z')` with no assumptions, which SymPy considers to be a different
    symbol from `z = Symbol('z', positive=True)`, which is used as the second argument
    to `diff()`. So as far as `diff` is concerned, the expression is constant and
    the result is 0.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里的答案显然是错误的，但发生的情况是`"z**2"`中的`z`被解析为没有假设的`Symbol('z')`，而SymPy认为这是与`z = Symbol('z',
    positive=True)`不同的符号，后者作为`diff()`的第二个参数使用。因此，对于`diff`而言，表达式是常数，结果为0。
- en: This sort of thing is particularly bad because it generally doesn’t lead to
    any errors. It will just silently give the “wrong” answer because SymPy will be
    treating symbols that you thought were the same as different. The situation is
    avoided by not using string inputs.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种情况特别糟糕，因为它通常不会导致任何错误。它会静默地给出“错误”的答案，因为SymPy将处理您认为相同但实际上不同的符号。这种情况可以通过不使用字符串输入来避免。
- en: 'If you are parsing strings, and you want some of the symbols in it to have
    certain assumptions, you should create those symbols and pass them to the dictionary
    to [`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr"). For example:'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您正在解析字符串，并且希望其中的某些符号具有特定的假设，则应创建这些符号并将它们传递给[`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr")的字典。例如：
- en: '**Don’t**'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**不要**'
- en: '[PRE17]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Do**'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**做**'
- en: '[PRE18]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Many SymPy operations are defined as methods, not functions, that is, they
    are called like `sympy_obj.method_name()`. These methods won’t work on strings,
    since they are not yet SymPy objects. For example:'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多SymPy操作被定义为方法，而不是函数，也就是说，它们像`sympy_obj.method_name()`这样调用。由于这些方法尚未是SymPy对象，因此无法在字符串上工作。例如：
- en: '[PRE19]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Contrasted with:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 与之相对：
- en: '[PRE20]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Symbol names can contain any character, including things that aren’t valid Python.
    But if you use strings as input, it is impossible to use such symbols. For example
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号名称可以包含任何字符，包括Python不支持的内容。但如果使用字符串作为输入，则无法使用这些符号。例如
- en: '[PRE21]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This doesn’t work because `x_{2}` is not valid Python. But it is perfectly
    possible to use this as a Symbol name:'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这不起作用，因为`x_{2}`不是有效的Python语法。但是将其用作符号名称是完全可能的：
- en: '[PRE22]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Actually, the above is the best case scenario, where you get an error. It is
    also possible you might get something unexpected:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，上述情况是最好的情况，即出现错误。也有可能会得到一些意外的结果：
- en: '[PRE23]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: What happened here is that instead of parsing `x^1_2` as \(x^1_2\), it is parsed
    as `x**12` (`^` is converted to `**` and [`_` is ignored in numeric literals in
    Python](https://peps.python.org/pep-0515/)).
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里发生的是，`x^1_2`被解析为`x**12`（`^`被转换为`**`，而[`_`在Python的数值文字中被忽略](https://peps.python.org/pep-0515/)）。
- en: If we instead create a Symbol, the actual contents of the symbol name are ignored.
    It is always represented as a single symbol.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们创建一个Symbol，那么符号名称的实际内容将被忽略。它始终表示为单个符号。
- en: '[PRE24]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you use strings, syntax errors won’t be caught until the line is run. If
    you build up the expressions, syntax errors will be caught immediately by before
    any of it runs.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用字符串，语法错误将在运行该行时才会被捕获。如果您构建表达式，语法错误将立即被捕获。
- en: Syntax highlighting in code editors doesn’t typically recognize and color-code
    the content of strings, whereas it can recognize Python expressions.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码编辑器中的语法高亮通常不会识别并对字符串内容进行颜色编码，而它可以识别Python表达式。
- en: Avoid Manipulating Expressions as Strings
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免将表达式作为字符串进行操作
- en: If you find yourself doing a lot of string or regular expression manipulations
    on symbolic expressions, this is generally a sign that you are using SymPy incorrectly.
    It’s better to build up expressions directly with operators like `+`, `-`, `*`,
    and `/` and SymPy’s various functions and methods. String-based manipulations
    can introduce errors, grow complex quickly, and lose the benefits of symbolic
    expression structures.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果发现自己在符号表达式上进行大量字符串或正则表达式操作，则通常表示正在错误地使用SymPy。最好直接使用诸如`+`、`-`、`*`和`/`以及SymPy的各种函数和方法直接构建表达式。基于字符串的操作可能会引入错误，迅速变得复杂，并丧失符号表达式结构的好处。
- en: The reason for this is that there is no notion of a symbolic expression in a
    string. To Python, `"(x + y)/z"` is no different from `"/x+)(y z "`, which is
    the same string with the characters in another order. To contrast, a SymPy expression
    actually knows about what type of mathematical object it represents. SymPy has
    many methods and functions for building and manipulating expressions, and they
    all operate on SymPy objects, not strings.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为字符串中没有符号表达式的概念。对于Python来说，`"(x + y)/z"`与`"/x+)(y z "`并无二致，它们只是字符顺序不同的同一字符串。相比之下，SymPy表达式确实了解它所代表的数学对象的类型。SymPy有许多用于构建和操作表达式的方法和函数，它们都是作用于SymPy对象而非字符串的。
- en: For example
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 例如
- en: '**Don’t**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要**'
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**Do**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**做**'
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: See also the [previous section on avoiding string inputs to functions](#best-practices-avoid-string-inputs).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅[避免向函数输入字符串](#best-practices-avoid-string-inputs)的上一节。
- en: '### Exact Rational Numbers vs. Floats'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '### 精确有理数与浮点数'
- en: If a number is known to be exactly equal to some quantity, avoid defining it
    as a floating-point number.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个数值确切等于某个量，请避免将其定义为浮点数。
- en: For example,
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，
- en: '**Don’t**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要**'
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '**Do**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**做**'
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: However, this isn’t to say that you should never use floating-point numbers
    in SymPy, only that if a more exact value is known it should be preferred. SymPy
    does support [arbitrary precision floating-point numbers](../modules/core.html#sympy.core.numbers.Float
    "sympy.core.numbers.Float"), but some operations may not perform as well with
    them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，并非说在SymPy中永远不应使用浮点数，只是如果已知更精确的值，则应优先使用。SymPy确实支持[任意精度浮点数](../modules/core.html#sympy.core.numbers.Float
    "sympy.core.numbers.Float")，但某些操作可能性能不佳。
- en: This also applies to non-rational numbers which can be represented exactly.
    For example, one should avoid using `math.pi` and prefer `sympy.pi`, since the
    former is a numerical approximation to \(\pi\) and the latter is exactly \(\pi\)
    (see also [Separate Symbolic and Numeric Code](#best-practices-separate-symbolic-and-numeric-code)
    below; in general, one should avoid importing `math` when using SymPy).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可以精确表示的非有理数，同样适用。例如，应避免使用`math.pi`，而优先使用`sympy.pi`，因为前者是对\(\pi\)的数值近似，而后者是\(\pi\)的精确表示（另请参见[分离符号和数值代码](#best-practices-separate-symbolic-and-numeric-code)下文；总体而言，在使用SymPy时应避免导入`math`）。
- en: '**Don’t**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要**'
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '**Do**'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '**做**'
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here `sympy.sin(math.pi)` is not exactly 0, because `math.pi` is not exactly
    \(\pi\).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`sympy.sin(math.pi)`并非严格等于0，因为`math.pi`并非严格等于\(\pi\)。
- en: One should also take care to avoid writing `integer/integer` where both integers
    are explicit integers. This is because Python will evaluate this to a floating-point
    value before SymPy is able to parse it.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还应特别注意避免写`integer/integer`，其中两个整数都是显式整数。这是因为Python会在SymPy能够解析之前将其评估为浮点值。
- en: '**Don’t**'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要**'
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, use [`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational") to create a rational number, or use `S()` shorthand
    if you want to save on typing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，可以使用[`Rational`](../modules/core.html#sympy.core.numbers.Rational "sympy.core.numbers.Rational")创建有理数，或者如果想节省输入，则可以使用`S()`缩写。
- en: '**Do**'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '**做**'
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '**Reason**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**原因**'
- en: 'Exact values, if they are known, should be preferred over floats for the following
    reasons:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已知的精确值，应优先选择而非浮点数，原因如下：
- en: An exact symbolic value can often be symbolically simplified or manipulated.
    A float represents an approximation to an exact real number, and therefore cannot
    be simplified exactly. For example, in the above example, `sin(math.pi)` does
    not produce `0` because `math.pi` is not exactly \(\pi\). It is just a floating-point
    number that approximates \(\pi\) to 15 digits (effectively, a close rational approximation
    to \(\pi\), but not exactly \(\pi\)).
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 精确的符号值通常可以被符号化简或操作。浮点数表示对精确实数的近似，因此无法被精确简化。例如，在上面的例子中，`sin(math.pi)`不会产生`0`，因为`math.pi`并不是完全的\(\pi\)。它只是一个浮点数，用15位数近似了\(\pi\)（实际上是\(\pi\)的一个接近的有理近似，但不是精确的\(\pi\)）。
- en: Some algorithms will not be able to compute a result if there are floating-point
    values, but can if the values are rational numbers. This is because rational numbers
    have properties that make it easier for these algorithms to work with them. For
    instance, with floats, one can have a situation where a number should be 0, but
    due to approximation errors, does not equal exactly 0.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果存在浮点值，某些算法将无法计算结果，但如果值是有理数，则可以计算。这是因为有理数具有使这些算法更易处理的属性。例如，使用浮点数时，可能会出现一个数字应该为0的情况，但由于近似误差，实际上并不等于0。
- en: A particularly notable example of this is with floating-point exponents. For
    example,
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特别引人注目的例子是浮点数指数。例如，
- en: '[PRE33]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'SymPy Floats have the same loss of significance cancellation issues that can
    occur from using finite precision floating-point approximations:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy浮点数具有与使用有限精度浮点数近似导致的相同的有效位数损失和抵消问题：
- en: '[PRE34]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It is possible to avoid these issues in SymPy in many cases by making careful
    use of `evalf` with its ability to evaluate in arbitrary precision. This typically
    involves either computing an expression with symbolic values and substituting
    them later with `expr.evalf(subs=...)`, or by starting with `Float` values with
    a precision higher than the default of 15 digits:'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在许多情况下，可以通过仔细使用带有任意精度评估能力的`evalf`来避免这些问题。这通常涉及计算带有符号值的表达式，然后使用`expr.evalf(subs=...)`稍后进行替换，或者通过使用比默认的15位高的精度开始使用`Float`值：
- en: '[PRE35]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A `Float` number can be converted to its exact rational equivalent by passing
    it to `Rational`. Alternatively, you can use `nsimplify` to find the nicest rational
    approximation. This can sometimes reproduce the number that was intended if the
    number is supposed to be rational (although again, it’s best to just start with
    rational numbers in the first place, if you can):'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将`Float`数传递给`Rational`来将其转换为其精确有理等价物。或者，您可以使用`nsimplify`来找到最好的有理近似值。这有时可以重现预期的数字，如果该数字应为有理数的话（尽管再次强调，最好一开始就使用有理数）：
- en: '[PRE36]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Avoid `simplify()`
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免使用`simplify()`
- en: '[`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") (not to be confused with [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify")) is designed as a general purpose heuristic. It
    tries various simplification algorithms on the input expression and returns the
    result that seems the “simplest” based on some metric.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify")（不要与[`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify")混淆）被设计为一种通用的启发式算法。它在输入表达式上尝试各种简化算法，并根据某些度量返回看起来“最简”的结果。'
- en: '`simplify()` is perfectly fine for interactive use, where you just want SymPy
    to do whatever it can to an expression. However, in programmatic usage, it’s better
    to avoid `simplify()` and use more [targeted simplification functions](../modules/simplify/simplify.html#simplify-docs)
    instead (e.g., [`cancel()`](../modules/polys/reference.html#sympy.polys.polytools.cancel
    "sympy.polys.polytools.cancel"), [`expand()`](../modules/core.html#sympy.core.function.expand
    "sympy.core.function.expand"), or [`collect()`](../modules/simplify/simplify.html#sympy.simplify.radsimp.collect
    "sympy.simplify.radsimp.collect")).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`simplify()`在交互使用中完全可以接受，您只需希望SymPy尽其所能处理表达式。但是，在程序化使用中，最好避免使用`simplify()`，而是使用更多的[定向简化函数](../modules/simplify/simplify.html#simplify-docs)（例如[`cancel()`](../modules/polys/reference.html#sympy.polys.polytools.cancel
    "sympy.polys.polytools.cancel")，[`expand()`](../modules/core.html#sympy.core.function.expand
    "sympy.core.function.expand")或[`collect()`](../modules/simplify/simplify.html#sympy.simplify.radsimp.collect
    "sympy.simplify.radsimp.collect")）。'
- en: 'There are a few reasons why this is generally preferred:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这样做有几个原因：
- en: Due to its heuristical nature, `simplify()` can potentially be slow, since it
    tries a lot of different approaches to try to find the best simplification.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于其启发式特性，`simplify()`可能会潜在地较慢，因为它尝试了许多不同的方法来找到最佳的简化。
- en: There are no guarantees about what form an expression will have after being
    passed through `simplify()`. It may actually end up “less simple” by whatever
    metric you were hoping for. To contrast, targeted simplification functions are
    very specific about what behaviors they have and what they guarantee about the
    output. For example,
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经过`simplify()`处理后，表达式的形式可能无法保证。它可能实际上按您希望的任何度量标准变得“不那么简单”。相比之下，目标化简函数非常明确地说明了它们的行为和输出的保证。例如，
- en: '[`factor()`](../modules/polys/reference.html#sympy.polys.polytools.factor "sympy.polys.polytools.factor")
    will always factor a polynomial into irreducible factors.'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`factor()`](../modules/polys/reference.html#sympy.polys.polytools.factor "sympy.polys.polytools.factor")
    将总是将多项式因式分解为不可约因子。'
- en: '[`cancel()`](../modules/polys/reference.html#sympy.polys.polytools.cancel "sympy.polys.polytools.cancel")
    will always convert a rational function into the form \(p/q\) where \(p\) and
    \(q\) are expanded polynomials with no common factors.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`cancel()`](../modules/polys/reference.html#sympy.polys.polytools.cancel "sympy.polys.polytools.cancel")
    将总是将有理函数转换为形式 \(p/q\)，其中 \(p\) 和 \(q\) 是展开的多项式，没有公共因子。'
- en: The documentation for each function describes exactly what behavior it will
    have on the input expression.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个函数的文档描述了它在输入表达式上的确切行为。
- en: A targeted simplification will not do something unexpected if the expression
    contains an unexpected form, or an unexpected subexpression. This is especially
    the case if simplification functions are applied with `deep=False` to only apply
    the simplification to the top-level expression.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果表达式包含意外形式或意外子表达式，目标化简不会执行意外操作。特别是如果应用简化函数时使用 `deep=False` 仅将简化应用于顶层表达式。
- en: Some other simplification functions are heuristical in nature, and care should
    be taken with them as well. For example, the [`trigsimp()`](../modules/simplify/simplify.html#sympy.simplify.trigsimp.trigsimp
    "sympy.simplify.trigsimp.trigsimp") function is a heuristic targeted to trigonometric
    functions, but the routines in the [`sympy.simplify.fu`](../modules/simplify/fu.html#module-sympy.simplify.fu
    "sympy.simplify.fu") submodule allow applying specific trigonometric identities.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些简化函数具有启发式特性，使用它们时也应格外小心。例如，[`trigsimp()`](../modules/simplify/simplify.html#sympy.simplify.trigsimp.trigsimp
    "sympy.simplify.trigsimp.trigsimp") 函数是一种针对三角函数的启发式方法，但[`sympy.simplify.fu`](../modules/simplify/fu.html#module-sympy.simplify.fu
    "sympy.simplify.fu") 子模块中的例程允许应用特定的三角函数恒等式。
- en: The [simplify section of the tutorial](../tutorials/intro-tutorial/simplification.html#tutorial-simplify)
    and the [simplify module reference](../modules/simplify/simplify.html) list the
    various targeted simplification functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 教程中的简化部分（[simplify section of the tutorial](../tutorials/intro-tutorial/simplification.html#tutorial-simplify)）和简化模块参考（[simplify
    module reference](../modules/simplify/simplify.html)）列出了各种目标化简函数。
- en: In some cases, you may know exactly what simplification operations you wish
    to apply to an expression, but there may not be an exact set of simplification
    functions that do them. When this happens, you can create your own targeted simplification
    using [`replace()`](../modules/core.html#sympy.core.basic.Basic.replace "sympy.core.basic.Basic.replace"),
    or in general, manually using [advanced expression manipulation](../tutorials/intro-tutorial/manipulation.html#tutorial-manipulation).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能确切地知道要应用到表达式的简化操作，但可能没有确切的简化函数集来执行这些操作。发生这种情况时，您可以使用[`replace()`](../modules/core.html#sympy.core.basic.Basic.replace
    "sympy.core.basic.Basic.replace") 或一般地使用[高级表达式操作](../tutorials/intro-tutorial/manipulation.html#tutorial-manipulation)创建您自己的目标简化。
- en: '### Don’t Hardcode Symbol Names in Python Functions'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '### 不要在 Python 函数中硬编码符号名称'
- en: Instead of hard-coding [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol") names inside of a function definition, make the symbols
    a parameter to the function.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数定义中，而不是在内部硬编码[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")名称，请将符号作为函数的参数。
- en: 'For example, consider a function `theta_operator` that computes the [theta
    operator](https://en.wikipedia.org/wiki/Theta_operator) \(\theta = zD_z\):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个函数`theta_operator`，它计算[θ运算符](https://en.wikipedia.org/wiki/Theta_operator)
    \(\theta = zD_z\)：
- en: '**Don’t**'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要**'
- en: '[PRE37]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Do**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**要**'
- en: '[PRE38]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'A hard-coded symbol name has the disadvantage of requiring all expressions
    to use that exact symbol name. In the above example, it is not possible to compute
    \(\theta = xD_x\) because it is hard-coded to \(zD_z\). What’s worse, trying to
    do so silently leads to a wrong result instead of an error, since `x` is treated
    as a constant expression:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 硬编码的符号名称的缺点是需要所有表达式使用确切的符号名称。在上述示例中，不可能计算 \(\theta = xD_x\)，因为它被硬编码为 \(zD_z\)。更糟糕的是，试图这样做会导致错误的结果，而不是错误，因为
    `x` 被视为常量表达式：
- en: '[PRE39]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is particularly problematic if the function accepts arbitrary user input,
    as the user may be using a different variable name that makes more sense in their
    mathematical context. And if the user already used the symbol `z` but as a constant,
    they would need to swap things around with `subs` before being able to use the
    function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这在函数接受任意用户输入时特别棘手，因为用户可能在他们的数学背景中使用不同的变量名。如果用户已经使用符号`z`但作为常数，他们需要在能够使用函数之前使用`subs`来交换这些内容。
- en: The other reason this antipattern is problematic is due to the gotcha that symbols
    with assumptions are considered unequal to symbols without assumptions. If someone
    defined their expression using
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个导致这种反模式问题的原因是，带有假设的符号被认为与没有假设的符号不相等。如果某人使用
- en: '[PRE40]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'for example, to make further simplifications possible (see [Defining Symbols](#best-practices-defining-symbols)
    above), the function hard-coding `Symbol(''z'')` without assumptions would not
    work:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为了使进一步简化成为可能（参见[定义符号](#best-practices-defining-symbols)），硬编码的函数中使用 `Symbol('z')`
    而没有假设将不起作用：
- en: '[PRE41]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'By making the symbol an argument to the function, like `theta_operator(expr,
    z)`, these problems all go away.  ### Separate Symbolic and Numeric Code'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将符号作为函数的参数，如 `theta_operator(expr, z)`，所有这些问题都可以解决。### 分离符号和数值代码
- en: SymPy sets itself apart from most of the rest of the libraries in the Python
    ecosystem in that it operates symbolically, whereas other libraries, like NumPy,
    operate numerically. These two paradigms are different enough that it’s always
    best to keep them as separate as possible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 与 Python 生态系统中的大多数其他库有所不同，它以符号方式运行，而其他库如 NumPy 则以数值方式运行。这两种范式差异足够大，因此最好尽可能将它们分开。
- en: Importantly, SymPy is not designed to work with NumPy arrays, and conversely,
    NumPy will not work directly with SymPy objects.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，SymPy 不设计与 NumPy 数组一起使用，反之亦然，NumPy 也不能直接使用 SymPy 对象。
- en: '[PRE42]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If you want to use both SymPy and NumPy, you should explicitly convert your
    SymPy expressions into NumPy functions using [`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify"). The typical workflow in SymPy is to model
    your problem symbolically using SymPy, then convert the result into a numerical
    function with `lambdify()` that can be evaluated on NumPy arrays. For advanced
    use-cases, `lambdify()`/NumPy may not be enough and you may instead need to use
    SymPy’s more general [code generation](../modules/codegen.html#codegen-prose)
    routines to generate code for other fast numerical languages such as Fortran or
    C.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望同时使用 SymPy 和 NumPy，应明确将 SymPy 表达式转换为 NumPy 函数，使用 [`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify")。在 SymPy 中的典型工作流程是使用 SymPy 符号化地建模问题，然后使用 `lambdify()`
    将结果转换为可以在 NumPy 数组上评估的数值函数。对于高级用例，`lambdify()`/NumPy 可能不足以满足需求，可能需要使用 SymPy 更通用的
    [代码生成](../modules/codegen.html#codegen-prose) 例程来为其他快速数值语言（如 Fortran 或 C）生成代码。
- en: '[PRE44]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These are some antipatterns that should be generally avoided
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是应该通常避免的反模式。
- en: '**Do not use `import math`.** It is virtually never necessary to use the [standard
    library `math` module](https://docs.python.org/3/library/math.html) alongside
    SymPy (or NumPy). Every function that is in `math` is already in SymPy. SymPy
    can compute values numerically using [evalf](glossary.html#term-evalf), which
    provides more precision and accuracy than `math`. Or better, SymPy will by default
    compute things symbolically. Functions and constants in `math` are floats, which
    are inexact. SymPy always works better with exact quantities when possible. For
    example,'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要使用 `import math`。** 在使用 SymPy（或 NumPy）时几乎从不需要使用[标准库 `math` 模块](https://docs.python.org/3/library/math.html)。`math`
    中的每个函数已经包含在 SymPy 中。SymPy 可以使用 [evalf](glossary.html#term-evalf) 进行数值计算，提供比 `math`
    更高的精度和准确性。更好的做法是，SymPy 默认会以符号方式计算。`math` 中的函数和常数是浮点数，存在不精确性。在可能的情况下，SymPy 始终更适合精确量。例如，'
- en: '[PRE45]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The result of `sympy.sin(math.pi)` is not `0` as you might expect, because
    `math.pi` is only an approximation of \(\pi\), equal to 16 digits. On the other
    hand, `sympy.pi` is *exactly* equal to \(\pi\) because it is represented symbolically,
    so it is able to give the exact answer:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sympy.sin(math.pi)` 的结果不是你可能期望的 `0`，因为 `math.pi` 只是 \(\pi\) 的近似值，精确到 16 位数字。另一方面，`sympy.pi`
    *确切* 等于 \(\pi\)，因为它是符号表示，所以能够给出精确的答案：'
- en: '[PRE46]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: So in general, one should [prefer symbolic representations](#best-practices-exact-rational-numbers-vs-floats).
    But even if you actually do want a float, you are better off using SymPy’s `evalf()`
    rather than `math`. This avoids the pitfall that `math` functions can only operate
    on `float` objects, not symbolic expressions
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，通常应该[偏爱符号表示](#best-practices-exact-rational-numbers-vs-floats)。但即使你确实需要一个浮点数，你最好使用
    SymPy 的 `evalf()` 而不是 `math`。这样可以避免 `math` 函数仅能操作 `float` 对象而不能操作符号表达式的问题。
- en: '[PRE47]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: And furthermore, SymPy’s `evalf()` is more accurate than `math`, because it
    uses arbitrary precision arithmetic, and allows you to specify any number of digits.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，SymPy 的 `evalf()` 比 `math` 更精确，因为它使用任意精度算术，并允许您指定任意数量的位数。
- en: '[PRE48]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Even when using NumPy, `math` should be avoided. NumPy functions are faster
    than their `math` equivalents, support a larger range of numerical dtypes, and
    can operate on arrays of values, whereas `math` functions can only operate on
    a single scalar at a time.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 即使在使用 NumPy 时，应避免使用 `math`。NumPy 函数比它们的 `math` 等效函数更快，支持更大范围的数值类型，并且可以操作值数组，而
    `math` 函数一次只能操作一个标量。
- en: '**Don’t pass SymPy expressions to a NumPy function.** You should not pass a
    SymPy expression to a NumPy function. This includes anything in the `numpy` or
    `scipy` namespaces, as well as most functions from other Python libraries such
    as `matplotlib`. These functions are only designed to work with NumPy arrays with
    numeric values.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要将 SymPy 表达式传递给 NumPy 函数。** 不应将 SymPy 表达式传递给 NumPy 函数。这包括 `numpy` 或 `scipy`
    命名空间中的任何内容，以及来自其他 Python 库（如 `matplotlib`）的大多数函数。这些函数只设计用于处理具有数值值的 NumPy 数组。'
- en: '**Don’t pass SymPy expressions to a lambdified function.** Similar to the previous
    point, you should not pass SymPy expressions to a function created with `lambdify`.
    In effect, the functions returned by `lambdify` *are* NumPy functions, so the
    situation here is exactly the same. It is possible that in some cases a function
    created from `lambdify()` will work with a SymPy expression, but this is just
    an accident of the way it works. See [the “how it works” section of the `lambdify()`
    documentation](../modules/utilities/lambdify.html#lambdify-how-it-works) for more
    details on why this happens.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不要将 SymPy 表达式传递给 lambdify 函数。** 与前一点类似，不应将 SymPy 表达式传递给使用 `lambdify` 创建的函数。实际上，`lambdify`
    返回的函数就是 NumPy 函数，因此这里的情况完全相同。某些情况下，通过 `lambdify()` 创建的函数可能会与 SymPy 表达式一起工作，但这只是其工作方式的偶然结果。有关此现象更多详细信息，请参阅
    `lambdify()` 文档的“how it works”部分。'
- en: '**Avoid storing SymPy expressions in a NumPy array.** While it is technically
    possible to store SymPy expressions inside of a NumPy array, doing so usually
    represents a mistake. A sign that this is happening is if the `dtype` of the NumPy
    array is `object` (instead of a numeric dtype like `float64` or `int64`).'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**避免将 SymPy 表达式存储在 NumPy 数组中。** 虽然技术上可以将 SymPy 表达式存储在 NumPy 数组中，但这样做通常是一个错误。表明这种情况发生的标志是如果
    NumPy 数组的 `dtype` 是 `object`（而不是像 `float64` 或 `int64` 这样的数值类型）。'
- en: Just as one should avoid using NumPy when doing symbolic calculations with SymPy,
    one should stop using SymPy once the calculation have moved over to the numeric
    side of things with NumPy.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 就像在 SymPy 进行符号计算时应避免使用 NumPy 一样，一旦计算转向 NumPy 的数值计算，就应停止使用 SymPy。
- en: A NumPy array that contains SymPy expressions effectively has the same problem
    as trying to call NumPy functions directly on a SymPy expression. They do not
    know how to operate on SymPy objects, so they will fail. This applies even if
    the SymPy objects are all SymPy [`Float`s](../modules/core.html#sympy.core.numbers.Float
    "sympy.core.numbers.Float").
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 包含 SymPy 表达式的 NumPy 数组实际上面临与直接在 SymPy 表达式上调用 NumPy 函数相同的问题。它们不知道如何操作 SymPy 对象，因此会失败。即使
    SymPy 对象都是 SymPy [`Float`](../modules/core.html#sympy.core.numbers.Float "sympy.core.numbers.Float")，情况也是如此。
- en: '[PRE49]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: If you are doing this, you should probably either be using native NumPy floats,
    or, if you really do want to store an array of SymPy expressions, you should use
    SymPy’s [`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix
    "sympy.matrices.dense.Matrix") or `NDimArray` classes.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您正在这样做，您可能应该使用本机NumPy浮点数，或者如果确实希望存储一组SymPy表达式，则应使用SymPy的[`Matrix`](../modules/matrices/dense.html#sympy.matrices.dense.Matrix
    "sympy.matrices.dense.Matrix")或`NDimArray`类。
- en: Advanced Usage
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高级用法
- en: Be Careful Comparing and Sorting Symbolic Objects
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谨慎比较和排序符号对象
- en: Be careful with programmatic code that compares numerical quantities, either
    directly using an inequality (`<`, `<=`, `>`, `>=`) or indirectly with something
    like `sorted`. The issue is that if an inequality is unknown, the result will
    be symbolic, like
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写比较数值量的程序代码时要小心，可以直接使用不等式（`<`、`<=`、`>`、`>=`）或间接使用像`sorted`之类的内容。问题在于如果不等式未知，则结果将是符号的，如
- en: '[PRE50]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'A symbolic inequality will raise an exception if `bool()` is called on it,
    due to the ambiguity:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对符号不等式调用`bool()`将引发异常，由于其模棱两可性：
- en: '[PRE51]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A check like
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 类似以下检查：
- en: '[PRE52]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'May work just fine if you only ever test it for numerical `x`. But if `x` can
    ever be symbolic, the above code is wrong. It will fail with `TypeError: cannot
    determine truth value of Relational`. If you ever see this exception, it means
    this error has been made somewhere (sometimes the error is in SymPy itself; if
    this appears to be the case, please [open an issue](https://github.com/sympy/sympy/issues)).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '如果仅针对数值`x`进行测试，则可能运行得很好。但是如果`x`可能是符号的，则上述代码是错误的。它将以`TypeError: cannot determine
    truth value of Relational`失败。如果您曾看到此异常，则意味着此错误已经发生（有时错误出现在SymPy本身; 如果情况如此，请[提交问题](https://github.com/sympy/sympy/issues)）。'
- en: The exact same issue occurs when using `sorted`, since this internally uses
    `>`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`sorted`时，会出现完全相同的问题，因为它内部使用了`>`。
- en: '[PRE53]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'There are a few options for fixing this issue, and the correct one to choose
    depends on what you are doing:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以解决此问题，选择正确的方法取决于您的操作目的：
- en: '**Disallow symbolic inputs.** If your function cannot possibly work on symbolic
    inputs, you can explicitly disallow them. The primary benefit here is to give
    a more readable error message to users than `TypeError:  cannot determine truth
    value of Relational`. The [`is_number`](../modules/core.html#sympy.core.expr.Expr.is_number
    "sympy.core.expr.Expr.is_number") attribute can be used to check if an expression
    can be evaluated to a specific number with `evalf()`. If you want to only accept
    integers, you can check `isinstance(x, Integer)` (after calling `sympify()` to
    convert Python ints). Beware that `is_integer` uses the assumptions system and
    may be True even for symbolic objects, like `Symbol(''x'', integer=True)`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁止符号输入。** 如果您的函数绝对不能处理符号输入，则可以明确禁止它们。这里的主要优点是向用户提供比`TypeError:  cannot determine
    truth value of Relational`更易读的错误消息。可以使用[`is_number`](../modules/core.html#sympy.core.expr.Expr.is_number
    "sympy.core.expr.Expr.is_number")属性来检查表达式是否可以通过`evalf()`计算为特定数字。如果只想接受整数，可以检查`isinstance(x,
    Integer)`（在调用`sympify()`将Python整数转换为SymPy表达式后）。注意，`is_integer`使用假设系统，即使对于如`Symbol(''x'',
    integer=True)`之类的符号对象也可能为True。'
- en: '**Use the assumptions system.** If you do support symbolic inputs, you should
    use the assumptions system to check for things like `x > 0`, e.g., using `x.is_positive`.
    When doing this, you should always [be aware of the nuances](../guides/booleans.html#booleans-guide)
    of the [three-valued fuzzy logic](glossary.html#term-Three-valued-logic) used
    in the assumptions system. That is, always be aware that an assumption could be
    `None`, meaning its value is unknown and could be either true or false. For example,'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用假设系统。** 如果您支持符号输入，应使用假设系统来检查诸如`x > 0`之类的条件，例如使用`x.is_positive`。在此过程中，您应始终注意[布尔指导](../guides/booleans.html#booleans-guide)中使用的三值模糊逻辑的细微差别。也就是说，始终注意假设可能为`None`，意味着其值未知且可能为真或假。例如，'
- en: '[PRE54]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: will only run the block if `x.is_positive` is `True`, but you may want to do
    something when `x.is_positive` is `None`.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 仅在`x.is_positive`为`True`时才会运行该块，但当`x.is_positive`为`None`时，您可能希望执行某些操作。
- en: '**Return a Piecewise result.** If the result of a function depends on an inequality
    or other boolean condition, you can use [`Piecewise`](../modules/functions/elementary.html#sympy.functions.elementary.piecewise.Piecewise
    "sympy.functions.elementary.piecewise.Piecewise") to return a result that represents
    both possibilities symbolically. This is generally preferred when possible, as
    it offers the most flexibility. This is because the result is represented symbolically,
    meaning, for instance, one can later substitute specific values for the symbols
    and it will evaluate to the specific case, even if it is combined with other expressions.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回一个分段函数结果。** 如果函数的结果取决于不等式或其他布尔条件，您可以使用[`Piecewise`](../modules/functions/elementary.html#sympy.functions.elementary.piecewise.Piecewise
    "sympy.functions.elementary.piecewise.Piecewise")返回一个代表两种可能性的结果。在可能的情况下，这通常是首选，因为它提供了最大的灵活性。这是因为结果是以符号方式表示的，这意味着，例如，可以稍后替换符号的具体值，并且它将评估为特定情况，即使它与其他表达式组合在一起。'
- en: For example, instead of
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，而不是
- en: '[PRE55]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: this can be represented symbolically as
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这可以用符号表示为
- en: '[PRE56]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**Use [`ordered()`](../modules/core.html#sympy.core.sorting.ordered "sympy.core.sorting.ordered")
    to sort expressions into a canonical order.** If you are trying to use `sorted`
    because you want a canonical ordering, but you don’t particularly care what that
    ordering is, you can use `ordered`.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用[`ordered()`](../modules/core.html#sympy.core.sorting.ordered "sympy.core.sorting.ordered")将表达式排序为规范顺序。**
    如果您试图使用`sorted`，因为您想要规范排序，但您并不特别关心排序是什么，您可以使用`ordered`。'
- en: '[PRE57]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Alternatively, try to write the function in a way so that the correctness of
    the result does not depend on the order that arguments are processed in.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，尝试编写函数的方式，使得结果的正确性不依赖于处理参数的顺序。
- en: Custom SymPy Objects
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义 SymPy 对象
- en: SymPy is designed to be extended with custom classes, typically by subclassing
    [Basic](glossary.html#term-Basic), [Expr](glossary.html#term-Expr), or [Function](glossary.html#term-Function-class).
    All the symbolic classes in SymPy itself are written this way, and the points
    here apply equally to them as to user-defined classes.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 设计为通过自定义类进行扩展，通常是通过对[Basic](glossary.html#term-Basic)、[Expr](glossary.html#term-Expr)或[Function](glossary.html#term-Function-class)进行子类化。SymPy
    本身的所有符号类都是这样编写的，并且这里的要点同样适用于用户定义的类。
- en: For an in-depth guide on how to write a `Function` subclass, see the [guide
    on writing custom functions](../guides/custom-functions.html#custom-functions).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何编写`Function`子类的深入指南，请参阅[编写自定义函数指南](../guides/custom-functions.html#custom-functions)。
- en: '### Args Invariants'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '### Args 不变量'
- en: 'Custom SymPy objects should always satisfy the following invariants:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义 SymPy 对象应始终满足以下不变量：
- en: '`all(isinstance(arg, Basic) for arg in args)`'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`all(isinstance(arg, Basic) for arg in args)`'
- en: '`expr.func(*expr.args) == expr`'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`expr.func(*expr.args) == expr`'
- en: The first says that all elements of [args](glossary.html#term-args) should be
    instances of [Basic](glossary.html#term-Basic). The second says that an expression
    should be rebuildable from its `args` (note that [func](glossary.html#term-func)
    is usually the same as `type(expr)`, though it may not always be).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个说所有[args](glossary.html#term-args)的元素应该是[Basic](glossary.html#term-Basic)的实例。第二个说一个表达式应该从它的`args`重建（注意[func](glossary.html#term-func)通常与`type(expr)`相同，尽管可能不总是）。
- en: These two invariants are assumed throughout SymPy, and are essential for any
    function that manipulates expressions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 在整个过程中假设这两个不变量，并且对于任何操作表达式的函数都是必不可少的。
- en: 'For example, consider this simple function, which is a simplified version of
    [`xreplace()`](../modules/core.html#sympy.core.basic.Basic.xreplace "sympy.core.basic.Basic.xreplace"):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个简单的函数，这是[`xreplace()`](../modules/core.html#sympy.core.basic.Basic.xreplace
    "sympy.core.basic.Basic.xreplace")的简化版本：
- en: '[PRE58]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The function works by recursively traversing the `args` of `expr`, and rebuilding
    it except any instances of `x` are replaced by `y`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数通过递归遍历`expr`的`args`，并重建它，除了`x`的任何实例都被替换为`y`。
- en: 'It’s easy to see how this function would break if the args invariants did not
    hold:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，如果参数不变量不成立，这个函数会如何破坏：
- en: If an expression had args that were not `Basic`, they would fail with `AttributeError`
    on a recursive call, because the non-`Basic` args would not have the `.args` or
    `.func` attributes.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个表达式的 args 不是`Basic`，它们在递归调用时将导致`AttributeError`失败，因为非`Basic`的 args 将没有`.args`或`.func`属性。
- en: If an expression did not rebuild from its `args`, the line `return exr.func(*newargs)`
    would fail, even in the trivial case where none of the args are changed by the
    replacement, which should effectively be a no-op.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个表达式没有从它的`args`中重建出来，那么`return exr.func(*newargs)`这行代码将失败，即使在没有替换任何args的情况下，这应该有效地是一个无操作。
- en: Making all `args` instances of `Basic` usually just means calling `_sympify()`
    on the inputs to the class so that they are basic instances. If you want to store
    a string on a class, you should either use a `Symbol` or `sympy.core.symbols.Str`.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有`args`实例转换为`Basic`通常意味着对类的输入调用`_sympify()`，这样它们就成为基本实例了。如果你想在类上存储一个字符串，你应该使用`Symbol`或`sympy.core.symbols.Str`。
- en: 'In some cases a class may accept args in multiple equivalent forms. It is important
    that whatever form is stored in `args` is one of the ways that can be used to
    reconstruct the class. It is okay to normalize `args` as long as that normalized
    form is accepted as input. For example, `Integral` always stores the variable
    argument as a tuple to make things easier to process internally, but this form
    is also accepted by the class constructor:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，一个类可能接受多种等价形式的args。重要的是，存储在`args`中的形式是可以用于重建类的方式之一。标准化`args`是可以接受的，只要标准化形式被接受为输入。例如，`Integral`总是将变量参数存储为一个元组，以便在内部处理时更容易，但这种形式也被类构造函数接受：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Note that most user-defined custom functions should be defined by subclassing
    `Function` (see the [guide to writing custom functions](../guides/custom-functions.html#custom-functions)).
    The `Function` class automatically takes care of both of the args invariants,
    so if you are using it, you do not need to worry about this.  ### Avoid Too Much
    Automatic Evaluation'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '请注意，大多数用户定义的自定义函数应该通过对`Function`进行子类化来定义（参见[编写自定义函数指南](../guides/custom-functions.html#custom-functions)）。`Function`类自动处理`args`的两个不变量，因此如果你使用它，你不需要担心这个问题。  ###
    避免过多的自动评估'
- en: When defining a custom function, avoid doing too much automatic evaluation (i.e.,
    evaluation in the `eval` or `__new__` methods).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义自定义函数时，避免做过多的自动评估（比如在`eval`或`__new__`方法中进行评估）。
- en: Generally, automatic evaluation should only be done in instances where it is
    fast, and it is something that no one ever want to not happen. Automatic evaluation
    is difficult to undo. A good rule of thumb is to evaluate on explicit numeric
    values (`isinstance(x, Number)`), and leave everything else symbolically unevaluated.
    Further simplification using more advanced identities should be done in specific
    simplification functions or `doit` (see the [custom functions guide](../guides/custom-functions.html#custom-functions)
    for a list of common simplification routines that can be defined on SymPy objects).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，只有在快速的实例中才应该进行自动评估，而且这是没人希望不发生的事情。自动评估很难撤销。一个很好的经验法则是在显式的数值上进行评估（`isinstance(x,
    Number)`），而且将其他一切保留为符号未评估。使用更高级的身份进行进一步简化应该在特定简化函数或`doit`中完成（参见[自定义函数指南](../guides/custom-functions.html#custom-functions)列出的可以在SymPy对象上定义的常见简化例程）。
- en: The [custom functions guide](../guides/custom-functions.html#custom-functions-automatic-evaluation)
    goes over this in depth (but note that this guideline applies equally to all SymPy
    objects, not just functions). But in a nutshell, the reason for this is that the
    only way to prevent automatic evaluation is to use `evaluate=False`, which is
    fragile. Additionally, code will invariably be written assuming the invariants
    that are true due to automatic evaluations, meaning that expressions created with
    `evaluate=False` can lead to wrong results from this code. This also means that
    removing automatic evaluation later can be difficult.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义函数指南](../guides/custom-functions.html#custom-functions-automatic-evaluation)对此进行了深入讨论（但请注意，这个准则适用于所有SymPy对象，而不仅仅是函数）。但简而言之，这样做的原因是，防止自动评估的唯一方法是使用`evaluate=False`，这是很脆弱的。另外，代码总是写成假设由于自动评估而成立的不变量，这意味着使用`evaluate=False`创建的表达式可能会导致代码产生错误的结果。这也意味着以后删除自动评估可能会很困难。'
- en: Evaluation that can potentially be expensive (for instance, applying a symbolic
    identity) is itself bad because it can make creating an expression without even
    doing anything with it allow. This also applies to checking for symbolic assumptions
    (like `x.is_integer`), so this should also be avoided in class constructors.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 可能很昂贵的评估（比如应用符号身份）本身是不好的，因为可以使得创建一个没有做任何事情的表达式。这也适用于检查符号假设（比如`x.is_integer`），因此在类构造函数中也应该避免这样做。
- en: '**Don’t**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**不要**'
- en: '[PRE60]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**Do**'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '**要**'
- en: '[PRE61]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that not all the classes in SymPy currently follow this guideline very
    well, but it is something that we are improving.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，目前 SymPy 中并不是所有的类都很好地遵循这个准则，但这是我们正在改进的事情。
- en: Don’t Denest Collections
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要去除嵌套集合。
- en: Functions and classes that accept an arbitrary number of arguments should either
    accept the arguments directly, like `f(*args)`, or as a single argument, like
    `f(args)`. They should not try to support both at once.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接受任意数量参数的函数和类应该直接接受这些参数，例如 `f(*args)`，或者作为单个参数，例如 `f(args)`。它们不应同时尝试支持两者。
- en: The reason is that this makes it impossible to represented nested collections.
    For example, take the [`FiniteSet`](../modules/sets.html#sympy.sets.sets.FiniteSet
    "sympy.sets.sets.FiniteSet") class. It is constructed like `FiniteSet(x, y, z)`
    (i.e., using `*args`).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于这会使得嵌套集合的表示变得不可能。例如，考虑[`FiniteSet`](../modules/sets.html#sympy.sets.sets.FiniteSet
    "sympy.sets.sets.FiniteSet")类。它的构造方式类似于 `FiniteSet(x, y, z)`（即使用 `*args`）。
- en: '[PRE62]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'It might be tempting to also support `FiniteSet([1, 2, 3])`, to match the built-in
    `set`. However, doing so would make it impossible to represent a nested `FiniteSet`
    containing a single `FiniteSet`, like \(\{\{1, 2, 3\}\}\):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您也想支持 `FiniteSet([1, 2, 3])`，以匹配内置的 `set`。然而，这样做会使得无法表示包含单个 `FiniteSet` 的嵌套
    `FiniteSet`，例如 \(\{\{1, 2, 3\}\}\)：
- en: '[PRE63]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: As to whether `args` or `*args` should be used, if it is only possible for there
    to be a finite number of arguments, `*args` is generally better, as this makes
    things easier to deal with using the object’s [args](glossary.html#term-args),
    since `obj.args` will be the direct arguments of the class. However, if it is
    possible that you might want to support a symbolic infinite collection in addition
    to finite ones, like [`Integers`](../modules/sets.html#sympy.sets.fancysets.Integers
    "sympy.sets.fancysets.Integers") or [`Range`](../modules/sets.html#sympy.sets.fancysets.Range
    "sympy.sets.fancysets.Range"), then it is better to use `args` as this will be
    impossible to do with `*args`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用 `args` 还是 `*args`，如果只可能有有限数量的参数，通常使用 `*args` 更好，因为这样可以更容易地使用对象的[args](glossary.html#term-args)，因为
    `obj.args` 将是类的直接参数。然而，如果可能需要支持符号无限集合，例如[`Integers`](../modules/sets.html#sympy.sets.fancysets.Integers
    "sympy.sets.fancysets.Integers")或[`Range`](../modules/sets.html#sympy.sets.fancysets.Range
    "sympy.sets.fancysets.Range")，那么最好使用 `args`，因为这将不可能使用 `*args` 来实现。
- en: '### Avoid Storing Extra Attributes on an Object'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '### 避免在对象上存储额外属性'
- en: A common reason that you might want to create a custom SymPy object is that
    you want to store extra attributes on the object. However, doing this in a naive
    way, i.e., by simply storing the data as a Python attribute on the object, is
    almost always a bad idea.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能希望创建一个自定义的 SymPy 对象的常见原因是您想在对象上存储额外的属性。然而，以简单的方式，即仅将数据作为 Python 属性存储在对象上，几乎总是不明智的做法。
- en: SymPy does not expect objects to have extra data stored in them beyond what
    is in their [args](glossary.html#term-args). For instance, this breaks `==` checking,
    which only compares an objects `args`. See the [Don’t Overwrite __eq__](#best-practices-eq)
    section below for why it is a bad idea to override `__eq__`. This section and
    that one are closely related.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 不希望对象在其[args](glossary.html#term-args)之外存储额外的数据。例如，这会破坏 `==` 检查，因为它只比较对象的
    `args`。有关为什么覆盖 `__eq__` 是一个坏主意，请参阅下面的[不要覆盖 __eq__](#best-practices-eq)部分。这一节和那一节是密切相关的。
- en: 'Typically, there is a better way to do what you are trying to do, depending
    on the specific details of your situation:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，根据您的具体情况，有更好的方法来完成您想要做的事情：
- en: '**Store the extra data in the object’s `args`.** This is the best approach
    if the extra data you want to store is part of the *mathematical* description
    of your object.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将额外数据存储在对象的`args`中。** 如果您想要存储的额外数据是对象*数学*描述的一部分，这是最佳方法。'
- en: As long as the data is representable using other SymPy objects, it can be stored
    in `args`. Note that an object’s `args` should be usable to [recreate the object](#best-practices-args-invariants)
    (e.g., something like `YourObject(*instance.args)` should recreate `instance`).
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只要数据可以使用其他 SymPy 对象来表示，它就可以存储在 `args` 中。请注意，对象的 `args` 应该可以用于[重新创建对象](#best-practices-args-invariants)（例如，类似
    `YourObject(*instance.args)` 的东西应该可以重新创建 `instance`）。
- en: Additionally, it should be mentioned that it is not a good idea to subclass
    `Symbol` if you plan to store anything extra in `args`. `Symbol` is designed around
    having no `args`. You are better off subclassing `Function` (see [Writing Custom
    Functions](../guides/custom-functions.html#custom-functions)) or `Expr` directly.
    If you simply want to have two symbols that are distinct from one another, the
    best approach is often just to give them different names. If you are concerned
    about how they are printed, you can replace them with a more canonical name when
    it comes time to print things, or use a [custom printer](../modules/printing.html#module-printing).
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，应该提到，如果您计划在`args`中存储任何额外内容，则不建议子类化`Symbol`。`Symbol`的设计是围绕着没有`args`的。最好是直接子类化`Function`（参见[编写自定义函数](../guides/custom-functions.html#custom-functions)）或直接子类化`Expr`。如果您只是想要有两个彼此不同的符号，最好的方法通常是给它们不同的名称。如果您关心它们的打印方式，可以在打印时用更规范的名称替换它们，或者使用[自定义打印机](../modules/printing.html#module-printing)。
- en: '**Store the data about the object separately.** This is the best approach if
    the extra data is not directly related to an object’s mathematical properties.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单独存储关于对象的数据**。如果额外的数据与对象的数学属性无直接关系，则这是最佳方法。'
- en: 'Remember that SymPy objects are hashable, so they can easily be used as dictionary
    keys. So maintaining a separate dictionary of `{object: extra_data}` pairs is
    straightforward.'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '请记住，SymPy对象是可哈希的，因此可以轻松用作字典键。因此，维护一个独立的`{object: extra_data}`对的字典非常简单。'
- en: Note that some SymPy APIs already allow redefining how they operate on objects
    separately from the objects themselves. A big example of this is the [printers](glossary.html#term-Printing),
    which allow defining [custom printers](../modules/printing.html#module-printing)
    that change how any SymPy object is printed without modifying those object themselves.
    Functions like [`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify") and [`init_printing()`](../modules/interactive.html#sympy.interactive.printing.init_printing
    "sympy.interactive.printing.init_printing") allow passing in a custom printer.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，某些SymPy API已经允许重新定义它们在对象上操作的方式，而不影响对象本身。其中一个很好的例子是[打印机](glossary.html#term-Printing)，它允许定义[自定义打印机](../modules/printing.html#module-printing)，从而改变任何SymPy对象的打印方式而无需修改这些对象本身。像[`lambdify()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.lambdify
    "sympy.utilities.lambdify.lambdify")和[`init_printing()`](../modules/interactive.html#sympy.interactive.printing.init_printing
    "sympy.interactive.printing.init_printing")这样的函数允许传入自定义打印机。
- en: '**Represent the attribute using different subclasses.** This is often a good
    idea if there are only a few possible values for the attribute (e.g., a boolean
    flag). Code duplication can be avoided by using a common superclass.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用不同子类表示属性**。如果属性的可能值很少（例如布尔标志），这通常是一个好主意。通过使用一个共同的超类可以避免代码重复。'
- en: '**If the data you want to store is a Python function**, it’s best to just use
    as a method on the class. In many cases, the method may already fit into one of
    the [existing set of overridable SymPy methods](../guides/custom-functions.html#custom-functions).
    If you want to define how a function evaluates itself numerically, you can use
    [`implemented_function()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.implemented_function
    "sympy.utilities.lambdify.implemented_function").'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**如果您要存储的数据是一个Python函数**，最好将其作为类的方法使用。在许多情况下，该方法可能已经适合于[现有的可重写SymPy方法集](../guides/custom-functions.html#custom-functions)之一。如果您想定义如何对函数进行数值评估，可以使用[`implemented_function()`](../modules/utilities/lambdify.html#sympy.utilities.lambdify.implemented_function
    "sympy.utilities.lambdify.implemented_function")。'
- en: '**Represent the information using by modifying the object’s `func`.** This
    solution is much more complicated than the others, and should only be used when
    it is necessary. In some extreme cases, it is not possible to represent every
    mathematical aspect of an object using `args` alone. This can happen, for example,
    because of the limitation that [`args` should only contain `Basic` instances](#best-practices-args-invariants).
    It is still possible to create custom SymPy objects in these situations by using
    a custom [func](glossary.html#term-func) that is different from `type(expr)` (in
    this case, you would override `__eq__` on the `func` [rather than on the class](#best-practices-eq)).'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过修改对象的`func`表示信息。** 这种解决方案比其他方案复杂得多，只有在必要时才应使用。在一些极端情况下，无法仅通过`args`单独表示对象的每个数学方面。例如，由于限制[`args`应仅包含`Basic`实例](#best-practices-args-invariants)，在这种情况下，仍然可以通过使用与`type(expr)`不同的自定义[func](glossary.html#term-func)来创建自定义的
    SymPy 对象（在这种情况下，您将在`func`上而不是在类上重写`__eq__`）。'
- en: 'However, this sort of situation is rare.  ### Don’t Overwrite `__eq__`'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然而，这种情况很少见。### 不要重写`__eq__`
- en: When building a custom SymPy object, it is sometimes tempting to overwrite `__eq__`
    to define custom logic for the `==` operator. This is almost always a bad idea.
    Custom SymPy classes should leave `__eq__` undefined and use the default implementation
    in the `Basic` superclass.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建自定义 SymPy 对象时，有时会有一种诱惑，即重写`__eq__`来定义`==`运算符的自定义逻辑。这几乎总是一个坏主意。自定义的 SymPy
    类应该不定义`__eq__`，而是使用`Basic`超类中的默认实现。
- en: In SymPy, `==` compares objects using [structural equality](glossary.html#term-Structural-Equality).
    That is, `a == b` means that `a` and `b` are exactly the same object. They have
    the same type and the same [args](glossary.html#term-args). `==` does not perform
    any sort of *mathematical* equality checking. For example,
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SymPy 中，`==`使用[结构相等性](glossary.html#term-Structural-Equality)来比较对象。也就是说，`a
    == b`意味着`a`和`b`是完全相同的对象。它们具有相同的类型和相同的[args](glossary.html#term-args)。`==`不执行任何类型的*数学*相等检查。例如，
- en: '[PRE64]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`==` also always returns a boolean `True` or `False`. Symbolic equations can
    be represented with [`Eq`](../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality").'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`==`始终返回布尔值`True`或`False`。符号方程可以用[`Eq`](../modules/core.html#sympy.core.relational.Equality
    "sympy.core.relational.Equality")表示。'
- en: There are several reasons for this
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因造成了这种情况
- en: Mathematical equality checking can be very expensive to compute, and in general,
    it is [computationally impossible to determine](https://en.wikipedia.org/wiki/Richardson%27s_theorem).
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数学相等性检查可能非常昂贵，并且一般来说，[计算上不可能确定](https://en.wikipedia.org/wiki/Richardson%27s_theorem)。
- en: Python itself automatically uses `==` in various places and assumes that it
    returns a boolean and is inexpensive to compute. For example, if `b` is a builtin
    Python container like `list`, `dict`, or `set`, then `a in b` uses `==`.[[1]](#dict-footnote)
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 本身在各处自动使用`==`，并假定它返回布尔值且计算成本低廉。例如，如果`b`是内置的 Python 容器如`list`、`dict`或`set`，那么`a
    in b`使用`==`。[[1]](#dict-footnote)
- en: SymPy internally uses `==` all over the place, both explicitly and implicitly
    via things like `in` or dictionary keys. This usage all implicitly assumes that
    `==` operates structurally.
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SymPy 在内部各处都使用`==`，明确地和隐含地，例如通过`in`或字典键。这种使用隐含地假定`==`操作是结构化的。
- en: In affect, *structural equality* means that if `a == b` is `True`, then `a`
    and `b` are for all intents and purposes the same object. This is because all
    SymPy objects are [immutable](glossary.html#term-Immutable). When `a ==` , any
    SymPy function may freely replace `a` with `b` in any subexpression.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，*结构相等性*意味着如果`a == b`为`True`，那么在所有意义上`a`和`b`是相同的对象。这是因为所有的 SymPy 对象都是[不可变的](glossary.html#term-Immutable)。当`a
    == b`时，任何 SymPy 函数都可以自由地在任何子表达式中用`b`替换`a`。
- en: The default `__eq__` method on [Basic](glossary.html#term-Basic) checks if the
    two objects have the same type and the same `args`. There are also many parts
    of SymPy that implicitly assume that if two objects are equal, then they have
    the same `args`. Therefore, it is not a good idea to try to override `__eq__`
    as a way to avoid storing some identifying information about an object in its
    `args`. The `args` of an object should contain everything that is needed to recreate
    it (see [args](glossary.html#term-args)). Note that it is possible for an objects
    constructor to accept multiple forms of arguments, so long as it accepts the form
    stored in `args` (e.g., it is perfectly fine for some args to have default values).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[Basic](glossary.html#term-Basic)上的默认`__eq__`方法检查两个对象是否具有相同的类型和相同的`args`。此外，SymPy的许多部分隐含地假定如果两个对象相等，则它们具有相同的`args`。因此，试图覆盖`__eq__`以避免在其`args`中存储某些标识信息并不是一个好主意。一个对象的`args`应包含重新创建它所需的一切（请参阅[args](glossary.html#term-args)）。请注意，对象的构造函数可以接受多种形式的参数，只要接受存储在`args`中的形式即可（例如，某些args可以具有默认值是完全可以的）。'
- en: 'Here are some examples of reasons you might be tempted to override `__eq__`
    and the preferred alternatives:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你可能会想要覆盖`__eq__`的原因及其首选替代方案的示例：
- en: To make `==` apply some smarter equality check than purely structural equality.
    As noted above, this is a bad idea because too many things implicitly assume `==`
    works structurally only. Instead, use a function or method to implement the smarter
    equality checking (for example, the `equals` method).
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使`==`应用比纯结构相等更智能的相等检查。如上所述，这是一个坏主意，因为太多事情都隐含地假定`==`只能结构上工作。相反，使用函数或方法来实现更智能的相等检查（例如，`equals`方法）。
- en: Another option is to define a [canonicalization](glossary.html#term-Canonicalize)
    method that puts objects into canonical form (e.g., via `doit`), so that, for
    instance, `x.doit() == y.doit()` is true whenever `x` and `y` are mathematically
    equal. This is not always possible because not every type of object has a computable
    canonical form, but it is a convenient approach when one does exist.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一种选择是定义一个[规范化](glossary.html#term-Canonicalize)方法，将对象放入规范形式（例如，通过`doit`），以便例如，当数学上相等时`x.doit()
    == y.doit()`为真。这并非总是可能的，因为并非每种类型的对象都具有可计算的规范形式，但在存在时这是一个方便的方法。
- en: To make `==` check for some additional attributes beyond those stored in the
    `args` of an expression. See the [Avoid Storing Extra Attributes on an Object](#best-practices-extra-attributes)
    section above for more details on why it’s a bad idea to directly store extra
    attributes on a SymPy object, and what the best alternatives are.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`==`检查除表达式`args`中存储的属性外的一些附加属性。有关为什么直接在SymPy对象上存储额外属性是一个坏主意以及最佳替代方案的更多详细信息，请参阅上文中的[避免在对象上存储额外属性](#best-practices-extra-attributes)部分。
- en: To make `==` compare equal to some non-SymPy object. It is preferable to extend
    `sympify` to be able to convert this object into the SymPy object. The default
    `__eq__` implementation will automatically call `sympify` on the other argument
    if it isn’t a `Basic` instance (e.g., `Integer(1) == int(1)` gives `True`). It
    is possible to extend `sympify` both for objects you control by defining a `_sympy_`
    method and for objects you do not control by extending the `converter` dictionary.
    See the [`sympify()`](../modules/core.html#sympy.core.sympify.sympify "sympy.core.sympify.sympify")
    documentation for more details.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`==`与某些非SymPy对象相等。最好扩展`sympify`以能够将该对象转换为SymPy对象。如果另一个参数不是`Basic`实例（例如，`Integer(1)
    == int(1)`会返回`True`），则默认的`__eq__`实现将自动调用`sympify`。对于您通过定义`_sympy_`方法控制的对象和通过扩展`converter`字典控制的对象，都可以扩展`sympify`。有关更多详细信息，请参见[`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify")文档。
- en: Avoiding Infinite Recursion from Assumptions Handlers
  id: totrans-255
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免假设处理程序的无限递归
- en: 'When writing assumptions handlers on custom functions like `_eval_is_positive`
    (see the [custom functions guide](../guides/custom-functions.html#custom-functions-assumptions)
    for details on how to do this), there are two important things to keep in mind:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 当在自定义函数上编写假设处理程序时，比如`_eval_is_positive`（详见[自定义函数指南](../guides/custom-functions.html#custom-functions-assumptions)中如何做此操作的详细信息），有两件重要的事情需要牢记：
- en: '**Firstly, avoid creating new expressions inside of an assumption handler.
    You should always pull apart the arguments of a function directly instead.** The
    reason is that creating a new expression could itself result in an assumptions
    query. This can easily lead to infinite recursion. And even when it doesn’t, creating
    a new expression that itself could lead to many recursive assumptions queries
    is bad for performance compared to querying the desired property more directly.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**首先，在假设处理器内部避免创建新表达式。你应该直接解析函数的参数。** 这是因为创建新表达式本身可能会导致假设查询。这很容易导致无限递归。即使没有，创建一个可能会导致多个递归假设查询的新表达式，与直接查询所需属性相比，对性能影响很不利。'
- en: This generally means using methods like [`as_independent()`](../modules/core.html#sympy.core.expr.Expr.as_independent
    "sympy.core.expr.Expr.as_independent") or `{meth}`~.as_coeff_mul`and checking
    the`args` of expressions directly (see the [custom functions guide](../guides/custom-functions.html#custom-functions-assumptions)
    for an example).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通常意味着使用[`as_independent()`](../modules/core.html#sympy.core.expr.Expr.as_independent
    "sympy.core.expr.Expr.as_independent")或`{meth}`~.as_coeff_mul`并直接检查表达式的`args`（参见[自定义函数指南](../guides/custom-functions.html#custom-functions-assumptions)中的示例）。
- en: Secondly, **do not recursively evaluate assumptions on `self` in assumptions
    handlers**. Assumptions handlers should only check for assumptions on `self.args`.
    The global assumptions system will automatically handle implications between different
    assumptions.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，在假设处理器中**不要对`self`递归评估假设**。假设处理器应仅检查`self.args`上的假设。全局假设系统将自动处理不同假设之间的含义。
- en: For example, you may be tempted to write something like
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可能会被诱惑写出类似于以下的内容
- en: '[PRE65]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: However, the `if self.is_real is False` check is completely unnecessary. The
    assumptions system already knows that `integer` implies `real`, and it will not
    bother checking `is_integer` if it already knows that `is_real` is False.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，检查`if self.is_real is False`是完全不必要的。假设系统已经知道`integer`蕴含`real`，如果已经知道`is_real`为False，它将不会检查`is_integer`。
- en: 'If you define the function this way, it will lead to an infinite recursion:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果以这种方式定义函数，将导致无限递归：
- en: '[PRE66]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Instead, define the handler based on the arguments of the function only:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，仅基于函数参数定义处理器：
- en: '[PRE67]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '* * *'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
