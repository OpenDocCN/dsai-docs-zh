- en: numpy.result_type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.result_type.html](https://numpy.org/doc/1.26/reference/generated/numpy.result_type.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Returns the type that results from applying the NumPy type promotion rules to
    the arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Type promotion in NumPy works similarly to the rules in languages like C++,
    with some slight differences. When both scalars and arrays are used, the array’s
    type takes precedence and the actual value of the scalar is taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: For example, calculating 3*a, where a is an array of 32-bit floats, intuitively
    should result in a 32-bit float output. If the 3 is a 32-bit integer, the NumPy
    rules indicate it can’t convert losslessly into a 32-bit float, so a 64-bit float
    should be the result type. By examining the value of the constant, ‘3’, we see
    that it fits in an 8-bit integer, which can be cast losslessly into the 32-bit
    float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**arrays_and_dtypes**list of arrays and dtypes'
  prefs: []
  type: TYPE_NORMAL
- en: The operands of some operation whose result type is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**out**dtype'
  prefs: []
  type: TYPE_NORMAL
- en: The result type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`dtype`](numpy.dtype.html#numpy.dtype "numpy.dtype"), [`promote_types`](numpy.promote_types.html#numpy.promote_types
    "numpy.promote_types"), [`min_scalar_type`](numpy.min_scalar_type.html#numpy.min_scalar_type
    "numpy.min_scalar_type"), [`can_cast`](numpy.can_cast.html#numpy.can_cast "numpy.can_cast")'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.6.0.
  prefs: []
  type: TYPE_NORMAL
- en: The specific algorithm used is as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Categories are determined by first checking which of boolean, integer (int/uint),
    or floating point (float/complex) the maximum kind of all the arrays and the scalars
    are.
  prefs: []
  type: TYPE_NORMAL
- en: If there are only scalars or the maximum category of the scalars is higher than
    the maximum category of the arrays, the data types are combined with [`promote_types`](numpy.promote_types.html#numpy.promote_types
    "numpy.promote_types") to produce the return value.
  prefs: []
  type: TYPE_NORMAL
- en: Otherwise, [`min_scalar_type`](numpy.min_scalar_type.html#numpy.min_scalar_type
    "numpy.min_scalar_type") is called on each scalar, and the resulting data types
    are all combined with [`promote_types`](numpy.promote_types.html#numpy.promote_types
    "numpy.promote_types") to produce the return value.
  prefs: []
  type: TYPE_NORMAL
- en: The set of int values is not a subset of the uint values for types with the
    same number of bits, something not reflected in [`min_scalar_type`](numpy.min_scalar_type.html#numpy.min_scalar_type
    "numpy.min_scalar_type"), but handled as a special case in [`result_type`](#numpy.result_type
    "numpy.result_type").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
