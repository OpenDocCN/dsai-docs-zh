- en: N-dim array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/tensor/array.html](https://docs.sympy.org/latest/modules/tensor/array.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: N-dim array module for SymPy.
  prefs: []
  type: TYPE_NORMAL
- en: Four classes are provided to handle N-dim arrays, given by the combinations
    dense/sparse (i.e. whether to store all elements or only the non-zero ones in
    memory) and mutable/immutable (immutable classes are SymPy objects, but cannot
    change after they have been created).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following examples show the usage of `Array`. This is an abbreviation for
    `ImmutableDenseNDimArray`, that is an immutable and dense N-dim array, the other
    classes are analogous. For mutable classes it is also possible to change element
    values after the object has been constructed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Array construction can detect the shape of nested lists and tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise one could pass a 1-dim array followed by a shape tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Slice support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Elementwise derivative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiplication with other SymPy expressions is applied elementwisely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply a function to each element of the N-dim array, use `applyfunc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'N-dim arrays can be converted to nested lists by the `tolist()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the rank is 2, it is possible to convert them to matrices with `tomatrix()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Products and contractions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tensor product between arrays \(A_{i_1,\ldots,i_n}\) and \(B_{j_1,\ldots,j_m}\)
    creates the combined array \(P = A \otimes B\) defined as
  prefs: []
  type: TYPE_NORMAL
- en: \(P_{i_1,\ldots,i_n,j_1,\ldots,j_m} := A_{i_1,\ldots,i_n}\cdot B_{j_1,\ldots,j_m}.\)
  prefs: []
  type: TYPE_NORMAL
- en: 'It is available through `tensorproduct(...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In case you don’t want to evaluate the tensor product immediately, you can
    use `ArrayTensorProduct`, which creates an unevaluated tensor product expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Calling `.as_explicit()` on `ArrayTensorProduct` is equivalent to just calling
    `tensorproduct(...)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Tensor product between a rank-1 array and a matrix creates a rank-3 array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to get back \(A_0 \otimes \mathbf{1}\) one can access \(p_{0,m,n}\) by
    slicing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tensor contraction sums over the specified axes, for example contracting positions
    \(a\) and \(b\) means
  prefs: []
  type: TYPE_NORMAL
- en: \(A_{i_1,\ldots,i_a,\ldots,i_b,\ldots,i_n} \implies \sum_k A_{i_1,\ldots,k,\ldots,k,\ldots,i_n}\)
  prefs: []
  type: TYPE_NORMAL
- en: Remember that Python indexing is zero starting, to contract the a-th and b-th
    axes it is therefore necessary to specify \(a-1\) and \(b-1\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The matrix trace is equivalent to the contraction of a rank-2 array:'
  prefs: []
  type: TYPE_NORMAL
- en: \(A_{m,n} \implies \sum_k A_{k,k}\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an expression representing a tensor contraction that does not get
    evaluated immediately, use `ArrayContraction`, which is equivalent to `tensorcontraction(...)`
    if it is followed by `.as_explicit()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Matrix product is equivalent to a tensor product of two rank-2 arrays, followed
    by a contraction of the 2nd and 3rd axes (in Python indexing axes number 1, 2).
  prefs: []
  type: TYPE_NORMAL
- en: \(A_{m,n}\cdot B_{i,j} \implies \sum_k A_{m, k}\cdot B_{k, j}\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'One may verify that the matrix product is equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: or equivalently
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Diagonal operator
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `tensordiagonal` function acts in a similar manner as `tensorcontraction`,
    but the joined indices are not summed over, for example diagonalizing positions
    \(a\) and \(b\) means
  prefs: []
  type: TYPE_NORMAL
- en: \(A_{i_1,\ldots,i_a,\ldots,i_b,\ldots,i_n} \implies A_{i_1,\ldots,k,\ldots,k,\ldots,i_n}
    \implies \tilde{A}_{i_1,\ldots,i_{a-1},i_{a+1},\ldots,i_{b-1},i_{b+1},\ldots,i_n,k}\)
  prefs: []
  type: TYPE_NORMAL
- en: where \(\tilde{A}\) is the array equivalent to the diagonal of \(A\) at positions
    \(a\) and \(b\) moved to the last index slot.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compare the difference between contraction and diagonal operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In short, no summation occurs with `tensordiagonal`.
  prefs: []
  type: TYPE_NORMAL
- en: Derivatives by array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The usual derivative operation may be extended to support derivation with respect
    to arrays, provided that all elements in the that array are symbols or expressions
    suitable for derivations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of a derivative by an array is as follows: given the array \(A_{i_1,
    \ldots, i_N}\) and the array \(X_{j_1, \ldots, j_M}\) the derivative of arrays
    will return a new array \(B\) defined by'
  prefs: []
  type: TYPE_NORMAL
- en: \(B_{j_1,\ldots,j_M,i_1,\ldots,i_N} := \frac{\partial A_{i_1,\ldots,i_N}}{\partial
    X_{j_1,\ldots,j_M}}\)
  prefs: []
  type: TYPE_NORMAL
- en: 'The function `derive_by_array` performs such an operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With scalars, it behaves exactly as the ordinary derivative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Scalar derived by an array basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Deriving array by an array basis: \(B^{nm} := \frac{\partial A^m}{\partial
    x^n}\)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Contraction of the resulting array: \(\sum_m \frac{\partial A^m}{\partial x^m}\)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Derivative by arrays. Supports both arrays and scalars.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent operator for array expressions is `array_derive`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Given the array \(A_{i_1, \ldots, i_N}\) and the array \(X_{j_1, \ldots, j_M}\)
    this function will return a new array \(B\) defined by
  prefs: []
  type: TYPE_NORMAL
- en: \(B_{j_1,\ldots,j_M,i_1,\ldots,i_N} := \frac{\partial A_{i_1,\ldots,i_N}}{\partial
    X_{j_1,\ldots,j_M}}\)
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Permutes the indices of an array.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter specifies the permutation of the indices.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent operator for array expressions is `PermuteDims`, which can be
    used to keep the expression unevaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the array is of second order, `transpose` can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Examples on higher dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative way to specify the same permutations as in the previous lines
    involves passing the *old* and *new* indices, either as a list or as a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`Permutation` objects are also allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.tensor.array.expressions.array_expressions.PermuteDims`](array_expressions.html#sympy.tensor.array.expressions.PermuteDims
    "sympy.tensor.array.expressions.array_expressions.PermuteDims")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Contraction of an array-like object on the specified axes.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent operator for array expressions is `ArrayContraction`, which can
    be used to keep the expression unevaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Matrix multiplication may be emulated with a proper combination of `tensorcontraction`
    and `tensorproduct`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.tensor.array.expressions.array_expressions.ArrayContraction`](array_expressions.html#sympy.tensor.array.expressions.ArrayContraction
    "sympy.tensor.array.expressions.array_expressions.ArrayContraction")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Tensor product among scalars or array-like objects.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent operator for array expressions is `ArrayTensorProduct`, which
    can be used to keep the expression unevaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Applying this function on two matrices will result in a rank 4 array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.tensor.array.expressions.array_expressions.ArrayTensorProduct`](array_expressions.html#sympy.tensor.array.expressions.ArrayTensorProduct
    "sympy.tensor.array.expressions.array_expressions.ArrayTensorProduct")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Diagonalization of an array-like object on the specified axes.
  prefs: []
  type: TYPE_NORMAL
- en: This is equivalent to multiplying the expression by Kronecker deltas uniting
    the axes.
  prefs: []
  type: TYPE_NORMAL
- en: The diagonal indices are put at the end of the axes.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent operator for array expressions is `ArrayDiagonal`, which can
    be used to keep the expression unevaluated.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '`tensordiagonal` acting on a 2-dimensional array by axes 0 and 1 is equivalent
    to the diagonal of the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In case of higher dimensional arrays, the diagonalized out dimensions are appended
    removed and appended as a single dimension at the end:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.tensor.array.expressions.array_expressions.ArrayDiagonal`](array_expressions.html#sympy.tensor.array.expressions.ArrayDiagonal
    "sympy.tensor.array.expressions.array_expressions.ArrayDiagonal")'
  prefs: []
  type: TYPE_NORMAL
