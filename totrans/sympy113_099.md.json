["```py\nsympy.core.sympify.sympify(a, locals=None, convert_xor=True, strict=False, rational=False, evaluate=None)\n```", "```py\n>>> from sympy import sympify \n```", "```py\n>>> sympify(2).is_integer\nTrue\n>>> sympify(2).is_real\nTrue \n```", "```py\n>>> sympify(2.0).is_real\nTrue\n>>> sympify(\"2.0\").is_real\nTrue\n>>> sympify(\"2e-45\").is_real\nTrue \n```", "```py\n>>> sympify(\"x***2\")\nTraceback (most recent call last):\n...\nSympifyError: SympifyError: \"could not parse 'x***2'\" \n```", "```py\n>>> sympify(\"2x+1\")\nTraceback (most recent call last):\n...\nSympifyError: Sympify of expression 'could not parse '2x+1'' failed \n```", "```py\n>>> from sympy.parsing.sympy_parser import parse_expr\n>>> parse_expr(\"2x+1\", transformations=\"all\")\n2*x + 1 \n```", "```py\n>>> s = 'bitcount(42)'\n>>> sympify(s)\nbitcount(42)\n>>> sympify(\"O(x)\")\nO(x)\n>>> sympify(\"O + 1\")\nTraceback (most recent call last):\n...\nTypeError: unbound method... \n```", "```py\n>>> ns = {}\n>>> exec('from sympy.core.evalf import bitcount', ns)\n>>> sympify(s, locals=ns)\n6 \n```", "```py\n>>> from sympy import Symbol\n>>> ns[\"O\"] = Symbol(\"O\")  # method 1\n>>> exec('from sympy.abc import O', ns)  # method 2\n>>> ns.update(dict(O=Symbol(\"O\")))  # method 3\n>>> sympify(\"O + 1\", locals=ns)\nO + 1 \n```", "```py\n>>> from sympy.abc import _clash1\n>>> set(_clash1)  # if this fails, see issue #23903\n{'E', 'I', 'N', 'O', 'Q', 'S'}\n>>> sympify('I & Q', _clash1)\nI & Q \n```", "```py\n>>> print(sympify(None))\nNone\n>>> sympify(None, strict=True)\nTraceback (most recent call last):\n...\nSympifyError: SympifyError: None \n```", "```py\n>>> sympify('2**2 / 3 + 5')\n19/3\n>>> sympify('2**2 / 3 + 5', evaluate=False)\n2**2/3 + 5\n>>> sympify('4/2+7', evaluate=True)\n9\n>>> sympify('4/2+7', evaluate=False)\n4/2 + 7\n>>> sympify(4/2+7, evaluate=False)\n9.00000000000000 \n```", "```py\n>>> from sympy import Matrix\n>>> class MyList1(object):\n...     def __iter__(self):\n...         yield 1\n...         yield 2\n...         return\n...     def __getitem__(self, i): return list(self)[i]\n...     def _sympy_(self): return Matrix(self)\n>>> sympify(MyList1())\nMatrix([\n[1],\n[2]]) \n```", "```py\n>>> class MyList2(object):   # XXX Do not do this if you control the class!\n...     def __iter__(self):  #     Use _sympy_!\n...         yield 1\n...         yield 2\n...         return\n...     def __getitem__(self, i): return list(self)[i]\n>>> from sympy.core.sympify import converter\n>>> converter[MyList2] = lambda x: Matrix(x)\n>>> sympify(MyList2())\nMatrix([\n[1],\n[2]]) \n```", "```py\n>>> sympify('x^y',convert_xor=True)\nx**y\n>>> sympify('x^y',convert_xor=False)\nx ^ y \n```", "```py\n>>> sympify('0.1',rational=False)\n0.1\n>>> sympify('0.1',rational=True)\n1/10 \n```", "```py\n>>> from sympy.core.sympify import kernS\n>>> from sympy.abc import x\n>>> -2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1\n-1\n>>> s = '-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1'\n>>> sympify(s)\n-1\n>>> kernS(s)\n-2*(-(-x + 1/x)/(x*(x - 1/x)**2) - 1/(x*(x - 1/x))) - 1 \n```", "```py\n>>> from sympy import I\n>>> I.is_algebraic\nTrue\n>>> I.is_real\nFalse\n>>> I.is_prime\nFalse \n```", "```py\n>>> from sympy import Symbol\n>>> x = Symbol('x', real=True); x\nx\n>>> x.is_real\nTrue\n>>> x.is_complex\nTrue \n```", "```py\n>>> from sympy.core.assumptions import assumptions\n>>> x = Symbol('x',positive=True)\n>>> assumptions(x + I)\n{'commutative': True, 'complex': True, 'composite': False, 'even':\nFalse, 'extended_negative': False, 'extended_nonnegative': False,\n'extended_nonpositive': False, 'extended_nonzero': False,\n'extended_positive': False, 'extended_real': False, 'finite': True,\n'imaginary': False, 'infinite': False, 'integer': False, 'irrational':\nFalse, 'negative': False, 'noninteger': False, 'nonnegative': False,\n'nonpositive': False, 'nonzero': False, 'odd': False, 'positive':\nFalse, 'prime': False, 'rational': False, 'real': False, 'zero':\nFalse} \n```", "```py\n>>> eq = x**2 + I\n>>> eq._assumptions\n{}\n>>> eq.is_finite\nTrue\n>>> eq._assumptions\n{'finite': True, 'infinite': False} \n```", "```py\n>>> Symbol('x', prime=True, even=True)._assumptions_orig\n{'even': True, 'prime': True} \n```", "```py\nsympy.core.cache.__cacheit(maxsize)\n```", "```py\n>>> from sympy import cacheit\n>>> @cacheit\n... def f(a, b):\n...    return a+b \n```", "```py\n>>> @cacheit\n... def f(a, b): # noqa: F811\n...    return [a, b] # <-- WRONG, returns mutable object \n```", "```py\nclass sympy.core.basic.Basic(*args)\n```", "```py\n>>> from sympy import cot\n>>> from sympy.abc import x, y \n```", "```py\n>>> cot(x).args\n(x,) \n```", "```py\n>>> cot(x).args[0]\nx \n```", "```py\n>>> (x*y).args\n(x, y) \n```", "```py\n>>> (x*y).args[1]\ny \n```", "```py\n>>> cot(x)._args    # do not use this, use cot(x).args instead\n(x,) \n```", "```py\n    >>> from sympy import Basic, Matrix, sympify\n    >>> A = Matrix([[1, 2], [3, 4]]).as_mutable()\n    >>> isinstance(A, Basic)\n    False \n    ```", "```py\n    >>> B = sympify(A)\n    >>> isinstance(B, Basic)\n    True \n    ```", "```py\nproperty args: tuple[Basic, ...]\n```", "```py\n>>> from sympy import cot\n>>> from sympy.abc import x, y \n```", "```py\n>>> cot(x).args\n(x,) \n```", "```py\n>>> cot(x).args[0]\nx \n```", "```py\n>>> (x*y).args\n(x, y) \n```", "```py\n>>> (x*y).args[1]\ny \n```", "```py\nas_content_primitive(radical=False, clear=True)\n```", "```py\nas_dummy()\n```", "```py\n>>> from sympy import Integral, Symbol\n>>> from sympy.abc import x\n>>> r = Symbol('r', real=True)\n>>> Integral(r, (r, x)).as_dummy()\nIntegral(_0, (_0, x))\n>>> _.variables[0].is_real is None\nTrue\n>>> r.as_dummy()\n_r \n```", "```py\nproperty assumptions0\n```", "```py\n>>> from sympy import Symbol\n>>> from sympy.abc import x\n>>> x.assumptions0\n{'commutative': True}\n>>> x = Symbol(\"x\", positive=True)\n>>> x.assumptions0\n{'commutative': True, 'complex': True, 'extended_negative': False,\n 'extended_nonnegative': True, 'extended_nonpositive': False,\n 'extended_nonzero': True, 'extended_positive': True, 'extended_real':\n True, 'finite': True, 'hermitian': True, 'imaginary': False,\n 'infinite': False, 'negative': False, 'nonnegative': True,\n 'nonpositive': False, 'nonzero': True, 'positive': True, 'real':\n True, 'zero': False} \n```", "```py\natoms(*types)\n```", "```py\n>>> from sympy import I, pi, sin\n>>> from sympy.abc import x, y\n>>> (1 + x + 2*sin(y + I*pi)).atoms()\n{1, 2, I, pi, x, y} \n```", "```py\n>>> from sympy import Number, NumberSymbol, Symbol\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Symbol)\n{x, y} \n```", "```py\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number)\n{1, 2} \n```", "```py\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol)\n{1, 2, pi} \n```", "```py\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Number, NumberSymbol, I)\n{1, 2, I, pi} \n```", "```py\n>>> (1 + x + 2*sin(y + I*pi)).atoms(x) # x is a Symbol\n{x, y} \n```", "```py\n>>> from sympy import S\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(1))\n{1} \n```", "```py\n>>> (1 + x + 2*sin(y + I*pi)).atoms(S(2))\n{1, 2} \n```", "```py\n>>> from sympy import Function, Mul\n>>> from sympy.core.function import AppliedUndef\n>>> f = Function('f')\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(Function)\n{f(x), sin(y + I*pi)}\n>>> (1 + f(x) + 2*sin(y + I*pi)).atoms(AppliedUndef)\n{f(x)} \n```", "```py\n>>> (1 + x + 2*sin(y + I*pi)).atoms(Mul)\n{I*pi, 2*sin(y + I*pi)} \n```", "```py\nproperty canonical_variables\n```", "```py\n>>> from sympy import Lambda\n>>> from sympy.abc import x\n>>> Lambda(x, 2*x).canonical_variables\n{x: _0} \n```", "```py\nclassmethod class_key()\n```", "```py\ncompare(other)\n```", "```py\n>>> from sympy.abc import x, y\n>>> x.compare(y)\n-1\n>>> x.compare(x)\n0\n>>> y.compare(x)\n1 \n```", "```py\ncount(query)\n```", "```py\ncount_ops(visual=None)\n```", "```py\ndoit(**hints)\n```", "```py\n>>> from sympy import Integral\n>>> from sympy.abc import x \n```", "```py\n>>> 2*Integral(x, x)\n2*Integral(x, x) \n```", "```py\n>>> (2*Integral(x, x)).doit()\nx**2 \n```", "```py\n>>> (2*Integral(x, x)).doit(deep=False)\n2*Integral(x, x) \n```", "```py\ndummy_eq(other, symbol=None)\n```", "```py\n>>> from sympy import Dummy\n>>> from sympy.abc import x, y \n```", "```py\n>>> u = Dummy('u') \n```", "```py\n>>> (u**2 + 1).dummy_eq(x**2 + 1)\nTrue\n>>> (u**2 + 1) == (x**2 + 1)\nFalse \n```", "```py\n>>> (u**2 + y).dummy_eq(x**2 + y, x)\nTrue\n>>> (u**2 + y).dummy_eq(x**2 + y, y)\nFalse \n```", "```py\nfind(query, group=False)\n```", "```py\nproperty free_symbols: set[Basic]\n```", "```py\nclassmethod fromiter(args, **assumptions)\n```", "```py\n>>> from sympy import Tuple\n>>> Tuple.fromiter(i for i in range(5))\n(0, 1, 2, 3, 4) \n```", "```py\nproperty func\n```", "```py\n>> x == x.func(*x.args) \n```", "```py\n>>> from sympy.abc import x\n>>> a = 2*x\n>>> a.func\n<class 'sympy.core.mul.Mul'>\n>>> a.args\n(2, x)\n>>> a.func(*a.args)\n2*x\n>>> a == a.func(*a.args)\nTrue \n```", "```py\nhas(*patterns)\n```", "```py\n>>> from sympy import sin\n>>> from sympy.abc import x, y, z\n>>> (x**2 + sin(x*y)).has(z)\nFalse\n>>> (x**2 + sin(x*y)).has(x, y, z)\nTrue\n>>> x.has(x)\nTrue \n```", "```py\n>>> from sympy import Interval\n>>> i = Interval.Lopen(0, 5); i\nInterval.Lopen(0, 5)\n>>> i.args\n(0, 5, True, False)\n>>> i.has(4)  # there is no \"4\" in the arguments\nFalse\n>>> i.has(0)  # there *is* a \"0\" in the arguments\nTrue \n```", "```py\n>>> i.contains(4)\nTrue\n>>> i.contains(0)\nFalse \n```", "```py\n>>> x.has()\nFalse \n```", "```py\nhas_free(*patterns)\n```", "```py\n>>> from sympy import Integral, Function\n>>> from sympy.abc import x, y\n>>> f = Function('f')\n>>> g = Function('g')\n>>> expr = Integral(f(x), (f(x), 1, g(y)))\n>>> expr.free_symbols\n{y}\n>>> expr.has_free(g(y))\nTrue\n>>> expr.has_free(*(x, f(x)))\nFalse \n```", "```py\n>>> expr.has_free(g)\nTrue\n>>> (x + y + 1).has_free(y + 1)\nTrue \n```", "```py\nhas_xfree(s: set[Basic])\n```", "```py\n>>> from sympy import Function\n>>> from sympy.abc import x, y\n>>> f = Function('f')\n>>> f(x).has_xfree({f})\nFalse\n>>> f(x).has_xfree({f(x)})\nTrue\n>>> f(x + 1).has_xfree({x})\nTrue\n>>> f(x + 1).has_xfree({x + 1})\nTrue\n>>> f(x + y + 1).has_xfree({x + 1})\nFalse \n```", "```py\nproperty is_comparable\n```", "```py\n>>> from sympy import exp_polar, pi, I\n>>> (I*exp_polar(I*pi/2)).is_comparable\nTrue\n>>> (I*exp_polar(I*pi*2)).is_comparable\nFalse \n```", "```py\n>>> e = 2**pi*(1 + 2**pi)\n>>> dif = e - e.expand()\n>>> dif.is_comparable\nFalse\n>>> dif.n(2)._prec\n1 \n```", "```py\nis_same(b, approx=None)\n```", "```py\n>>> from sympy import S\n>>> 2.0 == S(2)\nFalse\n>>> 0.5 == S.Half\nFalse \n```", "```py\n>>> from sympy import Float\n>>> from sympy.core.numbers import equal_valued\n>>> (S.Half/4).is_same(Float(0.125, 1), equal_valued)\nTrue\n>>> Float(1, 2).is_same(Float(1, 10), equal_valued)\nTrue \n```", "```py\n>>> Float(0.1, 9).is_same(Float(0.1, 10), equal_valued)\nFalse \n```", "```py\n>>> import math\n>>> Float(0.1, 9).is_same(Float(0.1, 10), math.isclose)\nTrue \n```", "```py\n>>> from sympy import eye, Basic\n>>> eye(1) == S(eye(1))  # mutable vs immutable\nTrue\n>>> Basic.is_same(eye(1), S(eye(1)))\nFalse \n```", "```py\nmatch(pattern, old=False)\n```", "```py\npattern.xreplace(self.match(pattern)) == self \n```", "```py\n>>> from sympy import Wild, Sum\n>>> from sympy.abc import x, y\n>>> p = Wild(\"p\")\n>>> q = Wild(\"q\")\n>>> r = Wild(\"r\")\n>>> e = (x+y)**(x+y)\n>>> e.match(p**p)\n{p_: x + y}\n>>> e.match(p**q)\n{p_: x + y, q_: x + y}\n>>> e = (2*x)**2\n>>> e.match(p*q**r)\n{p_: 4, q_: x, r_: 2}\n>>> (p*q**r).xreplace(e.match(p*q**r))\n4*x**2 \n```", "```py\n>>> Sum(x, (x, 1, 2)).match(Sum(y, (y, 1, p)))\n{p_: 2} \n```", "```py\n>>> Sum(x, (x, 1, 2)).match(Sum(q, (q, 1, p)))\n{p_: 2, q_: x} \n```", "```py\n>>> (x - 2).match(p - x, old=True)\n{p_: 2*x - 2}\n>>> (2/x).match(p*x, old=True)\n{p_: 2/x**2} \n```", "```py\nmatches(expr, repl_dict=None, old=False)\n```", "```py\n>>> from sympy import symbols, Wild, Basic\n>>> a, b, c = symbols('a b c')\n>>> x = Wild('x')\n>>> Basic(a + x, x).matches(Basic(a + b, c)) is None\nTrue\n>>> Basic(a + x, x).matches(Basic(a + b + c, b + c))\n{x_: b + c} \n```", "```py\nrcall(*args)\n```", "```py\n>>> from sympy import Lambda\n>>> from sympy.abc import x, y, z\n>>> (x + Lambda(y, 2*y)).rcall(z)\nx + 2*z \n```", "```py\nrefine(assumption=True)\n```", "```py\nreplace(query, value, map=False, simultaneous=True, exact=None)\n```", "```py\n>>> from sympy import log, sin, cos, tan, Wild, Mul, Add\n>>> from sympy.abc import x, y\n>>> f = log(sin(x)) + tan(sin(x**2)) \n```", "```py\n>>> f.replace(sin, cos)\nlog(cos(x)) + tan(cos(x**2))\n>>> sin(x).replace(sin, cos, map=True)\n(cos(x), {sin(x): cos(x)})\n>>> (x*y).replace(Mul, Add)\nx + y \n```", "```py\n>>> f.replace(sin, lambda arg: sin(2*arg))\nlog(sin(2*x)) + tan(sin(2*x**2))\n>>> (x*y).replace(Mul, lambda *args: sin(2*Mul(*args)))\nsin(2*x*y) \n```", "```py\n>>> a, b = map(Wild, 'ab')\n>>> f.replace(sin(a), tan(a))\nlog(tan(x)) + tan(tan(x**2))\n>>> f.replace(sin(a), tan(a/2))\nlog(tan(x/2)) + tan(tan(x**2/2))\n>>> f.replace(sin(a), a)\nlog(x) + tan(x**2)\n>>> (x*y).replace(a*x, a)\ny \n```", "```py\n>>> (2*x + y).replace(a*x + b, b - a)\ny - 2\n>>> (2*x).replace(a*x + b, b - a)\n2*x \n```", "```py\n>>> (2*x).replace(a*x + b, b - a, exact=False)\n2/x \n```", "```py\n>>> f.replace(sin(a), lambda a: sin(2*a))\nlog(sin(2*x)) + tan(sin(2*x**2)) \n```", "```py\n>>> g = 2*sin(x**3)\n>>> g.replace(lambda expr: expr.is_Number, lambda expr: expr**2)\n4*sin(x**9) \n```", "```py\n>>> e = x*(x*y + 1)\n>>> e.replace(lambda x: x.is_Mul, lambda x: 2*x)\n2*x*(2*x*y + 1) \n```", "```py\n>>> from sympy import Function\n>>> f = Function('f')\n>>> e = f(1) + f(0)\n>>> q = f(a), lambda a: f(a + 1)\n>>> e.replace(*q, exact=False)\nf(1) + f(2)\n>>> e.replace(*q, exact=True)\nf(0) + f(2) \n```", "```py\n>>> e = x**(1 + y)\n>>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=False)\nx\n>>> (x**(1 + y)).replace(x**(1 + a), lambda a: x**-a, exact=True)\nx**(-x - y + 1)\n>>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=False)\nx\n>>> (x**y).replace(x**(1 + a), lambda a: x**-a, exact=True)\nx**(1 - y) \n```", "```py\n>>> (1 + x**(1 + y)).replace(\n... lambda x: x.is_Pow and x.exp.is_Add and x.exp.args[0] == 1,\n... lambda x: x.base**(1 - (x.exp - 1)))\n...\nx**(1 - y) + 1 \n```", "```py\nrewrite(*args, deep=True, **hints)\n```", "```py\n>>> from sympy import cos, sin, exp, I\n>>> from sympy.abc import x\n>>> expr = cos(x) + I*sin(x)\n>>> expr.rewrite(exp)\nexp(I*x) \n```", "```py\n>>> expr.rewrite(sin, exp)\nexp(I*x)/2 + cos(x) - exp(-I*x)/2\n>>> expr.rewrite([cos,], exp)\nexp(I*x)/2 + I*sin(x) + exp(-I*x)/2\n>>> expr.rewrite([cos, sin], exp)\nexp(I*x) \n```", "```py\n>>> from sympy import Expr, sqrt, pi\n>>> class MySin(Expr):\n...     def _eval_rewrite(self, rule, args, **hints):\n...         x, = args\n...         if rule == cos:\n...             return cos(pi/2 - x, evaluate=False)\n...         if rule == sqrt:\n...             return sqrt(1 - cos(x)**2)\n>>> MySin(MySin(x)).rewrite(cos)\ncos(-cos(-x + pi/2) + pi/2)\n>>> MySin(x).rewrite(sqrt)\nsqrt(1 - cos(x)**2) \n```", "```py\n>>> class MySin(Expr):\n...     def _eval_rewrite_as_cos(self, *args, **hints):\n...         x, = args\n...         return cos(pi/2 - x, evaluate=False)\n>>> MySin(x).rewrite(cos)\ncos(-x + pi/2) \n```", "```py\nsimplify(**kwargs)\n```", "```py\nsort_key(order=None)\n```", "```py\n>>> from sympy import S, I \n```", "```py\n>>> sorted([S(1)/2, I, -I], key=lambda x: x.sort_key())\n[1/2, -I, I] \n```", "```py\n>>> S(\"[x, 1/x, 1/x**2, x**2, x**(1/2), x**(1/4), x**(3/2)]\")\n[x, 1/x, x**(-2), x**2, sqrt(x), x**(1/4), x**(3/2)]\n>>> sorted(_, key=lambda x: x.sort_key())\n[x**(-2), 1/x, x**(1/4), sqrt(x), x, x**(3/2), x**2] \n```", "```py\nsubs(*args, **kwargs)\n```", "```py\n>>> from sympy import pi, exp, limit, oo\n>>> from sympy.abc import x, y\n>>> (1 + x*y).subs(x, pi)\npi*y + 1\n>>> (1 + x*y).subs({x:pi, y:2})\n1 + 2*pi\n>>> (1 + x*y).subs([(x, pi), (y, 2)])\n1 + 2*pi\n>>> reps = [(y, x**2), (x, 2)]\n>>> (x + y).subs(reps)\n6\n>>> (x + y).subs(reversed(reps))\nx**2 + 2 \n```", "```py\n>>> (x**2 + x**4).subs(x**2, y)\ny**2 + y \n```", "```py\n>>> (x**2 + x**4).xreplace({x**2: y})\nx**4 + y \n```", "```py\n>>> (x/y).subs([(x, 0), (y, 0)])\n0\n>>> (x/y).subs([(x, 0), (y, 0)], simultaneous=True)\nnan \n```", "```py\n>>> ((x + y)/y).subs({x + y: y, y: x + y})\n1\n>>> ((x + y)/y).subs({x + y: y, y: x + y}, simultaneous=True)\ny/(x + y) \n```", "```py\n>>> from sympy import sqrt, sin, cos\n>>> from sympy.abc import a, b, c, d, e \n```", "```py\n>>> A = (sqrt(sin(2*x)), a)\n>>> B = (sin(2*x), b)\n>>> C = (cos(2*x), c)\n>>> D = (x, d)\n>>> E = (exp(x), e) \n```", "```py\n>>> expr = sqrt(sin(2*x))*sin(exp(x)*x)*cos(2*x) + sin(2*x) \n```", "```py\n>>> expr.subs(dict([A, B, C, D, E]))\na*c*sin(d*e) + b \n```", "```py\n>>> (x**3 - 3*x).subs({x: oo})\nnan \n```", "```py\n>>> limit(x**3 - 3*x, x, oo)\noo \n```", "```py\n>>> (1/x).evalf(subs={x: 3.0}, n=21)\n0.333333333333333333333 \n```", "```py\n>>> (1/x).subs({x: 3.0}).evalf(21)\n0.333333333333333314830 \n```", "```py\nxreplace(rule)\n```", "```py\n>>> from sympy import symbols, pi, exp\n>>> x, y, z = symbols('x y z')\n>>> (1 + x*y).xreplace({x: pi})\npi*y + 1\n>>> (1 + x*y).xreplace({x: pi, y: 2})\n1 + 2*pi \n```", "```py\n>>> (x*y + z).xreplace({x*y: pi})\nz + pi\n>>> (x*y*z).xreplace({x*y: pi})\nx*y*z\n>>> (2*x).xreplace({2*x: y, x: z})\ny\n>>> (2*2*x).xreplace({2*x: y, x: z})\n4*z\n>>> (x + y + 2).xreplace({x + y: 2})\nx + y + 2\n>>> (x + 2 + exp(x + 2)).xreplace({x + 2: y})\nx + exp(y) + 2 \n```", "```py\n>>> from sympy import Integral\n>>> Integral(x, (x, 1, 2*x)).xreplace({x: y})\nIntegral(y, (y, 1, 2*y)) \n```", "```py\n>>> Integral(x, (x, 1, 2*x)).xreplace({x: 2*y}) \nValueError: Invalid limits given: ((2*y, 1, 4*y),) \n```", "```py\nclass sympy.core.basic.Atom(*args)\n```", "```py\nclass sympy.core.singleton.SingletonRegistry\n```", "```py\n>>> from sympy import S, Integer\n>>> a = Integer(0)\n>>> a is S.Zero\nTrue \n```", "```py\n>>> x = 0\n>>> x is S.Zero\nFalse \n```", "```py\n>>> 0 == S.Zero\nTrue \n```", "```py\nclass sympy.core.singleton.Singleton(*args, **kwargs)\n```", "```py\n>>> from sympy import S, Basic\n>>> from sympy.core.singleton import Singleton\n>>> class MySingleton(Basic, metaclass=Singleton):\n...     pass\n>>> Basic() is Basic()\nFalse\n>>> MySingleton() is MySingleton()\nTrue\n>>> S.MySingleton is MySingleton()\nTrue \n```", "```py\nclass sympy.core.expr.Expr(*args)\n```", "```py\napart(x=None, **args)\n```", "```py\nargs_cnc(cset=False, warn=True, split_1=True)\n```", "```py\n>>> from sympy import symbols, oo\n>>> A, B = symbols('A B', commutative=0)\n>>> x, y = symbols('x y')\n>>> (-2*x*y).args_cnc()\n[[-1, 2, x, y], []]\n>>> (-2.5*x).args_cnc()\n[[-1, 2.5, x], []]\n>>> (-2*x*A*B*y).args_cnc()\n[[-1, 2, x, y], [A, B]]\n>>> (-2*x*A*B*y).args_cnc(split_1=False)\n[[-2, x, y], [A, B]]\n>>> (-2*x*y).args_cnc(cset=True)\n[{-1, 2, x, y}, []] \n```", "```py\n>>> (-2 + x + A).args_cnc()\n[[], [x - 2 + A]]\n>>> (-oo).args_cnc() # -oo is a singleton\n[[-1, oo], []] \n```", "```py\nas_coeff_Add(rational=False) → tuple['Number', Expr]\n```", "```py\nas_coeff_Mul(rational: bool = False) → tuple['Number', Expr]\n```", "```py\nas_coeff_add(*deps) → tuple[Expr, tuple[Expr, ...]]\n```", "```py\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_add()\n(3, ())\n>>> (3 + x).as_coeff_add()\n(3, (x,))\n>>> (3 + x + y).as_coeff_add(x)\n(y + 3, (x,))\n>>> (3 + y).as_coeff_add(x)\n(y + 3, ()) \n```", "```py\nas_coeff_exponent(x) → tuple[Expr, Expr]\n```", "```py\nas_coeff_mul(*deps, **kwargs) → tuple[Expr, tuple[Expr, ...]]\n```", "```py\n>>> from sympy import S\n>>> from sympy.abc import x, y\n>>> (S(3)).as_coeff_mul()\n(3, ())\n>>> (3*x*y).as_coeff_mul()\n(3, (x, y))\n>>> (3*x*y).as_coeff_mul(x)\n(3*y, (x,))\n>>> (3*y).as_coeff_mul(x)\n(3*y, ()) \n```", "```py\nas_coefficient(expr)\n```", "```py\n>>> from sympy import E, pi, sin, I, Poly\n>>> from sympy.abc import x \n```", "```py\n>>> E.as_coefficient(E)\n1\n>>> (2*E).as_coefficient(E)\n2\n>>> (2*sin(E)*E).as_coefficient(E) \n```", "```py\n>>> (2*E + x*E).as_coefficient(E)\nx + 2\n>>> _.args[0]  # just want the exact match\n2\n>>> p = Poly(2*E + x*E); p\nPoly(x*E + 2*E, x, E, domain='ZZ')\n>>> p.coeff_monomial(E)\n2\n>>> p.nth(0, 1)\n2 \n```", "```py\n>>> (2*E*x + x).as_coefficient(E)\n>>> (2*E*x + x).coeff(E)\n2*x \n```", "```py\n>>> (E*(x + 1) + x).as_coefficient(E) \n```", "```py\n>>> (2*pi*I).as_coefficient(pi*I)\n2\n>>> (2*I).as_coefficient(pi*I) \n```", "```py\nas_coefficients_dict(*syms)\n```", "```py\n>>> from sympy.abc import a, x, y\n>>> (3*x + a*x + 4).as_coefficients_dict()\n{1: 4, x: 3, a*x: 1}\n>>> _[a]\n0\n>>> (3*a*x).as_coefficients_dict()\n{a*x: 3}\n>>> (3*a*x).as_coefficients_dict(x)\n{x: 3*a}\n>>> (3*a*x).as_coefficients_dict(y)\n{1: 3*a*x} \n```", "```py\nas_content_primitive(radical=False, clear=True)\n```", "```py\n>>> from sympy import sqrt\n>>> from sympy.abc import x, y, z \n```", "```py\n>>> eq = 2 + 2*x + 2*y*(3 + 3*y) \n```", "```py\n>>> eq.as_content_primitive()\n(2, x + 3*y*(y + 1) + 1) \n```", "```py\n>>> ((2 + 6*x)**2).as_content_primitive()\n(4, (3*x + 1)**2)\n>>> ((2 + 6*x)**(2*y)).as_content_primitive()\n(1, (2*(3*x + 1))**(2*y)) \n```", "```py\n>>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n(11, x*(y + 1))\n>>> ((3*(x*(1 + y)) + 2*x*(3 + 3*y))).as_content_primitive()\n(9, x*(y + 1))\n>>> ((3*(z*(1 + y)) + 2.0*x*(3 + 3*y))).as_content_primitive()\n(1, 6.0*x*(y + 1) + 3*z*(y + 1))\n>>> ((5*(x*(1 + y)) + 2*x*(3 + 3*y))**2).as_content_primitive()\n(121, x**2*(y + 1)**2)\n>>> ((x*(1 + y) + 0.4*x*(3 + 3*y))**2).as_content_primitive()\n(1, 4.84*x**2*(y + 1)**2) \n```", "```py\n>>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n(2, sqrt(2)*(1 + 2*sqrt(5))) \n```", "```py\n>>> (x/2 + y).as_content_primitive()\n(1/2, x + 2*y)\n>>> (x/2 + y).as_content_primitive(clear=False)\n(1, x/2 + y) \n```", "```py\nas_expr(*gens)\n```", "```py\n>>> from sympy import sin\n>>> from sympy.abc import x, y \n```", "```py\n>>> f = (x**2 + x*y).as_poly(x, y)\n>>> f.as_expr()\nx**2 + x*y \n```", "```py\n>>> sin(x).as_expr()\nsin(x) \n```", "```py\nas_independent(*deps, **hint) → tuple[Expr, Expr]\n```", "```py\n>>> from sympy import sin, cos, exp\n>>> from sympy.abc import x, y, z \n```", "```py\n>>> (x + x*y).as_independent(x)\n(0, x*y + x)\n>>> (x + x*y).as_independent(y)\n(x, x*y)\n>>> (2*x*sin(x) + y + x + z).as_independent(x)\n(y + z, 2*x*sin(x) + x)\n>>> (2*x*sin(x) + y + x + z).as_independent(x, y)\n(z, 2*x*sin(x) + x + y) \n```", "```py\n>>> (x*sin(x)*cos(y)).as_independent(x)\n(cos(y), x*sin(x)) \n```", "```py\n>>> from sympy import symbols\n>>> n1, n2, n3 = symbols('n1 n2 n3', commutative=False)\n>>> (n1 + n1*n2).as_independent(n2)\n(n1, n1*n2)\n>>> (n2*n1 + n1*n2).as_independent(n2)\n(0, n1*n2 + n2*n1)\n>>> (n1*n2*n3).as_independent(n1)\n(1, n1*n2*n3)\n>>> (n1*n2*n3).as_independent(n2)\n(n1, n2*n3)\n>>> ((x-n1)*(x-y)).as_independent(x)\n(1, (x - y)*(x - n1)) \n```", "```py\n>>> (sin(x)).as_independent(x)\n(1, sin(x))\n>>> (sin(x)).as_independent(y)\n(sin(x), 1)\n>>> exp(x+y).as_independent(x)\n(1, exp(x + y)) \n```", "```py\n>>> (3*x).as_independent(x, as_Add=True)\n(0, 3*x) \n```", "```py\n>>> (3+x).as_independent(x, as_Add=False)\n(1, x + 3)\n>>> (-3+x).as_independent(x, as_Add=False)\n(1, x - 3) \n```", "```py\n>>> (y*(-3+x)).as_independent(x)\n(y, x - 3) \n```", "```py\n>>> from sympy import Integral\n>>> I = Integral(x, (x, 1, 2))\n>>> I.has(x)\nTrue\n>>> x in I.free_symbols\nFalse\n>>> I.as_independent(x) == (I, 1)\nTrue\n>>> (I + x).as_independent(x) == (I, x)\nTrue \n```", "```py\n>>> from sympy import separatevars, log\n>>> separatevars(exp(x+y)).as_independent(x)\n(exp(y), exp(x))\n>>> (x + x*y).as_independent(y)\n(x, x*y)\n>>> separatevars(x + x*y).as_independent(y)\n(x, y + 1)\n>>> (x*(1 + y)).as_independent(y)\n(x, y + 1)\n>>> (x*(1 + y)).expand(mul=True).as_independent(y)\n(x, x*y)\n>>> a, b=symbols('a b', positive=True)\n>>> (log(a*b).expand(log=True)).as_independent(b)\n(log(a), log(b)) \n```", "```py\nas_leading_term(*symbols, logx=None, cdir=0)\n```", "```py\n>>> from sympy.abc import x\n>>> (1 + x + x**2).as_leading_term(x)\n1\n>>> (1/x**2 + x + x**2).as_leading_term(x)\nx**(-2) \n```", "```py\nas_numer_denom()\n```", "```py\nas_ordered_factors(order=None)\n```", "```py\nas_ordered_terms(order=None, data=False)\n```", "```py\n>>> from sympy import sin, cos\n>>> from sympy.abc import x \n```", "```py\n>>> (sin(x)**2*cos(x) + sin(x)**2 + 1).as_ordered_terms()\n[sin(x)**2*cos(x), sin(x)**2, 1] \n```", "```py\nas_poly(*gens, **args)\n```", "```py\n>>> from sympy import sin\n>>> from sympy.abc import x, y \n```", "```py\n>>> print((x**2 + x*y).as_poly())\nPoly(x**2 + x*y, x, y, domain='ZZ') \n```", "```py\n>>> print((x**2 + x*y).as_poly(x, y))\nPoly(x**2 + x*y, x, y, domain='ZZ') \n```", "```py\n>>> print((x**2 + sin(y)).as_poly(x, y))\nNone \n```", "```py\nas_powers_dict()\n```", "```py\nas_real_imag(deep=True, **hints)\n```", "```py\n>>> from sympy import symbols, I \n```", "```py\n>>> x, y = symbols('x,y', real=True) \n```", "```py\n>>> (x + y*I).as_real_imag()\n(x, y) \n```", "```py\n>>> from sympy.abc import z, w \n```", "```py\n>>> (z + w*I).as_real_imag()\n(re(z) - im(w), re(w) + im(z)) \n```", "```py\nas_terms()\n```", "```py\naseries(x=None, n=6, bound=0, hir=False)\n```", "```py\n>>> from sympy import sin, exp\n>>> from sympy.abc import x \n```", "```py\n>>> e = sin(1/x + exp(-x)) - sin(1/x) \n```", "```py\n>>> e.aseries(x)\n(1/(24*x**4) - 1/(2*x**2) + 1 + O(x**(-6), (x, oo)))*exp(-x) \n```", "```py\n>>> e.aseries(x, n=3, hir=True)\n-exp(-2*x)*sin(1/x)/2 + exp(-x)*cos(1/x) + O(exp(-3*x), (x, oo)) \n```", "```py\n>>> e = exp(exp(x)/(1 - 1/x)) \n```", "```py\n>>> e.aseries(x)\nexp(exp(x)/(1 - 1/x)) \n```", "```py\n>>> e.aseries(x, bound=3) \nexp(exp(x)/x**2)*exp(exp(x)/x)*exp(-exp(x) + exp(x)/(1 - 1/x) - exp(x)/x - exp(x)/x**2)*exp(exp(x)) \n```", "```py\ncancel(*gens, **args)\n```", "```py\ncoeff(x, n=1, right=False, _first=True)\n```", "```py\n>>> from sympy import symbols\n>>> from sympy.abc import x, y, z \n```", "```py\n>>> (-x + 2*y).coeff(-1)\nx\n>>> (x - 2*y).coeff(-1)\n2*y \n```", "```py\n>>> (x + 2*y).coeff(1)\nx\n>>> (3 + 2*x + 4*x**2).coeff(1)\n0 \n```", "```py\n>>> (3 + 2*x + 4*x**2).coeff(x, 0)\n3\n>>> eq = ((x + 1)**3).expand() + 1\n>>> eq\nx**3 + 3*x**2 + 3*x + 2\n>>> [eq.coeff(x, i) for i in reversed(range(4))]\n[1, 3, 3, 2]\n>>> eq -= 2\n>>> [eq.coeff(x, i) for i in reversed(range(4))]\n[1, 3, 3, 0] \n```", "```py\n>>> (-x - 2*y).coeff(2)\n-y\n>>> from sympy import sqrt\n>>> (x + sqrt(2)*x).coeff(sqrt(2))\nx \n```", "```py\n>>> (3 + 2*x + 4*x**2).coeff(x)\n2\n>>> (3 + 2*x + 4*x**2).coeff(x**2)\n4\n>>> (3 + 2*x + 4*x**2).coeff(x**3)\n0\n>>> (z*(x + y)**2).coeff((x + y)**2)\nz\n>>> (z*(x + y)**2).coeff(x + y)\n0 \n```", "```py\n>>> (x + z*(x + x*y)).coeff(x)\n1 \n```", "```py\n>>> from sympy import factor_terms\n>>> factor_terms(x + z*(x + x*y)).coeff(x)\nz*(y + 1) + 1 \n```", "```py\n>>> n, m, o = symbols('n m o', commutative=False)\n>>> n.coeff(n)\n1\n>>> (3*n).coeff(n)\n3\n>>> (n*m + m*n*m).coeff(n) # = (1 + m)*n*m\n1 + m\n>>> (n*m + m*n*m).coeff(n, right=True) # = (1 + m)*n*m\nm \n```", "```py\n>>> (n*m + m*n).coeff(n)\n0 \n```", "```py\n>>> (n*m + x*m*n).coeff(m*n)\nx\n>>> (n*m + x*m*n).coeff(m*n, right=1)\n1 \n```", "```py\ncollect(syms, func=None, evaluate=True, exact=False, distribute_order_term=True)\n```", "```py\ncombsimp()\n```", "```py\ncompute_leading_term(x, logx=None)\n```", "```py\nconjugate()\n```", "```py\ncould_extract_minus_sign()\n```", "```py\n>>> from sympy.abc import x, y\n>>> e = x - y\n>>> {i.could_extract_minus_sign() for i in (e, -e)}\n{False, True} \n```", "```py\n>>> (x*(y - x)).could_extract_minus_sign()\nFalse \n```", "```py\n>>> from sympy import signsimp\n>>> signsimp(x*(y - x))\n-x*(x - y)\n>>> _.could_extract_minus_sign()\nTrue \n```", "```py\nequals(other, failing_expression=False)\n```", "```py\nexpand(deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints)\n```", "```py\nproperty expr_free_symbols\n```", "```py\n>>> from sympy.abc import x, y\n>>> (x + y).expr_free_symbols \n{x, y} \n```", "```py\n>>> from sympy import Tuple\n>>> t = Tuple(x + y)\n>>> t.expr_free_symbols \nset()\n>>> t.free_symbols\n{x, y} \n```", "```py\nextract_additively(c)\n```", "```py\n>>> from sympy.abc import x, y\n>>> e = 2*x + 3\n>>> e.extract_additively(x + 1)\nx + 2\n>>> e.extract_additively(3*x)\n>>> e.extract_additively(4)\n>>> (y*(x + 1)).extract_additively(x + 1)\n>>> ((x + 1)*(x + 2*y + 1) + 3).extract_additively(x + 1)\n(x + 1)*(x + 2*y) + 3 \n```", "```py\nextract_branch_factor(allow_half=False)\n```", "```py\n>>> from sympy import exp_polar, I, pi\n>>> from sympy.abc import x, y\n>>> exp_polar(I*pi).extract_branch_factor()\n(exp_polar(I*pi), 0)\n>>> exp_polar(2*I*pi).extract_branch_factor()\n(1, 1)\n>>> exp_polar(-pi*I).extract_branch_factor()\n(exp_polar(I*pi), -1)\n>>> exp_polar(3*pi*I + x).extract_branch_factor()\n(exp_polar(x + I*pi), 1)\n>>> (y*exp_polar(-5*pi*I)*exp_polar(3*pi*I + 2*pi*x)).extract_branch_factor()\n(y*exp_polar(2*pi*x), -1)\n>>> exp_polar(-I*pi/2).extract_branch_factor()\n(exp_polar(-I*pi/2), 0) \n```", "```py\n>>> exp_polar(I*pi).extract_branch_factor(allow_half=True)\n(1, 1/2)\n>>> exp_polar(2*I*pi).extract_branch_factor(allow_half=True)\n(1, 1)\n>>> exp_polar(3*I*pi).extract_branch_factor(allow_half=True)\n(1, 3/2)\n>>> exp_polar(-I*pi).extract_branch_factor(allow_half=True)\n(1, -1/2) \n```", "```py\nextract_multiplicatively(c)\n```", "```py\n>>> from sympy import symbols, Rational \n```", "```py\n>>> x, y = symbols('x,y', real=True) \n```", "```py\n>>> ((x*y)**3).extract_multiplicatively(x**2 * y)\nx*y**2 \n```", "```py\n>>> ((x*y)**3).extract_multiplicatively(x**4 * y) \n```", "```py\n>>> (2*x).extract_multiplicatively(2)\nx \n```", "```py\n>>> (2*x).extract_multiplicatively(3) \n```", "```py\n>>> (Rational(1, 2)*x).extract_multiplicatively(3)\nx/6 \n```", "```py\nfactor(*gens, **args)\n```", "```py\nfourier_series(limits=None)\n```", "```py\nfps(x=None, x0=0, dir=1, hyper=True, order=4, rational=True, full=False)\n```", "```py\ngammasimp()\n```", "```py\ngetO()\n```", "```py\ngetn()\n```", "```py\n>>> from sympy import O\n>>> from sympy.abc import x\n>>> (1 + x + O(x**2)).getn()\n2\n>>> (1 + x).getn() \n```", "```py\nintegrate(*args, **kwargs)\n```", "```py\ninvert(g, *gens, **args)\n```", "```py\nis_algebraic_expr(*syms)\n```", "```py\n>>> from sympy import Symbol, sqrt\n>>> x = Symbol('x', real=True)\n>>> sqrt(1 + x).is_rational_function()\nFalse\n>>> sqrt(1 + x).is_algebraic_expr()\nTrue \n```", "```py\n>>> from sympy import exp, factor\n>>> a = sqrt(exp(x)**2 + 2*exp(x) + 1)/(exp(x) + 1)\n>>> a.is_algebraic_expr(x)\nFalse\n>>> factor(a).is_algebraic_expr()\nTrue \n```", "```py\nis_constant(*wrt, **flags)\n```", "```py\n>>> from sympy import cos, sin, Sum, S, pi\n>>> from sympy.abc import a, n, x, y\n>>> x.is_constant()\nFalse\n>>> S(2).is_constant()\nTrue\n>>> Sum(x, (x, 1, 10)).is_constant()\nTrue\n>>> Sum(x, (x, 1, n)).is_constant()\nFalse\n>>> Sum(x, (x, 1, n)).is_constant(y)\nTrue\n>>> Sum(x, (x, 1, n)).is_constant(n)\nFalse\n>>> Sum(x, (x, 1, n)).is_constant(x)\nTrue\n>>> eq = a*cos(x)**2 + a*sin(x)**2 - a\n>>> eq.is_constant()\nTrue\n>>> eq.subs({x: pi, a: 2}) == eq.subs({x: pi, a: 3}) == 0\nTrue \n```", "```py\n>>> (0**x).is_constant()\nFalse\n>>> x.is_constant()\nFalse\n>>> (x**x).is_constant()\nFalse\n>>> one = cos(x)**2 + sin(x)**2\n>>> one.is_constant()\nTrue\n>>> ((one - 1)**(x + 1)).is_constant() in (True, False) # could be 0 or 1\nTrue \n```", "```py\nis_meromorphic(x, a)\n```", "```py\n>>> from sympy import zoo, log, sin, sqrt\n>>> from sympy.abc import x \n```", "```py\n>>> f = 1/x**2 + 1 - 2*x**3\n>>> f.is_meromorphic(x, 0)\nTrue\n>>> f.is_meromorphic(x, 1)\nTrue\n>>> f.is_meromorphic(x, zoo)\nTrue \n```", "```py\n>>> g = x**log(3)\n>>> g.is_meromorphic(x, 0)\nFalse\n>>> g.is_meromorphic(x, 1)\nTrue\n>>> g.is_meromorphic(x, zoo)\nFalse \n```", "```py\n>>> h = sin(1/x)*x**2\n>>> h.is_meromorphic(x, 0)\nFalse\n>>> h.is_meromorphic(x, 1)\nTrue\n>>> h.is_meromorphic(x, zoo)\nTrue \n```", "```py\n>>> log(x).is_meromorphic(x, -1)\nTrue\n>>> log(x).is_meromorphic(x, 0)\nFalse\n>>> sqrt(x).is_meromorphic(x, -1)\nTrue\n>>> sqrt(x).is_meromorphic(x, 0)\nFalse \n```", "```py\nproperty is_number\n```", "```py\n>>> from sympy import Function, Integral, cos, sin, pi\n>>> from sympy.abc import x\n>>> f = Function('f') \n```", "```py\n>>> x.is_number\nFalse\n>>> f(1).is_number\nFalse\n>>> (2*x).is_number\nFalse\n>>> (2 + Integral(2, x)).is_number\nFalse\n>>> (2 + Integral(2, (x, 1, 2))).is_number\nTrue \n```", "```py\n>>> pi.is_number, pi.is_Number\n(True, False) \n```", "```py\n>>> cos(1).is_number and cos(1).is_comparable\nTrue \n```", "```py\n>>> z = cos(1)**2 + sin(1)**2 - 1\n>>> z.is_number\nTrue\n>>> z.is_comparable\nFalse \n```", "```py\nis_polynomial(*syms)\n```", "```py\n>>> from sympy import Symbol, Function\n>>> x = Symbol('x')\n>>> ((x**2 + 1)**4).is_polynomial(x)\nTrue\n>>> ((x**2 + 1)**4).is_polynomial()\nTrue\n>>> (2**x + 1).is_polynomial(x)\nFalse\n>>> (2**x + 1).is_polynomial(2**x)\nTrue\n>>> f = Function('f')\n>>> (f(x) + 1).is_polynomial(x)\nFalse\n>>> (f(x) + 1).is_polynomial(f(x))\nTrue\n>>> (1/f(x) + 1).is_polynomial(f(x))\nFalse \n```", "```py\n>>> n = Symbol('n', nonnegative=True, integer=True)\n>>> (x**n + 1).is_polynomial(x)\nFalse \n```", "```py\n>>> from sympy import sqrt, factor, cancel\n>>> y = Symbol('y', positive=True)\n>>> a = sqrt(y**2 + 2*y + 1)\n>>> a.is_polynomial(y)\nFalse\n>>> factor(a)\ny + 1\n>>> factor(a).is_polynomial(y)\nTrue \n```", "```py\n>>> b = (y**2 + 2*y + 1)/(y + 1)\n>>> b.is_polynomial(y)\nFalse\n>>> cancel(b)\ny + 1\n>>> cancel(b).is_polynomial(y)\nTrue \n```", "```py\nis_rational_function(*syms)\n```", "```py\n>>> from sympy import Symbol, sin\n>>> from sympy.abc import x, y \n```", "```py\n>>> (x/y).is_rational_function()\nTrue \n```", "```py\n>>> (x**2).is_rational_function()\nTrue \n```", "```py\n>>> (x/sin(y)).is_rational_function(y)\nFalse \n```", "```py\n>>> n = Symbol('n', integer=True)\n>>> (x**n + 1).is_rational_function(x)\nFalse \n```", "```py\n>>> from sympy import sqrt, factor\n>>> y = Symbol('y', positive=True)\n>>> a = sqrt(y**2 + 2*y + 1)/y\n>>> a.is_rational_function(y)\nFalse\n>>> factor(a)\n(y + 1)/y\n>>> factor(a).is_rational_function(y)\nTrue \n```", "```py\nleadterm(x, logx=None, cdir=0)\n```", "```py\n>>> from sympy.abc import x\n>>> (1+x+x**2).leadterm(x)\n(1, 0)\n>>> (1/x**2+x+x**2).leadterm(x)\n(1, -2) \n```", "```py\nlimit(x, xlim, dir='+')\n```", "```py\nlseries(x=None, x0=0, dir='+', logx=None, cdir=0)\n```", "```py\nfor term in sin(x).lseries(x):\n    print term \n```", "```py\nnormal()\n```", "```py\nnseries(x=None, x0=0, n=6, dir='+', logx=None, cdir=0)\n```", "```py\n>>> from sympy import sin, log, Symbol\n>>> from sympy.abc import x, y\n>>> sin(x).nseries(x, 0, 6)\nx - x**3/6 + x**5/120 + O(x**6)\n>>> log(x+1).nseries(x, 0, 5)\nx - x**2/2 + x**3/3 - x**4/4 + O(x**5) \n```", "```py\n>>> e = sin(log(x))\n>>> e.nseries(x, 0, 6)\nTraceback (most recent call last):\n...\nPoleError: ...\n...\n>>> logx = Symbol('logx')\n>>> e.nseries(x, 0, 6, logx=logx)\nsin(logx) \n```", "```py\n>>> e = x**y\n>>> e.nseries(x, 0, 2)\nx**y\n>>> e.nseries(x, 0, 2, logx=logx)\nexp(logx*y) \n```", "```py\nnsimplify(constants=(), tolerance=None, full=False)\n```", "```py\npowsimp(*args, **kwargs)\n```", "```py\nprimitive()\n```", "```py\n>>> from sympy.abc import x\n>>> (3*(x + 1)**2).primitive()\n(3, (x + 1)**2)\n>>> a = (6*x + 2); a.primitive()\n(2, 3*x + 1)\n>>> b = (x/2 + 3); b.primitive()\n(1/2, x + 6)\n>>> (a*b).primitive() == (1, a*b)\nTrue \n```", "```py\nradsimp(**kwargs)\n```", "```py\nratsimp()\n```", "```py\nremoveO()\n```", "```py\nround(n=None)\n```", "```py\n>>> from sympy import pi, E, I, S, Number\n>>> pi.round()\n3\n>>> pi.round(2)\n3.14\n>>> (2*pi + E*I).round()\n6 + 3*I \n```", "```py\n>>> (2*pi + I/10).round()\n6\n>>> (pi/10 + 2*I).round()\n2*I\n>>> (pi/10 + E*I).round(2)\n0.31 + 2.72*I \n```", "```py\n>>> isinstance(round(S(123), -2), Number)\nTrue \n```", "```py\nseparate(deep=False, force=False)\n```", "```py\nseries(x=None, x0=0, n=6, dir='+', logx=None, cdir=0)\n```", "```pydir=\"-\", then (x->x0-). For infinite ``x0```", "```py\n>>> from sympy import cos, exp, tan\n>>> from sympy.abc import x, y\n>>> cos(x).series()\n1 - x**2/2 + x**4/24 + O(x**6)\n>>> cos(x).series(n=4)\n1 - x**2/2 + O(x**4)\n>>> cos(x).series(x, x0=1, n=2)\ncos(1) - (x - 1)*sin(1) + O((x - 1)**2, (x, 1))\n>>> e = cos(x + exp(y))\n>>> e.series(y, n=2)\ncos(x + 1) - y*sin(x + 1) + O(y**2)\n>>> e.series(x, n=2)\ncos(exp(y)) - x*sin(exp(y)) + O(x**2) \n```", "```py\n>>> term=cos(x).series(n=None)\n>>> [next(term) for i in range(2)]\n[1, -x**2/2] \n```", "```py\n>>> abs(x).series(dir=\"+\")\nx\n>>> abs(x).series(dir=\"-\")\n-x\n>>> f = tan(x)\n>>> f.series(x, 2, 6, \"+\")\ntan(2) + (1 + tan(2)**2)*(x - 2) + (x - 2)**2*(tan(2)**3 + tan(2)) +\n(x - 2)**3*(1/3 + 4*tan(2)**2/3 + tan(2)**4) + (x - 2)**4*(tan(2)**5 +\n5*tan(2)**3/3 + 2*tan(2)/3) + (x - 2)**5*(2/15 + 17*tan(2)**2/15 +\n2*tan(2)**4 + tan(2)**6) + O((x - 2)**6, (x, 2)) \n```", "```py\n>>> f.series(x, 2, 3, \"-\")\ntan(2) + (2 - x)*(-tan(2)**2 - 1) + (2 - x)**2*(tan(2)**3 + tan(2))\n+ O((x - 2)**3, (x, 2)) \n```", "```py\ntaylor_term(n, x, *previous_terms)\n```", "```py\ntogether(*args, **kwargs)\n```", "```py\ntrigsimp(**args)\n```", "```py\nclass sympy.core.expr.UnevaluatedExpr(arg, **kwargs)\n```", "```py\n>>> from sympy import UnevaluatedExpr\n>>> from sympy.abc import x\n>>> x*(1/x)\n1\n>>> x*UnevaluatedExpr(1/x)\nx*1/x \n```", "```py\nclass sympy.core.expr.AtomicExpr(*args)\n```", "```py\nclass sympy.core.symbol.Symbol(name, **assumptions)\n```", "```py\n>>> from sympy import Symbol\n>>> x = Symbol(\"x\", positive=True)\n>>> x.is_positive\nTrue\n>>> x.is_negative\nFalse \n```", "```py\n>>> from sympy import Symbol\n>>> alpha = Symbol('alpha')\n>>> alpha \nα \n```", "```py\n>>> from sympy import Symbol\n>>> alpha_i = Symbol('alpha_i')\n>>> alpha_i \nαᵢ \n```", "```py\nclass sympy.core.symbol.Wild(name, exclude=(), properties=(), **assumptions)\n```", "```py\n>>> from sympy import Wild, WildFunction, cos, pi\n>>> from sympy.abc import x, y, z\n>>> a = Wild('a')\n>>> x.match(a)\n{a_: x}\n>>> pi.match(a)\n{a_: pi}\n>>> (3*x**2).match(a*x)\n{a_: 3*x}\n>>> cos(x).match(a)\n{a_: cos(x)}\n>>> b = Wild('b', exclude=[x])\n>>> (3*x**2).match(b*x)\n>>> b.match(a)\n{a_: b_}\n>>> A = WildFunction('A')\n>>> A.match(a)\n{a_: A_} \n```", "```py\n>>> from sympy import symbols\n>>> a, b = symbols('a b', cls=Wild)\n>>> (2 + 3*y).match(a*x + b*y)\n{a_: 2/x, b_: 3} \n```", "```py\n>>> a = Wild('a', exclude=[x, y])\n>>> b = Wild('b', exclude=[x, y])\n>>> (2 + 3*y).match(a*x + b*y) \n```", "```py\n>>> E = 2*x**3*y*z\n>>> a, b = symbols('a b', cls=Wild)\n>>> E.match(a*b)\n{a_: 2*y*z, b_: x**3}\n>>> a = Wild('a', exclude=[x, y])\n>>> E.match(a*b)\n{a_: z, b_: 2*x**3*y}\n>>> a = Wild('a', exclude=[x, y, z])\n>>> E.match(a*b)\n{a_: 2, b_: x**3*y*z} \n```", "```py\n>>> a = Wild('a', properties=[lambda k: k.is_Integer])\n>>> E.match(a*b)\n{a_: 2, b_: x**3*y*z} \n```", "```py\nclass sympy.core.symbol.Dummy(name=None, dummy_index=None, **assumptions)\n```", "```py\n>>> from sympy import Dummy\n>>> Dummy(\"x\") == Dummy(\"x\")\nFalse \n```", "```py\n>>> Dummy() \n_Dummy_10 \n```", "```py\nsympy.core.symbol.symbols(names, *, cls=<class 'sympy.core.symbol.Symbol'>, **args) → Any\n```", "```py\n>>> from sympy import symbols, Function\n\n>>> x, y, z = symbols('x,y,z')\n>>> a, b, c = symbols('a b c') \n```", "```py\n>>> symbols('x')\nx\n>>> symbols('x,')\n(x,)\n>>> symbols('x,y')\n(x, y)\n>>> symbols(('a', 'b', 'c'))\n(a, b, c)\n>>> symbols(['a', 'b', 'c'])\n[a, b, c]\n>>> symbols({'a', 'b', 'c'})\n{a, b, c} \n```", "```py\n>>> symbols('x', seq=True)\n(x,) \n```", "```py\n>>> symbols('x:10')\n(x0, x1, x2, x3, x4, x5, x6, x7, x8, x9)\n\n>>> symbols('x5:10')\n(x5, x6, x7, x8, x9)\n>>> symbols('x5(:2)')\n(x50, x51)\n\n>>> symbols('x5:10,y:5')\n(x5, x6, x7, x8, x9, y0, y1, y2, y3, y4)\n\n>>> symbols(('x5:10', 'y:5'))\n((x5, x6, x7, x8, x9), (y0, y1, y2, y3, y4)) \n```", "```py\n>>> symbols('x:z')\n(x, y, z)\n>>> symbols('x:c')  # null range\n()\n>>> symbols('x(:c)')\n(xa, xb, xc)\n\n>>> symbols(':c')\n(a, b, c)\n\n>>> symbols('a:d, x:z')\n(a, b, c, d, x, y, z)\n\n>>> symbols(('a:d', 'x:z'))\n((a, b, c, d), (x, y, z)) \n```", "```py\n>>> symbols('x:2(1:3)')\n(x01, x02, x11, x12)\n>>> symbols(':3:2')  # parsing is from left to right\n(00, 01, 10, 11, 20, 21) \n```", "```py\n>>> symbols('x((a:b))')\n(x(a), x(b))\n>>> symbols(r'x(:1\\,:2)')  # or r'x((:1)\\,(:2))'\n(x(0,0), x(0,1)) \n```", "```py\n>>> a = symbols('a', integer=True)\n>>> a.is_integer\nTrue\n\n>>> x, y, z = symbols('x,y,z', real=True)\n>>> x.is_real and y.is_real and z.is_real\nTrue \n```", "```py\n>>> symbols('f,g,h', cls=Function)\n(f, g, h)\n\n>>> type(_[0])\n<class 'sympy.core.function.UndefinedFunction'> \n```", "```py\nsympy.core.symbol.var(names, **args)\n```", "```py\n.. rubric:: Examples \n```", "```py\n>>> from sympy import var \n```", "```py\n>>> var('x')\nx\n>>> x # noqa: F821\nx \n```", "```py\n>>> var('a,ab,abc')\n(a, ab, abc)\n>>> abc # noqa: F821\nabc \n```", "```py\n>>> var('x,y', real=True)\n(x, y)\n>>> x.is_real and y.is_real # noqa: F821\nTrue \n```", "```py\nsympy.core.intfunc.num_digits(n, base=10)\n```", "```py\n>>> from sympy.core.intfunc import num_digits\n>>> num_digits(10)\n2\n>>> num_digits(10, 2)  # 1010 -> 4 digits\n4\n>>> num_digits(-100, 16)  # -64 -> 2 digits\n2 \n```", "```py\nsympy.core.intfunc.trailing(n)\n```", "```py\n>>> from sympy import trailing\n>>> trailing(128)\n7\n>>> trailing(63)\n0 \n```", "```py\nsympy.core.intfunc.ilcm(*args)\n```", "```py\n>>> from sympy import ilcm\n>>> ilcm(5, 10)\n10\n>>> ilcm(7, 3)\n21\n>>> ilcm(5, 10, 15)\n30 \n```", "```py\nsympy.core.intfunc.igcd(*args)\n```", "```py\n>>> from sympy import igcd\n>>> igcd(2, 4)\n2\n>>> igcd(5, 10, 15)\n5 \n```", "```py\nsympy.core.intfunc.igcd_lehmer(a, b)\n```", "```py\nsympy.core.intfunc.igcdex(a, b)\n```", "```py\n>>> from sympy.core.intfunc import igcdex\n>>> igcdex(2, 3)\n(-1, 1, 1)\n>>> igcdex(10, 12)\n(-1, 1, 2) \n```", "```py\n>>> x, y, g = igcdex(100, 2004)\n>>> x, y, g\n(-20, 1, 4)\n>>> x*100 + y*2004\n4 \n```", "```py\nsympy.core.intfunc.isqrt(n)\n```", "```py\n>>> from sympy.core.intfunc import isqrt\n>>> isqrt(0)\n0\n>>> isqrt(9)\n3\n>>> isqrt(10)\n3\n>>> isqrt(\"30\")\nTraceback (most recent call last):\n  ...\nTypeError: '<' not supported between instances of 'str' and 'int'\n>>> from sympy.core.numbers import Rational\n>>> isqrt(Rational(-1, 2))\nTraceback (most recent call last):\n  ...\nValueError: n must be nonnegative \n```", "```py\nsympy.core.intfunc.integer_nthroot(y, n)\n```", "```py\n>>> from sympy import integer_nthroot\n>>> integer_nthroot(16, 2)\n(4, True)\n>>> integer_nthroot(26, 2)\n(5, False) \n```", "```py\n>>> from sympy.ntheory.primetest import is_square\n>>> is_square(26)\nFalse \n```", "```py\nsympy.core.intfunc.integer_log(n, b)\n```", "```py\n>>> from sympy import integer_log\n>>> integer_log(125, 5)\n(3, True)\n>>> integer_log(17, 9)\n(1, False) \n```", "```py\n>>> integer_log(-4, 2)\n(2, False)\n>>> integer_log(-16, 4)\n(0, False) \n```", "```py\n>>> integer_log(4, -2)\n(2, True)\n>>> integer_log(8, -2)\n(3, False)\n>>> integer_log(-8, -2)\n(3, True)\n>>> integer_log(-4, -2)\n(2, False) \n```", "```py\nsympy.core.intfunc.mod_inverse(a, m)\n```", "```py\n>>> from sympy import mod_inverse, S \n```", "```py\n>>> mod_inverse(3, 11)\n4\n>>> mod_inverse(-3, 11)\n7 \n```", "```py\n>>> mod_inverse(2, 4)\nTraceback (most recent call last):\n...\nValueError: inverse of 2 mod 4 does not exist \n```", "```py\n>>> mod_inverse(S(2)/7, S(5)/2)\n7/2 \n```", "```py\nclass sympy.core.numbers.Number(*obj)\n```", "```py\nas_coeff_Add(rational=False)\n```", "```py\nas_coeff_Mul(rational=False)\n```", "```py\ncofactors(other)\n```", "```py\ngcd(other)\n```", "```py\nlcm(other)\n```", "```py\nclass sympy.core.numbers.Float(num, dps=None, precision=None)\n```", "```py\n>>> from sympy import Float\n>>> Float(3.5)\n3.50000000000000\n>>> Float(3)\n3.00000000000000 \n```", "```py\n>>> Float(1)\n1.00000000000000\n>>> Float(10**20)\n100000000000000000000.\n>>> Float('1e20')\n100000000000000000000. \n```", "```py\n>>> Float(1e20)\n1.00000000000000e+20\n>>> Float(1.23456789123456789)\n1.23456789123457 \n```", "```py\n>>> Float('1.23456789123456789')\n1.23456789123456789 \n```", "```py\n>>> Float('1e-3', 3)\n0.00100\n>>> Float(100, 4)\n100.0 \n```", "```py\n>>> Float('123 456 789.123_456', '')\n123456789.123456\n>>> Float('12e-3', '')\n0.012\n>>> Float(3, '')\n3. \n```", "```py\n>>> Float('60.e2', '')  # 2 digits significant\n6.0e+3\n>>> Float('60e2', '')  # 4 digits significant\n6000.\n>>> Float('600e-2', '')  # 3 digits significant\n6.00 \n```", "```py\n>>> approx, exact = Float(.1, 1), Float(.125, 1) \n```", "```py\n>>> approx.evalf(5)\n0.099609 \n```", "```py\n>>> Float(exact, 5)\n0.12500\n>>> exact.evalf(20)\n0.12500000000000000000 \n```", "```py\n>>> Float(0.3, 20)\n0.29999999999999998890 \n```", "```py\n>>> Float('0.3', 20)\n0.30000000000000000000 \n```", "```py\n>>> def show(f): # binary rep of Float\n...     from sympy import Mul, Pow\n...     s, m, e, b = f._mpf_\n...     v = Mul(int(m), Pow(2, int(e), evaluate=False), evaluate=False)\n...     print('%s at prec=%s' % (v, f._prec))\n...\n>>> t = Float('0.3', 3)\n>>> show(t)\n4915/2**14 at prec=13\n>>> show(Float(t, 20)) # higher prec, not higher accuracy\n4915/2**14 at prec=70\n>>> show(Float(t, 2)) # lower prec\n307/2**10 at prec=10 \n```", "```py\n>>> show(t.evalf(20))\n4915/2**14 at prec=70\n>>> show(t.evalf(2))\n307/2**10 at prec=10 \n```", "```py\n>>> n, c, p = 1, 5, 0\n>>> (-1)**n*c*2**p\n-5\n>>> Float((1, 5, 0))\n-5.00000000000000 \n```", "```py\n>>> _._mpf_\n(1, 5, 0, 3) \n```", "```py\n>>> Float('-inf')\n-oo\n>>> _.is_Float\nFalse \n```", "```py\nclass sympy.core.numbers.Rational(p, q=None, gcd=None)\n```", "```py\n>>> from sympy import Rational, nsimplify, S, pi\n>>> Rational(1, 2)\n1/2 \n```", "```py\n>>> Rational(.5)\n1/2\n>>> Rational(.2)\n3602879701896397/18014398509481984 \n```", "```py\n>>> Rational(str(.2))\n1/5\n>>> Rational(.2).limit_denominator(10**12)\n1/5 \n```", "```py\n>>> Rational(\"1.23\")\n123/100\n>>> Rational('1e-2')\n1/100\n>>> Rational(\".1\")\n1/10\n>>> Rational('1e-2/3.2')\n1/320 \n```", "```py\n>>> S('.[3]')  # repeating digits in brackets\n1/3\n>>> S('3**2/10')  # general expressions\n9/10\n>>> nsimplify(.3)  # numbers that have a simple form\n3/10 \n```", "```py\n>>> Rational(pi)\nTraceback (most recent call last):\n...\nTypeError: invalid input: pi \n```", "```py\n>>> r = Rational(3, 4)\n>>> r\n3/4\n>>> r.p\n3\n>>> r.q\n4 \n```", "```py\n>>> r.p/r.q\n0.75 \n```", "```py\n>>> Rational(2, 4, gcd=1)\n2/4\n>>> Rational(2, -4, gcd=1).q\n4 \n```", "```py\nas_coeff_Add(rational=False)\n```", "```py\nas_coeff_Mul(rational=False)\n```", "```py\nas_content_primitive(radical=False, clear=True)\n```", "```py\n>>> from sympy import S\n>>> (S(-3)/2).as_content_primitive()\n(3/2, -1) \n```", "```py\nfactors(limit=None, use_trial=True, use_rho=False, use_pm1=False, verbose=False, visual=False)\n```", "```py\nlimit_denominator(max_denominator=1000000)\n```", "```py\n>>> from sympy import Rational\n>>> Rational('3.141592653589793').limit_denominator(10)\n22/7\n>>> Rational('3.141592653589793').limit_denominator(100)\n311/99 \n```", "```py\nclass sympy.core.numbers.Integer(i)\n```", "```py\n>>> from sympy import Integer\n>>> Integer(3)\n3 \n```", "```py\n>>> Integer(3.8)\n3\n>>> Integer(-3.8)\n-3 \n```", "```py\n>>> Integer(\"9\" * 20)\n99999999999999999999 \n```", "```py\nclass sympy.core.numbers.AlgebraicNumber(expr, coeffs=None, alias=None, **args)\n```", "```py\nstatic __new__(cls, expr, coeffs=None, alias=None, **args)\n```", "```py\n>>> from sympy import AlgebraicNumber, sqrt, CRootOf, S\n>>> from sympy.abc import x \n```", "```py\n>>> a1 = AlgebraicNumber(sqrt(2))\n>>> a1.minpoly_of_element().as_expr(x)\nx**2 - 2\n>>> a1.evalf(10)\n1.414213562 \n```", "```py\n>>> a2 = AlgebraicNumber(a1, [3, -5])\n>>> a2.as_expr()\n-5 + 3*sqrt(2) \n```", "```py\n>>> a2 = AlgebraicNumber(sqrt(2), [3, -5])\n>>> a2.as_expr()\n-5 + 3*sqrt(2) \n```", "```py\n>>> a3 = AlgebraicNumber(a2, [2, -1])\n>>> a3.as_expr()\n-11 + 6*sqrt(2) \n```", "```py\n>>> from sympy import to_number_field\n>>> a4 = to_number_field(sqrt(2), sqrt(2) + sqrt(3))\n>>> a4.minpoly_of_element().as_expr(x)\nx**2 - 2\n>>> a4.to_root()\nsqrt(2)\n>>> a4.primitive_element()\nsqrt(2) + sqrt(3)\n>>> a4.coeffs()\n[1/2, 0, -9/2, 0] \n```", "```py\n>>> a4 = AlgebraicNumber(sqrt(2) + sqrt(3), [S(1)/2, 0, S(-9)/2, 0])\n>>> a4.to_root()\nsqrt(2)\n>>> a4.primitive_element()\nsqrt(2) + sqrt(3) \n```", "```py\n>>> from sympy import cyclotomic_poly\n>>> from sympy.abc import zeta\n>>> a5 = AlgebraicNumber(CRootOf(cyclotomic_poly(5), -1),\n...                  [-1, -1, 0, 0], alias=zeta)\n>>> a5.as_poly().as_expr()\n-zeta**3 - zeta**2\n>>> a5.evalf()\n1.61803398874989 \n```", "```py\n>>> from sympy.abc import phi\n>>> a6 = AlgebraicNumber(a5.to_root(), coeffs=[2, 0], alias=phi)\n>>> a6.as_poly().as_expr()\n2*phi\n>>> a6.primitive_element().evalf()\n1.61803398874989 \n```", "```py\n>>> a6_wrong = AlgebraicNumber(a5, coeffs=[2, 0])\n>>> a6_wrong.as_poly().as_expr()\n-2*zeta**3 - 2*zeta**2\n>>> a6_wrong.primitive_element().evalf()\n0.309016994374947 + 0.951056516295154*I \n```", "```py\nas_expr(x=None)\n```", "```py\nas_poly(x=None)\n```", "```py\ncoeffs()\n```", "```py\nfield_element(coeffs)\n```", "```py\n>>> from sympy import AlgebraicNumber, sqrt\n>>> a = AlgebraicNumber(sqrt(5), [-1, 1])\n>>> b = a.field_element([3, 2])\n>>> print(a)\n1 - sqrt(5)\n>>> print(b)\n2 + 3*sqrt(5)\n>>> print(b.primitive_element() == a.primitive_element())\nTrue \n```", "```py\nproperty is_aliased\n```", "```py\nproperty is_primitive_element\n```", "```py\nminpoly_of_element()\n```", "```py\nnative_coeffs()\n```", "```py\nprimitive_element()\n```", "```py\nto_algebraic_integer()\n```", "```py\nto_primitive_element(radicals=True)\n```", "```py\n>>> from sympy import sqrt, to_number_field\n>>> from sympy.abc import x\n>>> a = to_number_field(sqrt(2), sqrt(2) + sqrt(3)) \n```", "```py\n>>> a.as_poly().as_expr(x)\nx**3/2 - 9*x/2 \n```", "```py\n>>> a.minpoly.as_poly().as_expr(x)\nx**4 - 10*x**2 + 1 \n```", "```py\n>>> a_prim = a.to_primitive_element()\n>>> a_prim.minpoly.as_poly().as_expr(x)\nx**2 - 2 \n```", "```py\nto_root(radicals=True, minpoly=None)\n```", "```py\nclass sympy.core.numbers.NumberSymbol\n```", "```py\napproximation(number_cls)\n```", "```py\nsympy.core.numbers.RealNumber\n```", "```py\nsympy.core.numbers.seterr(divide=False)\n```", "```py\nclass sympy.core.numbers.Zero\n```", "```py\n>>> from sympy import S, Integer\n>>> Integer(0) is S.Zero\nTrue\n>>> 1/S.Zero\nzoo \n```", "```py\nclass sympy.core.numbers.One\n```", "```py\n>>> from sympy import S, Integer\n>>> Integer(1) is S.One\nTrue \n```", "```py\nclass sympy.core.numbers.NegativeOne\n```", "```py\n>>> from sympy import S, Integer\n>>> Integer(-1) is S.NegativeOne\nTrue \n```", "```py\nclass sympy.core.numbers.Half\n```", "```py\n>>> from sympy import S, Rational\n>>> Rational(1, 2) is S.Half\nTrue \n```", "```py\nclass sympy.core.numbers.NaN\n```", "```pyoo - oo` produce NaN.  Two exceptions are ``0**0```", "```py\n>>> from sympy import nan, S, oo, Eq\n>>> nan is S.NaN\nTrue\n>>> oo - oo\nnan\n>>> nan + 1\nnan\n>>> Eq(nan, nan)   # mathematical equality\nFalse\n>>> nan == nan     # structural equality\nTrue \n```", "```py\nclass sympy.core.numbers.Infinity\n```", "```py\n>>> from sympy import oo, exp, limit, Symbol\n>>> 1 + oo\noo\n>>> 42/oo\n0\n>>> x = Symbol('x')\n>>> limit(exp(x), x, oo)\noo \n```", "```py\nclass sympy.core.numbers.NegativeInfinity\n```", "```py\nclass sympy.core.numbers.ComplexInfinity\n```", "```py\n>>> from sympy import zoo\n>>> zoo + 42\nzoo\n>>> 42/zoo\n0\n>>> zoo + zoo\nnan\n>>> zoo*zoo\nzoo \n```", "```py\nclass sympy.core.numbers.Exp1\n```", "```py\n>>> from sympy import exp, log, E\n>>> E is exp(1)\nTrue\n>>> log(E)\n1 \n```", "```py\nclass sympy.core.numbers.ImaginaryUnit\n```", "```py\n>>> from sympy import I, sqrt\n>>> sqrt(-1)\nI\n>>> I*I\n-1\n>>> 1/I\n-I \n```", "```py\nclass sympy.core.numbers.Pi\n```", "```py\n>>> from sympy import S, pi, oo, sin, exp, integrate, Symbol\n>>> S.Pi\npi\n>>> pi > 3\nTrue\n>>> pi.is_irrational\nTrue\n>>> x = Symbol('x')\n>>> sin(x + 2*pi)\nsin(x)\n>>> integrate(exp(-x**2), (x, -oo, oo))\nsqrt(pi) \n```", "```py\nclass sympy.core.numbers.EulerGamma\n```", "```py\n>>> from sympy import S\n>>> S.EulerGamma.is_irrational\n>>> S.EulerGamma > 0\nTrue\n>>> S.EulerGamma > 1\nFalse \n```", "```py\nclass sympy.core.numbers.Catalan\n```", "```py\n>>> from sympy import S\n>>> S.Catalan.is_irrational\n>>> S.Catalan > 0\nTrue\n>>> S.Catalan > 1\nFalse \n```", "```py\nclass sympy.core.numbers.GoldenRatio\n```", "```py\n>>> from sympy import S\n>>> S.GoldenRatio > 1\nTrue\n>>> S.GoldenRatio.expand(func=True)\n1/2 + sqrt(5)/2\n>>> S.GoldenRatio.is_irrational\nTrue \n```", "```py\nclass sympy.core.numbers.TribonacciConstant\n```", "```py\n>>> from sympy import S\n>>> S.TribonacciConstant > 1\nTrue\n>>> S.TribonacciConstant.expand(func=True)\n1/3 + (19 - 3*sqrt(33))**(1/3)/3 + (3*sqrt(33) + 19)**(1/3)/3\n>>> S.TribonacciConstant.is_irrational\nTrue\n>>> S.TribonacciConstant.n(20)\n1.8392867552141611326 \n```", "```py\nsympy.core.numbers.mod_inverse(a, m)\n```", "```py\n>>> from sympy import mod_inverse, S \n```", "```py\n>>> mod_inverse(3, 11)\n4\n>>> mod_inverse(-3, 11)\n7 \n```", "```py\n>>> mod_inverse(2, 4)\nTraceback (most recent call last):\n...\nValueError: inverse of 2 mod 4 does not exist \n```", "```py\n>>> mod_inverse(S(2)/7, S(5)/2)\n7/2 \n```", "```py\nsympy.core.numbers.equal_valued(x, y)\n```", "```py\n>>> from sympy import S, symbols, Rational, Float\n>>> from sympy.core.numbers import equal_valued\n>>> equal_valued(1, 2)\nFalse\n>>> equal_valued(1, 1)\nTrue \n```", "```py\n>>> x = symbols('x')\n>>> x**2 == x**2.0\nFalse \n```", "```py\n>>> Rational(1, 2) == Float(0.5)\nFalse \n```", "```py\n>>> equal_valued(1, 1.0) # Float vs Rational\nTrue\n>>> equal_valued(S(1).n(3), S(1).n(5)) # Floats of different precision\nTrue \n```", "```py\nclass sympy.core.power.Pow(b, e, evaluate=None)\n```", "```py\nas_base_exp()\n```", "```py\n>>> from sympy import Pow, S\n>>> p = Pow(S.Half, 2, evaluate=False)\n>>> p.as_base_exp()\n(2, -2)\n>>> p.args\n(1/2, 2)\n>>> p.base, p.exp\n(1/2, 2) \n```", "```py\nas_content_primitive(radical=False, clear=True)\n```", "```py\n>>> from sympy import sqrt\n>>> sqrt(4 + 4*sqrt(2)).as_content_primitive()\n(2, sqrt(1 + sqrt(2)))\n>>> sqrt(3 + 3*sqrt(2)).as_content_primitive()\n(1, sqrt(3)*sqrt(1 + sqrt(2))) \n```", "```py\n>>> from sympy import expand_power_base, powsimp, Mul\n>>> from sympy.abc import x, y \n```", "```py\n>>> ((2*x + 2)**2).as_content_primitive()\n(4, (x + 1)**2)\n>>> (4**((1 + y)/2)).as_content_primitive()\n(2, 4**(y/2))\n>>> (3**((1 + y)/2)).as_content_primitive()\n(1, 3**((y + 1)/2))\n>>> (3**((5 + y)/2)).as_content_primitive()\n(9, 3**((y + 1)/2))\n>>> eq = 3**(2 + 2*x)\n>>> powsimp(eq) == eq\nTrue\n>>> eq.as_content_primitive()\n(9, 3**(2*x))\n>>> powsimp(Mul(*_))\n3**(2*x + 2) \n```", "```py\n>>> eq = (2 + 2*x)**y\n>>> s = expand_power_base(eq); s.is_Mul, s\n(False, (2*x + 2)**y)\n>>> eq.as_content_primitive()\n(1, (2*(x + 1))**y)\n>>> s = expand_power_base(_[1]); s.is_Mul, s\n(True, 2**y*(x + 1)**y) \n```", "```py\nclass sympy.core.mul.Mul(*args, evaluate=None, _sympify=True)\n```", "```py\n>>> from sympy import Mul\n>>> from sympy.abc import x, y\n>>> Mul(x, 1)\nx\n>>> Mul(x, x)\nx**2 \n```", "```py\n>>> Mul(1, 2, evaluate=False)\n1*2\n>>> Mul(x, x, evaluate=False)\nx*x \n```", "```py\n>>> from sympy import MatrixSymbol\n>>> A = MatrixSymbol('A', 2,2)\n>>> expr = Mul(x,y).subs({y:A})\n>>> expr\nx*A\n>>> type(expr)\n<class 'sympy.matrices.expressions.matmul.MatMul'> \n```", "```py\nas_coeff_Mul(rational=False)\n```", "```py\nas_content_primitive(radical=False, clear=True)\n```", "```py\n>>> from sympy import sqrt\n>>> (-3*sqrt(2)*(2 - 2*sqrt(2))).as_content_primitive()\n(6, -sqrt(2)*(1 - sqrt(2))) \n```", "```py\nas_ordered_factors(order=None)\n```", "```py\n>>> from sympy import sin, cos\n>>> from sympy.abc import x, y \n```", "```py\n>>> (2*x*y*sin(x)*cos(x)).as_ordered_factors()\n[2, x, y, sin(x), cos(x)] \n```", "```py\nas_two_terms()\n```", "```py\n>>> from sympy.abc import x, y\n>>> (3*x*y).as_two_terms()\n(3, x*y) \n```", "```py\nclassmethod flatten(seq)\n```", "```py\n    > >>> from sympy import Mul, sqrt\n> \n    > >>> from sympy.abc import x, y, z\n> \n    > >>> 2*(x + 1) # this is the 2-arg Mul behavior\n> \n    > 2*x + 2\n> \n    > >>> y*(x + 1)*2\n> \n    > 2*y*(x + 1)\n> \n    > >>> 2*(x + 1)*y # 2-arg result will be obtained first\n> \n    > y*(2*x + 2)\n> \n    > >>> Mul(2, x + 1, y) # all 3 args simultaneously processed\n> \n    > 2*y*(x + 1)\n> \n    > >>> 2*((x + 1)*y) # parentheses can control this behavior\n> \n    > 2*y*(x + 1) \n    > ```", "```py\n    > >>> a = sqrt(x*sqrt(y))\n> \n    > >>> a**3\n> \n    > (x*sqrt(y))**(3/2)\n> \n    > >>> Mul(a,a,a)\n> \n    > (x*sqrt(y))**(3/2)\n> \n    > >>> a*a*a\n> \n    > x*sqrt(y)*sqrt(x*sqrt(y))\n> \n    > >>> _.subs(a.base, z).subs(z, a.base)\n> \n    > (x*sqrt(y))**(3/2) \n    > ```", "```py\nsympy.core.mul.prod(a, start=1)\n```", "```py\n>>> from sympy import prod, S\n>>> prod(range(3))\n0\n>>> type(_) is int\nTrue\n>>> prod([S(2), 3])\n6\n>>> _.is_Integer\nTrue \n```", "```py\n>>> prod([1, 2], 3)\n6 \n```", "```py\nclass sympy.core.add.Add(*args, evaluate=None, _sympify=True)\n```", "```py\n>>> from sympy import Add, I\n>>> from sympy.abc import x, y\n>>> Add(x, 1)\nx + 1\n>>> Add(x, x)\n2*x\n>>> 2*x**2 + 3*x + I*y + 2*y + 2*x/5 + 1.0*y + 1\n2*x**2 + 17*x/5 + 3.0*y + I*y + 1 \n```", "```py\n>>> Add(1, 2, evaluate=False)\n1 + 2\n>>> Add(x, x, evaluate=False)\nx + x \n```", "```py\n>>> from sympy import MatrixSymbol\n>>> A,B = MatrixSymbol('A', 2,2), MatrixSymbol('B', 2,2)\n>>> expr = Add(x,y).subs({x:A, y:B})\n>>> expr\nA + B\n>>> type(expr)\n<class 'sympy.matrices.expressions.matadd.MatAdd'> \n```", "```py\n>>> Add(x, 1)\nx + 1\n>>> Add(x, 1).args\n(1, x) \n```", "```py\nas_coeff_Add(rational=False, deps=None)\n```", "```py\nas_coeff_add(*deps)\n```", "```py\n>>> from sympy.abc import x\n>>> (7 + 3*x).as_coeff_add()\n(7, (3*x,))\n>>> (7*x).as_coeff_add()\n(0, (7*x,)) \n```", "```py\nas_content_primitive(radical=False, clear=True)\n```", "```py\n>>> from sympy import sqrt\n>>> (3 + 3*sqrt(2)).as_content_primitive()\n(3, 1 + sqrt(2)) \n```", "```py\n>>> (2*sqrt(2) + 4*sqrt(10)).as_content_primitive(radical=True)\n(2, sqrt(2)*(1 + 2*sqrt(5))) \n```", "```py\nas_numer_denom()\n```", "```py\n>>> from sympy.abc import x, y, z\n>>> (x*y/z).as_numer_denom()\n(x*y, z)\n>>> (x*(y + 1)/y**7).as_numer_denom()\n(x*(y + 1), y**7) \n```", "```py\nas_real_imag(deep=True, **hints)\n```", "```py\n>>> from sympy import I\n>>> (7 + 9*I).as_real_imag()\n(7, 9)\n>>> ((1 + I)/(1 - I)).as_real_imag()\n(0, 1)\n>>> ((1 + 2*I)*(1 + 3*I)).as_real_imag()\n(-5, 5) \n```", "```py\nas_two_terms()\n```", "```py\n>>> from sympy.abc import x, y\n>>> (3*x - 2*y + 5).as_two_terms()\n(5, 3*x - 2*y) \n```", "```py\nextract_leading_order(symbols, point=None)\n```", "```py\n>>> from sympy.abc import x\n>>> (x + 1 + 1/x**5).extract_leading_order(x)\n((x**(-5), O(x**(-5))),)\n>>> (1 + x).extract_leading_order(x)\n((1, O(1)),)\n>>> (x + x**2).extract_leading_order(x)\n((x, O(x)),) \n```", "```py\nclassmethod flatten(seq)\n```", "```py\nprimitive()\n```", "```py\n>>> from sympy.abc import x, y \n```", "```py\n>>> (2*x + 4*y).primitive()\n(2, x + 2*y) \n```", "```py\n>>> (2*x/3 + 4*y/9).primitive()\n(2/9, 3*x + 2*y) \n```", "```py\n>>> (2*x/3 + 4.2*y).primitive()\n(1/3, 2*x + 12.6*y) \n```", "```py\n>>> ((2 + 2*x)*x + 2).primitive()\n(1, x*(2*x + 2) + 2) \n```", "```py\n>>> ((2 + 2*x)*x + 2).as_content_primitive()\n(2, x*(x + 1) + 1) \n```", "```py\nclass sympy.core.mod.Mod(p, q)\n```", "```py\n>>> from sympy import binomial, factorial, Mod, Pow\n>>> Mod(Pow(2, 10**16, evaluate=False), 97)\n61\n>>> Mod(factorial(10**9, evaluate=False), 10**9 + 9)\n712524808\n>>> Mod(binomial(10**18, 10**12, evaluate=False), (10**5 + 3)**2)\n3744312326 \n```", "```py\n>>> from sympy.abc import x, y\n>>> x**2 % y\nMod(x**2, y)\n>>> _.subs({x: 5, y: 6})\n1 \n```", "```py\nclass sympy.core.relational.Relational(lhs, rhs, rop=None, **assumptions)\n```", "```py\n>>> from sympy import Rel\n>>> from sympy.abc import x, y\n>>> Rel(y, x + x**2, '==')\nEq(y, x**2 + x) \n```", "```py\n>>> from sympy import Rel\n>>> from sympy.abc import x, y\n>>> Rel(y, x + x**2, '==')\n Eq(y, x**2 + x)\n>>> Rel(y, x + x**2, 'eq')\n Eq(y, x**2 + x)\n>>> Rel(y, x + x**2)\n Eq(y, x**2 + x)\n>>> Rel(y, x + x**2, 'lt')\n y < x**2 + x \n```", "```py\n>>> from sympy import Rel\n>>> from sympy.abc import x, y\n>>> my_equality = Rel(y, x + x**2, '==')\n>>> my_equality.rel_op\n '=='\n>>> my_inequality = Rel(y, x + x**2, 'lt')\n>>> my_inequality.rel_op\n '<' \n```", "```py\nproperty canonical\n```", "```py\n>>> from sympy.abc import x, y\n>>> x < 2\nx < 2\n>>> _.reversed.canonical\nx < 2\n>>> (-y < x).canonical\nx > -y\n>>> (-y > x).canonical\nx < -y\n>>> (-y < -x).canonical\nx < y \n```", "```py\n>>> from sympy import Eq\n>>> Eq(x < y, y > x).canonical\nTrue \n```", "```py\nequals(other, failing_expression=False)\n```", "```py\nproperty lhs\n```", "```py\nproperty negated\n```", "```py\n>>> from sympy import Eq\n>>> from sympy.abc import x\n>>> Eq(x, 1)\nEq(x, 1)\n>>> _.negated\nNe(x, 1)\n>>> x < 1\nx < 1\n>>> _.negated\nx >= 1 \n```", "```py\nproperty reversed\n```", "```py\n>>> from sympy import Eq\n>>> from sympy.abc import x\n>>> Eq(x, 1)\nEq(x, 1)\n>>> _.reversed\nEq(1, x)\n>>> x < 1\nx < 1\n>>> _.reversed\n1 > x \n```", "```py\nproperty reversedsign\n```", "```py\n>>> from sympy import Eq\n>>> from sympy.abc import x\n>>> Eq(x, 1)\nEq(x, 1)\n>>> _.reversedsign\nEq(-x, -1)\n>>> x < 1\nx < 1\n>>> _.reversedsign\n-x > -1 \n```", "```py\nproperty rhs\n```", "```py\nproperty strict\n```", "```py\n>>> from sympy.abc import x\n>>> (x <= 1).strict\nx < 1\n>>> _.strict\nx < 1 \n```", "```py\nproperty weak\n```", "```py\n>>> from sympy.abc import x\n>>> (x < 1).weak\nx <= 1\n>>> _.weak\nx <= 1 \n```", "```py\nsympy.core.relational.Rel\n```", "```py\nsympy.core.relational.Eq\n```", "```py\nsympy.core.relational.Ne\n```", "```py\nsympy.core.relational.Lt\n```", "```py\nsympy.core.relational.Le\n```", "```py\nsympy.core.relational.Gt\n```", "```py\nsympy.core.relational.Ge\n```", "```py\nclass sympy.core.relational.Equality(lhs, rhs, **options)\n```", "```py\n>>> from sympy import Eq, simplify, exp, cos\n>>> from sympy.abc import x, y\n>>> Eq(y, x + x**2)\nEq(y, x**2 + x)\n>>> Eq(2, 5)\nFalse\n>>> Eq(2, 5, evaluate=False)\nEq(2, 5)\n>>> _.doit()\nFalse\n>>> Eq(exp(x), exp(x).rewrite(cos))\nEq(exp(x), sinh(x) + cosh(x))\n>>> simplify(_)\nTrue \n```", "```py\n>>> Eq(True, 1), True == 1\n(False, True) \n```", "```py\nas_poly(*gens, **kwargs)\n```", "```py\n>>> from sympy import Eq\n>>> from sympy.abc import x\n>>> Eq(x**2, 1).as_poly(x)\nPoly(x**2 - 1, x, domain='ZZ') \n```", "```py\nintegrate(*args, **kwargs)\n```", "```py\nclass sympy.core.relational.GreaterThan(lhs, rhs, **options)\n```", "```py\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational \n```", "```py\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x' \n```", "```py\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2 \n```", "```py\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue \n```", "```py\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1 \n```", "```py\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1 \n```", "```py\n> >>> 1 < x\n> \n> x > 1 \n> ```", "```py\n> >>> S(1) < x\n> \n> 1 < x \n> ```", "```py\n> >>> Lt(1, x)\n> \n> 1 < x\n> \n> >>> Relational(1, x, \"<\")\n> \n> 1 < x \n> ```", "```py\n> >>> e = x < 1; e\n> \n> x < 1\n> \n> >>> e == e  # neither side is a literal\n> \n> True\n> \n> >>> e == x < 1  # expecting True, too\n> \n> False\n> \n> >>> e != x < 1  # expecting False\n> \n> x < 1\n> \n> >>> x < 1 != x < 1  # expecting False or the same thing as before\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: cannot determine truth value of Relational \n> ```", "```py\n> >>> e == (x < 1)\n> \n> True\n> \n> >>> e != (x < 1)\n> \n> False\n> \n> >>> (x < 1) != (x < 1)\n> \n> False \n> ```", "```py\n> >>> e = x < y < z\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: symbolic boolean expression has no truth value. \n> ```", "```py\n> >>> e = And(x < y, y < z)\n> \n> >>> type( e )\n> \n> And\n> \n> >>> e\n> \n> (x < y) & (y < z) \n> ```", "```py\n> >>> (x < y) & (y < z)\n> \n> (x < y) & (y < z)\n> \n> >>> (x < y) and (y < z)\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: cannot determine truth value of Relational \n> ```", "```py\nclass sympy.core.relational.LessThan(lhs, rhs, **options)\n```", "```py\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational \n```", "```py\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x' \n```", "```py\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2 \n```", "```py\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue \n```", "```py\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1 \n```", "```py\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1 \n```", "```py\n> >>> 1 < x\n> \n> x > 1 \n> ```", "```py\n> >>> S(1) < x\n> \n> 1 < x \n> ```", "```py\n> >>> Lt(1, x)\n> \n> 1 < x\n> \n> >>> Relational(1, x, \"<\")\n> \n> 1 < x \n> ```", "```py\n> >>> e = x < 1; e\n> \n> x < 1\n> \n> >>> e == e  # neither side is a literal\n> \n> True\n> \n> >>> e == x < 1  # expecting True, too\n> \n> False\n> \n> >>> e != x < 1  # expecting False\n> \n> x < 1\n> \n> >>> x < 1 != x < 1  # expecting False or the same thing as before\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: cannot determine truth value of Relational \n> ```", "```py\n> >>> e == (x < 1)\n> \n> True\n> \n> >>> e != (x < 1)\n> \n> False\n> \n> >>> (x < 1) != (x < 1)\n> \n> False \n> ```", "```py\n> >>> e = x < y < z\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: symbolic boolean expression has no truth value. \n> ```", "```py\n> >>> e = And(x < y, y < z)\n> \n> >>> type( e )\n> \n> And\n> \n> >>> e\n> \n> (x < y) & (y < z) \n> ```", "```py\n> >>> (x < y) & (y < z)\n> \n> (x < y) & (y < z)\n> \n> >>> (x < y) and (y < z)\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: cannot determine truth value of Relational \n> ```", "```py\nclass sympy.core.relational.Unequality(lhs, rhs, **options)\n```", "```py\n>>> from sympy import Ne\n>>> from sympy.abc import x, y\n>>> Ne(y, x+x**2)\nNe(y, x**2 + x) \n```", "```py\nclass sympy.core.relational.StrictGreaterThan(lhs, rhs, **options)\n```", "```py\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational \n```", "```py\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x' \n```", "```py\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2 \n```", "```py\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue \n```", "```py\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1 \n```", "```py\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1 \n```", "```py\n> >>> 1 < x\n> \n> x > 1 \n> ```", "```py\n> >>> S(1) < x\n> \n> 1 < x \n> ```", "```py\n> >>> Lt(1, x)\n> \n> 1 < x\n> \n> >>> Relational(1, x, \"<\")\n> \n> 1 < x \n> ```", "```py\n> >>> e = x < 1; e\n> \n> x < 1\n> \n> >>> e == e  # neither side is a literal\n> \n> True\n> \n> >>> e == x < 1  # expecting True, too\n> \n> False\n> \n> >>> e != x < 1  # expecting False\n> \n> x < 1\n> \n> >>> x < 1 != x < 1  # expecting False or the same thing as before\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: cannot determine truth value of Relational \n> ```", "```py\n> >>> e == (x < 1)\n> \n> True\n> \n> >>> e != (x < 1)\n> \n> False\n> \n> >>> (x < 1) != (x < 1)\n> \n> False \n> ```", "```py\n> >>> e = x < y < z\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: symbolic boolean expression has no truth value. \n> ```", "```py\n> >>> e = And(x < y, y < z)\n> \n> >>> type( e )\n> \n> And\n> \n> >>> e\n> \n> (x < y) & (y < z) \n> ```", "```py\n> >>> (x < y) & (y < z)\n> \n> (x < y) & (y < z)\n> \n> >>> (x < y) and (y < z)\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: cannot determine truth value of Relational \n> ```", "```py\nclass sympy.core.relational.StrictLessThan(lhs, rhs, **options)\n```", "```py\n>>> from sympy import GreaterThan, StrictGreaterThan\n>>> from sympy import LessThan, StrictLessThan\n>>> from sympy import And, Ge, Gt, Le, Lt, Rel, S\n>>> from sympy.abc import x, y, z\n>>> from sympy.core.relational import Relational \n```", "```py\n>>> e = GreaterThan(x, 1)\n>>> e\nx >= 1\n>>> '%s >= %s is the same as %s <= %s' % (e.gts, e.lts, e.lts, e.gts)\n'x >= 1 is the same as 1 <= x' \n```", "```py\n>>> for f in [Ge, Gt, Le, Lt]:  # convenience wrappers\n...     print(f(x, 2))\nx >= 2\nx > 2\nx <= 2\nx < 2 \n```", "```py\n>>> x >= 2\nx >= 2\n>>> _ == Ge(x, 2)\nTrue \n```", "```py\n>>> Rel(x, 1, \">\")\nx > 1\n>>> Relational(x, 1, \">\")\nx > 1 \n```", "```py\n>>> StrictGreaterThan(x, 1)\nx > 1\n>>> GreaterThan(x, 1)\nx >= 1\n>>> LessThan(x, 1)\nx <= 1\n>>> StrictLessThan(x, 1)\nx < 1 \n```", "```py\n> >>> 1 < x\n> \n> x > 1 \n> ```", "```py\n> >>> S(1) < x\n> \n> 1 < x \n> ```", "```py\n> >>> Lt(1, x)\n> \n> 1 < x\n> \n> >>> Relational(1, x, \"<\")\n> \n> 1 < x \n> ```", "```py\n> >>> e = x < 1; e\n> \n> x < 1\n> \n> >>> e == e  # neither side is a literal\n> \n> True\n> \n> >>> e == x < 1  # expecting True, too\n> \n> False\n> \n> >>> e != x < 1  # expecting False\n> \n> x < 1\n> \n> >>> x < 1 != x < 1  # expecting False or the same thing as before\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: cannot determine truth value of Relational \n> ```", "```py\n> >>> e == (x < 1)\n> \n> True\n> \n> >>> e != (x < 1)\n> \n> False\n> \n> >>> (x < 1) != (x < 1)\n> \n> False \n> ```", "```py\n> >>> e = x < y < z\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: symbolic boolean expression has no truth value. \n> ```", "```py\n> >>> e = And(x < y, y < z)\n> \n> >>> type( e )\n> \n> And\n> \n> >>> e\n> \n> (x < y) & (y < z) \n> ```", "```py\n> >>> (x < y) & (y < z)\n> \n> (x < y) & (y < z)\n> \n> >>> (x < y) and (y < z)\n> \n> Traceback (most recent call last):\n> \n> ...\n> \n> TypeError: cannot determine truth value of Relational \n> ```", "```py\nclass sympy.core.multidimensional.vectorize(*mdargs)\n```", "```py\n>>> from sympy import vectorize, diff, sin, symbols, Function\n>>> x, y, z = symbols('x y z')\n>>> f, g, h = list(map(Function, 'fgh')) \n```", "```py\n>>> @vectorize(0)\n... def vsin(x):\n...     return sin(x) \n```", "```py\n>>> vsin([1, x, y])\n[sin(1), sin(x), sin(y)] \n```", "```py\n>>> @vectorize(0, 1)\n... def vdiff(f, y):\n...     return diff(f, y) \n```", "```py\n>>> vdiff([f(x, y, z), g(x, y, z), h(x, y, z)], [x, y, z])\n[[Derivative(f(x, y, z), x), Derivative(f(x, y, z), y), Derivative(f(x, y, z), z)], [Derivative(g(x, y, z), x), Derivative(g(x, y, z), y), Derivative(g(x, y, z), z)], [Derivative(h(x, y, z), x), Derivative(h(x, y, z), y), Derivative(h(x, y, z), z)]] \n```", "```py\nclass sympy.core.function.Lambda(signature, expr)\n```", "```py\n>>> from sympy import Lambda\n>>> from sympy.abc import x\n>>> f = Lambda(x, x**2)\n>>> f(4)\n16 \n```", "```py\n>>> from sympy.abc import y, z, t\n>>> f2 = Lambda((x, y, z, t), x + y**z + t**z)\n>>> f2(1, 2, 3, 4)\n73 \n```", "```py\n>>> f = Lambda(((x, y), z), x + y + z)\n>>> f((1, 2), 3)\n6 \n```", "```py\n>>> p = x, y, z\n>>> f = Lambda(p, x + y*z)\n>>> f(*p)\nx + y*z \n```", "```py\nproperty bound_symbols\n```", "```py\nproperty expr\n```", "```py\nproperty is_identity\n```", "```py\nproperty signature\n```", "```py\nproperty variables\n```", "```py\nclass sympy.core.function.WildFunction(*args)\n```", "```py\n>>> from sympy import WildFunction, Function, cos\n>>> from sympy.abc import x, y\n>>> F = WildFunction('F')\n>>> f = Function('f')\n>>> F.nargs\nNaturals0\n>>> x.match(F)\n>>> F.match(F)\n{F_: F_}\n>>> f(x).match(F)\n{F_: f(x)}\n>>> cos(x).match(F)\n{F_: cos(x)}\n>>> f(x, y).match(F)\n{F_: f(x, y)} \n```", "```py\n>>> F = WildFunction('F', nargs=2)\n>>> F.nargs\n{2}\n>>> f(x).match(F)\n>>> f(x, y).match(F)\n{F_: f(x, y)} \n```", "```py\n>>> F = WildFunction('F', nargs=(1, 2))\n>>> F.nargs\n{1, 2}\n>>> f(x).match(F)\n{F_: f(x)}\n>>> f(x, y).match(F)\n{F_: f(x, y)}\n>>> f(x, y, 1).match(F) \n```", "```py\nclass sympy.core.function.Derivative(expr, *variables, **kwargs)\n```", "```py\n>>> from sympy import Derivative, Function, symbols, Subs\n>>> from sympy.abc import x, y\n>>> f, g = symbols('f g', cls=Function) \n```", "```py\n>>> Derivative(x**2, x, evaluate=True)\n2*x \n```", "```py\n>>> Derivative(Derivative(f(x, y), y), x)\nDerivative(f(x, y), y, x) \n```", "```py\n>>> Derivative(f(x), x, x, y, x)\nDerivative(f(x), (x, 2), y, x) \n```", "```py\n>>> Derivative(f(x, y), y, x, evaluate=True)\nDerivative(f(x, y), x, y) \n```", "```py\n>>> Derivative(f(x)**2, f(x), evaluate=True)\n2*f(x) \n```", "```py\n>>> f(g(x)).diff(x)\nDerivative(f(g(x)), g(x))*Derivative(g(x), x) \n```", "```py\n>>> f(2*x + 3).diff(x) == 2*Subs(f(y).diff(y), y, 2*x + 3)\nTrue \n```", "```py\n>>> from sympy import sqrt, diff, Function, symbols\n>>> from sympy.abc import x, y, z\n>>> f, g = symbols('f,g', cls=Function) \n```", "```py\n>>> e = sqrt((x + 1)**2 + x)\n>>> diff(e, (x, 5), simplify=False).count_ops()\n136\n>>> diff(e, (x, 5)).count_ops()\n30 \n```", "```py\n>>> (x*y*z).diff(x*y)\nTraceback (most recent call last):\n...\nValueError: Can't calculate derivative wrt x*y. \n```", "```py\n>>> from sympy.abc import t\n>>> F = Function('F')\n>>> U = f(t)\n>>> V = U.diff(t) \n```", "```py\n>>> direct = F(t, U, V).diff(U) \n```", "```py\n>>> indirect = F(t, U, V).subs(U, x).diff(x).subs(x, U)\n>>> assert direct == indirect \n```", "```py\n>>> x.diff(f(x))\n0\n>>> g(x).diff(f(x))\n0 \n```", "```py\n>>> F = f(x)\n>>> Fx = F.diff(x)\n>>> Fx.diff(F)  # derivative depends on x, not F\n0\n>>> Fxx = Fx.diff(x)\n>>> Fxx.diff(Fx)  # derivative depends on x, not Fx\n0 \n```", "```py\n> >>> Fxx.subs(Fx, y)\n> \n> Derivative(y, x) \n> ```", "```py\n> >>> _.doit()\n> \n> 0 \n> ```", "```py\n>>> eq = f(x)*g(y)\n>>> eq.subs(f(x), x*y).diff(x, y).doit()\ny*Derivative(g(y), y) + g(y)\n>>> eq.diff(x, y).subs(f(x), x*y).doit()\ny*Derivative(g(y), y) \n```", "```py\nproperty _diff_wrt\n```", "```py\n>>> from sympy import Function, Derivative, cos\n>>> from sympy.abc import x\n>>> f = Function('f') \n```", "```py\n>>> Derivative(f(x), x)._diff_wrt\nTrue\n>>> Derivative(cos(x), x)._diff_wrt\nFalse\n>>> Derivative(x + 1, x)._diff_wrt\nFalse \n```", "```py\n>>> Derivative(f(f(x)), x).doit()\nDerivative(f(x), x)*Derivative(f(f(x)), f(x)) \n```", "```py\n>>> Derivative(f(f(x)), x)._diff_wrt\nFalse \n```", "```py\nclassmethod _sort_variable_count(vc)\n```", "```py\n>>> from sympy import Derivative, Function, symbols\n>>> vsort = Derivative._sort_variable_count\n>>> x, y, z = symbols('x y z')\n>>> f, g, h = symbols('f g h', cls=Function) \n```", "```py\n>>> vsort([(x, 1), (x, 1)])\n[(x, 2)]\n>>> vsort([(y, 1), (f(x), 1), (y, 1), (f(x), 1)])\n[(y, 2), (f(x), 2)] \n```", "```py\n>>> def vsort0(*v):\n...     # docstring helper to\n...     # change vi -> (vi, 0), sort, and return vi vals\n...     return [i[0] for i in vsort([(i, 0) for i in v])] \n```", "```py\n>>> vsort0(y, x)\n[x, y]\n>>> vsort0(g(y), g(x), f(y))\n[f(y), g(x), g(y)] \n```", "```py\n>>> dfx = f(x).diff(x)\n>>> assert vsort0(dfx, y) == [y, dfx]\n>>> assert vsort0(dfx, x) == [dfx, x] \n```", "```py\nas_finite_difference(points=1, x0=None, wrt=None)\n```", "```py\n>>> from sympy import symbols, Function, exp, sqrt, Symbol\n>>> x, h = symbols('x h')\n>>> f = Function('f')\n>>> f(x).diff(x).as_finite_difference()\n-f(x - 1/2) + f(x + 1/2) \n```", "```py\n>>> f(x).diff(x).as_finite_difference(h)\n-f(-h/2 + x)/h + f(h/2 + x)/h \n```", "```py\n>>> f(x).diff(x).as_finite_difference([x, x+h, x+2*h])\n-3*f(x)/(2*h) + 2*f(h + x)/h - f(2*h + x)/(2*h) \n```", "```py\n>>> e, sq2 = exp(1), sqrt(2)\n>>> xl = [x-h, x+h, x+e*h]\n>>> f(x).diff(x, 1).as_finite_difference(xl, x+h*sq2)  \n2*h*((h + sqrt(2)*h)/(2*h) - (-sqrt(2)*h + h)/(2*h))*f(E*h + x)/... \n```", "```py\n>>> dx = Function('dx')\n>>> f(x).diff(x).as_finite_difference(points=dx(x), x0=x-h)\n-f(-h + x - dx(-h + x)/2)/dx(-h + x) + f(-h + x + dx(-h + x)/2)/dx(-h + x) \n```", "```py\n>>> y = Symbol('y')\n>>> d2fdxdy=f(x,y).diff(x,y)\n>>> d2fdxdy.as_finite_difference(wrt=x)\n-Derivative(f(x - 1/2, y), y) + Derivative(f(x + 1/2, y), y) \n```", "```py\n>>> (1 + 42**f(x).diff(x)).replace(lambda arg: arg.is_Derivative,\n...     lambda arg: arg.as_finite_difference())\n42**(-f(x - 1/2) + f(x + 1/2)) + 1 \n```", "```py\ndoit_numerically(z0)\n```", "```py\nsympy.core.function.diff(f, *symbols, **kwargs)\n```", "```py\n>>> from sympy import sin, cos, Function, diff\n>>> from sympy.abc import x, y\n>>> f = Function('f') \n```", "```py\n>>> diff(sin(x), x)\ncos(x)\n>>> diff(f(x), x, x, x)\nDerivative(f(x), (x, 3))\n>>> diff(f(x), x, 3)\nDerivative(f(x), (x, 3))\n>>> diff(sin(x)*cos(y), x, 2, y, 2)\nsin(x)*cos(y) \n```", "```py\n>>> type(diff(sin(x), x))\ncos\n>>> type(diff(sin(x), x, evaluate=False))\n<class 'sympy.core.function.Derivative'>\n>>> type(diff(sin(x), x, 0))\nsin\n>>> type(diff(sin(x), x, 0, evaluate=False))\nsin \n```", "```py\n>>> diff(sin(x))\ncos(x)\n>>> diff(sin(x*y))\nTraceback (most recent call last):\n...\nValueError: specify differentiation variables to differentiate sin(x*y) \n```", "```py\nclass sympy.core.function.FunctionClass(*args, **kwargs)\n```", "```py\nproperty nargs\n```", "```py\n>>> from sympy import Function\n>>> f = Function('f') \n```", "```py\n>>> Function('f').nargs\nNaturals0 \n```", "```py\n>>> Function('f', nargs=1).nargs\n{1}\n>>> Function('f', nargs=(2, 1)).nargs\n{1, 2} \n```", "```py\n>>> f = Function('f')\n>>> f(1).nargs\nNaturals0\n>>> len(f(1).args)\n1 \n```", "```py\nclass sympy.core.function.Function(*args)\n```", "```py\n>>> from sympy import Function, Symbol\n>>> x = Symbol('x')\n>>> f = Function('f')\n>>> g = Function('g')(x)\n>>> f\nf\n>>> f(x)\nf(x)\n>>> g\ng(x)\n>>> f(x).diff(x)\nDerivative(f(x), x)\n>>> g.diff(x)\nDerivative(g(x), x) \n```", "```py\n>>> f_real = Function('f', real=True)\n>>> f_real(x).is_real\nTrue\n>>> f_real_inherit = Function(Symbol('f', real=True))\n>>> f_real_inherit(x).is_real\nTrue \n```", "```py\nas_base_exp()\n```", "```py\nfdiff(argindex=1)\n```", "```py\nclassmethod is_singular(a)\n```", "```py\n>>> from sympy import Function, cos\n>>> from sympy.abc import x\n>>> f = Function('f')\n>>> f(2) + f(x)\nf(2) + f(x) \n```", "```py\n>>> e = (f(x) + cos(x) + 2)\n>>> e.atoms(Function)\n{f(x), cos(x)} \n```", "```py\n>>> from sympy.core.function import AppliedUndef\n>>> e.atoms(AppliedUndef)\n{f(x)} \n```", "```py\nclass sympy.core.function.Subs(expr, variables, point, **assumptions)\n```", "```py\n>>> from sympy import Subs, Function, sin, cos\n>>> from sympy.abc import x, y, z\n>>> f = Function('f') \n```", "```py\n>>> f(x).diff(x).subs(x, 0)\nSubs(Derivative(f(x), x), x, 0) \n```", "```py\n>>> _.subs(f, sin).doit() == sin(x).diff(x).subs(x, 0) == cos(0)\nTrue \n```", "```py\n>>> Subs(f(x)*sin(y) + z, (x, y), (0, 1))\nSubs(z + f(x)*sin(y), (x, y), (0, 1))\n>>> _.doit()\nz + f(0)*sin(1) \n```", "```py\n>>> a, b = Subs(x, x, 0), Subs(y, y, 0)\n>>> a + b\n2*Subs(x, x, 0) \n```", "```py\n>>> s = Subs(x, x, 0)\n>>> s.has(x), s.has(y)\n(True, False)\n>>> ss = s.subs(x, y)\n>>> ss.has(x), ss.has(y)\n(True, False)\n>>> s, ss\n(Subs(x, x, 0), Subs(y, y, 0)) \n```", "```py\nproperty bound_symbols\n```", "```py\nproperty expr\n```", "```py\nproperty point\n```", "```py\nproperty variables\n```", "```py\nsympy.core.function.expand(e, deep=True, modulus=None, power_base=True, power_exp=True, mul=True, log=True, multinomial=True, basic=True, **hints)\n```", "```py\n>>> from sympy import cos, exp, sin\n>>> from sympy.abc import x, y, z\n>>> (y*(x + z)).expand(mul=True)\nx*y + y*z \n```", "```py\n>>> ((x + y + z)**2).expand(multinomial=True)\nx**2 + 2*x*y + 2*x*z + y**2 + 2*y*z + z**2 \n```", "```py\n>>> exp(x + y).expand(power_exp=True)\nexp(x)*exp(y)\n>>> (2**(x + y)).expand(power_exp=True)\n2**x*2**y \n```", "```py\n>>> ((x*y)**z).expand(power_base=True)\n(x*y)**z\n>>> ((x*y)**z).expand(power_base=True, force=True)\nx**z*y**z\n>>> ((2*y)**z).expand(power_base=True)\n2**z*y**z \n```", "```py\n>>> (x*y)**2\nx**2*y**2 \n```", "```py\n>>> from sympy import log, symbols\n>>> log(x**2*y).expand(log=True)\nlog(x**2*y)\n>>> log(x**2*y).expand(log=True, force=True)\n2*log(x) + log(y)\n>>> x, y = symbols('x,y', positive=True)\n>>> log(x**2*y).expand(log=True)\n2*log(x) + log(y) \n```", "```py\n>>> x, y = symbols('x,y')\n>>> (x + y).expand(complex=True)\nre(x) + re(y) + I*im(x) + I*im(y)\n>>> cos(x).expand(complex=True)\n-I*sin(re(x))*sinh(im(x)) + cos(re(x))*cosh(im(x)) \n```", "```py\n>>> from sympy import gamma\n>>> gamma(x + 1).expand(func=True)\nx*gamma(x) \n```", "```py\n>>> cos(x + y).expand(trig=True)\n-sin(x)*sin(y) + cos(x)*cos(y)\n>>> sin(2*x).expand(trig=True)\n2*sin(x)*cos(x) \n```", "```py\n    >>> (exp(x + y)*(x + y)).expand()\n    x*exp(x)*exp(y) + y*exp(x)*exp(y)\n    >>> (exp(x + y)*(x + y)).expand(power_exp=False)\n    x*exp(x + y) + y*exp(x + y)\n    >>> (exp(x + y)*(x + y)).expand(mul=False)\n    (x + y)*exp(x)*exp(y) \n    ```", "```py\n    >>> exp(x + exp(x + y)).expand()\n    exp(x)*exp(exp(x)*exp(y))\n    >>> exp(x + exp(x + y)).expand(deep=False)\n    exp(x)*exp(exp(x + y)) \n    ```", "```pymultinomial`, the expression might not be fully distributed. The solution is to use the various ``expand_hint```", "```py\n    >>> from sympy import expand, expand_mul, expand_power_base\n    >>> x, y, z = symbols('x,y,z', positive=True)\n\n    >>> expand(log(x*(y + z)))\n    log(x) + log(y + z) \n    ```", "```py\n    >>> expand_mul(log(x*(y + z)))\n    log(x*y + x*z)\n    >>> expand(log(x*(y + z)), log=False)\n    log(x*y + x*z) \n    ```", "```py\n    >>> expand((x*(y + z))**x)\n    (x*y + x*z)**x \n    ```", "```py\n    >>> expand((x*(y + z))**x, mul=False)\n    x**x*(y + z)**x\n    >>> expand_power_base((x*(y + z))**x)\n    x**x*(y + z)**x\n\n    >>> expand((x + y)*y/x)\n    y + y**2/x \n    ```", "```py\n    >>> expand((x + y)*y/x/(x + 1), frac=True)\n    (x*y + y**2)/(x**2 + x)\n    >>> expand((x + y)*y/x/(x + 1), numer=True)\n    (x*y + y**2)/(x*(x + 1))\n    >>> expand((x + y)*y/x/(x + 1), denom=True)\n    y*(x + y)/(x**2 + x) \n    ```", "```py\n    >>> expand((3*x + 1)**2)\n    9*x**2 + 6*x + 1\n    >>> expand((3*x + 1)**2, modulus=5)\n    4*x**2 + x + 1 \n    ```", "```py\n    >>> expand((x + 1)**2)\n    x**2 + 2*x + 1\n    >>> ((x + 1)**2).expand()\n    x**2 + 2*x + 1 \n    ```", "```py\ndef _eval_expand_hint(self, **hints):\n    # Only apply the method to the top-level expression\n    ... \n```", "```pyAttributeError``s.  Note, again, that you do not need to recursively apply the hint to args of your object: this is handled automatically by ``expand()```", "```py\n>>> from sympy import Expr, sympify\n>>> class MyClass(Expr):\n...     def __new__(cls, *args):\n...         args = sympify(args)\n...         return Expr.__new__(cls, *args)\n...\n...     def _eval_expand_double(self, *, force=False, **hints):\n...  '''\n...         Doubles the args of MyClass.\n...\n...         If there more than four args, doubling is not performed,\n...         unless force=True is also used (False by default).\n...         '''\n...         if not force and len(self.args) > 4:\n...             return self\n...         return self.func(*(self.args + self.args))\n...\n>>> a = MyClass(1, 2, MyClass(3, 4))\n>>> a\nMyClass(1, 2, MyClass(3, 4))\n>>> a.expand(double=True)\nMyClass(1, 2, MyClass(3, 4, 3, 4), 1, 2, MyClass(3, 4, 3, 4))\n>>> a.expand(double=True, deep=False)\nMyClass(1, 2, MyClass(3, 4), 1, 2, MyClass(3, 4)) \n```", "```py\n>>> b = MyClass(1, 2, 3, 4, 5)\n>>> b.expand(double=True)\nMyClass(1, 2, 3, 4, 5)\n>>> b.expand(double=True, force=True)\nMyClass(1, 2, 3, 4, 5, 1, 2, 3, 4, 5) \n```", "```py\nclass sympy.core.function.PoleError\n```", "```py\nsympy.core.function.count_ops(expr, visual=False)\n```", "```py\n>>> from sympy.abc import a, b, x, y\n>>> from sympy import sin, count_ops \n```", "```py\n>>> (x - y).count_ops(visual=True)\nSUB\n>>> (-x).count_ops(visual=True)\nNEG \n```", "```py\n>>> (1 + a + b**2).count_ops(visual=True)\n2*ADD + POW \n```", "```py\n>>> (sin(x)*x + sin(x)**2).count_ops(visual=True)\nADD + MUL + POW + 2*SIN \n```", "```py\n>>> (sin(x)*x + sin(x)**2).count_ops(visual=False)\n5 \n```", "```py\n>>> (1/x/y).count_ops(visual=True)\nDIV + MUL \n```", "```py\n>>> eq=x*(1 + x*(2 + x*(3 + x)))\n>>> count_ops(eq.expand(), visual=True) - count_ops(eq, visual=True)\n-MUL + 3*POW \n```", "```py\n>>> count_ops([x, sin(x), None, True, x + 2], visual=False)\n2\n>>> count_ops([x, sin(x), None, True, x + 2], visual=True)\nADD + SIN\n>>> count_ops({x: sin(x), x + 2: y + 1}, visual=True)\n2*ADD + SIN \n```", "```py\nsympy.core.function.expand_mul(expr, deep=True)\n```", "```py\n>>> from sympy import symbols, expand_mul, exp, log\n>>> x, y = symbols('x,y', positive=True)\n>>> expand_mul(exp(x+y)*(x+y)*log(x*y**2))\nx*exp(x + y)*log(x*y**2) + y*exp(x + y)*log(x*y**2) \n```", "```py\nsympy.core.function.expand_log(expr, deep=True, force=False, factor=False)\n```", "```py\n>>> from sympy import symbols, expand_log, exp, log\n>>> x, y = symbols('x,y', positive=True)\n>>> expand_log(exp(x+y)*(x+y)*log(x*y**2))\n(x + y)*(log(x) + 2*log(y))*exp(x + y) \n```", "```py\nsympy.core.function.expand_func(expr, deep=True)\n```", "```py\n>>> from sympy import expand_func, gamma\n>>> from sympy.abc import x\n>>> expand_func(gamma(x + 2))\nx*(x + 1)*gamma(x) \n```", "```py\nsympy.core.function.expand_trig(expr, deep=True)\n```", "```py\n>>> from sympy import expand_trig, sin\n>>> from sympy.abc import x, y\n>>> expand_trig(sin(x+y)*(x+y))\n(x + y)*(sin(x)*cos(y) + sin(y)*cos(x)) \n```", "```py\nsympy.core.function.expand_complex(expr, deep=True)\n```", "```py\n>>> from sympy import expand_complex, exp, sqrt, I\n>>> from sympy.abc import z\n>>> expand_complex(exp(z))\nI*exp(re(z))*sin(im(z)) + exp(re(z))*cos(im(z))\n>>> expand_complex(sqrt(I))\nsqrt(2)/2 + sqrt(2)*I/2 \n```", "```py\nsympy.core.function.expand_multinomial(expr, deep=True)\n```", "```py\n>>> from sympy import symbols, expand_multinomial, exp\n>>> x, y = symbols('x y', positive=True)\n>>> expand_multinomial((x + exp(x + 1))**2)\nx**2 + 2*x*exp(x + 1) + exp(2*x + 2) \n```", "```py\nsympy.core.function.expand_power_exp(expr, deep=True)\n```", "```py\n>>> from sympy import expand_power_exp, Symbol\n>>> from sympy.abc import x, y\n>>> expand_power_exp(3**(y + 2))\n9*3**y\n>>> expand_power_exp(x**(y + 2))\nx**(y + 2) \n```", "```py\n>>> expand_power_exp(Symbol('x', zero=False)**(y + 2))\nx**2*x**y \n```", "```py\nsympy.core.function.expand_power_base(expr, deep=True, force=False)\n```", "```py\n>>> from sympy.abc import x, y, z\n>>> from sympy import expand_power_base, sin, cos, exp, Symbol \n```", "```py\n>>> (x*y)**2\nx**2*y**2 \n```", "```py\n>>> (2*x)**y\n(2*x)**y\n>>> expand_power_base(_)\n2**y*x**y \n```", "```py\n>>> expand_power_base((x*y)**z)\n(x*y)**z\n>>> expand_power_base((x*y)**z, force=True)\nx**z*y**z\n>>> expand_power_base(sin((x*y)**z), deep=False)\nsin((x*y)**z)\n>>> expand_power_base(sin((x*y)**z), force=True)\nsin(x**z*y**z) \n```", "```py\n>>> expand_power_base((2*sin(x))**y + (2*cos(x))**y)\n2**y*sin(x)**y + 2**y*cos(x)**y \n```", "```py\n>>> expand_power_base((2*exp(y))**x)\n2**x*exp(y)**x \n```", "```py\n>>> expand_power_base((2*cos(x))**y)\n2**y*cos(x)**y \n```", "```py\n>>> expand_power_base(((x+y)*z)**2)\nz**2*(x + y)**2\n>>> (((x+y)*z)**2).expand()\nx**2*z**2 + 2*x*y*z**2 + y**2*z**2 \n```", "```py\n>>> expand_power_base((2*y)**(1+z))\n2**(z + 1)*y**(z + 1)\n>>> ((2*y)**(1+z)).expand()\n2*2**z*y**(z + 1) \n```", "```py\n>>> prev = _ \n```", "```py\n>>> p = Symbol('p', positive=True)\n>>> prev.subs(y, p).expand().subs(p, 0)\n0 \n```", "```py\n>>> prev.subs(y, 0).subs(z, -1)\n1 \n```", "```py\nsympy.core.function.nfloat(expr, n=15, exponent=False, dkeys=False)\n```", "```py\n>>> from sympy import nfloat, cos, pi, sqrt\n>>> from sympy.abc import x, y\n>>> nfloat(x**4 + x/2 + cos(pi/3) + 1 + sqrt(y))\nx**4 + 0.5*x + sqrt(y) + 1.5\n>>> nfloat(x**4 + sqrt(y), exponent=True)\nx**4.0 + y**0.5 \n```", "```py\n>>> type(nfloat((1, 2))) is tuple\nTrue \n```", "```py\nclass sympy.core.evalf.EvalfMixin\n```", "```py\nevalf(n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False)\n```", "```py\n> >>> from sympy import N\n> \n> >>> x = 1e-4\n> \n> >>> N(x, chop=True)\n> \n> 0.000100000000000000\n> \n> >>> N(x, chop=1e-5)\n> \n> 0.000100000000000000\n> \n> >>> N(x, chop=1e-4)\n> \n> 0 \n> ```", "```py\n>>> from sympy.abc import x, y, z\n>>> values = {x: 1e16, y: 1, z: 1e16}\n>>> (x + y - z).subs(values)\n0 \n```", "```py\n>>> (x + y - z).evalf(subs=values)\n1.00000000000000 \n```", "```py\nn(n=15, subs=None, maxn=100, chop=False, strict=False, quad=None, verbose=False)\n```", "```py\n> >>> from sympy import N\n> \n> >>> x = 1e-4\n> \n> >>> N(x, chop=True)\n> \n> 0.000100000000000000\n> \n> >>> N(x, chop=1e-5)\n> \n> 0.000100000000000000\n> \n> >>> N(x, chop=1e-4)\n> \n> 0 \n> ```", "```py\n>>> from sympy.abc import x, y, z\n>>> values = {x: 1e16, y: 1, z: 1e16}\n>>> (x + y - z).subs(values)\n0 \n```", "```py\n>>> (x + y - z).evalf(subs=values)\n1.00000000000000 \n```", "```py\nclass sympy.core.evalf.PrecisionExhausted\n```", "```py\nsympy.core.evalf.N(x, n=15, **options)\n```", "```py\n>>> from sympy import Sum, oo, N\n>>> from sympy.abc import k\n>>> Sum(1/k**k, (k, 1, oo))\nSum(k**(-k), (k, 1, oo))\n>>> N(_, 4)\n1.291 \n```", "```py\nclass sympy.core.containers.Tuple(*args, **kwargs)\n```", "```py\n>>> from sympy import Tuple, symbols\n>>> a, b, c, d = symbols('a b c d')\n>>> Tuple(a, b, c)[1:]\n(b, c)\n>>> Tuple(a, b, c).subs(a, d)\n(d, b, c) \n```", "```py\nindex(value, start=None, stop=None)\n```", "```py\nproperty kind\n```", "```py\n>>> from sympy import Tuple, Matrix\n>>> Tuple(1, 2).kind\nTupleKind(NumberKind, NumberKind)\n>>> Tuple(Matrix([1, 2]), 1).kind\nTupleKind(MatrixKind(NumberKind), NumberKind)\n>>> Tuple(1, 2).kind.element_kind\n(NumberKind, NumberKind) \n```", "```py\ntuple_count(value) → int\n```", "```py\nclass sympy.core.containers.TupleKind(*args)\n```", "```py\n>>> from sympy import Tuple\n>>> Tuple(1, 2).kind\nTupleKind(NumberKind, NumberKind)\n>>> Tuple(1, 2).kind.element_kind\n(NumberKind, NumberKind) \n```", "```py\nclass sympy.core.containers.Dict(*args)\n```", "```py\n>>> from sympy import Dict, Symbol \n```", "```py\n>>> D = Dict({1: 'one', 2: 'two'})\n>>> for key in D:\n...    if key == 1:\n...        print('%s  %s' % (key, D[key]))\n1 one \n```", "```py\n>>> 1 in D\nTrue\n>>> D.has(Symbol('one')) # searches keys and values\nTrue\n>>> 'one' in D # not in the keys\nFalse\n>>> D[1]\none \n```", "```py\nget(key, default=None)\n```", "```py\nitems()\n```", "```py\nkeys()\n```", "```py\nvalues()\n```", "```py\nsympy.core.exprtools.gcd_terms(terms, isprimitive=False, clear=True, fraction=True)\n```", "```py\n>>> from sympy import gcd_terms\n>>> from sympy.abc import x, y \n```", "```py\n>>> gcd_terms((x + 1)**2*y + (x + 1)*y**2)\ny*(x + 1)*(x + y + 1)\n>>> gcd_terms(x/2 + 1)\n(x + 2)/2\n>>> gcd_terms(x/2 + 1, clear=False)\nx/2 + 1\n>>> gcd_terms(x/2 + y/2, clear=False)\n(x + y)/2\n>>> gcd_terms(x/2 + 1/x)\n(x**2 + 2)/(2*x)\n>>> gcd_terms(x/2 + 1/x, fraction=False)\n(x + 2/x)/2\n>>> gcd_terms(x/2 + 1/x, fraction=False, clear=False)\nx/2 + 1/x \n```", "```py\n>>> gcd_terms(x/2/y + 1/x/y)\n(x**2 + 2)/(2*x*y)\n>>> gcd_terms(x/2/y + 1/x/y, clear=False)\n(x**2/2 + 1)/(x*y)\n>>> gcd_terms(x/2/y + 1/x/y, clear=False, fraction=False)\n(x/2 + 1/x)/y \n```", "```py\nsympy.core.exprtools.factor_terms(expr, radical=False, clear=False, fraction=False, sign=True)\n```", "```py\n>>> from sympy import factor_terms, Symbol\n>>> from sympy.abc import x, y\n>>> factor_terms(x + x*(2 + 4*y)**3)\nx*(8*(2*y + 1)**3 + 1)\n>>> A = Symbol('A', commutative=False)\n>>> factor_terms(x*A + x*A + x*y*A)\nx*(y*A + 2*A) \n```", "```py\n>>> factor_terms(x/2 + 1, clear=False)\nx/2 + 1\n>>> factor_terms(x/2 + 1, clear=True)\n(x + 2)/2 \n```", "```py\n>>> factor_terms(-x - y)\n-(x + y)\n>>> factor_terms(-x - y, sign=False)\n-x - y\n>>> factor_terms(-2*x - 2*y, sign=False)\n-2*(x + y) \n```", "```py\nclass sympy.core.kind.Kind(*args)\n```", "```py\nsympy.core.kind.NumberKind\n```", "```py\nsympy.core.kind.UndefinedKind\n```", "```py\nsympy.core.kind.BooleanKind\n```", "```py\nsympy.core.sorting.default_sort_key(item, order=None)\n```", "```py\n>>> from sympy import S, I, default_sort_key, sin, cos, sqrt\n>>> from sympy.core.function import UndefinedFunction\n>>> from sympy.abc import x \n```", "```py\n>>> x.sort_key() == default_sort_key(x)\nTrue \n```", "```py\n>>> default_sort_key(UndefinedFunction('f'))\n((0, 0, 'UndefinedFunction'), (1, ('f',)), ((1, 0, 'Number'),\n (0, ()), (), 1), 1)\n>>> default_sort_key('1')\n((0, 0, 'str'), (1, ('1',)), ((1, 0, 'Number'), (0, ()), (), 1), 1)\n>>> default_sort_key(S.One)\n((1, 0, 'Number'), (0, ()), (), 1)\n>>> default_sort_key(2)\n((1, 0, 'Number'), (0, ()), (), 2) \n```", "```py\n>>> a = [2, I, -I]\n>>> sorted(a, key=default_sort_key)\n[2, -I, I] \n```", "```py\n>>> a.sort(key=default_sort_key); a[0]\n2\n>>> min(a, key=default_sort_key)\n2 \n```", "```py\n>>> a, b = x, 1/x \n```", "```py\n>>> a.sort_key() == a.sort_key('rev-lex')\nTrue \n```", "```py\n>>> eq = a + b\n>>> eq.sort_key() == eq.sort_key('rev-lex')\nFalse\n>>> eq.as_ordered_terms()\n[x, 1/x]\n>>> eq.as_ordered_terms('rev-lex')\n[1/x, x] \n```", "```py\n>>> sorted(eq.args, key=default_sort_key)\n[1/x, x]\n>>> sorted(eq.args, key=lambda i: default_sort_key(i, order='rev-lex'))\n[1/x, x] \n```", "```py\n>>> sorted([sin(x)*cos(x), sin(x)], key=default_sort_key)\n[sin(x)*cos(x), sin(x)]\n>>> sorted([x, x**2, sqrt(x), x**3], key=default_sort_key)\n[sqrt(x), x, x**2, x**3] \n```", "```py\nsympy.core.sorting.ordered(seq, keys=None, default=True, warn=False)\n```", "```py\n>>> from sympy import ordered, count_ops\n>>> from sympy.abc import x, y \n```", "```py\n>>> list(ordered([y + 2, x + 2, x**2 + y + 3],\n...    count_ops, default=False, warn=False))\n...\n[y + 2, x + 2, x**2 + y + 3] \n```", "```py\n>>> list(ordered([y + 2, x + 2, x**2 + y + 3]))\n...\n[x + 2, y + 2, x**2 + y + 3] \n```", "```py\n>>> seq, keys = [[[1, 2, 1], [0, 3, 1], [1, 1, 3], [2], [1]], [\n...    lambda x: len(x),\n...    lambda x: sum(x)]]\n...\n>>> list(ordered(seq, keys, default=False, warn=False))\n[[1], [2], [1, 2, 1], [0, 3, 1], [1, 1, 3]] \n```", "```py\n>>> list(ordered(seq, keys, default=False, warn=True))\nTraceback (most recent call last):\n...\nValueError: not enough keys to break ties \n```", "```py\n>>> from sympy.core.random import random, seed\n>>> assert random() < 1\n>>> seed(1); a = random()\n>>> b = random()\n>>> seed(1); c = random()\n>>> assert a == c\n>>> assert a != b  # remote possibility this will fail \n```", "```py\nsympy.core.random.random_complex_number(a=2, b=-1, c=3, d=1, rational=False, tolerance=None)\n```", "```py\nsympy.core.random.verify_numerically(f, g, z=None, tol=1e-06, a=2, b=-1, c=3, d=1)\n```", "```py\n>>> from sympy import sin, cos\n>>> from sympy.abc import x\n>>> from sympy.core.random import verify_numerically as tn\n>>> tn(sin(x)**2 + cos(x)**2, 1, x)\nTrue \n```", "```py\nsympy.core.random.test_derivative_numerically(f, z, tol=1e-06, a=2, b=-1, c=3, d=1)\n```", "```py\n>>> from sympy import sin\n>>> from sympy.abc import x\n>>> from sympy.core.random import test_derivative_numerically as td\n>>> td(sin(x), x)\nTrue \n```", "```py\nsympy.core.random._randrange(seed=None)\n```", "```py\n>>> from sympy.core.random import _randrange\n>>> rr = _randrange()\n>>> rr(1000) \n999\n>>> rr = _randrange(3)\n>>> rr(1000) \n238\n>>> rr = _randrange([0, 5, 1, 3, 4])\n>>> rr(3), rr(3)\n(0, 1) \n```", "```py\nsympy.core.random._randint(seed=None)\n```", "```py\n>>> from sympy.core.random import _randint\n>>> ri = _randint()\n>>> ri(1, 1000) \n999\n>>> ri = _randint(3)\n>>> ri(1, 1000) \n238\n>>> ri = _randint([0, 5, 1, 2, 4])\n>>> ri(1, 3), ri(1, 3)\n(1, 2) \n```", "```py\nsympy.core.traversal.bottom_up(rv, F, atoms=False, nonbasic=False)\n```", "```py\nsympy.core.traversal.postorder_traversal(node, keys=None)\n```", "```py\n>>> from sympy import postorder_traversal\n>>> from sympy.abc import w, x, y, z \n```", "```py\n>>> list(postorder_traversal(w + (x + y)*z)) \n[z, y, x, x + y, z*(x + y), w, w + z*(x + y)]\n>>> list(postorder_traversal(w + (x + y)*z, keys=True))\n[w, z, x, y, x + y, z*(x + y), w + z*(x + y)] \n```", "```py\nsympy.core.traversal.preorder_traversal(node, keys=None)\n```", "```py\n>>> from sympy import preorder_traversal, symbols\n>>> x, y, z = symbols('x y z') \n```", "```py\n>>> list(preorder_traversal((x + y)*z, keys=None)) \n[z*(x + y), z, x + y, y, x]\n>>> list(preorder_traversal((x + y)*z, keys=True))\n[z*(x + y), z, x + y, x, y] \n```", "```py\nsympy.core.traversal.use(expr, func, level=0, args=(), kwargs={})\n```", "```py\n>>> from sympy import use, expand\n>>> from sympy.abc import x, y \n```", "```py\n>>> f = (x + y)**2*x + 1 \n```", "```py\n>>> use(f, expand, level=2)\nx*(x**2 + 2*x*y + y**2) + 1\n>>> expand(f)\nx**3 + 2*x**2*y + x*y**2 + 1 \n```", "```py\nsympy.core.traversal.walk(e, *target)\n```", "```py\n>>> from sympy.core.traversal import walk\n>>> from sympy import Min, Max\n>>> from sympy.abc import x, y, z\n>>> list(walk(Min(x, Max(y, Min(1, z))), Min))\n[Min(x, Max(y, Min(1, z)))]\n>>> list(walk(Min(x, Max(y, Min(1, z))), Min, Max))\n[Min(x, Max(y, Min(1, z))), Max(y, Min(1, z)), Min(1, z)] \n```"]