- en: pandas.DataFrame.to_sql
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_sql.html](https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.to_sql.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Write records stored in a DataFrame to a SQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Databases supported by SQLAlchemy [[1]](#r689dfd12abe5-1) are supported. Tables
    can be newly created, appended to, or overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**name**str'
  prefs: []
  type: TYPE_NORMAL
- en: Name of SQL table.
  prefs: []
  type: TYPE_NORMAL
- en: '**con**sqlalchemy.engine.(Engine or Connection) or sqlite3.Connection'
  prefs: []
  type: TYPE_NORMAL
- en: Using SQLAlchemy makes it possible to use any DB supported by that library.
    Legacy support is provided for sqlite3.Connection objects. The user is responsible
    for engine disposal and connection closure for the SQLAlchemy connectable. See
    [here](https://docs.sqlalchemy.org/en/20/core/connections.html). If passing a
    sqlalchemy.engine.Connection which is already in a transaction, the transaction
    will not be committed. If passing a sqlite3.Connection, it will not be possible
    to roll back the record insertion.
  prefs: []
  type: TYPE_NORMAL
- en: '**schema**str, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the schema (if database flavor supports this). If None, use default
    schema.
  prefs: []
  type: TYPE_NORMAL
- en: '**if_exists**{‘fail’, ‘replace’, ‘append’}, default ‘fail’'
  prefs: []
  type: TYPE_NORMAL
- en: How to behave if the table already exists.
  prefs: []
  type: TYPE_NORMAL
- en: 'fail: Raise a ValueError.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'replace: Drop the table before inserting new values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'append: Insert new values to the existing table.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**index**bool, default True'
  prefs: []
  type: TYPE_NORMAL
- en: Write DataFrame index as a column. Uses index_label as the column name in the
    table. Creates a table index for this column.
  prefs: []
  type: TYPE_NORMAL
- en: '**index_label**str or sequence, default None'
  prefs: []
  type: TYPE_NORMAL
- en: Column label for index column(s). If None is given (default) and index is True,
    then the index names are used. A sequence should be given if the DataFrame uses
    MultiIndex.
  prefs: []
  type: TYPE_NORMAL
- en: '**chunksize**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the number of rows in each batch to be written at a time. By default,
    all rows will be written at once.
  prefs: []
  type: TYPE_NORMAL
- en: '**dtype**dict or scalar, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the datatype for columns. If a dictionary is used, the keys should
    be the column names and the values should be the SQLAlchemy types or strings for
    the sqlite3 legacy mode. If a scalar is provided, it will be applied to all columns.
  prefs: []
  type: TYPE_NORMAL
- en: '**method**{None, ‘multi’, callable}, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Controls the SQL insertion clause used:'
  prefs: []
  type: TYPE_NORMAL
- en: 'None : Uses standard SQL `INSERT` clause (one per row).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '‘multi’: Pass multiple values in a single `INSERT` clause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: callable with signature `(pd_table, conn, keys, data_iter)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details and a sample callable implementation can be found in the section [insert
    method](../../user_guide/io.html#io-sql-method).
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: None or int
  prefs: []
  type: TYPE_NORMAL
- en: Number of rows affected by to_sql. None is returned if the callable passed into
    `method` does not return an integer number of rows.
  prefs: []
  type: TYPE_NORMAL
- en: The number of returned rows affected is the sum of the `rowcount` attribute
    of `sqlite3.Cursor` or SQLAlchemy connectable which may not reflect the exact
    number of written rows as stipulated in the [sqlite3](https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.rowcount)
    or [SQLAlchemy](https://docs.sqlalchemy.org/en/20/core/connections.html#sqlalchemy.engine.CursorResult.rowcount).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: ValueError
  prefs: []
  type: TYPE_NORMAL
- en: When the table already exists and if_exists is ‘fail’ (the default).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`read_sql`](pandas.read_sql.html#pandas.read_sql "pandas.read_sql")'
  prefs: []
  type: TYPE_NORMAL
- en: Read a DataFrame from a table.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: Timezone aware datetime columns will be written as `Timestamp with timezone`
    type with SQLAlchemy if supported by the database. Otherwise, the datetimes will
    be stored as timezone unaware timestamps local to the original timezone.
  prefs: []
  type: TYPE_NORMAL
- en: Not all datastores support `method="multi"`. Oracle, for example, does not support
    multi-value insert.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[1](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.sqlalchemy.org](https://docs.sqlalchemy.org)'
  prefs: []
  type: TYPE_NORMAL
- en: '[2]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.python.org/dev/peps/pep-0249/](https://www.python.org/dev/peps/pep-0249/)'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: Create an in-memory SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Create a table from scratch with 3 rows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'An sqlalchemy.engine.Connection can also be passed to con:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is allowed to support operations that require that the same DBAPI connection
    is used for the entire operation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Overwrite the table with just `df2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Use `method` to define a callable insertion method to do nothing if there’s
    a primary key conflict on a table in a PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For MySQL, a callable to update columns `b` and `c` if there’s a conflict on
    a primary key.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Specify the dtype (especially useful for integers with missing values). Notice
    that while pandas is forced to store the data as floating point, the database
    supports nullable integers. When fetching the data with Python, we get back integer
    scalars.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
