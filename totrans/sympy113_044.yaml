- en: Classification of SymPy objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/explanation/special_topics/classification.html](https://docs.sympy.org/latest/explanation/special_topics/classification.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: There are several ways of how SymPy object is classified.
  prefs: []
  type: TYPE_NORMAL
- en: class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like any other object in Python, SymPy expression is an instance of class. You
    can get the class of the object with built-in \(type()\) function, and check it
    with \(isinstance()\) function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Classes represent only the programmatic structures of the objects, and does
    not distinguish the mathematical difference between them. For example, the integral
    of number and the integral of matrix both have the class \(Integral\), although
    the former is number and the latter is matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '## kind'
  prefs: []
  type: TYPE_NORMAL
- en: Kind indicates what mathematical object does the expression represent. You can
    retrieve the kind of expression with \(.kind\) property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This result shows that \(Integral(1, x)\) is number, and \(Integral(A, x)\)
    is matrix with number element.
  prefs: []
  type: TYPE_NORMAL
- en: Since the class cannot guarantee to catch this difference, kind of the object
    is very important. For example, if you are building a function or class that is
    designed to work only for numbers, you should consider filtering the arguments
    with \(NumberKind\) so that the user does not naively pass unsupported objects
    such as \(Integral(A, x)\).
  prefs: []
  type: TYPE_NORMAL
- en: For the performance, set theory is not implemented in kind system. For example,
  prefs: []
  type: TYPE_NORMAL
- en: \(NumberKind\) does not distinguish the real number and complex number.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SymPy’s \(Set\) and kind are not compatible.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: sets and assumptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to classify the object in strictly mathematical way, you may need
    SymPy’s sets and assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: See \(assumptions\) module and \(sets\) module for more information.
  prefs: []
  type: TYPE_NORMAL
- en: func
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: \(func\) is the head of the object, and it is used to recurse over the expression
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, resulting head may be a class or another SymPy object. Keep
    this in mind when you classify the object with this attribute. See [Advanced Expression
    Manipulation](../../tutorials/intro-tutorial/manipulation.html#tutorial-manipulation)
    for detailed information.
  prefs: []
  type: TYPE_NORMAL
