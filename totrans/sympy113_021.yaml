- en: Assumptions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假设
- en: Original text：[https://docs.sympy.org/latest/guides/assumptions.html](https://docs.sympy.org/latest/guides/assumptions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sympy.org/latest/guides/assumptions.html](https://docs.sympy.org/latest/guides/assumptions.html)
- en: This page outlines the core assumptions system in SymPy. It explains what the
    core assumptions system is, how the assumptions system is used and what the different
    assumptions predicates mean.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本页概述了 SymPy 中的核心假设系统。它解释了核心假设系统是什么，假设系统如何使用以及不同的假设谓词的含义。
- en: Note
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This page describes the core assumptions system also often referred to as the
    “old assumptions” system. There is also a “new assumptions” system which is described
    elsewhere. Note that the system described here is actually the system that is
    widely used in SymPy. The “new assumptions” system is not really used anywhere
    in SymPy yet and the “old assumptions” system will not be removed. At the time
    of writing (SymPy 1.7) it is still recommended for users to use the old assumption
    system.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本页描述了核心假设系统，通常也称为“旧假设”系统。还有一个“新假设”系统，描述在其他地方。请注意，这里描述的系统实际上是 SymPy 中广泛使用的系统。“新假设”系统目前实际上在
    SymPy 中没有得到使用，而“旧假设”系统也不会被移除。在撰写本文时（SymPy 1.7），仍建议用户使用旧的假设系统。
- en: 'Firstly we consider what happens when taking the square root of the square
    of a concrete integer such as \(2\) or \(-2\):'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们考虑对具体整数（如 \(2\) 或 \(-2\)）进行平方根操作时会发生什么：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What these examples demonstrate is that for a positive number \(x\) we have
    \(\sqrt{x^2} = x\) whereas for a negative number we would instead have \(\sqrt{x^2}
    = -x\). That may seem obvious but the situation can be more surprising when working
    with a symbol rather then an explicit number. For example
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例展示了对于正数 \(x\)，我们有 \(\sqrt{x^2} = x\)，而对于负数，我们有 \(\sqrt{x^2} = -x\)。这似乎是显而易见的，但在处理符号而非显式数字时，情况可能更令人惊讶。例如
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It might look as if that should simplify to `x` but it does not even if [`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") is used:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来应该简化为 `x`，但即使使用 [`simplify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.simplify
    "sympy.simplify.simplify.simplify") 也不会：
- en: '[PRE2]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is because SymPy will refuse to simplify this expression if the simplification
    is not valid for *every* possible value of `x`. By default the symbol `x` is considered
    only to represent something roughly like an arbitrary complex number and the obvious
    simplification here is only valid for positive real numbers. Since `x` is not
    known to be positive or even real no simplification of this expression is possible.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为如果简化对于`x`的每一个可能值都不合适，SymPy 将拒绝简化这个表达式。默认情况下，符号 `x` 被认为仅代表大致像一个任意复数的东西，而这里的显而易见的简化仅对正实数有效。因为
    `x` 不被认为是正数甚至是实数，所以这个表达式的简化是不可能的。
- en: 'We can tell SymPy that a symbol represents a positive real number when creating
    the symbol and then the simplification will happen automatically:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建符号时，我们可以告诉 SymPy 符号表示正实数，然后简化将自动发生。
- en: '[PRE3]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This is what is meant by “assumptions” in SymPy. If the symbol `y` is created
    with `positive=True` then SymPy will *assume* that it represents a positive real
    number rather than an arbitrary complex or possibly infinite number. That *assumption*
    can make it possible to simplify expressions or might allow other manipulations
    to work. It is usually a good idea to be as precise as possible about the assumptions
    on a symbol when creating it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 SymPy 中所谓的“假设”。如果用 `positive=True` 创建符号 `y`，那么 SymPy 将*假设*它表示一个正实数，而不是任意复数或可能是无限大的数。这种*假设*可以使表达式简化或可能允许其他操作。在创建符号时，尽可能明确符号的假设通常是一个好主意。
- en: The (old) assumptions system
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: （旧）假设系统
- en: 'There are two sides to the assumptions system. The first side is that we can
    declare assumptions on a symbol when creating the symbol. The other side is that
    we can query the assumptions on any expression using the corresponding `is_*`
    attribute. For example:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设系统有两个方面。一方面是我们可以在创建符号时声明符号的假设。另一方面是我们可以使用相应的 `is_*` 属性查询任何表达式的假设。例如：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can query assumptions on any expression not just a symbol:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以查询任何表达式的假设，而不仅仅是一个符号：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The values given in an assumptions query use three-valued “fuzzy” logic. Any
    query can return `True`, `False`, or `None` where `None` should be interpreted
    as meaning that the result is *unknown*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 假设查询中给出的值使用三值“模糊”逻辑。任何查询可以返回 `True`、`False` 或 `None`，其中 `None` 应被解释为结果是*未知*的。
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We need to use `print` in the above examples because the special value `None`
    does not display by default in the Python interpreter.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们需要使用 `print`，因为默认情况下 Python 解释器不显示特殊值 `None`。
- en: There are several reasons why an assumptions query might give `None`. It is
    possible that the query is *unknowable* as in the case of `x` above. Since `x`
    does not have any assumptions declared it roughly represents an arbitrary complex
    number. An arbitrary complex number *might* be a positive real number but it also
    might *not* be. Without further information there is no way to resolve the query
    `x.is_positive`.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个原因会导致假设查询返回 `None`。例如，查询可能是*不可知的*，就像上述的 `x` 情况一样。由于 `x` 没有声明任何假设，它大致代表一个任意复数。一个任意复数*可能*是正实数，但也*可能*不是。没有更多信息，无法解决查询
    `x.is_positive`。
- en: Another reason why an assumptions query might give `None` is that there does
    in many cases the problem of determining whether an expression is e.g. positive
    is *undecidable*. That means that there does not exist an algorithm for answering
    the query in general. For some cases an algorithm or at least a simple check would
    be possible but has not yet been implemented although it could be added to SymPy.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个假设查询返回 `None` 的原因是在许多情况下，例如确定表达式是否为正是*不可判定*的问题。这意味着通常情况下不存在回答该查询的算法。对于某些情况来说，可能存在算法或至少可以进行简单检查，但尚未在
    SymPy 中实现，尽管可以添加。
- en: 'The final reason that an assumptions query might give `None` is just that the
    assumptions system does not try very hard to answer complicated queries. The system
    is intended to be fast and uses simple heuristic methods to conclude a `True`
    or `False` answer in common cases. For example any sum of positive terms is positive
    so:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设查询可能返回 `None` 的最后一个原因是，假设系统并未尝试非常努力地回答复杂的查询。该系统旨在快速运行，并使用简单的启发式方法在常见情况下得出`True`或`False`的答案。例如，任何正项的和都是正的，因此：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The last example is particularly simple so the assumptions system is able to
    give a definite answer. If the sum involved a mix of positive or negative terms
    it would be a harder query:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个示例特别简单，因此假设系统能够给出明确的答案。如果该和涉及正负项的混合，那么这将是一个更难的查询：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Ideally that last example would give `True` rather than `None` because the
    expression is always positive for any real value of `x` (and `x` has been assumed
    real). The assumptions system is intended to be efficient though: it is expected
    many more complex queries will not be fully resolved. This is because assumptions
    queries are primarily used internally by SymPy as part of low-level calculations.
    Making the system more comprehensive would slow SymPy down.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，最后一个示例应该返回 `True` 而不是 `None`，因为该表达式对于任何实数值的 `x` 都是始终为正（且已假设 `x` 为实数）。尽管如此，假设系统的设计意在高效运行：预计许多更复杂的查询将无法完全解决。这是因为假设查询主要在
    SymPy 内部作为低级别计算的一部分使用。使系统更全面可能会减慢 SymPy 的运行速度。
- en: Note that in fuzzy logic giving an indeterminate result `None` is never a contradiction.
    If it is possible to infer a definite `True` or `False` result when resolving
    a query then that is better than returning `None`. However a result of `None`
    is not a *bug*. Any code that uses the assumptions system needs to be prepared
    to handle all three cases for any query and should not presume that a definite
    answer will always be given.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在模糊逻辑中，给出不确定结果 `None` 绝不是矛盾的。如果在解决查询时能推断出明确的 `True` 或 `False` 结果，则比返回 `None`
    更好。然而，`None` 的结果并不是*错误*。任何使用假设系统的代码都需要准备处理任何查询的三种情况，并不应假设总会给出明确的答案。
- en: 'The assumptions system is not just for symbols or for complex expressions.
    It can also be used for plain SymPy integers and other objects. The assumptions
    predicates are available on any instance of [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") which is the superclass for most classes of SymPy objects.
    A plain Python `int` is not a [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") instance and can not be used to query assumptions predicates.
    We can “sympify” regular Python objects to become SymPy objects with [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") or `S` ([`SingletonRegistry`](../modules/core.html#sympy.core.singleton.SingletonRegistry
    "sympy.core.singleton.SingletonRegistry")) and then the assumptions system can
    be used:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设系统不仅适用于符号或复杂表达式。它也可以用于普通的 SymPy 整数和其他对象。假设谓词适用于 [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") 的任何实例，这是 SymPy 对象大多数类的超类。普通的 Python `int` 不是 [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") 的实例，不能用于查询假设谓词。我们可以用 [`sympify()`](../modules/core.html#sympy.core.sympify.sympify
    "sympy.core.sympify.sympify") 或 `S` ([`SingletonRegistry`](../modules/core.html#sympy.core.singleton.SingletonRegistry
    "sympy.core.singleton.SingletonRegistry")) 将常规 Python 对象“符号化”为 SymPy 对象，然后可以使用假设系统：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Gotcha: symbols with different assumptions'
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注意：具有不同假设的符号
- en: 'In SymPy it is possible to declare two symbols with different names and they
    will implicitly be considered equal under *structural equality*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SymPy 中，可以声明两个具有不同名称的符号，它们将隐式地被视为 *结构相等*：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'However if the symbols have different assumptions then they will be considered
    to represent distinct symbols:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果符号具有不同的假设，则它们将被视为代表不同的符号：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'One way to simplify an expression is to use the [`posify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.posify
    "sympy.simplify.simplify.posify") function which will replace all symbols in an
    expression with symbols that have the assumption `positive=True` (unless that
    contradicts any existing assumptions for the symbol):'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 简化表达式的一种方法是使用 [`posify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.posify
    "sympy.simplify.simplify.posify") 函数，它将表达式中的所有符号替换为具有假设 `positive=True` 的符号（除非这与符号的任何现有假设相矛盾）：
- en: '[PRE12]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The [`posify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.posify
    "sympy.simplify.simplify.posify") function returns the expression with all symbols
    replaced (which might lead to simplifications) and also a dict which maps the
    new symbols to the old that can be used with [`subs()`](../modules/core.html#sympy.core.basic.Basic.subs
    "sympy.core.basic.Basic.subs"). This is useful because otherwise the new expression
    with the new symbols having the `positive=True` assumption will not compare equal
    to the old:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[`posify()`](../modules/simplify/simplify.html#sympy.simplify.simplify.posify
    "sympy.simplify.simplify.posify") 函数返回表达式，其中所有符号都被替换（这可能导致简化），还返回一个字典，将新符号映射到旧符号，可用于
    [`subs()`](../modules/core.html#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs")。这很有用，否则具有
    `positive=True` 假设的新表达式将不等同于旧表达式：'
- en: '[PRE13]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Applying assumptions to string inputs
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对字符串输入应用假设
- en: We have seen how to set assumptions when [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol") or [`symbols()`](../modules/core.html#sympy.core.symbol.symbols
    "sympy.core.symbol.symbols") explicitly. A natural question to ask is in what
    other situations can we assign assumptions to an object?
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何在 [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol "sympy.core.symbol.Symbol")
    或 [`symbols()`](../modules/core.html#sympy.core.symbol.symbols "sympy.core.symbol.symbols")
    明确设置假设。一个自然的问题是，在什么其他情况下可以为对象分配假设？
- en: 'It is common for users to use strings as input to SymPy functions (although
    the general feeling among SymPy developers is that this should be discouraged)
    e.g.:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通常将字符串作为 SymPy 函数的输入（尽管 SymPy 开发人员普遍认为这应该被弃用），例如：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When creating symbols explicitly it would be possible to assign assumptions
    that would affect the behaviour of [`solve()`](../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve"):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当显式创建符号时，可以分配假设，这会影响 [`solve()`](../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") 的行为：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'When using string input SymPy will create the expression and create all of
    the symbolc implicitly so the question arises how can the assumptions be specified?
    The answer is that rather than depending on implicit string conversion it is better
    to use the [`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr") function explicitly and then it is possible
    to provide assumptions for the symbols e.g.:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用字符串输入SymPy将创建表达式并隐式创建所有符号，因此问题是如何指定假设？答案是，与其依赖隐式字符串转换，不如显式使用[`parse_expr()`](../modules/parsing.html#sympy.parsing.sympy_parser.parse_expr
    "sympy.parsing.sympy_parser.parse_expr")函数，然后可以为符号提供假设，例如：
- en: '[PRE16]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The [`solve()`](../modules/solvers/solvers.html#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") function is unusual as a high level API in that
    it actually checks the assumptions on any input symbols (the unknowns) and uses
    that to tailor its output. The assumptions system otherwise affects low-level
    evaluation but is not necessarily handled explicitly by high-level APIs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[`solve()`](../modules/solvers/solvers.html#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")函数作为高级API是不寻常的，因为它实际上会检查输入符号（未知数）的假设，并使用它来定制其输出。假设系统否则影响低级评估，但高级API不一定显式处理。'
- en: Predicates
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谓词
- en: 'There are many different predicates that can be assumed for a symbol or can
    be queried for an expression. It is possible to combine multiple predicates when
    creating a symbol. Predicates are logically combined using *and* so if a symbol
    is declared with `positive=True` and also with `integer=True` then it is both
    positive *and* integer:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多不同的谓词可以为符号假设或可以在表达式中查询。在创建符号时可以组合多个谓词。谓词在逻辑上使用*and*组合，因此如果一个符号被声明为`positive=True`并且也被声明为`integer=True`，那么它既是正数*又*是整数：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The full set of known predicates for a symbol can be accessed using the [`assumptions0`](../modules/core.html#sympy.core.basic.Basic.assumptions0
    "sympy.core.basic.Basic.assumptions0") attribute:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`assumptions0`](../modules/core.html#sympy.core.basic.Basic.assumptions0
    "sympy.core.basic.Basic.assumptions0")属性访问符号的完整已知谓词集：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can see that there are many more predicates listed than the two that were
    used to create `x`. This is because the assumptions system can infer some predicates
    from combinations of other predicates. For example if a symbol is declared with
    `positive=True` then it is possible to infer that it should have `negative=False`
    because a positive number can never be negative. Similarly if a symbol is created
    with `integer=True` then it is possible to infer that is should have `rational=True`
    because every integer is a rational number.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到列出的谓词比用于创建`x`的两个谓词多得多。这是因为假设系统可以从其他谓词的组合中推断出一些谓词。例如，如果一个符号声明为`positive=True`，那么可以推断它应该`negative=False`，因为正数永远不会是负数。类似地，如果一个符号被创建为`integer=True`，那么可以推断它应该`rational=True`，因为每个整数都是有理数。
- en: A full table of the possible predicates and their definitions is given below.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面提供了可能的谓词及其定义的完整表格。
- en: Assumptions predicates for the (old) assumptions
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 假设（旧）假设的谓词
- en: '| Predicate | Definition | Implications |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| 谓词 | 定义 | 含义 |'
- en: '| --- | --- | --- |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `commutative` | A commutative expression. A `commutative` expression commutes
    with all other expressions under multiplication. If an expression `a` has `commutative=True`
    then `a * b == b * a` for any other expression `b` (even if `b` is not `commutative`).
    Unlike all other assumptions predicates `commutative` must always be `True` or
    `False` and can never be `None`. Also unlike all other predicates `commutative`
    defaults to `True` in e.g. `Symbol(''x'')`. [[commutative]](#commutative) |  |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `commutative` | 可交换的表达式。 `commutative`表达式在乘法下与所有其他表达式交换。如果表达式`a`具有`commutative=True`，则对于任何其他表达式`b`都有`a
    * b == b * a`（即使`b`不是`commutative`）。与所有其他假设谓词不同，`commutative`必须始终是`True`或`False`，不能是`None`。而且与所有其他谓词不同，例如在`Symbol(''x'')`中，默认为`True`。[[commutative]](#commutative)
    |  |'
- en: '| `infinite` | An infinite expression such as `oo`, `-oo` or `zoo`. [[infinite]](#infinite)
    | `== !finite` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `infinite` | 无限表达式，如`oo`、`-oo`或`zoo`。[[infinite]](#infinite) | `== !finite`
    |'
- en: '| `finite` | A finite expression. Any expression that is not `infinite` is
    considered `finite`. [[infinite]](#infinite) | `== !infinite` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| `finite` | 有限表达式。任何非`infinite`的表达式都被视为`finite`。[[infinite]](#infinite) |
    `== !infinite` |'
- en: '| `hermitian` | An element of the field of Hermitian operators. [[antihermitian]](#antihermitian)
    |  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| `hermitian` | Hermitian操作符的域中的元素。[[antihermitian]](#antihermitian) |  |'
- en: '| `antihermitian` | An element of the field of antihermitian operators. [[antihermitian]](#antihermitian)
    |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `antihermitian` | 一个反厄米算子域的元素。[[antihermitian]](#antihermitian) |  |'
- en: '| `complex` | A complex number, \(z\in\mathbb{C}\). Any number of the form
    \(x + iy\) where \(x\) and \(y\) are `real` and \(i = \sqrt{-1}\). All `complex`
    numbers are `finite`. Includes all `real` numbers. [[complex]](#complex) | `->
    commutative``-> finite` |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| `complex` | 复数，\(z\in\mathbb{C}\)。任何形式为 \(x + iy\)，其中 \(x\) 和 \(y\) 是`real`且
    \(i = \sqrt{-1}\)。所有的`complex`数都是`finite`。包括所有的`real`数。 [[complex]](#complex)
    | `-> commutative``-> finite` |'
- en: '| `algebraic` | An algebraic number, \(z\in\overline{\mathbb{Q}}\). Any number
    that is a root of a non-zero polynomial \(p(z)\in\mathbb{Q}[z]\) having rational
    coefficients. All `algebraic` numbers are `complex`. An `algebraic` number may
    or may not be `real`. Includes all `rational` numbers. [[algebraic]](#algebraic)
    | `-> complex` |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `algebraic` | 代数数，\(z\in\overline{\mathbb{Q}}\)。任何是非零有理系数多项式 \(p(z)\in\mathbb{Q}[z]\)
    的根的数。所有的`algebraic`数都是`complex`。一个`algebraic`数可能是`real`，也可能不是。包括所有的`rational`数。
    [[algebraic]](#algebraic) | `-> complex` |'
- en: '| `transcendental` | A complex number that is not algebraic, \(z\in\mathbb{C}-\overline{\mathbb{Q}}\).
    All `transcendental` numbers are `complex`. A `transcendental` number may or may
    not be `real` but can never be `rational`. [[transcendental]](#transcendental)
    | `== (complex & !algebraic)` |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `transcendental` | 复数，不属于代数数，\(z\in\mathbb{C}-\overline{\mathbb{Q}}\)。所有的`transcendental`数都是`complex`。一个`transcendental`数可能是`real`，也可能不是，但绝不可能是`rational`。
    [[transcendental]](#transcendental) | `== (complex & !algebraic)` |'
- en: '| `extended_real` | An element of the extended real number line, \(x\in\overline{\mathbb{R}}\)
    where \(\overline{\mathbb{R}}=\mathbb{R}\cup\{-\infty,+\infty\}\). An `extended_real`
    number is either `real` or \(\pm\infty\). The relational operators `<`, `<=`,
    `>=` and `>` are defined only for expressions that are `extended_real`. [[extended_real]](#extended-real)
    | `-> commutative` |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `extended_real` | 扩展实数线上的元素，\(x\in\overline{\mathbb{R}}\) 其中 \(\overline{\mathbb{R}}=\mathbb{R}\cup\{-\infty,+\infty\}\)。一个`extended_real`数要么是`real`，要么是
    \(\pm\infty\)。只有表达式为`extended_real`时才定义了关系运算符 `<`、`<=`、`>=` 和 `>`。 [[extended_real]](#extended-real)
    | `-> commutative` |'
- en: '| `real` | A real number, \(x\in\mathbb{R}\). All `real` numbers are `finite`
    and `complex` (the set of reals is a subset of the set of complex numbers). Includes
    all `rational` numbers. A `real` number is either `negative`, `zero` or `positive`.
    [[real]](#real) | `-> complex``== (extended_real & finite)``== (negative &#124;
    zero &#124; positive)``-> hermitian` |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `real` | 实数，\(x\in\mathbb{R}\)。所有的`real`数都是`finite`和`complex`（实数集是复数集的子集）。包括所有的`rational`数。一个`real`数要么是`negative`、`zero`或`positive`。
    [[real]](#real) | `-> complex``== (extended_real & finite)``== (negative &#124;
    zero &#124; positive)``-> hermitian` |'
- en: '| `imaginary` | An imaginary number, \(z\in\mathbb{I}-\{0\}\). A number of
    the form \(z=yi\) where \(y\) is real, \(y\ne 0\) and \(i=\sqrt{-1}\). All `imaginary`
    numbers are `complex` and not `real`. Note in particular that `zero` is \(not\)
    considered `imaginary` in SymPy. [[imaginary]](#imaginary) | `-> complex``-> antihermitian``->
    !extended_real` |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `imaginary` | 虚数，\(z\in\mathbb{I}-\{0\}\)。形式为 \(z=yi\)，其中 \(y\) 是`real`，\(y\ne
    0\) 且 \(i=\sqrt{-1}\)。所有的`imaginary`数都是`complex`且不是`real`。特别地，SymPy 中不认为`zero`是`imaginary`。
    [[imaginary]](#imaginary) | `-> complex``-> antihermitian``-> !extended_real`
    |'
- en: '| `rational` | A rational number, \(q\in\mathbb{Q}\). Any number of the form
    \(\frac{a}{b}\) where \(a\) and \(b\) are integers and \(b \ne 0\). All `rational`
    numbers are `real` and `algebraic`. Includes all `integer` numbers. [[rational]](#rational)
    | `-> real``-> algebraic` |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `rational` | 有理数，\(q\in\mathbb{Q}\)。任何形式为 \(\frac{a}{b}\)，其中 \(a\) 和 \(b\)
    是整数且 \(b \ne 0\)。所有的`rational`数都是`real`和`algebraic`。包括所有的`integer`数。 [[rational]](#rational)
    | `-> real``-> algebraic` |'
- en: '| `irrational` | A real number that is not rational, \(x\in\mathbb{R}-\mathbb{Q}\).
    [[irrational]](#irrational) | `== (real & !rational)` |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `irrational` | 不是有理数的实数，\(x\in\mathbb{R}-\mathbb{Q}\)。[[irrational]](#irrational)
    | `== (real & !rational)` |'
- en: '| `integer` | An integer, \(a\in\mathbb{Z}\). All integers are `rational`.
    Includes `zero` and all `prime`, `composite`, `even` and `odd` numbers. [[integer]](#integer)
    | `-> rational` |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `integer` | 整数，\(a\in\mathbb{Z}\)。所有的整数都是`rational`。包括`zero`和所有的`prime`、`composite`、`even`和`odd`数。
    [[integer]](#integer) | `-> rational` |'
- en: '| `noninteger` | An extended real number that is not an integer, \(x\in\overline{\mathbb{R}}-\mathbb{Z}\).
    | `== (extended_real & !integer)` |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `noninteger` | 不是整数的扩展实数，\(x\in\overline{\mathbb{R}}-\mathbb{Z}\)。 | `==
    (extended_real & !integer)` |'
- en: '| `even` | An even number, \(e\in\{2k: k\in\mathbb{Z}\}\). All `even` numbers
    are `integer` numbers. Includes `zero`. [[parity]](#parity) | `-> integer``->
    !odd` |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `even` | 偶数，\(e\in\{2k: k\in\mathbb{Z}\}\)。所有的 `even` 数都是整数。包括 `zero`。[[奇偶性]](#奇偶性)
    | `-> 整数``-> !奇数` |'
- en: '| `odd` | An odd number, \(o\in\{2k + 1: k\in\mathbb{Z}\}\). All `odd` numbers
    are `integer` numbers. [[parity]](#parity) | `-> integer``-> !even` |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `odd` | 奇数，\(o\in\{2k + 1: k\in\mathbb{Z}\}\)。所有的 `odd` 数都是整数。[[奇偶性]](#奇偶性)
    | `-> 整数``-> !偶数` |'
- en: '| `prime` | A prime number, \(p\in\mathbb{P}\). All `prime` numbers are `positive`
    and `integer`. [[prime]](#prime) | `-> integer``-> positive` |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `prime` | 质数，\(p\in\mathbb{P}\)。所有的 `prime` 数都是 `positive` 和 `integer`。[[质数]](#质数)
    | `-> 整数``-> 正数` |'
- en: '| `composite` | A composite number, \(c\in\mathbb{N}-(\mathbb{P}\cup\{1\})\).
    A positive integer that is the product of two or more primes. A `composite` number
    is always a `positive` `integer` and is not `prime`. [[composite]](#composite)
    | `-> (integer & positive & !prime)``!composite -> (!positive &#124; !even &#124;
    prime)` |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `composite` | 复合数，\(c\in\mathbb{N}-(\mathbb{P}\cup\{1\})\)。是两个或更多素数的乘积的正整数。`composite`
    数总是一个 `positive` `integer`，且不是 `prime`。[[composite]](#composite) | `-> (整数 & 正数
    & !素数)``!composite -> (!正数 &#124; !偶数 &#124; 素数)` |'
- en: '| `zero` | The number \(0\). An expression with `zero=True` represents the
    number `0` which is an `integer`. [[zero]](#zero) | `-> even & finite``== (extended_nonnegative
    & extended_nonpositive)``== (nonnegative & nonpositive)` |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `zero` | 数字 \(0\)。表达式中 `zero=True` 表示数字 `0` 是一个 `integer`。[[零]](#零) | `->
    偶数 & 有限``== (扩展非负数 & 扩展非正数)``== (非负数 & 非正数)` |'
- en: '| `nonzero` | A nonzero real number, \(x\in\mathbb{R}-\{0\}\). A `nonzero`
    number is always `real` and can not be `zero`. | `-> real``== (extended_nonzero
    & finite)` |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `nonzero` | 非零实数，\(x\in\mathbb{R}-\{0\}\)。`nonzero` 数总是 `real`，且不能是 `zero`。
    | `-> 实数``== (extended_nonzero & 有限)` |'
- en: '| `extended_nonzero` | A member of the extended reals that is not zero, \(x\in\overline{\mathbb{R}}-\{0\}\).
    | `== (extended_real & !zero)` |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `extended_nonzero` | 扩展实数中不为零的成员，\(x\in\overline{\mathbb{R}}-\{0\}\)。 | `==
    (扩展实数 & !零)` |'
- en: '| `positive` | A positive real number, \(x\in\mathbb{R}, x>0\). All `positive`
    numbers are `finite` so `oo` is not `positive`. [[positive]](#positive) | `==
    (nonnegative & nonzero)``== (extended_positive & finite)` |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `positive` | 正实数，\(x\in\mathbb{R}, x>0\)。所有的 `positive` 数都是有限的，因此 `oo` 不是
    `positive`。[[正数]](#正数) | `== (非负数 & 非零)``== (扩展正数 & 有限)` |'
- en: '| `nonnegative` | A nonnegative real number, \(x\in\mathbb{R}, x\ge 0\). All
    `nonnegative` numbers are `finite` so `oo` is not `nonnegative`. [[positive]](#positive)
    | `== (real & !negative)``== (extended_nonnegative & finite)` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `nonnegative` | 非负实数，\(x\in\mathbb{R}, x\ge 0\)。所有的 `nonnegative` 数都是有限的，因此
    `oo` 不是 `nonnegative`。[[正数]](#正数) | `== (实数 & !负数)` |'
- en: '| `negative` | A negative real number, \(x\in\mathbb{R}, x<0\). All `negative`
    numbers are `finite` so `-oo` is not `negative`. [[negative]](#negative) | `==
    (nonpositive & nonzero)``== (extended_negative & finite)` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `negative` | 负实数，\(x\in\mathbb{R}, x<0\)。所有的 `negative` 数都是有限的，因此 `-oo` 不是
    `negative`。[[负数]](#负数) | `== (非正数 & 非零)``== (扩展负数 & 有限)` |'
- en: '| `nonpositive` | A nonpositive real number, \(x\in\mathbb{R}, x\le 0\). All
    `nonpositive` numbers are `finite` so `-oo` is not `nonpositive`. [[negative]](#negative)
    | `== (real & !positive)``== (extended_nonpositive & finite)` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `nonpositive` | 非正实数，\(x\in\mathbb{R}, x\le 0\)。所有的 `nonpositive` 数都是有限的，因此
    `-oo` 不是 `nonpositive`。[[负数]](#负数) | `== (实数 & !正数)` |'
- en: '| `extended_positive` | A positive extended real number, \(x\in\overline{\mathbb{R}},
    x>0\). An `extended_positive` number is either `positive` or `oo`. [[extended_real]](#extended-real)
    | `== (extended_nonnegative & extended_nonzero)` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `extended_positive` | 正的扩展实数，\(x\in\overline{\mathbb{R}}, x>0\)。`extended_positive`
    数要么是 `positive` 要么是 `oo`。[[扩展实数]](#扩展实数) | `== (扩展非负数 & 扩展非零)` |'
- en: '| `extended_nonnegative` | A nonnegative extended real number, \(x\in\overline{\mathbb{R}},
    x\ge 0\). An `extended_nonnegative` number is either `nonnegative` or `oo`. [[extended_real]](#extended-real)
    | `== (extended_real & !extended_negative)` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `extended_nonnegative` | 非负扩展实数，\(x\in\overline{\mathbb{R}}, x\ge 0\)。`extended_nonnegative`
    数既可以是 `nonnegative` 也可以是 `oo`。[[扩展实数]](#扩展实数) | `== (扩展实数 & !extended_negative)`
    |'
- en: '| `extended_negative` | A negative extended real number, \(x\in\overline{\mathbb{R}},
    x<0\). An `extended_negative` number is either `negative` or `-oo`. [[extended_real]](#extended-real)
    | `== (extended_nonpositive & extended_nonzero)` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `extended_negative` | 负的扩展实数，\(x\in\overline{\mathbb{R}}, x<0\)。`extended_negative`
    数要么是 `negative` 要么是 `-oo`。[[扩展实数]](#扩展实数) | `== (扩展非正数 & 扩展非零)` |'
- en: '| `extended_nonpositive` | A nonpositive extended real number, \(x\in\overline{\mathbb{R}},
    x\le 0\). An `extended_nonpositive` number is either `nonpositive` or `-oo`. [[extended_real]](#extended-real)
    | `== (extended_real & !extended_positive)` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `扩展非正数` | 非正扩展实数，\(x\in\overline{\mathbb{R}}, x\le 0\)。一个`扩展非正数`是`非正数`或`-oo`。[[扩展实数]](#extended-real)
    | `== (扩展实数 & !扩展正数)` |'
- en: References for the above definitions
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上述定义的参考资料
- en: '[[commutative](#id1)]'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[[交换性](#id1)]'
- en: '[https://en.wikipedia.org/wiki/Commutative_property](https://en.wikipedia.org/wiki/Commutative_property)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/交换性质](https://zh.wikipedia.org/wiki/Commutative_property)'
- en: '[infinite] ([1](#id2),[2](#id3))'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[无限] ([1](#id2),[2](#id3))'
- en: '[https://en.wikipedia.org/wiki/Infinity](https://en.wikipedia.org/wiki/Infinity)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/无穷大](https://zh.wikipedia.org/wiki/Infinity)'
- en: '[antihermitian] ([1](#id4),[2](#id5))'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[反厄米] ([1](#id4),[2](#id5))'
- en: '[https://en.wikipedia.org/wiki/Skew-Hermitian_matrix](https://en.wikipedia.org/wiki/Skew-Hermitian_matrix)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/斜厄米矩阵](https://zh.wikipedia.org/wiki/Skew-Hermitian_matrix)'
- en: '[[complex](#id6)]'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[[复数](#id6)]'
- en: '[https://en.wikipedia.org/wiki/Complex_number](https://en.wikipedia.org/wiki/Complex_number)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/复数](https://zh.wikipedia.org/wiki/Complex_number)'
- en: '[[algebraic](#id7)]'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[[代数数](#id7)]'
- en: '[https://en.wikipedia.org/wiki/Algebraic_number](https://en.wikipedia.org/wiki/Algebraic_number)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/代数数](https://zh.wikipedia.org/wiki/Algebraic_number)'
- en: '[[transcendental](#id8)]'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[[超越数](#id8)]'
- en: '[https://en.wikipedia.org/wiki/Transcendental_number](https://en.wikipedia.org/wiki/Transcendental_number)'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/超越数](https://zh.wikipedia.org/wiki/Transcendental_number)'
- en: '[extended_real] ([1](#id9),[2](#id24),[3](#id25),[4](#id26),[5](#id27))'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[扩展实数] ([1](#id9),[2](#id24),[3](#id25),[4](#id26),[5](#id27))'
- en: '[https://en.wikipedia.org/wiki/Extended_real_number_line](https://en.wikipedia.org/wiki/Extended_real_number_line)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/扩展实数数线](https://zh.wikipedia.org/wiki/Extended_real_number_line)'
- en: '[[real](#id10)]'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[[实数](#id10)]'
- en: '[https://en.wikipedia.org/wiki/Real_number](https://en.wikipedia.org/wiki/Real_number)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/实数](https://zh.wikipedia.org/wiki/Real_number)'
- en: '[[imaginary](#id11)]'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[[虚数](#id11)]'
- en: '[https://en.wikipedia.org/wiki/Imaginary_number](https://en.wikipedia.org/wiki/Imaginary_number)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/虚数](https://zh.wikipedia.org/wiki/Imaginary_number)'
- en: '[[rational](#id12)]'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[[有理数](#id12)]'
- en: '[https://en.wikipedia.org/wiki/Rational_number](https://en.wikipedia.org/wiki/Rational_number)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/有理数](https://zh.wikipedia.org/wiki/Rational_number)'
- en: '[[irrational](#id13)]'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[[无理数](#id13)]'
- en: '[https://en.wikipedia.org/wiki/Irrational_number](https://en.wikipedia.org/wiki/Irrational_number)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/无理数](https://zh.wikipedia.org/wiki/Irrational_number)'
- en: '[[integer](#id14)]'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[[整数](#id14)]'
- en: '[https://en.wikipedia.org/wiki/Integer](https://en.wikipedia.org/wiki/Integer)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/整数](https://zh.wikipedia.org/wiki/Integer)'
- en: '[parity] ([1](#id15),[2](#id16))'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[奇偶性] ([1](#id15),[2](#id16))'
- en: '[https://en.wikipedia.org/wiki/Parity_%28mathematics%29](https://en.wikipedia.org/wiki/Parity_%28mathematics%29)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/奇偶性_(数学)](https://zh.wikipedia.org/wiki/Parity_%28mathematics%29)'
- en: '[[prime](#id17)]'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[[质数](#id17)]'
- en: '[https://en.wikipedia.org/wiki/Prime_number](https://en.wikipedia.org/wiki/Prime_number)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/质数](https://zh.wikipedia.org/wiki/Prime_number)'
- en: '[[composite](#id18)]'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[[合数](#id18)]'
- en: '[https://en.wikipedia.org/wiki/Composite_number](https://en.wikipedia.org/wiki/Composite_number)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/合数数](https://zh.wikipedia.org/wiki/Composite_number)'
- en: '[[zero](#id19)]'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[[零](#id19)]'
- en: '[https://en.wikipedia.org/wiki/0](https://en.wikipedia.org/wiki/0)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/0](https://zh.wikipedia.org/wiki/0)'
- en: '[positive] ([1](#id20),[2](#id21))'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[正数] ([1](#id20),[2](#id21))'
- en: '[https://en.wikipedia.org/wiki/Positive_real_numbers](https://en.wikipedia.org/wiki/Positive_real_numbers)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/正实数](https://zh.wikipedia.org/wiki/Positive_real_numbers)'
- en: '[negative] ([1](#id22),[2](#id23))'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[负数] ([1](#id22),[2](#id23))'
- en: '[https://en.wikipedia.org/wiki/Negative_number](https://en.wikipedia.org/wiki/Negative_number)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://zh.wikipedia.org/wiki/负数](https://zh.wikipedia.org/wiki/Negative_number)'
- en: Implications
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响
- en: 'The assumptions system uses the inference rules to infer new predicates beyond
    those immediately specified when creating a symbol:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设系统使用推理规则来推断在创建符号时未明确指定的新谓词。
- en: '[PRE19]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Although `x` was not explicitly declared `positive` it can be inferred from
    the predicates that were given explicitly. Specifically one of the inference rules
    is `real == negative | zero | positive` so if `real` is `True` and both `negative`
    and `zero` are `False` then `positive` must be `True`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`x`没有明确声明为`正数`，但可以从明确给出的谓词推断出来。特别是推理规则之一是`实数 == 负数 | 零 | 正数`，所以如果`实数`为`True`且`负数`和`零`都为`False`，那么`正数`必须为`True`。
- en: 'In practice the assumption inference rules mean that it is not necessary to
    include redundant predicates for example a positive real number can be simply
    be declared as positive:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，假设推理规则意味着不必包含冗余的谓词，例如，正实数可以简单地声明为正：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Combining predicates that are inconsistent will give an error:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 合并不一致的谓词将导致错误：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Interpretation of the predicates
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 谓词的解释
- en: 'Although the predicates are defined in the table above it is worth taking some
    time to think about how to interpret them. Firstly many of the concepts referred
    to by the predicate names like “zero”, “prime”, “rational” etc have a basic meaning
    in mathematics but can also have more general meanings. For example when dealing
    with matrices a matrix of all zeros might be referred to as “zero”. The predicates
    in the assumptions system do not allow any generalizations such as this. The predicate
    `zero` is strictly reserved for the plain number \(0\). Instead matrices have
    an [`is_zero_matrix()`](../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.is_zero_matrix
    "sympy.matrices.matrixbase.MatrixBase.is_zero_matrix") property for this purpose
    (although that property is not strictly part of the assumptions system):'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管上表中定义了这些谓词，但值得花些时间考虑如何解释它们。首先，许多谓词名称所指的概念，如“零”，“素数”，“有理数”等在数学中有基本含义，但也可能有更广泛的含义。例如，在处理矩阵时，全零矩阵可能被称为“零”。假设系统中的谓词不允许这样的泛化。谓词
    `zero` 严格保留给普通数 \(0\)。相反，矩阵具有一个 [`is_zero_matrix()`](../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.is_zero_matrix
    "sympy.matrices.matrixbase.MatrixBase.is_zero_matrix") 属性用于此目的（尽管该属性并不严格属于假设系统）：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Similarly there are generalisations of the integers such as the Gaussian integers
    which have a different notion of prime number. The `prime` predicate in the assumptions
    system does not include those and strictly refers only to the standard prime numbers
    \(\mathbb{P} = \{2, 3, 5, 7, 11, \cdots\}\). Likewise `integer` only means the
    standard concept of the integers \(\mathbb{Z} = \{0, \pm 1, \pm 2, \cdots\}\),
    `rational` only means the standard concept of the rational numbers \(\mathbb{Q}\)
    and so on.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，还有整数的泛化，如高斯整数，其对素数有不同的概念。假设系统中的 `prime` 谓词不包括这些，严格只指标准素数集合 \(\mathbb{P}
    = \{2, 3, 5, 7, 11, \cdots\}\)。同样，`integer` 只意味着标准整数概念 \(\mathbb{Z} = \{0, \pm
    1, \pm 2, \cdots\}\)，`rational` 只意味着标准有理数概念 \(\mathbb{Q}\)，依此类推。
- en: The predicates set up schemes of subsets such as the chain beginning with the
    complex numbers which are considered as a superset of the reals which are in turn
    a superset of the rationals and so on. The chain of subsets
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这些谓词建立了类似于以复数开头的子集的体系，复数被认为是实数的超集，而实数又是有理数的超集，依此类推。子集的链条
- en: \[\mathbb{Z} \subset \mathbb{Q} \subset \mathbb{R} \subset \mathbb{C}\]
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: \[\mathbb{Z} \subset \mathbb{Q} \subset \mathbb{R} \subset \mathbb{C}\]
- en: corresponds to the chain of implications in the assumptions system
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于假设系统中的推理链条
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'A “vanilla” symbol with no assumptions explicitly attached is not known to
    belong to any of these sets and is not even known to be finite:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 一个“普通”的符号没有明确附加到这些集合中，甚至不知道它是有限的：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: It is hard for SymPy to know what it can do with such a symbol that is not even
    known to be finite or complex so it is generally better to give some assumptions
    to the symbol explicitly. Many parts of SymPy will implicitly treat such a symbol
    as complex and in some cases SymPy will permit manipulations that would not strictly
    be valid given that `x` is not known to be finite. In a formal sense though very
    little is known about a vanilla symbol which makes manipulations involving it
    difficult.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SymPy 来说，它很难知道如此一个甚至不知道是有限还是复数的符号可以做什么，因此通常最好明确地给符号一些假设。SymPy 的许多部分将会隐式地将这样的符号视为复数，在某些情况下，SymPy
    将允许进行不严格的操作，尽管 `x` 不知道是有限的。从正式意义上讲，对于一个普通符号了解得很少，这使得涉及它的操作变得困难。
- en: 'Defining *something* about a symbol can make a big difference. For example
    if we declare the symbol to be an integer then this implies a suite of other predicates
    that will help in further manipulations:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于符号的*定义*可以产生很大的差异。例如，如果我们声明符号是整数，那么这意味着一系列其他谓词将有助于进一步的操作：
- en: '[PRE25]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These assumptions can lead to very significant simplifications e.g. `integer=True`
    gives:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些假设可以导致非常重要的简化，例如 `integer=True` 得到：
- en: '[PRE26]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Replacing a whole expression with \(0\) is about as good as simplification can
    get!
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 用 \(0\) 替换整个表达式就像简化所能做到的一样好！
- en: 'It is normally advisable to set as many assumptions as possible on any symbols
    so that expressions can be simplified as much as possible. A common misunderstanding
    leads to defining a symbol with a `False` predicate e.g.:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常建议在任何符号上设置尽可能多的假设，以便尽可能简化表达式。一个常见的误解导致用 `False` 谓词定义一个符号，例如：
- en: '[PRE27]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If the intention is to say that `x` is a real number that is not positive then
    that needs to be explicitly stated. In the context that the symbol is known to
    be real, the predicate `positive=False` becomes much more meaningful:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果意图是说 `x` 是一个不是正数的实数，那么需要明确说明。在已知符号是实数的情况下，谓词 `positive=False` 变得更有意义：
- en: '[PRE28]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: A symbol declared as `Symbol('x', real=True, negative=False)` is equivalent
    to a symbol declared as `Symbol('x', nonnegative=True)`. Simply declaring a symbol
    as `Symbol('x', positive=False)` does not allow the assumptions system to conclude
    much about it because a vanilla symbol is not known to be finite or even complex.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 声明为 `Symbol('x', real=True, negative=False)` 的符号等同于声明为 `Symbol('x', nonnegative=True)`。仅仅声明一个符号为
    `Symbol('x', positive=False)` 并不能让假设系统对它有太多推断，因为普通符号并不被认为是有限的，甚至是复数。
- en: A related confusion arises with `Symbol('x', complex=True)` and `Symbol('x',
    real=False)`. Often when either of these is used neither is what is actually wanted.
    The first thing to understand is that all real numbers are complex so a symbol
    created with `real=True` will also have `complex=True` and a symbol created with
    `complex=True` will not have `real=False`. If the intention was to create a complex
    number that is not a real number then it should be `Symbol('x', complex=True,
    real=False)`. On the other hand declaring `real=False` alone is not sufficient
    to conclude that `complex=True` because knowing that it is not a real number does
    not tell us whether it is finite or whether or not it is some completely different
    kind of object from a complex number.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Symbol('x', complex=True)` 和 `Symbol('x', real=False)` 存在一个相关的混淆。通常情况下，当其中任何一个被使用时，实际上不是我们想要的。首先要理解的是，所有的实数都是复数，因此用
    `real=True` 创建的符号也会有 `complex=True`，而用 `complex=True` 创建的符号不会有 `real=False`。如果意图是创建一个既是复数又不是实数的复数，则应该使用
    `Symbol('x', complex=True, real=False)`。另一方面，仅声明 `real=False` 是不足以推断 `complex=True`
    的，因为知道它不是实数并不能告诉我们它是否有限或者是否是复数之外的完全不同的对象。
- en: A vanilla symbol is defined by not knowing whether it is `finite` etc but there
    is no clear definition of what it *should* actually represent. It is tempting
    to think of it as an “arbitrary complex number or possibly one of the infinities”
    but there is no way to query an arbitrary (non-symbol) expression in order to
    determine if it meets those criteria. It is important to bear in mind that within
    the SymPy codebase and potentially in downstream libraries many other kinds of
    mathematical objects can be found that might also have `commutative=True` while
    being something very different from an ordinary number (in this context even SymPy’s
    standard infinities are considered “ordinary”).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通符号的定义是不知道它是否 `finite` 等，但是没有清晰的定义告诉我们它实际上应该代表什么。有时会想把它看作是一个“任意复数或可能是无穷大之一”，但是没有办法查询一个任意的（非符号）表达式以确定它是否符合这些条件。需要牢记的是，在
    SymPy 代码库中以及可能在下游库中，还可以找到许多其他类型的数学对象，它们可能也有 `commutative=True`，但与普通数（在这种情况下，即使是
    SymPy 的标准无穷大也被视为“普通”）完全不同。
- en: 'The only predicate that is applied by default for a symbol is `commutative`.
    We can also declare a symbol to be *noncommutative* e.g.:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一默认应用于符号的谓词是 `commutative`。我们还可以声明一个符号为 *noncommutative*，例如：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note here that since `x` and `y` are both noncommutative `x` and `y` do not
    commute so `x*y != y*x`. On the other hand since `z` is commutative `x` and `z`
    commute and `x*z == z*x` even though `x` is noncommutative.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里，由于 `x` 和 `y` 都是非交换的，所以 `x` 和 `y` 不交换，即 `x*y != y*x`。另一方面，由于 `z` 是可交换的，所以
    `x` 和 `z` 交换，即 `x*z == z*x`，尽管 `x` 是非交换的。
- en: The interpretation of what a vanilla symbol represents is unclear but the interpretation
    of an expression with `commutative=False` is entirely obscure. Such an expression
    is necessarily not a complex number or an extended real or any of the standard
    infinities (even `zoo` is commutative). We are left with very little that we can
    say about what such an expression *does* represent.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个普通符号表示的解释不清楚，但是对于一个 `commutative=False` 的表达式的解释完全模糊。这样的表达式必然不是复数，也不是扩展实数或任何标准的无穷大（即使
    `zoo` 是可交换的）。我们对这样一个表达式 *代表* 什么知之甚少。
- en: '## Other is_* properties'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '## 其他 is_* 属性'
- en: 'There are many properties and attributes in SymPy that that have names beginning
    with `is_` that look similar to the properties used in the (old) assumptions system
    but are not in fact part of the assumptions system. Some of these have a similar
    meaning and usage as those of the assumptions system such as the [`is_zero_matrix()`](../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.is_zero_matrix
    "sympy.matrices.matrixbase.MatrixBase.is_zero_matrix") property shown above. Another
    example is the `is_empty` property of sets:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: SymPy 中有许多属性和特性，其名称以 `is_` 开头，看起来类似于（旧）假设系统中使用的属性，但实际上并不属于假设系统。其中一些与假设系统的属性具有类似的含义和用法，例如上面显示的
    [`is_zero_matrix()`](../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.is_zero_matrix
    "sympy.matrices.matrixbase.MatrixBase.is_zero_matrix") 属性。另一个例子是集合的 `is_empty`
    属性：
- en: '[PRE30]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `is_empty` property gives a fuzzy-bool indicating whether or not a [`Set`](../modules/sets.html#sympy.sets.sets.Set
    "sympy.sets.sets.Set") is the empty set. In the example of `S2` it is not possible
    to know whether or not the set is empty without knowing whether or not `x` is
    equal to `1` so `S2.is_empty` gives `None`. The `is_empty` property for sets plays
    a similar role to the `is_zero` property for numbers in the assumptions system:
    `is_empty` is normally only `True` for the [`EmptySet`](../modules/sets.html#sympy.sets.sets.EmptySet
    "sympy.sets.sets.EmptySet") object but it is still useful to be able to distinguish
    between the cases where `is_empty=False` and `is_empty=None`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`is_empty` 属性给出了一个模糊布尔值，指示一个 [`Set`](../modules/sets.html#sympy.sets.sets.Set
    "sympy.sets.sets.Set") 是否为空集。在 `S2` 的示例中，不知道集合是否为空集，因为不知道 `x` 是否等于 `1`，所以 `S2.is_empty`
    返回 `None`。对于集合，`is_empty` 属性起到类似于假设系统中 `is_zero` 属性的作用：`is_empty` 通常仅对 [`EmptySet`](../modules/sets.html#sympy.sets.sets.EmptySet
    "sympy.sets.sets.EmptySet") 对象为 `True`，但仍然有助于区分 `is_empty=False` 和 `is_empty=None`
    的情况。'
- en: Although `is_zero_matrix` and `is_empty` are used for similar purposes to the
    assumptions properties such as `is_zero` they are not part of the (old) assumptions
    system. There are no associated inference rules connecting e.g. `Set.is_empty`
    and `Set.is_finite_set` because the inference rules are part of the (old) assumptions
    system which only deals with the predicates listed in the table above. It is not
    possible to declare a [`MatrixSymbol`](../modules/matrices/expressions.html#sympy.matrices.expressions.MatrixSymbol
    "sympy.matrices.expressions.MatrixSymbol") with e.g. `zero_matrix=False` and there
    is no `SetSymbol` class but if there was it would not have a system for understanding
    predicates like `empty=False`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `is_zero_matrix` 和 `is_empty` 用于与假设属性类似的目的，如 `is_zero`，但它们并不是（旧）假设系统的一部分。例如，没有关联的推理规则将
    `Set.is_empty` 和 `Set.is_finite_set` 连接起来，因为推理规则是（旧）假设系统的一部分，该系统仅处理表格中列出的谓词。不可能声明一个具有例如
    `zero_matrix=False` 的 [`MatrixSymbol`](../modules/matrices/expressions.html#sympy.matrices.expressions.MatrixSymbol
    "sympy.matrices.expressions.MatrixSymbol")，也没有 `SetSymbol` 类，但如果有的话，它不会有一个像 `empty=False`
    这样的谓词理解系统。
- en: 'The properties [`is_zero_matrix()`](../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.is_zero_matrix
    "sympy.matrices.matrixbase.MatrixBase.is_zero_matrix") and `is_empty` are similar
    to those of the assumptions system because they concern *semantic* aspects of
    an expression. There are a large number of other properties that focus on *structural*
    aspects such as `is_Number`, [`is_number()`](../modules/core.html#sympy.core.expr.Expr.is_number
    "sympy.core.expr.Expr.is_number"), [`is_comparable()`](../modules/core.html#sympy.core.basic.Basic.is_comparable
    "sympy.core.basic.Basic.is_comparable"). Since these properties refer to structural
    aspects of an expression they will always give `True` or `False` rather than a
    fuzzy bool that also has the possibility of being `None`. Capitalised properties
    such as `is_Number` are usually shorthand for `isinstance` checks e.g.:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 属性 [`is_zero_matrix()`](../modules/matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.is_zero_matrix
    "sympy.matrices.matrixbase.MatrixBase.is_zero_matrix") 和 `is_empty` 类似于假设系统的属性，因为它们涉及表达式的*语义*方面。
    还有许多其他属性，专注于*结构*方面，例如 `is_Number`，[`is_number()`](../modules/core.html#sympy.core.expr.Expr.is_number
    "sympy.core.expr.Expr.is_number")，[`is_comparable()`](../modules/core.html#sympy.core.basic.Basic.is_comparable
    "sympy.core.basic.Basic.is_comparable")。由于这些属性涉及表达式的结构方面，它们将始终返回 `True` 或 `False`，而不是具有可能为
    `None` 的模糊布尔值。大写的属性如 `is_Number` 通常是 `isinstance` 检查的简写，例如：
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The [`Number`](../modules/core.html#sympy.core.numbers.Number "sympy.core.numbers.Number")
    class is the superclass for [`Integer`](../modules/core.html#sympy.core.numbers.Integer
    "sympy.core.numbers.Integer"), [`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational") and [`Float`](../modules/core.html#sympy.core.numbers.Float
    "sympy.core.numbers.Float") so any instance of [`Number`](../modules/core.html#sympy.core.numbers.Number
    "sympy.core.numbers.Number") represents a concrete number with a known value.
    A symbol such as `y` that is declared with `rational=True` might represent the
    same value as `x` but it is not a concrete number with a known value so this is
    a structural rather than a semantic distinction. Properties like `is_Number` are
    sometimes used in SymPy in place of e.g. `isinstance(obj, Number)` because they
    do not have problems with circular imports and checking `x.is_Number` can be faster
    than a call to `isinstance`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Number`](../modules/core.html#sympy.core.numbers.Number "sympy.core.numbers.Number")
    类是 [`Integer`](../modules/core.html#sympy.core.numbers.Integer "sympy.core.numbers.Integer")、[`Rational`](../modules/core.html#sympy.core.numbers.Rational
    "sympy.core.numbers.Rational") 和 [`Float`](../modules/core.html#sympy.core.numbers.Float
    "sympy.core.numbers.Float") 的超类，因此 [`Number`](../modules/core.html#sympy.core.numbers.Number
    "sympy.core.numbers.Number") 的任何实例代表具有已知值的具体数。像 `y` 这样用 `rational=True` 声明的符号可能代表与
    `x` 相同的值，但它不是具有已知值的具体数，因此这是一种结构上而不是语义上的区别。例如 `is_Number` 属性有时在 SymPy 中用来取代 `isinstance(obj,
    Number)`，因为它们不会导致循环导入问题，并且检查 `x.is_Number` 可能比调用 `isinstance` 更快。'
- en: 'The [`is_number`](../modules/core.html#sympy.core.expr.Expr.is_number "sympy.core.expr.Expr.is_number")
    (lower-case) property is very different from `is_Number`. The [`is_number`](../modules/core.html#sympy.core.expr.Expr.is_number
    "sympy.core.expr.Expr.is_number") property is `True` for any expression that can
    be numerically evaluated to a floating point complex number with [`evalf()`](../modules/core.html#sympy.core.evalf.EvalfMixin.evalf
    "sympy.core.evalf.EvalfMixin.evalf"):'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 小写的 [`is_number`](../modules/core.html#sympy.core.expr.Expr.is_number "sympy.core.expr.Expr.is_number")
    属性与 `is_Number` 非常不同。 [`is_number`](../modules/core.html#sympy.core.expr.Expr.is_number
    "sympy.core.expr.Expr.is_number") 属性对于任何可以通过 [`evalf()`](../modules/core.html#sympy.core.evalf.EvalfMixin.evalf
    "sympy.core.evalf.EvalfMixin.evalf") 数值评估为浮点复数的表达式都为 `True`：
- en: '[PRE32]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The primary reason for checking `expr.is_number` is to predict whether a call
    to [`evalf()`](../modules/core.html#sympy.core.evalf.EvalfMixin.evalf "sympy.core.evalf.EvalfMixin.evalf")
    will fully evaluate. The [`is_comparable()`](../modules/core.html#sympy.core.basic.Basic.is_comparable
    "sympy.core.basic.Basic.is_comparable") property is similar to [`is_number()`](../modules/core.html#sympy.core.expr.Expr.is_number
    "sympy.core.expr.Expr.is_number") except that if `is_comparable` gives `True`
    then the expression is guaranteed to numerically evaluate to a *real* [`Float`](../modules/core.html#sympy.core.numbers.Float
    "sympy.core.numbers.Float"). When `a.is_comparable` and `b.is_comparable` the
    inequality `a < b` should be resolvable as something like `a.evalf() < b.evalf()`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 `expr.is_number` 的主要原因是为了预测是否调用 [`evalf()`](../modules/core.html#sympy.core.evalf.EvalfMixin.evalf
    "sympy.core.evalf.EvalfMixin.evalf") 将完全评估。 [`is_comparable()`](../modules/core.html#sympy.core.basic.Basic.is_comparable
    "sympy.core.basic.Basic.is_comparable") 属性类似于 [`is_number()`](../modules/core.html#sympy.core.expr.Expr.is_number
    "sympy.core.expr.Expr.is_number")，但如果 `is_comparable` 返回 `True`，则表达式保证数值评估为 *实数*
    [`Float`](../modules/core.html#sympy.core.numbers.Float "sympy.core.numbers.Float")。当
    `a.is_comparable` 和 `b.is_comparable` 时，不等式 `a < b` 应该被解析为类似于 `a.evalf() < b.evalf()`
    的形式。
- en: The full set of `is_*` properties, attributes and methods in SymPy is large.
    It is important to be clear though that only those that are listed in the table
    of predicates above are actually part of the assumptions system. It is only those
    properties that are involved in the *mechanism* that implements the assumptions
    system which is explained below.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SymPy 中，完整的 `is_*` 属性、属性和方法集合非常庞大。不过重要的是要清楚，只有那些在上面谓词表中列出的才是实际上的假设系统的一部分。只有那些涉及实现假设系统的
    *机制* 的属性才会在下面解释。
- en: Implementing assumptions handlers
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现假设处理程序
- en: We will now work through an example of how to implement a SymPy symbolic function
    so that we can see how the old assumptions are used internally. SymPy already
    has an `exp` function which is defined for all complex numbers but we will define
    an `expreal` function which is restricted to real arguments.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将通过实现一个 SymPy 符号函数的示例来说明如何查看内部使用的旧假设。SymPy 已经有一个对所有复数定义的 `exp` 函数，但我们将定义一个仅限于实数参数的
    `expreal` 函数。
- en: '[PRE33]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `Function.eval` method is used to pick up on special values of the function
    so that we can return a different object if it would be a simplification. When
    `expreal(x)` is called the `expreal.__new__` class method (defined in the superclass
    `Function`) will call `expreal.eval(x)`. If `expreal.eval` returns something other
    than `None` then that will be returned instead of an unevaluated `expreal(x)`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Function.eval`方法用于捕获函数的特殊值，以便我们可以在简化时返回不同的对象。当调用`expreal(x)`时，`expreal.__new__`类方法（在超类`Function`中定义）将调用`expreal.eval(x)`。如果`expreal.eval`返回的不是`None`，则将返回该值，而不是未求值的`expreal(x)`：'
- en: '[PRE34]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Note that the `expreal.eval` method does not compare the argument using `==`.
    The special values are verified using the assumptions system to query the properties
    of the argument. That means that the `expreal` method can also evaluate for different
    forms of expression that have matching properties e.g.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`expreal.eval`方法不使用`==`比较参数。特殊值是使用假设系统来查询参数的属性。这意味着`expreal`方法也可以对具有匹配属性的不同形式的表达式进行评估，例如：
- en: '[PRE35]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Of course the assumptions system can only resolve a limited number of special
    values so most `eval` methods will also check against some special values with
    `==` but it is preferable to check e.g. `x.is_zero` rather than `x==0`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，假设系统只能解析有限数量的特殊值，因此大多数`eval`方法也会使用`==`检查一些特殊值，但最好检查例如`x.is_zero`而不是`x==0`。
- en: 'Note also that the `expreal.eval` method validates that the argument is real.
    We want to allow \(\pm\infty\) as arguments to `expreal` so we check for `extended_real`
    rather than `real`. If the argument is not extended real then we raise an error:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，`expreal.eval`方法验证参数是否为实数。我们希望允许\(\pm\infty\)作为`expreal`的参数，因此我们检查`extended_real`而不是`real`。如果参数不是扩展实数，则会引发错误：
- en: '[PRE36]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Importantly we check `x.is_extended_real is False` rather than `not x.is_extended_real`
    which means that we only reject the argument if it is *definitely* not extended
    real: if `x.is_extended_real` gives `None` then the argument will not be rejected.
    The first reason for allowing `x.is_extended_real=None` is so that a vanilla symbol
    can be used with `expreal`. The second reason is that an assumptions query can
    always give `None` even in cases where an argument is definitely real e.g.:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，我们检查`x.is_extended_real is False`而不是`not x.is_extended_real`，这意味着我们只在参数*绝对*不是扩展实数时拒绝它：如果`x.is_extended_real`返回`None`，则不会拒绝参数。允许`x.is_extended_real=None`的第一个原因是可以将普通符号用于`expreal`。第二个原因是，在即使参数明确为实数的情况下，假设查询也可能始终返回`None`，例如：
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Validating the argument in `expreal.eval` does mean that it will not be validated
    when `evaluate=False` is passed but there is not really a better place to perform
    the validation:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在`expreal.eval`中验证参数确实意味着在传递`evaluate=False`时不会验证参数，但实际上没有更好的位置来执行验证：
- en: '[PRE38]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `extended_nonnegative` class attribute and the `_eval_is_*` methods on
    the `expreal` class implement queries in the assumptions system for instances
    of `expreal`:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`expreal`类的`extended_nonnegative`类属性和`expreal`类上的`_eval_is_*`方法实现了对`expreal`实例在假设系统中的查询：'
- en: '[PRE39]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The assumptions system resolves queries like `expreal(2).is_finite` using the
    corresponding handler `expreal._eval_is_finite` and *also* the implication rules.
    For example it is known that `expreal(2).is_rational` is `False` because `expreal(2)._eval_is_algebraic`
    returns `False` and there is an implication rule `rational -> algebraic`. This
    means that an `is_rational` query can be resolved in this case by the `_eval_is_algebraic`
    handler. It is actually better not to implement assumptions handlers for every
    possible predicate but rather to try and identify a minimal set of handlers that
    can resolve as many queries as possible with as few checks as possible.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 假设系统使用相应的处理程序`expreal._eval_is_finite`解析像`expreal(2).is_finite`这样的查询，*还*使用蕴含规则。例如，已知`expreal(2).is_rational`为`False`，因为`expreal(2)._eval_is_algebraic`返回`False`，并且存在一个蕴含规则`rational
    -> algebraic`。这意味着在这种情况下，可以通过`_eval_is_algebraic`处理程序解析`is_rational`查询。实际上，最好不要为每个可能的谓词实现假设处理程序，而是尝试识别一组最小的处理程序，可以尽可能少地检查以解析尽可能多的查询：
- en: Another point to note is that the `_eval_is_*` methods only make assumptions
    queries on the argument `x` and do not make any assumptions queries on `self`.
    Recursive assumptions queries on the same object will interfere with the assumptions
    implications resolver potentially leading to non-deterministic behaviour so they
    should not be used (there are examples of this in the SymPy codebase but they
    should be removed).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的地方是，`_eval_is_*` 方法仅对参数 `x` 进行假设查询，并不对 `self` 进行任何假设查询。在同一对象上递归进行假设查询会干扰假设蕴含解析器，可能导致非确定性行为，因此不应使用它们（SymPy
    代码库中存在这样的例子，但应予以移除）。
- en: Many of the `expreal` methods implicitly return `None`. This is a common pattern
    in the assumptions system. The `eval` method and the `_eval_is_*` methods can
    all return `None` and often will. A Python function that ends without reaching
    a `return` statement will implicitly return `None`. We take advantage of this
    by leaving out many of the `else` clauses from the `if` statements and allowing
    `None` to be returned implicitly. When following the control flow of these methods
    it is important to bear in mind firstly that any queried property can give `True`,
    `False` or `None` and also that any function will implicitly return `None` if
    all of the conditionals fail.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 `expreal` 方法隐式返回 `None`。这是假设系统中的常见模式。`eval` 方法和 `_eval_is_*` 方法都可以返回 `None`，并且通常会返回
    `None`。Python 函数如果在没有达到 `return` 语句的情况下结束，会隐式返回 `None`。我们通过省略许多 `if` 语句的 `else`
    子句，并允许隐式返回 `None` 来利用这一点。在跟踪这些方法的控制流时，重要的是要记住，任何查询的属性都可能返回 `True`、`False` 或 `None`，并且如果所有条件失败，任何函数都会隐式返回
    `None`。
- en: Mechanism of the assumptions system
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 假设系统的机制
- en: Note
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This section describes internal details that could change in a future SymPy
    version.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了在未来 SymPy 版本中可能会发生变化的内部细节。
- en: This section will explain the inner workings of the assumptions system. It is
    important to understand that these inner workings are implementation details and
    could change from one SymPy version to another. This explanation is written as
    of SymPy 1.7\. Although the (old) assumptions system has many limitations (discussed
    in the next section) it is a mature system that is used extensively in SymPy and
    has been well optimised for its current usage. The assumptions system is used
    implicitly in most SymPy operations to control evaluation of elementary expressions.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将解释假设系统的内部工作原理。重要的是要理解，这些内部工作原理是实现细节，可能会从一个 SymPy 版本变化到另一个版本。此解释适用于 SymPy
    1.7 版本。尽管（旧）假设系统存在许多限制（在下一节讨论），但它是一个成熟的系统，在 SymPy 中被广泛使用，并且已经针对当前用途进行了优化。假设系统在大多数
    SymPy 操作中隐式使用，以控制基本表达式的评估。
- en: 'There are several stages in the implementation of the assumptions system within
    a SymPy process that lead up to the evaluation of a single query in the assumptions
    system. Briefly these are:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SymPy 进程中，假设系统的实现经历了几个阶段，最终导致假设系统中单个查询的评估。简而言之，这些阶段包括：
- en: At import time the assumptions rules defined in `sympy/core/assumptions.py`
    are processed into a canonical form ready for efficiently applying the implication
    rules. This happens once when SymPy is imported before even the [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") class is defined.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导入时，`sympy/core/assumptions.py` 中定义的假设规则被处理成一个规范形式，以便高效地应用蕴含规则。这在 SymPy 被导入时仅发生一次，甚至在[`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") 类被定义之前。
- en: The `Basic.__init_subclass__` method will post-process every [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") subclass to add the relevant properties needed for assumptions
    queries. This also adds the `default_assumptions` attribute to the class. This
    happens each time a [`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")
    subclass is defined (when its containing module is imported).
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Basic.__init_subclass__` 方法将后处理每个 [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") 子类，以添加所需的属性，用于假设查询。这也向类添加了 `default_assumptions` 属性。每次定义
    [`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")
    子类时（导入其所在的模块时），都会发生这种情况。'
- en: Every [`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")
    instance initially uses the `default_assumptions` class attribute. When an assumptions
    query is made on a [`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")
    instance in the first instance the query will be answered from the `default_assumptions`
    for the class.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个 [`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")
    实例最初使用 `default_assumptions` 类属性。当对 [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") 实例进行假设查询时，在第一次实例中，查询将从类的 `default_assumptions` 中得到答案。
- en: If there is no cached value for the assumptions query in the `default_assumptions`
    for the class then the default assumptions will be copied to make an assumptions
    cache for the instance. Then the `_ask()` function is called to resolve the query
    which will firstly call the relevant instance handler `_eval_is` method. If the
    handler returns non-None then the result will be cached and returned.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果类的 `default_assumptions` 中对于假设查询没有缓存值，则将复制默认假设以创建实例的假设缓存。然后调用 `_ask()` 函数来解析查询，该函数首先将调用相关实例处理程序
    `_eval_is` 方法。如果处理程序返回非 `None`，则结果将被缓存并返回。
- en: If the handler does not exist or gives None then the implications resolver is
    tried. This will enumerate (in a randomised order) all possible combinations of
    predicates that could potentially be used to resolve the query under the implication
    rules. In each case the handler `_eval_is` method will be called to see if it
    gives non-None. If any combination of handlers and implication rules leads to
    a definitive result for the query then that result is cached in the instance cache
    and returned.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果处理程序不存在或返回 `None`，则将尝试使用推理解析器。这将以随机顺序枚举所有可能用于根据推理规则解析查询的谓词组合。在每种情况下，将调用处理程序的
    `_eval_is` 方法以查看是否返回非 `None`。如果任何处理程序和推理规则的组合导致查询的确定结果，则将该结果缓存到实例缓存中并返回。
- en: Finally if the implications resolver failed to resolve the query then the query
    is considered unresolvable. The value of `None` for the query is cached in the
    instance cache and returned.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果推理解析器未能解析查询，则认为查询无法解决。查询的 `None` 值将被缓存在实例缓存中并返回。
- en: 'The assumptions rules defined in `sympy/core/assumptions.py` are given in forms
    like `real ==  negative | zero | positive`. When this module is imported these
    are converted into a `FactRules` instance called `_assume_rules`. This preprocesses
    the implication rules into the form of “A” and “B” rules that can be used for
    the implications resolver. This is explained in the code in `sympy/core/facts.py`.
    We can access this internal object directly like (full output omitted):'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`sympy/core/assumptions.py` 中定义的假设规则以 `real == negative | zero | positive`
    的形式给出。当导入这个模块时，这些规则会被转换成一个名为 `_assume_rules` 的 `FactRules` 实例。这将预处理含义规则，转换成可以用于推理解析的
    “A” 和 “B” 规则形式。这在 `sympy/core/facts.py` 中的代码中有详细说明。我们可以像这样直接访问这个内部对象（完整输出略）：'
- en: '[PRE40]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `Basic.__init_subclass__` method will inspect the attributes of each `Basic`
    class to see if any assumptions related attributes are defined. An example of
    these is the `is_extended_nonnegative = True` attribute defined in the `expreal`
    class. The implications of any such attributes will be used to precompute any
    statically knowable assumptions. For example `is_extended_nonnegative=True` implies
    `real=True` etc. A `StdFactKB` instance is created for the class which stores
    those assumptions whose values are known at this stage. The `StdFactKB` instance
    is assigned as the class attribute `default_assumptions`. We can see this with
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`Basic.__init_subclass__` 方法将检查每个 `Basic` 类的属性，看看是否定义了任何与假设相关的属性。这些属性的一个示例是在
    `expreal` 类中定义的 `is_extended_nonnegative = True` 属性。这些属性的含义将用于预先计算任何静态可知的假设。例如，`is_extended_nonnegative=True`
    暗示 `real=True` 等。为类创建一个 `StdFactKB` 实例，该实例存储这些在此阶段已知的假设值。将 `StdFactKB` 实例分配为类属性
    `default_assumptions`。我们可以通过以下方式看到这一点：'
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Although only `is_positive` was defined in the class `A` it also has attributes
    such as `is_real` which are inferred from `is_positive`. The set of all such assumptions
    for class `A` can be seen in `default_assumptions` which looks like a `dict` but
    is in fact a `StdFactKB` instance:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在类 `A` 中仅定义了 `is_positive`，它还具有诸如 `is_real` 等从 `is_positive` 推断而来的属性。类 `A`
    的所有这类假设集合可以在 `default_assumptions` 中看到，它看起来像一个 `dict`，但实际上是一个 `StdFactKB` 实例：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: When an instance of any [`Basic`](../modules/core.html#sympy.core.basic.Basic
    "sympy.core.basic.Basic") subclass is created `Basic.__new__` will assign its
    `_assumptions` attribute which will initially be a reference to `cls.default_assumptions`
    shared amongst all instances of the same class. The instance will use this to
    resolve any assumptions queries until that fails to give a definitive result at
    which point a copy of `cls.default_assumptions` will be created and assigned to
    the instance’s `_assumptions` attribute. The copy will be used as a cache to store
    any results computed for the instance by its `_eval_is` handlers.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建任何[`Basic`](../modules/core.html#sympy.core.basic.Basic "sympy.core.basic.Basic")子类的实例时，`Basic.__new__`将分配其
    `_assumptions` 属性，该属性最初将是对 `cls.default_assumptions` 的引用，这在同一类的所有实例之间是共享的。实例将使用此属性来解析任何假设查询，直到无法给出明确结果为止，此时将创建
    `cls.default_assumptions` 的副本，并分配给实例的 `_assumptions` 属性。该副本将用作缓存，用于存储由其 `_eval_is`
    处理程序计算的实例的任何结果。
- en: When the `_assumptions` attribute fails to give the relevant result it is time
    to call the `_eval_is` handlers. At this point the `_ask()` function is called.
    The `_ask()` function will initially try to resolve a query such as `is_rational`
    by calling the corresponding method i.e. `_eval_is_rational`. If that gives non-None
    then the result is stored in `_assumptions` and any implications of that result
    are computed and stored as well. At that point the query is resolved and the value
    returned.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `_assumptions` 属性未能提供相关结果时，是调用 `_eval_is` 处理程序的时候了。此时会调用 `_ask()` 函数。`_ask()`
    函数将首先尝试通过调用相应的方法，如 `_eval_is_rational` 来解析诸如 `is_rational` 的查询。如果返回非空，则结果将存储在
    `_assumptions` 中，并计算并存储该结果的任何推论。此时，查询将被解析并返回值。
- en: '[PRE43]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If e.g. `_eval_is_rational` does not exist or gives `None` then `_ask()` will
    try all possibilities to use the implication rules and any other handler methods
    such as `_eval_is_integer`, `_eval_is_algebraic` etc that might possibly be able
    to give an answer to the original query. If any method leads to a definite result
    being known for the original query then that is returned. Otherwise once all possibilities
    for using a handler and the implication rules to resolve the query are exhausted
    `None` will be cached and returned.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 如果例如 `_eval_is_rational` 不存在或返回 `None`，那么 `_ask()` 将尝试所有可能性来使用推论规则和任何其他处理程序方法，如
    `_eval_is_integer`、`_eval_is_algebraic` 等，这些方法可能能够对原始查询给出答案。如果任何方法导致已知原始查询的确定结果，则返回该结果。否则，一旦用于解析查询的处理程序和推论规则的所有可能性都耗尽，将缓存并返回
    `None`。
- en: '[PRE44]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the `_ask()` function the handlers are called in a randomised order which
    can mean that execution at this point is non-deterministic. Provided all of the
    different handler methods are consistent (i.e. there are no bugs) then the end
    result will still be deterministic. However a bug where two handlers are inconsistent
    can manifest in non-deterministic behaviour because this randomisation might lead
    to the handlers being called in different orders when the same program is run
    multiple times.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `_ask()` 函数中，处理程序的调用顺序是随机的，这意味着此时的执行是非确定性的。只要所有不同的处理程序方法保持一致（即没有错误），最终结果仍将是确定性的。然而，如果存在两个处理程序不一致的
    bug，则可能导致非确定性行为，因为此随机化可能导致在多次运行同一程序时以不同的顺序调用处理程序。
- en: Limitations
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制
- en: Combining predicates with or
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并带有 or 的谓词
- en: 'In the old assumptions we can easily combine predicates with *and* when creating
    a Symbol e.g.:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧的假设中，我们可以轻松地在创建符号时将谓词与*and*组合，例如：
- en: '[PRE45]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We can also easily query whether two conditions are jointly satisfied with
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以轻松地查询两个条件是否共同满足
- en: '[PRE46]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: However there is no way in the old assumptions to create a [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol") with assumptions predicates combined with *or*. For
    example if we wanted to say that “x is positive or x is an integer” then it is
    not possible to create a [`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol") with those assumptions.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在旧的假设中，无法创建具有*或*组合的[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol")。例如，如果我们想要表达“x 是正数或 x 是整数”，则无法创建具有这些假设的[`Symbol`](../modules/core.html#sympy.core.symbol.Symbol
    "sympy.core.symbol.Symbol")。
- en: It is also not possible to ask an assumptions query based on *or* e.g. “is expr
    an expression that is positive or an integer”. We can use e.g.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 也不可能根据*或*进行假设查询，例如“expr 是否为正数或整数表达式”。我们可以使用例如
- en: '[PRE47]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: However if all that is known about `x` is that it is possibly positive or otherwise
    a negative integer then both queries `x.is_positive` and `x.is_integer` will resolve
    to `None`. That means that the query becomes
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果对`x`的所有了解只是它可能是正数或者是一个负整数，那么`x.is_positive`和`x.is_integer`这两个查询都会返回`None`。这意味着查询变成了
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: which then also gives `None`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然后也会返回`None`。
- en: Relations between different symbols
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同符号之间的关系
- en: A fundamental limitation of the old assumptions system is that all explicit
    assumptions are properties of an individual symbol. There is no way in this system
    to make an assumption about the *relationship* between two symbols. One of the
    most common requests is the ability to assume something like `x < y` but there
    is no way to even specify that in the old assumptions.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 旧假设系统的一个基本限制是，所有显式假设都是一个单独符号的属性。在这个系统中，没有办法假设两个符号之间的*关系*。最常见的请求之一是能够假设类似`x <
    y`这样的内容，但在旧的假设中甚至没有办法指定这一点。
- en: The new assumptions have the theoretical capability that relational assumptions
    can be specified. However the algorithms to make use of that information are not
    yet implemented and the exact API for specifying relational assumptions has not
    been decided upon.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 新的假设具有理论上的能力，可以指定关系性假设。然而，利用该信息的算法尚未实现，并且还未决定指定关系性假设的确切 API。
