- en: scipy.signal.istft
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.istft.html#scipy.signal.istft](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.istft.html#scipy.signal.istft)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Perform the inverse Short Time Fourier transform (iSTFT).
  prefs: []
  type: TYPE_NORMAL
- en: Legacy
  prefs: []
  type: TYPE_NORMAL
- en: This function is considered legacy and will no longer receive updates. This
    could also mean it will be removed in future SciPy versions. [`ShortTimeFFT`](scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT
    "scipy.signal.ShortTimeFFT") is a newer STFT / ISTFT implementation with more
    features. A [comparison](../../tutorial/signal.html#tutorial-stft-legacy-stft)
    between the implementations can be found in the [Short-Time Fourier Transform](../../tutorial/signal.html#tutorial-stft)
    section of the [SciPy User Guide](../../tutorial/index.html#user-guide).
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zxx**array_like'
  prefs: []
  type: TYPE_NORMAL
- en: STFT of the signal to be reconstructed. If a purely real array is passed, it
    will be cast to a complex data type.
  prefs: []
  type: TYPE_NORMAL
- en: '**fs**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Sampling frequency of the time series. Defaults to 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**window**str or tuple or array_like, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Desired window to use. If *window* is a string or tuple, it is passed to [`get_window`](scipy.signal.get_window.html#scipy.signal.get_window
    "scipy.signal.get_window") to generate the window values, which are DFT-even by
    default. See [`get_window`](scipy.signal.get_window.html#scipy.signal.get_window
    "scipy.signal.get_window") for a list of windows and required parameters. If *window*
    is array_like it will be used directly as the window and its length must be nperseg.
    Defaults to a Hann window. Must match the window used to generate the STFT for
    faithful inversion.
  prefs: []
  type: TYPE_NORMAL
- en: '**nperseg**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Number of data points corresponding to each STFT segment. This parameter must
    be specified if the number of data points per segment is odd, or if the STFT was
    padded via `nfft > nperseg`. If *None*, the value depends on the shape of *Zxx*
    and *input_onesided*. If *input_onesided* is *True*, `nperseg=2*(Zxx.shape[freq_axis]
    - 1)`. Otherwise, `nperseg=Zxx.shape[freq_axis]`. Defaults to *None*.
  prefs: []
  type: TYPE_NORMAL
- en: '**noverlap**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Number of points to overlap between segments. If *None*, half of the segment
    length. Defaults to *None*. When specified, the COLA constraint must be met (see
    Notes below), and should match the parameter used to generate the STFT. Defaults
    to *None*.
  prefs: []
  type: TYPE_NORMAL
- en: '**nfft**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: 'Number of FFT points corresponding to each STFT segment. This parameter must
    be specified if the STFT was padded via `nfft > nperseg`. If *None*, the default
    values are the same as for *nperseg*, detailed above, with one exception: if *input_onesided*
    is True and `nperseg==2*Zxx.shape[freq_axis] - 1`, *nfft* also takes on that value.
    This case allows the proper inversion of an odd-length unpadded STFT using `nfft=None`.
    Defaults to *None*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**input_onesided**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If *True*, interpret the input array as one-sided FFTs, such as is returned
    by [`stft`](scipy.signal.stft.html#scipy.signal.stft "scipy.signal.stft") with
    `return_onesided=True` and [`numpy.fft.rfft`](https://numpy.org/devdocs/reference/generated/numpy.fft.rfft.html#numpy.fft.rfft
    "(in NumPy v2.0.dev0)"). If *False*, interpret the input as a a two-sided FFT.
    Defaults to *True*.
  prefs: []
  type: TYPE_NORMAL
- en: '**boundary**bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies whether the input signal was extended at its boundaries by supplying
    a non-*None* `boundary` argument to [`stft`](scipy.signal.stft.html#scipy.signal.stft
    "scipy.signal.stft"). Defaults to *True*.
  prefs: []
  type: TYPE_NORMAL
- en: '**time_axis**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Where the time segments of the STFT is located; the default is the last axis
    (i.e. `axis=-1`).
  prefs: []
  type: TYPE_NORMAL
- en: '**freq_axis**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Where the frequency axis of the STFT is located; the default is the penultimate
    axis (i.e. `axis=-2`).
  prefs: []
  type: TYPE_NORMAL
- en: '**scaling: {‘spectrum’, ‘psd’}**'
  prefs: []
  type: TYPE_NORMAL
- en: The default ‘spectrum’ scaling allows each frequency line of *Zxx* to be interpreted
    as a magnitude spectrum. The ‘psd’ option scales each line to a power spectral
    density - it allows to calculate the signal’s energy by numerically integrating
    over `abs(Zxx)**2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**t**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Array of output data times.
  prefs: []
  type: TYPE_NORMAL
- en: '**x**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: iSTFT of *Zxx*.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`stft`](scipy.signal.stft.html#scipy.signal.stft "scipy.signal.stft")'
  prefs: []
  type: TYPE_NORMAL
- en: Short Time Fourier Transform
  prefs: []
  type: TYPE_NORMAL
- en: '[`ShortTimeFFT`](scipy.signal.ShortTimeFFT.html#scipy.signal.ShortTimeFFT "scipy.signal.ShortTimeFFT")'
  prefs: []
  type: TYPE_NORMAL
- en: Newer STFT/ISTFT implementation providing more features.
  prefs: []
  type: TYPE_NORMAL
- en: '[`check_COLA`](scipy.signal.check_COLA.html#scipy.signal.check_COLA "scipy.signal.check_COLA")'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the Constant OverLap Add (COLA) constraint is met
  prefs: []
  type: TYPE_NORMAL
- en: '[`check_NOLA`](scipy.signal.check_NOLA.html#scipy.signal.check_NOLA "scipy.signal.check_NOLA")'
  prefs: []
  type: TYPE_NORMAL
- en: Check whether the Nonzero Overlap Add (NOLA) constraint is met
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable inversion of an STFT via the inverse STFT with [`istft`](#scipy.signal.istft
    "scipy.signal.istft"), the signal windowing must obey the constraint of “nonzero
    overlap add” (NOLA):'
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{t}w^{2}[n-tH] \ne 0\]
  prefs: []
  type: TYPE_NORMAL
- en: This ensures that the normalization factors that appear in the denominator of
    the overlap-add reconstruction equation
  prefs: []
  type: TYPE_NORMAL
- en: \[x[n]=\frac{\sum_{t}x_{t}[n]w[n-tH]}{\sum_{t}w^{2}[n-tH]}\]
  prefs: []
  type: TYPE_NORMAL
- en: are not zero. The NOLA constraint can be checked with the [`check_NOLA`](scipy.signal.check_NOLA.html#scipy.signal.check_NOLA
    "scipy.signal.check_NOLA") function.
  prefs: []
  type: TYPE_NORMAL
- en: An STFT which has been modified (via masking or otherwise) is not guaranteed
    to correspond to a exactly realizible signal. This function implements the iSTFT
    via the least-squares estimation algorithm detailed in [[2]](#r9884493677cb-2),
    which produces a signal that minimizes the mean squared error between the STFT
    of the returned signal and the modified STFT.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 0.19.0.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1]'
  prefs: []
  type: TYPE_NORMAL
- en: Oppenheim, Alan V., Ronald W. Schafer, John R. Buck “Discrete-Time Signal Processing”,
    Prentice Hall, 1999.
  prefs: []
  type: TYPE_NORMAL
- en: '[[2](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: Daniel W. Griffin, Jae S. Lim “Signal Estimation from Modified Short-Time Fourier
    Transform”, IEEE 1984, 10.1109/TASSP.1984.1164317
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Generate a test signal, a 2 Vrms sine wave at 50Hz corrupted by 0.001 V**2/Hz
    of white noise sampled at 1024 Hz.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Compute the STFT, and plot its magnitude
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-signal-istft-1_00_00.png](../Images/b5004a747ecfc2233dc72eeab37e2bdc.png)'
  prefs: []
  type: TYPE_IMG
- en: Zero the components that are 10% or less of the carrier magnitude, then convert
    back to a time series via inverse STFT
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Compare the cleaned signal with the original and true carrier signals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-signal-istft-1_01_00.png](../Images/13bac3031e2f7077ae84ed15aad87c12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that the cleaned signal does not start as abruptly as the original, since
    some of the coefficients of the transient were also removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/scipy-signal-istft-1_02_00.png](../Images/d7f9032568b1d5274cb0b56cb3f1c48c.png)'
  prefs: []
  type: TYPE_IMG
