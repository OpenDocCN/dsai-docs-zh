- en: scipy.signal.find_peaks_cwt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.find_peaks_cwt.html#scipy.signal.find_peaks_cwt](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.signal.find_peaks_cwt.html#scipy.signal.find_peaks_cwt)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Find peaks in a 1-D array with wavelet transformation.
  prefs: []
  type: TYPE_NORMAL
- en: The general approach is to smooth *vector* by convolving it with *wavelet(width)*
    for each width in *widths*. Relative maxima which appear at enough length scales,
    and with sufficiently high SNR, are accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**vector**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: 1-D array in which to find the peaks.
  prefs: []
  type: TYPE_NORMAL
- en: '**widths**float or sequence'
  prefs: []
  type: TYPE_NORMAL
- en: Single width or 1-D array-like of widths to use for calculating the CWT matrix.
    In general, this range should cover the expected width of peaks of interest.
  prefs: []
  type: TYPE_NORMAL
- en: '**wavelet**callable, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Should take two parameters and return a 1-D array to convolve with *vector*.
    The first parameter determines the number of points of the returned wavelet array,
    the second parameter is the scale (*width*) of the wavelet. Should be normalized
    and symmetric. Default is the ricker wavelet.
  prefs: []
  type: TYPE_NORMAL
- en: '**max_distances**ndarray, optional'
  prefs: []
  type: TYPE_NORMAL
- en: At each row, a ridge line is only connected if the relative max at row[n] is
    within `max_distances[n]` from the relative max at `row[n+1]`. Default value is
    `widths/4`.
  prefs: []
  type: TYPE_NORMAL
- en: '**gap_thresh**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If a relative maximum is not found within *max_distances*, there will be a gap.
    A ridge line is discontinued if there are more than *gap_thresh* points without
    connecting a new relative maximum. Default is the first value of the widths array
    i.e. widths[0].
  prefs: []
  type: TYPE_NORMAL
- en: '**min_length**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum length a ridge line needs to be acceptable. Default is `cwt.shape[0]
    / 4`, ie 1/4-th the number of widths.
  prefs: []
  type: TYPE_NORMAL
- en: '**min_snr**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Minimum SNR ratio. Default 1\. The signal is the maximum CWT coefficient on
    the largest ridge line. The noise is *noise_perc* th percentile of datapoints
    contained within the same ridge line.
  prefs: []
  type: TYPE_NORMAL
- en: '**noise_perc**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: When calculating the noise floor, percentile of data points examined below which
    to consider noise. Calculated using *stats.scoreatpercentile*. Default is 10.
  prefs: []
  type: TYPE_NORMAL
- en: '**window_size**int, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Size of window to use to calculate noise floor. Default is `cwt.shape[1] / 20`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**peaks_indices**ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Indices of the locations in the *vector* where peaks were found. The list is
    sorted.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`cwt`](scipy.signal.cwt.html#scipy.signal.cwt "scipy.signal.cwt")'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous wavelet transform.
  prefs: []
  type: TYPE_NORMAL
- en: '[`find_peaks`](scipy.signal.find_peaks.html#scipy.signal.find_peaks "scipy.signal.find_peaks")'
  prefs: []
  type: TYPE_NORMAL
- en: Find peaks inside a signal based on peak properties.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This approach was designed for finding sharp peaks among noisy data, however
    with proper parameter selection it should function well for different peak shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Perform a continuous wavelet transform on *vector*, for the supplied *widths*.
    This is a convolution of *vector* with *wavelet(width)* for each width in *widths*.
    See [`cwt`](scipy.signal.cwt.html#scipy.signal.cwt "scipy.signal.cwt").
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify “ridge lines” in the cwt matrix. These are relative maxima at each
    row, connected across adjacent rows. See identify_ridge_lines
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Filter the ridge_lines using filter_ridge_lines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New in version 0.11.0.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[1]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bioinformatics (2006) 22 (17): 2059-2065. [DOI:10.1093/bioinformatics/btl355](https://doi.org/10.1093/bioinformatics/btl355)'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
