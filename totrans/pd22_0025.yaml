- en: Essential basic functionality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/user_guide/basics.html](https://pandas.pydata.org/docs/user_guide/basics.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Here we discuss a lot of the essential functionality common to the pandas data
    structures. To begin, let’s create some example objects like we did in the [10
    minutes to pandas](10min.html#min) section:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '## Head and tail'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: To view a small sample of a Series or DataFrame object, use the [`head()`](../reference/api/pandas.DataFrame.head.html#pandas.DataFrame.head
    "pandas.DataFrame.head") and [`tail()`](../reference/api/pandas.DataFrame.tail.html#pandas.DataFrame.tail
    "pandas.DataFrame.tail") methods. The default number of elements to display is
    five, but you may pass a custom number.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]  ## Attributes and underlying data'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: pandas objects have a number of attributes enabling you to access the metadata
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '**shape**: gives the axis dimensions of the object, consistent with ndarray'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axis labels
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Series**: *index* (only axis)'
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: *index* (rows) and *columns*'
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, **these attributes can be safely assigned to**!
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: pandas objects ([`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index"),
    [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series"),
    [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame"))
    can be thought of as containers for arrays, which hold the actual data and do
    the actual computation. For many types, the underlying array is a [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). However, pandas and 3rd party libraries may *extend* NumPy’s
    type system to add support for custom arrays (see [dtypes](#basics-dtypes)).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: To get the actual data inside a [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") or [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), use the `.array` property
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[`array`](../reference/api/pandas.Series.array.html#pandas.Series.array "pandas.Series.array")
    will always be an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). The exact details of what an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") is and why pandas uses them are a bit
    beyond the scope of this introduction. See [dtypes](#basics-dtypes) for more.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: If you know you need a NumPy array, use [`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") or `numpy.asarray()`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When the Series or Index is backed by an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), [`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") may involve copying data and coercing values. See [dtypes](#basics-dtypes)
    for more.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") gives some control over the `dtype` of the resulting
    [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). For example, consider datetimes with timezones. NumPy doesn’t
    have a dtype to represent timezone-aware datetimes, so there are two possibly
    useful representations:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: An object-dtype [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)") with [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") objects, each with the correct `tz`
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `datetime64[ns]` -dtype [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"), where the values have been converted to UTC and the timezone
    discarded
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Timezones may be preserved with `dtype=object`
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Or thrown away with `dtype='datetime64[ns]'`
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Getting the “raw data” inside a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") is possibly a bit more complex. When your `DataFrame` only
    has a single data type for all the columns, [`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") will return the underlying data:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If a DataFrame contains homogeneously-typed data, the ndarray can actually be
    modified in-place, and the changes will be reflected in the data structure. For
    heterogeneous data (e.g. some of the DataFrame’s columns are not all the same
    dtype), this will not be the case. The values attribute itself, unlike the axis
    labels, cannot be assigned to.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: When working with heterogeneous data, the dtype of the resulting ndarray will
    be chosen to accommodate all of the data involved. For example, if strings are
    involved, the result will be of object dtype. If there are only floats and integers,
    the resulting array will be of float dtype.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, pandas recommended [`Series.values`](../reference/api/pandas.Series.values.html#pandas.Series.values
    "pandas.Series.values") or [`DataFrame.values`](../reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values
    "pandas.DataFrame.values") for extracting the data from a Series or DataFrame.
    You’ll still find references to these in old code bases and online. Going forward,
    we recommend avoiding `.values` and using `.array` or `.to_numpy()`. `.values`
    has the following drawbacks:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: When your Series contains an [extension type](../development/extending.html#extending-extension-types),
    it’s unclear whether [`Series.values`](../reference/api/pandas.Series.values.html#pandas.Series.values
    "pandas.Series.values") returns a NumPy array or the extension array. [`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array") will always return an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), and will never copy data. [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") will always return a NumPy array, potentially at the
    cost of copying / coercing values.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你的 Series 包含一个[扩展类型](../development/extending.html#extending-extension-types)时，不清楚
    [`Series.values`](../reference/api/pandas.Series.values.html#pandas.Series.values
    "pandas.Series.values") 返回一个 NumPy 数组还是扩展数组。[`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array") 总是返回一个 [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray")，并且永远不会复制数据。[`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") 总是返回一个 NumPy 数组，可能会造成复制/强制转换值的代价。
- en: 'When your DataFrame contains a mixture of data types, [`DataFrame.values`](../reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values
    "pandas.DataFrame.values") may involve copying data and coercing values to a common
    dtype, a relatively expensive operation. [`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy"), being a method, makes it clearer that the returned
    NumPy array may not be a view on the same data in the DataFrame.  ## Accelerated
    operations'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '当你的 DataFrame 包含不同数据类型时，[`DataFrame.values`](../reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values
    "pandas.DataFrame.values") 可能涉及复制数据并将值强制转换为一个公共的数据类型，这是一个相对昂贵的操作。[`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") 作为一个方法，更清楚地表明返回的 NumPy 数组可能不是 DataFrame 中相同数据的视图。  ##
    加速操作'
- en: pandas has support for accelerating certain types of binary numerical and boolean
    operations using the `numexpr` library and the `bottleneck` libraries.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: pandas 支持使用 `numexpr` 库和 `bottleneck` 库加速某些类型的二进制数值和布尔操作。
- en: These libraries are especially useful when dealing with large data sets, and
    provide large speedups. `numexpr` uses smart chunking, caching, and multiple cores.
    `bottleneck` is a set of specialized cython routines that are especially fast
    when dealing with arrays that have `nans`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大型数据集时，这些库特别有用，并提供了大幅加速。`numexpr` 使用智能分块、缓存和多核。`bottleneck` 是一组专门的 cython
    程序，当处理具有 `nans` 的数组时特别快。
- en: 'Here is a sample (using 100 column x 100,000 row `DataFrames`):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个示例（使用 100 列 x 100,000 行的 `DataFrames`）：
- en: '| Operation | 0.11.0 (ms) | Prior Version (ms) | Ratio to Prior |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 操作 | 0.11.0 (毫秒) | 之前版本 (毫秒) | 与之前版本的比率 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `df1 > df2` | 13.32 | 125.35 | 0.1063 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| `df1 > df2` | 13.32 | 125.35 | 0.1063 |'
- en: '| `df1 * df2` | 21.71 | 36.63 | 0.5928 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `df1 * df2` | 21.71 | 36.63 | 0.5928 |'
- en: '| `df1 + df2` | 22.04 | 36.50 | 0.6039 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `df1 + df2` | 22.04 | 36.50 | 0.6039 |'
- en: You are highly encouraged to install both libraries. See the section [Recommended
    Dependencies](../getting_started/install.html#install-recommended-dependencies)
    for more installation info.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议安装这两个库。查看 [推荐依赖项](../getting_started/install.html#install-recommended-dependencies)
    部分获取更多安装信息。
- en: 'These are both enabled to be used by default, you can control this by setting
    the options:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者默认启用，你可以通过设置选项来控制这一点：
- en: '[PRE8]  ## Flexible binary operations'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]  ## 灵活的二进制操作'
- en: 'With binary operations between pandas data structures, there are two key points
    of interest:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 pandas 数据结构之间进行二进制操作时，有两个关键点值得注意：
- en: Broadcasting behavior between higher- (e.g. DataFrame) and lower-dimensional
    (e.g. Series) objects.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高维（例如 DataFrame）和低维（例如 Series）对象之间的广播行为。
- en: Missing data in computations.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算中的缺失数据。
- en: We will demonstrate how to manage these issues independently, though they can
    be handled simultaneously.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将演示如何独立处理这些问题，尽管它们可以同时处理。
- en: Matching / broadcasting behavior
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匹配/广播行为
- en: 'DataFrame has the methods [`add()`](../reference/api/pandas.DataFrame.add.html#pandas.DataFrame.add
    "pandas.DataFrame.add"), [`sub()`](../reference/api/pandas.DataFrame.sub.html#pandas.DataFrame.sub
    "pandas.DataFrame.sub"), [`mul()`](../reference/api/pandas.DataFrame.mul.html#pandas.DataFrame.mul
    "pandas.DataFrame.mul"), [`div()`](../reference/api/pandas.DataFrame.div.html#pandas.DataFrame.div
    "pandas.DataFrame.div") and related functions [`radd()`](../reference/api/pandas.DataFrame.radd.html#pandas.DataFrame.radd
    "pandas.DataFrame.radd"), [`rsub()`](../reference/api/pandas.DataFrame.rsub.html#pandas.DataFrame.rsub
    "pandas.DataFrame.rsub"), … for carrying out binary operations. For broadcasting
    behavior, Series input is of primary interest. Using these functions, you can
    use to either match on the *index* or *columns* via the **axis** keyword:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Furthermore you can align a level of a MultiIndexed DataFrame with a Series.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Series and Index also support the [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)") builtin. This function takes the floor division and modulo
    operation at the same time returning a two-tuple of the same type as the left
    hand side. For example:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can also do elementwise [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)"):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Missing data / operations with fill values
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Series and DataFrame, the arithmetic functions have the option of inputting
    a *fill_value*, namely a value to substitute when at most one of the values at
    a location are missing. For example, when adding two DataFrame objects, you may
    wish to treat NaN as 0 unless both DataFrames are missing that value, in which
    case the result will be NaN (you can later replace NaN with some other value using
    `fillna` if you wish).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '### Flexible comparisons'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Series and DataFrame have the binary comparison methods `eq`, `ne`, `lt`, `gt`,
    `le`, and `ge` whose behavior is analogous to the binary arithmetic operations
    described above:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'These operations produce a pandas object of the same type as the left-hand-side
    input that is of dtype `bool`. These `boolean` objects can be used in indexing
    operations, see the section on [Boolean indexing](indexing.html#indexing-boolean).  ###
    Boolean reductions'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply the reductions: [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty"), [`any()`](../reference/api/pandas.DataFrame.any.html#pandas.DataFrame.any
    "pandas.DataFrame.any"), [`all()`](../reference/api/pandas.DataFrame.all.html#pandas.DataFrame.all
    "pandas.DataFrame.all"), and [`bool()`](../reference/api/pandas.DataFrame.bool.html#pandas.DataFrame.bool
    "pandas.DataFrame.bool") to provide a way to summarize a boolean result.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can reduce to a final boolean value.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can test if a pandas object is empty, via the [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty") property.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Warning
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Asserting the truthiness of a pandas object will raise an error, as the testing
    of the emptiness or values is ambiguous.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'See [gotchas](gotchas.html#gotchas-truth) for a more detailed discussion.  ###
    Comparing if objects are equivalent'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Often you may find that there is more than one way to compute the same result.
    As a simple example, consider `df + df` and `df * 2`. To test that these two computations
    produce the same result, given the tools shown above, you might imagine using
    `(df + df == df * 2).all()`. But in fact, this expression is False:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Notice that the boolean DataFrame `df + df == df * 2` contains some False values!
    This is because NaNs do not compare as equals:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, NDFrames (such as Series and DataFrames) have an [`equals()`](../reference/api/pandas.DataFrame.equals.html#pandas.DataFrame.equals
    "pandas.DataFrame.equals") method for testing equality, with NaNs in corresponding
    locations treated as equal.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note that the Series or DataFrame index needs to be in the same order for equality
    to be True:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Comparing array-like objects
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can conveniently perform element-wise comparisons when comparing a pandas
    data structure with a scalar value:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'pandas also handles element-wise comparisons between different array-like objects
    of the same length:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Trying to compare `Index` or `Series` objects of different lengths will raise
    a ValueError:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Combining overlapping data sets
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A problem occasionally arising is the combination of two similar data sets
    where values in one are preferred over the other. An example would be two data
    series representing a particular economic indicator where one is considered to
    be of “higher quality”. However, the lower quality series might extend further
    back in history or have more complete data coverage. As such, we would like to
    combine two DataFrame objects where missing values in one DataFrame are conditionally
    filled with like-labeled values from the other DataFrame. The function implementing
    this operation is [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first"), which we illustrate:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: General DataFrame combine
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") method above calls the more general [`DataFrame.combine()`](../reference/api/pandas.DataFrame.combine.html#pandas.DataFrame.combine
    "pandas.DataFrame.combine"). This method takes another DataFrame and a combiner
    function, aligns the input DataFrame and then passes the combiner function pairs
    of Series (i.e., columns whose names are the same).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for instance, to reproduce [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") as above:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]  ## Descriptive statistics'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'There exists a large number of methods for computing descriptive statistics
    and other related operations on [Series](../reference/series.html#api-series-stats),
    [DataFrame](../reference/frame.html#api-dataframe-stats). Most of these are aggregations
    (hence producing a lower-dimensional result) like [`sum()`](../reference/api/pandas.DataFrame.sum.html#pandas.DataFrame.sum
    "pandas.DataFrame.sum"), [`mean()`](../reference/api/pandas.DataFrame.mean.html#pandas.DataFrame.mean
    "pandas.DataFrame.mean"), and [`quantile()`](../reference/api/pandas.DataFrame.quantile.html#pandas.DataFrame.quantile
    "pandas.DataFrame.quantile"), but some of them, like [`cumsum()`](../reference/api/pandas.DataFrame.cumsum.html#pandas.DataFrame.cumsum
    "pandas.DataFrame.cumsum") and [`cumprod()`](../reference/api/pandas.DataFrame.cumprod.html#pandas.DataFrame.cumprod
    "pandas.DataFrame.cumprod"), produce an object of the same size. Generally speaking,
    these methods take an **axis** argument, just like *ndarray.{sum, std, …}*, but
    the axis can be specified by name or integer:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: no axis argument needed'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: “index” (axis=0, default), “columns” (axis=1)'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'All such methods have a `skipna` option signaling whether to exclude missing
    data (`True` by default):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Combined with the broadcasting / arithmetic behavior, one can describe various
    statistical procedures, like standardization (rendering data zero mean and standard
    deviation of 1), very concisely:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that methods like [`cumsum()`](../reference/api/pandas.DataFrame.cumsum.html#pandas.DataFrame.cumsum
    "pandas.DataFrame.cumsum") and [`cumprod()`](../reference/api/pandas.DataFrame.cumprod.html#pandas.DataFrame.cumprod
    "pandas.DataFrame.cumprod") preserve the location of `NaN` values. This is somewhat
    different from [`expanding()`](../reference/api/pandas.DataFrame.expanding.html#pandas.DataFrame.expanding
    "pandas.DataFrame.expanding") and [`rolling()`](../reference/api/pandas.DataFrame.rolling.html#pandas.DataFrame.rolling
    "pandas.DataFrame.rolling") since `NaN` behavior is furthermore dictated by a
    `min_periods` parameter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here is a quick reference summary table of common functions. Each also takes
    an optional `level` parameter which applies only if the object has a [hierarchical
    index](advanced.html#advanced-hierarchical).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
- en: '| `count` | Number of non-NA observations |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Sum of values |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
- en: '| `mean` | Mean of values |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
- en: '| `median` | Arithmetic median of values |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
- en: '| `min` | Minimum |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
- en: '| `max` | Maximum |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
- en: '| `mode` | Mode |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Absolute Value |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
- en: '| `prod` | Product of values |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
- en: '| `std` | Bessel-corrected sample standard deviation |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
- en: '| `var` | Unbiased variance |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
- en: '| `sem` | Standard error of the mean |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| `skew` | Sample skewness (3rd moment) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `kurt` | Sample kurtosis (4th moment) |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
- en: '| `quantile` | Sample quantile (value at %) |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
- en: '| `cumsum` | Cumulative sum |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
- en: '| `cumprod` | Cumulative product |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| `cummax` | Cumulative maximum |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| `cummin` | Cumulative minimum |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: 'Note that by chance some NumPy methods, like `mean`, `std`, and `sum`, will
    exclude NAs on Series input by default:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[`Series.nunique()`](../reference/api/pandas.Series.nunique.html#pandas.Series.nunique
    "pandas.Series.nunique") will return the number of unique non-NA values in a Series:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '### Summarizing data: describe'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a convenient [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") function which computes a variety of summary statistics
    about a Series or the columns of a DataFrame (excluding NAs of course):'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can select specific percentiles to include in the output:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By default, the median is always included.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'For a non-numerical Series object, [`describe()`](../reference/api/pandas.Series.describe.html#pandas.Series.describe
    "pandas.Series.describe") will give a simple summary of the number of unique values
    and most frequently occurring values:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Note that on a mixed-type DataFrame object, [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") will restrict the summary to include only numerical
    columns or, if none are, only categorical columns:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This behavior can be controlled by providing a list of types as `include`/`exclude`
    arguments. The special value `all` can also be used:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That feature relies on [select_dtypes](#basics-selectdtypes). Refer to there
    for details about accepted inputs.  ### Index of min/max values'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") functions on Series and DataFrame compute the index
    labels with the minimum and maximum corresponding values:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'When there are multiple rows (or columns) matching the minimum or maximum value,
    [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") return the first matching index:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '`idxmin` and `idxmax` are called `argmin` and `argmax` in NumPy.  ### Value
    counts (histogramming) / mode'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`value_counts()`](../reference/api/pandas.Series.value_counts.html#pandas.Series.value_counts
    "pandas.Series.value_counts") Series method computes a histogram of a 1D array
    of values. It can also be used as a function on regular arrays:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The [`value_counts()`](../reference/api/pandas.DataFrame.value_counts.html#pandas.DataFrame.value_counts
    "pandas.DataFrame.value_counts") method can be used to count combinations across
    multiple columns. By default all columns are used but a subset can be selected
    using the `subset` argument.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Similarly, you can get the most frequently occurring value(s), i.e. the mode,
    of the values in a Series or DataFrame:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Discretization and quantiling
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Continuous values can be discretized using the [`cut()`](../reference/api/pandas.cut.html#pandas.cut
    "pandas.cut") (bins based on values) and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut
    "pandas.qcut") (bins based on sample quantiles) functions:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut "pandas.qcut") computes
    sample quantiles. For example, we could slice up some normally distributed data
    into equal-size quartiles like so:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We can also pass infinite values to define the bins:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]  ## Function application'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: To apply your own or another library’s functions to pandas objects, you should
    be aware of the three methods below. The appropriate method to use depends on
    whether your function expects to operate on an entire `DataFrame` or `Series`,
    row- or column-wise, or elementwise.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[Tablewise Function Application](#tablewise-function-application): [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe")'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Row or Column-wise Function Application](#row-or-column-wise-function-application):
    [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply")'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Aggregation API](#aggregation-api): [`agg()`](../reference/api/pandas.DataFrame.agg.html#pandas.DataFrame.agg
    "pandas.DataFrame.agg") and [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform")'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Applying Elementwise Functions](#applying-elementwise-functions): [`map()`](../reference/api/pandas.DataFrame.map.html#pandas.DataFrame.map
    "pandas.DataFrame.map")'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '### Tablewise function application'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrames` and `Series` can be passed into functions. However, if the function
    needs to be called in a chain, consider using the [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe") method.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'First some setup:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`extract_city_name` and `add_country_name` are functions taking and returning
    `DataFrames`.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Now compare the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Is equivalent to:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: pandas encourages the second style, which is known as method chaining. `pipe`
    makes it easy to use your own or another library’s functions in method chains,
    alongside pandas’ methods.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, the functions `extract_city_name` and `add_country_name`
    each expected a `DataFrame` as the first positional argument. What if the function
    you wish to apply takes its data as, say, the second argument? In this case, provide
    `pipe` with a tuple of `(callable, data_keyword)`. `.pipe` will route the `DataFrame`
    to the argument specified in the tuple.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can fit a regression using statsmodels. Their API expects a
    formula first and a `DataFrame` as the second argument, `data`. We pass in the
    function, keyword pair `(sm.ols, ''data'')` to `pipe`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The pipe method is inspired by unix pipes and more recently [dplyr](https://github.com/tidyverse/dplyr)
    and [magrittr](https://github.com/tidyverse/magrittr), which have introduced the
    popular `(%>%)` (read pipe) operator for [R](https://www.r-project.org). The implementation
    of `pipe` here is quite clean and feels right at home in Python. We encourage
    you to view the source code of [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe").
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Row or column-wise function application
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arbitrary functions can be applied along the axes of a DataFrame using the
    [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method, which, like the descriptive statistics methods,
    takes an optional `axis` argument:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method will also dispatch on a string method name.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The return type of the function passed to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") affects the type of the final output from `DataFrame.apply`
    for the default behaviour:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: If the applied function returns a `Series`, the final output is a `DataFrame`.
    The columns match the index of the `Series` returned by the applied function.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the applied function returns any other type, the final output is a `Series`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This default behaviour can be overridden using the `result_type`, which accepts
    three options: `reduce`, `broadcast`, and `expand`. These will determine how list-likes
    return values expand (or not) to a `DataFrame`.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '[`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") combined with some cleverness can be used to answer
    many questions about a data set. For example, suppose we wanted to extract the
    date where the maximum value for each column occurred:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: You may also pass additional arguments and keyword arguments to the [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Another useful feature is the ability to pass Series methods to carry out some
    Series operation on each column or row:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Finally, [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") takes an argument `raw` which is False by default, which
    converts each row or column into a Series before applying the function. When set
    to True, the passed function will instead receive an ndarray object, which has
    positive performance implications if you do not need the indexing functionality.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '### Aggregation API'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The aggregation API allows one to express possibly multiple aggregation operations
    in a single concise way. This API is similar across pandas objects, see [groupby
    API](groupby.html#groupby-aggregate), the [window API](window.html#window-overview),
    and the [resample API](timeseries.html#timeseries-aggregate). The entry point
    for aggregation is [`DataFrame.aggregate()`](../reference/api/pandas.DataFrame.aggregate.html#pandas.DataFrame.aggregate
    "pandas.DataFrame.aggregate"), or the alias [`DataFrame.agg()`](../reference/api/pandas.DataFrame.agg.html#pandas.DataFrame.agg
    "pandas.DataFrame.agg").
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a similar starting frame from above:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Using a single function is equivalent to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"). You can also pass named methods as strings. These will
    return a `Series` of the aggregated output:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Single aggregations on a `Series` this will return a scalar value:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Aggregating with multiple functions
  id: totrans-212
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can pass multiple aggregation arguments as a list. The results of each of
    the passed functions will be a row in the resulting `DataFrame`. These are naturally
    named from the aggregation function.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Multiple functions yield multiple rows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'On a `Series`, multiple functions return a `Series`, indexed by the function
    names:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Passing a `lambda` function will yield a `<lambda>` named row:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Passing a named function will yield that name for the row:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Aggregating with a dict
  id: totrans-223
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dictionary of column names to a scalar or a list of scalars, to `DataFrame.agg`
    allows you to customize which functions are applied to which columns. Note that
    the results are not in any particular order, you can use an `OrderedDict` instead
    to guarantee ordering.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Passing a list-like will generate a `DataFrame` output. You will get a matrix-like
    output of all of the aggregators. The output will consist of all unique functions.
    Those that are not noted for a particular column will be `NaN`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '#### Custom describe'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: With `.agg()` it is possible to easily create a custom describe function, similar
    to the built in [describe function](#basics-describe).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]  ### Transform API'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: The [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") method returns an object that is indexed the same
    (same size) as the original. This API allows you to provide *multiple* operations
    at the same time rather than one-by-one. Its API is quite similar to the `.agg`
    API.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: We create a frame similar to the one used in the above sections.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Transform the entire frame. `.transform()` allows input functions as: a NumPy
    function, a string function name or a user defined function.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") received a single function; this is equivalent to
    a [ufunc](https://numpy.org/doc/stable/reference/ufuncs.html) application.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Passing a single function to `.transform()` with a `Series` will yield a single
    `Series` in return.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Transform with multiple functions
  id: totrans-240
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing multiple functions will yield a column MultiIndexed DataFrame. The first
    level will be the original frame column names; the second level will be the names
    of the transforming functions.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Passing multiple functions to a Series will yield a DataFrame. The resulting
    column names will be the transforming functions.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Transforming with a dict
  id: totrans-245
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dict of functions will allow selective transforming per column.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Passing a dict of lists will generate a MultiIndexed DataFrame with these selective
    transforms.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]  ### Applying elementwise functions'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: 'Since not all functions can be vectorized (accept NumPy arrays and return another
    array or value), the methods [`map()`](../reference/api/pandas.DataFrame.map.html#pandas.DataFrame.map
    "pandas.DataFrame.map") on DataFrame and analogously [`map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") on Series accept any Python function taking a single value
    and returning a single value. For example:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[`Series.map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") has an additional feature; it can be used to easily “link”
    or “map” values defined by a secondary series. This is closely related to [merging/joining
    functionality](merging.html#merging):'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]  ## Reindexing and altering labels'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") is the fundamental data alignment method in pandas. It
    is used to implement nearly all other features relying on label-alignment functionality.
    To *reindex* means to conform the data to match a given set of labels along a
    particular axis. This accomplishes several things:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Reorders the existing data to match a new set of labels
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserts missing value (NA) markers in label locations where no data for that
    label existed
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If specified, **fill** data for missing labels using logic (highly relevant
    to working with time series data)
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here, the `f` label was not contained in the Series and hence appears as `NaN`
    in the result.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'With a DataFrame, you can simultaneously reindex the index and columns:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Note that the `Index` objects containing the actual axis labels can be **shared**
    between objects. So if we have a Series and a DataFrame, the following can be
    done:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: This means that the reindexed Series’s index is the same Python object as the
    DataFrame’s index.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.reindex()`](../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex
    "pandas.DataFrame.reindex") also supports an “axis-style” calling convention,
    where you specify a single `labels` argument and the `axis` it applies to.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: See also
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[MultiIndex / Advanced Indexing](advanced.html#advanced) is an even more concise
    way of doing reindexing.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing performance-sensitive code, there is a good reason to spend some
    time becoming a reindexing ninja: **many operations are faster on pre-aligned
    data**. Adding two unaligned DataFrames internally triggers a reindexing step.
    For exploratory analysis you will hardly notice the difference (because `reindex`
    has been heavily optimized), but when CPU cycles matter sprinkling a few explicit
    `reindex` calls here and there can have an impact.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '### Reindexing to align with another object'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wish to take an object and reindex its axes to be labeled the same
    as another object. While the syntax for this is straightforward albeit verbose,
    it is a common enough operation that the [`reindex_like()`](../reference/api/pandas.DataFrame.reindex_like.html#pandas.DataFrame.reindex_like
    "pandas.DataFrame.reindex_like") method is available to make this simpler:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]  ### Aligning objects with each other with `align`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`align()`](../reference/api/pandas.Series.align.html#pandas.Series.align
    "pandas.Series.align") method is the fastest way to simultaneously align two objects.
    It supports a `join` argument (related to [joining and merging](merging.html#merging)):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '`join=''outer''`: take the union of the indexes (default)'
  id: totrans-276
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-277
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-278
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''left''`: use the calling object’s index'
  id: totrans-279
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-280
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-281
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''right''`: use the passed object’s index'
  id: totrans-282
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-283
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-284
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''inner''`: intersect the indexes'
  id: totrans-285
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It returns a tuple with both of the reindexed Series:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'For DataFrames, the join method will be applied to both the index and the columns
    by default:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'You can also pass an `axis` option to only align on the specified axis:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'If you pass a Series to [`DataFrame.align()`](../reference/api/pandas.DataFrame.align.html#pandas.DataFrame.align
    "pandas.DataFrame.align"), you can choose to align both objects either on the
    DataFrame’s index or columns using the `axis` argument:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]  ### Filling while reindexing'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") takes an optional parameter `method` which is a filling
    method chosen from the following table:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Action |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| pad / ffill | Fill values forward |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '| bfill / backfill | Fill values backward |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
- en: '| nearest | Fill from the nearest index value |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
- en: 'We illustrate these fill methods on a simple Series:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: These methods require that the indexes are **ordered** increasing or decreasing.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the same result could have been achieved using [ffill](missing_data.html#missing-data-fillna)
    (except for `method=''nearest''`) or [interpolate](missing_data.html#missing-data-interpolate):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") will raise a ValueError if the index is not monotonically
    increasing or decreasing. [`fillna()`](../reference/api/pandas.Series.fillna.html#pandas.Series.fillna
    "pandas.Series.fillna") and [`interpolate()`](../reference/api/pandas.Series.interpolate.html#pandas.Series.interpolate
    "pandas.Series.interpolate") will not perform any checks on the order of the index.  ###
    Limits on filling while reindexing'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'The `limit` and `tolerance` arguments provide additional control over filling
    while reindexing. Limit specifies the maximum count of consecutive matches:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'In contrast, tolerance specifies the maximum distance between the index and
    indexer values:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Notice that when used on a `DatetimeIndex`, `TimedeltaIndex` or `PeriodIndex`,
    `tolerance` will coerced into a `Timedelta` if possible. This allows you to specify
    tolerance with appropriate strings.  ### Dropping labels from an axis'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'A method closely related to `reindex` is the [`drop()`](../reference/api/pandas.DataFrame.drop.html#pandas.DataFrame.drop
    "pandas.DataFrame.drop") function. It removes a set of labels from an axis:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Note that the following also works, but is a bit less obvious / clean:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]  ### Renaming / mapping labels'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: The [`rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") method allows you to relabel an axis based on some
    mapping (a dict or Series) or an arbitrary function.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'If you pass a function, it must return a value when called with any of the
    labels (and must produce a set of unique values). A dict or Series can also be
    used:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: If the mapping doesn’t include a column/index label, it isn’t renamed. Note
    that extra labels in the mapping don’t throw an error.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") also supports an “axis-style” calling convention, where
    you specify a single `mapper` and the `axis` to apply that mapping to.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Finally, [`rename()`](../reference/api/pandas.Series.rename.html#pandas.Series.rename
    "pandas.Series.rename") also accepts a scalar or list-like for altering the `Series.name`
    attribute.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The methods [`DataFrame.rename_axis()`](../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis
    "pandas.DataFrame.rename_axis") and [`Series.rename_axis()`](../reference/api/pandas.Series.rename_axis.html#pandas.Series.rename_axis
    "pandas.Series.rename_axis") allow specific names of a `MultiIndex` to be changed
    (as opposed to the labels).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]  ## Iteration'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of basic iteration over pandas objects depends on the type. When
    iterating over a Series, it is regarded as array-like, and basic iteration produces
    the values. DataFrames follow the dict-like convention of iterating over the “keys”
    of the objects.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, basic iteration (`for i in object`) produces:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: values'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: column labels'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, for example, iterating over a DataFrame gives you the column names:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: pandas objects also have the dict-like [`items()`](../reference/api/pandas.DataFrame.items.html#pandas.DataFrame.items
    "pandas.DataFrame.items") method to iterate over the (key, value) pairs.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate over the rows of a DataFrame, you can use the following methods:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows"): Iterate over the rows of a DataFrame as (index,
    Series) pairs. This converts the rows to Series objects, which can change the
    dtypes and has some performance implications.'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples"): Iterate over the rows of a DataFrame as namedtuples
    of the values. This is a lot faster than [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows"), and is in most cases preferable to use to iterate
    over the values of a DataFrame.'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating through pandas objects is generally **slow**. In many cases, iterating
    manually over the rows is not needed and can be avoided with one of the following
    approaches:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for a *vectorized* solution: many operations can be performed using built-in
    methods or NumPy functions, (boolean) indexing, …'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have a function that cannot work on the full DataFrame/Series at once,
    it is better to use [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") instead of iterating over the values. See the docs on
    [function application](#basics-apply).
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to do iterative manipulations on the values but performance is important,
    consider writing the inner loop with cython or numba. See the [enhancing performance](enhancingperf.html#enhancingperf)
    section for some examples of this approach.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: You should **never modify** something you are iterating over. This is not guaranteed
    to work in all cases. Depending on the data types, the iterator returns a copy
    and not a view, and writing to it will have no effect!
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following case setting the value has no effect:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: items
  id: totrans-345
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consistent with the dict-like interface, [`items()`](../reference/api/pandas.DataFrame.items.html#pandas.DataFrame.items
    "pandas.DataFrame.items") iterates through key-value pairs:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: (index, scalar value) pairs'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: (column, Series) pairs'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '### iterrows'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") allows you to iterate through the rows of a DataFrame
    as Series objects. It returns an iterator yielding each index value along with
    a Series containing the data in each row:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Note
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Because [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") returns a Series for each row, it does **not** preserve
    dtypes across the rows (dtypes are preserved across columns for DataFrames). For
    example,
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'All values in `row`, returned as a Series, are now upcasted to floats, also
    the original integer value in column `x`:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: To preserve dtypes while iterating over the rows, it is better to use [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") which returns namedtuples of the values and which
    is generally much faster than [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a contrived way to transpose the DataFrame would be:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: itertuples
  id: totrans-362
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") method will return an iterator yielding a namedtuple
    for each row in the DataFrame. The first element of the tuple will be the row’s
    corresponding index value, while the remaining values are the row values.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: This method does not convert the row to a Series object; it merely returns the
    values inside a namedtuple. Therefore, [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") preserves the data type of the values and is generally
    faster as [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'The column names will be renamed to positional names if they are invalid Python
    identifiers, repeated, or start with an underscore. With a large number of columns
    (>255), regular tuples are returned.  ## .dt accessor'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` has an accessor to succinctly return datetime like properties for
    the *values* of the Series, if it is a datetime/period like Series. This will
    return a Series, indexed like the existing Series.'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'This enables nice expressions like this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'You can easily produces tz aware transformations:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'You can also chain these types of operations:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: You can also format datetime values as strings with [`Series.dt.strftime()`](../reference/api/pandas.Series.dt.strftime.html#pandas.Series.dt.strftime
    "pandas.Series.dt.strftime") which supports the same format as the standard [`strftime()`](https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime
    "(in Python v3.12)").
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `.dt` accessor works for period and timedelta dtypes.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Note
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: '`Series.dt` will raise a `TypeError` if you access with a non-datetime-like
    values.'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Vectorized string methods
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Series is equipped with a set of string processing methods that make it easy
    to operate on each element of the array. Perhaps most importantly, these methods
    exclude missing/NA values automatically. These are accessed via the Series’s `str`
    attribute and generally have names matching the equivalent (scalar) built-in string
    methods. For example:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-387
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Powerful pattern-matching methods are provided as well, but note that pattern-matching
    generally uses [regular expressions](https://docs.python.org/3/library/re.html)
    by default (and in some cases always uses them).
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: Prior to pandas 1.0, string methods were only available on `object` -dtype `Series`.
    pandas 1.0 added the [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype") which is dedicated to strings. See [Text data types](text.html#text-types)
    for more.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: Please see [Vectorized String Methods](text.html#text-string-methods) for a
    complete description.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '## Sorting'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas supports three kinds of sorting: sorting by index labels, sorting by
    column values, and sorting by a combination of both.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: '### By index'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_index()`](../reference/api/pandas.Series.sort_index.html#pandas.Series.sort_index
    "pandas.Series.sort_index") and [`DataFrame.sort_index()`](../reference/api/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index
    "pandas.DataFrame.sort_index") methods are used to sort a pandas object by its
    index levels.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Sorting by index also supports a `key` parameter that takes a callable function
    to apply to the index being sorted. For `MultiIndex` objects, the key is applied
    per-level to the levels specified by `level`.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'For information on key sorting by value, see [value sorting](#basics-sort-value-key).  ###
    By values'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_values()`](../reference/api/pandas.Series.sort_values.html#pandas.Series.sort_values
    "pandas.Series.sort_values") method is used to sort a `Series` by its values.
    The [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") method is used to sort a `DataFrame` by its column
    or row values. The optional `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may used to specify one or more columns to use
    to determine the sorted order.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The `by` parameter can take a list of column names, e.g.:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'These methods have special treatment of NA values via the `na_position` argument:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Sorting also supports a `key` parameter that takes a callable function to apply
    to the values being sorted.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '`key` will be given the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") of values and should return a `Series` or array of the same shape
    with the transformed values. For `DataFrame` objects, the key is applied per column,
    so the key should still expect a Series and return a Series, e.g.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The name or type of each column can be used to apply different functions to
    different columns.  ### By indexes and values'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Strings passed as the `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may refer to either columns or index level names.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Sort by ‘second’ (index) and ‘A’ (column)
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Note
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'If a string matches both a column name and an index level name then a warning
    is issued and the column takes precedence. This will result in an ambiguity error
    in a future version.  ### searchsorted'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Series has the [`searchsorted()`](../reference/api/pandas.Series.searchsorted.html#pandas.Series.searchsorted
    "pandas.Series.searchsorted") method, which works similarly to [`numpy.ndarray.searchsorted()`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "(in NumPy v1.26)").
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]  ### smallest / largest values'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` has the [`nsmallest()`](../reference/api/pandas.Series.nsmallest.html#pandas.Series.nsmallest
    "pandas.Series.nsmallest") and [`nlargest()`](../reference/api/pandas.Series.nlargest.html#pandas.Series.nlargest
    "pandas.Series.nlargest") methods which return the smallest or largest \(n\) values.
    For a large `Series` this can be much faster than sorting the entire Series and
    calling `head(n)` on the result.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '`DataFrame` also has the `nlargest` and `nsmallest` methods.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]  ### Sorting by a MultiIndex column'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: You must be explicit about sorting when the column is a MultiIndex, and fully
    specify all levels to `by`.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Copying
  id: totrans-428
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`copy()`](../reference/api/pandas.DataFrame.copy.html#pandas.DataFrame.copy
    "pandas.DataFrame.copy") method on pandas objects copies the underlying data (though
    not the axis indexes, since they are immutable) and returns a new object. Note
    that **it is seldom necessary to copy objects**. For example, there are only a
    handful of ways to alter a DataFrame *in-place*:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: Inserting, deleting, or modifying a column.
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning to the `index` or `columns` attributes.
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For homogeneous data, directly modifying the values via the `values` attribute
    or advanced indexing.
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be clear, no pandas method has the side effect of modifying your data; almost
    every method returns a new object, leaving the original object untouched. If the
    data is modified, it is because you did so explicitly.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '## dtypes'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, pandas uses NumPy arrays and dtypes for Series or individual
    columns of a DataFrame. NumPy provides support for `float`, `int`, `bool`, `timedelta64[ns]`
    and `datetime64[ns]` (note that NumPy does not support timezone-aware datetimes).
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: pandas and third-party libraries *extend* NumPy’s type system in a few places.
    This section describes the extensions pandas has made internally. See [Extension
    types](../development/extending.html#extending-extension-types) for how to write
    your own extension that works with pandas. See [the ecosystem page](https://pandas.pydata.org/community/ecosystem.html)
    for a list of third-party libraries that have implemented an extension.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: The following table lists all of pandas extension types. For methods requiring
    `dtype` arguments, strings can be specified as indicated. See the respective documentation
    sections for more on each type.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: '| Kind of Data | Data Type | Scalar | Array | String Aliases |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
- en: '| [tz-aware datetime](timeseries.html#timeseries-timezone) | [`DatetimeTZDtype`](../reference/api/pandas.DatetimeTZDtype.html#pandas.DatetimeTZDtype
    "pandas.DatetimeTZDtype") | [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") | [`arrays.DatetimeArray`](../reference/api/pandas.arrays.DatetimeArray.html#pandas.arrays.DatetimeArray
    "pandas.arrays.DatetimeArray") | `''datetime64[ns, <tz>]''` |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
- en: '| [Categorical](categorical.html#categorical) | [`CategoricalDtype`](../reference/api/pandas.CategoricalDtype.html#pandas.CategoricalDtype
    "pandas.CategoricalDtype") | (none) | [`Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") | `''category''` |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
- en: '| [period (time spans)](timeseries.html#timeseries-periods) | [`PeriodDtype`](../reference/api/pandas.PeriodDtype.html#pandas.PeriodDtype
    "pandas.PeriodDtype") | [`Period`](../reference/api/pandas.Period.html#pandas.Period
    "pandas.Period") | [`arrays.PeriodArray`](../reference/api/pandas.arrays.PeriodArray.html#pandas.arrays.PeriodArray
    "pandas.arrays.PeriodArray") `''Period[<freq>]''` | `''period[<freq>]''`, |'
  id: totrans-442
  prefs: []
  type: TYPE_TB
- en: '| [sparse](sparse.html#sparse) | [`SparseDtype`](../reference/api/pandas.SparseDtype.html#pandas.SparseDtype
    "pandas.SparseDtype") | (none) | [`arrays.SparseArray`](../reference/api/pandas.arrays.SparseArray.html#pandas.arrays.SparseArray
    "pandas.arrays.SparseArray") | `''Sparse''`, `''Sparse[int]''`, `''Sparse[float]''`
    |'
  id: totrans-443
  prefs: []
  type: TYPE_TB
- en: '| [intervals](advanced.html#advanced-intervalindex) | [`IntervalDtype`](../reference/api/pandas.IntervalDtype.html#pandas.IntervalDtype
    "pandas.IntervalDtype") | [`Interval`](../reference/api/pandas.Interval.html#pandas.Interval
    "pandas.Interval") | [`arrays.IntervalArray`](../reference/api/pandas.arrays.IntervalArray.html#pandas.arrays.IntervalArray
    "pandas.arrays.IntervalArray") | `''interval''`, `''Interval''`, `''Interval[<numpy_dtype>]''`,
    `''Interval[datetime64[ns, <tz>]]''`, `''Interval[timedelta64[<freq>]]''` |'
  id: totrans-444
  prefs: []
  type: TYPE_TB
- en: '| [nullable integer](integer_na.html#integer-na) | [`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype
    "pandas.Int64Dtype"), … | (none) | [`arrays.IntegerArray`](../reference/api/pandas.arrays.IntegerArray.html#pandas.arrays.IntegerArray
    "pandas.arrays.IntegerArray") | `''Int8''`, `''Int16''`, `''Int32''`, `''Int64''`,
    `''UInt8''`, `''UInt16''`, `''UInt32''`, `''UInt64''` |'
  id: totrans-445
  prefs: []
  type: TYPE_TB
- en: '| [nullable float](../reference/arrays.html#api-arrays-float-na) | [`Float64Dtype`](../reference/api/pandas.Float64Dtype.html#pandas.Float64Dtype
    "pandas.Float64Dtype"), … | (none) | [`arrays.FloatingArray`](../reference/api/pandas.arrays.FloatingArray.html#pandas.arrays.FloatingArray
    "pandas.arrays.FloatingArray") | `''Float32''`, `''Float64''` |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
- en: '| [Strings](text.html#text) | [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype") | [`str`](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)") | [`arrays.StringArray`](../reference/api/pandas.arrays.StringArray.html#pandas.arrays.StringArray
    "pandas.arrays.StringArray") | `''string''` |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
- en: '| [Boolean (with NA)](../reference/arrays.html#api-arrays-bool) | [`BooleanDtype`](../reference/api/pandas.BooleanDtype.html#pandas.BooleanDtype
    "pandas.BooleanDtype") | [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)") | [`arrays.BooleanArray`](../reference/api/pandas.arrays.BooleanArray.html#pandas.arrays.BooleanArray
    "pandas.arrays.BooleanArray") | `''boolean''` |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
- en: pandas has two ways to store strings.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
- en: '`object` dtype, which can hold any Python object, including strings.'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype"), which is dedicated to strings.'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally, we recommend using [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype"). See [Text data types](text.html#text-types) for more.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
- en: Finally, arbitrary objects may be stored using the `object` dtype, but should
    be avoided to the extent possible (for performance and interoperability with other
    libraries and methods. See [object conversion](#basics-object-conversion)).
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
- en: A convenient [`dtypes`](../reference/api/pandas.DataFrame.dtypes.html#pandas.DataFrame.dtypes
    "pandas.DataFrame.dtypes") attribute for DataFrame returns a Series with the data
    type of each column.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: On a `Series` object, use the [`dtype`](../reference/api/pandas.Series.dtype.html#pandas.Series.dtype
    "pandas.Series.dtype") attribute.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: If a pandas object contains data with multiple dtypes *in a single column*,
    the dtype of the column will be chosen to accommodate all of the data types (`object`
    is the most general).
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: The number of columns of each type in a `DataFrame` can be found by calling
    `DataFrame.dtypes.value_counts()`.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed
    (either directly via the `dtype` keyword, a passed `ndarray`, or a passed `Series`),
    then it will be preserved in DataFrame operations. Furthermore, different numeric
    dtypes will **NOT** be combined. The following example will give you a taste.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: defaults
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default integer types are `int64` and float types are `float64`, *regardless*
    of platform (32-bit or 64-bit). The following will all result in `int64` dtypes.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Note that Numpy will choose *platform-dependent* types when creating arrays.
    The following **WILL** result in `int32` on 32-bit platform.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: upcasting
  id: totrans-469
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types can potentially be *upcasted* when combined with other types, meaning
    they are promoted from the current type (e.g. `int` to `float`).
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") will return the *lower-common-denominator* of the
    dtypes, meaning the dtype that can accommodate **ALL** of the types in the resulting
    homogeneous dtyped NumPy array. This can force some *upcasting*.'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: astype
  id: totrans-474
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") method to explicitly convert dtypes from one to another.
    These will by default return a copy, even if the dtype was unchanged (pass `copy=False`
    to change this behavior). In addition, they will raise an exception if the astype
    operation is invalid.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting is always according to the **NumPy** rules. If two different dtypes
    are involved in an operation, then the more *general* one will be used as the
    result of the operation.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Convert certain columns to a specific dtype by passing a dict to [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Note
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: When trying to convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") and [`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc
    "pandas.DataFrame.loc"), upcasting occurs.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: '[`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc "pandas.DataFrame.loc")
    tries to fit in what we are assigning to the current dtypes, while `[]` will overwrite
    them taking the dtype from the right hand side. Therefore the following piece
    of code produces the unintended result.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '### object conversion'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: pandas offers various functions to try to force conversion of types from the
    `object` dtype to other types. In cases where the data is already of the correct
    type, but stored in an `object` array, the [`DataFrame.infer_objects()`](../reference/api/pandas.DataFrame.infer_objects.html#pandas.DataFrame.infer_objects
    "pandas.DataFrame.infer_objects") and [`Series.infer_objects()`](../reference/api/pandas.Series.infer_objects.html#pandas.Series.infer_objects
    "pandas.Series.infer_objects") methods can be used to soft convert to the correct
    type.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  id: totrans-488
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Because the data was transposed the original inference stored all columns as
    object, which `infer_objects` will correct.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  id: totrans-490
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The following functions are available for one dimensional object arrays or
    scalars to perform hard conversion of objects to a specified type:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") (conversion to numeric dtypes)'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE146]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[`to_datetime()`](../reference/api/pandas.to_datetime.html#pandas.to_datetime
    "pandas.to_datetime") (conversion to datetime objects)'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE147]'
  id: totrans-495
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[`to_timedelta()`](../reference/api/pandas.to_timedelta.html#pandas.to_timedelta
    "pandas.to_timedelta") (conversion to timedelta objects)'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE148]'
  id: totrans-497
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'To force a conversion, we can pass in an `errors` argument, which specifies
    how pandas should deal with elements that cannot be converted to desired dtype
    or object. By default, `errors=''raise''`, meaning that any errors encountered
    will be raised during the conversion process. However, if `errors=''coerce''`,
    these errors will be ignored and pandas will convert problematic elements to `pd.NaT`
    (for datetime and timedelta) or `np.nan` (for numeric). This might be useful if
    you are reading in data which is mostly of the desired dtype (e.g. numeric, datetime),
    but occasionally has non-conforming elements intermixed that you want to represent
    as missing:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'In addition to object conversion, [`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") provides another argument `downcast`, which gives the option
    of downcasting the newly (or already) numeric data to a smaller dtype, which can
    conserve memory:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'As these methods apply only to one-dimensional arrays, lists or scalars; they
    cannot be used directly on multi-dimensional objects such as DataFrames. However,
    with [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"), we can “apply” the function over each column efficiently:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: gotchas
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performing selection operations on `integer` type data can easily upcast the
    data to `floating`. The dtype of the input data will be preserved in cases where
    `nans` are not introduced. See also [Support for integer NA](gotchas.html#gotchas-intna).
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: While float dtypes are unchanged.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Selecting columns based on `dtype`
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") method implements subsetting of columns based
    on their `dtype`.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") with a slew of different dtypes:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'And the dtypes:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") has two parameters `include` and `exclude` that
    allow you to say “give me the columns *with* these dtypes” (`include`) and/or
    “give the columns *without* these dtypes” (`exclude`).'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to select `bool` columns:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'You can also pass the name of a dtype in the [NumPy dtype hierarchy](https://numpy.org/doc/stable/reference/arrays.scalars.html):'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  id: totrans-519
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") also works with generic dtypes as well.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to select all numeric and boolean columns while excluding unsigned
    integers:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'To select string columns you must use the `object` dtype:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'To see all the child dtypes of a generic `dtype` like `numpy.number` you can
    define a function that returns a tree of child dtypes:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'All NumPy dtypes are subclasses of `numpy.generic`:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Note
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: pandas also defines the types `category`, and `datetime64[ns, tz]`, which are
    not integrated into the normal NumPy hierarchy and won’t show up with the above
    function.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: '## Head and tail'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: To view a small sample of a Series or DataFrame object, use the [`head()`](../reference/api/pandas.DataFrame.head.html#pandas.DataFrame.head
    "pandas.DataFrame.head") and [`tail()`](../reference/api/pandas.DataFrame.tail.html#pandas.DataFrame.tail
    "pandas.DataFrame.tail") methods. The default number of elements to display is
    five, but you may pass a custom number.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '## Attributes and underlying data'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: pandas objects have a number of attributes enabling you to access the metadata
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: '**shape**: gives the axis dimensions of the object, consistent with ndarray'
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Axis labels
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Series**: *index* (only axis)'
  id: totrans-538
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: *index* (rows) and *columns*'
  id: totrans-539
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Note, **these attributes can be safely assigned to**!
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: pandas objects ([`Index`](../reference/api/pandas.Index.html#pandas.Index "pandas.Index"),
    [`Series`](../reference/api/pandas.Series.html#pandas.Series "pandas.Series"),
    [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame "pandas.DataFrame"))
    can be thought of as containers for arrays, which hold the actual data and do
    the actual computation. For many types, the underlying array is a [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). However, pandas and 3rd party libraries may *extend* NumPy’s
    type system to add support for custom arrays (see [dtypes](#basics-dtypes)).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: To get the actual data inside a [`Index`](../reference/api/pandas.Index.html#pandas.Index
    "pandas.Index") or [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series"), use the `.array` property
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[`array`](../reference/api/pandas.Series.array.html#pandas.Series.array "pandas.Series.array")
    will always be an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"). The exact details of what an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray") is and why pandas uses them are a bit
    beyond the scope of this introduction. See [dtypes](#basics-dtypes) for more.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: If you know you need a NumPy array, use [`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") or `numpy.asarray()`.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: When the Series or Index is backed by an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), [`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") may involve copying data and coercing values. See [dtypes](#basics-dtypes)
    for more.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") gives some control over the `dtype` of the resulting
    [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"). For example, consider datetimes with timezones. NumPy doesn’t
    have a dtype to represent timezone-aware datetimes, so there are two possibly
    useful representations:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: An object-dtype [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)") with [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") objects, each with the correct `tz`
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `datetime64[ns]` -dtype [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v1.26)"), where the values have been converted to UTC and the timezone
    discarded
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Timezones may be preserved with `dtype=object`
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Or thrown away with `dtype='datetime64[ns]'`
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'Getting the “raw data” inside a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") is possibly a bit more complex. When your `DataFrame` only
    has a single data type for all the columns, [`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") will return the underlying data:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: If a DataFrame contains homogeneously-typed data, the ndarray can actually be
    modified in-place, and the changes will be reflected in the data structure. For
    heterogeneous data (e.g. some of the DataFrame’s columns are not all the same
    dtype), this will not be the case. The values attribute itself, unlike the axis
    labels, cannot be assigned to.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: When working with heterogeneous data, the dtype of the resulting ndarray will
    be chosen to accommodate all of the data involved. For example, if strings are
    involved, the result will be of object dtype. If there are only floats and integers,
    the resulting array will be of float dtype.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, pandas recommended [`Series.values`](../reference/api/pandas.Series.values.html#pandas.Series.values
    "pandas.Series.values") or [`DataFrame.values`](../reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values
    "pandas.DataFrame.values") for extracting the data from a Series or DataFrame.
    You’ll still find references to these in old code bases and online. Going forward,
    we recommend avoiding `.values` and using `.array` or `.to_numpy()`. `.values`
    has the following drawbacks:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: When your Series contains an [extension type](../development/extending.html#extending-extension-types),
    it’s unclear whether [`Series.values`](../reference/api/pandas.Series.values.html#pandas.Series.values
    "pandas.Series.values") returns a NumPy array or the extension array. [`Series.array`](../reference/api/pandas.Series.array.html#pandas.Series.array
    "pandas.Series.array") will always return an [`ExtensionArray`](../reference/api/pandas.api.extensions.ExtensionArray.html#pandas.api.extensions.ExtensionArray
    "pandas.api.extensions.ExtensionArray"), and will never copy data. [`Series.to_numpy()`](../reference/api/pandas.Series.to_numpy.html#pandas.Series.to_numpy
    "pandas.Series.to_numpy") will always return a NumPy array, potentially at the
    cost of copying / coercing values.
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When your DataFrame contains a mixture of data types, [`DataFrame.values`](../reference/api/pandas.DataFrame.values.html#pandas.DataFrame.values
    "pandas.DataFrame.values") may involve copying data and coercing values to a common
    dtype, a relatively expensive operation. [`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy"), being a method, makes it clearer that the returned
    NumPy array may not be a view on the same data in the DataFrame.
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '## Accelerated operations'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: pandas has support for accelerating certain types of binary numerical and boolean
    operations using the `numexpr` library and the `bottleneck` libraries.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: These libraries are especially useful when dealing with large data sets, and
    provide large speedups. `numexpr` uses smart chunking, caching, and multiple cores.
    `bottleneck` is a set of specialized cython routines that are especially fast
    when dealing with arrays that have `nans`.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a sample (using 100 column x 100,000 row `DataFrames`):'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: '| Operation | 0.11.0 (ms) | Prior Version (ms) | Ratio to Prior |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-569
  prefs: []
  type: TYPE_TB
- en: '| `df1 > df2` | 13.32 | 125.35 | 0.1063 |'
  id: totrans-570
  prefs: []
  type: TYPE_TB
- en: '| `df1 * df2` | 21.71 | 36.63 | 0.5928 |'
  id: totrans-571
  prefs: []
  type: TYPE_TB
- en: '| `df1 + df2` | 22.04 | 36.50 | 0.6039 |'
  id: totrans-572
  prefs: []
  type: TYPE_TB
- en: You are highly encouraged to install both libraries. See the section [Recommended
    Dependencies](../getting_started/install.html#install-recommended-dependencies)
    for more installation info.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
- en: 'These are both enabled to be used by default, you can control this by setting
    the options:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  id: totrans-575
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '## Flexible binary operations'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
- en: 'With binary operations between pandas data structures, there are two key points
    of interest:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
- en: Broadcasting behavior between higher- (e.g. DataFrame) and lower-dimensional
    (e.g. Series) objects.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Missing data in computations.
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will demonstrate how to manage these issues independently, though they can
    be handled simultaneously.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
- en: Matching / broadcasting behavior
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DataFrame has the methods [`add()`](../reference/api/pandas.DataFrame.add.html#pandas.DataFrame.add
    "pandas.DataFrame.add"), [`sub()`](../reference/api/pandas.DataFrame.sub.html#pandas.DataFrame.sub
    "pandas.DataFrame.sub"), [`mul()`](../reference/api/pandas.DataFrame.mul.html#pandas.DataFrame.mul
    "pandas.DataFrame.mul"), [`div()`](../reference/api/pandas.DataFrame.div.html#pandas.DataFrame.div
    "pandas.DataFrame.div") and related functions [`radd()`](../reference/api/pandas.DataFrame.radd.html#pandas.DataFrame.radd
    "pandas.DataFrame.radd"), [`rsub()`](../reference/api/pandas.DataFrame.rsub.html#pandas.DataFrame.rsub
    "pandas.DataFrame.rsub"), … for carrying out binary operations. For broadcasting
    behavior, Series input is of primary interest. Using these functions, you can
    use to either match on the *index* or *columns* via the **axis** keyword:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Furthermore you can align a level of a MultiIndexed DataFrame with a Series.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'Series and Index also support the [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)") builtin. This function takes the floor division and modulo
    operation at the same time returning a two-tuple of the same type as the left
    hand side. For example:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'We can also do elementwise [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)"):'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Missing data / operations with fill values
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Series and DataFrame, the arithmetic functions have the option of inputting
    a *fill_value*, namely a value to substitute when at most one of the values at
    a location are missing. For example, when adding two DataFrame objects, you may
    wish to treat NaN as 0 unless both DataFrames are missing that value, in which
    case the result will be NaN (you can later replace NaN with some other value using
    `fillna` if you wish).
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '### Flexible comparisons'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
- en: 'Series and DataFrame have the binary comparison methods `eq`, `ne`, `lt`, `gt`,
    `le`, and `ge` whose behavior is analogous to the binary arithmetic operations
    described above:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'These operations produce a pandas object of the same type as the left-hand-side
    input that is of dtype `bool`. These `boolean` objects can be used in indexing
    operations, see the section on [Boolean indexing](indexing.html#indexing-boolean).  ###
    Boolean reductions'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply the reductions: [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty"), [`any()`](../reference/api/pandas.DataFrame.any.html#pandas.DataFrame.any
    "pandas.DataFrame.any"), [`all()`](../reference/api/pandas.DataFrame.all.html#pandas.DataFrame.all
    "pandas.DataFrame.all"), and [`bool()`](../reference/api/pandas.DataFrame.bool.html#pandas.DataFrame.bool
    "pandas.DataFrame.bool") to provide a way to summarize a boolean result.'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: You can reduce to a final boolean value.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: You can test if a pandas object is empty, via the [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty") property.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Warning
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
- en: Asserting the truthiness of a pandas object will raise an error, as the testing
    of the emptiness or values is ambiguous.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'See [gotchas](gotchas.html#gotchas-truth) for a more detailed discussion.  ###
    Comparing if objects are equivalent'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
- en: 'Often you may find that there is more than one way to compute the same result.
    As a simple example, consider `df + df` and `df * 2`. To test that these two computations
    produce the same result, given the tools shown above, you might imagine using
    `(df + df == df * 2).all()`. But in fact, this expression is False:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Notice that the boolean DataFrame `df + df == df * 2` contains some False values!
    This is because NaNs do not compare as equals:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: So, NDFrames (such as Series and DataFrames) have an [`equals()`](../reference/api/pandas.DataFrame.equals.html#pandas.DataFrame.equals
    "pandas.DataFrame.equals") method for testing equality, with NaNs in corresponding
    locations treated as equal.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Note that the Series or DataFrame index needs to be in the same order for equality
    to be True:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Comparing array-like objects
  id: totrans-616
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can conveniently perform element-wise comparisons when comparing a pandas
    data structure with a scalar value:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'pandas also handles element-wise comparisons between different array-like objects
    of the same length:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Trying to compare `Index` or `Series` objects of different lengths will raise
    a ValueError:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: Combining overlapping data sets
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A problem occasionally arising is the combination of two similar data sets
    where values in one are preferred over the other. An example would be two data
    series representing a particular economic indicator where one is considered to
    be of “higher quality”. However, the lower quality series might extend further
    back in history or have more complete data coverage. As such, we would like to
    combine two DataFrame objects where missing values in one DataFrame are conditionally
    filled with like-labeled values from the other DataFrame. The function implementing
    this operation is [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first"), which we illustrate:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: General DataFrame combine
  id: totrans-626
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") method above calls the more general [`DataFrame.combine()`](../reference/api/pandas.DataFrame.combine.html#pandas.DataFrame.combine
    "pandas.DataFrame.combine"). This method takes another DataFrame and a combiner
    function, aligns the input DataFrame and then passes the combiner function pairs
    of Series (i.e., columns whose names are the same).
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for instance, to reproduce [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") as above:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Matching / broadcasting behavior
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DataFrame has the methods [`add()`](../reference/api/pandas.DataFrame.add.html#pandas.DataFrame.add
    "pandas.DataFrame.add"), [`sub()`](../reference/api/pandas.DataFrame.sub.html#pandas.DataFrame.sub
    "pandas.DataFrame.sub"), [`mul()`](../reference/api/pandas.DataFrame.mul.html#pandas.DataFrame.mul
    "pandas.DataFrame.mul"), [`div()`](../reference/api/pandas.DataFrame.div.html#pandas.DataFrame.div
    "pandas.DataFrame.div") and related functions [`radd()`](../reference/api/pandas.DataFrame.radd.html#pandas.DataFrame.radd
    "pandas.DataFrame.radd"), [`rsub()`](../reference/api/pandas.DataFrame.rsub.html#pandas.DataFrame.rsub
    "pandas.DataFrame.rsub"), … for carrying out binary operations. For broadcasting
    behavior, Series input is of primary interest. Using these functions, you can
    use to either match on the *index* or *columns* via the **axis** keyword:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Furthermore you can align a level of a MultiIndexed DataFrame with a Series.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'Series and Index also support the [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)") builtin. This function takes the floor division and modulo
    operation at the same time returning a two-tuple of the same type as the left
    hand side. For example:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'We can also do elementwise [`divmod()`](https://docs.python.org/3/library/functions.html#divmod
    "(in Python v3.12)"):'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Missing data / operations with fill values
  id: totrans-639
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Series and DataFrame, the arithmetic functions have the option of inputting
    a *fill_value*, namely a value to substitute when at most one of the values at
    a location are missing. For example, when adding two DataFrame objects, you may
    wish to treat NaN as 0 unless both DataFrames are missing that value, in which
    case the result will be NaN (you can later replace NaN with some other value using
    `fillna` if you wish).
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '### Flexible comparisons'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
- en: 'Series and DataFrame have the binary comparison methods `eq`, `ne`, `lt`, `gt`,
    `le`, and `ge` whose behavior is analogous to the binary arithmetic operations
    described above:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: These operations produce a pandas object of the same type as the left-hand-side
    input that is of dtype `bool`. These `boolean` objects can be used in indexing
    operations, see the section on [Boolean indexing](indexing.html#indexing-boolean).
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
- en: '### Boolean reductions'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
- en: 'You can apply the reductions: [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty"), [`any()`](../reference/api/pandas.DataFrame.any.html#pandas.DataFrame.any
    "pandas.DataFrame.any"), [`all()`](../reference/api/pandas.DataFrame.all.html#pandas.DataFrame.all
    "pandas.DataFrame.all"), and [`bool()`](../reference/api/pandas.DataFrame.bool.html#pandas.DataFrame.bool
    "pandas.DataFrame.bool") to provide a way to summarize a boolean result.'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: You can reduce to a final boolean value.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  id: totrans-650
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: You can test if a pandas object is empty, via the [`empty`](../reference/api/pandas.DataFrame.empty.html#pandas.DataFrame.empty
    "pandas.DataFrame.empty") property.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Warning
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
- en: Asserting the truthiness of a pandas object will raise an error, as the testing
    of the emptiness or values is ambiguous.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: See [gotchas](gotchas.html#gotchas-truth) for a more detailed discussion.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
- en: '### Comparing if objects are equivalent'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: 'Often you may find that there is more than one way to compute the same result.
    As a simple example, consider `df + df` and `df * 2`. To test that these two computations
    produce the same result, given the tools shown above, you might imagine using
    `(df + df == df * 2).all()`. But in fact, this expression is False:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Notice that the boolean DataFrame `df + df == df * 2` contains some False values!
    This is because NaNs do not compare as equals:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: So, NDFrames (such as Series and DataFrames) have an [`equals()`](../reference/api/pandas.DataFrame.equals.html#pandas.DataFrame.equals
    "pandas.DataFrame.equals") method for testing equality, with NaNs in corresponding
    locations treated as equal.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'Note that the Series or DataFrame index needs to be in the same order for equality
    to be True:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Comparing array-like objects
  id: totrans-667
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can conveniently perform element-wise comparisons when comparing a pandas
    data structure with a scalar value:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'pandas also handles element-wise comparisons between different array-like objects
    of the same length:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'Trying to compare `Index` or `Series` objects of different lengths will raise
    a ValueError:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: Combining overlapping data sets
  id: totrans-674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A problem occasionally arising is the combination of two similar data sets
    where values in one are preferred over the other. An example would be two data
    series representing a particular economic indicator where one is considered to
    be of “higher quality”. However, the lower quality series might extend further
    back in history or have more complete data coverage. As such, we would like to
    combine two DataFrame objects where missing values in one DataFrame are conditionally
    filled with like-labeled values from the other DataFrame. The function implementing
    this operation is [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first"), which we illustrate:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: General DataFrame combine
  id: totrans-677
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") method above calls the more general [`DataFrame.combine()`](../reference/api/pandas.DataFrame.combine.html#pandas.DataFrame.combine
    "pandas.DataFrame.combine"). This method takes another DataFrame and a combiner
    function, aligns the input DataFrame and then passes the combiner function pairs
    of Series (i.e., columns whose names are the same).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
- en: 'So, for instance, to reproduce [`combine_first()`](../reference/api/pandas.DataFrame.combine_first.html#pandas.DataFrame.combine_first
    "pandas.DataFrame.combine_first") as above:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '## Descriptive statistics'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
- en: 'There exists a large number of methods for computing descriptive statistics
    and other related operations on [Series](../reference/series.html#api-series-stats),
    [DataFrame](../reference/frame.html#api-dataframe-stats). Most of these are aggregations
    (hence producing a lower-dimensional result) like [`sum()`](../reference/api/pandas.DataFrame.sum.html#pandas.DataFrame.sum
    "pandas.DataFrame.sum"), [`mean()`](../reference/api/pandas.DataFrame.mean.html#pandas.DataFrame.mean
    "pandas.DataFrame.mean"), and [`quantile()`](../reference/api/pandas.DataFrame.quantile.html#pandas.DataFrame.quantile
    "pandas.DataFrame.quantile"), but some of them, like [`cumsum()`](../reference/api/pandas.DataFrame.cumsum.html#pandas.DataFrame.cumsum
    "pandas.DataFrame.cumsum") and [`cumprod()`](../reference/api/pandas.DataFrame.cumprod.html#pandas.DataFrame.cumprod
    "pandas.DataFrame.cumprod"), produce an object of the same size. Generally speaking,
    these methods take an **axis** argument, just like *ndarray.{sum, std, …}*, but
    the axis can be specified by name or integer:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: no axis argument needed'
  id: totrans-683
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: “index” (axis=0, default), “columns” (axis=1)'
  id: totrans-684
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'All such methods have a `skipna` option signaling whether to exclude missing
    data (`True` by default):'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Combined with the broadcasting / arithmetic behavior, one can describe various
    statistical procedures, like standardization (rendering data zero mean and standard
    deviation of 1), very concisely:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Note that methods like [`cumsum()`](../reference/api/pandas.DataFrame.cumsum.html#pandas.DataFrame.cumsum
    "pandas.DataFrame.cumsum") and [`cumprod()`](../reference/api/pandas.DataFrame.cumprod.html#pandas.DataFrame.cumprod
    "pandas.DataFrame.cumprod") preserve the location of `NaN` values. This is somewhat
    different from [`expanding()`](../reference/api/pandas.DataFrame.expanding.html#pandas.DataFrame.expanding
    "pandas.DataFrame.expanding") and [`rolling()`](../reference/api/pandas.DataFrame.rolling.html#pandas.DataFrame.rolling
    "pandas.DataFrame.rolling") since `NaN` behavior is furthermore dictated by a
    `min_periods` parameter.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: Here is a quick reference summary table of common functions. Each also takes
    an optional `level` parameter which applies only if the object has a [hierarchical
    index](advanced.html#advanced-hierarchical).
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  id: totrans-694
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-695
  prefs: []
  type: TYPE_TB
- en: '| `count` | Number of non-NA observations |'
  id: totrans-696
  prefs: []
  type: TYPE_TB
- en: '| `sum` | Sum of values |'
  id: totrans-697
  prefs: []
  type: TYPE_TB
- en: '| `mean` | Mean of values |'
  id: totrans-698
  prefs: []
  type: TYPE_TB
- en: '| `median` | Arithmetic median of values |'
  id: totrans-699
  prefs: []
  type: TYPE_TB
- en: '| `min` | Minimum |'
  id: totrans-700
  prefs: []
  type: TYPE_TB
- en: '| `max` | Maximum |'
  id: totrans-701
  prefs: []
  type: TYPE_TB
- en: '| `mode` | Mode |'
  id: totrans-702
  prefs: []
  type: TYPE_TB
- en: '| `abs` | Absolute Value |'
  id: totrans-703
  prefs: []
  type: TYPE_TB
- en: '| `prod` | Product of values |'
  id: totrans-704
  prefs: []
  type: TYPE_TB
- en: '| `std` | Bessel-corrected sample standard deviation |'
  id: totrans-705
  prefs: []
  type: TYPE_TB
- en: '| `var` | Unbiased variance |'
  id: totrans-706
  prefs: []
  type: TYPE_TB
- en: '| `sem` | Standard error of the mean |'
  id: totrans-707
  prefs: []
  type: TYPE_TB
- en: '| `skew` | Sample skewness (3rd moment) |'
  id: totrans-708
  prefs: []
  type: TYPE_TB
- en: '| `kurt` | Sample kurtosis (4th moment) |'
  id: totrans-709
  prefs: []
  type: TYPE_TB
- en: '| `quantile` | Sample quantile (value at %) |'
  id: totrans-710
  prefs: []
  type: TYPE_TB
- en: '| `cumsum` | Cumulative sum |'
  id: totrans-711
  prefs: []
  type: TYPE_TB
- en: '| `cumprod` | Cumulative product |'
  id: totrans-712
  prefs: []
  type: TYPE_TB
- en: '| `cummax` | Cumulative maximum |'
  id: totrans-713
  prefs: []
  type: TYPE_TB
- en: '| `cummin` | Cumulative minimum |'
  id: totrans-714
  prefs: []
  type: TYPE_TB
- en: 'Note that by chance some NumPy methods, like `mean`, `std`, and `sum`, will
    exclude NAs on Series input by default:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[`Series.nunique()`](../reference/api/pandas.Series.nunique.html#pandas.Series.nunique
    "pandas.Series.nunique") will return the number of unique non-NA values in a Series:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '### Summarizing data: describe'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a convenient [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") function which computes a variety of summary statistics
    about a Series or the columns of a DataFrame (excluding NAs of course):'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'You can select specific percentiles to include in the output:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: By default, the median is always included.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
- en: 'For a non-numerical Series object, [`describe()`](../reference/api/pandas.Series.describe.html#pandas.Series.describe
    "pandas.Series.describe") will give a simple summary of the number of unique values
    and most frequently occurring values:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'Note that on a mixed-type DataFrame object, [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") will restrict the summary to include only numerical
    columns or, if none are, only categorical columns:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'This behavior can be controlled by providing a list of types as `include`/`exclude`
    arguments. The special value `all` can also be used:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'That feature relies on [select_dtypes](#basics-selectdtypes). Refer to there
    for details about accepted inputs.  ### Index of min/max values'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") functions on Series and DataFrame compute the index
    labels with the minimum and maximum corresponding values:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'When there are multiple rows (or columns) matching the minimum or maximum value,
    [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") return the first matching index:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: Note
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
- en: '`idxmin` and `idxmax` are called `argmin` and `argmax` in NumPy.  ### Value
    counts (histogramming) / mode'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`value_counts()`](../reference/api/pandas.Series.value_counts.html#pandas.Series.value_counts
    "pandas.Series.value_counts") Series method computes a histogram of a 1D array
    of values. It can also be used as a function on regular arrays:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The [`value_counts()`](../reference/api/pandas.DataFrame.value_counts.html#pandas.DataFrame.value_counts
    "pandas.DataFrame.value_counts") method can be used to count combinations across
    multiple columns. By default all columns are used but a subset can be selected
    using the `subset` argument.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  id: totrans-741
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: 'Similarly, you can get the most frequently occurring value(s), i.e. the mode,
    of the values in a Series or DataFrame:'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  id: totrans-743
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: Discretization and quantiling
  id: totrans-744
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Continuous values can be discretized using the [`cut()`](../reference/api/pandas.cut.html#pandas.cut
    "pandas.cut") (bins based on values) and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut
    "pandas.qcut") (bins based on sample quantiles) functions:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut "pandas.qcut") computes
    sample quantiles. For example, we could slice up some normally distributed data
    into equal-size quartiles like so:'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  id: totrans-748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'We can also pass infinite values to define the bins:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '### Summarizing data: describe'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a convenient [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") function which computes a variety of summary statistics
    about a Series or the columns of a DataFrame (excluding NAs of course):'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'You can select specific percentiles to include in the output:'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  id: totrans-755
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: By default, the median is always included.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
- en: 'For a non-numerical Series object, [`describe()`](../reference/api/pandas.Series.describe.html#pandas.Series.describe
    "pandas.Series.describe") will give a simple summary of the number of unique values
    and most frequently occurring values:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'Note that on a mixed-type DataFrame object, [`describe()`](../reference/api/pandas.DataFrame.describe.html#pandas.DataFrame.describe
    "pandas.DataFrame.describe") will restrict the summary to include only numerical
    columns or, if none are, only categorical columns:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'This behavior can be controlled by providing a list of types as `include`/`exclude`
    arguments. The special value `all` can also be used:'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: That feature relies on [select_dtypes](#basics-selectdtypes). Refer to there
    for details about accepted inputs.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
- en: '### Index of min/max values'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") functions on Series and DataFrame compute the index
    labels with the minimum and maximum corresponding values:'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  id: totrans-766
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'When there are multiple rows (or columns) matching the minimum or maximum value,
    [`idxmin()`](../reference/api/pandas.DataFrame.idxmin.html#pandas.DataFrame.idxmin
    "pandas.DataFrame.idxmin") and [`idxmax()`](../reference/api/pandas.DataFrame.idxmax.html#pandas.DataFrame.idxmax
    "pandas.DataFrame.idxmax") return the first matching index:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: Note
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
- en: '`idxmin` and `idxmax` are called `argmin` and `argmax` in NumPy.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
- en: '### Value counts (histogramming) / mode'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`value_counts()`](../reference/api/pandas.Series.value_counts.html#pandas.Series.value_counts
    "pandas.Series.value_counts") Series method computes a histogram of a 1D array
    of values. It can also be used as a function on regular arrays:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: The [`value_counts()`](../reference/api/pandas.DataFrame.value_counts.html#pandas.DataFrame.value_counts
    "pandas.DataFrame.value_counts") method can be used to count combinations across
    multiple columns. By default all columns are used but a subset can be selected
    using the `subset` argument.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'Similarly, you can get the most frequently occurring value(s), i.e. the mode,
    of the values in a Series or DataFrame:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: Discretization and quantiling
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Continuous values can be discretized using the [`cut()`](../reference/api/pandas.cut.html#pandas.cut
    "pandas.cut") (bins based on values) and [`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut
    "pandas.qcut") (bins based on sample quantiles) functions:'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  id: totrans-780
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[`qcut()`](../reference/api/pandas.qcut.html#pandas.qcut "pandas.qcut") computes
    sample quantiles. For example, we could slice up some normally distributed data
    into equal-size quartiles like so:'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  id: totrans-782
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'We can also pass infinite values to define the bins:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '## Function application'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
- en: To apply your own or another library’s functions to pandas objects, you should
    be aware of the three methods below. The appropriate method to use depends on
    whether your function expects to operate on an entire `DataFrame` or `Series`,
    row- or column-wise, or elementwise.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
- en: '[Tablewise Function Application](#tablewise-function-application): [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe")'
  id: totrans-787
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Row or Column-wise Function Application](#row-or-column-wise-function-application):
    [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply")'
  id: totrans-788
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Aggregation API](#aggregation-api): [`agg()`](../reference/api/pandas.DataFrame.agg.html#pandas.DataFrame.agg
    "pandas.DataFrame.agg") and [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform")'
  id: totrans-789
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[Applying Elementwise Functions](#applying-elementwise-functions): [`map()`](../reference/api/pandas.DataFrame.map.html#pandas.DataFrame.map
    "pandas.DataFrame.map")'
  id: totrans-790
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '### Tablewise function application'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrames` and `Series` can be passed into functions. However, if the function
    needs to be called in a chain, consider using the [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe") method.'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
- en: 'First some setup:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '`extract_city_name` and `add_country_name` are functions taking and returning
    `DataFrames`.'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
- en: 'Now compare the following:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Is equivalent to:'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  id: totrans-799
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: pandas encourages the second style, which is known as method chaining. `pipe`
    makes it easy to use your own or another library’s functions in method chains,
    alongside pandas’ methods.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, the functions `extract_city_name` and `add_country_name`
    each expected a `DataFrame` as the first positional argument. What if the function
    you wish to apply takes its data as, say, the second argument? In this case, provide
    `pipe` with a tuple of `(callable, data_keyword)`. `.pipe` will route the `DataFrame`
    to the argument specified in the tuple.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can fit a regression using statsmodels. Their API expects a
    formula first and a `DataFrame` as the second argument, `data`. We pass in the
    function, keyword pair `(sm.ols, ''data'')` to `pipe`:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: The pipe method is inspired by unix pipes and more recently [dplyr](https://github.com/tidyverse/dplyr)
    and [magrittr](https://github.com/tidyverse/magrittr), which have introduced the
    popular `(%>%)` (read pipe) operator for [R](https://www.r-project.org). The implementation
    of `pipe` here is quite clean and feels right at home in Python. We encourage
    you to view the source code of [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe").
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
- en: Row or column-wise function application
  id: totrans-805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arbitrary functions can be applied along the axes of a DataFrame using the
    [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method, which, like the descriptive statistics methods,
    takes an optional `axis` argument:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: The [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method will also dispatch on a string method name.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  id: totrans-809
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'The return type of the function passed to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") affects the type of the final output from `DataFrame.apply`
    for the default behaviour:'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
- en: If the applied function returns a `Series`, the final output is a `DataFrame`.
    The columns match the index of the `Series` returned by the applied function.
  id: totrans-811
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the applied function returns any other type, the final output is a `Series`.
  id: totrans-812
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This default behaviour can be overridden using the `result_type`, which accepts
    three options: `reduce`, `broadcast`, and `expand`. These will determine how list-likes
    return values expand (or not) to a `DataFrame`.'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
- en: '[`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") combined with some cleverness can be used to answer
    many questions about a data set. For example, suppose we wanted to extract the
    date where the maximum value for each column occurred:'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  id: totrans-815
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: You may also pass additional arguments and keyword arguments to the [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  id: totrans-817
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'Another useful feature is the ability to pass Series methods to carry out some
    Series operation on each column or row:'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  id: totrans-819
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Finally, [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") takes an argument `raw` which is False by default, which
    converts each row or column into a Series before applying the function. When set
    to True, the passed function will instead receive an ndarray object, which has
    positive performance implications if you do not need the indexing functionality.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
- en: '### Aggregation API'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
- en: The aggregation API allows one to express possibly multiple aggregation operations
    in a single concise way. This API is similar across pandas objects, see [groupby
    API](groupby.html#groupby-aggregate), the [window API](window.html#window-overview),
    and the [resample API](timeseries.html#timeseries-aggregate). The entry point
    for aggregation is [`DataFrame.aggregate()`](../reference/api/pandas.DataFrame.aggregate.html#pandas.DataFrame.aggregate
    "pandas.DataFrame.aggregate"), or the alias [`DataFrame.agg()`](../reference/api/pandas.DataFrame.agg.html#pandas.DataFrame.agg
    "pandas.DataFrame.agg").
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a similar starting frame from above:'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  id: totrans-824
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: 'Using a single function is equivalent to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"). You can also pass named methods as strings. These will
    return a `Series` of the aggregated output:'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  id: totrans-826
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Single aggregations on a `Series` this will return a scalar value:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: Aggregating with multiple functions
  id: totrans-829
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can pass multiple aggregation arguments as a list. The results of each of
    the passed functions will be a row in the resulting `DataFrame`. These are naturally
    named from the aggregation function.
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  id: totrans-831
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'Multiple functions yield multiple rows:'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  id: totrans-833
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'On a `Series`, multiple functions return a `Series`, indexed by the function
    names:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Passing a `lambda` function will yield a `<lambda>` named row:'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  id: totrans-837
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'Passing a named function will yield that name for the row:'
  id: totrans-838
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  id: totrans-839
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: Aggregating with a dict
  id: totrans-840
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dictionary of column names to a scalar or a list of scalars, to `DataFrame.agg`
    allows you to customize which functions are applied to which columns. Note that
    the results are not in any particular order, you can use an `OrderedDict` instead
    to guarantee ordering.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'Passing a list-like will generate a `DataFrame` output. You will get a matrix-like
    output of all of the aggregators. The output will consist of all unique functions.
    Those that are not noted for a particular column will be `NaN`:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '#### Custom describe'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
- en: With `.agg()` it is possible to easily create a custom describe function, similar
    to the built in [describe function](#basics-describe).
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]  ### Transform API'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
- en: The [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") method returns an object that is indexed the same
    (same size) as the original. This API allows you to provide *multiple* operations
    at the same time rather than one-by-one. Its API is quite similar to the `.agg`
    API.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
- en: We create a frame similar to the one used in the above sections.
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: 'Transform the entire frame. `.transform()` allows input functions as: a NumPy
    function, a string function name or a user defined function.'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: Here [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") received a single function; this is equivalent to
    a [ufunc](https://numpy.org/doc/stable/reference/ufuncs.html) application.
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: Passing a single function to `.transform()` with a `Series` will yield a single
    `Series` in return.
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  id: totrans-856
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: Transform with multiple functions
  id: totrans-857
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing multiple functions will yield a column MultiIndexed DataFrame. The first
    level will be the original frame column names; the second level will be the names
    of the transforming functions.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: Passing multiple functions to a Series will yield a DataFrame. The resulting
    column names will be the transforming functions.
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  id: totrans-861
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Transforming with a dict
  id: totrans-862
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dict of functions will allow selective transforming per column.
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: Passing a dict of lists will generate a MultiIndexed DataFrame with these selective
    transforms.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]  ### Applying elementwise functions'
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
- en: 'Since not all functions can be vectorized (accept NumPy arrays and return another
    array or value), the methods [`map()`](../reference/api/pandas.DataFrame.map.html#pandas.DataFrame.map
    "pandas.DataFrame.map") on DataFrame and analogously [`map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") on Series accept any Python function taking a single value
    and returning a single value. For example:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[`Series.map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") has an additional feature; it can be used to easily “link”
    or “map” values defined by a secondary series. This is closely related to [merging/joining
    functionality](merging.html#merging):'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]  ### Tablewise function application'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
- en: '`DataFrames` and `Series` can be passed into functions. However, if the function
    needs to be called in a chain, consider using the [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe") method.'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
- en: 'First some setup:'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  id: totrans-873
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '`extract_city_name` and `add_country_name` are functions taking and returning
    `DataFrames`.'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
- en: 'Now compare the following:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'Is equivalent to:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: pandas encourages the second style, which is known as method chaining. `pipe`
    makes it easy to use your own or another library’s functions in method chains,
    alongside pandas’ methods.
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, the functions `extract_city_name` and `add_country_name`
    each expected a `DataFrame` as the first positional argument. What if the function
    you wish to apply takes its data as, say, the second argument? In this case, provide
    `pipe` with a tuple of `(callable, data_keyword)`. `.pipe` will route the `DataFrame`
    to the argument specified in the tuple.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can fit a regression using statsmodels. Their API expects a
    formula first and a `DataFrame` as the second argument, `data`. We pass in the
    function, keyword pair `(sm.ols, ''data'')` to `pipe`:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: The pipe method is inspired by unix pipes and more recently [dplyr](https://github.com/tidyverse/dplyr)
    and [magrittr](https://github.com/tidyverse/magrittr), which have introduced the
    popular `(%>%)` (read pipe) operator for [R](https://www.r-project.org). The implementation
    of `pipe` here is quite clean and feels right at home in Python. We encourage
    you to view the source code of [`pipe()`](../reference/api/pandas.DataFrame.pipe.html#pandas.DataFrame.pipe
    "pandas.DataFrame.pipe").
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
- en: Row or column-wise function application
  id: totrans-884
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Arbitrary functions can be applied along the axes of a DataFrame using the
    [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method, which, like the descriptive statistics methods,
    takes an optional `axis` argument:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: The [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method will also dispatch on a string method name.
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'The return type of the function passed to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") affects the type of the final output from `DataFrame.apply`
    for the default behaviour:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
- en: If the applied function returns a `Series`, the final output is a `DataFrame`.
    The columns match the index of the `Series` returned by the applied function.
  id: totrans-890
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the applied function returns any other type, the final output is a `Series`.
  id: totrans-891
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This default behaviour can be overridden using the `result_type`, which accepts
    three options: `reduce`, `broadcast`, and `expand`. These will determine how list-likes
    return values expand (or not) to a `DataFrame`.'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
- en: '[`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") combined with some cleverness can be used to answer
    many questions about a data set. For example, suppose we wanted to extract the
    date where the maximum value for each column occurred:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  id: totrans-894
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: You may also pass additional arguments and keyword arguments to the [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") method.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  id: totrans-896
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'Another useful feature is the ability to pass Series methods to carry out some
    Series operation on each column or row:'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  id: totrans-898
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: Finally, [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") takes an argument `raw` which is False by default, which
    converts each row or column into a Series before applying the function. When set
    to True, the passed function will instead receive an ndarray object, which has
    positive performance implications if you do not need the indexing functionality.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
- en: '### Aggregation API'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
- en: The aggregation API allows one to express possibly multiple aggregation operations
    in a single concise way. This API is similar across pandas objects, see [groupby
    API](groupby.html#groupby-aggregate), the [window API](window.html#window-overview),
    and the [resample API](timeseries.html#timeseries-aggregate). The entry point
    for aggregation is [`DataFrame.aggregate()`](../reference/api/pandas.DataFrame.aggregate.html#pandas.DataFrame.aggregate
    "pandas.DataFrame.aggregate"), or the alias [`DataFrame.agg()`](../reference/api/pandas.DataFrame.agg.html#pandas.DataFrame.agg
    "pandas.DataFrame.agg").
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use a similar starting frame from above:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'Using a single function is equivalent to [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"). You can also pass named methods as strings. These will
    return a `Series` of the aggregated output:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'Single aggregations on a `Series` this will return a scalar value:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Aggregating with multiple functions
  id: totrans-908
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can pass multiple aggregation arguments as a list. The results of each of
    the passed functions will be a row in the resulting `DataFrame`. These are naturally
    named from the aggregation function.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'Multiple functions yield multiple rows:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'On a `Series`, multiple functions return a `Series`, indexed by the function
    names:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'Passing a `lambda` function will yield a `<lambda>` named row:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'Passing a named function will yield that name for the row:'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  id: totrans-918
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: Aggregating with a dict
  id: totrans-919
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dictionary of column names to a scalar or a list of scalars, to `DataFrame.agg`
    allows you to customize which functions are applied to which columns. Note that
    the results are not in any particular order, you can use an `OrderedDict` instead
    to guarantee ordering.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'Passing a list-like will generate a `DataFrame` output. You will get a matrix-like
    output of all of the aggregators. The output will consist of all unique functions.
    Those that are not noted for a particular column will be `NaN`:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '#### Custom describe'
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
- en: With `.agg()` it is possible to easily create a custom describe function, similar
    to the built in [describe function](#basics-describe).
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: Aggregating with multiple functions
  id: totrans-927
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: You can pass multiple aggregation arguments as a list. The results of each of
    the passed functions will be a row in the resulting `DataFrame`. These are naturally
    named from the aggregation function.
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'Multiple functions yield multiple rows:'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  id: totrans-931
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'On a `Series`, multiple functions return a `Series`, indexed by the function
    names:'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  id: totrans-933
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'Passing a `lambda` function will yield a `<lambda>` named row:'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'Passing a named function will yield that name for the row:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: Aggregating with a dict
  id: totrans-938
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dictionary of column names to a scalar or a list of scalars, to `DataFrame.agg`
    allows you to customize which functions are applied to which columns. Note that
    the results are not in any particular order, you can use an `OrderedDict` instead
    to guarantee ordering.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  id: totrans-940
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'Passing a list-like will generate a `DataFrame` output. You will get a matrix-like
    output of all of the aggregators. The output will consist of all unique functions.
    Those that are not noted for a particular column will be `NaN`:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '#### Custom describe'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
- en: With `.agg()` it is possible to easily create a custom describe function, similar
    to the built in [describe function](#basics-describe).
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '### Transform API'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
- en: The [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") method returns an object that is indexed the same
    (same size) as the original. This API allows you to provide *multiple* operations
    at the same time rather than one-by-one. Its API is quite similar to the `.agg`
    API.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
- en: We create a frame similar to the one used in the above sections.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  id: totrans-949
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'Transform the entire frame. `.transform()` allows input functions as: a NumPy
    function, a string function name or a user defined function.'
  id: totrans-950
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  id: totrans-951
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: Here [`transform()`](../reference/api/pandas.DataFrame.transform.html#pandas.DataFrame.transform
    "pandas.DataFrame.transform") received a single function; this is equivalent to
    a [ufunc](https://numpy.org/doc/stable/reference/ufuncs.html) application.
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  id: totrans-953
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: Passing a single function to `.transform()` with a `Series` will yield a single
    `Series` in return.
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  id: totrans-955
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: Transform with multiple functions
  id: totrans-956
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing multiple functions will yield a column MultiIndexed DataFrame. The first
    level will be the original frame column names; the second level will be the names
    of the transforming functions.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: Passing multiple functions to a Series will yield a DataFrame. The resulting
    column names will be the transforming functions.
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: Transforming with a dict
  id: totrans-961
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dict of functions will allow selective transforming per column.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  id: totrans-963
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: Passing a dict of lists will generate a MultiIndexed DataFrame with these selective
    transforms.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: Transform with multiple functions
  id: totrans-966
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing multiple functions will yield a column MultiIndexed DataFrame. The first
    level will be the original frame column names; the second level will be the names
    of the transforming functions.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  id: totrans-968
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: Passing multiple functions to a Series will yield a DataFrame. The resulting
    column names will be the transforming functions.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  id: totrans-970
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: Transforming with a dict
  id: totrans-971
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Passing a dict of functions will allow selective transforming per column.
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: Passing a dict of lists will generate a MultiIndexed DataFrame with these selective
    transforms.
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: '### Applying elementwise functions'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
- en: 'Since not all functions can be vectorized (accept NumPy arrays and return another
    array or value), the methods [`map()`](../reference/api/pandas.DataFrame.map.html#pandas.DataFrame.map
    "pandas.DataFrame.map") on DataFrame and analogously [`map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") on Series accept any Python function taking a single value
    and returning a single value. For example:'
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  id: totrans-978
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: '[`Series.map()`](../reference/api/pandas.Series.map.html#pandas.Series.map
    "pandas.Series.map") has an additional feature; it can be used to easily “link”
    or “map” values defined by a secondary series. This is closely related to [merging/joining
    functionality](merging.html#merging):'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  id: totrans-980
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: '## Reindexing and altering labels'
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") is the fundamental data alignment method in pandas. It
    is used to implement nearly all other features relying on label-alignment functionality.
    To *reindex* means to conform the data to match a given set of labels along a
    particular axis. This accomplishes several things:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
- en: Reorders the existing data to match a new set of labels
  id: totrans-983
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserts missing value (NA) markers in label locations where no data for that
    label existed
  id: totrans-984
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If specified, **fill** data for missing labels using logic (highly relevant
    to working with time series data)
  id: totrans-985
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a simple example:'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  id: totrans-987
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: Here, the `f` label was not contained in the Series and hence appears as `NaN`
    in the result.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
- en: 'With a DataFrame, you can simultaneously reindex the index and columns:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'Note that the `Index` objects containing the actual axis labels can be **shared**
    between objects. So if we have a Series and a DataFrame, the following can be
    done:'
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  id: totrans-992
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: This means that the reindexed Series’s index is the same Python object as the
    DataFrame’s index.
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.reindex()`](../reference/api/pandas.DataFrame.reindex.html#pandas.DataFrame.reindex
    "pandas.DataFrame.reindex") also supports an “axis-style” calling convention,
    where you specify a single `labels` argument and the `axis` it applies to.'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: See also
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
- en: '[MultiIndex / Advanced Indexing](advanced.html#advanced) is an even more concise
    way of doing reindexing.'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
- en: 'When writing performance-sensitive code, there is a good reason to spend some
    time becoming a reindexing ninja: **many operations are faster on pre-aligned
    data**. Adding two unaligned DataFrames internally triggers a reindexing step.
    For exploratory analysis you will hardly notice the difference (because `reindex`
    has been heavily optimized), but when CPU cycles matter sprinkling a few explicit
    `reindex` calls here and there can have an impact.'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
- en: '### Reindexing to align with another object'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wish to take an object and reindex its axes to be labeled the same
    as another object. While the syntax for this is straightforward albeit verbose,
    it is a common enough operation that the [`reindex_like()`](../reference/api/pandas.DataFrame.reindex_like.html#pandas.DataFrame.reindex_like
    "pandas.DataFrame.reindex_like") method is available to make this simpler:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]  ### Aligning objects with each other with `align`'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`align()`](../reference/api/pandas.Series.align.html#pandas.Series.align
    "pandas.Series.align") method is the fastest way to simultaneously align two objects.
    It supports a `join` argument (related to [joining and merging](merging.html#merging)):'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
- en: '`join=''outer''`: take the union of the indexes (default)'
  id: totrans-1004
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1005
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1006
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''left''`: use the calling object’s index'
  id: totrans-1007
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1008
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1009
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''right''`: use the passed object’s index'
  id: totrans-1010
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1011
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1012
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''inner''`: intersect the indexes'
  id: totrans-1013
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It returns a tuple with both of the reindexed Series:'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  id: totrans-1015
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'For DataFrames, the join method will be applied to both the index and the columns
    by default:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'You can also pass an `axis` option to only align on the specified axis:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: 'If you pass a Series to [`DataFrame.align()`](../reference/api/pandas.DataFrame.align.html#pandas.DataFrame.align
    "pandas.DataFrame.align"), you can choose to align both objects either on the
    DataFrame’s index or columns using the `axis` argument:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]  ### Filling while reindexing'
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") takes an optional parameter `method` which is a filling
    method chosen from the following table:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Action |'
  id: totrans-1023
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1024
  prefs: []
  type: TYPE_TB
- en: '| pad / ffill | Fill values forward |'
  id: totrans-1025
  prefs: []
  type: TYPE_TB
- en: '| bfill / backfill | Fill values backward |'
  id: totrans-1026
  prefs: []
  type: TYPE_TB
- en: '| nearest | Fill from the nearest index value |'
  id: totrans-1027
  prefs: []
  type: TYPE_TB
- en: 'We illustrate these fill methods on a simple Series:'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  id: totrans-1029
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: These methods require that the indexes are **ordered** increasing or decreasing.
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the same result could have been achieved using [ffill](missing_data.html#missing-data-fillna)
    (except for `method=''nearest''`) or [interpolate](missing_data.html#missing-data-interpolate):'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") will raise a ValueError if the index is not monotonically
    increasing or decreasing. [`fillna()`](../reference/api/pandas.Series.fillna.html#pandas.Series.fillna
    "pandas.Series.fillna") and [`interpolate()`](../reference/api/pandas.Series.interpolate.html#pandas.Series.interpolate
    "pandas.Series.interpolate") will not perform any checks on the order of the index.  ###
    Limits on filling while reindexing'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
- en: 'The `limit` and `tolerance` arguments provide additional control over filling
    while reindexing. Limit specifies the maximum count of consecutive matches:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'In contrast, tolerance specifies the maximum distance between the index and
    indexer values:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'Notice that when used on a `DatetimeIndex`, `TimedeltaIndex` or `PeriodIndex`,
    `tolerance` will coerced into a `Timedelta` if possible. This allows you to specify
    tolerance with appropriate strings.  ### Dropping labels from an axis'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
- en: 'A method closely related to `reindex` is the [`drop()`](../reference/api/pandas.DataFrame.drop.html#pandas.DataFrame.drop
    "pandas.DataFrame.drop") function. It removes a set of labels from an axis:'
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  id: totrans-1040
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Note that the following also works, but is a bit less obvious / clean:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]  ### Renaming / mapping labels'
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
- en: The [`rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") method allows you to relabel an axis based on some
    mapping (a dict or Series) or an arbitrary function.
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'If you pass a function, it must return a value when called with any of the
    labels (and must produce a set of unique values). A dict or Series can also be
    used:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: If the mapping doesn’t include a column/index label, it isn’t renamed. Note
    that extra labels in the mapping don’t throw an error.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") also supports an “axis-style” calling convention, where
    you specify a single `mapper` and the `axis` to apply that mapping to.'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  id: totrans-1049
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: Finally, [`rename()`](../reference/api/pandas.Series.rename.html#pandas.Series.rename
    "pandas.Series.rename") also accepts a scalar or list-like for altering the `Series.name`
    attribute.
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: The methods [`DataFrame.rename_axis()`](../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis
    "pandas.DataFrame.rename_axis") and [`Series.rename_axis()`](../reference/api/pandas.Series.rename_axis.html#pandas.Series.rename_axis
    "pandas.Series.rename_axis") allow specific names of a `MultiIndex` to be changed
    (as opposed to the labels).
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]  ### Reindexing to align with another object'
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
- en: 'You may wish to take an object and reindex its axes to be labeled the same
    as another object. While the syntax for this is straightforward albeit verbose,
    it is a common enough operation that the [`reindex_like()`](../reference/api/pandas.DataFrame.reindex_like.html#pandas.DataFrame.reindex_like
    "pandas.DataFrame.reindex_like") method is available to make this simpler:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: '### Aligning objects with each other with `align`'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`align()`](../reference/api/pandas.Series.align.html#pandas.Series.align
    "pandas.Series.align") method is the fastest way to simultaneously align two objects.
    It supports a `join` argument (related to [joining and merging](merging.html#merging)):'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
- en: '`join=''outer''`: take the union of the indexes (default)'
  id: totrans-1058
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1059
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1060
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''left''`: use the calling object’s index'
  id: totrans-1061
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1062
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1063
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''right''`: use the passed object’s index'
  id: totrans-1064
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-1065
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-1066
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`join=''inner''`: intersect the indexes'
  id: totrans-1067
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It returns a tuple with both of the reindexed Series:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'For DataFrames, the join method will be applied to both the index and the columns
    by default:'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'You can also pass an `axis` option to only align on the specified axis:'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'If you pass a Series to [`DataFrame.align()`](../reference/api/pandas.DataFrame.align.html#pandas.DataFrame.align
    "pandas.DataFrame.align"), you can choose to align both objects either on the
    DataFrame’s index or columns using the `axis` argument:'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  id: totrans-1075
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: '### Filling while reindexing'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") takes an optional parameter `method` which is a filling
    method chosen from the following table:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Action |'
  id: totrans-1078
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-1079
  prefs: []
  type: TYPE_TB
- en: '| pad / ffill | Fill values forward |'
  id: totrans-1080
  prefs: []
  type: TYPE_TB
- en: '| bfill / backfill | Fill values backward |'
  id: totrans-1081
  prefs: []
  type: TYPE_TB
- en: '| nearest | Fill from the nearest index value |'
  id: totrans-1082
  prefs: []
  type: TYPE_TB
- en: 'We illustrate these fill methods on a simple Series:'
  id: totrans-1083
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  id: totrans-1084
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: These methods require that the indexes are **ordered** increasing or decreasing.
  id: totrans-1085
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the same result could have been achieved using [ffill](missing_data.html#missing-data-fillna)
    (except for `method=''nearest''`) or [interpolate](missing_data.html#missing-data-interpolate):'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: '[`reindex()`](../reference/api/pandas.Series.reindex.html#pandas.Series.reindex
    "pandas.Series.reindex") will raise a ValueError if the index is not monotonically
    increasing or decreasing. [`fillna()`](../reference/api/pandas.Series.fillna.html#pandas.Series.fillna
    "pandas.Series.fillna") and [`interpolate()`](../reference/api/pandas.Series.interpolate.html#pandas.Series.interpolate
    "pandas.Series.interpolate") will not perform any checks on the order of the index.'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
- en: '### Limits on filling while reindexing'
  id: totrans-1089
  prefs: []
  type: TYPE_NORMAL
- en: 'The `limit` and `tolerance` arguments provide additional control over filling
    while reindexing. Limit specifies the maximum count of consecutive matches:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: 'In contrast, tolerance specifies the maximum distance between the index and
    indexer values:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: Notice that when used on a `DatetimeIndex`, `TimedeltaIndex` or `PeriodIndex`,
    `tolerance` will coerced into a `Timedelta` if possible. This allows you to specify
    tolerance with appropriate strings.
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
- en: '### Dropping labels from an axis'
  id: totrans-1095
  prefs: []
  type: TYPE_NORMAL
- en: 'A method closely related to `reindex` is the [`drop()`](../reference/api/pandas.DataFrame.drop.html#pandas.DataFrame.drop
    "pandas.DataFrame.drop") function. It removes a set of labels from an axis:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: 'Note that the following also works, but is a bit less obvious / clean:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: '### Renaming / mapping labels'
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
- en: The [`rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") method allows you to relabel an axis based on some
    mapping (a dict or Series) or an arbitrary function.
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: 'If you pass a function, it must return a value when called with any of the
    labels (and must produce a set of unique values). A dict or Series can also be
    used:'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  id: totrans-1104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: If the mapping doesn’t include a column/index label, it isn’t renamed. Note
    that extra labels in the mapping don’t throw an error.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
- en: '[`DataFrame.rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename") also supports an “axis-style” calling convention, where
    you specify a single `mapper` and the `axis` to apply that mapping to.'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: Finally, [`rename()`](../reference/api/pandas.Series.rename.html#pandas.Series.rename
    "pandas.Series.rename") also accepts a scalar or list-like for altering the `Series.name`
    attribute.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  id: totrans-1109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: The methods [`DataFrame.rename_axis()`](../reference/api/pandas.DataFrame.rename_axis.html#pandas.DataFrame.rename_axis
    "pandas.DataFrame.rename_axis") and [`Series.rename_axis()`](../reference/api/pandas.Series.rename_axis.html#pandas.Series.rename_axis
    "pandas.Series.rename_axis") allow specific names of a `MultiIndex` to be changed
    (as opposed to the labels).
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  id: totrans-1111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '## Iteration'
  id: totrans-1112
  prefs: []
  type: TYPE_NORMAL
- en: The behavior of basic iteration over pandas objects depends on the type. When
    iterating over a Series, it is regarded as array-like, and basic iteration produces
    the values. DataFrames follow the dict-like convention of iterating over the “keys”
    of the objects.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
- en: 'In short, basic iteration (`for i in object`) produces:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: values'
  id: totrans-1115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: column labels'
  id: totrans-1116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, for example, iterating over a DataFrame gives you the column names:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: pandas objects also have the dict-like [`items()`](../reference/api/pandas.DataFrame.items.html#pandas.DataFrame.items
    "pandas.DataFrame.items") method to iterate over the (key, value) pairs.
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
- en: 'To iterate over the rows of a DataFrame, you can use the following methods:'
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
- en: '[`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows"): Iterate over the rows of a DataFrame as (index,
    Series) pairs. This converts the rows to Series objects, which can change the
    dtypes and has some performance implications.'
  id: totrans-1121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples"): Iterate over the rows of a DataFrame as namedtuples
    of the values. This is a lot faster than [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows"), and is in most cases preferable to use to iterate
    over the values of a DataFrame.'
  id: totrans-1122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
- en: 'Iterating through pandas objects is generally **slow**. In many cases, iterating
    manually over the rows is not needed and can be avoided with one of the following
    approaches:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
- en: 'Look for a *vectorized* solution: many operations can be performed using built-in
    methods or NumPy functions, (boolean) indexing, …'
  id: totrans-1125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you have a function that cannot work on the full DataFrame/Series at once,
    it is better to use [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply") instead of iterating over the values. See the docs on
    [function application](#basics-apply).
  id: totrans-1126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need to do iterative manipulations on the values but performance is important,
    consider writing the inner loop with cython or numba. See the [enhancing performance](enhancingperf.html#enhancingperf)
    section for some examples of this approach.
  id: totrans-1127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
- en: You should **never modify** something you are iterating over. This is not guaranteed
    to work in all cases. Depending on the data types, the iterator returns a copy
    and not a view, and writing to it will have no effect!
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following case setting the value has no effect:'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  id: totrans-1131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: items
  id: totrans-1132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consistent with the dict-like interface, [`items()`](../reference/api/pandas.DataFrame.items.html#pandas.DataFrame.items
    "pandas.DataFrame.items") iterates through key-value pairs:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: (index, scalar value) pairs'
  id: totrans-1134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: (column, Series) pairs'
  id: totrans-1135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: '### iterrows'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
- en: '[`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") allows you to iterate through the rows of a DataFrame
    as Series objects. It returns an iterator yielding each index value along with
    a Series containing the data in each row:'
  id: totrans-1139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  id: totrans-1140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: Note
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
- en: Because [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") returns a Series for each row, it does **not** preserve
    dtypes across the rows (dtypes are preserved across columns for DataFrames). For
    example,
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  id: totrans-1143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: 'All values in `row`, returned as a Series, are now upcasted to floats, also
    the original integer value in column `x`:'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  id: totrans-1145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: To preserve dtypes while iterating over the rows, it is better to use [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") which returns namedtuples of the values and which
    is generally much faster than [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a contrived way to transpose the DataFrame would be:'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  id: totrans-1148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: itertuples
  id: totrans-1149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") method will return an iterator yielding a namedtuple
    for each row in the DataFrame. The first element of the tuple will be the row’s
    corresponding index value, while the remaining values are the row values.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: This method does not convert the row to a Series object; it merely returns the
    values inside a namedtuple. Therefore, [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") preserves the data type of the values and is generally
    faster as [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
- en: The column names will be renamed to positional names if they are invalid Python
    identifiers, repeated, or start with an underscore. With a large number of columns
    (>255), regular tuples are returned.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
- en: items
  id: totrans-1156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consistent with the dict-like interface, [`items()`](../reference/api/pandas.DataFrame.items.html#pandas.DataFrame.items
    "pandas.DataFrame.items") iterates through key-value pairs:'
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
- en: '**Series**: (index, scalar value) pairs'
  id: totrans-1158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DataFrame**: (column, Series) pairs'
  id: totrans-1159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE358]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: '### iterrows'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
- en: '[`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") allows you to iterate through the rows of a DataFrame
    as Series objects. It returns an iterator yielding each index value along with
    a Series containing the data in each row:'
  id: totrans-1163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  id: totrans-1164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: Note
  id: totrans-1165
  prefs: []
  type: TYPE_NORMAL
- en: Because [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows") returns a Series for each row, it does **not** preserve
    dtypes across the rows (dtypes are preserved across columns for DataFrames). For
    example,
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: 'All values in `row`, returned as a Series, are now upcasted to floats, also
    the original integer value in column `x`:'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  id: totrans-1169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: To preserve dtypes while iterating over the rows, it is better to use [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") which returns namedtuples of the values and which
    is generally much faster than [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, a contrived way to transpose the DataFrame would be:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: itertuples
  id: totrans-1173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") method will return an iterator yielding a namedtuple
    for each row in the DataFrame. The first element of the tuple will be the row’s
    corresponding index value, while the remaining values are the row values.
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance:'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  id: totrans-1176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: This method does not convert the row to a Series object; it merely returns the
    values inside a namedtuple. Therefore, [`itertuples()`](../reference/api/pandas.DataFrame.itertuples.html#pandas.DataFrame.itertuples
    "pandas.DataFrame.itertuples") preserves the data type of the values and is generally
    faster as [`iterrows()`](../reference/api/pandas.DataFrame.iterrows.html#pandas.DataFrame.iterrows
    "pandas.DataFrame.iterrows").
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
- en: The column names will be renamed to positional names if they are invalid Python
    identifiers, repeated, or start with an underscore. With a large number of columns
    (>255), regular tuples are returned.
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
- en: '## .dt accessor'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` has an accessor to succinctly return datetime like properties for
    the *values* of the Series, if it is a datetime/period like Series. This will
    return a Series, indexed like the existing Series.'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'This enables nice expressions like this:'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE365]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'You can easily produces tz aware transformations:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE366]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: 'You can also chain these types of operations:'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: You can also format datetime values as strings with [`Series.dt.strftime()`](../reference/api/pandas.Series.dt.strftime.html#pandas.Series.dt.strftime
    "pandas.Series.dt.strftime") which supports the same format as the standard [`strftime()`](https://docs.python.org/3/library/datetime.html#datetime.datetime.strftime
    "(in Python v3.12)").
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: '[PRE369]'
  id: totrans-1191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: The `.dt` accessor works for period and timedelta dtypes.
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  id: totrans-1193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[PRE371]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: Note
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
- en: '`Series.dt` will raise a `TypeError` if you access with a non-datetime-like
    values.'
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
- en: Vectorized string methods
  id: totrans-1197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Series is equipped with a set of string processing methods that make it easy
    to operate on each element of the array. Perhaps most importantly, these methods
    exclude missing/NA values automatically. These are accessed via the Series’s `str`
    attribute and generally have names matching the equivalent (scalar) built-in string
    methods. For example:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  id: totrans-1199
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE372]'
- en: Powerful pattern-matching methods are provided as well, but note that pattern-matching
    generally uses [regular expressions](https://docs.python.org/3/library/re.html)
    by default (and in some cases always uses them).
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
- en: Prior to pandas 1.0, string methods were only available on `object` -dtype `Series`.
    pandas 1.0 added the [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype") which is dedicated to strings. See [Text data types](text.html#text-types)
    for more.
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
- en: Please see [Vectorized String Methods](text.html#text-string-methods) for a
    complete description.
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
- en: '## Sorting'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
- en: 'pandas supports three kinds of sorting: sorting by index labels, sorting by
    column values, and sorting by a combination of both.'
  id: totrans-1205
  prefs: []
  type: TYPE_NORMAL
- en: '### By index'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_index()`](../reference/api/pandas.Series.sort_index.html#pandas.Series.sort_index
    "pandas.Series.sort_index") and [`DataFrame.sort_index()`](../reference/api/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index
    "pandas.DataFrame.sort_index") methods are used to sort a pandas object by its
    index levels.
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  id: totrans-1208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: Sorting by index also supports a `key` parameter that takes a callable function
    to apply to the index being sorted. For `MultiIndex` objects, the key is applied
    per-level to the levels specified by `level`.
  id: totrans-1209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  id: totrans-1210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: '[PRE375]'
  id: totrans-1211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: 'For information on key sorting by value, see [value sorting](#basics-sort-value-key).  ###
    By values'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_values()`](../reference/api/pandas.Series.sort_values.html#pandas.Series.sort_values
    "pandas.Series.sort_values") method is used to sort a `Series` by its values.
    The [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") method is used to sort a `DataFrame` by its column
    or row values. The optional `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may used to specify one or more columns to use
    to determine the sorted order.
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'The `by` parameter can take a list of column names, e.g.:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: 'These methods have special treatment of NA values via the `na_position` argument:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: Sorting also supports a `key` parameter that takes a callable function to apply
    to the values being sorted.
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[PRE380]'
  id: totrans-1221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: '`key` will be given the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") of values and should return a `Series` or array of the same shape
    with the transformed values. For `DataFrame` objects, the key is applied per column,
    so the key should still expect a Series and return a Series, e.g.'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: '[PRE382]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'The name or type of each column can be used to apply different functions to
    different columns.  ### By indexes and values'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
- en: Strings passed as the `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may refer to either columns or index level names.
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: Sort by ‘second’ (index) and ‘A’ (column)
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: Note
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
- en: 'If a string matches both a column name and an index level name then a warning
    is issued and the column takes precedence. This will result in an ambiguity error
    in a future version.  ### searchsorted'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
- en: Series has the [`searchsorted()`](../reference/api/pandas.Series.searchsorted.html#pandas.Series.searchsorted
    "pandas.Series.searchsorted") method, which works similarly to [`numpy.ndarray.searchsorted()`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "(in NumPy v1.26)").
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]  ### smallest / largest values'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` has the [`nsmallest()`](../reference/api/pandas.Series.nsmallest.html#pandas.Series.nsmallest
    "pandas.Series.nsmallest") and [`nlargest()`](../reference/api/pandas.Series.nlargest.html#pandas.Series.nlargest
    "pandas.Series.nlargest") methods which return the smallest or largest \(n\) values.
    For a large `Series` this can be much faster than sorting the entire Series and
    calling `head(n)` on the result.'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  id: totrans-1235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: '`DataFrame` also has the `nlargest` and `nsmallest` methods.'
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]  ### Sorting by a MultiIndex column'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
- en: You must be explicit about sorting when the column is a MultiIndex, and fully
    specify all levels to `by`.
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]  ### By index'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_index()`](../reference/api/pandas.Series.sort_index.html#pandas.Series.sort_index
    "pandas.Series.sort_index") and [`DataFrame.sort_index()`](../reference/api/pandas.DataFrame.sort_index.html#pandas.DataFrame.sort_index
    "pandas.DataFrame.sort_index") methods are used to sort a pandas object by its
    index levels.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  id: totrans-1241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: Sorting by index also supports a `key` parameter that takes a callable function
    to apply to the index being sorted. For `MultiIndex` objects, the key is applied
    per-level to the levels specified by `level`.
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  id: totrans-1243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: '[PRE391]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: For information on key sorting by value, see [value sorting](#basics-sort-value-key).
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
- en: '### By values'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
- en: The [`Series.sort_values()`](../reference/api/pandas.Series.sort_values.html#pandas.Series.sort_values
    "pandas.Series.sort_values") method is used to sort a `Series` by its values.
    The [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") method is used to sort a `DataFrame` by its column
    or row values. The optional `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may used to specify one or more columns to use
    to determine the sorted order.
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: 'The `by` parameter can take a list of column names, e.g.:'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: 'These methods have special treatment of NA values via the `na_position` argument:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: Sorting also supports a `key` parameter that takes a callable function to apply
    to the values being sorted.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  id: totrans-1254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '`key` will be given the [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") of values and should return a `Series` or array of the same shape
    with the transformed values. For `DataFrame` objects, the key is applied per column,
    so the key should still expect a Series and return a Series, e.g.'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: '[PRE398]'
  id: totrans-1258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: The name or type of each column can be used to apply different functions to
    different columns.
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
- en: '### By indexes and values'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
- en: Strings passed as the `by` parameter to [`DataFrame.sort_values()`](../reference/api/pandas.DataFrame.sort_values.html#pandas.DataFrame.sort_values
    "pandas.DataFrame.sort_values") may refer to either columns or index level names.
  id: totrans-1261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  id: totrans-1262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Sort by ‘second’ (index) and ‘A’ (column)
  id: totrans-1263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  id: totrans-1264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: Note
  id: totrans-1265
  prefs: []
  type: TYPE_NORMAL
- en: If a string matches both a column name and an index level name then a warning
    is issued and the column takes precedence. This will result in an ambiguity error
    in a future version.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
- en: '### searchsorted'
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
- en: Series has the [`searchsorted()`](../reference/api/pandas.Series.searchsorted.html#pandas.Series.searchsorted
    "pandas.Series.searchsorted") method, which works similarly to [`numpy.ndarray.searchsorted()`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.searchsorted.html#numpy.ndarray.searchsorted
    "(in NumPy v1.26)").
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE401]'
- en: '### smallest / largest values'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
- en: '`Series` has the [`nsmallest()`](../reference/api/pandas.Series.nsmallest.html#pandas.Series.nsmallest
    "pandas.Series.nsmallest") and [`nlargest()`](../reference/api/pandas.Series.nlargest.html#pandas.Series.nlargest
    "pandas.Series.nlargest") methods which return the smallest or largest \(n\) values.
    For a large `Series` this can be much faster than sorting the entire Series and
    calling `head(n)` on the result.'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE402]'
- en: '`DataFrame` also has the `nlargest` and `nsmallest` methods.'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE403]'
- en: '### Sorting by a MultiIndex column'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
- en: You must be explicit about sorting when the column is a MultiIndex, and fully
    specify all levels to `by`.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE404]'
- en: Copying
  id: totrans-1278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`copy()`](../reference/api/pandas.DataFrame.copy.html#pandas.DataFrame.copy
    "pandas.DataFrame.copy") method on pandas objects copies the underlying data (though
    not the axis indexes, since they are immutable) and returns a new object. Note
    that **it is seldom necessary to copy objects**. For example, there are only a
    handful of ways to alter a DataFrame *in-place*:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
- en: Inserting, deleting, or modifying a column.
  id: totrans-1280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning to the `index` or `columns` attributes.
  id: totrans-1281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For homogeneous data, directly modifying the values via the `values` attribute
    or advanced indexing.
  id: totrans-1282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be clear, no pandas method has the side effect of modifying your data; almost
    every method returns a new object, leaving the original object untouched. If the
    data is modified, it is because you did so explicitly.
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
- en: '## dtypes'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, pandas uses NumPy arrays and dtypes for Series or individual
    columns of a DataFrame. NumPy provides support for `float`, `int`, `bool`, `timedelta64[ns]`
    and `datetime64[ns]` (note that NumPy does not support timezone-aware datetimes).
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
- en: pandas and third-party libraries *extend* NumPy’s type system in a few places.
    This section describes the extensions pandas has made internally. See [Extension
    types](../development/extending.html#extending-extension-types) for how to write
    your own extension that works with pandas. See [the ecosystem page](https://pandas.pydata.org/community/ecosystem.html)
    for a list of third-party libraries that have implemented an extension.
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
- en: The following table lists all of pandas extension types. For methods requiring
    `dtype` arguments, strings can be specified as indicated. See the respective documentation
    sections for more on each type.
  id: totrans-1287
  prefs: []
  type: TYPE_NORMAL
- en: '| Kind of Data | Data Type | Scalar | Array | String Aliases |'
  id: totrans-1288
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  id: totrans-1289
  prefs: []
  type: TYPE_TB
- en: '| [tz-aware datetime](timeseries.html#timeseries-timezone) | [`DatetimeTZDtype`](../reference/api/pandas.DatetimeTZDtype.html#pandas.DatetimeTZDtype
    "pandas.DatetimeTZDtype") | [`Timestamp`](../reference/api/pandas.Timestamp.html#pandas.Timestamp
    "pandas.Timestamp") | [`arrays.DatetimeArray`](../reference/api/pandas.arrays.DatetimeArray.html#pandas.arrays.DatetimeArray
    "pandas.arrays.DatetimeArray") | `''datetime64[ns, <tz>]''` |'
  id: totrans-1290
  prefs: []
  type: TYPE_TB
- en: '| [Categorical](categorical.html#categorical) | [`CategoricalDtype`](../reference/api/pandas.CategoricalDtype.html#pandas.CategoricalDtype
    "pandas.CategoricalDtype") | (none) | [`Categorical`](../reference/api/pandas.Categorical.html#pandas.Categorical
    "pandas.Categorical") | `''category''` |'
  id: totrans-1291
  prefs: []
  type: TYPE_TB
- en: '| [period (time spans)](timeseries.html#timeseries-periods) | [`PeriodDtype`](../reference/api/pandas.PeriodDtype.html#pandas.PeriodDtype
    "pandas.PeriodDtype") | [`Period`](../reference/api/pandas.Period.html#pandas.Period
    "pandas.Period") | [`arrays.PeriodArray`](../reference/api/pandas.arrays.PeriodArray.html#pandas.arrays.PeriodArray
    "pandas.arrays.PeriodArray") `''Period[<freq>]''` | `''period[<freq>]''`, |'
  id: totrans-1292
  prefs: []
  type: TYPE_TB
- en: '| [sparse](sparse.html#sparse) | [`SparseDtype`](../reference/api/pandas.SparseDtype.html#pandas.SparseDtype
    "pandas.SparseDtype") | (none) | [`arrays.SparseArray`](../reference/api/pandas.arrays.SparseArray.html#pandas.arrays.SparseArray
    "pandas.arrays.SparseArray") | `''Sparse''`, `''Sparse[int]''`, `''Sparse[float]''`
    |'
  id: totrans-1293
  prefs: []
  type: TYPE_TB
- en: '| [intervals](advanced.html#advanced-intervalindex) | [`IntervalDtype`](../reference/api/pandas.IntervalDtype.html#pandas.IntervalDtype
    "pandas.IntervalDtype") | [`Interval`](../reference/api/pandas.Interval.html#pandas.Interval
    "pandas.Interval") | [`arrays.IntervalArray`](../reference/api/pandas.arrays.IntervalArray.html#pandas.arrays.IntervalArray
    "pandas.arrays.IntervalArray") | `''interval''`, `''Interval''`, `''Interval[<numpy_dtype>]''`,
    `''Interval[datetime64[ns, <tz>]]''`, `''Interval[timedelta64[<freq>]]''` |'
  id: totrans-1294
  prefs: []
  type: TYPE_TB
- en: '| [nullable integer](integer_na.html#integer-na) | [`Int64Dtype`](../reference/api/pandas.Int64Dtype.html#pandas.Int64Dtype
    "pandas.Int64Dtype"), … | (none) | [`arrays.IntegerArray`](../reference/api/pandas.arrays.IntegerArray.html#pandas.arrays.IntegerArray
    "pandas.arrays.IntegerArray") | `''Int8''`, `''Int16''`, `''Int32''`, `''Int64''`,
    `''UInt8''`, `''UInt16''`, `''UInt32''`, `''UInt64''` |'
  id: totrans-1295
  prefs: []
  type: TYPE_TB
- en: '| [nullable float](../reference/arrays.html#api-arrays-float-na) | [`Float64Dtype`](../reference/api/pandas.Float64Dtype.html#pandas.Float64Dtype
    "pandas.Float64Dtype"), … | (none) | [`arrays.FloatingArray`](../reference/api/pandas.arrays.FloatingArray.html#pandas.arrays.FloatingArray
    "pandas.arrays.FloatingArray") | `''Float32''`, `''Float64''` |'
  id: totrans-1296
  prefs: []
  type: TYPE_TB
- en: '| [Strings](text.html#text) | [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype") | [`str`](https://docs.python.org/3/library/stdtypes.html#str
    "(in Python v3.12)") | [`arrays.StringArray`](../reference/api/pandas.arrays.StringArray.html#pandas.arrays.StringArray
    "pandas.arrays.StringArray") | `''string''` |'
  id: totrans-1297
  prefs: []
  type: TYPE_TB
- en: '| [Boolean (with NA)](../reference/arrays.html#api-arrays-bool) | [`BooleanDtype`](../reference/api/pandas.BooleanDtype.html#pandas.BooleanDtype
    "pandas.BooleanDtype") | [`bool`](https://docs.python.org/3/library/functions.html#bool
    "(in Python v3.12)") | [`arrays.BooleanArray`](../reference/api/pandas.arrays.BooleanArray.html#pandas.arrays.BooleanArray
    "pandas.arrays.BooleanArray") | `''boolean''` |'
  id: totrans-1298
  prefs: []
  type: TYPE_TB
- en: pandas has two ways to store strings.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
- en: '`object` dtype, which can hold any Python object, including strings.'
  id: totrans-1300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype"), which is dedicated to strings.'
  id: totrans-1301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generally, we recommend using [`StringDtype`](../reference/api/pandas.StringDtype.html#pandas.StringDtype
    "pandas.StringDtype"). See [Text data types](text.html#text-types) for more.
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
- en: Finally, arbitrary objects may be stored using the `object` dtype, but should
    be avoided to the extent possible (for performance and interoperability with other
    libraries and methods. See [object conversion](#basics-object-conversion)).
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
- en: A convenient [`dtypes`](../reference/api/pandas.DataFrame.dtypes.html#pandas.DataFrame.dtypes
    "pandas.DataFrame.dtypes") attribute for DataFrame returns a Series with the data
    type of each column.
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE405]'
- en: On a `Series` object, use the [`dtype`](../reference/api/pandas.Series.dtype.html#pandas.Series.dtype
    "pandas.Series.dtype") attribute.
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE406]'
- en: If a pandas object contains data with multiple dtypes *in a single column*,
    the dtype of the column will be chosen to accommodate all of the data types (`object`
    is the most general).
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE407]'
- en: The number of columns of each type in a `DataFrame` can be found by calling
    `DataFrame.dtypes.value_counts()`.
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE408]'
- en: Numeric dtypes will propagate and can coexist in DataFrames. If a dtype is passed
    (either directly via the `dtype` keyword, a passed `ndarray`, or a passed `Series`),
    then it will be preserved in DataFrame operations. Furthermore, different numeric
    dtypes will **NOT** be combined. The following example will give you a taste.
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  id: totrans-1313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE409]'
- en: defaults
  id: totrans-1314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default integer types are `int64` and float types are `float64`, *regardless*
    of platform (32-bit or 64-bit). The following will all result in `int64` dtypes.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  id: totrans-1316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE410]'
- en: Note that Numpy will choose *platform-dependent* types when creating arrays.
    The following **WILL** result in `int32` on 32-bit platform.
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  id: totrans-1318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE411]'
- en: upcasting
  id: totrans-1319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types can potentially be *upcasted* when combined with other types, meaning
    they are promoted from the current type (e.g. `int` to `float`).
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE412]'
- en: '[`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") will return the *lower-common-denominator* of the
    dtypes, meaning the dtype that can accommodate **ALL** of the types in the resulting
    homogeneous dtyped NumPy array. This can force some *upcasting*.'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE413]'
- en: astype
  id: totrans-1324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") method to explicitly convert dtypes from one to another.
    These will by default return a copy, even if the dtype was unchanged (pass `copy=False`
    to change this behavior). In addition, they will raise an exception if the astype
    operation is invalid.
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting is always according to the **NumPy** rules. If two different dtypes
    are involved in an operation, then the more *general* one will be used as the
    result of the operation.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  id: totrans-1327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE414]'
- en: Convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE415]'
- en: Convert certain columns to a specific dtype by passing a dict to [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  id: totrans-1331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE416]'
- en: Note
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
- en: When trying to convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") and [`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc
    "pandas.DataFrame.loc"), upcasting occurs.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
- en: '[`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc "pandas.DataFrame.loc")
    tries to fit in what we are assigning to the current dtypes, while `[]` will overwrite
    them taking the dtype from the right hand side. Therefore the following piece
    of code produces the unintended result.'
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  id: totrans-1335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE417]'
- en: '### object conversion'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
- en: pandas offers various functions to try to force conversion of types from the
    `object` dtype to other types. In cases where the data is already of the correct
    type, but stored in an `object` array, the [`DataFrame.infer_objects()`](../reference/api/pandas.DataFrame.infer_objects.html#pandas.DataFrame.infer_objects
    "pandas.DataFrame.infer_objects") and [`Series.infer_objects()`](../reference/api/pandas.Series.infer_objects.html#pandas.Series.infer_objects
    "pandas.Series.infer_objects") methods can be used to soft convert to the correct
    type.
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  id: totrans-1338
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE418]'
- en: Because the data was transposed the original inference stored all columns as
    object, which `infer_objects` will correct.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  id: totrans-1340
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE419]'
- en: 'The following functions are available for one dimensional object arrays or
    scalars to perform hard conversion of objects to a specified type:'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") (conversion to numeric dtypes)'
  id: totrans-1342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE420]'
  id: totrans-1343
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE420]'
- en: '[`to_datetime()`](../reference/api/pandas.to_datetime.html#pandas.to_datetime
    "pandas.to_datetime") (conversion to datetime objects)'
  id: totrans-1344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE421]'
  id: totrans-1345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE421]'
- en: '[`to_timedelta()`](../reference/api/pandas.to_timedelta.html#pandas.to_timedelta
    "pandas.to_timedelta") (conversion to timedelta objects)'
  id: totrans-1346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE422]'
  id: totrans-1347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE422]'
- en: 'To force a conversion, we can pass in an `errors` argument, which specifies
    how pandas should deal with elements that cannot be converted to desired dtype
    or object. By default, `errors=''raise''`, meaning that any errors encountered
    will be raised during the conversion process. However, if `errors=''coerce''`,
    these errors will be ignored and pandas will convert problematic elements to `pd.NaT`
    (for datetime and timedelta) or `np.nan` (for numeric). This might be useful if
    you are reading in data which is mostly of the desired dtype (e.g. numeric, datetime),
    but occasionally has non-conforming elements intermixed that you want to represent
    as missing:'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE423]'
- en: 'In addition to object conversion, [`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") provides another argument `downcast`, which gives the option
    of downcasting the newly (or already) numeric data to a smaller dtype, which can
    conserve memory:'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  id: totrans-1351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE424]'
- en: 'As these methods apply only to one-dimensional arrays, lists or scalars; they
    cannot be used directly on multi-dimensional objects such as DataFrames. However,
    with [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"), we can “apply” the function over each column efficiently:'
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  id: totrans-1353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE425]'
- en: gotchas
  id: totrans-1354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performing selection operations on `integer` type data can easily upcast the
    data to `floating`. The dtype of the input data will be preserved in cases where
    `nans` are not introduced. See also [Support for integer NA](gotchas.html#gotchas-intna).
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  id: totrans-1356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE426]'
- en: While float dtypes are unchanged.
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  id: totrans-1358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE427]'
- en: defaults
  id: totrans-1359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default integer types are `int64` and float types are `float64`, *regardless*
    of platform (32-bit or 64-bit). The following will all result in `int64` dtypes.
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE428]'
- en: Note that Numpy will choose *platform-dependent* types when creating arrays.
    The following **WILL** result in `int32` on 32-bit platform.
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE429]'
- en: upcasting
  id: totrans-1364
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Types can potentially be *upcasted* when combined with other types, meaning
    they are promoted from the current type (e.g. `int` to `float`).
  id: totrans-1365
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  id: totrans-1366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE430]'
- en: '[`DataFrame.to_numpy()`](../reference/api/pandas.DataFrame.to_numpy.html#pandas.DataFrame.to_numpy
    "pandas.DataFrame.to_numpy") will return the *lower-common-denominator* of the
    dtypes, meaning the dtype that can accommodate **ALL** of the types in the resulting
    homogeneous dtyped NumPy array. This can force some *upcasting*.'
  id: totrans-1367
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE431]'
  id: totrans-1368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE431]'
- en: astype
  id: totrans-1369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can use the [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") method to explicitly convert dtypes from one to another.
    These will by default return a copy, even if the dtype was unchanged (pass `copy=False`
    to change this behavior). In addition, they will raise an exception if the astype
    operation is invalid.
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
- en: Upcasting is always according to the **NumPy** rules. If two different dtypes
    are involved in an operation, then the more *general* one will be used as the
    result of the operation.
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE432]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE432]'
- en: Convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE433]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE433]'
- en: Convert certain columns to a specific dtype by passing a dict to [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype").
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE434]'
  id: totrans-1376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE434]'
- en: Note
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
- en: When trying to convert a subset of columns to a specified type using [`astype()`](../reference/api/pandas.DataFrame.astype.html#pandas.DataFrame.astype
    "pandas.DataFrame.astype") and [`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc
    "pandas.DataFrame.loc"), upcasting occurs.
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
- en: '[`loc()`](../reference/api/pandas.DataFrame.loc.html#pandas.DataFrame.loc "pandas.DataFrame.loc")
    tries to fit in what we are assigning to the current dtypes, while `[]` will overwrite
    them taking the dtype from the right hand side. Therefore the following piece
    of code produces the unintended result.'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE435]'
  id: totrans-1380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE435]'
- en: '### object conversion'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
- en: pandas offers various functions to try to force conversion of types from the
    `object` dtype to other types. In cases where the data is already of the correct
    type, but stored in an `object` array, the [`DataFrame.infer_objects()`](../reference/api/pandas.DataFrame.infer_objects.html#pandas.DataFrame.infer_objects
    "pandas.DataFrame.infer_objects") and [`Series.infer_objects()`](../reference/api/pandas.Series.infer_objects.html#pandas.Series.infer_objects
    "pandas.Series.infer_objects") methods can be used to soft convert to the correct
    type.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE436]'
  id: totrans-1383
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE436]'
- en: Because the data was transposed the original inference stored all columns as
    object, which `infer_objects` will correct.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE437]'
  id: totrans-1385
  prefs:
  - PREF_BQ
  type: TYPE_PRE
  zh: '[PRE437]'
- en: 'The following functions are available for one dimensional object arrays or
    scalars to perform hard conversion of objects to a specified type:'
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") (conversion to numeric dtypes)'
  id: totrans-1387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE438]'
  id: totrans-1388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE438]'
- en: '[`to_datetime()`](../reference/api/pandas.to_datetime.html#pandas.to_datetime
    "pandas.to_datetime") (conversion to datetime objects)'
  id: totrans-1389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE439]'
  id: totrans-1390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE439]'
- en: '[`to_timedelta()`](../reference/api/pandas.to_timedelta.html#pandas.to_timedelta
    "pandas.to_timedelta") (conversion to timedelta objects)'
  id: totrans-1391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE440]'
  id: totrans-1392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE440]'
- en: 'To force a conversion, we can pass in an `errors` argument, which specifies
    how pandas should deal with elements that cannot be converted to desired dtype
    or object. By default, `errors=''raise''`, meaning that any errors encountered
    will be raised during the conversion process. However, if `errors=''coerce''`,
    these errors will be ignored and pandas will convert problematic elements to `pd.NaT`
    (for datetime and timedelta) or `np.nan` (for numeric). This might be useful if
    you are reading in data which is mostly of the desired dtype (e.g. numeric, datetime),
    but occasionally has non-conforming elements intermixed that you want to represent
    as missing:'
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE441]'
  id: totrans-1394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE441]'
- en: 'In addition to object conversion, [`to_numeric()`](../reference/api/pandas.to_numeric.html#pandas.to_numeric
    "pandas.to_numeric") provides another argument `downcast`, which gives the option
    of downcasting the newly (or already) numeric data to a smaller dtype, which can
    conserve memory:'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE442]'
  id: totrans-1396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE442]'
- en: 'As these methods apply only to one-dimensional arrays, lists or scalars; they
    cannot be used directly on multi-dimensional objects such as DataFrames. However,
    with [`apply()`](../reference/api/pandas.DataFrame.apply.html#pandas.DataFrame.apply
    "pandas.DataFrame.apply"), we can “apply” the function over each column efficiently:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  id: totrans-1398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE443]'
- en: gotchas
  id: totrans-1399
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Performing selection operations on `integer` type data can easily upcast the
    data to `floating`. The dtype of the input data will be preserved in cases where
    `nans` are not introduced. See also [Support for integer NA](gotchas.html#gotchas-intna).
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  id: totrans-1401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE444]'
- en: While float dtypes are unchanged.
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE445]'
  id: totrans-1403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE445]'
- en: Selecting columns based on `dtype`
  id: totrans-1404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") method implements subsetting of columns based
    on their `dtype`.
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") with a slew of different dtypes:'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE446]'
  id: totrans-1407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE446]'
- en: 'And the dtypes:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE447]'
  id: totrans-1409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE447]'
- en: '[`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") has two parameters `include` and `exclude` that
    allow you to say “give me the columns *with* these dtypes” (`include`) and/or
    “give the columns *without* these dtypes” (`exclude`).'
  id: totrans-1410
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to select `bool` columns:'
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE448]'
  id: totrans-1412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE448]'
- en: 'You can also pass the name of a dtype in the [NumPy dtype hierarchy](https://numpy.org/doc/stable/reference/arrays.scalars.html):'
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE449]'
  id: totrans-1414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE449]'
- en: '[`select_dtypes()`](../reference/api/pandas.DataFrame.select_dtypes.html#pandas.DataFrame.select_dtypes
    "pandas.DataFrame.select_dtypes") also works with generic dtypes as well.'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to select all numeric and boolean columns while excluding unsigned
    integers:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE450]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE450]'
- en: 'To select string columns you must use the `object` dtype:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE451]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE451]'
- en: 'To see all the child dtypes of a generic `dtype` like `numpy.number` you can
    define a function that returns a tree of child dtypes:'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  id: totrans-1421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE452]'
- en: 'All NumPy dtypes are subclasses of `numpy.generic`:'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE453]'
- en: Note
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
- en: pandas also defines the types `category`, and `datetime64[ns, tz]`, which are
    not integrated into the normal NumPy hierarchy and won’t show up with the above
    function.
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
