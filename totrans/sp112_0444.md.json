["```py\nscipy.optimize.differential_evolution(func, bounds, args=(), strategy='best1bin', maxiter=1000, popsize=15, tol=0.01, mutation=(0.5, 1), recombination=0.7, seed=None, callback=None, disp=False, polish=True, init='latinhypercube', atol=0, updating='immediate', workers=1, constraints=(), x0=None, *, integrality=None, vectorized=False)\n```", "```py\n>>> import numpy as np\n>>> from scipy.optimize import rosen, differential_evolution\n>>> bounds = [(0,2), (0, 2), (0, 2), (0, 2), (0, 2)]\n>>> result = differential_evolution(rosen, bounds)\n>>> result.x, result.fun\n(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19) \n```", "```py\n>>> result = differential_evolution(rosen, bounds, updating='deferred',\n...                                 workers=2)\n>>> result.x, result.fun\n(array([1., 1., 1., 1., 1.]), 1.9216496320061384e-19) \n```", "```py\n>>> from scipy.optimize import LinearConstraint, Bounds \n```", "```py\n>>> lc = LinearConstraint([[1, 1]], -np.inf, 1.9) \n```", "```py\n>>> bounds = Bounds([0., 0.], [2., 2.])\n>>> result = differential_evolution(rosen, bounds, constraints=lc,\n...                                 seed=1)\n>>> result.x, result.fun\n(array([0.96632622, 0.93367155]), 0.0011352416852625719) \n```", "```py\n>>> def ackley(x):\n...     arg1 = -0.2 * np.sqrt(0.5 * (x[0] ** 2 + x[1] ** 2))\n...     arg2 = 0.5 * (np.cos(2. * np.pi * x[0]) + np.cos(2. * np.pi * x[1]))\n...     return -20. * np.exp(arg1) - np.exp(arg2) + 20. + np.e\n>>> bounds = [(-5, 5), (-5, 5)]\n>>> result = differential_evolution(ackley, bounds, seed=1)\n>>> result.x, result.fun\n(array([0., 0.]), 4.440892098500626e-16) \n```", "```py\n>>> result = differential_evolution(\n...     ackley, bounds, vectorized=True, updating='deferred', seed=1\n... )\n>>> result.x, result.fun\n(array([0., 0.]), 4.440892098500626e-16) \n```", "```py\n>>> def custom_strategy_fn(candidate, population, rng=None):\n...     parameter_count = population.shape(-1)\n...     mutation, recombination = 0.7, 0.9\n...     trial = np.copy(population[candidate])\n...     fill_point = rng.choice(parameter_count)\n...\n...     pool = np.arange(len(population))\n...     rng.shuffle(pool)\n...\n...     # two unique random numbers that aren't the same, and\n...     # aren't equal to candidate.\n...     idxs = []\n...     while len(idxs) < 2 and len(pool) > 0:\n...         idx = pool[0]\n...         pool = pool[1:]\n...         if idx != candidate:\n...             idxs.append(idx)\n...\n...     r0, r1 = idxs[:2]\n...\n...     bprime = (population[0] + mutation *\n...               (population[r0] - population[r1]))\n...\n...     crossovers = rng.uniform(size=parameter_count)\n...     crossovers = crossovers < recombination\n...     crossovers[fill_point] = True\n...     trial = np.where(crossovers, bprime, trial)\n...     return trial \n```"]