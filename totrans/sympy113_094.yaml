- en: Solvers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/solvers/solvers.html](https://docs.sympy.org/latest/modules/solvers/solvers.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The *solvers* module in SymPy implements methods for solving equations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For a beginner-friendly guide focused on solving common types of equations,
    refer to [Solve Equations](../../guides/solving/index.html#solving-guide).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve") is
    an older more mature general function for solving many types of equations. [`solve()`](#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve") has many options and uses different methods internally
    to determine what type of equations you pass it, so if you know what type of equation
    you are dealing with you may want to use the newer [`solveset()`](solveset.html#module-sympy.solvers.solveset
    "sympy.solvers.solveset") which solves univariate equations, [`linsolve()`](solveset.html#sympy.solvers.solveset.linsolve
    "sympy.solvers.solveset.linsolve") which solves system of linear equations, and
    [`nonlinsolve()`](solveset.html#sympy.solvers.solveset.nonlinsolve "sympy.solvers.solveset.nonlinsolve")
    which solves systems of non linear equations.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Algebraic equations'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use [`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")
    to solve algebraic equations. We suppose all equations are equaled to 0, so solving
    x**2 == 1 translates into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The first argument for [`solve()`](#sympy.solvers.solvers.solve "sympy.solvers.solvers.solve")
    is an equation (equaled to zero) and the second argument is the symbol that we
    want to solve the equation for.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Algebraically solves equations and systems of equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**f :**'
  prefs: []
  type: TYPE_NORMAL
- en: a single Expr or Poly that must be zero
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: an Equality
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a Relational expression
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: a Boolean
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: iterable of one or more of the above
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**symbols** : (object(s) to solve for) specified as'
  prefs: []
  type: TYPE_NORMAL
- en: none given (other non-numeric objects will be used)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: single symbol
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: denested list of symbols (e.g., `solve(f, x, y)`)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ordered iterable of symbols (e.g., `solve(f, [x, y])`)
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '**flags :**'
  prefs: []
  type: TYPE_NORMAL
- en: dict=True (default is False)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return list (perhaps empty) of solution mappings.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: set=True (default is False)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return list of symbols and set of tuple(s) of solution(s).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: exclude=[] (default)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do not try to solve for any of the free symbols in exclude; if expressions are
    given, the free symbols in them will be extracted automatically.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: check=True (default)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If False, do not do any testing of solutions. This can be useful if you want
    to include solutions that make any denominator zero.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: numerical=True (default)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do a fast numerical check if *f* has only one symbol.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: minimal=True (default is False)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A very fast, minimal testing.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: warn=True (default is False)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Show a warning if `checksol()` could not conclude.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: simplify=True (default)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Simplify all but polynomials of order 3 or greater before returning them and
    (if check is not False) use the general simplify function on the solutions and
    the expression obtained when they are substituted into the function which should
    be zero.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: force=True (default is False)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Make positive all symbols without assumptions regarding sign.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: rational=True (default)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Recast Floats as Rational; if this option is not used, the system containing
    Floats may fail to solve because of issues with polys. If rational=None, Floats
    will be recast as rationals but the answer will be recast as Floats. If the flag
    is False then nothing will be done to the Floats.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: manual=True (default is False)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Do not use the polys/matrix method to solve a system of equations, solve them
    one at a time as you might “manually.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: implicit=True (default is False)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Allows `solve` to return a solution for a pattern in terms of other functions
    that contain that pattern; this is only needed if the pattern is inside of some
    invertible function like cos, exp, ect.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: particular=True (default is False)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Instructs `solve` to try to find a particular solution to a linear system with
    as many zeros as possible; this is very expensive.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: quick=True (default is False; `particular` must be True)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Selects a fast heuristic to find a solution with many zeros whereas a value
    of False uses the very slow method guaranteed to find the largest number of zeros
    possible.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: cubics=True (default)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return explicit solutions when cubic expressions are encountered. When False,
    quartics and quintics are disabled, too.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: quartics=True (default)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return explicit solutions when quartic expressions are encountered. When False,
    quintics are disabled, too.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: quintics=True (default)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Return explicit solutions (if possible) when quintic expressions are encountered.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: 'Currently supported:'
  prefs: []
  type: TYPE_NORMAL
- en: polynomial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: transcendental
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: piecewise combinations of the above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: systems of linear and polynomial equations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: systems containing relational expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: systems implied by undetermined coefficients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: The default output varies according to the input and might be a list (possibly
    empty), a dictionary, a list of dictionaries or tuples, or an expression involving
    relationals. For specifics regarding different forms of output that may appear,
    see [Solve Output by Type](../../explanation/solve_output.html#solve-output).
    Let it suffice here to say that to obtain a uniform output from \(solve\) use
    `dict=True` or `set=True` (see below).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The expressions that are passed can be Expr, Equality, or Poly classes (or
    lists of the same); a Matrix is considered to be a list of all the elements of
    the matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If no symbols are indicated to be of interest and the equation is univariate,
    a list of values is returned; otherwise, the keys in a dictionary will indicate
    which (of all the variables used in the expression(s)) variables and solutions
    were found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you pass symbols for which solutions are sought, the output will vary depending
    on the number of symbols you passed, whether you are passing a list of expressions
    or not, and whether a linear system was solved. Uniform output is attained by
    using `dict=True` or `set=True`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'If any equation does not depend on the symbol(s) given, it will be eliminated
    from the equation set and an answer may be given implicitly in terms of variables
    that were not of interest:'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: 'When you pass all but one of the free symbols, an attempt is made to find a
    single solution based on the method of undetermined coefficients. If it succeeds,
    a dictionary of values is returned. If you want an algebraic solutions for one
    or more of the symbols, pass the expression to be solved in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When there is no solution for any given symbol which will make all expressions
    zero, the empty list is returned (or an empty set in the tuple when `set=True`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When an object other than a Symbol is given as a symbol, it is isolated algebraically
    and an implicit solution may be obtained. This is mostly provided as a convenience
    to save you from replacing the object with a Symbol and solving for that Symbol.
    It will only work if the specified object can be replaced with a Symbol using
    the subs method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: To solve for a function within a derivative, use [`dsolve()`](ode.html#sympy.solvers.ode.dsolve
    "sympy.solvers.ode.dsolve").
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To solve for a symbol implicitly, use implicit=True:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to solve for anything in an expression that can be replaced
    with a symbol using [`subs`](../core.html#sympy.core.basic.Basic.subs "sympy.core.basic.Basic.subs"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_BQ
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Nothing heroic is done in this implicit solving so you may end up with a symbol
    still in the solution:'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you attempt to solve for a number, remember that the number you have obtained
    does not necessarily mean that the value is equivalent to the expression obtained:'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_PRE
- en: '**Additional Examples**'
  prefs: []
  type: TYPE_NORMAL
- en: '`solve()` with check=True (default) will run through the symbol tags to eliminate
    unwanted solutions. If no assumptions are included, all possible solutions will
    be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'By setting the `positive` flag, only one solution will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'When the solutions are checked, those that make any denominator zero are automatically
    excluded. If you do not want to exclude such solutions, then use the check=False
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If `check=False`, then a solution to the numerator being zero is found but
    the value of \(x = 0\) is a spurious solution since \(\sin(x)/x\) has the well
    known limit (without discontinuity) of 1 at \(x = 0\):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In the following case, however, the limit exists and is equal to the value
    of \(x = 0\) that is excluded when check=True:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '**Solving Relationships**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When one or more expressions passed to `solve` is a relational, a relational
    result is returned (and the `dict` and `set` flags are ignored):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Although checking of assumptions on symbols in relationals is not done, setting
    assumptions will affect how certain relationals might automatically simplify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There is currently no algorithm in SymPy that allows you to use relationships
    to resolve more than one variable. So the following does not determine that `q
    < 0` (and trying to solve for `r` and `q` will raise an error):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can directly call the routine that `solve` calls when it encounters a relational:
    [`reduce_inequalities()`](inequalities.html#sympy.solvers.inequalities.reduce_inequalities
    "sympy.solvers.inequalities.reduce_inequalities"). It treats Expr like Equality.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If each relationship contains only one symbol of interest, the expressions
    can be processed for multiple symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'But an error is raised if any relationship has more than one symbol of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '**Disabling High-Order Explicit Solutions**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When solving polynomial expressions, you might not want explicit solutions
    (which can be quite long). If the expression is univariate, `CRootOf` instances
    will be returned instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If the expression is multivariate, no solution might be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes solutions will be obtained even when a flag is False because the
    expression could be factored. In the following example, the equation can be factored
    as the product of a linear and a quadratic factor so explicit solutions (which
    did not require solving a cubic expression) are obtained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Solving Equations Involving Radicals**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of SymPy’s use of the principle root, some solutions to radical equations
    will be missed unless check=False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, there is only a single solution to the equation. Other
    expressions will yield spurious roots which must be checked manually; roots which
    give a negative argument to odd-powered radicals will also need special checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The first solution is negative so `real_root` must be used to see that it satisfies
    the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If the roots of the equation are not real then more care will be necessary
    to find the roots, especially for higher order equations. Consider the following
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will construct a known value for this expression at x = 3 by selecting the
    1-th root for each radical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `solve` function is unable to find any exact roots to this equation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `unrad`, however, can be used to get a form of the equation for
    which numerical roots can be found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Although `eq` or `eq1` could have been used to find `xvals`, the solution can
    only be verified with `expr1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rsolve`](#sympy.solvers.recurr.rsolve "sympy.solvers.recurr.rsolve")'
  prefs: []
  type: TYPE_NORMAL
- en: For solving recurrence relationships
  prefs: []
  type: TYPE_NORMAL
- en: '[`dsolve`](ode.html#sympy.solvers.ode.dsolve "sympy.solvers.ode.dsolve")'
  prefs: []
  type: TYPE_NORMAL
- en: For solving differential equations
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Return a tuple derived from `f = lhs - rhs` that is one of the following: `(0,
    1)`, `(0, 0)`, `(symbol, solution)`, `(n, d)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`(0, 1)` meaning that `f` is independent of the symbols in *symbols* that are
    not in *exclude*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(0, 0)` meaning that there is no solution to the equation amongst the symbols
    given. If the first element of the tuple is not zero, then the function is guaranteed
    to be dependent on a symbol in *symbols*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(symbol, solution)` where symbol appears linearly in the numerator of `f`,
    is in *symbols* (if given), and is not in *exclude* (if given). No simplification
    is done to `f` other than a `mul=True` expansion, so the solution will correspond
    strictly to a unique solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '`(n, d)` where `n` and `d` are the numerator and denominator of `f` when the
    numerator was not linear in any symbol of interest; `n` will never be a symbol
    unless a solution for that symbol was found (in which case the second element
    is the solution, not the denominator).'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`f` is independent of the symbols in *symbols* that are not in *exclude*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The variable `x` appears as a linear variable in each of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When not linear in `x` or `y` then the numerator and denominator are returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If the numerator of the expression is a symbol, then `(0, 0)` is returned if
    the solution for that symbol would have set any denominator to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'But automatic rewriting may cause a symbol in the denominator to appear in
    the numerator so a solution will be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Use an unevaluated expression to avoid this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If `x` is allowed to cancel in the following expression, then it appears to
    be linear in `x`, but this sort of cancellation is not done by `solve_linear`
    so the solution will always satisfy the original expression without causing a
    division by zero error.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'A list of symbols for which a solution is desired may be given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A list of symbols to ignore may also be given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: (A solution for `y` is obtained because it is the first variable from the canonically
    sorted list of symbols that had a linear solution.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Solve system of \(N\) linear equations with \(M\) variables, which means both
    under- and overdetermined systems are supported.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The possible number of solutions is zero, one, or infinite. Respectively, this
    procedure will return None or a dictionary with solutions. In the case of underdetermined
    systems, all arbitrary parameters are skipped. This may cause a situation in which
    an empty dictionary is returned. In that case, all symbols can be assigned arbitrary
    values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Input to this function is a \(N\times M + 1\) matrix, which means it has to
    be in augmented form. If you prefer to enter \(N\) equations and \(M\) unknowns
    then use `solve(Neqs, *Msymbols)` instead. Note: a local copy of the matrix is
    made by this routine so the matrix that is passed will not be modified.'
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm used here is fraction-free Gaussian elimination, which results,
    after elimination, in an upper-triangular matrix. Then solutions are found using
    back-substitution. This approach is more efficient and compact than the Gauss-Jordan
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Solve the following system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'A degenerate system returns an empty dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Solves the augmented matrix system using `LUsolve` and returns a dictionary
    in which solutions are keyed to the symbols of *syms* as ordered.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The matrix must be invertible.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`LUsolve`](../matrices/matrices.html#sympy.matrices.matrixbase.MatrixBase.LUsolve
    "sympy.matrices.matrixbase.MatrixBase.LUsolve")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Solve a system of equations in \(k\) parameters that is formed by matching coefficients
    in variables `coeffs` that are on factors dependent on the remaining variables
    (or those given explicitly by `syms`.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: The result of this function is a dictionary with symbolic values of those parameters
    with respect to coefficients in \(q\) – empty if there is no solution or coefficients
    do not appear in the equation – else None (if the system was not recognized).
    If there is more than one solution, the solutions are passed as a list. The output
    can be modified using the same semantics as for \(solve\) since the flags that
    are passed are sent directly to \(solve\) so, for example the flag `dict=True`
    will always return a list of solutions as dictionaries.
  prefs: []
  type: TYPE_NORMAL
- en: This function accepts both Equality and Expr class instances. The solving process
    is most efficient when symbols are specified in addition to parameters to be determined,
    but an attempt to determine them (if absent) will be made. If an expected solution
    is not obtained (and symbols were not specified) try specifying them.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The equation can be nonlinear in the symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'And the system can be nonlinear in coefficients, too, but if there is only
    a single solution, it will be returned as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Multiple solutions are always returned in a list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Using flag `dict=True` (in keeping with semantics in [`solve()`](#sympy.solvers.solvers.solve
    "sympy.solvers.solvers.solve")) will force the result to always be a list with
    any solutions as elements in that list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Solve a nonlinear equation system numerically: `nsolve(f, [args,] x0, modules=[''mpmath''],
    **kwargs)`.'
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: '`f` is a vector function of symbolic expressions representing the system. *args*
    are the variables. If there is only one variable, this argument can be omitted.
    `x0` is a starting vector close to a solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Use the modules keyword to specify which modules should be used to evaluate
    the function and the Jacobian matrix. Make sure to use a module that supports
    matrices. For more information on the syntax, please see the docstring of `lambdify`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the keyword arguments contain `dict=True` (default is False) `nsolve` will
    return a list (perhaps empty) of solution mappings. This might be especially useful
    if you want to use `nsolve` as a fallback to solve since using the dict argument
    for both methods produces return values of consistent type structure. Please note:
    to keep this consistent with `solve`, the solution will be returned in a list
    even though `nsolve` (currently at least) only finds one solution at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: Overdetermined systems are supported.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'For one-dimensional functions the syntax is simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve with higher precision than the default, use the prec argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To solve for complex roots of real functions, a nonreal initial point must
    be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`mpmath.findroot` is used and you can find their more extensive documentation,
    especially concerning keyword parameters and available solvers. Note, however,
    that functions which are very steep near the root, the verification of the solution
    may fail. In this case you should use the flag `verify=False` and independently
    verify the solution.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'One might safely skip the verification if bounds of the root are known and
    a bisection method is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, a function may be better behaved when the denominator is ignored.
    Since this is not always the case, however, the decision of what function to use
    is left to the discretion of the user.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Checks whether sol is a solution of equation f == 0.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: Input can be either a single symbol and corresponding value or a dictionary
    of symbols and values. When given as a dictionary and flag `simplify=True`, the
    values in the dictionary will be simplified. *f* can be a single equation or an
    iterable of equations. A solution must satisfy all equations in *f* to be considered
    valid; if a solution does not satisfy any equation, False is returned; if one
    or more checks are inconclusive (and none are False) then None is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'To check if an expression is zero using `checksol()`, pass it as *f* and send
    an empty dictionary for *symbol*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: None is returned if `checksol()` could not conclude.
  prefs: []
  type: TYPE_NORMAL
- en: 'flags:'
  prefs: []
  type: TYPE_NORMAL
- en: ‘numerical=True (default)’
  prefs: []
  type: TYPE_NORMAL
- en: do a fast numerical check if `f` has only one symbol.
  prefs: []
  type: TYPE_NORMAL
- en: ‘minimal=True (default is False)’
  prefs: []
  type: TYPE_NORMAL
- en: a very fast, minimal testing.
  prefs: []
  type: TYPE_NORMAL
- en: ‘warn=True (default is False)’
  prefs: []
  type: TYPE_NORMAL
- en: show a warning if checksol() could not conclude.
  prefs: []
  type: TYPE_NORMAL
- en: ‘simplify=True (default)’
  prefs: []
  type: TYPE_NORMAL
- en: simplify solution before substituting into function and simplify the function
    before trying specific simplifications
  prefs: []
  type: TYPE_NORMAL
- en: ‘force=True (default is False)’
  prefs: []
  type: TYPE_NORMAL
- en: make positive all symbols without assumptions regarding sign.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Remove radicals with symbolic arguments and return (eq, cov), None, or raise
    an error.
  prefs: []
  type: TYPE_NORMAL
- en: Explanation
  prefs: []
  type: TYPE_NORMAL
- en: None is returned if there are no radicals to remove.
  prefs: []
  type: TYPE_NORMAL
- en: NotImplementedError is raised if there are radicals and they cannot be removed
    or if the relationship between the original symbols and the change of variable
    needed to rewrite the system as a polynomial cannot be solved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Otherwise the tuple, `(eq, cov)`, is returned where:'
  prefs: []
  type: TYPE_NORMAL
- en: '*eq*, `cov`'
  prefs: []
  type: TYPE_NORMAL
- en: '*eq* is an equation without radicals (in the symbol(s) of interest) whose solutions
    are a superset of the solutions to the original expression. *eq* might be rewritten
    in terms of a new variable; the relationship to the original variables is given
    by `cov` which is a list containing `v` and `v**p - b` where `p` is the power
    needed to clear the radical and `b` is the radical now expressed as a polynomial
    in the symbols of interest. For example, for sqrt(2 - x) the tuple would be `(c,
    c**2 - 2 + x)`. The solutions of *eq* will contain solutions to the original equation
    (if there are any).'
  prefs: []
  type: TYPE_NORMAL
- en: '*syms*'
  prefs: []
  type: TYPE_NORMAL
- en: 'An iterable of symbols which, if provided, will limit the focus of radical
    removal: only radicals with one or more of the symbols of interest will be cleared.
    All free symbols are used if *syms* is not set.'
  prefs: []
  type: TYPE_NORMAL
- en: '*flags* are used internally for communication during recursive calls. Two options
    are also recognized:'
  prefs: []
  type: TYPE_NORMAL
- en: '`take`, when defined, is interpreted as a single-argument function that returns
    True if a given Pow should be handled.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Radicals can be removed from an expression if:'
  prefs: []
  type: TYPE_NORMAL
- en: All bases of the radicals are the same; a change of variables is done in this
    case.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: If all radicals appear in one term of the expression.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: There are only four terms with sqrt() factors or there are less than four terms
    having sqrt() factors.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: There are only two terms with radicals.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Ordinary Differential equations (ODEs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [ODE](ode.html#ode-docs).
  prefs: []
  type: TYPE_NORMAL
- en: Partial Differential Equations (PDEs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [PDE](pde.html#pde-docs).
  prefs: []
  type: TYPE_NORMAL
- en: Deutils (Utilities for solving ODE’s and PDE’s)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Returns the order of a given differential equation with respect to func.
  prefs: []
  type: TYPE_NORMAL
- en: This function is implemented recursively.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '## Recurrence Equations'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Solve univariate recurrence with rational coefficients.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given \(k\)-th order linear recurrence \(\operatorname{L} y = f\), or equivalently:'
  prefs: []
  type: TYPE_NORMAL
- en: \[a_{k}(n) y(n+k) + a_{k-1}(n) y(n+k-1) + \cdots + a_{0}(n) y(n) = f(n)\]
  prefs: []
  type: TYPE_NORMAL
- en: where \(a_{i}(n)\), for \(i=0, \ldots, k\), are polynomials or rational functions
    in \(n\), and \(f\) is a hypergeometric function or a sum of a fixed number of
    pairwise dissimilar hypergeometric terms in \(n\), finds all solutions or returns
    `None`, if none were found.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initial conditions can be given as a dictionary in two forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{  n_0  : v_0,   n_1  : v_1, ...,   n_m  : v_m}`'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{y(n_0) : v_0, y(n_1) : v_1, ..., y(n_m) : v_m}`'
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: 'or as a list `L` of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`L = [v_0, v_1, ..., v_m]`'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: where `L[i] = v_i`, for \(i=0, \ldots, m\), maps to \(y(n_i)\).
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets consider the following recurrence:'
  prefs: []
  type: TYPE_NORMAL
- en: \[(n - 1) y(n + 2) - (n^2 + 3 n - 2) y(n + 1) + 2 n (n + 1) y(n) = 0\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rsolve_poly`](#sympy.solvers.recurr.rsolve_poly "sympy.solvers.recurr.rsolve_poly"),
    [`rsolve_ratio`](#sympy.solvers.recurr.rsolve_ratio "sympy.solvers.recurr.rsolve_ratio"),
    [`rsolve_hyper`](#sympy.solvers.recurr.rsolve_hyper "sympy.solvers.recurr.rsolve_hyper")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Given linear recurrence operator \(\operatorname{L}\) of order \(k\) with polynomial
    coefficients and inhomogeneous equation \(\operatorname{L} y = f\), where \(f\)
    is a polynomial, we seek for all polynomial solutions over field \(K\) of characteristic
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm performs two basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute degree \(N\) of the general polynomial solution.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Find all polynomials of degree \(N\) or less of \(\operatorname{L} y = f\).
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: There are two methods for computing the polynomial solutions. If the degree
    bound is relatively small, i.e. it’s smaller than or equal to the order of the
    recurrence, then naive method of undetermined coefficients is being used. This
    gives a system of algebraic equations with \(N+1\) unknowns.
  prefs: []
  type: TYPE_NORMAL
- en: In the other case, the algorithm performs transformation of the initial equation
    to an equivalent one for which the system of algebraic equations has only \(r\)
    indeterminates. This method is quite sophisticated (in comparison with the naive
    one) and was invented together by Abramov, Bronstein and Petkovsek.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to generalize the algorithm implemented here to the case of linear
    q-difference and differential equations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets say that we would like to compute \(m\)-th Bernoulli polynomial up to
    a constant. For this we can use \(b(n+1) - b(n) = m n^{m-1}\) recurrence, which
    has solution \(b(n) = B_m + C\). For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R890](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'S. A. Abramov, M. Bronstein and M. Petkovsek, On polynomial solutions of linear
    operator equations, in: T. Levelt, ed., Proc. ISSAC ‘95, ACM Press, New York,
    1995, 290-296.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[R891](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: M. Petkovsek, Hypergeometric solutions of linear recurrences with polynomial
    coefficients, J. Symbolic Computation, 14 (1992), 243-264.
  prefs: []
  type: TYPE_NORMAL
- en: '[[R892](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Given linear recurrence operator \(\operatorname{L}\) of order \(k\) with polynomial
    coefficients and inhomogeneous equation \(\operatorname{L} y = f\), where \(f\)
    is a polynomial, we seek for all rational solutions over field \(K\) of characteristic
    zero.
  prefs: []
  type: TYPE_NORMAL
- en: This procedure accepts only polynomials, however if you are interested in solving
    recurrence with rational coefficients then use `rsolve` which will pre-process
    the given equation and run this procedure with polynomial arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm performs two basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Compute polynomial \(v(n)\) which can be used as universal denominator of any
    rational solution of equation \(\operatorname{L} y = f\).
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Construct new linear difference equation by substitution \(y(n) = u(n)/v(n)\)
    and solve it for \(u(n)\) finding all its polynomial solutions. Return `None`
    if none were found.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: The algorithm implemented here is a revised version of the original Abramov’s
    algorithm, developed in 1989\. The new approach is much simpler to implement and
    has better overall efficiency. This method can be easily adapted to the q-difference
    equations case.
  prefs: []
  type: TYPE_NORMAL
- en: Besides finding rational solutions alone, this functions is an important part
    of Hyper algorithm where it is used to find a particular solution for the inhomogeneous
    part of a recurrence.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`rsolve_hyper`](#sympy.solvers.recurr.rsolve_hyper "sympy.solvers.recurr.rsolve_hyper")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R893](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'S. A. Abramov, Rational solutions of linear difference and q-difference equations
    with polynomial coefficients, in: T. Levelt, ed., Proc. ISSAC ‘95, ACM Press,
    New York, 1995, 285-289'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Given linear recurrence operator \(\operatorname{L}\) of order \(k\) with polynomial
    coefficients and inhomogeneous equation \(\operatorname{L} y = f\) we seek for
    all hypergeometric solutions over field \(K\) of characteristic zero.
  prefs: []
  type: TYPE_NORMAL
- en: The inhomogeneous part can be either hypergeometric or a sum of a fixed number
    of pairwise dissimilar hypergeometric terms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm performs three basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Group together similar hypergeometric terms in the inhomogeneous part of \(\operatorname{L}
    y = f\), and find particular solution using Abramov’s algorithm.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Compute generating set of \(\operatorname{L}\) and find basis in it, so that
    all solutions are linearly independent.
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Form final solution with the number of arbitrary constants equal to dimension
    of basis of \(\operatorname{L}\).
  prefs:
  - PREF_BQ
  - PREF_OL
  type: TYPE_NORMAL
- en: Term \(a(n)\) is hypergeometric if it is annihilated by first order linear difference
    equations with polynomial coefficients or, in simpler words, if consecutive term
    ratio is a rational function.
  prefs: []
  type: TYPE_NORMAL
- en: The output of this procedure is a linear combination of fixed number of hypergeometric
    terms. However the underlying method can generate larger class of solutions -
    D’Alembertian terms.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that this method not only computes the kernel of the inhomogeneous
    equation, but also reduces in to a basis so that solutions generated by this procedure
    are linearly independent
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R894](#id5)]'
  prefs: []
  type: TYPE_NORMAL
- en: M. Petkovsek, Hypergeometric solutions of linear recurrences with polynomial
    coefficients, J. Symbolic Computation, 14 (1992), 243-264.
  prefs: []
  type: TYPE_NORMAL
- en: '[[R895](#id6)]'
  prefs: []
  type: TYPE_NORMAL
- en: Petkovsek, H. S. Wilf, D. Zeilberger, A = B, 1996.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Systems of Polynomial Equations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of solutions for the system of polynomial equations or else None.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**seq: a list/tuple/set**'
  prefs: []
  type: TYPE_NORMAL
- en: Listing all the equations that are needed to be solved
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**gens: generators**'
  prefs: []
  type: TYPE_NORMAL
- en: generators of the equations in seq for which we want the solutions
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**strict: a boolean (default is False)**'
  prefs: []
  type: TYPE_NORMAL
- en: if strict is True, NotImplementedError will be raised if the solution is known
    to be incomplete (which can occur if not all solutions are expressible in radicals)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**args: Keyword arguments**'
  prefs: []
  type: TYPE_NORMAL
- en: Special options for solving the equations.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: List[Tuple]
  prefs: []
  type: TYPE_NORMAL
- en: a list of tuples with elements being solutions for the symbols in the order
    they were passed as gens
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: None
  prefs: []
  type: TYPE_NORMAL
- en: None is returned when the computed basis contains only the ground.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Solve a polynomial system using Gianni-Kalkbrenner algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The algorithm proceeds by computing one Groebner basis in the ground domain
    and then by iteratively computing polynomial factorizations in appropriately constructed
    algebraic extensions of the ground domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**polys: a list/tuple/set**'
  prefs: []
  type: TYPE_NORMAL
- en: Listing all the equations that are needed to be solved
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**gens: generators**'
  prefs: []
  type: TYPE_NORMAL
- en: generators of the equations in polys for which we want the solutions
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**args: Keyword arguments**'
  prefs: []
  type: TYPE_NORMAL
- en: Special options for solving the equations
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: List[Tuple]
  prefs: []
  type: TYPE_NORMAL
- en: A List of tuples. Solutions for symbols that satisfy the equations listed in
    polys
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Patrizia Gianni, Teo Mora, Algebraic Solution of System of Polynomial Equations
    using Groebner Bases, AAECC-5 on Applied Algebra, Algebraic Algorithms and Error-Correcting
    Codes, LNCS 356 247–257, 1989
  prefs: []
  type: TYPE_NORMAL
- en: Diophantine Equations (DEs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Diophantine](diophantine.html#diophantine-docs)
  prefs: []
  type: TYPE_NORMAL
- en: Inequalities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Inequality Solvers](inequalities.html#inequality-docs)
  prefs: []
  type: TYPE_NORMAL
- en: '## Linear Programming (Optimization)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: return maximum of linear equation `f` under linear constraints expressed using
    Ge, Le or Eq.
  prefs: []
  type: TYPE_NORMAL
- en: All variables are unbounded unless constrained.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'Negative values for variables are permitted unless explicitly exluding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'If a non-negative constraint is added for x, there is no possible solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`linprog`](#sympy.solvers.simplex.linprog "sympy.solvers.simplex.linprog"),
    [`lpmin`](#sympy.solvers.simplex.lpmin "sympy.solvers.simplex.lpmin")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: return minimum of linear equation `f` under linear constraints expressed using
    Ge, Le or Eq.
  prefs: []
  type: TYPE_NORMAL
- en: All variables are unbounded unless constrained.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Negative values for variables are permitted unless explicitly exluding, so
    minimizing `x` for `x <= 3` is an unbounded problem while the following has a
    bounded solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Without indicating that `x` is nonnegative, there is no minimum for this objective:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`linprog`](#sympy.solvers.simplex.linprog "sympy.solvers.simplex.linprog"),
    [`lpmax`](#sympy.solvers.simplex.lpmax "sympy.solvers.simplex.lpmax")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Return the minimization of `c*x` with the given constraints `A*x <= b` and `A_eq*x
    = b_eq`. Unless bounds are given, variables will have nonnegative values in the
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: If `A` is not given, then the dimension of the system will be determined by
    the length of `C`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, all variables will be nonnegative. If `bounds` is given as a single
    tuple, `(lo, hi)`, then all variables will be constrained to be between `lo` and
    `hi`. Use None for a `lo` or `hi` if it is unconstrained in the negative or positive
    direction, respectively, e.g. `(None, 0)` indicates nonpositive values. To set
    individual ranges, pass a list with length equal to the number of columns in `A`,
    each element being a tuple; if only a few variables take on non-default values
    they can be passed as a dictionary with keys giving the corresponding column to
    which the variable is assigned, e.g. `bounds={2: (1, 4)}` would limit the 3rd
    variable to have a value in range `[1, 4]`.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`lpmin`](#sympy.solvers.simplex.lpmin "sympy.solvers.simplex.lpmin"), [`lpmax`](#sympy.solvers.simplex.lpmax
    "sympy.solvers.simplex.lpmax")'
  prefs: []
  type: TYPE_NORMAL
