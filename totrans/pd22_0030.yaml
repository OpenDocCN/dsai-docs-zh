- en: Copy-on-Write (CoW)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pandas.pydata.org/docs/user_guide/copy_on_write.html](https://pandas.pydata.org/docs/user_guide/copy_on_write.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-Write will become the default in pandas 3.0\. We recommend [turning
    it on now](#copy-on-write-enabling) to benefit from all improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-Write was first introduced in version 1.5.0\. Starting from version
    2.0 most of the optimizations that become possible through CoW are implemented
    and supported. All possible optimizations are supported starting from pandas 2.1.
  prefs: []
  type: TYPE_NORMAL
- en: CoW will be enabled by default in version 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: CoW will lead to more predictable behavior since it is not possible to update
    more than one object with one statement, e.g. indexing operations or methods won’t
    have side-effects. Additionally, through delaying copies as long as possible,
    the average performance and memory usage will improve.
  prefs: []
  type: TYPE_NORMAL
- en: Previous behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'pandas indexing behavior is tricky to understand. Some operations return views
    while other return copies. Depending on the result of the operation, mutating
    one object might accidentally mutate another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Mutating `subset`, e.g. updating its values, also updates `df`. The exact behavior
    is hard to predict. Copy-on-Write solves accidentally modifying more than one
    object, it explicitly disallows this. With CoW enabled, `df` is unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The following sections will explain what this means and how it impacts existing
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: '## Migrating to Copy-on-Write'
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-Write will be the default and only mode in pandas 3.0\. This means that
    users need to migrate their code to be compliant with CoW rules.
  prefs: []
  type: TYPE_NORMAL
- en: The default mode in pandas will raise warnings for certain cases that will actively
    change behavior and thus change user intended behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We added another mode, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: that will warn for every operation that will change behavior with CoW. We expect
    this mode to be very noisy, since many cases that we don’t expect that they will
    influence users will also emit a warning. We recommend checking this mode and
    analyzing the warnings, but it is not necessary to address all of these warning.
    The first two items of the following lists are the only cases that need to be
    addressed to make existing code work with CoW.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following few items describe the user visible changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chained assignment will never work**'
  prefs: []
  type: TYPE_NORMAL
- en: '`loc` should be used as an alternative. Check the [chained assignment section](#copy-on-write-chained-assignment)
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the underlying array of a pandas object will return a read-only
    view**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This example returns a NumPy array that is a view of the Series object. This
    view can be modified and thus also modify the pandas object. This is not compliant
    with CoW rules. The returned array is set to non-writeable to protect against
    this behavior. Creating a copy of this array allows modification. You can also
    make the array writeable again if you don’t care about the pandas object anymore.
  prefs: []
  type: TYPE_NORMAL
- en: See the section about [read-only NumPy arrays](#copy-on-write-read-only-na)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Only one pandas object is updated at once**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet updates both `df` and `subset` without CoW:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This won’t be possible anymore with CoW, since the CoW rules explicitly forbid
    this. This includes updating a single column as a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and relying on the change propagating back to the parent [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). This statement can be rewritten into a single statement with
    `loc` or `iloc` if this behavior is necessary. [`DataFrame.where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where") is another suitable alternative for this case.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a column selected from a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") with an inplace method will also not work anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another form of chained assignment. This can generally be rewritten
    in 2 different forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'A different alternative would be to not use `inplace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**Constructors now copy NumPy arrays by default**'
  prefs: []
  type: TYPE_NORMAL
- en: The Series and DataFrame constructors will now copy NumPy array by default when
    not otherwise specified. This was changed to avoid mutating a pandas object when
    the NumPy array is changed inplace outside of pandas. You can set `copy=False`
    to avoid this copy.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CoW means that any DataFrame or Series derived from another in any way always
    behaves as a copy. As a consequence, we can only change the values of an object
    through modifying the object itself. CoW disallows updating a DataFrame or a Series
    that shares data with another DataFrame or Series object inplace.
  prefs: []
  type: TYPE_NORMAL
- en: This avoids side-effects when modifying values and hence, most methods can avoid
    actually copying the data and only trigger a copy when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will operate inplace with CoW:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The object `df` does not share any data with any other object and hence no
    copy is triggered when updating the values. In contrast, the following operation
    triggers a copy of the data under CoW:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`reset_index` returns a lazy copy with CoW while it copies the data without
    CoW. Since both objects, `df` and `df2` share the same data, a copy is triggered
    when modifying `df2`. The object `df` still has the same values as initially while
    `df2` was modified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the object `df` isn’t needed anymore after performing the `reset_index`
    operation, you can emulate an inplace-like operation through assigning the output
    of `reset_index` to the same variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The initial object gets out of scope as soon as the result of `reset_index`
    is reassigned and hence `df` does not share data with any other object. No copy
    is necessary when modifying the object. This is generally true for all methods
    listed in [Copy-on-Write optimizations](#copy-on-write-optimizations).
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, when operating on views, the view and the parent object was modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'CoW triggers a copy when `df` is changed to avoid mutating `view` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '## Chained Assignment'
  prefs: []
  type: TYPE_NORMAL
- en: Chained assignment references a technique where an object is updated through
    two subsequent indexing operations, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The column `foo` is updated where the column `bar` is greater than 5. This
    violates the CoW principles though, because it would have to modify the view `df["foo"]`
    and `df` in one step. Hence, chained assignment will consistently never work and
    raise a `ChainedAssignmentError` warning with CoW enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With copy on write this can be done by using `loc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]  ## Read-only NumPy arrays'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing the underlying NumPy array of a DataFrame will return a read-only
    array if the array shares data with the initial DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The array is a copy if the initial DataFrame consists of more than one array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The array shares data with the DataFrame if the DataFrame consists of only
    one NumPy array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This array is read-only, which means that it can’t be modified inplace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The same holds true for a Series, since a Series always consists of a single
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two potential solution to this:'
  prefs: []
  type: TYPE_NORMAL
- en: Trigger a copy manually if you want to avoid updating DataFrames that share
    memory with your array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the array writeable. This is a more performant solution but circumvents
    Copy-on-Write rules, so it should be used with caution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Patterns to avoid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No defensive copy will be performed if two objects share the same data while
    you are modifying one object inplace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This creates two objects that share data and thus the setitem operation will
    trigger a copy. This is not necessary if the initial object `df` isn’t needed
    anymore. Simply reassigning to the same variable will invalidate the reference
    that is held by the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: No copy is necessary in this example. Creating multiple references keeps unnecessary
    references alive and thus will hurt performance with Copy-on-Write.
  prefs: []
  type: TYPE_NORMAL
- en: '## Copy-on-Write optimizations'
  prefs: []
  type: TYPE_NORMAL
- en: A new lazy copy mechanism that defers the copy until the object in question
    is modified and only if this object shares data with another object. This mechanism
    was added to methods that don’t require a copy of the underlying data. Popular
    examples are [`DataFrame.drop()`](../reference/api/pandas.DataFrame.drop.html#pandas.DataFrame.drop
    "pandas.DataFrame.drop") for `axis=1` and [`DataFrame.rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename").
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods return views when Copy-on-Write is enabled, which provides a
    significant performance improvement compared to the regular execution.  ## How
    to enable CoW'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy-on-Write can be enabled through the configuration option `copy_on_write`.
    The option can be turned on __globally__ through either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Previous behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'pandas indexing behavior is tricky to understand. Some operations return views
    while other return copies. Depending on the result of the operation, mutating
    one object might accidentally mutate another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Mutating `subset`, e.g. updating its values, also updates `df`. The exact behavior
    is hard to predict. Copy-on-Write solves accidentally modifying more than one
    object, it explicitly disallows this. With CoW enabled, `df` is unchanged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The following sections will explain what this means and how it impacts existing
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: '## Migrating to Copy-on-Write'
  prefs: []
  type: TYPE_NORMAL
- en: Copy-on-Write will be the default and only mode in pandas 3.0\. This means that
    users need to migrate their code to be compliant with CoW rules.
  prefs: []
  type: TYPE_NORMAL
- en: The default mode in pandas will raise warnings for certain cases that will actively
    change behavior and thus change user intended behavior.
  prefs: []
  type: TYPE_NORMAL
- en: We added another mode, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: that will warn for every operation that will change behavior with CoW. We expect
    this mode to be very noisy, since many cases that we don’t expect that they will
    influence users will also emit a warning. We recommend checking this mode and
    analyzing the warnings, but it is not necessary to address all of these warning.
    The first two items of the following lists are the only cases that need to be
    addressed to make existing code work with CoW.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following few items describe the user visible changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chained assignment will never work**'
  prefs: []
  type: TYPE_NORMAL
- en: '`loc` should be used as an alternative. Check the [chained assignment section](#copy-on-write-chained-assignment)
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessing the underlying array of a pandas object will return a read-only
    view**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example returns a NumPy array that is a view of the Series object. This
    view can be modified and thus also modify the pandas object. This is not compliant
    with CoW rules. The returned array is set to non-writeable to protect against
    this behavior. Creating a copy of this array allows modification. You can also
    make the array writeable again if you don’t care about the pandas object anymore.
  prefs: []
  type: TYPE_NORMAL
- en: See the section about [read-only NumPy arrays](#copy-on-write-read-only-na)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: '**Only one pandas object is updated at once**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet updates both `df` and `subset` without CoW:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This won’t be possible anymore with CoW, since the CoW rules explicitly forbid
    this. This includes updating a single column as a [`Series`](../reference/api/pandas.Series.html#pandas.Series
    "pandas.Series") and relying on the change propagating back to the parent [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame"). This statement can be rewritten into a single statement with
    `loc` or `iloc` if this behavior is necessary. [`DataFrame.where()`](../reference/api/pandas.DataFrame.where.html#pandas.DataFrame.where
    "pandas.DataFrame.where") is another suitable alternative for this case.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a column selected from a [`DataFrame`](../reference/api/pandas.DataFrame.html#pandas.DataFrame
    "pandas.DataFrame") with an inplace method will also not work anymore.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This is another form of chained assignment. This can generally be rewritten
    in 2 different forms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A different alternative would be to not use `inplace`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Constructors now copy NumPy arrays by default**'
  prefs: []
  type: TYPE_NORMAL
- en: The Series and DataFrame constructors will now copy NumPy array by default when
    not otherwise specified. This was changed to avoid mutating a pandas object when
    the NumPy array is changed inplace outside of pandas. You can set `copy=False`
    to avoid this copy.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CoW means that any DataFrame or Series derived from another in any way always
    behaves as a copy. As a consequence, we can only change the values of an object
    through modifying the object itself. CoW disallows updating a DataFrame or a Series
    that shares data with another DataFrame or Series object inplace.
  prefs: []
  type: TYPE_NORMAL
- en: This avoids side-effects when modifying values and hence, most methods can avoid
    actually copying the data and only trigger a copy when necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example will operate inplace with CoW:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The object `df` does not share any data with any other object and hence no
    copy is triggered when updating the values. In contrast, the following operation
    triggers a copy of the data under CoW:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`reset_index` returns a lazy copy with CoW while it copies the data without
    CoW. Since both objects, `df` and `df2` share the same data, a copy is triggered
    when modifying `df2`. The object `df` still has the same values as initially while
    `df2` was modified.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the object `df` isn’t needed anymore after performing the `reset_index`
    operation, you can emulate an inplace-like operation through assigning the output
    of `reset_index` to the same variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The initial object gets out of scope as soon as the result of `reset_index`
    is reassigned and hence `df` does not share data with any other object. No copy
    is necessary when modifying the object. This is generally true for all methods
    listed in [Copy-on-Write optimizations](#copy-on-write-optimizations).
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, when operating on views, the view and the parent object was modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'CoW triggers a copy when `df` is changed to avoid mutating `view` as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '## Chained Assignment'
  prefs: []
  type: TYPE_NORMAL
- en: Chained assignment references a technique where an object is updated through
    two subsequent indexing operations, e.g.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The column `foo` is updated where the column `bar` is greater than 5. This
    violates the CoW principles though, because it would have to modify the view `df["foo"]`
    and `df` in one step. Hence, chained assignment will consistently never work and
    raise a `ChainedAssignmentError` warning with CoW enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With copy on write this can be done by using `loc`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '## Read-only NumPy arrays'
  prefs: []
  type: TYPE_NORMAL
- en: 'Accessing the underlying NumPy array of a DataFrame will return a read-only
    array if the array shares data with the initial DataFrame:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The array is a copy if the initial DataFrame consists of more than one array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The array shares data with the DataFrame if the DataFrame consists of only
    one NumPy array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This array is read-only, which means that it can’t be modified inplace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The same holds true for a Series, since a Series always consists of a single
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two potential solution to this:'
  prefs: []
  type: TYPE_NORMAL
- en: Trigger a copy manually if you want to avoid updating DataFrames that share
    memory with your array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the array writeable. This is a more performant solution but circumvents
    Copy-on-Write rules, so it should be used with caution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Patterns to avoid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No defensive copy will be performed if two objects share the same data while
    you are modifying one object inplace.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This creates two objects that share data and thus the setitem operation will
    trigger a copy. This is not necessary if the initial object `df` isn’t needed
    anymore. Simply reassigning to the same variable will invalidate the reference
    that is held by the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: No copy is necessary in this example. Creating multiple references keeps unnecessary
    references alive and thus will hurt performance with Copy-on-Write.
  prefs: []
  type: TYPE_NORMAL
- en: '## Copy-on-Write optimizations'
  prefs: []
  type: TYPE_NORMAL
- en: A new lazy copy mechanism that defers the copy until the object in question
    is modified and only if this object shares data with another object. This mechanism
    was added to methods that don’t require a copy of the underlying data. Popular
    examples are [`DataFrame.drop()`](../reference/api/pandas.DataFrame.drop.html#pandas.DataFrame.drop
    "pandas.DataFrame.drop") for `axis=1` and [`DataFrame.rename()`](../reference/api/pandas.DataFrame.rename.html#pandas.DataFrame.rename
    "pandas.DataFrame.rename").
  prefs: []
  type: TYPE_NORMAL
- en: These methods return views when Copy-on-Write is enabled, which provides a significant
    performance improvement compared to the regular execution.
  prefs: []
  type: TYPE_NORMAL
- en: '## How to enable CoW'
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy-on-Write can be enabled through the configuration option `copy_on_write`.
    The option can be turned on __globally__ through either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
