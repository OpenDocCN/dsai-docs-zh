- en: Fourier Transforms (scipy.fft)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.scipy.org/doc/scipy-1.12.0/tutorial/fft.html](https://docs.scipy.org/doc/scipy-1.12.0/tutorial/fft.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Contents
  prefs: []
  type: TYPE_NORMAL
- en: '[Fourier Transforms (](#fourier-transforms-scipy-fft)[`scipy.fft`](../reference/fft.html#module-scipy.fft
    "scipy.fft"))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fast Fourier transforms](#fast-fourier-transforms)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[1-D discrete Fourier transforms](#d-discrete-fourier-transforms)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[2- and N-D discrete Fourier transforms](#and-n-d-discrete-fourier-transforms)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Discrete Cosine Transforms](#discrete-cosine-transforms)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type I DCT](#type-i-dct)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type II DCT](#type-ii-dct)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type III DCT](#type-iii-dct)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type IV DCT](#type-iv-dct)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DCT and IDCT](#dct-and-idct)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example](#example)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Discrete Sine Transforms](#discrete-sine-transforms)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type I DST](#type-i-dst)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type II DST](#type-ii-dst)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type III DST](#type-iii-dst)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Type IV DST](#type-iv-dst)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[DST and IDST](#dst-and-idst)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Fast Hankel Transform](#fast-hankel-transform)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[References](#references)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fourier analysis is a method for expressing a function as a sum of periodic
    components, and for recovering the signal from those components. When both the
    function and its Fourier transform are replaced with discretized counterparts,
    it is called the discrete Fourier transform (DFT). The DFT has become a mainstay
    of numerical computing in part because of a very fast algorithm for computing
    it, called the Fast Fourier Transform (FFT), which was known to Gauss (1805) and
    was brought to light in its current form by Cooley and Tukey [[CT65]](#ct65).
    Press et al. [[NR07]](#nr07) provide an accessible introduction to Fourier analysis
    and its applications.
  prefs: []
  type: TYPE_NORMAL
- en: '## [Fast Fourier transforms](#id11)'
  prefs: []
  type: TYPE_NORMAL
- en: '[1-D discrete Fourier transforms](#id12)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The FFT *y[k]* of length \(N\) of the length-\(N\) sequence *x[n]* is defined
    as
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = \sum_{n=0}^{N-1} e^{-2 \pi j \frac{k n}{N} } x[n] \, ,\]
  prefs: []
  type: TYPE_NORMAL
- en: and the inverse transform is defined as follows
  prefs: []
  type: TYPE_NORMAL
- en: \[x[n] = \frac{1}{N} \sum_{k=0}^{N-1} e^{2 \pi j \frac{k n}{N} } y[k] \, .\]
  prefs: []
  type: TYPE_NORMAL
- en: These transforms can be calculated by means of [`fft`](../reference/generated/scipy.fft.fft.html#scipy.fft.fft
    "scipy.fft.fft") and [`ifft`](../reference/generated/scipy.fft.ifft.html#scipy.fft.ifft
    "scipy.fft.ifft"), respectively, as shown in the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: From the definition of the FFT it can be seen that
  prefs: []
  type: TYPE_NORMAL
- en: \[y[0] = \sum_{n=0}^{N-1} x[n] \, .\]
  prefs: []
  type: TYPE_NORMAL
- en: In the example
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: which corresponds to \(y[0]\). For N even, the elements \(y[1]...y[N/2-1]\)
    contain the positive-frequency terms, and the elements \(y[N/2]...y[N-1]\) contain
    the negative-frequency terms, in order of decreasingly negative frequency. For
    N odd, the elements \(y[1]...y[(N-1)/2]\) contain the positive-frequency terms,
    and the elements \(y[(N+1)/2]...y[N-1]\) contain the negative-frequency terms,
    in order of decreasingly negative frequency.
  prefs: []
  type: TYPE_NORMAL
- en: In case the sequence x is real-valued, the values of \(y[n]\) for positive frequencies
    is the conjugate of the values \(y[n]\) for negative frequencies (because the
    spectrum is symmetric). Typically, only the FFT corresponding to positive frequencies
    is plotted.
  prefs: []
  type: TYPE_NORMAL
- en: The example plots the FFT of the sum of two sines.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '!["This code generates an X-Y plot showing amplitude on the Y axis vs frequency
    on the X axis. A single blue trace has an amplitude of zero all the way across
    with the exception of two peaks. The taller first peak is at 50 Hz with a second
    peak at 80 Hz."](../Images/805f438610f43a63ac427cb01f57d9a7.png)'
  prefs: []
  type: TYPE_IMG
- en: The FFT input signal is inherently truncated. This truncation can be modeled
    as multiplication of an infinite signal with a rectangular window function. In
    the spectral domain this multiplication becomes convolution of the signal spectrum
    with the window function spectrum, being of form \(\sin(x)/x\). This convolution
    is the cause of an effect called spectral leakage (see [[WPW]](#wpw)). Windowing
    the signal with a dedicated window function helps mitigate spectral leakage. The
    example below uses a Blackman window from scipy.signal and shows the effect of
    windowing (the zero component of the FFT has been truncated for illustrative purposes).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '!["This code generates an X-Y log-linear plot with amplitude on the Y axis
    vs frequency on the X axis. The first trace is the FFT with two peaks at 50 and
    80 Hz and a noise floor around an amplitude of 1e-2\. The second trace is the
    windowed FFT and has the same two peaks but the noise floor is much lower around
    an amplitude of 1e-7 due to the window function."](../Images/e7e633d9c6d5016d83f442b7117b7a1e.png)'
  prefs: []
  type: TYPE_IMG
- en: In case the sequence x is complex-valued, the spectrum is no longer symmetric.
    To simplify working with the FFT functions, scipy provides the following two helper
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: The function [`fftfreq`](../reference/generated/scipy.fft.fftfreq.html#scipy.fft.fftfreq
    "scipy.fft.fftfreq") returns the FFT sample frequency points.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In a similar spirit, the function [`fftshift`](../reference/generated/scipy.fft.fftshift.html#scipy.fft.fftshift
    "scipy.fft.fftshift") allows swapping the lower and upper halves of a vector,
    so that it becomes suitable for display.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The example below plots the FFT of two complex exponentials; note the asymmetric
    spectrum.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '!["This code generates an X-Y plot with amplitude on the Y axis vs frequency
    on the X axis. The trace is zero-valued across the plot except for two sharp peaks
    at -80 and 50 Hz. The 50 Hz peak on the right is twice as tall."](../Images/86cad2500ebb59d90c1c32f347e91b00.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The function [`rfft`](../reference/generated/scipy.fft.rfft.html#scipy.fft.rfft
    "scipy.fft.rfft") calculates the FFT of a real sequence and outputs the complex
    FFT coefficients \(y[n]\) for only half of the frequency range. The remaining
    negative frequency components are implied by the Hermitian symmetry of the FFT
    for a real input (`y[n] = conj(y[-n])`). In case of N being even: \([Re(y[0])
    + 0j, y[1], ..., Re(y[N/2]) + 0j]\); in case of N being odd \([Re(y[0]) + 0j,
    y[1], ..., y[N/2]\). The terms shown explicitly as \(Re(y[k]) + 0j\) are restricted
    to be purely real since, by the hermitian property, they are their own complex
    conjugate.'
  prefs: []
  type: TYPE_NORMAL
- en: The corresponding function [`irfft`](../reference/generated/scipy.fft.irfft.html#scipy.fft.irfft
    "scipy.fft.irfft") calculates the IFFT of the FFT coefficients with this special
    ordering.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the [`rfft`](../reference/generated/scipy.fft.rfft.html#scipy.fft.rfft
    "scipy.fft.rfft") of odd and even length signals are of the same shape. By default,
    [`irfft`](../reference/generated/scipy.fft.irfft.html#scipy.fft.irfft "scipy.fft.irfft")
    assumes the output signal should be of even length. And so, for odd signals, it
    will give the wrong result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To recover the original odd-length signal, we **must** pass the output shape
    by the *n* parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[2- and N-D discrete Fourier transforms](#id13)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The functions [`fft2`](../reference/generated/scipy.fft.fft2.html#scipy.fft.fft2
    "scipy.fft.fft2") and [`ifft2`](../reference/generated/scipy.fft.ifft2.html#scipy.fft.ifft2
    "scipy.fft.ifft2") provide 2-D FFT and IFFT, respectively. Similarly, [`fftn`](../reference/generated/scipy.fft.fftn.html#scipy.fft.fftn
    "scipy.fft.fftn") and [`ifftn`](../reference/generated/scipy.fft.ifftn.html#scipy.fft.ifftn
    "scipy.fft.ifftn") provide N-D FFT, and IFFT, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: For real-input signals, similarly to [`rfft`](../reference/generated/scipy.fft.rfft.html#scipy.fft.rfft
    "scipy.fft.rfft"), we have the functions [`rfft2`](../reference/generated/scipy.fft.rfft2.html#scipy.fft.rfft2
    "scipy.fft.rfft2") and [`irfft2`](../reference/generated/scipy.fft.irfft2.html#scipy.fft.irfft2
    "scipy.fft.irfft2") for 2-D real transforms; [`rfftn`](../reference/generated/scipy.fft.rfftn.html#scipy.fft.rfftn
    "scipy.fft.rfftn") and [`irfftn`](../reference/generated/scipy.fft.irfftn.html#scipy.fft.irfftn
    "scipy.fft.irfftn") for N-D real transforms.
  prefs: []
  type: TYPE_NORMAL
- en: The example below demonstrates a 2-D IFFT and plots the resulting (2-D) time-domain
    signals.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '!["This code generates six heatmaps arranged in a 2x3 grid. The top row shows
    mostly blank canvases with the exception of two tiny red peaks on each image.
    The bottom row shows the real-part of the inverse FFT of each image above it.
    The first column has two dots arranged horizontally in the top image and in the
    bottom image a smooth grayscale plot of 5 black vertical stripes representing
    the 2-D time domain signal. The second column has two dots arranged vertically
    in the top image and in the bottom image a smooth grayscale plot of 5 horizontal
    black stripes representing the 2-D time domain signal. In the last column the
    top image has two dots diagonally located; the corresponding image below has perhaps
    20 black stripes at a 60 degree angle."](../Images/5be40428f3d653ccecce1631fbe54705.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Discrete Cosine Transforms](#id14)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SciPy provides a DCT with the function [`dct`](../reference/generated/scipy.fft.dct.html#scipy.fft.dct
    "scipy.fft.dct") and a corresponding IDCT with the function [`idct`](../reference/generated/scipy.fft.idct.html#scipy.fft.idct
    "scipy.fft.idct"). There are 8 types of the DCT [[WPC]](#wpc), [[Mak]](#mak);
    however, only the first 4 types are implemented in scipy. “The” DCT generally
    refers to DCT type 2, and “the” Inverse DCT generally refers to DCT type 3\. In
    addition, the DCT coefficients can be normalized differently (for most types,
    scipy provides `None` and `ortho`). Two parameters of the dct/idct function calls
    allow setting the DCT type and coefficient normalization.
  prefs: []
  type: TYPE_NORMAL
- en: For a single dimension array x, dct(x, norm=’ortho’) is equal to MATLAB dct(x).
  prefs: []
  type: TYPE_NORMAL
- en: '[Type I DCT](#id15)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SciPy uses the following definition of the unnormalized DCT-I (`norm=None`):'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = x_0 + (-1)^k x_{N-1} + 2\sum_{n=1}^{N-2} x[n] \cos\left(\frac{\pi nk}{N-1}\right),
    \qquad 0 \le k < N.\]
  prefs: []
  type: TYPE_NORMAL
- en: Note that the DCT-I is only supported for input size > 1.
  prefs: []
  type: TYPE_NORMAL
- en: '[Type II DCT](#id16)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SciPy uses the following definition of the unnormalized DCT-II (`norm=None`):'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \cos \left({\pi(2n+1)k \over 2N} \right) \qquad
    0 \le k < N.\]
  prefs: []
  type: TYPE_NORMAL
- en: 'In case of the normalized DCT (`norm=''ortho''`), the DCT coefficients \(y[k]\)
    are multiplied by a scaling factor *f*:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}f = \begin{cases} \sqrt{1/(4N)}, & \text{if $k = 0$} \\ \sqrt{1/(2N)},
    & \text{otherwise} \end{cases} \, .\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the DCT “base functions” \(\phi_k[n] = 2 f \cos \left({\pi(2n+1)k
    \over 2N} \right)\) become orthonormal:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\sum_{n=0}^{N-1} \phi_k[n] \phi_l[n] = \delta_{lk}.\]
  prefs: []
  type: TYPE_NORMAL
- en: '[Type III DCT](#id17)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SciPy uses the following definition of the unnormalized DCT-III (`norm=None`):'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = x_0 + 2 \sum_{n=1}^{N-1} x[n] \cos\left({\pi n(2k+1) \over 2N}\right)
    \qquad 0 \le k < N,\]
  prefs: []
  type: TYPE_NORMAL
- en: 'or, for `norm=''ortho''`:'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = {x_0\over\sqrt{N}} + {2\over\sqrt{N}} \sum_{n=1}^{N-1} x[n] \cos\left({\pi
    n(2k+1) \over 2N}\right) \qquad 0 \le k < N.\]
  prefs: []
  type: TYPE_NORMAL
- en: '[Type IV DCT](#id18)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SciPy uses the following definition of the unnormalized DCT-IV (`norm=None`):'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \cos\left({\pi (2n+1)(2k+1) \over 4N}\right)
    \qquad 0 \le k < N,\]
  prefs: []
  type: TYPE_NORMAL
- en: 'or, for `norm=''ortho''`:'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = \sqrt{2\over N}\sum_{n=0}^{N-1} x[n] \cos\left({\pi (2n+1)(2k+1) \over
    4N}\right) \qquad 0 \le k < N\]
  prefs: []
  type: TYPE_NORMAL
- en: '[DCT and IDCT](#id19)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The (unnormalized) DCT-III is the inverse of the (unnormalized) DCT-II, up to
    a factor of *2N*. The orthonormalized DCT-III is exactly the inverse of the orthonormalized
    DCT- II. The function [`idct`](../reference/generated/scipy.fft.idct.html#scipy.fft.idct
    "scipy.fft.idct") performs the mappings between the DCT and IDCT types, as well
    as the correct normalization.
  prefs: []
  type: TYPE_NORMAL
- en: The following example shows the relation between DCT and IDCT for different
    types and normalizations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The DCT-II and DCT-III are each other’s inverses, so for an orthonormal transform
    we return back to the original signal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Doing the same under default normalization, however, we pick up an extra scaling
    factor of \(2N=10\) since the forward transform is unnormalized.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For this reason, we should use the function [`idct`](../reference/generated/scipy.fft.idct.html#scipy.fft.idct
    "scipy.fft.idct") using the same type for both, giving a correctly normalized
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Analogous results can be seen for the DCT-I, which is its own inverse up to
    a factor of \(2(N-1)\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And for the DCT-IV, which is also its own inverse up to a factor of \(2N\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Example](#id20)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DCT exhibits the “energy compaction property”, meaning that for many signals
    only the first few DCT coefficients have significant magnitude. Zeroing out the
    other coefficients leads to a small reconstruction error, a fact which is exploited
    in lossy signal compression (e.g. JPEG compression).
  prefs: []
  type: TYPE_NORMAL
- en: The example below shows a signal x and two reconstructions (\(x_{20}\) and \(x_{15}\))
    from the signal’s DCT coefficients. The signal \(x_{20}\) is reconstructed from
    the first 20 DCT coefficients, \(x_{15}\) is reconstructed from the first 15 DCT
    coefficients. It can be seen that the relative error of using 20 coefficients
    is still very small (~0.1%), but provides a five-fold compression rate.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '!["This code generates an X-Y plot showing amplitude on the Y axis and time
    on the X axis. The first blue trace is the original signal and starts at amplitude
    1 and oscillates down to 0 amplitude over the duration of the plot resembling
    a frequency chirp. The second red trace is the x_20 reconstruction using the DCT
    and closely follows the original signal in the high amplitude region but it is
    unclear to the right side of the plot. The third green trace is the x_15 reconstruction
    using the DCT and is less precise than the x_20 reconstruction but still similar
    to x."](../Images/77d374115738777155f029ee6a65cd4a.png)'
  prefs: []
  type: TYPE_IMG
- en: '[Discrete Sine Transforms](#id21)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SciPy provides a DST [[Mak]](#mak) with the function [`dst`](../reference/generated/scipy.fft.dst.html#scipy.fft.dst
    "scipy.fft.dst") and a corresponding IDST with the function [`idst`](../reference/generated/scipy.fft.idst.html#scipy.fft.idst
    "scipy.fft.idst").
  prefs: []
  type: TYPE_NORMAL
- en: There are, theoretically, 8 types of the DST for different combinations of even/odd
    boundary conditions and boundary offsets [[WPS]](#wps), only the first 4 types
    are implemented in scipy.
  prefs: []
  type: TYPE_NORMAL
- en: '[Type I DST](#id22)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DST-I assumes the input is odd around n=-1 and n=N. SciPy uses the following
    definition of the unnormalized DST-I (`norm=None`):'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = 2\sum_{n=0}^{N-1} x[n] \sin\left( \pi {(n+1) (k+1)}\over{N+1} \right),
    \qquad 0 \le k < N.\]
  prefs: []
  type: TYPE_NORMAL
- en: Note also that the DST-I is only supported for input size > 1\. The (unnormalized)
    DST-I is its own inverse, up to a factor of *2(N+1)*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Type II DST](#id23)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DST-II assumes the input is odd around n=-1/2 and even around n=N. SciPy uses
    the following definition of the unnormalized DST-II (`norm=None`):'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \sin\left( {\pi (n+1/2)(k+1)} \over N \right),
    \qquad 0 \le k < N.\]
  prefs: []
  type: TYPE_NORMAL
- en: '[Type III DST](#id24)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'DST-III assumes the input is odd around n=-1 and even around n=N-1\. SciPy
    uses the following definition of the unnormalized DST-III (`norm=None`):'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = (-1)^k x[N-1] + 2 \sum_{n=0}^{N-2} x[n] \sin \left( {\pi (n+1)(k+1/2)}
    \over N \right), \qquad 0 \le k < N.\]
  prefs: []
  type: TYPE_NORMAL
- en: '[Type IV DST](#id25)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SciPy uses the following definition of the unnormalized DST-IV (`norm=None`):'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = 2 \sum_{n=0}^{N-1} x[n] \sin\left({\pi (2n+1)(2k+1) \over 4N}\right)
    \qquad 0 \le k < N,\]
  prefs: []
  type: TYPE_NORMAL
- en: 'or, for `norm=''ortho''`:'
  prefs: []
  type: TYPE_NORMAL
- en: \[y[k] = \sqrt{2\over N}\sum_{n=0}^{N-1} x[n] \sin\left({\pi (2n+1)(2k+1) \over
    4N}\right) \qquad 0 \le k < N,\]
  prefs: []
  type: TYPE_NORMAL
- en: '[DST and IDST](#id26)'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following example shows the relation between DST and IDST for different
    types and normalizations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The DST-II and DST-III are each other’s inverses, so for an orthonormal transform
    we return back to the original signal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Doing the same under default normalization, however, we pick up an extra scaling
    factor of \(2N=10\) since the forward transform is unnormalized.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For this reason, we should use the function [`idst`](../reference/generated/scipy.fft.idst.html#scipy.fft.idst
    "scipy.fft.idst") using the same type for both, giving a correctly normalized
    result.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Analogous results can be seen for the DST-I, which is its own inverse up to
    a factor of \(2(N-1)\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: And for the DST-IV, which is also its own inverse up to a factor of \(2N\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[Fast Hankel Transform](#id27)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SciPy provides the functions `fht` and `ifht` to perform the Fast Hankel Transform
    (FHT) and its inverse (IFHT) on logarithmically-spaced input arrays.
  prefs: []
  type: TYPE_NORMAL
- en: The FHT is the discretised version of the continuous Hankel transform defined
    by [[Ham00]](#ham00)
  prefs: []
  type: TYPE_NORMAL
- en: \[A(k) = \int_{0}^{\infty} \! a(r) \, J_{\mu}(kr) \, k \, dr \;,\]
  prefs: []
  type: TYPE_NORMAL
- en: with \(J_{\mu}\) the Bessel function of order \(\mu\). Under a change of variables
    \(r \to \log r\), \(k \to \log k\), this becomes
  prefs: []
  type: TYPE_NORMAL
- en: \[A(e^{\log k}) = \int_{0}^{\infty} \! a(e^{\log r}) \, J_{\mu}(e^{\log k +
    \log r}) \, e^{\log k + \log r} \, d{\log r}\]
  prefs: []
  type: TYPE_NORMAL
- en: which is a convolution in logarithmic space. The FHT algorithm uses the FFT
    to perform this convolution on discrete input data.
  prefs: []
  type: TYPE_NORMAL
- en: Care must be taken to minimise numerical ringing due to the circular nature
    of FFT convolution. To ensure that the low-ringing condition [[Ham00]](#ham00)
    holds, the output array can be slightly shifted by an offset computed using the
    `fhtoffset` function.
  prefs: []
  type: TYPE_NORMAL
- en: '[References](#id28)'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[[CT65](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cooley, James W., and John W. Tukey, 1965, “An algorithm for the machine calculation
    of complex Fourier series,” *Math. Comput.* 19: 297-301.'
  prefs: []
  type: TYPE_NORMAL
- en: '[[NR07](#id2)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Press, W., Teukolsky, S., Vetterline, W.T., and Flannery, B.P., 2007, *Numerical
    Recipes: The Art of Scientific Computing*, ch. 12-13\. Cambridge Univ. Press,
    Cambridge, UK.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mak] ([1](#id5),[2](#id6))'
  prefs: []
  type: TYPE_NORMAL
- en: J. Makhoul, 1980, ‘A Fast Cosine Transform in One and Two Dimensions’, *IEEE
    Transactions on acoustics, speech and signal processing* vol. 28(1), pp. 27-34,
    [DOI:10.1109/TASSP.1980.1163351](https://doi.org/10.1109/TASSP.1980.1163351)
  prefs: []
  type: TYPE_NORMAL
- en: '[Ham00] ([1](#id8),[2](#id9))'
  prefs: []
  type: TYPE_NORMAL
- en: A. J. S. Hamilton, 2000, “Uncorrelated modes of the non-linear power spectrum”,
    *MNRAS*, 312, 257\. [DOI:10.1046/j.1365-8711.2000.03071.x](https://doi.org/10.1046/j.1365-8711.2000.03071.x)
  prefs: []
  type: TYPE_NORMAL
- en: '[[WPW](#id3)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Window_function](https://en.wikipedia.org/wiki/Window_function)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[WPC](#id4)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Discrete_cosine_transform](https://en.wikipedia.org/wiki/Discrete_cosine_transform)'
  prefs: []
  type: TYPE_NORMAL
- en: '[[WPS](#id7)]'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Discrete_sine_transform](https://en.wikipedia.org/wiki/Discrete_sine_transform)'
  prefs: []
  type: TYPE_NORMAL
