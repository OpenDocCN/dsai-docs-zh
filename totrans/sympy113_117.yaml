- en: Matrix Expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sympy.org/latest/modules/matrices/expressions.html](https://docs.sympy.org/latest/modules/matrices/expressions.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The Matrix expression module allows users to write down statements like
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: where `X` and `Y` are [`MatrixSymbol`](#sympy.matrices.expressions.MatrixSymbol
    "sympy.matrices.expressions.MatrixSymbol")’s rather than scalar symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrix expression derivatives are supported. The derivative of a matrix by
    another matrix is generally a 4-dimensional array, but if some dimensions are
    trivial or diagonal, the derivation algorithm will try to express the result as
    a matrix expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The last output is an array expression, as the returned symbol is 4-dimensional.
  prefs: []
  type: TYPE_NORMAL
- en: Matrix Expressions Core Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Superclass for Matrix Expressions
  prefs: []
  type: TYPE_NORMAL
- en: MatrixExprs represent abstract matrices, linear transformations represented
    within a particular basis.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`MatrixSymbol`](#sympy.matrices.expressions.MatrixSymbol "sympy.matrices.expressions.MatrixSymbol"),
    [`MatAdd`](#sympy.matrices.expressions.MatAdd "sympy.matrices.expressions.MatAdd"),
    [`MatMul`](#sympy.matrices.expressions.MatMul "sympy.matrices.expressions.MatMul"),
    [`Transpose`](#sympy.matrices.expressions.Transpose "sympy.matrices.expressions.Transpose"),
    [`Inverse`](#sympy.matrices.expressions.Inverse "sympy.matrices.expressions.Inverse")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Matrix transposition
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Efficiently extract the coefficient of a product.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Returns a dense Matrix with elements represented explicitly
  prefs: []
  type: TYPE_NORMAL
- en: Returns an object of type ImmutableDenseMatrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_mutable`](#sympy.matrices.expressions.MatrixExpr.as_mutable "sympy.matrices.expressions.MatrixExpr.as_mutable")'
  prefs: []
  type: TYPE_NORMAL
- en: returns mutable Matrix type
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Returns a dense, mutable matrix with elements represented explicitly
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`as_explicit`](#sympy.matrices.expressions.MatrixExpr.as_explicit "sympy.matrices.expressions.MatrixExpr.as_explicit")'
  prefs: []
  type: TYPE_NORMAL
- en: returns ImmutableDenseMatrix
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Test elementwise equality between matrices, potentially of different types
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Parse expression of matrices with explicitly summed indices into a matrix expression
    without indices, if possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'This transformation expressed in mathematical notation:'
  prefs: []
  type: TYPE_NORMAL
- en: \(\sum_{j=0}^{N-1} A_{i,j} B_{j,k} \Longrightarrow \mathbf{A}\cdot \mathbf{B}\)
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional parameter `first_index`: specify which free index to use as the index
    starting the expression.'
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Transposition is detected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Detect the trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'More complicated expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Symbolic representation of a Matrix object
  prefs: []
  type: TYPE_NORMAL
- en: Creates a SymPy Symbol to represent a Matrix. This matrix has a shape and can
    be included in Matrix Expressions
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: A Sum of Matrix Expressions
  prefs: []
  type: TYPE_NORMAL
- en: MatAdd inherits from and operates like SymPy Add
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A product of matrix expressions
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Return the elementwise (aka Hadamard) product of matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Elementwise product of matrix expressions
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Hadamard product for matrix symbols:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This is a symbolic object that simply stores its argument without evaluating
    it. To actually compute the product, use the function `hadamard_product()` or
    `HadamardProduct.doit`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Elementwise power of matrix expressions
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**base** : scalar or matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '**exp** : scalar or matrix'
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: There are four definitions for the hadamard power which can be used. Let’s consider
    \(A, B\) as \((m, n)\) matrices, and \(a, b\) as scalars.
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrix raised to a scalar exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}A^{\circ b} = \begin{bmatrix} A_{0, 0}^b & A_{0, 1}^b & \cdots
    & A_{0, n-1}^b \\ A_{1, 0}^b & A_{1, 1}^b & \cdots & A_{1, n-1}^b \\ \vdots &
    \vdots & \ddots & \vdots \\ A_{m-1, 0}^b & A_{m-1, 1}^b & \cdots & A_{m-1, n-1}^b
    \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalar raised to a matrix exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}a^{\circ B} = \begin{bmatrix} a^{B_{0, 0}} & a^{B_{0, 1}} & \cdots
    & a^{B_{0, n-1}} \\ a^{B_{1, 0}} & a^{B_{1, 1}} & \cdots & a^{B_{1, n-1}} \\ \vdots
    & \vdots & \ddots & \vdots \\ a^{B_{m-1, 0}} & a^{B_{m-1, 1}} & \cdots & a^{B_{m-1,
    n-1}} \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Matrix raised to a matrix exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: \[\begin{split}A^{\circ B} = \begin{bmatrix} A_{0, 0}^{B_{0, 0}} & A_{0, 1}^{B_{0,
    1}} & \cdots & A_{0, n-1}^{B_{0, n-1}} \\ A_{1, 0}^{B_{1, 0}} & A_{1, 1}^{B_{1,
    1}} & \cdots & A_{1, n-1}^{B_{1, n-1}} \\ \vdots & \vdots & \ddots & \vdots \\
    A_{m-1, 0}^{B_{m-1, 0}} & A_{m-1, 1}^{B_{m-1, 1}} & \cdots & A_{m-1, n-1}^{B_{m-1,
    n-1}} \end{bmatrix}\end{split}\]
  prefs: []
  type: TYPE_NORMAL
- en: 'Scalar raised to a scalar exponent:'
  prefs: []
  type: TYPE_NORMAL
- en: \[a^{\circ b} = a^b\]
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The multiplicative inverse of a matrix expression
  prefs: []
  type: TYPE_NORMAL
- en: This is a symbolic object that simply stores its argument without evaluating
    it. To actually compute the inverse, use the `.inverse()` method of matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The transpose of a matrix expression.
  prefs: []
  type: TYPE_NORMAL
- en: This is a symbolic object that simply stores its argument without evaluating
    it. To actually compute the transpose, use the `transpose()` function, or the
    `.T` attribute of matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Matrix Trace
  prefs: []
  type: TYPE_NORMAL
- en: Represents the trace of a matrix expression.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Represents a matrix using a function (`Lambda`) which gives outputs according
    to the coordinates of each matrix entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**rows** : nonnegative integer. Can be symbolic.'
  prefs: []
  type: TYPE_NORMAL
- en: '**cols** : nonnegative integer. Can be symbolic.'
  prefs: []
  type: TYPE_NORMAL
- en: '**lamda** : Function, Lambda or str'
  prefs: []
  type: TYPE_NORMAL
- en: If it is a SymPy `Function` or `Lambda` instance, it should be able to accept
    two arguments which represents the matrix coordinates.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If it is a pure string containing Python `lambda` semantics, it is interpreted
    by the SymPy parser and casted into a SymPy `Lambda` instance.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a `FunctionMatrix` from `Lambda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a `FunctionMatrix` from a SymPy function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a `FunctionMatrix` from a SymPy undefined function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a `FunctionMatrix` from Python `lambda`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Example of lazy evaluation of matrix product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This class provides an alternative way to represent an extremely dense matrix
    with entries in some form of a sequence, in a most sparse way.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: A Permutation Matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**perm** : Permutation'
  prefs: []
  type: TYPE_NORMAL
- en: The permutation the matrix uses.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The size of the permutation determines the matrix size.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: See the documentation of [`sympy.combinatorics.permutations.Permutation`](../combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation
    "sympy.combinatorics.permutations.Permutation") for the further information of
    how to create a permutation object.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a permutation matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Permuting a matrix row and column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.combinatorics.permutations.Permutation`](../combinatorics/permutations.html#sympy.combinatorics.permutations.Permutation
    "sympy.combinatorics.permutations.Permutation")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Symbolic representation for permuting matrix rows or columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**perm** : Permutation, PermutationMatrix'
  prefs: []
  type: TYPE_NORMAL
- en: The permutation to use for permuting the matrix. The permutation can be resized
    to the suitable one,
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**axis** : 0 or 1'
  prefs: []
  type: TYPE_NORMAL
- en: The axis to permute alongside. If \(0\), it will permute the matrix rows. If
    \(1\), it will permute the matrix columns.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: This follows the same notation used in [`sympy.matrices.matrixbase.MatrixBase.permute()`](matrices.html#sympy.matrices.matrixbase.MatrixBase.permute
    "sympy.matrices.matrixbase.MatrixBase.permute").
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Permuting the matrix rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Permuting the matrix columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.permute`](matrices.html#sympy.matrices.matrixbase.MatrixBase.permute
    "sympy.matrices.matrixbase.MatrixBase.permute")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The Matrix Identity I - multiplicative identity
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The Matrix Zero 0 - additive identity
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: A symbolic companion matrix of a polynomial.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: MatrixSet represents the set of matrices with `shape = (n, m)` over the given
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Block Matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Block matrices allow you to construct larger matrices out of smaller sub-blocks.
    They can work with [`MatrixExpr`](#sympy.matrices.expressions.MatrixExpr "sympy.matrices.expressions.MatrixExpr")
    or [`ImmutableMatrix`](immutablematrices.html#sympy.matrices.immutable.ImmutableMatrix
    "sympy.matrices.immutable.ImmutableMatrix") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: A BlockMatrix is a Matrix comprised of other matrices.
  prefs: []
  type: TYPE_NORMAL
- en: The submatrices are stored in a SymPy Matrix object but accessed as part of
    a Matrix Expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Some matrices might be comprised of rows of blocks with the matrices in each
    row having the same height and the rows all having the same total number of columns
    but not having the same number of columns for each matrix in each row. In this
    case, the matrix is not a block matrix and should be instantiated by Matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.irregular`](matrices.html#sympy.matrices.matrixbase.MatrixBase.irregular
    "sympy.matrices.matrixbase.MatrixBase.irregular")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Returns the Block LDU decomposition of a 2x2 Block Matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(L, D, U)** : Matrices'
  prefs: []
  type: TYPE_NORMAL
- en: 'L : Lower Diagonal Matrix D : Diagonal Matrix U : Upper Diagonal Matrix'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ShapeError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the block matrix is not a 2x2 matrix
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**NonInvertibleMatrixError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the matrix “A” is non-invertible
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition`](#sympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition
    "sympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition"), [`sympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition`](#sympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition
    "sympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Returns the Block LU decomposition of a 2x2 Block Matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(L, U)** : Matrices'
  prefs: []
  type: TYPE_NORMAL
- en: 'L : Lower Diagonal Matrix U : Upper Diagonal Matrix'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ShapeError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the block matrix is not a 2x2 matrix
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**NonInvertibleMatrixError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the matrix “A” is non-invertible
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition`](#sympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition
    "sympy.matrices.expressions.blockmatrix.BlockMatrix.UDLdecomposition"), [`sympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition`](#sympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition
    "sympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Returns the Block UDL decomposition of a 2x2 Block Matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**(U, D, L)** : Matrices'
  prefs: []
  type: TYPE_NORMAL
- en: 'U : Upper Diagonal Matrix D : Diagonal Matrix L : Lower Diagonal Matrix'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ShapeError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the block matrix is not a 2x2 matrix
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**NonInvertibleMatrixError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the matrix “D” is non-invertible
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition`](#sympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition
    "sympy.matrices.expressions.blockmatrix.BlockMatrix.LDUdecomposition"), [`sympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition`](#sympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition
    "sympy.matrices.expressions.blockmatrix.BlockMatrix.LUdecomposition")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Return the Schur Complement of the 2x2 BlockMatrix
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**mat** : String, optional'
  prefs: []
  type: TYPE_NORMAL
- en: The matrix with respect to which the Schur Complement is calculated. ‘A’ is
    used by default
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**generalized** : bool, optional'
  prefs: []
  type: TYPE_NORMAL
- en: If True, returns the generalized Schur Component which uses Moore-Penrose Inverse
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**M** : Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: The Schur Complement Matrix
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ShapeError**'
  prefs: []
  type: TYPE_NORMAL
- en: If the block matrix is not a 2x2 matrix
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**NonInvertibleMatrixError**'
  prefs: []
  type: TYPE_NORMAL
- en: If given matrix is non-invertible
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: The default Schur Complement is evaluated with “A”
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Schur complement with non-invertible matrices is not defined. Instead, the generalized
    Schur complement can be calculated which uses the Moore-Penrose Inverse. To achieve
    this, \(generalized\) must be set to \(True\)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.matrixbase.MatrixBase.pinv`](matrices.html#sympy.matrices.matrixbase.MatrixBase.pinv
    "sympy.matrices.matrixbase.MatrixBase.pinv")'
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs: []
  type: TYPE_NORMAL
- en: '[[R608](#id1)]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Wikipedia Article on Schur Component : [https://en.wikipedia.org/wiki/Schur_complement](https://en.wikipedia.org/wiki/Schur_complement)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Return transpose of matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: A sparse matrix with block matrices along its diagonals
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get the individual diagonal blocks, use [`get_diag_blocks()`](#sympy.matrices.expressions.blockmatrix.BlockDiagMatrix.get_diag_blocks
    "sympy.matrices.expressions.blockmatrix.BlockDiagMatrix.get_diag_blocks").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sympy.matrices.dense.diag`](matrices.html#sympy.matrices.dense.diag "sympy.matrices.dense.diag")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Return the list of diagonal blocks of the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'How to get diagonal blocks from the block diagonal matrix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Evaluates a block matrix expression
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
