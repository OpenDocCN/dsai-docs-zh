- en: numpy.linalg.lstsq
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://numpy.org/doc/1.26/reference/generated/numpy.linalg.lstsq.html](https://numpy.org/doc/1.26/reference/generated/numpy.linalg.lstsq.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Return the least-squares solution to a linear matrix equation.
  prefs: []
  type: TYPE_NORMAL
- en: Computes the vector *x* that approximately solves the equation `a @ x = b`.
    The equation may be under-, well-, or over-determined (i.e., the number of linearly
    independent rows of *a* can be less than, equal to, or greater than its number
    of linearly independent columns). If *a* is square and of full rank, then *x*
    (but for round-off error) is the “exact” solution of the equation. Else, *x* minimizes
    the Euclidean 2-norm \(||b - ax||\). If there are multiple minimizing solutions,
    the one with the smallest 2-norm \(||x||\) is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**a**(M, N) array_like'
  prefs: []
  type: TYPE_NORMAL
- en: “Coefficient” matrix.
  prefs: []
  type: TYPE_NORMAL
- en: '**b**{(M,), (M, K)} array_like'
  prefs: []
  type: TYPE_NORMAL
- en: Ordinate or “dependent variable” values. If *b* is two-dimensional, the least-squares
    solution is calculated for each of the *K* columns of *b*.
  prefs: []
  type: TYPE_NORMAL
- en: '**rcond**float, optional'
  prefs: []
  type: TYPE_NORMAL
- en: Cut-off ratio for small singular values of *a*. For the purposes of rank determination,
    singular values are treated as zero if they are smaller than *rcond* times the
    largest singular value of *a*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.14.0: If not set, a FutureWarning is given. The previous
    default of `-1` will use the machine precision as *rcond* parameter, the new default
    will use the machine precision times *max(M, N)*. To silence the warning and use
    the new default, use `rcond=None`, to keep using the old behavior, use `rcond=-1`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x**{(N,), (N, K)} ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Least-squares solution. If *b* is two-dimensional, the solutions are in the
    *K* columns of *x*.
  prefs: []
  type: TYPE_NORMAL
- en: '**residuals**{(1,), (K,), (0,)} ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sums of squared residuals: Squared Euclidean 2-norm for each column in `b -
    a @ x`. If the rank of *a* is < N or M <= N, this is an empty array. If *b* is
    1-dimensional, this is a (1,) shape array. Otherwise the shape is (K,).'
  prefs: []
  type: TYPE_NORMAL
- en: '**rank**int'
  prefs: []
  type: TYPE_NORMAL
- en: Rank of matrix *a*.
  prefs: []
  type: TYPE_NORMAL
- en: '**s**(min(M, N),) ndarray'
  prefs: []
  type: TYPE_NORMAL
- en: Singular values of *a*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: LinAlgError
  prefs: []
  type: TYPE_NORMAL
- en: If computation does not converge.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`scipy.linalg.lstsq`](https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.lstsq.html#scipy.linalg.lstsq
    "(in SciPy v1.11.2)")'
  prefs: []
  type: TYPE_NORMAL
- en: Similar function in SciPy.
  prefs: []
  type: TYPE_NORMAL
- en: Notes
  prefs: []
  type: TYPE_NORMAL
- en: If *b* is a matrix, then all array results are returned as matrices.
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs: []
  type: TYPE_NORMAL
- en: 'Fit a line, `y = mx + c`, through some noisy data-points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: By examining the coefficients, we see that the line should have a gradient of
    roughly 1 and cut the y-axis at, more or less, -1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the line equation as `y = Ap`, where `A = [[x 1]]` and `p =
    [[m], [c]]`. Now use [`lstsq`](#numpy.linalg.lstsq "numpy.linalg.lstsq") to solve
    for *p*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Plot the data along with the fitted line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![../../_images/numpy-linalg-lstsq-1.png](../Images/59258e6fdac54ae81ea662ff5b15f2c0.png)'
  prefs: []
  type: TYPE_IMG
